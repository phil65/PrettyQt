{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"prettyqt: Pythonic layer on top of PyQt5 / PySide2 What is it? PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PySide2. Main Features Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module. Where to get it The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt Dependencies qtpy qtawesome bidict orjson regex docutils Installation from sources This project uses poetry for dependency management and packaging. Install this first. In the prettyqt directory (same one where you found this file after cloning the git repo), execute: poetry install License MIT Documentation The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/ Contributing to pandas All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Home"},{"location":"index.html#prettyqt-pythonic-layer-on-top-of-pyqt5-pyside2","text":"","title":"prettyqt: Pythonic layer on top of PyQt5 / PySide2"},{"location":"index.html#what-is-it","text":"PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PySide2.","title":"What is it?"},{"location":"index.html#main-features","text":"Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module.","title":"Main Features"},{"location":"index.html#where-to-get-it","text":"The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt","title":"Where to get it"},{"location":"index.html#dependencies","text":"qtpy qtawesome bidict orjson regex docutils","title":"Dependencies"},{"location":"index.html#installation-from-sources","text":"This project uses poetry for dependency management and packaging. Install this first. In the prettyqt directory (same one where you found this file after cloning the git repo), execute: poetry install","title":"Installation from sources"},{"location":"index.html#license","text":"MIT","title":"License"},{"location":"index.html#documentation","text":"The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/","title":"Documentation"},{"location":"index.html#contributing-to-pandas","text":"All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Contributing to pandas"},{"location":"changelog.html","text":"v0.126.0 (2020-10-08) Feat core : add Process class DateTime : add get/set_time_spec and get_date/time methods core : add Time class DateTime : add timezone methods core : add TimeZone class Pixmap : add create_dot classmethod v0.125.1 (2020-10-07) Fix import fix v0.125.0 (2020-10-07) Feat widgets : add Transition classes core : add Transition classes Fix fix Action.get_shortcut for NoneValue v0.124.0 (2020-10-05) Feat IODevice : add get_open_mode method Improve repr and add str method for Date and DateTime core : add TemporaryFile class FileDevice : add set/get_file_time methods MainWindow : allow setting central widget to None AbstractButton : add get_shortcut method Url : add from_user_input method WebEngineView : add get_url method FileInfo : support pathlib + add proper repr KeySequence : allow initializing with standard keys v0.123.1 (2020-09-29) Fix add missing State import in core module v0.123.0 (2020-09-29) Feat core : add State classes core : add TextBoundaryFinder class ProgressBar : add get/set_orientation methods + serialize work Action : allow setting callback with ctor WebEngineView : set subclassed WebEnginePage by default WebEnginePage : add some more methods and constants AbstractSlider : add get/set_orientation methods core : add FileInfo class webenginewidgets : add WebEngineProfile class v0.122.1 (2020-09-27) Fix use correct icon names v0.122.0 (2020-09-27) Feat gui : add PageLayout gui : add Movie class gui : add PageSize class gui : add FontInfo class core : add UrlQuery class add network module PropertyAnimation : add get/set_property_name methods core : add ParallelAnimationGroup widgets : add SizeGrip class widgets : add DataWidgetMapper class core : add StringListModel VersionNumber : add get_python_version gui : add Transform class Painter : add draw_polygon method add core.ByteArray v0.121.0 (2020-09-10) Feat Image : add setitem / getitem methods Line/LineF : add reversed and abs methods GraphicsScene : add get/set_item_index_method method Fix serialization fixes v0.120.0 (2020-08-27) Feat GraphicsWidget : add set_layout method GraphicsLayout : add some magic methods GraphicsScene : add add_item_group method widgets : add GraphicsAnchorLayout / GraphicsGridLayout / GraphicsLinearLayout widgets : add GraphicsItemGroup Layout : add delitem method Polygon/PolygonF : add repr and iter methods PainterPath : some additional methods GraphicsItems : add repr methods Line/LineF : add repr and iter Application : allow loading included language files via load_language_file widgets : add GraphicsView class Refactor PromptLineEdit rework v0.119.1 (2020-08-24) Fix add missing StyleOptionComplex class v0.119.0 (2020-08-24) Feat GraphicsScene : add some convenience methods widgets : add graphicsitem classes StylePainter : add draw_complex_control method gui : allow pickling some more classes core : add LineF class Widget : add get_palette() method widgets : add GraphicsPixmapItem / GraphicsScene GraphicsItem : add getitem and setitem methods widgets : add Blur/Colorize/DropShadowEffect Fix Graphicsitem collides methods fix KeySequence : pickling v0.118.2 (2020-08-17) Fix Fix tests v0.118.1 (2020-08-17) Fix MenuBar : fix add method v0.118.0 (2020-08-17) Refactor MenuBar : return subclassed types instead of qt classes Feat gui : add TextDocument / TextBlock / TextOption gui : add ConicalGradient / RadialGradient custom_widgets : add CollapsibleFrame GraphicsItem : add some more methods v0.117.0 (2020-08-16) Feat MimeData : add dict-like interface Timer : add get/set_type methods File : add repr and str methods Dir : add repr and truediv methods Frame : set/get_frame_shape, set/get_frame_shadow Splitter : add setitem method, and some more typing Polygon/PolygonF : pythonize core : add Abstract/Variant/PropertyAnimation and AnimationGroup core : add EasingCurve StyleOptionSlider : add get_orientation method Refactor SpanSlider : clean up code v0.116.0 (2020-08-13) Feat gui : add LinearGradient AbstractSlider : add get/set_repeat_action and trigger_action methods TabWidget : add get/set_tab_position methods Image/Pixmap : add bool method MenuBar : serialize stuff MdiArea : serialize stuff Brush : allow pickling + add get_texture_image method custom_widgets : add Timeline Pen : add methods for setting and getting style / join style / cap style Refactor Painter : rework set_pen / get_pen v0.115.0 (2020-08-12) Feat Polygon : add add_points method Object : add store_widget_states / restore_widget_states Painter : add paint_on, set_transparent_background, set_brush PainterPath : add add_rect method Application : add class_getitem Fix RegexEditor : correctly initialize dialog v0.114.1 (2020-08-12) Fix HeaderView : fix saving state v0.114.0 (2020-08-12) Refactor use AutoSlot decorator Feat add autoslot decorator add prettyqt.debug v0.113.0 (2020-08-10) Feat gui : add PainterPath class gui : add Polygon class gui : palette improvements core : add Line class core : add TransposeProxyModel / ConcatenateTablesProxyModel add ObjectBrowser widgets : add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect Action : \"checked\" param for ctor gui : some magic methods + get_matches for KeySequence core : allow pickling VersionNumber / Size / Dir gui : add Gradient class add ColumnItemModel / ColumnItem Settings : add set_values method Widget : spacing kwarg for set_layout Refactor add serialization stuff improve some repr methods v0.112.0 (2020-08-04) Feat utils : add install_exceptionhook method FileSystemModel : add some more shortcuts for set_root_path core : add VersionNumber class Application : add get_icon method MessageBox : add show_exception method Refactor improve compat with older Qt Versions Fix another test fix v0.111.1 (2020-08-03) Fix fix tests for Linux v0.111.0 (2020-08-03) Feat widgets : add FontComboBox StandardPaths : add class_getitem method Action : some more ctor kwargs Action : add get/set_menu_role methods, some pickle work Refactor custom Exception for wrong params Fix Menu : disable separator widgetAction v0.110.2 (2020-08-03) Fix fix broken LogTextEdit v0.110.1 (2020-08-03) Fix LogTextEdit : improve exception handling SidebarWidget : some fixes related to set_marker v0.110.0 (2020-08-02) Refactor improve serialization for listitems Validator pickle work Feat Image : allow pickling DataStream : add create_bytearray / write_bytearray / copy_data methods core : add DataStream class v0.109.0 (2020-08-02) Feat widget : add pretty method for devtools GridLayout : allow adding tuples/lists Refactor rework widget pickling move CheckboxDelegate to custom_delegates pickle stuff for undocommand v0.108.0 (2020-07-31) Feat custom_delegates : add IconDelegate and NoFocusDelegate TableWidet : add getitem and setitem methods Icon : add from_image method allow str for layout. getitem (uses objectName) SidebarWidget : add set_marker method Refactor move delegates to separate module v0.107.0 (2020-07-29) Feat GridLayout : also allow adding LayoutItems via add method v0.106.1 (2020-07-29) Fix TabWidget : correctly close detached tabs on app close pickle fixes for toolbar and dockwidget PygmentsHighlighter : catch pygments KeyError v0.106.0 (2020-07-26) Feat gui : add DesktopServices class multimedia : add AudioRecorder class core : add StandardPaths class widgets : add Undo classes v0.105.0 (2020-07-24) Feat MediaRecorder : some new methods sort_by_column for tableview and treeview multimedia : dict-setter and getter for encodersettings Refactor improve Url-Pathlib interoperability Fix PopupInfo : use PrimaryScreen geometry instead of screens[0] for positioning v0.104.0 (2020-07-23) Feat multimedia : add MediaRecorder AbstractItemModel : add getitem method multimedia : add VideoEncoderSettings / AudioEncoderSettings Refactor use subclassed core.Size v0.103.0 (2020-07-22) Feat ActionGroup : add getitem method MediaContent : add get_url method add multimediawidgets module add multimedia module PlainTextEdit : add allow_wheel_zoom method Object : name kwarg for find_parent method v0.102.0 (2020-07-21) Refactor move raise_dock to from Widget to Object SidebarWidget : some code cleanup, make settings button size configurable Widget : default state to True for set_attribute MainWindow : add return value for load_window_state Feat Object : add find_parent method PlainTextEdit : add style kwarg to set_syntaxhighlighter v0.101.1 (2020-07-20) Fix LogTextEdit : better integrate with custom qstylesheets v0.101.0 (2020-07-20) Feat MessageBox : add detail_text keyword argument to message method Fix correct return type for gui.icon.get_icon v0.100.0 (2020-07-20) Feat ToolTip : add show_text method GuiApplication : add set_override_cursor / restore_override_cursor methods GuiApplication : add override_cursor context manager v0.99.0 (2020-07-18) Refactor FileChooserButton : typing and fixes Dataset : typing and fixes SidebarWidget : use button map instead of attaching button to widget Feat AbstractItemView : add scroll_to method v0.98.5 (2020-07-17) Perf add icon cache Refactor use core.Settings for windows dark mode detection v0.98.4 (2020-07-15) Fix use qta default icon color instead of black for default v0.98.3 (2020-07-15) Refactor properly set stylesheets by using contextmanager FontDialog : do not override current_font contextmanager move current_font context manager to Widget class v0.98.2 (2020-07-15) Fix package name v0.98.1 (2020-07-15) Fix correctly reset stylesheet for widget validation background Refactor use qstylizer for stylesheet editing v0.98.0 (2020-07-15) Feat widgets : add StyleFactory Refactor FontDatabase : make add_fonts_from_folder a classmethod v0.97.0 (2020-07-15) Feat gui : add FontDatabase widgets : add Completer widgets : add ActionGroup v0.96.0 (2020-07-14) Feat SelectionWidget : default keyword argument for add_custom v0.95.0 (2020-07-14) Feat SelectionWidget : different options for custom type add PagedPaintDevice Widget : add set_margin method v0.94.0 (2020-07-14) Feat Widget : add Widget.font_metrics() SpacerItem : allow strings for size policy in ctor allow Mapping for listwidget.add_items Refactor change to {value: label} dicts for FlagSelectionWidget.add_items v0.93.1 (2020-07-14) Refactor typecheck for Mapping instead of dict for combobox / selectionwidget add_items method v0.93.0 (2020-07-14) Feat add register_extensions function to settings module Refactor Settings : do not override value method v0.92.1 (2020-07-14) Fix winextras test fix v0.92.0 (2020-07-14) Feat add widgets.SystemTrayIcon add winextras module Label : set_indent method v0.91.0 (2020-07-13) Feat SidebarWidget : allow choosing layout MainWindow : add show_blocking method v0.90.0 (2020-07-13) Feat Toolbar : allow combinations of allowed areas for set_allowed_areas SidebarWidget : add optional settings menu v0.89.1 (2020-07-13) Refactor SelectionWidget : switch to {data: label} dicts for add_items to be in line with RadioButton v0.89.0 (2020-07-13) Feat SidebarWidget : make button width configurable v0.88.1 (2020-07-13) Refactor ComboBox : use set_data for set_value Fix ComboBox : fix add_items method v0.88.0 (2020-07-13) Feat ComboBox : set_data method v0.87.0 (2020-07-13) Feat ComboBox : allow dict for add_items v0.86.3 (2020-07-12) Refactor RegexEditor : code cleanup v0.86.2 (2020-07-12) Fix another deployment fix v0.86.1 (2020-07-12) Fix deployment fix v0.86.0 (2020-07-12) Feat add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line v0.85.1 (2020-07-10) Fix add missing pygments requirement v0.85.0 (2020-07-10) Feat dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method Refactor CodeEditor : use pygments for syntax highlighting v0.84.0 (2020-07-10) Feat sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child v0.83.1 (2020-07-09) Refactor move set_icon from window classes to widget class v0.83.0 (2020-07-09) Feat add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager v0.82.0 (2020-07-09) Feat add Label.set_bold / set_italic / set_weight added Font.set_weight v0.81.0 (2020-07-08) Feat allow setting window icon color os dark mode detection v0.80.1 (2020-07-08) Fix Settings.value() returned wrong type v0.80.0 (2020-07-08) Feat add Widget.set_attribute add margin keyword argument to Widget.set_layout v0.79.1 (2020-07-08) Fix remove Qt logger on Application exit v0.79.0 (2020-07-08) Feat add widgets.Application.get_widget v0.78.0 (2020-07-08) Feat allow to save/load window state recursively. Saving needs to be done explicitely now. Fix some fixes for core.Settings dict interface properly preserve types in core.Settings v0.77.1 (2020-07-07) Refactor also allow qt flag for Splitter ctor Fix return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview 0.77.0 (2020-07-06) Feat allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages Fix fix Messagebox.message call Refactor dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars","title":"Changelog"},{"location":"changelog.html#v01260-2020-10-08","text":"","title":"v0.126.0 (2020-10-08)"},{"location":"changelog.html#feat","text":"core : add Process class DateTime : add get/set_time_spec and get_date/time methods core : add Time class DateTime : add timezone methods core : add TimeZone class Pixmap : add create_dot classmethod","title":"Feat"},{"location":"changelog.html#v01251-2020-10-07","text":"","title":"v0.125.1 (2020-10-07)"},{"location":"changelog.html#fix","text":"import fix","title":"Fix"},{"location":"changelog.html#v01250-2020-10-07","text":"","title":"v0.125.0 (2020-10-07)"},{"location":"changelog.html#feat_1","text":"widgets : add Transition classes core : add Transition classes","title":"Feat"},{"location":"changelog.html#fix_1","text":"fix Action.get_shortcut for NoneValue","title":"Fix"},{"location":"changelog.html#v01240-2020-10-05","text":"","title":"v0.124.0 (2020-10-05)"},{"location":"changelog.html#feat_2","text":"IODevice : add get_open_mode method Improve repr and add str method for Date and DateTime core : add TemporaryFile class FileDevice : add set/get_file_time methods MainWindow : allow setting central widget to None AbstractButton : add get_shortcut method Url : add from_user_input method WebEngineView : add get_url method FileInfo : support pathlib + add proper repr KeySequence : allow initializing with standard keys","title":"Feat"},{"location":"changelog.html#v01231-2020-09-29","text":"","title":"v0.123.1 (2020-09-29)"},{"location":"changelog.html#fix_2","text":"add missing State import in core module","title":"Fix"},{"location":"changelog.html#v01230-2020-09-29","text":"","title":"v0.123.0 (2020-09-29)"},{"location":"changelog.html#feat_3","text":"core : add State classes core : add TextBoundaryFinder class ProgressBar : add get/set_orientation methods + serialize work Action : allow setting callback with ctor WebEngineView : set subclassed WebEnginePage by default WebEnginePage : add some more methods and constants AbstractSlider : add get/set_orientation methods core : add FileInfo class webenginewidgets : add WebEngineProfile class","title":"Feat"},{"location":"changelog.html#v01221-2020-09-27","text":"","title":"v0.122.1 (2020-09-27)"},{"location":"changelog.html#fix_3","text":"use correct icon names","title":"Fix"},{"location":"changelog.html#v01220-2020-09-27","text":"","title":"v0.122.0 (2020-09-27)"},{"location":"changelog.html#feat_4","text":"gui : add PageLayout gui : add Movie class gui : add PageSize class gui : add FontInfo class core : add UrlQuery class add network module PropertyAnimation : add get/set_property_name methods core : add ParallelAnimationGroup widgets : add SizeGrip class widgets : add DataWidgetMapper class core : add StringListModel VersionNumber : add get_python_version gui : add Transform class Painter : add draw_polygon method add core.ByteArray","title":"Feat"},{"location":"changelog.html#v01210-2020-09-10","text":"","title":"v0.121.0 (2020-09-10)"},{"location":"changelog.html#feat_5","text":"Image : add setitem / getitem methods Line/LineF : add reversed and abs methods GraphicsScene : add get/set_item_index_method method","title":"Feat"},{"location":"changelog.html#fix_4","text":"serialization fixes","title":"Fix"},{"location":"changelog.html#v01200-2020-08-27","text":"","title":"v0.120.0 (2020-08-27)"},{"location":"changelog.html#feat_6","text":"GraphicsWidget : add set_layout method GraphicsLayout : add some magic methods GraphicsScene : add add_item_group method widgets : add GraphicsAnchorLayout / GraphicsGridLayout / GraphicsLinearLayout widgets : add GraphicsItemGroup Layout : add delitem method Polygon/PolygonF : add repr and iter methods PainterPath : some additional methods GraphicsItems : add repr methods Line/LineF : add repr and iter Application : allow loading included language files via load_language_file widgets : add GraphicsView class","title":"Feat"},{"location":"changelog.html#refactor","text":"PromptLineEdit rework","title":"Refactor"},{"location":"changelog.html#v01191-2020-08-24","text":"","title":"v0.119.1 (2020-08-24)"},{"location":"changelog.html#fix_5","text":"add missing StyleOptionComplex class","title":"Fix"},{"location":"changelog.html#v01190-2020-08-24","text":"","title":"v0.119.0 (2020-08-24)"},{"location":"changelog.html#feat_7","text":"GraphicsScene : add some convenience methods widgets : add graphicsitem classes StylePainter : add draw_complex_control method gui : allow pickling some more classes core : add LineF class Widget : add get_palette() method widgets : add GraphicsPixmapItem / GraphicsScene GraphicsItem : add getitem and setitem methods widgets : add Blur/Colorize/DropShadowEffect","title":"Feat"},{"location":"changelog.html#fix_6","text":"Graphicsitem collides methods fix KeySequence : pickling","title":"Fix"},{"location":"changelog.html#v01182-2020-08-17","text":"","title":"v0.118.2 (2020-08-17)"},{"location":"changelog.html#fix_7","text":"Fix tests","title":"Fix"},{"location":"changelog.html#v01181-2020-08-17","text":"","title":"v0.118.1 (2020-08-17)"},{"location":"changelog.html#fix_8","text":"MenuBar : fix add method","title":"Fix"},{"location":"changelog.html#v01180-2020-08-17","text":"","title":"v0.118.0 (2020-08-17)"},{"location":"changelog.html#refactor_1","text":"MenuBar : return subclassed types instead of qt classes","title":"Refactor"},{"location":"changelog.html#feat_8","text":"gui : add TextDocument / TextBlock / TextOption gui : add ConicalGradient / RadialGradient custom_widgets : add CollapsibleFrame GraphicsItem : add some more methods","title":"Feat"},{"location":"changelog.html#v01170-2020-08-16","text":"","title":"v0.117.0 (2020-08-16)"},{"location":"changelog.html#feat_9","text":"MimeData : add dict-like interface Timer : add get/set_type methods File : add repr and str methods Dir : add repr and truediv methods Frame : set/get_frame_shape, set/get_frame_shadow Splitter : add setitem method, and some more typing Polygon/PolygonF : pythonize core : add Abstract/Variant/PropertyAnimation and AnimationGroup core : add EasingCurve StyleOptionSlider : add get_orientation method","title":"Feat"},{"location":"changelog.html#refactor_2","text":"SpanSlider : clean up code","title":"Refactor"},{"location":"changelog.html#v01160-2020-08-13","text":"","title":"v0.116.0 (2020-08-13)"},{"location":"changelog.html#feat_10","text":"gui : add LinearGradient AbstractSlider : add get/set_repeat_action and trigger_action methods TabWidget : add get/set_tab_position methods Image/Pixmap : add bool method MenuBar : serialize stuff MdiArea : serialize stuff Brush : allow pickling + add get_texture_image method custom_widgets : add Timeline Pen : add methods for setting and getting style / join style / cap style","title":"Feat"},{"location":"changelog.html#refactor_3","text":"Painter : rework set_pen / get_pen","title":"Refactor"},{"location":"changelog.html#v01150-2020-08-12","text":"","title":"v0.115.0 (2020-08-12)"},{"location":"changelog.html#feat_11","text":"Polygon : add add_points method Object : add store_widget_states / restore_widget_states Painter : add paint_on, set_transparent_background, set_brush PainterPath : add add_rect method Application : add class_getitem","title":"Feat"},{"location":"changelog.html#fix_9","text":"RegexEditor : correctly initialize dialog","title":"Fix"},{"location":"changelog.html#v01141-2020-08-12","text":"","title":"v0.114.1 (2020-08-12)"},{"location":"changelog.html#fix_10","text":"HeaderView : fix saving state","title":"Fix"},{"location":"changelog.html#v01140-2020-08-12","text":"","title":"v0.114.0 (2020-08-12)"},{"location":"changelog.html#refactor_4","text":"use AutoSlot decorator","title":"Refactor"},{"location":"changelog.html#feat_12","text":"add autoslot decorator add prettyqt.debug","title":"Feat"},{"location":"changelog.html#v01130-2020-08-10","text":"","title":"v0.113.0 (2020-08-10)"},{"location":"changelog.html#feat_13","text":"gui : add PainterPath class gui : add Polygon class gui : palette improvements core : add Line class core : add TransposeProxyModel / ConcatenateTablesProxyModel add ObjectBrowser widgets : add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect Action : \"checked\" param for ctor gui : some magic methods + get_matches for KeySequence core : allow pickling VersionNumber / Size / Dir gui : add Gradient class add ColumnItemModel / ColumnItem Settings : add set_values method Widget : spacing kwarg for set_layout","title":"Feat"},{"location":"changelog.html#refactor_5","text":"add serialization stuff improve some repr methods","title":"Refactor"},{"location":"changelog.html#v01120-2020-08-04","text":"","title":"v0.112.0 (2020-08-04)"},{"location":"changelog.html#feat_14","text":"utils : add install_exceptionhook method FileSystemModel : add some more shortcuts for set_root_path core : add VersionNumber class Application : add get_icon method MessageBox : add show_exception method","title":"Feat"},{"location":"changelog.html#refactor_6","text":"improve compat with older Qt Versions","title":"Refactor"},{"location":"changelog.html#fix_11","text":"another test fix","title":"Fix"},{"location":"changelog.html#v01111-2020-08-03","text":"","title":"v0.111.1 (2020-08-03)"},{"location":"changelog.html#fix_12","text":"fix tests for Linux","title":"Fix"},{"location":"changelog.html#v01110-2020-08-03","text":"","title":"v0.111.0 (2020-08-03)"},{"location":"changelog.html#feat_15","text":"widgets : add FontComboBox StandardPaths : add class_getitem method Action : some more ctor kwargs Action : add get/set_menu_role methods, some pickle work","title":"Feat"},{"location":"changelog.html#refactor_7","text":"custom Exception for wrong params","title":"Refactor"},{"location":"changelog.html#fix_13","text":"Menu : disable separator widgetAction","title":"Fix"},{"location":"changelog.html#v01102-2020-08-03","text":"","title":"v0.110.2 (2020-08-03)"},{"location":"changelog.html#fix_14","text":"fix broken LogTextEdit","title":"Fix"},{"location":"changelog.html#v01101-2020-08-03","text":"","title":"v0.110.1 (2020-08-03)"},{"location":"changelog.html#fix_15","text":"LogTextEdit : improve exception handling SidebarWidget : some fixes related to set_marker","title":"Fix"},{"location":"changelog.html#v01100-2020-08-02","text":"","title":"v0.110.0 (2020-08-02)"},{"location":"changelog.html#refactor_8","text":"improve serialization for listitems Validator pickle work","title":"Refactor"},{"location":"changelog.html#feat_16","text":"Image : allow pickling DataStream : add create_bytearray / write_bytearray / copy_data methods core : add DataStream class","title":"Feat"},{"location":"changelog.html#v01090-2020-08-02","text":"","title":"v0.109.0 (2020-08-02)"},{"location":"changelog.html#feat_17","text":"widget : add pretty method for devtools GridLayout : allow adding tuples/lists","title":"Feat"},{"location":"changelog.html#refactor_9","text":"rework widget pickling move CheckboxDelegate to custom_delegates pickle stuff for undocommand","title":"Refactor"},{"location":"changelog.html#v01080-2020-07-31","text":"","title":"v0.108.0 (2020-07-31)"},{"location":"changelog.html#feat_18","text":"custom_delegates : add IconDelegate and NoFocusDelegate TableWidet : add getitem and setitem methods Icon : add from_image method allow str for layout. getitem (uses objectName) SidebarWidget : add set_marker method","title":"Feat"},{"location":"changelog.html#refactor_10","text":"move delegates to separate module","title":"Refactor"},{"location":"changelog.html#v01070-2020-07-29","text":"","title":"v0.107.0 (2020-07-29)"},{"location":"changelog.html#feat_19","text":"GridLayout : also allow adding LayoutItems via add method","title":"Feat"},{"location":"changelog.html#v01061-2020-07-29","text":"","title":"v0.106.1 (2020-07-29)"},{"location":"changelog.html#fix_16","text":"TabWidget : correctly close detached tabs on app close pickle fixes for toolbar and dockwidget PygmentsHighlighter : catch pygments KeyError","title":"Fix"},{"location":"changelog.html#v01060-2020-07-26","text":"","title":"v0.106.0 (2020-07-26)"},{"location":"changelog.html#feat_20","text":"gui : add DesktopServices class multimedia : add AudioRecorder class core : add StandardPaths class widgets : add Undo classes","title":"Feat"},{"location":"changelog.html#v01050-2020-07-24","text":"","title":"v0.105.0 (2020-07-24)"},{"location":"changelog.html#feat_21","text":"MediaRecorder : some new methods sort_by_column for tableview and treeview multimedia : dict-setter and getter for encodersettings","title":"Feat"},{"location":"changelog.html#refactor_11","text":"improve Url-Pathlib interoperability","title":"Refactor"},{"location":"changelog.html#fix_17","text":"PopupInfo : use PrimaryScreen geometry instead of screens[0] for positioning","title":"Fix"},{"location":"changelog.html#v01040-2020-07-23","text":"","title":"v0.104.0 (2020-07-23)"},{"location":"changelog.html#feat_22","text":"multimedia : add MediaRecorder AbstractItemModel : add getitem method multimedia : add VideoEncoderSettings / AudioEncoderSettings","title":"Feat"},{"location":"changelog.html#refactor_12","text":"use subclassed core.Size","title":"Refactor"},{"location":"changelog.html#v01030-2020-07-22","text":"","title":"v0.103.0 (2020-07-22)"},{"location":"changelog.html#feat_23","text":"ActionGroup : add getitem method MediaContent : add get_url method add multimediawidgets module add multimedia module PlainTextEdit : add allow_wheel_zoom method Object : name kwarg for find_parent method","title":"Feat"},{"location":"changelog.html#v01020-2020-07-21","text":"","title":"v0.102.0 (2020-07-21)"},{"location":"changelog.html#refactor_13","text":"move raise_dock to from Widget to Object SidebarWidget : some code cleanup, make settings button size configurable Widget : default state to True for set_attribute MainWindow : add return value for load_window_state","title":"Refactor"},{"location":"changelog.html#feat_24","text":"Object : add find_parent method PlainTextEdit : add style kwarg to set_syntaxhighlighter","title":"Feat"},{"location":"changelog.html#v01011-2020-07-20","text":"","title":"v0.101.1 (2020-07-20)"},{"location":"changelog.html#fix_18","text":"LogTextEdit : better integrate with custom qstylesheets","title":"Fix"},{"location":"changelog.html#v01010-2020-07-20","text":"","title":"v0.101.0 (2020-07-20)"},{"location":"changelog.html#feat_25","text":"MessageBox : add detail_text keyword argument to message method","title":"Feat"},{"location":"changelog.html#fix_19","text":"correct return type for gui.icon.get_icon","title":"Fix"},{"location":"changelog.html#v01000-2020-07-20","text":"","title":"v0.100.0 (2020-07-20)"},{"location":"changelog.html#feat_26","text":"ToolTip : add show_text method GuiApplication : add set_override_cursor / restore_override_cursor methods GuiApplication : add override_cursor context manager","title":"Feat"},{"location":"changelog.html#v0990-2020-07-18","text":"","title":"v0.99.0 (2020-07-18)"},{"location":"changelog.html#refactor_14","text":"FileChooserButton : typing and fixes Dataset : typing and fixes SidebarWidget : use button map instead of attaching button to widget","title":"Refactor"},{"location":"changelog.html#feat_27","text":"AbstractItemView : add scroll_to method","title":"Feat"},{"location":"changelog.html#v0985-2020-07-17","text":"","title":"v0.98.5 (2020-07-17)"},{"location":"changelog.html#perf","text":"add icon cache","title":"Perf"},{"location":"changelog.html#refactor_15","text":"use core.Settings for windows dark mode detection","title":"Refactor"},{"location":"changelog.html#v0984-2020-07-15","text":"","title":"v0.98.4 (2020-07-15)"},{"location":"changelog.html#fix_20","text":"use qta default icon color instead of black for default","title":"Fix"},{"location":"changelog.html#v0983-2020-07-15","text":"","title":"v0.98.3 (2020-07-15)"},{"location":"changelog.html#refactor_16","text":"properly set stylesheets by using contextmanager FontDialog : do not override current_font contextmanager move current_font context manager to Widget class","title":"Refactor"},{"location":"changelog.html#v0982-2020-07-15","text":"","title":"v0.98.2 (2020-07-15)"},{"location":"changelog.html#fix_21","text":"package name","title":"Fix"},{"location":"changelog.html#v0981-2020-07-15","text":"","title":"v0.98.1 (2020-07-15)"},{"location":"changelog.html#fix_22","text":"correctly reset stylesheet for widget validation background","title":"Fix"},{"location":"changelog.html#refactor_17","text":"use qstylizer for stylesheet editing","title":"Refactor"},{"location":"changelog.html#v0980-2020-07-15","text":"","title":"v0.98.0 (2020-07-15)"},{"location":"changelog.html#feat_28","text":"widgets : add StyleFactory","title":"Feat"},{"location":"changelog.html#refactor_18","text":"FontDatabase : make add_fonts_from_folder a classmethod","title":"Refactor"},{"location":"changelog.html#v0970-2020-07-15","text":"","title":"v0.97.0 (2020-07-15)"},{"location":"changelog.html#feat_29","text":"gui : add FontDatabase widgets : add Completer widgets : add ActionGroup","title":"Feat"},{"location":"changelog.html#v0960-2020-07-14","text":"","title":"v0.96.0 (2020-07-14)"},{"location":"changelog.html#feat_30","text":"SelectionWidget : default keyword argument for add_custom","title":"Feat"},{"location":"changelog.html#v0950-2020-07-14","text":"","title":"v0.95.0 (2020-07-14)"},{"location":"changelog.html#feat_31","text":"SelectionWidget : different options for custom type add PagedPaintDevice Widget : add set_margin method","title":"Feat"},{"location":"changelog.html#v0940-2020-07-14","text":"","title":"v0.94.0 (2020-07-14)"},{"location":"changelog.html#feat_32","text":"Widget : add Widget.font_metrics() SpacerItem : allow strings for size policy in ctor allow Mapping for listwidget.add_items","title":"Feat"},{"location":"changelog.html#refactor_19","text":"change to {value: label} dicts for FlagSelectionWidget.add_items","title":"Refactor"},{"location":"changelog.html#v0931-2020-07-14","text":"","title":"v0.93.1 (2020-07-14)"},{"location":"changelog.html#refactor_20","text":"typecheck for Mapping instead of dict for combobox / selectionwidget add_items method","title":"Refactor"},{"location":"changelog.html#v0930-2020-07-14","text":"","title":"v0.93.0 (2020-07-14)"},{"location":"changelog.html#feat_33","text":"add register_extensions function to settings module","title":"Feat"},{"location":"changelog.html#refactor_21","text":"Settings : do not override value method","title":"Refactor"},{"location":"changelog.html#v0921-2020-07-14","text":"","title":"v0.92.1 (2020-07-14)"},{"location":"changelog.html#fix_23","text":"winextras test fix","title":"Fix"},{"location":"changelog.html#v0920-2020-07-14","text":"","title":"v0.92.0 (2020-07-14)"},{"location":"changelog.html#feat_34","text":"add widgets.SystemTrayIcon add winextras module Label : set_indent method","title":"Feat"},{"location":"changelog.html#v0910-2020-07-13","text":"","title":"v0.91.0 (2020-07-13)"},{"location":"changelog.html#feat_35","text":"SidebarWidget : allow choosing layout MainWindow : add show_blocking method","title":"Feat"},{"location":"changelog.html#v0900-2020-07-13","text":"","title":"v0.90.0 (2020-07-13)"},{"location":"changelog.html#feat_36","text":"Toolbar : allow combinations of allowed areas for set_allowed_areas SidebarWidget : add optional settings menu","title":"Feat"},{"location":"changelog.html#v0891-2020-07-13","text":"","title":"v0.89.1 (2020-07-13)"},{"location":"changelog.html#refactor_22","text":"SelectionWidget : switch to {data: label} dicts for add_items to be in line with RadioButton","title":"Refactor"},{"location":"changelog.html#v0890-2020-07-13","text":"","title":"v0.89.0 (2020-07-13)"},{"location":"changelog.html#feat_37","text":"SidebarWidget : make button width configurable","title":"Feat"},{"location":"changelog.html#v0881-2020-07-13","text":"","title":"v0.88.1 (2020-07-13)"},{"location":"changelog.html#refactor_23","text":"ComboBox : use set_data for set_value","title":"Refactor"},{"location":"changelog.html#fix_24","text":"ComboBox : fix add_items method","title":"Fix"},{"location":"changelog.html#v0880-2020-07-13","text":"","title":"v0.88.0 (2020-07-13)"},{"location":"changelog.html#feat_38","text":"ComboBox : set_data method","title":"Feat"},{"location":"changelog.html#v0870-2020-07-13","text":"","title":"v0.87.0 (2020-07-13)"},{"location":"changelog.html#feat_39","text":"ComboBox : allow dict for add_items","title":"Feat"},{"location":"changelog.html#v0863-2020-07-12","text":"","title":"v0.86.3 (2020-07-12)"},{"location":"changelog.html#refactor_24","text":"RegexEditor : code cleanup","title":"Refactor"},{"location":"changelog.html#v0862-2020-07-12","text":"","title":"v0.86.2 (2020-07-12)"},{"location":"changelog.html#fix_25","text":"another deployment fix","title":"Fix"},{"location":"changelog.html#v0861-2020-07-12","text":"","title":"v0.86.1 (2020-07-12)"},{"location":"changelog.html#fix_26","text":"deployment fix","title":"Fix"},{"location":"changelog.html#v0860-2020-07-12","text":"","title":"v0.86.0 (2020-07-12)"},{"location":"changelog.html#feat_40","text":"add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line","title":"Feat"},{"location":"changelog.html#v0851-2020-07-10","text":"","title":"v0.85.1 (2020-07-10)"},{"location":"changelog.html#fix_27","text":"add missing pygments requirement","title":"Fix"},{"location":"changelog.html#v0850-2020-07-10","text":"","title":"v0.85.0 (2020-07-10)"},{"location":"changelog.html#feat_41","text":"dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method","title":"Feat"},{"location":"changelog.html#refactor_25","text":"CodeEditor : use pygments for syntax highlighting","title":"Refactor"},{"location":"changelog.html#v0840-2020-07-10","text":"","title":"v0.84.0 (2020-07-10)"},{"location":"changelog.html#feat_42","text":"sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child","title":"Feat"},{"location":"changelog.html#v0831-2020-07-09","text":"","title":"v0.83.1 (2020-07-09)"},{"location":"changelog.html#refactor_26","text":"move set_icon from window classes to widget class","title":"Refactor"},{"location":"changelog.html#v0830-2020-07-09","text":"","title":"v0.83.0 (2020-07-09)"},{"location":"changelog.html#feat_43","text":"add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager","title":"Feat"},{"location":"changelog.html#v0820-2020-07-09","text":"","title":"v0.82.0 (2020-07-09)"},{"location":"changelog.html#feat_44","text":"add Label.set_bold / set_italic / set_weight added Font.set_weight","title":"Feat"},{"location":"changelog.html#v0810-2020-07-08","text":"","title":"v0.81.0 (2020-07-08)"},{"location":"changelog.html#feat_45","text":"allow setting window icon color os dark mode detection","title":"Feat"},{"location":"changelog.html#v0801-2020-07-08","text":"","title":"v0.80.1 (2020-07-08)"},{"location":"changelog.html#fix_28","text":"Settings.value() returned wrong type","title":"Fix"},{"location":"changelog.html#v0800-2020-07-08","text":"","title":"v0.80.0 (2020-07-08)"},{"location":"changelog.html#feat_46","text":"add Widget.set_attribute add margin keyword argument to Widget.set_layout","title":"Feat"},{"location":"changelog.html#v0791-2020-07-08","text":"","title":"v0.79.1 (2020-07-08)"},{"location":"changelog.html#fix_29","text":"remove Qt logger on Application exit","title":"Fix"},{"location":"changelog.html#v0790-2020-07-08","text":"","title":"v0.79.0 (2020-07-08)"},{"location":"changelog.html#feat_47","text":"add widgets.Application.get_widget","title":"Feat"},{"location":"changelog.html#v0780-2020-07-08","text":"","title":"v0.78.0 (2020-07-08)"},{"location":"changelog.html#feat_48","text":"allow to save/load window state recursively. Saving needs to be done explicitely now.","title":"Feat"},{"location":"changelog.html#fix_30","text":"some fixes for core.Settings dict interface properly preserve types in core.Settings","title":"Fix"},{"location":"changelog.html#v0771-2020-07-07","text":"","title":"v0.77.1 (2020-07-07)"},{"location":"changelog.html#refactor_27","text":"also allow qt flag for Splitter ctor","title":"Refactor"},{"location":"changelog.html#fix_31","text":"return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview","title":"Fix"},{"location":"changelog.html#0770-2020-07-06","text":"","title":"0.77.0 (2020-07-06)"},{"location":"changelog.html#feat_49","text":"allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages","title":"Feat"},{"location":"changelog.html#fix_32","text":"fix Messagebox.message call","title":"Fix"},{"location":"changelog.html#refactor_28","text":"dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars","title":"Refactor"},{"location":"contributing.html","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs ~~~~~~~~~~~ Report bugs at https://github.com/phil65/prettyqt/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs ~~~~~~~~ Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features ~~~~~~~~~~~~~~~~~~ Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ~~~~~~~~~~~~~~~~~~~ PrettyQt could always use more documentation, whether as part of the official PrettyQt docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback ~~~~~~~~~~~~~~~ The best way to send feedback is to file an issue at https://github.com/phil65/prettyqt/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! Ready to contribute? Here's how to set up prettyqt for local development. Fork the prettyqt repo on GitHub. Clone your fork locally:: $ git clone git@github.com:your_name_here/prettyqt.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:: $ mkvirtualenv prettyqt $ cd prettyqt/ $ python setup.py develop Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests: $ flake8 prettyqt tests $ py.test To install required development libraries, run \"pip install -r requirements_dev.txt\". Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6 - 3.8. Check https://travis-ci.org/phil65/prettyqt/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Contributing"},{"location":"contributing.html#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing.html#types-of-contributions","text":"Report Bugs ~~~~~~~~~~~ Report bugs at https://github.com/phil65/prettyqt/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs ~~~~~~~~ Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features ~~~~~~~~~~~~~~~~~~ Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ~~~~~~~~~~~~~~~~~~~ PrettyQt could always use more documentation, whether as part of the official PrettyQt docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback ~~~~~~~~~~~~~~~ The best way to send feedback is to file an issue at https://github.com/phil65/prettyqt/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Types of Contributions"},{"location":"contributing.html#get-started","text":"Ready to contribute? Here's how to set up prettyqt for local development. Fork the prettyqt repo on GitHub. Clone your fork locally:: $ git clone git@github.com:your_name_here/prettyqt.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:: $ mkvirtualenv prettyqt $ cd prettyqt/ $ python setup.py develop Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests: $ flake8 prettyqt tests $ py.test To install required development libraries, run \"pip install -r requirements_dev.txt\". Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing.html#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6 - 3.8. Check https://travis-ci.org/phil65/prettyqt/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"api/charts.html","text":"charts module Charts module. abstractseries AbstractSeries QAbstractSeries with some custom properties. chart Chart apply_nice_numbers ( self ) Adjust both axis to display nice round numbers. Source code in prettyqt/charts/chart.py def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers () update_boundaries ( self ) Set new min/max values based on axis. Source code in prettyqt/charts/chart.py def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min () zoom_by_factor ( self , factor ) Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y )) chartview ChartView keyPressEvent ( self , event ) Handle keypress events to allow navigation via keyboard. Source code in prettyqt/charts/chartview.py def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_0 : self . chart () . apply_nice_numbers () else : return super () . keyPressEvent ( event ) event . accept () mouseMoveEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . RightButton : if not self . last_mouse_pos : return None pos_diff = event . pos () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . pos () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event ) mousePressEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : cursor = gui . Cursor ( QtCore . Qt . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . pos () event . accept () super () . mousePressEvent ( event ) mouseReleaseEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return None super () . mouseReleaseEvent ( event ) save_as_image ( self ) Let user choose folder and save chart as an image file. Source code in prettyqt/charts/chartview.py @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return None self . chart () . show_legend () image = self . get_image () image . save ( filename [ 0 ]) self . chart () . hide_legend () wheelEvent ( self , event ) Handle wheel event for zooming. Source code in prettyqt/charts/chartview.py def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct ) lineseries LineSeries QLineSeries with some custom properties. xyseries XYSeries QXYSeries with some custom properties.","title":"charts"},{"location":"api/charts.html#charts-module","text":"","title":"charts module"},{"location":"api/charts.html#prettyqt.charts","text":"Charts module.","title":"prettyqt.charts"},{"location":"api/charts.html#prettyqt.charts.abstractseries","text":"","title":"abstractseries"},{"location":"api/charts.html#prettyqt.charts.abstractseries.AbstractSeries","text":"QAbstractSeries with some custom properties.","title":"AbstractSeries"},{"location":"api/charts.html#prettyqt.charts.chart","text":"","title":"chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart","text":"","title":"Chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.apply_nice_numbers","text":"Adjust both axis to display nice round numbers. Source code in prettyqt/charts/chart.py def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers ()","title":"apply_nice_numbers()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.update_boundaries","text":"Set new min/max values based on axis. Source code in prettyqt/charts/chart.py def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min ()","title":"update_boundaries()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.zoom_by_factor","text":"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y ))","title":"zoom_by_factor()"},{"location":"api/charts.html#prettyqt.charts.chartview","text":"","title":"chartview"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView","text":"","title":"ChartView"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.keyPressEvent","text":"Handle keypress events to allow navigation via keyboard. Source code in prettyqt/charts/chartview.py def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_0 : self . chart () . apply_nice_numbers () else : return super () . keyPressEvent ( event ) event . accept ()","title":"keyPressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseMoveEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . RightButton : if not self . last_mouse_pos : return None pos_diff = event . pos () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . pos () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event )","title":"mouseMoveEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mousePressEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : cursor = gui . Cursor ( QtCore . Qt . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . pos () event . accept () super () . mousePressEvent ( event )","title":"mousePressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseReleaseEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return None super () . mouseReleaseEvent ( event )","title":"mouseReleaseEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.save_as_image","text":"Let user choose folder and save chart as an image file. Source code in prettyqt/charts/chartview.py @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return None self . chart () . show_legend () image = self . get_image () image . save ( filename [ 0 ]) self . chart () . hide_legend ()","title":"save_as_image()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.wheelEvent","text":"Handle wheel event for zooming. Source code in prettyqt/charts/chartview.py def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct )","title":"wheelEvent()"},{"location":"api/charts.html#prettyqt.charts.lineseries","text":"","title":"lineseries"},{"location":"api/charts.html#prettyqt.charts.lineseries.LineSeries","text":"QLineSeries with some custom properties.","title":"LineSeries"},{"location":"api/charts.html#prettyqt.charts.xyseries","text":"","title":"xyseries"},{"location":"api/charts.html#prettyqt.charts.xyseries.XYSeries","text":"QXYSeries with some custom properties.","title":"XYSeries"},{"location":"api/core.html","text":"core module Core module. Contains QtCore-based classes abstractanimation AbstractAnimation get_direction ( self ) Get the current animation direction. Possible values: \"forward\", \"backward\" Returns: Type Description str animation direction Source code in prettyqt/core/abstractanimation.py def get_direction ( self ) -> str : \"\"\"Get the current animation direction. Possible values: \"forward\", \"backward\" Returns: animation direction \"\"\" return DIRECTIONS . inv [ self . direction ()] get_state ( self ) Get the current animation state. Possible values: \"stopped\", \"paused\", \"running\" Returns: Type Description str animation state Source code in prettyqt/core/abstractanimation.py def get_state ( self ) -> str : \"\"\"Get the current animation state. Possible values: \"stopped\", \"paused\", \"running\" Returns: animation state \"\"\" return STATES . inv [ self . state ()] set_direction ( self , direction ) Set animation direction. Valid values: \"forward\", \"backward\" Parameters: Name Type Description Default direction str animation direction required Exceptions: Type Description InvalidParamError animation direction does not exist Source code in prettyqt/core/abstractanimation.py def set_direction ( self , direction : str ): \"\"\"Set animation direction. Valid values: \"forward\", \"backward\" Args: direction: animation direction Raises: InvalidParamError: animation direction does not exist \"\"\" if direction not in DIRECTIONS : raise InvalidParamError ( direction , DIRECTIONS ) self . setDirection ( DIRECTIONS [ direction ]) start_animation ( self , policy ) Start the animation. Valid values for policy: \"keep\", \"delete\" Parameters: Name Type Description Default policy str animation policy required Exceptions: Type Description InvalidParamError animation policy does not exist Source code in prettyqt/core/abstractanimation.py def start_animation ( self , policy : str ): \"\"\"Start the animation. Valid values for policy: \"keep\", \"delete\" Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" if policy not in DELETION_POLICIES : raise InvalidParamError ( policy , DELETION_POLICIES ) self . start ( DELETION_POLICIES [ policy ]) abstractitemmodel AbstractItemModel __len__ ( self ) special Return amount of rows. Source code in prettyqt/core/abstractitemmodel.py def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount () change_layout ( self ) Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit () reset_model ( self ) Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel () abstracttransition AbstractTransition get_transition_type ( self ) Return current transition type. Possible values: \"exclusive\", \"parallel\" Returns: Type Description str transition type Source code in prettyqt/core/abstracttransition.py def get_transition_type ( self ) -> str : \"\"\"Return current transition type. Possible values: \"exclusive\", \"parallel\" Returns: transition type \"\"\" return TRANSITION_TYPES . inv [ self . transitionType ()] set_transition_type ( self , typ ) Set transition type. Allowed values are \"exclusive\", \"parallel\" Parameters: Name Type Description Default typ str transition type to use required Exceptions: Type Description InvalidParamError transition type does not exist Source code in prettyqt/core/abstracttransition.py def set_transition_type ( self , typ : str ): \"\"\"Set transition type. Allowed values are \"exclusive\", \"parallel\" Args: typ: transition type to use Raises: InvalidParamError: transition type does not exist \"\"\" if typ not in TRANSITION_TYPES : raise InvalidParamError ( typ , TRANSITION_TYPES ) self . setTransitionType ( TRANSITION_TYPES [ typ ]) bytearray ByteArray __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/bytearray.py def __reduce__ ( self ): return ( self . __class__ , ( bytes ( self ),)) datastream DataStream get_byte_order ( self ) Return byte order. possible values are \"big_endian\", \"little_endian\" Returns: Type Description bool byte order Source code in prettyqt/core/datastream.py def get_byte_order ( self ) -> bool : \"\"\"Return byte order. possible values are \"big_endian\", \"little_endian\" Returns: byte order \"\"\" return BYTE_ORDER . inv [ self . byteOrder ()] get_float_precision ( self ) Return floating point precision. possible values are \"single\", \"double\" Returns: Type Description bool floating point precision Source code in prettyqt/core/datastream.py def get_float_precision ( self ) -> bool : \"\"\"Return floating point precision. possible values are \"single\", \"double\" Returns: floating point precision \"\"\" return FLOAT_PRECISION . inv [ self . floatingPointPrecision ()] set_byte_order ( self , order ) Set byte order. valid values are: \"big_endian\", \"little endian\" Parameters: Name Type Description Default order str byte order to use required Exceptions: Type Description InvalidParamError invalid order Source code in prettyqt/core/datastream.py def set_byte_order ( self , order : str ): \"\"\"Set byte order. valid values are: \"big_endian\", \"little endian\" Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ]) set_float_precision ( self , precision ) Set floating point precision. valid values are: \"single\", \"double\" Parameters: Name Type Description Default precision str floating point precision required Exceptions: Type Description InvalidParamError invalid precision Source code in prettyqt/core/datastream.py def set_float_precision ( self , precision : str ): \"\"\"Set floating point precision. valid values are: \"single\", \"double\" Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOAT_PRECISION : raise InvalidParamError ( precision , FLOAT_PRECISION ) self . setFloatingPointPrecision ( FLOAT_PRECISION [ precision ]) date Date __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/date.py def __reduce__ ( self ): return ( self . __class__ , ( self . year (), self . month (), self . day ())) datetime DateTime __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/datetime.py def __reduce__ ( self ): return ( self . __class__ , ( self . date (), self . time ())) get_time_spec ( self ) Return current time specification. Possible values: \"local_time\", \"utc\", \"offset_from_utc\", \"timezone\" Returns: Type Description str time specification Source code in prettyqt/core/datetime.py def get_time_spec ( self ) -> str : \"\"\"Return current time specification. Possible values: \"local_time\", \"utc\", \"offset_from_utc\", \"timezone\" Returns: time specification \"\"\" return TIME_SPECS . inv [ self . timeSpec ()] set_time_spec ( self , spec ) Set the time specification. Allowed values are \"local_time\", \"utc\", \"offset_from_utc\", \"timezone\" Parameters: Name Type Description Default mode time specification to use required Exceptions: Type Description InvalidParamError time specification does not exist Source code in prettyqt/core/datetime.py def set_time_spec ( self , spec : str ): \"\"\"Set the time specification. Allowed values are \"local_time\", \"utc\", \"offset_from_utc\", \"timezone\" Args: mode: time specification to use Raises: InvalidParamError: time specification does not exist \"\"\" if spec not in TIME_SPECS : raise InvalidParamError ( spec , TIME_SPECS ) self . setTimeSpec ( TIME_SPECS [ spec ]) easingcurve EasingCurve get_type ( self ) Get the current easing curve type. Possible values: \"linear\", \"in_quad\", \"out_quad\", \"in_out_quad\", \"out_in_quad\", \"in_cubic\", \"out_cubic\", \"in_out_cubic\", \"out_in_cubic\", \"in_quart\", \"out_quart\", \"in_out_quart\", \"out_in_quart\", \"in_quint\", \"out_quint\", \"in_out_quint\", \"out_in_quint\", \"in_sine\", \"out_sine\", \"in_out_sine\", \"out_in_sine\", \"in_expo\", \"out_expo\", \"in_out_expo\", \"out_in_expo\", \"in_circ\", \"out_circ\", \"in_out_circ\", \"out_in_circ\", \"in_elastic\", \"out_elastic\", \"in_out_elastic\", \"out_in_elastic\", \"in_back\", \"out_back\", \"in_out_back\", \"out_in_back\", \"in_bounce\", \"out_bounce\", \"in_out_bounce\", \"out_in_bounce\", \"bezier_spline\", \"tcb_spline\", \"custom\" Returns: Type Description str easing curve type Source code in prettyqt/core/easingcurve.py def get_type ( self ) -> str : \"\"\"Get the current easing curve type. Possible values: \"linear\", \"in_quad\", \"out_quad\", \"in_out_quad\", \"out_in_quad\", \"in_cubic\", \"out_cubic\", \"in_out_cubic\", \"out_in_cubic\", \"in_quart\", \"out_quart\", \"in_out_quart\", \"out_in_quart\", \"in_quint\", \"out_quint\", \"in_out_quint\", \"out_in_quint\", \"in_sine\", \"out_sine\", \"in_out_sine\", \"out_in_sine\", \"in_expo\", \"out_expo\", \"in_out_expo\", \"out_in_expo\", \"in_circ\", \"out_circ\", \"in_out_circ\", \"out_in_circ\", \"in_elastic\", \"out_elastic\", \"in_out_elastic\", \"out_in_elastic\", \"in_back\", \"out_back\", \"in_out_back\", \"out_in_back\", \"in_bounce\", \"out_bounce\", \"in_out_bounce\", \"out_in_bounce\", \"bezier_spline\", \"tcb_spline\", \"custom\" Returns: easing curve type \"\"\" return TYPES . inv [ self . type ()] set_type ( self , typ ) Set easing curve type. Valid values for modality: \"linear\", \"in_quad\", \"out_quad\", \"in_out_quad\", \"out_in_quad\", \"in_cubic\", \"out_cubic\", \"in_out_cubic\", \"out_in_cubic\", \"in_quart\", \"out_quart\", \"in_out_quart\", \"out_in_quart\", \"in_quint\", \"out_quint\", \"in_out_quint\", \"out_in_quint\", \"in_sine\", \"out_sine\", \"in_out_sine\", \"out_in_sine\", \"in_expo\", \"out_expo\", \"in_out_expo\", \"out_in_expo\", \"in_circ\", \"out_circ\", \"in_out_circ\", \"out_in_circ\", \"in_elastic\", \"out_elastic\", \"in_out_elastic\", \"out_in_elastic\", \"in_back\", \"out_back\", \"in_out_back\", \"out_in_back\", \"in_bounce\", \"out_bounce\", \"in_out_bounce\", \"out_in_bounce\", \"bezier_spline\", \"tcb_spline\", \"custom\" Parameters: Name Type Description Default type easing curve type required Exceptions: Type Description InvalidParamError easing curve type does not exist Source code in prettyqt/core/easingcurve.py def set_type ( self , typ : str ): \"\"\"Set easing curve type. Valid values for modality: \"linear\", \"in_quad\", \"out_quad\", \"in_out_quad\", \"out_in_quad\", \"in_cubic\", \"out_cubic\", \"in_out_cubic\", \"out_in_cubic\", \"in_quart\", \"out_quart\", \"in_out_quart\", \"out_in_quart\", \"in_quint\", \"out_quint\", \"in_out_quint\", \"out_in_quint\", \"in_sine\", \"out_sine\", \"in_out_sine\", \"out_in_sine\", \"in_expo\", \"out_expo\", \"in_out_expo\", \"out_in_expo\", \"in_circ\", \"out_circ\", \"in_out_circ\", \"out_in_circ\", \"in_elastic\", \"out_elastic\", \"in_out_elastic\", \"out_in_elastic\", \"in_back\", \"out_back\", \"in_out_back\", \"out_in_back\", \"in_bounce\", \"out_bounce\", \"in_out_bounce\", \"out_in_bounce\", \"bezier_spline\", \"tcb_spline\", \"custom\" Args: type: easing curve type Raises: InvalidParamError: easing curve type does not exist \"\"\" if typ not in TYPES : raise InvalidParamError ( typ , TYPES ) self . setType ( TYPES [ typ ]) filedevice FileDevice get_file_time ( self , typ ) Return current file time. Possible values: \"access\", \"birth\", \"metadata_change\", \"modification\" Returns: Type Description Optional[datetime.datetime] file time Source code in prettyqt/core/filedevice.py def get_file_time ( self , typ : str ) -> Optional [ datetime . datetime ]: \"\"\"Return current file time. Possible values: \"access\", \"birth\", \"metadata_change\", \"modification\" Returns: file time \"\"\" if typ not in FILE_TIMES : raise InvalidParamError ( typ , FILE_TIMES ) date = self . fileTime ( FILE_TIMES [ typ ]) if not date : return None return to_datetime ( date ) set_file_time ( self , file_time , typ ) Set file time. Allowed values are \"access\", \"birth\", \"metadata_change\", \"modification\" Parameters: Name Type Description Default typ str file time to use required Exceptions: Type Description InvalidParamError file time does not exist Source code in prettyqt/core/filedevice.py def set_file_time ( self , file_time : Union [ QtCore . QDateTime , datetime . datetime ], typ : str ) -> bool : \"\"\"Set file time. Allowed values are \"access\", \"birth\", \"metadata_change\", \"modification\" Args: typ: file time to use Raises: InvalidParamError: file time does not exist \"\"\" if typ not in FILE_TIMES : raise InvalidParamError ( typ , FILE_TIMES ) return self . setFileTime ( file_time , FILE_TIMES [ typ ]) historystate HistoryState get_history_type ( self ) Return current history type. Possible values: \"shallow\", \"deep\" Returns: Type Description str history type Source code in prettyqt/core/historystate.py def get_history_type ( self ) -> str : \"\"\"Return current history type. Possible values: \"shallow\", \"deep\" Returns: history type \"\"\" return HISTORY_TYPES . inv [ self . historyType ()] set_history_type ( self , typ ) Set history type to use. Allowed values are \"shallow\", \"deep\" Parameters: Name Type Description Default typ str history type to use required Exceptions: Type Description InvalidParamError history type does not exist Source code in prettyqt/core/historystate.py def set_history_type ( self , typ : str ): \"\"\"Set history type to use. Allowed values are \"shallow\", \"deep\" Args: typ: history type to use Raises: InvalidParamError: history type does not exist \"\"\" if typ not in HISTORY_TYPES : raise InvalidParamError ( typ , HISTORY_TYPES ) self . setHistoryType ( HISTORY_TYPES [ typ ]) process Process set_input_channel_mode ( self , mode ) Set the input channel mode. possible values are \"managed\", \"forward\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_input_channel_mode ( self , mode : str ): \"\"\"Set the input channel mode. possible values are \"managed\", \"forward\" Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in INPUT_CHANNEL_MODES : raise InvalidParamError ( mode , INPUT_CHANNEL_MODES ) self . setInputChannelMode ( INPUT_CHANNEL_MODES [ mode ]) set_process_channel_mode ( self , mode ) Set the process channel mode. possible values are \"separate\", \"merged\", \"forwarded\", \"forwarded_error\", \"forwarded_output\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_process_channel_mode ( self , mode : str ): \"\"\"Set the process channel mode. possible values are \"separate\", \"merged\", \"forwarded\", \"forwarded_error\", \"forwarded_output\" Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in PROCESS_CHANNEL_MODES : raise InvalidParamError ( mode , PROCESS_CHANNEL_MODES ) self . setProcessChannelMode ( PROCESS_CHANNEL_MODES [ mode ]) set_read_channel ( self , channel ) Set the input channel channel. possible values are \"managed\", \"forwarded\" Parameters: Name Type Description Default channel str channel to set required Exceptions: Type Description InvalidParamError invalid channel Source code in prettyqt/core/process.py def set_read_channel ( self , channel : str ): \"\"\"Set the input channel channel. possible values are \"managed\", \"forwarded\" Args: channel: channel to set Raises: InvalidParamError: invalid channel \"\"\" if channel not in PROCESS_CHANNELS : raise InvalidParamError ( channel , PROCESS_CHANNELS ) self . setReadChannel ( PROCESS_CHANNELS [ channel ]) set_state ( self , state ) Set the process state. possible values are \"not_running\", \"starting\", \"running\" Parameters: Name Type Description Default state str state to set required Exceptions: Type Description InvalidParamError invalid state Source code in prettyqt/core/process.py def set_state ( self , state : str ): \"\"\"Set the process state. possible values are \"not_running\", \"starting\", \"running\" Args: state: state to set Raises: InvalidParamError: invalid state \"\"\" if state not in PROCESS_STATES : raise InvalidParamError ( state , PROCESS_STATES ) self . setProcessState ( PROCESS_STATES [ state ]) regularexpression RegularExpression globalMatch ( self , * args , ** kwargs ) globalMatch(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it ) match ( self , text , offset = 0 , match_type = 'normal' , anchored = False ) match(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py def match ( self , text : str , offset : int = 0 , match_type : str = \"normal\" , anchored : bool = False , ) -> core . RegularExpressionMatch : if isinstance ( match_type , str ): match_type = MATCH_TYPES [ match_type ] if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , match_type , options ) return core . RegularExpressionMatch ( match ) settings Settings get_default_format () classmethod Return default settings format. possible values are \"native\", \"ini\" Returns: Type Description str default settings format Source code in prettyqt/core/settings.py @classmethod def get_default_format ( cls ) -> str : \"\"\"Return default settings format. possible values are \"native\", \"ini\" Returns: default settings format \"\"\" return FORMATS . inv [ cls . defaultFormat ()] get_scope ( self ) Return scope. possible values are \"user\", \"system\" Returns: Type Description str scope Source code in prettyqt/core/settings.py def get_scope ( self ) -> str : \"\"\"Return scope. possible values are \"user\", \"system\" Returns: scope \"\"\" return SCOPES . inv [ self . scope ()] group ( self , prefix ) Context manager for setting groups. Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py @contextlib . contextmanager def group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup () read_array ( self , prefix ) Context manager for reading arrays. Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray () set_default_format ( fmt ) classmethod Set the default format. possible values are \"native\", \"ini\" Parameters: Name Type Description Default fmt str the default format to use required Exceptions: Type Description InvalidParamError invalid format Source code in prettyqt/core/settings.py @classmethod def set_default_format ( cls , fmt : str ): \"\"\"Set the default format. possible values are \"native\", \"ini\" Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMATS : raise InvalidParamError ( fmt , FORMATS ) cls . setDefaultFormat ( FORMATS [ fmt ]) set_path ( fmt , scope , path ) classmethod Set the path to the settings file. Parameters: Name Type Description Default fmt str the default format to use required scope str the scope to use required Exceptions: Type Description InvalidParamError invalid format or scope Source code in prettyqt/core/settings.py @classmethod def set_path ( cls , fmt : str , scope : str , path : Union [ str , pathlib . Path ]): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMATS : raise InvalidParamError ( fmt , FORMATS ) if scope not in SCOPES : raise InvalidParamError ( scope , SCOPES ) cls . setPath ( FORMATS [ fmt ], SCOPES [ scope ], str ( path )) write_array ( self , prefix , size =- 1 ) Context manager for writing arrays. Parameters: Name Type Description Default prefix str prefix for settings array required size int size of settings array -1 Source code in prettyqt/core/settings.py @contextlib . contextmanager def write_array ( self , prefix : str , size : int = - 1 ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" self . beginWriteArray ( prefix , size ) yield None self . endArray () size Size __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/size.py def __reduce__ ( self ): return ( self . __class__ , ( self . width (), self . height ())) state State get_child_mode ( self ) Return current child mode. Possible values: \"exclusive\", \"parallel\" Returns: Type Description str child mode Source code in prettyqt/core/state.py def get_child_mode ( self ) -> str : \"\"\"Return current child mode. Possible values: \"exclusive\", \"parallel\" Returns: child mode \"\"\" return CHILD_MODES . inv [ self . childMode ()] set_child_mode ( self , mode ) Set child mode to use. Allowed values are \"exclusive\", \"parallel\" Parameters: Name Type Description Default mode str child mode to use required Exceptions: Type Description InvalidParamError child mode does not exist Source code in prettyqt/core/state.py def set_child_mode ( self , mode : str ): \"\"\"Set child mode to use. Allowed values are \"exclusive\", \"parallel\" Args: mode: child mode to use Raises: InvalidParamError: child mode does not exist \"\"\" if mode not in CHILD_MODES : raise InvalidParamError ( mode , CHILD_MODES ) self . setChildMode ( CHILD_MODES [ mode ]) time Time __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/time.py def __reduce__ ( self ): return ( self . __class__ , ( self . hour (), self . minute (), self . second (), self . msec ())) timer Timer get_type ( self ) Return current timer type. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str timer type Source code in prettyqt/core/timer.py def get_type ( self ) -> str : \"\"\"Return current timer type. Possible values: \"horizontal\", \"vertical\" Returns: timer type \"\"\" return TYPES . inv [ self . timerType ()] set_type ( self , typ ) Set the timer type. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default typ str timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/timer.py def set_type ( self , typ : str ): \"\"\"Set the timer type. Allowed values are \"horizontal\", \"vertical\" Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in TYPES : raise InvalidParamError ( typ , TYPES ) self . setTimerType ( TYPES [ typ ]) url Url to_path ( self ) Get pathlib object from the URL. Returns: Type Description Path Path Source code in prettyqt/core/url.py def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self )) versionnumber VersionNumber major ( self ) An integer representing the major version. Source code in prettyqt/core/versionnumber.py def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion () micro ( self ) An integer representing the micro version. Source code in prettyqt/core/versionnumber.py def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion () minor ( self ) An integer representing the minor version. Source code in prettyqt/core/versionnumber.py def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion ()","title":"core"},{"location":"api/core.html#core-module","text":"","title":"core module"},{"location":"api/core.html#prettyqt.core","text":"Core module. Contains QtCore-based classes","title":"prettyqt.core"},{"location":"api/core.html#prettyqt.core.abstractanimation","text":"","title":"abstractanimation"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation","text":"","title":"AbstractAnimation"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.get_direction","text":"Get the current animation direction. Possible values: \"forward\", \"backward\" Returns: Type Description str animation direction Source code in prettyqt/core/abstractanimation.py def get_direction ( self ) -> str : \"\"\"Get the current animation direction. Possible values: \"forward\", \"backward\" Returns: animation direction \"\"\" return DIRECTIONS . inv [ self . direction ()]","title":"get_direction()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.get_state","text":"Get the current animation state. Possible values: \"stopped\", \"paused\", \"running\" Returns: Type Description str animation state Source code in prettyqt/core/abstractanimation.py def get_state ( self ) -> str : \"\"\"Get the current animation state. Possible values: \"stopped\", \"paused\", \"running\" Returns: animation state \"\"\" return STATES . inv [ self . state ()]","title":"get_state()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.set_direction","text":"Set animation direction. Valid values: \"forward\", \"backward\" Parameters: Name Type Description Default direction str animation direction required Exceptions: Type Description InvalidParamError animation direction does not exist Source code in prettyqt/core/abstractanimation.py def set_direction ( self , direction : str ): \"\"\"Set animation direction. Valid values: \"forward\", \"backward\" Args: direction: animation direction Raises: InvalidParamError: animation direction does not exist \"\"\" if direction not in DIRECTIONS : raise InvalidParamError ( direction , DIRECTIONS ) self . setDirection ( DIRECTIONS [ direction ])","title":"set_direction()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.start_animation","text":"Start the animation. Valid values for policy: \"keep\", \"delete\" Parameters: Name Type Description Default policy str animation policy required Exceptions: Type Description InvalidParamError animation policy does not exist Source code in prettyqt/core/abstractanimation.py def start_animation ( self , policy : str ): \"\"\"Start the animation. Valid values for policy: \"keep\", \"delete\" Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" if policy not in DELETION_POLICIES : raise InvalidParamError ( policy , DELETION_POLICIES ) self . start ( DELETION_POLICIES [ policy ])","title":"start_animation()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel","text":"","title":"abstractitemmodel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel","text":"","title":"AbstractItemModel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.__len__","text":"Return amount of rows. Source code in prettyqt/core/abstractitemmodel.py def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.change_layout","text":"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit ()","title":"change_layout()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.reset_model","text":"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel ()","title":"reset_model()"},{"location":"api/core.html#prettyqt.core.abstracttransition","text":"","title":"abstracttransition"},{"location":"api/core.html#prettyqt.core.abstracttransition.AbstractTransition","text":"","title":"AbstractTransition"},{"location":"api/core.html#prettyqt.core.abstracttransition.AbstractTransition.get_transition_type","text":"Return current transition type. Possible values: \"exclusive\", \"parallel\" Returns: Type Description str transition type Source code in prettyqt/core/abstracttransition.py def get_transition_type ( self ) -> str : \"\"\"Return current transition type. Possible values: \"exclusive\", \"parallel\" Returns: transition type \"\"\" return TRANSITION_TYPES . inv [ self . transitionType ()]","title":"get_transition_type()"},{"location":"api/core.html#prettyqt.core.abstracttransition.AbstractTransition.set_transition_type","text":"Set transition type. Allowed values are \"exclusive\", \"parallel\" Parameters: Name Type Description Default typ str transition type to use required Exceptions: Type Description InvalidParamError transition type does not exist Source code in prettyqt/core/abstracttransition.py def set_transition_type ( self , typ : str ): \"\"\"Set transition type. Allowed values are \"exclusive\", \"parallel\" Args: typ: transition type to use Raises: InvalidParamError: transition type does not exist \"\"\" if typ not in TRANSITION_TYPES : raise InvalidParamError ( typ , TRANSITION_TYPES ) self . setTransitionType ( TRANSITION_TYPES [ typ ])","title":"set_transition_type()"},{"location":"api/core.html#prettyqt.core.bytearray","text":"","title":"bytearray"},{"location":"api/core.html#prettyqt.core.bytearray.ByteArray","text":"","title":"ByteArray"},{"location":"api/core.html#prettyqt.core.bytearray.ByteArray.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/bytearray.py def __reduce__ ( self ): return ( self . __class__ , ( bytes ( self ),))","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.datastream","text":"","title":"datastream"},{"location":"api/core.html#prettyqt.core.datastream.DataStream","text":"","title":"DataStream"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_byte_order","text":"Return byte order. possible values are \"big_endian\", \"little_endian\" Returns: Type Description bool byte order Source code in prettyqt/core/datastream.py def get_byte_order ( self ) -> bool : \"\"\"Return byte order. possible values are \"big_endian\", \"little_endian\" Returns: byte order \"\"\" return BYTE_ORDER . inv [ self . byteOrder ()]","title":"get_byte_order()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_float_precision","text":"Return floating point precision. possible values are \"single\", \"double\" Returns: Type Description bool floating point precision Source code in prettyqt/core/datastream.py def get_float_precision ( self ) -> bool : \"\"\"Return floating point precision. possible values are \"single\", \"double\" Returns: floating point precision \"\"\" return FLOAT_PRECISION . inv [ self . floatingPointPrecision ()]","title":"get_float_precision()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_byte_order","text":"Set byte order. valid values are: \"big_endian\", \"little endian\" Parameters: Name Type Description Default order str byte order to use required Exceptions: Type Description InvalidParamError invalid order Source code in prettyqt/core/datastream.py def set_byte_order ( self , order : str ): \"\"\"Set byte order. valid values are: \"big_endian\", \"little endian\" Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ])","title":"set_byte_order()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_float_precision","text":"Set floating point precision. valid values are: \"single\", \"double\" Parameters: Name Type Description Default precision str floating point precision required Exceptions: Type Description InvalidParamError invalid precision Source code in prettyqt/core/datastream.py def set_float_precision ( self , precision : str ): \"\"\"Set floating point precision. valid values are: \"single\", \"double\" Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOAT_PRECISION : raise InvalidParamError ( precision , FLOAT_PRECISION ) self . setFloatingPointPrecision ( FLOAT_PRECISION [ precision ])","title":"set_float_precision()"},{"location":"api/core.html#prettyqt.core.date","text":"","title":"date"},{"location":"api/core.html#prettyqt.core.date.Date","text":"","title":"Date"},{"location":"api/core.html#prettyqt.core.date.Date.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/date.py def __reduce__ ( self ): return ( self . __class__ , ( self . year (), self . month (), self . day ()))","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.datetime","text":"","title":"datetime"},{"location":"api/core.html#prettyqt.core.datetime.DateTime","text":"","title":"DateTime"},{"location":"api/core.html#prettyqt.core.datetime.DateTime.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/datetime.py def __reduce__ ( self ): return ( self . __class__ , ( self . date (), self . time ()))","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.datetime.DateTime.get_time_spec","text":"Return current time specification. Possible values: \"local_time\", \"utc\", \"offset_from_utc\", \"timezone\" Returns: Type Description str time specification Source code in prettyqt/core/datetime.py def get_time_spec ( self ) -> str : \"\"\"Return current time specification. Possible values: \"local_time\", \"utc\", \"offset_from_utc\", \"timezone\" Returns: time specification \"\"\" return TIME_SPECS . inv [ self . timeSpec ()]","title":"get_time_spec()"},{"location":"api/core.html#prettyqt.core.datetime.DateTime.set_time_spec","text":"Set the time specification. Allowed values are \"local_time\", \"utc\", \"offset_from_utc\", \"timezone\" Parameters: Name Type Description Default mode time specification to use required Exceptions: Type Description InvalidParamError time specification does not exist Source code in prettyqt/core/datetime.py def set_time_spec ( self , spec : str ): \"\"\"Set the time specification. Allowed values are \"local_time\", \"utc\", \"offset_from_utc\", \"timezone\" Args: mode: time specification to use Raises: InvalidParamError: time specification does not exist \"\"\" if spec not in TIME_SPECS : raise InvalidParamError ( spec , TIME_SPECS ) self . setTimeSpec ( TIME_SPECS [ spec ])","title":"set_time_spec()"},{"location":"api/core.html#prettyqt.core.easingcurve","text":"","title":"easingcurve"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve","text":"","title":"EasingCurve"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.get_type","text":"Get the current easing curve type. Possible values: \"linear\", \"in_quad\", \"out_quad\", \"in_out_quad\", \"out_in_quad\", \"in_cubic\", \"out_cubic\", \"in_out_cubic\", \"out_in_cubic\", \"in_quart\", \"out_quart\", \"in_out_quart\", \"out_in_quart\", \"in_quint\", \"out_quint\", \"in_out_quint\", \"out_in_quint\", \"in_sine\", \"out_sine\", \"in_out_sine\", \"out_in_sine\", \"in_expo\", \"out_expo\", \"in_out_expo\", \"out_in_expo\", \"in_circ\", \"out_circ\", \"in_out_circ\", \"out_in_circ\", \"in_elastic\", \"out_elastic\", \"in_out_elastic\", \"out_in_elastic\", \"in_back\", \"out_back\", \"in_out_back\", \"out_in_back\", \"in_bounce\", \"out_bounce\", \"in_out_bounce\", \"out_in_bounce\", \"bezier_spline\", \"tcb_spline\", \"custom\" Returns: Type Description str easing curve type Source code in prettyqt/core/easingcurve.py def get_type ( self ) -> str : \"\"\"Get the current easing curve type. Possible values: \"linear\", \"in_quad\", \"out_quad\", \"in_out_quad\", \"out_in_quad\", \"in_cubic\", \"out_cubic\", \"in_out_cubic\", \"out_in_cubic\", \"in_quart\", \"out_quart\", \"in_out_quart\", \"out_in_quart\", \"in_quint\", \"out_quint\", \"in_out_quint\", \"out_in_quint\", \"in_sine\", \"out_sine\", \"in_out_sine\", \"out_in_sine\", \"in_expo\", \"out_expo\", \"in_out_expo\", \"out_in_expo\", \"in_circ\", \"out_circ\", \"in_out_circ\", \"out_in_circ\", \"in_elastic\", \"out_elastic\", \"in_out_elastic\", \"out_in_elastic\", \"in_back\", \"out_back\", \"in_out_back\", \"out_in_back\", \"in_bounce\", \"out_bounce\", \"in_out_bounce\", \"out_in_bounce\", \"bezier_spline\", \"tcb_spline\", \"custom\" Returns: easing curve type \"\"\" return TYPES . inv [ self . type ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.set_type","text":"Set easing curve type. Valid values for modality: \"linear\", \"in_quad\", \"out_quad\", \"in_out_quad\", \"out_in_quad\", \"in_cubic\", \"out_cubic\", \"in_out_cubic\", \"out_in_cubic\", \"in_quart\", \"out_quart\", \"in_out_quart\", \"out_in_quart\", \"in_quint\", \"out_quint\", \"in_out_quint\", \"out_in_quint\", \"in_sine\", \"out_sine\", \"in_out_sine\", \"out_in_sine\", \"in_expo\", \"out_expo\", \"in_out_expo\", \"out_in_expo\", \"in_circ\", \"out_circ\", \"in_out_circ\", \"out_in_circ\", \"in_elastic\", \"out_elastic\", \"in_out_elastic\", \"out_in_elastic\", \"in_back\", \"out_back\", \"in_out_back\", \"out_in_back\", \"in_bounce\", \"out_bounce\", \"in_out_bounce\", \"out_in_bounce\", \"bezier_spline\", \"tcb_spline\", \"custom\" Parameters: Name Type Description Default type easing curve type required Exceptions: Type Description InvalidParamError easing curve type does not exist Source code in prettyqt/core/easingcurve.py def set_type ( self , typ : str ): \"\"\"Set easing curve type. Valid values for modality: \"linear\", \"in_quad\", \"out_quad\", \"in_out_quad\", \"out_in_quad\", \"in_cubic\", \"out_cubic\", \"in_out_cubic\", \"out_in_cubic\", \"in_quart\", \"out_quart\", \"in_out_quart\", \"out_in_quart\", \"in_quint\", \"out_quint\", \"in_out_quint\", \"out_in_quint\", \"in_sine\", \"out_sine\", \"in_out_sine\", \"out_in_sine\", \"in_expo\", \"out_expo\", \"in_out_expo\", \"out_in_expo\", \"in_circ\", \"out_circ\", \"in_out_circ\", \"out_in_circ\", \"in_elastic\", \"out_elastic\", \"in_out_elastic\", \"out_in_elastic\", \"in_back\", \"out_back\", \"in_out_back\", \"out_in_back\", \"in_bounce\", \"out_bounce\", \"in_out_bounce\", \"out_in_bounce\", \"bezier_spline\", \"tcb_spline\", \"custom\" Args: type: easing curve type Raises: InvalidParamError: easing curve type does not exist \"\"\" if typ not in TYPES : raise InvalidParamError ( typ , TYPES ) self . setType ( TYPES [ typ ])","title":"set_type()"},{"location":"api/core.html#prettyqt.core.filedevice","text":"","title":"filedevice"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice","text":"","title":"FileDevice"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice.get_file_time","text":"Return current file time. Possible values: \"access\", \"birth\", \"metadata_change\", \"modification\" Returns: Type Description Optional[datetime.datetime] file time Source code in prettyqt/core/filedevice.py def get_file_time ( self , typ : str ) -> Optional [ datetime . datetime ]: \"\"\"Return current file time. Possible values: \"access\", \"birth\", \"metadata_change\", \"modification\" Returns: file time \"\"\" if typ not in FILE_TIMES : raise InvalidParamError ( typ , FILE_TIMES ) date = self . fileTime ( FILE_TIMES [ typ ]) if not date : return None return to_datetime ( date )","title":"get_file_time()"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice.set_file_time","text":"Set file time. Allowed values are \"access\", \"birth\", \"metadata_change\", \"modification\" Parameters: Name Type Description Default typ str file time to use required Exceptions: Type Description InvalidParamError file time does not exist Source code in prettyqt/core/filedevice.py def set_file_time ( self , file_time : Union [ QtCore . QDateTime , datetime . datetime ], typ : str ) -> bool : \"\"\"Set file time. Allowed values are \"access\", \"birth\", \"metadata_change\", \"modification\" Args: typ: file time to use Raises: InvalidParamError: file time does not exist \"\"\" if typ not in FILE_TIMES : raise InvalidParamError ( typ , FILE_TIMES ) return self . setFileTime ( file_time , FILE_TIMES [ typ ])","title":"set_file_time()"},{"location":"api/core.html#prettyqt.core.historystate","text":"","title":"historystate"},{"location":"api/core.html#prettyqt.core.historystate.HistoryState","text":"","title":"HistoryState"},{"location":"api/core.html#prettyqt.core.historystate.HistoryState.get_history_type","text":"Return current history type. Possible values: \"shallow\", \"deep\" Returns: Type Description str history type Source code in prettyqt/core/historystate.py def get_history_type ( self ) -> str : \"\"\"Return current history type. Possible values: \"shallow\", \"deep\" Returns: history type \"\"\" return HISTORY_TYPES . inv [ self . historyType ()]","title":"get_history_type()"},{"location":"api/core.html#prettyqt.core.historystate.HistoryState.set_history_type","text":"Set history type to use. Allowed values are \"shallow\", \"deep\" Parameters: Name Type Description Default typ str history type to use required Exceptions: Type Description InvalidParamError history type does not exist Source code in prettyqt/core/historystate.py def set_history_type ( self , typ : str ): \"\"\"Set history type to use. Allowed values are \"shallow\", \"deep\" Args: typ: history type to use Raises: InvalidParamError: history type does not exist \"\"\" if typ not in HISTORY_TYPES : raise InvalidParamError ( typ , HISTORY_TYPES ) self . setHistoryType ( HISTORY_TYPES [ typ ])","title":"set_history_type()"},{"location":"api/core.html#prettyqt.core.process","text":"","title":"process"},{"location":"api/core.html#prettyqt.core.process.Process","text":"","title":"Process"},{"location":"api/core.html#prettyqt.core.process.Process.set_input_channel_mode","text":"Set the input channel mode. possible values are \"managed\", \"forward\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_input_channel_mode ( self , mode : str ): \"\"\"Set the input channel mode. possible values are \"managed\", \"forward\" Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in INPUT_CHANNEL_MODES : raise InvalidParamError ( mode , INPUT_CHANNEL_MODES ) self . setInputChannelMode ( INPUT_CHANNEL_MODES [ mode ])","title":"set_input_channel_mode()"},{"location":"api/core.html#prettyqt.core.process.Process.set_process_channel_mode","text":"Set the process channel mode. possible values are \"separate\", \"merged\", \"forwarded\", \"forwarded_error\", \"forwarded_output\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_process_channel_mode ( self , mode : str ): \"\"\"Set the process channel mode. possible values are \"separate\", \"merged\", \"forwarded\", \"forwarded_error\", \"forwarded_output\" Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in PROCESS_CHANNEL_MODES : raise InvalidParamError ( mode , PROCESS_CHANNEL_MODES ) self . setProcessChannelMode ( PROCESS_CHANNEL_MODES [ mode ])","title":"set_process_channel_mode()"},{"location":"api/core.html#prettyqt.core.process.Process.set_read_channel","text":"Set the input channel channel. possible values are \"managed\", \"forwarded\" Parameters: Name Type Description Default channel str channel to set required Exceptions: Type Description InvalidParamError invalid channel Source code in prettyqt/core/process.py def set_read_channel ( self , channel : str ): \"\"\"Set the input channel channel. possible values are \"managed\", \"forwarded\" Args: channel: channel to set Raises: InvalidParamError: invalid channel \"\"\" if channel not in PROCESS_CHANNELS : raise InvalidParamError ( channel , PROCESS_CHANNELS ) self . setReadChannel ( PROCESS_CHANNELS [ channel ])","title":"set_read_channel()"},{"location":"api/core.html#prettyqt.core.process.Process.set_state","text":"Set the process state. possible values are \"not_running\", \"starting\", \"running\" Parameters: Name Type Description Default state str state to set required Exceptions: Type Description InvalidParamError invalid state Source code in prettyqt/core/process.py def set_state ( self , state : str ): \"\"\"Set the process state. possible values are \"not_running\", \"starting\", \"running\" Args: state: state to set Raises: InvalidParamError: invalid state \"\"\" if state not in PROCESS_STATES : raise InvalidParamError ( state , PROCESS_STATES ) self . setProcessState ( PROCESS_STATES [ state ])","title":"set_state()"},{"location":"api/core.html#prettyqt.core.regularexpression","text":"","title":"regularexpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression","text":"","title":"RegularExpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.globalMatch","text":"globalMatch(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it )","title":"globalMatch()"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.match","text":"match(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py def match ( self , text : str , offset : int = 0 , match_type : str = \"normal\" , anchored : bool = False , ) -> core . RegularExpressionMatch : if isinstance ( match_type , str ): match_type = MATCH_TYPES [ match_type ] if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , match_type , options ) return core . RegularExpressionMatch ( match )","title":"match()"},{"location":"api/core.html#prettyqt.core.settings","text":"","title":"settings"},{"location":"api/core.html#prettyqt.core.settings.Settings","text":"","title":"Settings"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_default_format","text":"Return default settings format. possible values are \"native\", \"ini\" Returns: Type Description str default settings format Source code in prettyqt/core/settings.py @classmethod def get_default_format ( cls ) -> str : \"\"\"Return default settings format. possible values are \"native\", \"ini\" Returns: default settings format \"\"\" return FORMATS . inv [ cls . defaultFormat ()]","title":"get_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_scope","text":"Return scope. possible values are \"user\", \"system\" Returns: Type Description str scope Source code in prettyqt/core/settings.py def get_scope ( self ) -> str : \"\"\"Return scope. possible values are \"user\", \"system\" Returns: scope \"\"\" return SCOPES . inv [ self . scope ()]","title":"get_scope()"},{"location":"api/core.html#prettyqt.core.settings.Settings.group","text":"Context manager for setting groups. Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py @contextlib . contextmanager def group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup ()","title":"group()"},{"location":"api/core.html#prettyqt.core.settings.Settings.read_array","text":"Context manager for reading arrays. Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray ()","title":"read_array()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_default_format","text":"Set the default format. possible values are \"native\", \"ini\" Parameters: Name Type Description Default fmt str the default format to use required Exceptions: Type Description InvalidParamError invalid format Source code in prettyqt/core/settings.py @classmethod def set_default_format ( cls , fmt : str ): \"\"\"Set the default format. possible values are \"native\", \"ini\" Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMATS : raise InvalidParamError ( fmt , FORMATS ) cls . setDefaultFormat ( FORMATS [ fmt ])","title":"set_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_path","text":"Set the path to the settings file. Parameters: Name Type Description Default fmt str the default format to use required scope str the scope to use required Exceptions: Type Description InvalidParamError invalid format or scope Source code in prettyqt/core/settings.py @classmethod def set_path ( cls , fmt : str , scope : str , path : Union [ str , pathlib . Path ]): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMATS : raise InvalidParamError ( fmt , FORMATS ) if scope not in SCOPES : raise InvalidParamError ( scope , SCOPES ) cls . setPath ( FORMATS [ fmt ], SCOPES [ scope ], str ( path ))","title":"set_path()"},{"location":"api/core.html#prettyqt.core.settings.Settings.write_array","text":"Context manager for writing arrays. Parameters: Name Type Description Default prefix str prefix for settings array required size int size of settings array -1 Source code in prettyqt/core/settings.py @contextlib . contextmanager def write_array ( self , prefix : str , size : int = - 1 ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" self . beginWriteArray ( prefix , size ) yield None self . endArray ()","title":"write_array()"},{"location":"api/core.html#prettyqt.core.size","text":"","title":"size"},{"location":"api/core.html#prettyqt.core.size.Size","text":"","title":"Size"},{"location":"api/core.html#prettyqt.core.size.Size.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/size.py def __reduce__ ( self ): return ( self . __class__ , ( self . width (), self . height ()))","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.state","text":"","title":"state"},{"location":"api/core.html#prettyqt.core.state.State","text":"","title":"State"},{"location":"api/core.html#prettyqt.core.state.State.get_child_mode","text":"Return current child mode. Possible values: \"exclusive\", \"parallel\" Returns: Type Description str child mode Source code in prettyqt/core/state.py def get_child_mode ( self ) -> str : \"\"\"Return current child mode. Possible values: \"exclusive\", \"parallel\" Returns: child mode \"\"\" return CHILD_MODES . inv [ self . childMode ()]","title":"get_child_mode()"},{"location":"api/core.html#prettyqt.core.state.State.set_child_mode","text":"Set child mode to use. Allowed values are \"exclusive\", \"parallel\" Parameters: Name Type Description Default mode str child mode to use required Exceptions: Type Description InvalidParamError child mode does not exist Source code in prettyqt/core/state.py def set_child_mode ( self , mode : str ): \"\"\"Set child mode to use. Allowed values are \"exclusive\", \"parallel\" Args: mode: child mode to use Raises: InvalidParamError: child mode does not exist \"\"\" if mode not in CHILD_MODES : raise InvalidParamError ( mode , CHILD_MODES ) self . setChildMode ( CHILD_MODES [ mode ])","title":"set_child_mode()"},{"location":"api/core.html#prettyqt.core.time","text":"","title":"time"},{"location":"api/core.html#prettyqt.core.time.Time","text":"","title":"Time"},{"location":"api/core.html#prettyqt.core.time.Time.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/time.py def __reduce__ ( self ): return ( self . __class__ , ( self . hour (), self . minute (), self . second (), self . msec ()))","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.timer","text":"","title":"timer"},{"location":"api/core.html#prettyqt.core.timer.Timer","text":"","title":"Timer"},{"location":"api/core.html#prettyqt.core.timer.Timer.get_type","text":"Return current timer type. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str timer type Source code in prettyqt/core/timer.py def get_type ( self ) -> str : \"\"\"Return current timer type. Possible values: \"horizontal\", \"vertical\" Returns: timer type \"\"\" return TYPES . inv [ self . timerType ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.timer.Timer.set_type","text":"Set the timer type. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default typ str timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/timer.py def set_type ( self , typ : str ): \"\"\"Set the timer type. Allowed values are \"horizontal\", \"vertical\" Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in TYPES : raise InvalidParamError ( typ , TYPES ) self . setTimerType ( TYPES [ typ ])","title":"set_type()"},{"location":"api/core.html#prettyqt.core.url","text":"","title":"url"},{"location":"api/core.html#prettyqt.core.url.Url","text":"","title":"Url"},{"location":"api/core.html#prettyqt.core.url.Url.to_path","text":"Get pathlib object from the URL. Returns: Type Description Path Path Source code in prettyqt/core/url.py def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self ))","title":"to_path()"},{"location":"api/core.html#prettyqt.core.versionnumber","text":"","title":"versionnumber"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber","text":"","title":"VersionNumber"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.major","text":"An integer representing the major version. Source code in prettyqt/core/versionnumber.py def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion ()","title":"major()"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.micro","text":"An integer representing the micro version. Source code in prettyqt/core/versionnumber.py def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion ()","title":"micro()"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.minor","text":"An integer representing the minor version. Source code in prettyqt/core/versionnumber.py def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion ()","title":"minor()"},{"location":"api/custom_delegates.html","text":"custom_delegates module Module containing custom delegate classes. buttondelegate ButtonDelegate createEditor ( self , parent , option , index ) createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/buttondelegate.py def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn setEditorData ( self , editor , index ) setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setEditorData ( self , editor , index ): pass setModelData ( self , editor , model , index ) setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setModelData ( self , editor , model , index ): pass checkboxdelegate CheckBoxDelegate Delegate that places a CheckBox in every cell. createEditor ( self , parent , option , index ) Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. Source code in prettyqt/custom_delegates/checkboxdelegate.py def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb setEditorData ( self , cb , index ) Override. set correct initial value for editor widget Source code in prettyqt/custom_delegates/checkboxdelegate.py def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection ) setModelData ( self , combo , model , index ) Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. Source code in prettyqt/custom_delegates/checkboxdelegate.py def setModelData ( self , combo , model , index ): \"\"\"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. \"\"\" dtype = self . dtypes [ combo . currentText ()] # s = model.data(index, model.DATA_ROLE) try : model . setData ( index , dtype , model . DTYPE_ROLE ) except ValueError as e : logger . error ( e ) icondelegate IconDelegate paint ( self , painter , option , index ) Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Parameters: Name Type Description Default painter QPainter painter to paint the icon required option QStyleOptionViewItem state of the item to be displayed required index QModelIndex index which gets decorated required Source code in prettyqt/custom_delegates/icondelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if value : margin = 10 mode = gui . Icon . Normal if not ( option . state & widgets . Style . State_Enabled ): mode = gui . Icon . Disabled elif option . state & widgets . Style . State_Selected : mode = gui . Icon . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QIcon ): state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) actualSize = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = core . Size ( min ( option . decorationSize . width (), actualSize . width ()), min ( option . decorationSize . height (), actualSize . height ()), ) r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) icon . paint ( painter , r , constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER , mode , state ) nofocusdelegate NoFocusDelegate paint ( self , painter , option , index ) paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/nofocusdelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . State_HasFocus : option . state = option . state ^ widgets . Style . State_HasFocus super () . paint ( painter , option , index ) radiodelegate RadioDelegate createEditor ( self , parent , option , index ) createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/radiodelegate.py def createEditor ( self , parent , option , index ): editor = widgets . Widget ( parent ) editor . setContentsMargins ( 0 , 0 , 0 , 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . buttonGroup = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . setFocusPolicy ( QtCore . Qt . NoFocus ) rb . installEventFilter ( self ) editor . buttonGroup . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) editor . installEventFilter ( self ) return editor eventFilter ( self , source , event ) eventFilter(self, QObject, QEvent) -> bool Source code in prettyqt/custom_delegates/radiodelegate.py def eventFilter ( self , source , event ): if event . type () == core . Event . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event ) setEditorData ( self , editor , index ) setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setEditorData ( self , editor , index ): value = index . data ( QtCore . Qt . DisplayRole ) if value in self . items : editor . buttonGroup . button ( self . items . index ( value )) . setChecked ( True ) setModelData ( self , editor , model , index ) setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setModelData ( self , editor , model , index ): button = editor . buttonGroup . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], QtCore . Qt . DisplayRole ) self . choices [ button ] = index . row () updateEditorGeometry ( self , editor , option , index ) updateEditorGeometry(self, QWidget, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def updateEditorGeometry ( self , editor , option , index ): rect = core . Rect ( option . rect ) minWidth = editor . minimumSizeHint () . width () if rect . width () < minWidth : rect . setWidth ( minWidth ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) editor . setMask ( mask )","title":"custom_delegates"},{"location":"api/custom_delegates.html#custom_delegates-module","text":"","title":"custom_delegates module"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates","text":"Module containing custom delegate classes.","title":"prettyqt.custom_delegates"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate","text":"","title":"buttondelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate","text":"","title":"ButtonDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.createEditor","text":"createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/buttondelegate.py def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setEditorData","text":"setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setEditorData ( self , editor , index ): pass","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setModelData","text":"setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setModelData ( self , editor , model , index ): pass","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate","text":"","title":"checkboxdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate","text":"Delegate that places a CheckBox in every cell.","title":"CheckBoxDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.createEditor","text":"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. Source code in prettyqt/custom_delegates/checkboxdelegate.py def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.setEditorData","text":"Override. set correct initial value for editor widget Source code in prettyqt/custom_delegates/checkboxdelegate.py def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection )","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.setModelData","text":"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. Source code in prettyqt/custom_delegates/checkboxdelegate.py def setModelData ( self , combo , model , index ): \"\"\"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. \"\"\" dtype = self . dtypes [ combo . currentText ()] # s = model.data(index, model.DATA_ROLE) try : model . setData ( index , dtype , model . DTYPE_ROLE ) except ValueError as e : logger . error ( e )","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate","text":"","title":"icondelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate","text":"","title":"IconDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate.paint","text":"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Parameters: Name Type Description Default painter QPainter painter to paint the icon required option QStyleOptionViewItem state of the item to be displayed required index QModelIndex index which gets decorated required Source code in prettyqt/custom_delegates/icondelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if value : margin = 10 mode = gui . Icon . Normal if not ( option . state & widgets . Style . State_Enabled ): mode = gui . Icon . Disabled elif option . state & widgets . Style . State_Selected : mode = gui . Icon . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QIcon ): state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) actualSize = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = core . Size ( min ( option . decorationSize . width (), actualSize . width ()), min ( option . decorationSize . height (), actualSize . height ()), ) r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) icon . paint ( painter , r , constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER , mode , state )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate","text":"","title":"nofocusdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate","text":"","title":"NoFocusDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate.paint","text":"paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/nofocusdelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . State_HasFocus : option . state = option . state ^ widgets . Style . State_HasFocus super () . paint ( painter , option , index )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate","text":"","title":"radiodelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate","text":"","title":"RadioDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.createEditor","text":"createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/radiodelegate.py def createEditor ( self , parent , option , index ): editor = widgets . Widget ( parent ) editor . setContentsMargins ( 0 , 0 , 0 , 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . buttonGroup = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . setFocusPolicy ( QtCore . Qt . NoFocus ) rb . installEventFilter ( self ) editor . buttonGroup . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) editor . installEventFilter ( self ) return editor","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.eventFilter","text":"eventFilter(self, QObject, QEvent) -> bool Source code in prettyqt/custom_delegates/radiodelegate.py def eventFilter ( self , source , event ): if event . type () == core . Event . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event )","title":"eventFilter()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setEditorData","text":"setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setEditorData ( self , editor , index ): value = index . data ( QtCore . Qt . DisplayRole ) if value in self . items : editor . buttonGroup . button ( self . items . index ( value )) . setChecked ( True )","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setModelData","text":"setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setModelData ( self , editor , model , index ): button = editor . buttonGroup . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], QtCore . Qt . DisplayRole ) self . choices [ button ] = index . row ()","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.updateEditorGeometry","text":"updateEditorGeometry(self, QWidget, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def updateEditorGeometry ( self , editor , option , index ): rect = core . Rect ( option . rect ) minWidth = editor . minimumSizeHint () . width () if rect . width () < minWidth : rect . setWidth ( minWidth ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) editor . setMask ( mask )","title":"updateEditorGeometry()"},{"location":"api/custom_models.html","text":"custom_models module Custom_models module. Contains custom models columnitemmodel ColumnItemModel Model that provides an interface to an objectree that is build of TreeItems. columnCount ( self , _parent = None ) Return the number of columns in the tree. Source code in prettyqt/custom_models/columnitemmodel.py def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols ) data ( self , index , role ) Return the tree item at the given index and role. Source code in prettyqt/custom_models/columnitemmodel.py def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: func = self . _attr_cols [ col ] . label if func is None : return \"\" attr = func ( tree_item ) return attr . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None flags ( self , index ) flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/custom_models/columnitemmodel.py def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE headerData ( self , section , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/columnitemmodel.py def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None regexmatchesmodel RegexMatchesModel columnCount ( self , parent = None ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER ) data ( self , index , role ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span () headerData ( self , offset , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] rowCount ( self , parent = None ) Required override for AbstractitemModels. Source code in prettyqt/custom_models/regexmatchesmodel.py def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches ) transposeproxymodel TransposeProxyModel columnCount ( self , parent =< PyQt5 . QtCore . QModelIndex object at 0x7f282e193250 > ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def columnCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . rowCount ( parent ) data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def data ( self , index : QtCore . QModelIndex , role = QtCore . Qt . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role ) headerData ( self , section , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def headerData ( self , section : int , orientation , role ): return self . _source_model . headerData ( section , orientation , role ) index ( self , row , column , parent = None ) index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def index ( self , row : int , column : int , parent = None ) -> QtCore . QModelIndex : return self . createIndex ( row , column ) mapFromSource ( self , source_index ) mapFromSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapFromSource ( self , source_index : QtCore . QModelIndex ) -> QtCore . QModelIndex : return self . index ( source_index . column (), source_index . row ()) mapToSource ( self , proxy_index ) mapToSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapToSource ( self , proxy_index : QtCore . QModelIndex ) -> QtCore . QModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ()) parent ( self , index ) parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/custom_models/transposeproxymodel.py def parent ( self , index : QtCore . QModelIndex ): return None rowCount ( self , parent =< PyQt5 . QtCore . QModelIndex object at 0x7f282e1931d0 > ) rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def rowCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . columnCount ( parent ) setSourceModel ( self , source_model ) setSourceModel(self, QAbstractItemModel) Source code in prettyqt/custom_models/transposeproxymodel.py def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"custom_models"},{"location":"api/custom_models.html#custom_models-module","text":"","title":"custom_models module"},{"location":"api/custom_models.html#prettyqt.custom_models","text":"Custom_models module. Contains custom models","title":"prettyqt.custom_models"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel","text":"","title":"columnitemmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel","text":"Model that provides an interface to an objectree that is build of TreeItems.","title":"ColumnItemModel"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.columnCount","text":"Return the number of columns in the tree. Source code in prettyqt/custom_models/columnitemmodel.py def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.data","text":"Return the tree item at the given index and role. Source code in prettyqt/custom_models/columnitemmodel.py def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: func = self . _attr_cols [ col ] . label if func is None : return \"\" attr = func ( tree_item ) return attr . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.flags","text":"flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/custom_models/columnitemmodel.py def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE","title":"flags()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/columnitemmodel.py def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel","text":"","title":"regexmatchesmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel","text":"","title":"RegexMatchesModel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span ()","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ]","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.rowCount","text":"Required override for AbstractitemModels. Source code in prettyqt/custom_models/regexmatchesmodel.py def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel","text":"","title":"transposeproxymodel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel","text":"","title":"TransposeProxyModel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def columnCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . rowCount ( parent )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.data","text":"data(self, QModelIndex, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def data ( self , index : QtCore . QModelIndex , role = QtCore . Qt . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role )","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def headerData ( self , section : int , orientation , role ): return self . _source_model . headerData ( section , orientation , role )","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.index","text":"index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def index ( self , row : int , column : int , parent = None ) -> QtCore . QModelIndex : return self . createIndex ( row , column )","title":"index()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapFromSource","text":"mapFromSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapFromSource ( self , source_index : QtCore . QModelIndex ) -> QtCore . QModelIndex : return self . index ( source_index . column (), source_index . row ())","title":"mapFromSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapToSource","text":"mapToSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapToSource ( self , proxy_index : QtCore . QModelIndex ) -> QtCore . QModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ())","title":"mapToSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.parent","text":"parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/custom_models/transposeproxymodel.py def parent ( self , index : QtCore . QModelIndex ): return None","title":"parent()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.rowCount","text":"rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def rowCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . columnCount ( parent )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.setSourceModel","text":"setSourceModel(self, QAbstractItemModel) Source code in prettyqt/custom_models/transposeproxymodel.py def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"setSourceModel()"},{"location":"api/custom_validators.html","text":"custom_validators module Custom_validators module. Contains custom validators compositevalidator CompositeValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/compositevalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] return ( min ( vals ), text , pos ) notemptyvalidator NotEmptyValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notemptyvalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos ) notzerovalidator NotZeroValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notzerovalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"0\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos ) pathvalidator PathValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/pathvalidator.py def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return ( self . Acceptable , text , pos ) return ( self . Intermediate , text , pos ) regexpatternvalidator RegexPatternValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexpatternvalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : self . compiled = re . compile ( text ) except sre_constants . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) except re . _regex_core . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) else : self . error_message = \"\" return ( self . Acceptable , text , pos ) regexvalidators BaseRegexValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexvalidators.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , partial = True ) if match is None : return ( self . Invalid , text , pos ) if match . partial : return ( self . Intermediate , text , pos ) else : return ( self . Acceptable , text , pos )","title":"custom_validators"},{"location":"api/custom_validators.html#custom_validators-module","text":"","title":"custom_validators module"},{"location":"api/custom_validators.html#prettyqt.custom_validators","text":"Custom_validators module. Contains custom validators","title":"prettyqt.custom_validators"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator","text":"","title":"compositevalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator","text":"","title":"CompositeValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/compositevalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] return ( min ( vals ), text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator","text":"","title":"notemptyvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator","text":"","title":"NotEmptyValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notemptyvalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator","text":"","title":"notzerovalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator","text":"","title":"NotZeroValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notzerovalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"0\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator","text":"","title":"pathvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator","text":"","title":"PathValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/pathvalidator.py def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return ( self . Acceptable , text , pos ) return ( self . Intermediate , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator","text":"","title":"regexpatternvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator","text":"","title":"RegexPatternValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexpatternvalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : self . compiled = re . compile ( text ) except sre_constants . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) except re . _regex_core . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) else : self . error_message = \"\" return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators","text":"","title":"regexvalidators"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator","text":"","title":"BaseRegexValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexvalidators.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , partial = True ) if match is None : return ( self . Invalid , text , pos ) if match . partial : return ( self . Intermediate , text , pos ) else : return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_widgets.html","text":"custom_widgets module Module containing custom widget classes. codeeditor CodeEditor resizeEvent ( self , event ) resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/codeeditor.py def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect ) LineNumberArea paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/codeeditor.py def paintEvent ( self , event ): self . editor . line_area_paintevent ( event ) sizeHint ( self ) sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/codeeditor.py def sizeHint ( self ): return core . Size ( self . editor . line_area_width (), 0 ) dataset DataItem set_pos ( self , col = 0 , colspan = None ) Set data item's position on a GUI layout. Source code in prettyqt/custom_widgets/dataset.py def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self DataSetMeta __new__ ( mcs , name , bases , dct ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct ) filechooserbutton FileChooserButton __init__ ( self , extensions = None , mode = 'save' , file_mode = 'existing_files' , root = None , parent = None ) special Initialize FileChooserButton. Parameters: Name Type Description Default extensions Optional[Dict[str, List[str]]] dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode str Accept mode (\"save\" or \"load\") 'save' file_mode str File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' root Union[NoneType, str, pathlib.Path] Root path None parent Optional[PyQt5.QtWidgets.QWidget] parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py def __init__ ( self , extensions : Optional [ Dict [ str , List [ str ]]] = None , mode : str = \"save\" , file_mode : str = \"existing_files\" , root : Union [ None , str , pathlib . Path ] = None , parent : Optional [ QtWidgets . QWidget ] = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : Optional [ pathlib . Path ] = None self . extensions = extensions self . mode = mode self . file_mode = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout += self . lineedit action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout += self . button flowlayout FlowLayout addItem ( self , item ) addItem(self, QLayoutItem) Source code in prettyqt/custom_widgets/flowlayout.py def addItem ( self , item : QtWidgets . QLayoutItem ): self . items . append ( item ) count ( self ) count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py def count ( self ) -> int : return len ( self . items ) expandingDirections ( self ) expandingDirections(self) -> Qt.Orientations Source code in prettyqt/custom_widgets/flowlayout.py def expandingDirections ( self ): return QtCore . Qt . Orientations ( QtCore . Qt . Orientation ( 0 )) hasHeightForWidth ( self ) hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py def hasHeightForWidth ( self ) -> bool : return True heightForWidth ( self , width ) heightForWidth(self, int) -> int Source code in prettyqt/custom_widgets/flowlayout.py def heightForWidth ( self , width : int ): return self . do_layout ( core . Rect ( 0 , 0 , width , 0 ), True ) itemAt ( self , index ) itemAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def itemAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: if 0 <= index < len ( self . items ): return self . items [ index ] return None minimumSize ( self ) minimumSize(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def minimumSize ( self ): size = core . Size () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += core . Size ( margin_width , margin_width ) return size setGeometry ( self , rect ) setGeometry(self, QRect) Source code in prettyqt/custom_widgets/flowlayout.py def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False ) sizeHint ( self ) sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def sizeHint ( self ) -> core . Size : return self . minimumSize () takeAt ( self , index ) takeAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def takeAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None labeledslider LabeledSlider paintEvent ( self , e ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/labeledslider.py def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () painter = gui . Painter ( self ) st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PM_SliderSpaceAvailable , st_slider , self . sl ) for v , v_str in self . levels : # get the size of the label rect = painter . drawText ( core . Rect (), QtCore . Qt . TextDontPrint , v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc if self . bottom_margin <= rect . height (): self . bottom_margin = rect . height () self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) painter . drawText ( left , bottom , v_str ) return popupinfo PopupInfo Dialog overlay to show some info to user. show ( self , * args , ** kwargs ) show(self) Source code in prettyqt/custom_widgets/popupinfo.py def show ( self , * args , ** kwargs ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) / 2 y = ( screen_geo . height () - size . height ()) / 2 self . move ( x , y - 200 ) super () . show ( * args , ** kwargs ) self . timer . start ( 2500 ) promptlineedit Credits to PyQode Authors. PromptLineEdit Extends QLineEdit to show a prompt text and a clear icon. prompt_text: str property writable Gets/Sets the prompt text. paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/promptlineedit.py def paintEvent ( self , event ): super () . paintEvent ( event ) if not ( self . _prompt_text and not self . text () and self . isEnabled ()): return None option = widgets . StyleOptionFrame () self . initStyleOption ( option ) left , top , right , bottom = self . getTextMargins () va = self . style () . visualAlignment ( self . layoutDirection (), self . alignment ()) rect = ( self . style () . subElementRect ( widgets . Style . SE_LineEditContents , option , self ) . adjusted ( 2 , 0 , 0 , 0 ) . adjusted ( left , top , - right , - bottom ) ) fm = self . font_metrics () text = fm . elided_text ( self . _prompt_text , mode = \"right\" , width = rect . width ()) with gui . Painter ( self ) as painter : color = self . get_palette () . get_color ( \"text\" , \"disabled\" ) painter . setPen ( color ) painter . drawText ( rect , va , text ) resizeEvent ( self , event ) resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/promptlineedit.py def resizeEvent ( self , event ): # Adjusts Clear button position super () . resizeEvent ( event ) self . button . resize ( self . _margin , self . height () - 2 ) self . button . move ( self . width () - self . _margin - 3 , 1 ) set_button_visible ( self , visible ) Sets the clear button as visible . Parameters: Name Type Description Default visible bool Visibility of button required Source code in prettyqt/custom_widgets/promptlineedit.py def set_button_visible ( self , visible : bool ): \"\"\"Sets the clear button as ``visible``. Args: visible (bool): Visibility of button \"\"\" self . button . setVisible ( visible ) left , top , right , bottom = self . getTextMargins () if visible : right = self . _margin + self . _spacing else : right = 0 self . setTextMargins ( left , top , right , bottom ) regexeditor special Module containing classes related to the RegEx editor. editor This module contains the editor widget implementation. quick_ref Contains the quick reference widget. spanslider SpanSlider mouseMoveEvent ( self , event ) mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PM_MaximumDragDistance , opt , self ) new_pos = self . _pixel_pos_to_value ( self . pick ( event . pos ()) - self . offset ) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . pos ()): new_pos = self . position # pick the preferred handle on the first movement if self . first_movement : if self . lower == self . upper : if new_pos < self . lower_value : self . _swap_controls () self . first_movement = False else : self . first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper - 1 ) if self . movement == \"free\" and new_pos > self . upper : self . _swap_controls () self . set_upper_pos ( new_pos ) else : self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower : self . _swap_controls () self . set_lower_pos ( new_pos ) else : self . set_upper_pos ( new_pos ) event . accept () mousePressEvent ( self , event ) mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . handle_mouse_press ( event . pos (), self . upper_pressed , self . upper , \"upper\" ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . handle_mouse_press ( event . pos (), self . lower_pressed , self . lower , \"lower\" ) self . first_movement = True event . accept () mouseReleaseEvent ( self , event ) mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SC_None self . update () paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/spanslider.py def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SC_SliderTickmarks painter . drawComplexControl ( SLIDER_STYLE , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . drawComplexControl ( SLIDER_STYLE , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () rect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) if self . is_horizontal (): rect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) self . _draw_span ( painter , rect ) # handles if self . last_pressed == \"lower\" : self . draw_handle ( painter , \"upper\" ) self . draw_handle ( painter , \"lower\" ) else : self . draw_handle ( painter , \"lower\" ) self . draw_handle ( painter , \"upper\" ) set_movement_mode ( self , mode ) Set movement mode. Valid values: \"no_crossing\", \"no_overlap\", \"free\" Parameters: Name Type Description Default modality modality for the main window required Exceptions: Type Description ValueError modality type does not exist Source code in prettyqt/custom_widgets/spanslider.py def set_movement_mode ( self , mode : str ): \"\"\"Set movement mode. Valid values: \"no_crossing\", \"no_overlap\", \"free\" Args: modality: modality for the main window Raises: ValueError: modality type does not exist \"\"\" if mode not in [ \"no_crossing\" , \"no_overlap\" , \"free\" ]: raise ValueError ( \"Invalid movement mode\" ) self . movement = mode trigger_action ( self , action , main ) Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Source code in prettyqt/custom_widgets/spanslider.py def trigger_action ( self , action : str , main : bool ): value = 0 no = False up = False my_min = self . minimum () my_max = self . maximum () self . block_tracking = True main_control = main and self . main_control == \"upper\" alt_control = not main and self . main_control == \"lower\" is_upper_handle = main_control or alt_control val = self . upper if is_upper_handle else self . lower if action == \"single_step_add\" : up = is_upper_handle value = clamp ( val + self . singleStep (), my_min , my_max ) elif action == \"single_step_sub\" : up = is_upper_handle value = clamp ( val - self . singleStep (), my_min , my_max ) elif action == \"to_minimum\" : value = my_min up = is_upper_handle elif action == \"to_maximum\" : value = my_max up = is_upper_handle elif action == \"move\" : up = is_upper_handle no = True elif action == \"none\" : no = True if not no and not up : if self . movement == \"no_crossing\" : value = min ( value , self . upper ) elif self . movement == \"no_overlap\" : value = min ( value , self . upper - 1 ) if self . movement == \"free\" and value > self . upper : self . _swap_controls () self . set_upper_pos ( value ) else : self . set_lower_pos ( value ) elif not no : if self . movement == \"no_crossing\" : value = max ( value , self . lower ) elif self . movement == \"no_overlap\" : value = max ( value , self . lower + 1 ) if self . movement == \"free\" and value < self . lower : self . _swap_controls () self . set_lower_pos ( value ) else : self . set_upper_pos ( value ) self . block_tracking = False self . set_lower_value ( self . lower_pos ) self . set_upper_value ( self . upper_pos ) timeline Timeline enterEvent ( self , e ) enterEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def enterEvent ( self , e ): self . is_in = True leaveEvent ( self , e ) leaveEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def leaveEvent ( self , e ): self . is_in = False self . update () mouseMoveEvent ( self , e ) mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseMoveEvent ( self , e ): self . pos = e . pos () # if mouse is being pressed, update pointer if self . clicking : x = self . pos . x () self . pointer_pos = x self . position_changed . emit ( x ) self . _check_selection ( x ) self . pointer_time_pos = self . pointer_pos * self . get_scale () self . update () mousePressEvent ( self , e ) mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mousePressEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : x = e . pos () . x () self . pointer_pos = x self . position_changed . emit ( x ) self . pointer_time_pos = self . pointer_pos * self . get_scale () self . _check_selection ( x ) self . update () self . clicking = True # Set clicking check to true mouseReleaseEvent ( self , e ) mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseReleaseEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : self . clicking = False # Set clicking check to false paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/timeline.py def paintEvent ( self , event ): qp = gui . Painter () w = 0 # Draw time scale = self . get_scale () with qp . paint_on ( self ): qp . set_color ( self . text_color ) qp . setFont ( self . font ) qp . use_antialiasing () while w <= self . width (): time_string = self . get_time_string ( w * scale ) qp . drawText ( w - 50 , 0 , 100 , 100 , QtCore . Qt . AlignHCenter , time_string ) w += 100 # Draw down line qp . set_pen ( color = PEN_COLOR , width = 5 ) qp . drawLine ( 0 , 40 , self . width (), 40 ) # Draw dash lines point = 0 qp . set_pen ( color = self . text_color ) qp . drawLine ( 0 , 40 , self . width (), 40 ) while point <= self . width (): y2 = 30 if point % 30 != 0 else 20 qp . drawLine ( 3 * point , 40 , 3 * point , y2 ) point += 10 if self . pos is not None and self . is_in : qp . drawLine ( self . pos . x (), 0 , self . pos . x (), 40 ) poly = gui . Polygon () if self . pointer_pos is not None : val = self . pointer_time_pos / self . get_scale () line = core . Line ( val , 40 , val , self . height ()) poly . add_points (( val - 10 , 20 ), ( val + 10 , 20 ), ( val , 40 )) else : line = core . Line ( 0 , 0 , 0 , self . height ()) poly . add_points (( - 10 , 20 ), ( 10 , 20 ), ( 0 , 40 )) # Draw samples t = 0 for sample in self . video_samples : scaled_dur = sample . duration / scale scaled_t = t / scale t += sample . duration # Clear clip path with qp . clip_path () as path : rect = core . RectF ( scaled_t , 50 , scaled_dur , 200 ) path . addRoundedRect ( rect , 10 , 10 ) # Draw sample path = gui . PainterPath () qp . set_pen ( color = sample . color ) rect = core . RectF ( scaled_t , 50 , scaled_dur , 50 ) path . addRoundedRect ( rect , 10 , 10 ) sample . start_pos = scaled_t sample . end_pos = scaled_t + scaled_dur qp . fillPath ( path , sample . color ) qp . drawPath ( path ) # Draw preview pictures if sample . picture is None : continue pic_width = sample . picture . size () . width () if pic_width < scaled_dur : width = pic_width pic = sample . picture else : width = scaled_dur pic = sample . picture . copy ( 0 , 0 , scaled_dur , 45 ) with qp . clip_path () as path : rect = core . RectF ( scaled_t , 52.5 , width , 45 ) path . addRoundedRect ( rect , 10 , 10 ) rect = core . Rect ( scaled_t , 52.5 , width , 45 ) qp . drawPixmap ( rect , pic ) # Clear clip path with qp . clip_path () as path : path . add_rect ( self . rect ()) # Draw pointer qp . set_color ( PEN_COLOR ) qp . set_brush ( PEN_COLOR ) qp . drawPolygon ( poly ) qp . drawLine ( line ) waitingspinner The MIT License (MIT). Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. BaseWaitingSpinner paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( style = \"none\" ) for i in range ( 0 , self . _line_num ): painter . save () painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length , ) rotate_angle = float ( 360 * i ) / float ( self . _line_num ) painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) rect = core . Rect ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . RelativeSize ) painter . restore () WaitingSpinner paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event )","title":"custom_widgets"},{"location":"api/custom_widgets.html#custom_widgets-module","text":"","title":"custom_widgets module"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets","text":"Module containing custom widget classes.","title":"prettyqt.custom_widgets"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor","text":"","title":"codeeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor","text":"","title":"CodeEditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor.resizeEvent","text":"resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/codeeditor.py def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea","text":"","title":"LineNumberArea"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/codeeditor.py def paintEvent ( self , event ): self . editor . line_area_paintevent ( event )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.sizeHint","text":"sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/codeeditor.py def sizeHint ( self ): return core . Size ( self . editor . line_area_width (), 0 )","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset","text":"","title":"dataset"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem","text":"","title":"DataItem"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem.set_pos","text":"Set data item's position on a GUI layout. Source code in prettyqt/custom_widgets/dataset.py def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self","title":"set_pos()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta","text":"","title":"DataSetMeta"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct )","title":"__new__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton","text":"","title":"filechooserbutton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton","text":"","title":"FileChooserButton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton.__init__","text":"Initialize FileChooserButton. Parameters: Name Type Description Default extensions Optional[Dict[str, List[str]]] dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode str Accept mode (\"save\" or \"load\") 'save' file_mode str File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' root Union[NoneType, str, pathlib.Path] Root path None parent Optional[PyQt5.QtWidgets.QWidget] parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py def __init__ ( self , extensions : Optional [ Dict [ str , List [ str ]]] = None , mode : str = \"save\" , file_mode : str = \"existing_files\" , root : Union [ None , str , pathlib . Path ] = None , parent : Optional [ QtWidgets . QWidget ] = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : Optional [ pathlib . Path ] = None self . extensions = extensions self . mode = mode self . file_mode = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout += self . lineedit action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout += self . button","title":"__init__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout","text":"","title":"flowlayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout","text":"","title":"FlowLayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.addItem","text":"addItem(self, QLayoutItem) Source code in prettyqt/custom_widgets/flowlayout.py def addItem ( self , item : QtWidgets . QLayoutItem ): self . items . append ( item )","title":"addItem()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.count","text":"count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py def count ( self ) -> int : return len ( self . items )","title":"count()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.expandingDirections","text":"expandingDirections(self) -> Qt.Orientations Source code in prettyqt/custom_widgets/flowlayout.py def expandingDirections ( self ): return QtCore . Qt . Orientations ( QtCore . Qt . Orientation ( 0 ))","title":"expandingDirections()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.hasHeightForWidth","text":"hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py def hasHeightForWidth ( self ) -> bool : return True","title":"hasHeightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.heightForWidth","text":"heightForWidth(self, int) -> int Source code in prettyqt/custom_widgets/flowlayout.py def heightForWidth ( self , width : int ): return self . do_layout ( core . Rect ( 0 , 0 , width , 0 ), True )","title":"heightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.itemAt","text":"itemAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def itemAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: if 0 <= index < len ( self . items ): return self . items [ index ] return None","title":"itemAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.minimumSize","text":"minimumSize(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def minimumSize ( self ): size = core . Size () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += core . Size ( margin_width , margin_width ) return size","title":"minimumSize()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.setGeometry","text":"setGeometry(self, QRect) Source code in prettyqt/custom_widgets/flowlayout.py def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False )","title":"setGeometry()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.sizeHint","text":"sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def sizeHint ( self ) -> core . Size : return self . minimumSize ()","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.takeAt","text":"takeAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def takeAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None","title":"takeAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider","text":"","title":"labeledslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider","text":"","title":"LabeledSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/labeledslider.py def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () painter = gui . Painter ( self ) st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PM_SliderSpaceAvailable , st_slider , self . sl ) for v , v_str in self . levels : # get the size of the label rect = painter . drawText ( core . Rect (), QtCore . Qt . TextDontPrint , v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc if self . bottom_margin <= rect . height (): self . bottom_margin = rect . height () self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) painter . drawText ( left , bottom , v_str ) return","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo","text":"","title":"popupinfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo","text":"Dialog overlay to show some info to user.","title":"PopupInfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo.show","text":"show(self) Source code in prettyqt/custom_widgets/popupinfo.py def show ( self , * args , ** kwargs ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) / 2 y = ( screen_geo . height () - size . height ()) / 2 self . move ( x , y - 200 ) super () . show ( * args , ** kwargs ) self . timer . start ( 2500 )","title":"show()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit","text":"Credits to PyQode Authors.","title":"promptlineedit"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit","text":"Extends QLineEdit to show a prompt text and a clear icon.","title":"PromptLineEdit"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.prompt_text","text":"Gets/Sets the prompt text.","title":"prompt_text"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/promptlineedit.py def paintEvent ( self , event ): super () . paintEvent ( event ) if not ( self . _prompt_text and not self . text () and self . isEnabled ()): return None option = widgets . StyleOptionFrame () self . initStyleOption ( option ) left , top , right , bottom = self . getTextMargins () va = self . style () . visualAlignment ( self . layoutDirection (), self . alignment ()) rect = ( self . style () . subElementRect ( widgets . Style . SE_LineEditContents , option , self ) . adjusted ( 2 , 0 , 0 , 0 ) . adjusted ( left , top , - right , - bottom ) ) fm = self . font_metrics () text = fm . elided_text ( self . _prompt_text , mode = \"right\" , width = rect . width ()) with gui . Painter ( self ) as painter : color = self . get_palette () . get_color ( \"text\" , \"disabled\" ) painter . setPen ( color ) painter . drawText ( rect , va , text )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.resizeEvent","text":"resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/promptlineedit.py def resizeEvent ( self , event ): # Adjusts Clear button position super () . resizeEvent ( event ) self . button . resize ( self . _margin , self . height () - 2 ) self . button . move ( self . width () - self . _margin - 3 , 1 )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.set_button_visible","text":"Sets the clear button as visible . Parameters: Name Type Description Default visible bool Visibility of button required Source code in prettyqt/custom_widgets/promptlineedit.py def set_button_visible ( self , visible : bool ): \"\"\"Sets the clear button as ``visible``. Args: visible (bool): Visibility of button \"\"\" self . button . setVisible ( visible ) left , top , right , bottom = self . getTextMargins () if visible : right = self . _margin + self . _spacing else : right = 0 self . setTextMargins ( left , top , right , bottom )","title":"set_button_visible()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor","text":"Module containing classes related to the RegEx editor.","title":"regexeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.editor","text":"This module contains the editor widget implementation.","title":"editor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.quick_ref","text":"Contains the quick reference widget.","title":"quick_ref"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider","text":"","title":"spanslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider","text":"","title":"SpanSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseMoveEvent","text":"mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PM_MaximumDragDistance , opt , self ) new_pos = self . _pixel_pos_to_value ( self . pick ( event . pos ()) - self . offset ) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . pos ()): new_pos = self . position # pick the preferred handle on the first movement if self . first_movement : if self . lower == self . upper : if new_pos < self . lower_value : self . _swap_controls () self . first_movement = False else : self . first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper - 1 ) if self . movement == \"free\" and new_pos > self . upper : self . _swap_controls () self . set_upper_pos ( new_pos ) else : self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower : self . _swap_controls () self . set_lower_pos ( new_pos ) else : self . set_upper_pos ( new_pos ) event . accept ()","title":"mouseMoveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mousePressEvent","text":"mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . handle_mouse_press ( event . pos (), self . upper_pressed , self . upper , \"upper\" ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . handle_mouse_press ( event . pos (), self . lower_pressed , self . lower , \"lower\" ) self . first_movement = True event . accept ()","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseReleaseEvent","text":"mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SC_None self . update ()","title":"mouseReleaseEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/spanslider.py def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SC_SliderTickmarks painter . drawComplexControl ( SLIDER_STYLE , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . drawComplexControl ( SLIDER_STYLE , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () rect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) if self . is_horizontal (): rect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) self . _draw_span ( painter , rect ) # handles if self . last_pressed == \"lower\" : self . draw_handle ( painter , \"upper\" ) self . draw_handle ( painter , \"lower\" ) else : self . draw_handle ( painter , \"lower\" ) self . draw_handle ( painter , \"upper\" )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.set_movement_mode","text":"Set movement mode. Valid values: \"no_crossing\", \"no_overlap\", \"free\" Parameters: Name Type Description Default modality modality for the main window required Exceptions: Type Description ValueError modality type does not exist Source code in prettyqt/custom_widgets/spanslider.py def set_movement_mode ( self , mode : str ): \"\"\"Set movement mode. Valid values: \"no_crossing\", \"no_overlap\", \"free\" Args: modality: modality for the main window Raises: ValueError: modality type does not exist \"\"\" if mode not in [ \"no_crossing\" , \"no_overlap\" , \"free\" ]: raise ValueError ( \"Invalid movement mode\" ) self . movement = mode","title":"set_movement_mode()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.trigger_action","text":"Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Source code in prettyqt/custom_widgets/spanslider.py def trigger_action ( self , action : str , main : bool ): value = 0 no = False up = False my_min = self . minimum () my_max = self . maximum () self . block_tracking = True main_control = main and self . main_control == \"upper\" alt_control = not main and self . main_control == \"lower\" is_upper_handle = main_control or alt_control val = self . upper if is_upper_handle else self . lower if action == \"single_step_add\" : up = is_upper_handle value = clamp ( val + self . singleStep (), my_min , my_max ) elif action == \"single_step_sub\" : up = is_upper_handle value = clamp ( val - self . singleStep (), my_min , my_max ) elif action == \"to_minimum\" : value = my_min up = is_upper_handle elif action == \"to_maximum\" : value = my_max up = is_upper_handle elif action == \"move\" : up = is_upper_handle no = True elif action == \"none\" : no = True if not no and not up : if self . movement == \"no_crossing\" : value = min ( value , self . upper ) elif self . movement == \"no_overlap\" : value = min ( value , self . upper - 1 ) if self . movement == \"free\" and value > self . upper : self . _swap_controls () self . set_upper_pos ( value ) else : self . set_lower_pos ( value ) elif not no : if self . movement == \"no_crossing\" : value = max ( value , self . lower ) elif self . movement == \"no_overlap\" : value = max ( value , self . lower + 1 ) if self . movement == \"free\" and value < self . lower : self . _swap_controls () self . set_lower_pos ( value ) else : self . set_upper_pos ( value ) self . block_tracking = False self . set_lower_value ( self . lower_pos ) self . set_upper_value ( self . upper_pos )","title":"trigger_action()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline","text":"","title":"timeline"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline","text":"","title":"Timeline"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.enterEvent","text":"enterEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def enterEvent ( self , e ): self . is_in = True","title":"enterEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.leaveEvent","text":"leaveEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def leaveEvent ( self , e ): self . is_in = False self . update ()","title":"leaveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mouseMoveEvent","text":"mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseMoveEvent ( self , e ): self . pos = e . pos () # if mouse is being pressed, update pointer if self . clicking : x = self . pos . x () self . pointer_pos = x self . position_changed . emit ( x ) self . _check_selection ( x ) self . pointer_time_pos = self . pointer_pos * self . get_scale () self . update ()","title":"mouseMoveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mousePressEvent","text":"mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mousePressEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : x = e . pos () . x () self . pointer_pos = x self . position_changed . emit ( x ) self . pointer_time_pos = self . pointer_pos * self . get_scale () self . _check_selection ( x ) self . update () self . clicking = True # Set clicking check to true","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mouseReleaseEvent","text":"mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseReleaseEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : self . clicking = False # Set clicking check to false","title":"mouseReleaseEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/timeline.py def paintEvent ( self , event ): qp = gui . Painter () w = 0 # Draw time scale = self . get_scale () with qp . paint_on ( self ): qp . set_color ( self . text_color ) qp . setFont ( self . font ) qp . use_antialiasing () while w <= self . width (): time_string = self . get_time_string ( w * scale ) qp . drawText ( w - 50 , 0 , 100 , 100 , QtCore . Qt . AlignHCenter , time_string ) w += 100 # Draw down line qp . set_pen ( color = PEN_COLOR , width = 5 ) qp . drawLine ( 0 , 40 , self . width (), 40 ) # Draw dash lines point = 0 qp . set_pen ( color = self . text_color ) qp . drawLine ( 0 , 40 , self . width (), 40 ) while point <= self . width (): y2 = 30 if point % 30 != 0 else 20 qp . drawLine ( 3 * point , 40 , 3 * point , y2 ) point += 10 if self . pos is not None and self . is_in : qp . drawLine ( self . pos . x (), 0 , self . pos . x (), 40 ) poly = gui . Polygon () if self . pointer_pos is not None : val = self . pointer_time_pos / self . get_scale () line = core . Line ( val , 40 , val , self . height ()) poly . add_points (( val - 10 , 20 ), ( val + 10 , 20 ), ( val , 40 )) else : line = core . Line ( 0 , 0 , 0 , self . height ()) poly . add_points (( - 10 , 20 ), ( 10 , 20 ), ( 0 , 40 )) # Draw samples t = 0 for sample in self . video_samples : scaled_dur = sample . duration / scale scaled_t = t / scale t += sample . duration # Clear clip path with qp . clip_path () as path : rect = core . RectF ( scaled_t , 50 , scaled_dur , 200 ) path . addRoundedRect ( rect , 10 , 10 ) # Draw sample path = gui . PainterPath () qp . set_pen ( color = sample . color ) rect = core . RectF ( scaled_t , 50 , scaled_dur , 50 ) path . addRoundedRect ( rect , 10 , 10 ) sample . start_pos = scaled_t sample . end_pos = scaled_t + scaled_dur qp . fillPath ( path , sample . color ) qp . drawPath ( path ) # Draw preview pictures if sample . picture is None : continue pic_width = sample . picture . size () . width () if pic_width < scaled_dur : width = pic_width pic = sample . picture else : width = scaled_dur pic = sample . picture . copy ( 0 , 0 , scaled_dur , 45 ) with qp . clip_path () as path : rect = core . RectF ( scaled_t , 52.5 , width , 45 ) path . addRoundedRect ( rect , 10 , 10 ) rect = core . Rect ( scaled_t , 52.5 , width , 45 ) qp . drawPixmap ( rect , pic ) # Clear clip path with qp . clip_path () as path : path . add_rect ( self . rect ()) # Draw pointer qp . set_color ( PEN_COLOR ) qp . set_brush ( PEN_COLOR ) qp . drawPolygon ( poly ) qp . drawLine ( line )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner","text":"The MIT License (MIT). Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"waitingspinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner","text":"","title":"BaseWaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( style = \"none\" ) for i in range ( 0 , self . _line_num ): painter . save () painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length , ) rotate_angle = float ( 360 * i ) / float ( self . _line_num ) painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) rect = core . Rect ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . RelativeSize ) painter . restore ()","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner","text":"","title":"WaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event )","title":"paintEvent()"},{"location":"api/gui.html","text":"gui module Gui module. Contains QtGui-based classes color Color __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/color.py def __reduce__ ( self ): return ( self . __class__ , ( self . red (), self . green (), self . blue (), self . alpha ())) from_text ( text ) classmethod Create a QColor from specified string. Source code in prettyqt/gui/color.py @classmethod def from_text ( cls , text ): \"\"\"Create a QColor from specified string.\"\"\" color = cls () text = str ( text ) if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color cursor Cursor get_shape ( self ) Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: Type Description str cursor shape Source code in prettyqt/gui/cursor.py def get_shape ( self ) -> str : \"\"\"Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: cursor shape \"\"\" return SHAPES . inv [ self . shape ()] set_shape ( self , shape ) Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Parameters: Name Type Description Default shape str shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/gui/cursor.py def set_shape ( self , shape : str ): \"\"\"Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in SHAPES : raise InvalidParamError ( shape , SHAPES ) self . setShape ( SHAPES [ shape ]) font Font set_style_hint ( self , hint ) Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str style hint required Exceptions: Type Description InvalidParamError invalid style hint Source code in prettyqt/gui/font.py def set_style_hint ( self , hint : str ): \"\"\"Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ]) set_weight ( self , weight ) Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/font.py def set_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) self . setWeight ( WEIGHTS [ weight ]) gradient Gradient get_coordinate_mode ( self ) Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: Type Description str coordinate mode Source code in prettyqt/gui/gradient.py def get_coordinate_mode ( self ) -> str : \"\"\"Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: coordinate mode \"\"\" return COORDINATE_MODES . inv [ self . coordinateMode ()] get_spread ( self ) Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: Type Description str spread method Source code in prettyqt/gui/gradient.py def get_spread ( self ) -> str : \"\"\"Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: spread method \"\"\" return SPREADS . inv [ self . spread ()] get_type ( self ) Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: Type Description str gradient type Source code in prettyqt/gui/gradient.py def get_type ( self ) -> str : \"\"\"Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: gradient type \"\"\" return TYPES . inv [ self . type ()] set_coordinate_mode ( self , mode ) Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Parameters: Name Type Description Default mode str coordinate mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/gradient.py def set_coordinate_mode ( self , mode : str ): \"\"\"Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODES : raise InvalidParamError ( mode , COORDINATE_MODES ) self . setCoordinateMode ( COORDINATE_MODES [ mode ]) set_spread ( self , method ) Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Parameters: Name Type Description Default method str spread method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/gui/gradient.py def set_spread ( self , method : str ): \"\"\"Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREADS : raise InvalidParamError ( method , SPREADS ) self . setSpread ( SPREADS [ method ]) icon get_icon ( icon , color = None , as_qicon = False ) Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. Source code in prettyqt/gui/icon.py def get_icon ( icon : IconType , color : Optional [ str ] = None , as_qicon : bool = False ): \"\"\"Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. \"\"\" if isinstance ( icon , QtGui . QIcon ): return icon if as_qicon else Icon ( icon ) if isinstance ( icon , pathlib . Path ): icon = str ( icon ) if ( icon , color , as_qicon ) in icon_cache : return icon_cache [( icon , color , as_qicon )] if isinstance ( icon , str ) and icon . startswith ( \"mdi.\" ): if color is not None : new = qta . icon ( icon , color = color ) else : new = qta . icon ( icon ) else : new = QtGui . QIcon ( icon ) icon = new if as_qicon else Icon ( new ) icon_cache [( icon , color , as_qicon )] = icon return icon keysequence KeySequence __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/keysequence.py def __reduce__ ( self ): return ( self . __class__ , ( self . toString (),)) movie Movie get_cache_mode ( self ) Get the current cache mode. Possible values: \"none\", \"all\" Returns: Type Description str cache mode Source code in prettyqt/gui/movie.py def get_cache_mode ( self ) -> str : \"\"\"Get the current cache mode. Possible values: \"none\", \"all\" Returns: cache mode \"\"\" return CACHE_MODES . inv [ self . cacheMode ()] set_cache_mode ( self , mode ) Set cache mode. Valid values for cache_mode: \"none\", \"all\" Parameters: Name Type Description Default cache_mode cache mode required Exceptions: Type Description InvalidParamError cache mode does not exist Source code in prettyqt/gui/movie.py def set_cache_mode ( self , mode : str ): \"\"\"Set cache mode. Valid values for cache_mode: \"none\", \"all\" Args: cache_mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ]) pagelayout PageLayout get_mode ( self ) Get the current mode. Possible values: \"standard\", \"full_page\" Returns: Type Description str mode Source code in prettyqt/gui/pagelayout.py def get_mode ( self ) -> str : \"\"\"Get the current mode. Possible values: \"standard\", \"full_page\" Returns: mode \"\"\" return MODES . inv [ self . mode ()] get_orientation ( self ) Get the current orientation. Possible values: \"portrait\", \"landscape\" Returns: Type Description str orientation Source code in prettyqt/gui/pagelayout.py def get_orientation ( self ) -> str : \"\"\"Get the current orientation. Possible values: \"portrait\", \"landscape\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()] get_units ( self ) Get the current unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: Type Description str unit Source code in prettyqt/gui/pagelayout.py def get_units ( self ) -> str : \"\"\"Get the current unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: unit \"\"\" return UNITS . inv [ self . units ()] set_mode ( self , mode ) Set mode. Valid values for mode: \"standard\", \"full_page\" Parameters: Name Type Description Default mode str mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/pagelayout.py def set_mode ( self , mode : str ): \"\"\"Set mode. Valid values for mode: \"standard\", \"full_page\" Args: mode: mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setMode ( MODES [ mode ]) set_orientation ( self , orientation ) Set orientation. Valid values for orientation: \"portrait\", \"landscape\" Parameters: Name Type Description Default orientation str orientation required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/gui/pagelayout.py def set_orientation ( self , orientation : str ): \"\"\"Set orientation. Valid values for orientation: \"portrait\", \"landscape\" Args: orientation: orientation Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) set_units ( self , unit ) Set unit. Valid values for units: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Parameters: Name Type Description Default units unit required Exceptions: Type Description InvalidParamError unit does not exist Source code in prettyqt/gui/pagelayout.py def set_units ( self , unit : str ): \"\"\"Set unit. Valid values for units: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Args: units: unit Raises: InvalidParamError: unit does not exist \"\"\" if unit not in UNITS : raise InvalidParamError ( unit , UNITS ) self . setUnits ( UNITS [ unit ]) pagesize PageSize get_definition_units ( self ) Get the definition unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: Type Description str unit Source code in prettyqt/gui/pagesize.py def get_definition_units ( self ) -> str : \"\"\"Get the definition unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: unit \"\"\" units = self . definitionUnits () if units == - 1 : raise ValueError ( \"Invalid page size\" ) return UNITS . inv [ units ] get_id ( self ) Get the standard page size id. Returns: Type Description str page size id Source code in prettyqt/gui/pagesize.py def get_id ( self ) -> str : \"\"\"Get the standard page size id. Returns: page size id \"\"\" return PAGE_SIZE_IDS . inv [ self . id ()] painter Painter get_composition_mode ( self ) Get the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: Type Description str composition mode Source code in prettyqt/gui/painter.py def get_composition_mode ( self ) -> str : \"\"\"Get the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: composition mode \"\"\" return COMP_MODES . inv [ self . compositionMode ()] get_pen ( self ) Return current pen. Returns: Type Description str current pen Source code in prettyqt/gui/painter.py def get_pen ( self ) -> str : \"\"\"Return current pen. Returns: current pen \"\"\" return gui . Pen ( self . pen ()) set_composition_mode ( self , mode ) Set the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Exceptions: Type Description InvalidParamError composition mode does not exist Source code in prettyqt/gui/painter.py def set_composition_mode ( self , mode : str ): \"\"\"Set the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMP_MODES : raise InvalidParamError ( mode , COMP_MODES ) self . setCompositionMode ( COMP_MODES [ mode ]) set_pen ( self , style = 'solid' , width = 1 , color = 'black' , join_style = 'bevel' , cap_style = 'square' ) Set pen to use. Parameters: Name Type Description Default style str pen style to use 'solid' width int pen width 1 color Union[str, int, PyQt5.QtGui.QRgba64, PyQt5.QtCore.Qt.GlobalColor, PyQt5.QtGui.QColor, tuple] pen color 'black' join_style str pen join style to use 'bevel' cap_style str pen cap style to use 'square' Source code in prettyqt/gui/painter.py def set_pen ( self , style : str = \"solid\" , width : int = 1 , color : colors . ColorType = \"black\" , join_style : str = \"bevel\" , cap_style : str = \"square\" , ): \"\"\"Set pen to use. Args: style: pen style to use width: pen width color: pen color join_style: pen join style to use cap_style: pen cap style to use \"\"\" pen = gui . Pen () pen . set_style ( style ) pen . set_cap_style ( cap_style ) pen . set_join_style ( join_style ) pen . setWidth ( width ) pen . set_color ( color ) self . setPen ( pen ) pen Pen get_cap_style ( self ) Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: Type Description str cap style Source code in prettyqt/gui/pen.py def get_cap_style ( self ) -> str : \"\"\"Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: cap style \"\"\" return CAP_STYLES . inv [ self . capStyle ()] get_join_style ( self ) Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: Type Description str join style Source code in prettyqt/gui/pen.py def get_join_style ( self ) -> str : \"\"\"Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: join style \"\"\" return JOIN_STYLES . inv [ self . joinStyle ()] get_style ( self ) Return current pen style. Possible values: \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Returns: Type Description str pen style Source code in prettyqt/gui/pen.py def get_style ( self ) -> str : \"\"\"Return current pen style. Possible values: \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Returns: pen style \"\"\" return PEN_STYLES . inv [ self . style ()] set_cap_style ( self , style ) Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Parameters: Name Type Description Default style str cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/pen.py def set_cap_style ( self , style : str ): \"\"\"Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in CAP_STYLES : raise InvalidParamError ( style , CAP_STYLES ) self . setCapStyle ( CAP_STYLES [ style ]) set_join_style ( self , style ) Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Parameters: Name Type Description Default style str join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/pen.py def set_join_style ( self , style : str ): \"\"\"Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in JOIN_STYLES : raise InvalidParamError ( style , JOIN_STYLES ) self . setJoinStyle ( JOIN_STYLES [ style ]) set_style ( self , style ) Set pen style to use. Allowed values are \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Parameters: Name Type Description Default style str pen style to use required Exceptions: Type Description InvalidParamError pen style does not exist Source code in prettyqt/gui/pen.py def set_style ( self , style : str ): \"\"\"Set pen style to use. Allowed values are \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Args: style: pen style to use Raises: InvalidParamError: pen style does not exist \"\"\" if style not in PEN_STYLES : raise InvalidParamError ( style , PEN_STYLES ) self . setStyle ( PEN_STYLES [ style ]) polygon Polygon __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/polygon.py def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () regularexpressionvalidator_pyside RegularExpressionValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/gui/regularexpressionvalidator_pyside.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if self . regex is None : raise TypeError () if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , match_type = \"prefer_first\" ) if match . hasPartialMatch (): return ( self . Intermediate , text , pos ) if match . hasMatch (): return ( self . Acceptable , text , pos ) return ( self . Invalid , text , pos ) standarditem StandardItem clone ( self ) clone(self) -> QStandardItem Source code in prettyqt/gui/standarditem.py def clone ( self ): item = self . __class__ () core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/gui/standarditem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) syntaxhighlighter SyntaxHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt ) textblockuserdata TextBlockUserData Storage for the user data associated with each line. textcharformat TextCharFormat get_font_weight ( self ) Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: Type Description str current font weight Source code in prettyqt/gui/textcharformat.py def get_font_weight ( self ) -> str : \"\"\"Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: current font weight \"\"\" return WEIGHTS . inv [ self . fontWeight ()] get_underline_style ( self ) Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: Type Description str current underline style Source code in prettyqt/gui/textcharformat.py def get_underline_style ( self ) -> str : \"\"\"Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: current underline style \"\"\" return UNDERLINE_STYLES . inv [ self . underlineStyle ()] set_font_style_hint ( self , hint ) Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str font style hint required Exceptions: Type Description InvalidParamError invalid font style hint Source code in prettyqt/gui/textcharformat.py def set_font_style_hint ( self , hint : str ): \"\"\"Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setFontStyleHint ( STYLE_HINTS [ hint ]) set_font_weight ( self , weight ) Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/textcharformat.py def set_font_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) self . setFontWeight ( WEIGHTS [ weight ]) set_underline_style ( self , style ) Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Parameters: Name Type Description Default style str underline style required Exceptions: Type Description InvalidParamError invalid underline style Source code in prettyqt/gui/textcharformat.py def set_underline_style ( self , style : str ): \"\"\"Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLES : raise InvalidParamError ( style , UNDERLINE_STYLES ) self . setUnderlineStyle ( UNDERLINE_STYLES [ style ]) textcursor TextCursor edit_block ( self ) Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock () select ( self , selection ) select(self, QTextCursor.SelectionType) Source code in prettyqt/gui/textcursor.py def select ( self , selection ): if selection in SELECTION_TYPES : selection = SELECTION_TYPES [ selection ] super () . select ( selection ) select_text ( self , start_pos , end_pos ) Select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos Union[int, str] Start position required end_pos Union[int, str] End position required Source code in prettyqt/gui/textcursor.py def select_text ( self , start_pos : Union [ int , str ], end_pos : Union [ int , str ]) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText () set_position ( self , pos , mode = 'move' ) Set cursor to given position. Parameters: Name Type Description Default pos int Cursor position required mode str Move mode 'move' Source code in prettyqt/gui/textcursor.py def set_position ( self , pos : int , mode : str = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODES [ mode ]) textdocument TextDocument clear_stacks ( self , stack ) Clear undo / redo stack. Allowed values are \"undo\", \"redo\", \"undo_and_redo\" Parameters: Name Type Description Default stack str stack to clear required Exceptions: Type Description InvalidParamError stack type does not exist Source code in prettyqt/gui/textdocument.py def clear_stacks ( self , stack : str ): \"\"\"Clear undo / redo stack. Allowed values are \"undo\", \"redo\", \"undo_and_redo\" Args: stack: stack to clear Raises: InvalidParamError: stack type does not exist \"\"\" if stack not in STACKS : raise InvalidParamError ( stack , STACKS ) self . clearUndoRedoStacks ( STACKS [ stack ]) get_default_cursor_move_style ( self ) Return current cursor move style. Possible values: \"logical\", \"visual\" Returns: Type Description str cursor move style Source code in prettyqt/gui/textdocument.py def get_default_cursor_move_style ( self ) -> str : \"\"\"Return current cursor move style. Possible values: \"logical\", \"visual\" Returns: cursor move style \"\"\" return CURSOR_MOVE_STYLES . inv [ self . defaultCursorMoveStyle ()] set_default_cursor_move_style ( self , style ) Set the cursor move style. Allowed values are \"logical\", \"visual\" Parameters: Name Type Description Default style str cursor move style required Exceptions: Type Description InvalidParamError cursor move style does not exist Source code in prettyqt/gui/textdocument.py def set_default_cursor_move_style ( self , style : str ): \"\"\"Set the cursor move style. Allowed values are \"logical\", \"visual\" Args: style: cursor move style Raises: InvalidParamError: cursor move style does not exist \"\"\" if style not in CURSOR_MOVE_STYLES : raise InvalidParamError ( style , CURSOR_MOVE_STYLES ) self . setDefaultCursorMoveStyle ( CURSOR_MOVE_STYLES [ style ]) validator Validator __radd__ ( self , other ) special Needed for sum(). Source code in prettyqt/gui/validator.py def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other )","title":"gui"},{"location":"api/gui.html#gui-module","text":"","title":"gui module"},{"location":"api/gui.html#prettyqt.gui","text":"Gui module. Contains QtGui-based classes","title":"prettyqt.gui"},{"location":"api/gui.html#prettyqt.gui.color","text":"","title":"color"},{"location":"api/gui.html#prettyqt.gui.color.Color","text":"","title":"Color"},{"location":"api/gui.html#prettyqt.gui.color.Color.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/color.py def __reduce__ ( self ): return ( self . __class__ , ( self . red (), self . green (), self . blue (), self . alpha ()))","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.color.Color.from_text","text":"Create a QColor from specified string. Source code in prettyqt/gui/color.py @classmethod def from_text ( cls , text ): \"\"\"Create a QColor from specified string.\"\"\" color = cls () text = str ( text ) if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color","title":"from_text()"},{"location":"api/gui.html#prettyqt.gui.cursor","text":"","title":"cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor","text":"","title":"Cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.get_shape","text":"Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: Type Description str cursor shape Source code in prettyqt/gui/cursor.py def get_shape ( self ) -> str : \"\"\"Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: cursor shape \"\"\" return SHAPES . inv [ self . shape ()]","title":"get_shape()"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.set_shape","text":"Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Parameters: Name Type Description Default shape str shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/gui/cursor.py def set_shape ( self , shape : str ): \"\"\"Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in SHAPES : raise InvalidParamError ( shape , SHAPES ) self . setShape ( SHAPES [ shape ])","title":"set_shape()"},{"location":"api/gui.html#prettyqt.gui.font","text":"","title":"font"},{"location":"api/gui.html#prettyqt.gui.font.Font","text":"","title":"Font"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style_hint","text":"Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str style hint required Exceptions: Type Description InvalidParamError invalid style hint Source code in prettyqt/gui/font.py def set_style_hint ( self , hint : str ): \"\"\"Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ])","title":"set_style_hint()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_weight","text":"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/font.py def set_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) self . setWeight ( WEIGHTS [ weight ])","title":"set_weight()"},{"location":"api/gui.html#prettyqt.gui.gradient","text":"","title":"gradient"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient","text":"","title":"Gradient"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_coordinate_mode","text":"Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: Type Description str coordinate mode Source code in prettyqt/gui/gradient.py def get_coordinate_mode ( self ) -> str : \"\"\"Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: coordinate mode \"\"\" return COORDINATE_MODES . inv [ self . coordinateMode ()]","title":"get_coordinate_mode()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_spread","text":"Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: Type Description str spread method Source code in prettyqt/gui/gradient.py def get_spread ( self ) -> str : \"\"\"Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: spread method \"\"\" return SPREADS . inv [ self . spread ()]","title":"get_spread()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_type","text":"Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: Type Description str gradient type Source code in prettyqt/gui/gradient.py def get_type ( self ) -> str : \"\"\"Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: gradient type \"\"\" return TYPES . inv [ self . type ()]","title":"get_type()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.set_coordinate_mode","text":"Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Parameters: Name Type Description Default mode str coordinate mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/gradient.py def set_coordinate_mode ( self , mode : str ): \"\"\"Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODES : raise InvalidParamError ( mode , COORDINATE_MODES ) self . setCoordinateMode ( COORDINATE_MODES [ mode ])","title":"set_coordinate_mode()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.set_spread","text":"Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Parameters: Name Type Description Default method str spread method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/gui/gradient.py def set_spread ( self , method : str ): \"\"\"Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREADS : raise InvalidParamError ( method , SPREADS ) self . setSpread ( SPREADS [ method ])","title":"set_spread()"},{"location":"api/gui.html#prettyqt.gui.icon","text":"","title":"icon"},{"location":"api/gui.html#prettyqt.gui.icon.get_icon","text":"Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. Source code in prettyqt/gui/icon.py def get_icon ( icon : IconType , color : Optional [ str ] = None , as_qicon : bool = False ): \"\"\"Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. \"\"\" if isinstance ( icon , QtGui . QIcon ): return icon if as_qicon else Icon ( icon ) if isinstance ( icon , pathlib . Path ): icon = str ( icon ) if ( icon , color , as_qicon ) in icon_cache : return icon_cache [( icon , color , as_qicon )] if isinstance ( icon , str ) and icon . startswith ( \"mdi.\" ): if color is not None : new = qta . icon ( icon , color = color ) else : new = qta . icon ( icon ) else : new = QtGui . QIcon ( icon ) icon = new if as_qicon else Icon ( new ) icon_cache [( icon , color , as_qicon )] = icon return icon","title":"get_icon()"},{"location":"api/gui.html#prettyqt.gui.keysequence","text":"","title":"keysequence"},{"location":"api/gui.html#prettyqt.gui.keysequence.KeySequence","text":"","title":"KeySequence"},{"location":"api/gui.html#prettyqt.gui.keysequence.KeySequence.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/keysequence.py def __reduce__ ( self ): return ( self . __class__ , ( self . toString (),))","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.movie","text":"","title":"movie"},{"location":"api/gui.html#prettyqt.gui.movie.Movie","text":"","title":"Movie"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_cache_mode","text":"Get the current cache mode. Possible values: \"none\", \"all\" Returns: Type Description str cache mode Source code in prettyqt/gui/movie.py def get_cache_mode ( self ) -> str : \"\"\"Get the current cache mode. Possible values: \"none\", \"all\" Returns: cache mode \"\"\" return CACHE_MODES . inv [ self . cacheMode ()]","title":"get_cache_mode()"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.set_cache_mode","text":"Set cache mode. Valid values for cache_mode: \"none\", \"all\" Parameters: Name Type Description Default cache_mode cache mode required Exceptions: Type Description InvalidParamError cache mode does not exist Source code in prettyqt/gui/movie.py def set_cache_mode ( self , mode : str ): \"\"\"Set cache mode. Valid values for cache_mode: \"none\", \"all\" Args: cache_mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ])","title":"set_cache_mode()"},{"location":"api/gui.html#prettyqt.gui.pagelayout","text":"","title":"pagelayout"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout","text":"","title":"PageLayout"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_mode","text":"Get the current mode. Possible values: \"standard\", \"full_page\" Returns: Type Description str mode Source code in prettyqt/gui/pagelayout.py def get_mode ( self ) -> str : \"\"\"Get the current mode. Possible values: \"standard\", \"full_page\" Returns: mode \"\"\" return MODES . inv [ self . mode ()]","title":"get_mode()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_orientation","text":"Get the current orientation. Possible values: \"portrait\", \"landscape\" Returns: Type Description str orientation Source code in prettyqt/gui/pagelayout.py def get_orientation ( self ) -> str : \"\"\"Get the current orientation. Possible values: \"portrait\", \"landscape\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()]","title":"get_orientation()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_units","text":"Get the current unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: Type Description str unit Source code in prettyqt/gui/pagelayout.py def get_units ( self ) -> str : \"\"\"Get the current unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: unit \"\"\" return UNITS . inv [ self . units ()]","title":"get_units()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_mode","text":"Set mode. Valid values for mode: \"standard\", \"full_page\" Parameters: Name Type Description Default mode str mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/pagelayout.py def set_mode ( self , mode : str ): \"\"\"Set mode. Valid values for mode: \"standard\", \"full_page\" Args: mode: mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setMode ( MODES [ mode ])","title":"set_mode()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_orientation","text":"Set orientation. Valid values for orientation: \"portrait\", \"landscape\" Parameters: Name Type Description Default orientation str orientation required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/gui/pagelayout.py def set_orientation ( self , orientation : str ): \"\"\"Set orientation. Valid values for orientation: \"portrait\", \"landscape\" Args: orientation: orientation Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_units","text":"Set unit. Valid values for units: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Parameters: Name Type Description Default units unit required Exceptions: Type Description InvalidParamError unit does not exist Source code in prettyqt/gui/pagelayout.py def set_units ( self , unit : str ): \"\"\"Set unit. Valid values for units: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Args: units: unit Raises: InvalidParamError: unit does not exist \"\"\" if unit not in UNITS : raise InvalidParamError ( unit , UNITS ) self . setUnits ( UNITS [ unit ])","title":"set_units()"},{"location":"api/gui.html#prettyqt.gui.pagesize","text":"","title":"pagesize"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize","text":"","title":"PageSize"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_definition_units","text":"Get the definition unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: Type Description str unit Source code in prettyqt/gui/pagesize.py def get_definition_units ( self ) -> str : \"\"\"Get the definition unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: unit \"\"\" units = self . definitionUnits () if units == - 1 : raise ValueError ( \"Invalid page size\" ) return UNITS . inv [ units ]","title":"get_definition_units()"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_id","text":"Get the standard page size id. Returns: Type Description str page size id Source code in prettyqt/gui/pagesize.py def get_id ( self ) -> str : \"\"\"Get the standard page size id. Returns: page size id \"\"\" return PAGE_SIZE_IDS . inv [ self . id ()]","title":"get_id()"},{"location":"api/gui.html#prettyqt.gui.painter","text":"","title":"painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter","text":"","title":"Painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_composition_mode","text":"Get the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: Type Description str composition mode Source code in prettyqt/gui/painter.py def get_composition_mode ( self ) -> str : \"\"\"Get the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: composition mode \"\"\" return COMP_MODES . inv [ self . compositionMode ()]","title":"get_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_pen","text":"Return current pen. Returns: Type Description str current pen Source code in prettyqt/gui/painter.py def get_pen ( self ) -> str : \"\"\"Return current pen. Returns: current pen \"\"\" return gui . Pen ( self . pen ())","title":"get_pen()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_composition_mode","text":"Set the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Exceptions: Type Description InvalidParamError composition mode does not exist Source code in prettyqt/gui/painter.py def set_composition_mode ( self , mode : str ): \"\"\"Set the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMP_MODES : raise InvalidParamError ( mode , COMP_MODES ) self . setCompositionMode ( COMP_MODES [ mode ])","title":"set_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_pen","text":"Set pen to use. Parameters: Name Type Description Default style str pen style to use 'solid' width int pen width 1 color Union[str, int, PyQt5.QtGui.QRgba64, PyQt5.QtCore.Qt.GlobalColor, PyQt5.QtGui.QColor, tuple] pen color 'black' join_style str pen join style to use 'bevel' cap_style str pen cap style to use 'square' Source code in prettyqt/gui/painter.py def set_pen ( self , style : str = \"solid\" , width : int = 1 , color : colors . ColorType = \"black\" , join_style : str = \"bevel\" , cap_style : str = \"square\" , ): \"\"\"Set pen to use. Args: style: pen style to use width: pen width color: pen color join_style: pen join style to use cap_style: pen cap style to use \"\"\" pen = gui . Pen () pen . set_style ( style ) pen . set_cap_style ( cap_style ) pen . set_join_style ( join_style ) pen . setWidth ( width ) pen . set_color ( color ) self . setPen ( pen )","title":"set_pen()"},{"location":"api/gui.html#prettyqt.gui.pen","text":"","title":"pen"},{"location":"api/gui.html#prettyqt.gui.pen.Pen","text":"","title":"Pen"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_cap_style","text":"Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: Type Description str cap style Source code in prettyqt/gui/pen.py def get_cap_style ( self ) -> str : \"\"\"Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: cap style \"\"\" return CAP_STYLES . inv [ self . capStyle ()]","title":"get_cap_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_join_style","text":"Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: Type Description str join style Source code in prettyqt/gui/pen.py def get_join_style ( self ) -> str : \"\"\"Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: join style \"\"\" return JOIN_STYLES . inv [ self . joinStyle ()]","title":"get_join_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_style","text":"Return current pen style. Possible values: \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Returns: Type Description str pen style Source code in prettyqt/gui/pen.py def get_style ( self ) -> str : \"\"\"Return current pen style. Possible values: \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Returns: pen style \"\"\" return PEN_STYLES . inv [ self . style ()]","title":"get_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_cap_style","text":"Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Parameters: Name Type Description Default style str cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/pen.py def set_cap_style ( self , style : str ): \"\"\"Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in CAP_STYLES : raise InvalidParamError ( style , CAP_STYLES ) self . setCapStyle ( CAP_STYLES [ style ])","title":"set_cap_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_join_style","text":"Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Parameters: Name Type Description Default style str join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/pen.py def set_join_style ( self , style : str ): \"\"\"Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in JOIN_STYLES : raise InvalidParamError ( style , JOIN_STYLES ) self . setJoinStyle ( JOIN_STYLES [ style ])","title":"set_join_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_style","text":"Set pen style to use. Allowed values are \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Parameters: Name Type Description Default style str pen style to use required Exceptions: Type Description InvalidParamError pen style does not exist Source code in prettyqt/gui/pen.py def set_style ( self , style : str ): \"\"\"Set pen style to use. Allowed values are \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Args: style: pen style to use Raises: InvalidParamError: pen style does not exist \"\"\" if style not in PEN_STYLES : raise InvalidParamError ( style , PEN_STYLES ) self . setStyle ( PEN_STYLES [ style ])","title":"set_style()"},{"location":"api/gui.html#prettyqt.gui.polygon","text":"","title":"polygon"},{"location":"api/gui.html#prettyqt.gui.polygon.Polygon","text":"","title":"Polygon"},{"location":"api/gui.html#prettyqt.gui.polygon.Polygon.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/polygon.py def __reduce__ ( self ): return type ( self ), (), self . __getstate__ ()","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.regularexpressionvalidator_pyside","text":"","title":"regularexpressionvalidator_pyside"},{"location":"api/gui.html#prettyqt.gui.regularexpressionvalidator_pyside.RegularExpressionValidator","text":"","title":"RegularExpressionValidator"},{"location":"api/gui.html#prettyqt.gui.regularexpressionvalidator_pyside.RegularExpressionValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/gui/regularexpressionvalidator_pyside.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if self . regex is None : raise TypeError () if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , match_type = \"prefer_first\" ) if match . hasPartialMatch (): return ( self . Intermediate , text , pos ) if match . hasMatch (): return ( self . Acceptable , text , pos ) return ( self . Invalid , text , pos )","title":"validate()"},{"location":"api/gui.html#prettyqt.gui.standarditem","text":"","title":"standarditem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem","text":"","title":"StandardItem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.clone","text":"clone(self) -> QStandardItem Source code in prettyqt/gui/standarditem.py def clone ( self ): item = self . __class__ () core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item","title":"clone()"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/gui/standarditem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter","text":"","title":"syntaxhighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter","text":"","title":"SyntaxHighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt )","title":"highlightBlock()"},{"location":"api/gui.html#prettyqt.gui.textblockuserdata","text":"","title":"textblockuserdata"},{"location":"api/gui.html#prettyqt.gui.textblockuserdata.TextBlockUserData","text":"Storage for the user data associated with each line.","title":"TextBlockUserData"},{"location":"api/gui.html#prettyqt.gui.textcharformat","text":"","title":"textcharformat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat","text":"","title":"TextCharFormat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_font_weight","text":"Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: Type Description str current font weight Source code in prettyqt/gui/textcharformat.py def get_font_weight ( self ) -> str : \"\"\"Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: current font weight \"\"\" return WEIGHTS . inv [ self . fontWeight ()]","title":"get_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_underline_style","text":"Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: Type Description str current underline style Source code in prettyqt/gui/textcharformat.py def get_underline_style ( self ) -> str : \"\"\"Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: current underline style \"\"\" return UNDERLINE_STYLES . inv [ self . underlineStyle ()]","title":"get_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_style_hint","text":"Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str font style hint required Exceptions: Type Description InvalidParamError invalid font style hint Source code in prettyqt/gui/textcharformat.py def set_font_style_hint ( self , hint : str ): \"\"\"Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setFontStyleHint ( STYLE_HINTS [ hint ])","title":"set_font_style_hint()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_weight","text":"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/textcharformat.py def set_font_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) self . setFontWeight ( WEIGHTS [ weight ])","title":"set_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_underline_style","text":"Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Parameters: Name Type Description Default style str underline style required Exceptions: Type Description InvalidParamError invalid underline style Source code in prettyqt/gui/textcharformat.py def set_underline_style ( self , style : str ): \"\"\"Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLES : raise InvalidParamError ( style , UNDERLINE_STYLES ) self . setUnderlineStyle ( UNDERLINE_STYLES [ style ])","title":"set_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcursor","text":"","title":"textcursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor","text":"","title":"TextCursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.edit_block","text":"Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock ()","title":"edit_block()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select","text":"select(self, QTextCursor.SelectionType) Source code in prettyqt/gui/textcursor.py def select ( self , selection ): if selection in SELECTION_TYPES : selection = SELECTION_TYPES [ selection ] super () . select ( selection )","title":"select()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select_text","text":"Select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos Union[int, str] Start position required end_pos Union[int, str] End position required Source code in prettyqt/gui/textcursor.py def select_text ( self , start_pos : Union [ int , str ], end_pos : Union [ int , str ]) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText ()","title":"select_text()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.set_position","text":"Set cursor to given position. Parameters: Name Type Description Default pos int Cursor position required mode str Move mode 'move' Source code in prettyqt/gui/textcursor.py def set_position ( self , pos : int , mode : str = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODES [ mode ])","title":"set_position()"},{"location":"api/gui.html#prettyqt.gui.textdocument","text":"","title":"textdocument"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument","text":"","title":"TextDocument"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.clear_stacks","text":"Clear undo / redo stack. Allowed values are \"undo\", \"redo\", \"undo_and_redo\" Parameters: Name Type Description Default stack str stack to clear required Exceptions: Type Description InvalidParamError stack type does not exist Source code in prettyqt/gui/textdocument.py def clear_stacks ( self , stack : str ): \"\"\"Clear undo / redo stack. Allowed values are \"undo\", \"redo\", \"undo_and_redo\" Args: stack: stack to clear Raises: InvalidParamError: stack type does not exist \"\"\" if stack not in STACKS : raise InvalidParamError ( stack , STACKS ) self . clearUndoRedoStacks ( STACKS [ stack ])","title":"clear_stacks()"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.get_default_cursor_move_style","text":"Return current cursor move style. Possible values: \"logical\", \"visual\" Returns: Type Description str cursor move style Source code in prettyqt/gui/textdocument.py def get_default_cursor_move_style ( self ) -> str : \"\"\"Return current cursor move style. Possible values: \"logical\", \"visual\" Returns: cursor move style \"\"\" return CURSOR_MOVE_STYLES . inv [ self . defaultCursorMoveStyle ()]","title":"get_default_cursor_move_style()"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.set_default_cursor_move_style","text":"Set the cursor move style. Allowed values are \"logical\", \"visual\" Parameters: Name Type Description Default style str cursor move style required Exceptions: Type Description InvalidParamError cursor move style does not exist Source code in prettyqt/gui/textdocument.py def set_default_cursor_move_style ( self , style : str ): \"\"\"Set the cursor move style. Allowed values are \"logical\", \"visual\" Args: style: cursor move style Raises: InvalidParamError: cursor move style does not exist \"\"\" if style not in CURSOR_MOVE_STYLES : raise InvalidParamError ( style , CURSOR_MOVE_STYLES ) self . setDefaultCursorMoveStyle ( CURSOR_MOVE_STYLES [ style ])","title":"set_default_cursor_move_style()"},{"location":"api/gui.html#prettyqt.gui.validator","text":"","title":"validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator","text":"","title":"Validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator.__radd__","text":"Needed for sum(). Source code in prettyqt/gui/validator.py def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other )","title":"__radd__()"},{"location":"api/multimedia.html","text":"multimedia module Multimedia module. audioencodersettings Settings dataclass Settings(bitrate: int, channel_count: int, codec: str, encoding_mode: str, encoding_options: Dict[str, Any], quality: str, sample_rate: int) mediaplayer MediaPlayer get_media_status ( self ) Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: Type Description str media status Source code in prettyqt/multimedia/mediaplayer.py def get_media_status ( self ) -> str : \"\"\"Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: media status \"\"\" return MEDIA_STATUS . inv [ self . mediaStatus ()] get_state ( self ) Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: Type Description str state Source code in prettyqt/multimedia/mediaplayer.py def get_state ( self ) -> str : \"\"\"Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: state \"\"\" return STATES . inv [ self . state ()] mediaplaylist MediaPlaylist get_playback_mode ( self ) Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: Type Description str playback mode Source code in prettyqt/multimedia/mediaplaylist.py def get_playback_mode ( self ) -> str : \"\"\"Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: playback mode \"\"\" return PLAYBACK_MODES . inv [ self . playbackMode ()] set_playback_mode ( self , mode ) Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Parameters: Name Type Description Default mode str playback mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/multimedia/mediaplaylist.py def set_playback_mode ( self , mode : str ): \"\"\"Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Args: mode: playback mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in PLAYBACK_MODES : raise InvalidParamError ( mode , PLAYBACK_MODES ) self . setPlaybackMode ( PLAYBACK_MODES [ mode ]) mediarecorder MediaRecorder get_availability ( self ) Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: Type Description str availability status Source code in prettyqt/multimedia/mediarecorder.py def get_availability ( self ) -> str : \"\"\"Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: availability status \"\"\" return AVAILABILITY_STATUS . inv [ self . availability ()] videoencodersettings Settings dataclass Settings(bitrate: int, codec: str, encoding_mode: str, encoding_options: Dict[str, Any], quality: str, frame_rate: float, resolution: Tuple[int, int])","title":"multimedia"},{"location":"api/multimedia.html#multimedia-module","text":"","title":"multimedia module"},{"location":"api/multimedia.html#prettyqt.multimedia","text":"Multimedia module.","title":"prettyqt.multimedia"},{"location":"api/multimedia.html#prettyqt.multimedia.audioencodersettings","text":"","title":"audioencodersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.audioencodersettings.Settings","text":"Settings(bitrate: int, channel_count: int, codec: str, encoding_mode: str, encoding_options: Dict[str, Any], quality: str, sample_rate: int)","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer","text":"","title":"mediaplayer"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer","text":"","title":"MediaPlayer"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_media_status","text":"Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: Type Description str media status Source code in prettyqt/multimedia/mediaplayer.py def get_media_status ( self ) -> str : \"\"\"Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: media status \"\"\" return MEDIA_STATUS . inv [ self . mediaStatus ()]","title":"get_media_status()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_state","text":"Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: Type Description str state Source code in prettyqt/multimedia/mediaplayer.py def get_state ( self ) -> str : \"\"\"Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: state \"\"\" return STATES . inv [ self . state ()]","title":"get_state()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist","text":"","title":"mediaplaylist"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist","text":"","title":"MediaPlaylist"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist.get_playback_mode","text":"Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: Type Description str playback mode Source code in prettyqt/multimedia/mediaplaylist.py def get_playback_mode ( self ) -> str : \"\"\"Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: playback mode \"\"\" return PLAYBACK_MODES . inv [ self . playbackMode ()]","title":"get_playback_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist.set_playback_mode","text":"Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Parameters: Name Type Description Default mode str playback mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/multimedia/mediaplaylist.py def set_playback_mode ( self , mode : str ): \"\"\"Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Args: mode: playback mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in PLAYBACK_MODES : raise InvalidParamError ( mode , PLAYBACK_MODES ) self . setPlaybackMode ( PLAYBACK_MODES [ mode ])","title":"set_playback_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder","text":"","title":"mediarecorder"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder","text":"","title":"MediaRecorder"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder.get_availability","text":"Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: Type Description str availability status Source code in prettyqt/multimedia/mediarecorder.py def get_availability ( self ) -> str : \"\"\"Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: availability status \"\"\" return AVAILABILITY_STATUS . inv [ self . availability ()]","title":"get_availability()"},{"location":"api/multimedia.html#prettyqt.multimedia.videoencodersettings","text":"","title":"videoencodersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.videoencodersettings.Settings","text":"Settings(bitrate: int, codec: str, encoding_mode: str, encoding_options: Dict[str, Any], quality: str, frame_rate: float, resolution: Tuple[int, int])","title":"Settings"},{"location":"api/multimediawidgets.html","text":"multimediawidgets module Multimediawidgets module.","title":"multimediawidgets"},{"location":"api/multimediawidgets.html#multimediawidgets-module","text":"","title":"multimediawidgets module"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets","text":"Multimediawidgets module.","title":"prettyqt.multimediawidgets"},{"location":"api/syntaxhighlighters.html","text":"syntaxhighlighters module syntaxhighlighters module. contains some custom syntax highlighers highlightrule HighlightRule dataclass HighlightRule(regex: Union[str, List[str]] = '', color: str = 'black', italic: bool = False, bold: bool = False, minimal: bool = False, font_size: Union[float, NoneType] = None, nth: int = 0) __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format () jsonhighlighter JsonHighlighter highlightBlock ( self , text ) Highlight a block of code using the rules outlined in the Constructor. Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT ) markdownhighlighter Syntax highlighter for Markdown markup language. MarkdownHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE ) pygmentshighlighter PygmentsHighlighter Syntax highlighter that uses Pygments for parsing. highlightBlock ( self , string ) Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack set_style ( self , style ) Sets the style to the specified Pygments style. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style ( self , style ): \"\"\"Sets the style to the specified Pygments style.\"\"\" if isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches () set_style_sheet ( self , stylesheet ) Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style_sheet ( self , stylesheet ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches () get_tokens_unprocessed ( self , text , stack = ( 'root' ,)) Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def get_tokens_unprocessed ( self , text , stack = ( \"root\" ,)): \"\"\"Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while 1 : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if type ( action ) is _TokenType : yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , \"wrong state def: %r \" % new_state statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" pos += 1 statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos , Text , \" \\n \" continue yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack ) qstring_length ( text ) Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def qstring_length ( text ): \"\"\"Tries to compute what the length of an utf16-encoded QString would be.\"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length pythonhighlighter Syntax highlighter for the programming language Python. PythonHighlighter Syntax highlighter for the Python language. highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE ) match_multiline ( self , text , delimiter , in_state , style ) Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def match_multiline ( self , text , delimiter , in_state , style ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : start = delimiter . indexIn ( text ) # Move past this match add = delimiter . matchedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter end = delimiter . indexIn ( text , start + add ) # Ending delimiter on this line? if end >= add : length = end - start + add + delimiter . matchedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . indexIn ( text , start + length ) # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state regexmatchhighlighter RegexMatchHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i ) xmlhighlighter Based on http://www.yasinuludag.com/blog/?p=49 . XmlHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . indexIn ( text ) while start_index >= 0 : end_index = VALUE_END_EXPRESSION . indexIn ( text , start_index ) if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : matched_len = VALUE_END_EXPRESSION . matchedLength () comment_len = end_index - start_index + matched_len self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . indexIn ( text , start_index + comment_len ) yamlhighlighter YamlHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . indexIn ( text ) if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"syntaxhighlighters"},{"location":"api/syntaxhighlighters.html#syntaxhighlighters-module","text":"","title":"syntaxhighlighters module"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters","text":"syntaxhighlighters module. contains some custom syntax highlighers","title":"prettyqt.syntaxhighlighters"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule","text":"","title":"highlightrule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule","text":"HighlightRule(regex: Union[str, List[str]] = '', color: str = 'black', italic: bool = False, bold: bool = False, minimal: bool = False, font_size: Union[float, NoneType] = None, nth: int = 0)","title":"HighlightRule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format ()","title":"__init_subclass__()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter","text":"","title":"jsonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter","text":"","title":"JsonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter.highlightBlock","text":"Highlight a block of code using the rules outlined in the Constructor. Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter","text":"Syntax highlighter for Markdown markup language.","title":"markdownhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter","text":"","title":"MarkdownHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter","text":"","title":"pygmentshighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter","text":"Syntax highlighter that uses Pygments for parsing.","title":"PygmentsHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.highlightBlock","text":"Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style","text":"Sets the style to the specified Pygments style. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style ( self , style ): \"\"\"Sets the style to the specified Pygments style.\"\"\" if isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches ()","title":"set_style()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style_sheet","text":"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style_sheet ( self , stylesheet ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches ()","title":"set_style_sheet()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.get_tokens_unprocessed","text":"Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def get_tokens_unprocessed ( self , text , stack = ( \"root\" ,)): \"\"\"Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while 1 : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if type ( action ) is _TokenType : yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , \"wrong state def: %r \" % new_state statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" pos += 1 statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos , Text , \" \\n \" continue yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack )","title":"get_tokens_unprocessed()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.qstring_length","text":"Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def qstring_length ( text ): \"\"\"Tries to compute what the length of an utf16-encoded QString would be.\"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length","title":"qstring_length()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter","text":"Syntax highlighter for the programming language Python.","title":"pythonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter","text":"Syntax highlighter for the Python language.","title":"PythonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.match_multiline","text":"Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def match_multiline ( self , text , delimiter , in_state , style ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : start = delimiter . indexIn ( text ) # Move past this match add = delimiter . matchedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter end = delimiter . indexIn ( text , start + add ) # Ending delimiter on this line? if end >= add : length = end - start + add + delimiter . matchedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . indexIn ( text , start + length ) # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state","title":"match_multiline()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter","text":"","title":"regexmatchhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter","text":"","title":"RegexMatchHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter","text":"Based on http://www.yasinuludag.com/blog/?p=49 .","title":"xmlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter","text":"","title":"XmlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . indexIn ( text ) while start_index >= 0 : end_index = VALUE_END_EXPRESSION . indexIn ( text , start_index ) if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : matched_len = VALUE_END_EXPRESSION . matchedLength () comment_len = end_index - start_index + matched_len self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . indexIn ( text , start_index + comment_len )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter","text":"","title":"yamlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter","text":"","title":"YamlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . indexIn ( text ) if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"highlightBlock()"},{"location":"api/webenginewidgets.html","text":"webenginewidgets module Webenginewidgets module. contains QWebEngineView-based classes webenginepage WebEnginePage A web engine page holds the HTML document contents, link history + actions. find_text ( self , string , backward = False , case_sensitive = False , callback = None ) Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webenginepage.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = self . FindFlag () if case_sensitive : flag |= self . FindCaseSensitively if backward : flag |= self . FindBackward self . findText ( string , flag , callback ) get_lifecycle_state ( self ) Get the current lifecycle state. Possible values: \"active\", \"frozen\", \"discarded\" Returns: Type Description str lifecycle state Source code in prettyqt/webenginewidgets/webenginepage.py def get_lifecycle_state ( self ) -> str : \"\"\"Get the current lifecycle state. Possible values: \"active\", \"frozen\", \"discarded\" Returns: lifecycle state \"\"\" return LIFECYCLE_STATES . inv [ self . lifecycleState ()] load_url ( self , url ) Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webenginepage.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) set_lifecycle_state ( self , state ) Set lifecycle state. Valid values: \"active\", \"frozen\", \"discarded\" Parameters: Name Type Description Default state str lifecycle state required Exceptions: Type Description InvalidParamError lifecycle state does not exist Source code in prettyqt/webenginewidgets/webenginepage.py def set_lifecycle_state ( self , state : str ): \"\"\"Set lifecycle state. Valid values: \"active\", \"frozen\", \"discarded\" Args: state: lifecycle state Raises: InvalidParamError: lifecycle state does not exist \"\"\" if state not in LIFECYCLE_STATES : raise InvalidParamError ( state , LIFECYCLE_STATES ) self . setLifecycleState ( LIFECYCLE_STATES [ state ]) set_url ( self , url ) Set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webenginepage.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom ) Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webenginepage.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom ) webengineprofile WebEngineProfile get_http_cache_type ( self ) Return current http cache type. Possible values are \"none\", \"disk\", \"memory\" Returns: Type Description str Http cache type Source code in prettyqt/webenginewidgets/webengineprofile.py def get_http_cache_type ( self ) -> str : \"\"\"Return current http cache type. Possible values are \"none\", \"disk\", \"memory\" Returns: Http cache type \"\"\" return HTTP_CACHE_TYPES . inv [ self . httpCacheType ()] get_persistent_cookie_policy ( self ) Return current persistent cookie policy. Possible values are \"none\", \"allow\", \"force\" Returns: Type Description str Save page format Source code in prettyqt/webenginewidgets/webengineprofile.py def get_persistent_cookie_policy ( self ) -> str : \"\"\"Return current persistent cookie policy. Possible values are \"none\", \"allow\", \"force\" Returns: Save page format \"\"\" return PERSISTENT_COOKIE_POLICIES . inv [ self . persistentCookiesPolicy ()] set_http_cache_type ( self , typ ) Set the http cache type. Allowed values are \"none\", \"disk\", \"memory\" Parameters: Name Type Description Default type http cache type required Exceptions: Type Description InvalidParamError Cache type does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_http_cache_type ( self , typ : str ): \"\"\"Set the http cache type. Allowed values are \"none\", \"disk\", \"memory\" Args: type: http cache type Raises: InvalidParamError: Cache type does not exist \"\"\" if typ not in HTTP_CACHE_TYPES : raise InvalidParamError ( typ , HTTP_CACHE_TYPES ) self . setHttpCacheType ( HTTP_CACHE_TYPES [ typ ]) set_persistent_cookie_policy ( self , policy ) Set the persistent cookie policy. Allowed values are \"none\", \"allow\", \"force\" Parameters: Name Type Description Default policy str persistent cookie policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_persistent_cookie_policy ( self , policy : str ): \"\"\"Set the persistent cookie policy. Allowed values are \"none\", \"allow\", \"force\" Args: policy: persistent cookie policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in PERSISTENT_COOKIE_POLICIES : raise InvalidParamError ( policy , PERSISTENT_COOKIE_POLICIES ) self . setPersistentCookiesPolicy ( PERSISTENT_COOKIE_POLICIES [ policy ]) webengineview WebEngineView find_text ( self , string , backward = False , case_sensitive = False , callback = None ) Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webengineview.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlag () if case_sensitive : flag |= QtWebEngineWidgets . QWebEnginePage . FindCaseSensitively if backward : flag |= QtWebEngineWidgets . QWebEnginePage . FindBackward self . findText ( string , flag , callback ) load_url ( self , url ) Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webengineview.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) set_url ( self , url ) Set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webengineview.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom ) Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"webenginewidgets"},{"location":"api/webenginewidgets.html#webenginewidgets-module","text":"","title":"webenginewidgets module"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets","text":"Webenginewidgets module. contains QWebEngineView-based classes","title":"prettyqt.webenginewidgets"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage","text":"","title":"webenginepage"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage","text":"A web engine page holds the HTML document contents, link history + actions.","title":"WebEnginePage"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.find_text","text":"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webenginepage.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = self . FindFlag () if case_sensitive : flag |= self . FindCaseSensitively if backward : flag |= self . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.get_lifecycle_state","text":"Get the current lifecycle state. Possible values: \"active\", \"frozen\", \"discarded\" Returns: Type Description str lifecycle state Source code in prettyqt/webenginewidgets/webenginepage.py def get_lifecycle_state ( self ) -> str : \"\"\"Get the current lifecycle state. Possible values: \"active\", \"frozen\", \"discarded\" Returns: lifecycle state \"\"\" return LIFECYCLE_STATES . inv [ self . lifecycleState ()]","title":"get_lifecycle_state()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.load_url","text":"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webenginepage.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_lifecycle_state","text":"Set lifecycle state. Valid values: \"active\", \"frozen\", \"discarded\" Parameters: Name Type Description Default state str lifecycle state required Exceptions: Type Description InvalidParamError lifecycle state does not exist Source code in prettyqt/webenginewidgets/webenginepage.py def set_lifecycle_state ( self , state : str ): \"\"\"Set lifecycle state. Valid values: \"active\", \"frozen\", \"discarded\" Args: state: lifecycle state Raises: InvalidParamError: lifecycle state does not exist \"\"\" if state not in LIFECYCLE_STATES : raise InvalidParamError ( state , LIFECYCLE_STATES ) self . setLifecycleState ( LIFECYCLE_STATES [ state ])","title":"set_lifecycle_state()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_url","text":"Set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webenginepage.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_zoom","text":"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webenginepage.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile","text":"","title":"webengineprofile"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile","text":"","title":"WebEngineProfile"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.get_http_cache_type","text":"Return current http cache type. Possible values are \"none\", \"disk\", \"memory\" Returns: Type Description str Http cache type Source code in prettyqt/webenginewidgets/webengineprofile.py def get_http_cache_type ( self ) -> str : \"\"\"Return current http cache type. Possible values are \"none\", \"disk\", \"memory\" Returns: Http cache type \"\"\" return HTTP_CACHE_TYPES . inv [ self . httpCacheType ()]","title":"get_http_cache_type()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.get_persistent_cookie_policy","text":"Return current persistent cookie policy. Possible values are \"none\", \"allow\", \"force\" Returns: Type Description str Save page format Source code in prettyqt/webenginewidgets/webengineprofile.py def get_persistent_cookie_policy ( self ) -> str : \"\"\"Return current persistent cookie policy. Possible values are \"none\", \"allow\", \"force\" Returns: Save page format \"\"\" return PERSISTENT_COOKIE_POLICIES . inv [ self . persistentCookiesPolicy ()]","title":"get_persistent_cookie_policy()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.set_http_cache_type","text":"Set the http cache type. Allowed values are \"none\", \"disk\", \"memory\" Parameters: Name Type Description Default type http cache type required Exceptions: Type Description InvalidParamError Cache type does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_http_cache_type ( self , typ : str ): \"\"\"Set the http cache type. Allowed values are \"none\", \"disk\", \"memory\" Args: type: http cache type Raises: InvalidParamError: Cache type does not exist \"\"\" if typ not in HTTP_CACHE_TYPES : raise InvalidParamError ( typ , HTTP_CACHE_TYPES ) self . setHttpCacheType ( HTTP_CACHE_TYPES [ typ ])","title":"set_http_cache_type()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.set_persistent_cookie_policy","text":"Set the persistent cookie policy. Allowed values are \"none\", \"allow\", \"force\" Parameters: Name Type Description Default policy str persistent cookie policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_persistent_cookie_policy ( self , policy : str ): \"\"\"Set the persistent cookie policy. Allowed values are \"none\", \"allow\", \"force\" Args: policy: persistent cookie policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in PERSISTENT_COOKIE_POLICIES : raise InvalidParamError ( policy , PERSISTENT_COOKIE_POLICIES ) self . setPersistentCookiesPolicy ( PERSISTENT_COOKIE_POLICIES [ policy ])","title":"set_persistent_cookie_policy()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview","text":"","title":"webengineview"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView","text":"","title":"WebEngineView"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.find_text","text":"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webengineview.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlag () if case_sensitive : flag |= QtWebEngineWidgets . QWebEnginePage . FindCaseSensitively if backward : flag |= QtWebEngineWidgets . QWebEnginePage . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.load_url","text":"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webengineview.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_url","text":"Set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webengineview.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_zoom","text":"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/widgets.html","text":"widgets module widgets module. contains QtWidgets-based classes abstractbutton AbstractButton set_icon ( self , icon ) Set the icon for the button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/abstractbutton.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) abstractitemview AbstractItemView get_selection_behaviour ( self ) Return current selection behaviour. Possible values: \"rows\", \"columns\", \"items\" Returns: Type Description str selection behaviour Source code in prettyqt/widgets/abstractitemview.py def get_selection_behaviour ( self ) -> str : \"\"\"Return current selection behaviour. Possible values: \"rows\", \"columns\", \"items\" Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOURS . inv [ self . selectionBehavior ()] get_selection_mode ( self ) Return current selection mode. Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/abstractitemview.py def get_selection_mode ( self ) -> str : \"\"\"Return current selection mode. Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()] highlight_when_inactive ( self ) Highlight items when widget does not have focus. Source code in prettyqt/widgets/abstractitemview.py def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p ) jump_to_column ( self , col_num ) Make sure column at given index is visible. scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return None idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx ) num_selected ( self ) Return amount of selected rows. Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ()) scroll_to_bottom ( self ) Override to use abstractitemview-way of scrolling to bottom. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom () scroll_to_top ( self ) Override to use abstractitemview-way of scrolling to top. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop () selectAll ( self ) Override, we dont want to selectAll for too many items bc of performance. Source code in prettyqt/widgets/abstractitemview.py def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return None if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return None super () . selectAll () selected_data ( self ) Returns generator yielding selected userData. Source code in prettyqt/widgets/abstractitemview.py def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes ()) selected_indexes ( self ) Returns list of selected indexes in first row. Source code in prettyqt/widgets/abstractitemview.py def selected_indexes ( self ) -> List [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) return sorted ( indexes , key = lambda x : x . row ()) selected_names ( self ) Returns generator yielding item names. Source code in prettyqt/widgets/abstractitemview.py def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ()) selected_rows ( self ) Returns generator yielding row nums. Source code in prettyqt/widgets/abstractitemview.py def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ()) set_horizontal_scroll_mode ( self , mode ) Set the horizontal scroll mode. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_horizontal_scroll_mode ( self , mode : str ): \"\"\"Set the horizontal scroll mode. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ]) set_model ( self , model ) Delete old selection model explicitely, seems to help with memory usage. Source code in prettyqt/widgets/abstractitemview.py def set_model ( self , model : Optional [ QtCore . QAbstractItemModel ]): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model set_scroll_mode ( self , mode ) Set the scroll mode for both directions. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_scroll_mode ( self , mode : str ): \"\"\"Set the scroll mode for both directions. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ]) self . setVerticalScrollMode ( SCROLL_MODES [ mode ]) set_selection_behaviour ( self , behaviour ) Set selection behaviour for given item view. Allowed values are \"rows\", \"columns\", \"items\" Parameters: Name Type Description Default behaviour str selection behaviour to use required Exceptions: Type Description InvalidParamError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_behaviour ( self , behaviour : str ): \"\"\"Set selection behaviour for given item view. Allowed values are \"rows\", \"columns\", \"items\" Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOURS : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOURS ) self . setSelectionBehavior ( SELECTION_BEHAVIOURS [ behaviour ]) set_selection_mode ( self , mode ) Set selection mode for given item view. Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"Set selection mode for given item view. Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise InvalidParamError ( mode , SELECTION_MODES ) self . setSelectionMode ( SELECTION_MODES [ mode ]) set_vertical_scroll_mode ( self , mode ) Set the vertical scroll mode. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_vertical_scroll_mode ( self , mode : str ): \"\"\"Set the vertical scroll mode. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setVerticalScrollMode ( SCROLL_MODES [ mode ]) toggle_select_all ( self ) Select all items from list (deselect when all selected). Source code in prettyqt/widgets/abstractitemview.py def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return None if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll () abstractscrollarea AbstractScrollArea get_size_adjust_policy ( self ) Return size adjust policy. possible values are \"content\", \"first_show\", \"ignored\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def get_size_adjust_policy ( self ) -> str : \"\"\"Return size adjust policy. possible values are \"content\", \"first_show\", \"ignored\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()] scroll_to_bottom ( self ) Scroll to the bottom of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max () scroll_to_top ( self ) Scroll to the top of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min () set_horizontal_scrollbar_policy ( self , mode ) Set the horizontal scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_policy ( self , mode : str ): \"\"\"Set the horizontal scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_horizontal_scrollbar_width ( self , width ) Set the horizontal scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) set_scrollbar_policy ( self , mode ) Set the policy for both scrollbars. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_policy ( self , mode : str ): \"\"\"Set the policy for both scrollbars. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_scrollbar_width ( self , width ) Set the width for both scrollbars. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width ) set_size_adjust_policy ( self , policy ) Set size adjust policy. Valid values are \"content\", \"first_show\", \"ignored\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def set_size_adjust_policy ( self , policy : str ): \"\"\"Set size adjust policy. Valid values are \"content\", \"first_show\", \"ignored\" Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise InvalidParamError ( policy , SIZE_POLICIES ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy ) set_vertical_scrollbar_policy ( self , mode ) Set the vertical scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_policy ( self , mode : str ): \"\"\"Set the vertical scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_vertical_scrollbar_width ( self , width ) Set the vertical scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) abstractslider AbstractSlider get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/abstractslider.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()] get_repeat_action ( self ) Get current repeat action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Returns: Type Description str current repeat action Source code in prettyqt/widgets/abstractslider.py def get_repeat_action ( self ) -> str : \"\"\"Get current repeat action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Returns: current repeat action \"\"\" return SLIDER_ACTIONS . inv [ self . repeatAction ()] is_horizontal ( self ) Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == QtCore . Qt . Horizontal is_vertical ( self ) Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == QtCore . Qt . Vertical scroll_to_max ( self ) Scroll to the maximum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ()) scroll_to_min ( self ) Scroll to the minimum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ()) set_horizontal ( self ) Set slider orientation to horizontal. Source code in prettyqt/widgets/abstractslider.py def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( QtCore . Qt . Horizontal ) set_orientation ( self , orientation ) Set the orientation of the slider. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the slider required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/abstractslider.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the slider. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) set_repeat_action ( self , action , threshold = 500 , repeat_time = 50 ) Set the repeat action. Valid values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Parameters: Name Type Description Default action str repeat action required Exceptions: Type Description InvalidParamError invalid repeat action Source code in prettyqt/widgets/abstractslider.py def set_repeat_action ( self , action : str , threshold : int = 500 , repeat_time : int = 50 ): \"\"\"Set the repeat action. Valid values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Args: action: repeat action Raises: InvalidParamError: invalid repeat action \"\"\" if action not in SLIDER_ACTIONS : raise InvalidParamError ( action , SLIDER_ACTIONS ) self . setRepeatAction ( SLIDER_ACTIONS [ action ], threshold , repeat_time ) set_vertical ( self ) Set slider orientation to vertical. Source code in prettyqt/widgets/abstractslider.py def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( QtCore . Qt . Vertical ) trigger_action ( self , action ) Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Source code in prettyqt/widgets/abstractslider.py def trigger_action ( self , action : str ): \"\"\"Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" \"\"\" if action not in SLIDER_ACTIONS : raise InvalidParamError ( action , SLIDER_ACTIONS ) self . triggerAction ( SLIDER_ACTIONS [ action ]) abstractspinbox AbstractSpinBox get_button_symbols ( self ) Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: Type Description str button symbol type Source code in prettyqt/widgets/abstractspinbox.py def get_button_symbols ( self ) -> str : \"\"\"Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: button symbol type \"\"\" return SYMBOLS . inv [ self . buttonSymbols ()] get_correction_mode ( self ) Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: Type Description str correction mode Source code in prettyqt/widgets/abstractspinbox.py def get_correction_mode ( self ) -> str : \"\"\"Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: correction mode \"\"\" return CORRECTION_MODES . inv [ self . correctionMode ()] get_step_type ( self ) Return step type. possible values are \"default\", \"adaptive\" Returns: Type Description str step type Source code in prettyqt/widgets/abstractspinbox.py def get_step_type ( self ) -> str : \"\"\"Return step type. possible values are \"default\", \"adaptive\" Returns: step type \"\"\" return STEP_TYPES . inv [ self . stepType ()] set_button_symbols ( self , mode ) Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Parameters: Name Type Description Default mode str button symbol type to use required Exceptions: Type Description InvalidParamError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py def set_button_symbols ( self , mode : str ): \"\"\"Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ]) set_correction_mode ( self , mode ) Set correction mode. possible values are \"to_previous\", \"to_nearest\" Parameters: Name Type Description Default mode str correction mode to use required Exceptions: Type Description InvalidParamError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py def set_correction_mode ( self , mode : str ): \"\"\"Set correction mode. possible values are \"to_previous\", \"to_nearest\" Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ]) set_step_type ( self , mode ) Set step type. possible values are \"default\", \"adaptive\" Parameters: Name Type Description Default mode str step type to use required Exceptions: Type Description InvalidParamError invalid step type Source code in prettyqt/widgets/abstractspinbox.py def set_step_type ( self , mode : str ): \"\"\"Set step type. possible values are \"default\", \"adaptive\" Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ]) action Action get_menu_role ( self ) Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: Type Description str menu role Source code in prettyqt/widgets/action.py def get_menu_role ( self ) -> str : \"\"\"Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: menu role \"\"\" return ROLES . inv [ self . menuRole ()] get_priority ( self ) Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: Type Description str priority Source code in prettyqt/widgets/action.py def get_priority ( self ) -> str : \"\"\"Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: priority \"\"\" return PRIORITIES . inv [ self . priority ()] get_shortcut_context ( self ) Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: Type Description str shortcut context Source code in prettyqt/widgets/action.py def get_shortcut_context ( self ) -> str : \"\"\"Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: shortcut context \"\"\" return CONTEXTS . inv [ self . shortcutContext ()] set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/action.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) set_menu_role ( self , role ) Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Parameters: Name Type Description Default role str menu role required Exceptions: Type Description InvalidParamError menu role does not exist Source code in prettyqt/widgets/action.py def set_menu_role ( self , role : str ): \"\"\"Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ]) set_priority ( self , priority ) Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Parameters: Name Type Description Default priority str priority for the action required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/widgets/action.py def set_priority ( self , priority : str ): \"\"\"Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ]) set_shortcut_context ( self , context ) Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Parameters: Name Type Description Default context str shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/action.py def set_shortcut_context ( self , context : str ): \"\"\"Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in CONTEXTS : raise InvalidParamError ( context , CONTEXTS ) self . setShortcutContext ( CONTEXTS [ context ]) actiongroup ActionGroup get_exclusion_policy ( self ) Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: Type Description str exclusion policy Source code in prettyqt/widgets/actiongroup.py def get_exclusion_policy ( self ) -> str : \"\"\"Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: exclusion policy \"\"\" return POLICIES . inv [ self . exclusionPolicy ()] set_exclusion_policy ( self , policy ) Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Parameters: Name Type Description Default policy Optional[str] exclusion policy to use required Exceptions: Type Description InvalidParamError exclusion policy does not exist Source code in prettyqt/widgets/actiongroup.py def set_exclusion_policy ( self , policy : Optional [ str ]): \"\"\"Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ]) application Application copy_to_clipboard ( text ) classmethod Sets clipboard to supplied text. Source code in prettyqt/widgets/application.py @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Clipboard ) cb . setText ( text , mode = cb . Clipboard ) set_icon ( self , icon ) Set the default window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/application.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) calendarwidget CalendarWidget get_selection_mode ( self ) Return current selection mode. Possible values: \"single\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/calendarwidget.py def get_selection_mode ( self ) -> str : \"\"\"Return current selection mode. Possible values: \"single\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()] set_selection_mode ( self , mode ) Set selection mode for given calendar widget. Allowed values are \"single\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/calendarwidget.py def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"Set selection mode for given calendar widget. Allowed values are \"single\" or \"none\" Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise InvalidParamError ( mode , SELECTION_MODES ) self . setSelectionMode ( SELECTION_MODES [ mode ]) checkbox CheckBox get_checkstate ( self ) Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description bool checkstate Source code in prettyqt/widgets/checkbox.py def get_checkstate ( self ) -> bool : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()] set_checkstate ( self , state ) Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/checkbox.py def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( STATES [ state ]) combobox ComboBox get_insert_policy ( self ) Return insert policy. possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: Type Description str insert policy Source code in prettyqt/widgets/combobox.py def get_insert_policy ( self ) -> str : \"\"\"Return insert policy. possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: insert policy \"\"\" return INSERT_POLICIES . inv [ self . insertPolicy ()] get_size_adjust_policy ( self ) Return size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/combobox.py def get_size_adjust_policy ( self ) -> str : \"\"\"Return size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()] set_insert_policy ( self , policy ) Set insert policy. valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Parameters: Name Type Description Default policy str insert policy to use required Exceptions: Type Description InvalidParamError invalid insert policy Source code in prettyqt/widgets/combobox.py def set_insert_policy ( self , policy : str ): \"\"\"Set insert policy. valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICIES : raise InvalidParamError ( policy , INSERT_POLICIES ) policy = INSERT_POLICIES . get ( policy ) self . setInsertPolicy ( policy ) set_size_adjust_policy ( self , policy ) Set size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/combobox.py def set_size_adjust_policy ( self , policy : str ): \"\"\"Set size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise InvalidParamError ( policy , SIZE_POLICIES ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy ) completer Completer get_completion_mode ( self ) Return current completion mode. Possible values: \"popup\", \"inline\", \"unfiltered_popup\" Returns: Type Description str completion mode Source code in prettyqt/widgets/completer.py def get_completion_mode ( self ) -> str : \"\"\"Return current completion mode. Possible values: \"popup\", \"inline\", \"unfiltered_popup\" Returns: completion mode \"\"\" return COMPLETION_MODES . inv [ self . completionMode ()] get_filter_mode ( self ) Return current filter mode. Possible values: \"starts_with\", \"contains\", \"ends_with\" Returns: Type Description str filter mode Source code in prettyqt/widgets/completer.py def get_filter_mode ( self ) -> str : \"\"\"Return current filter mode. Possible values: \"starts_with\", \"contains\", \"ends_with\" Returns: filter mode \"\"\" return FILTER_MODES . inv [ self . filterMode ()] get_sort_mode ( self ) Return current sort mode. Possible values: \"unsorted\", \"case_sensitive\", \"case_insensitive\" Returns: Type Description str sort mode Source code in prettyqt/widgets/completer.py def get_sort_mode ( self ) -> str : \"\"\"Return current sort mode. Possible values: \"unsorted\", \"case_sensitive\", \"case_insensitive\" Returns: sort mode \"\"\" return SORT_MODES . inv [ self . modelSorting ()] set_completion_mode ( self , mode ) Set completion mode to use. Allowed values are \"popup\", \"inline\", \"unfiltered_popup\" Parameters: Name Type Description Default mode str completion mode to use required Exceptions: Type Description InvalidParamError completion mode does not exist Source code in prettyqt/widgets/completer.py def set_completion_mode ( self , mode : str ): \"\"\"Set completion mode to use. Allowed values are \"popup\", \"inline\", \"unfiltered_popup\" Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODES : raise InvalidParamError ( mode , COMPLETION_MODES ) self . setCompletionMode ( COMPLETION_MODES [ mode ]) set_filter_mode ( self , mode ) Set filter mode to use. Allowed values are \"starts_with\", \"contains\", \"ends_with\" Parameters: Name Type Description Default mode str filter mode to use required Exceptions: Type Description InvalidParamError filter mode does not exist Source code in prettyqt/widgets/completer.py def set_filter_mode ( self , mode : str ): \"\"\"Set filter mode to use. Allowed values are \"starts_with\", \"contains\", \"ends_with\" Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in FILTER_MODES : raise InvalidParamError ( mode , FILTER_MODES ) self . setFilterMode ( FILTER_MODES [ mode ]) set_sort_mode ( self , mode ) Set sort mode to use. Allowed values are \"unsorted\", \"case_sensitive\", \"case_insensitive\" Parameters: Name Type Description Default mode Optional[str] sort mode to use required Exceptions: Type Description InvalidParamError sort mode does not exist Source code in prettyqt/widgets/completer.py def set_sort_mode ( self , mode : Optional [ str ]): \"\"\"Set sort mode to use. Allowed values are \"unsorted\", \"case_sensitive\", \"case_insensitive\" Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODES : raise InvalidParamError ( mode , SORT_MODES ) self . setModelSorting ( SORT_MODES [ mode ]) datawidgetmapper DataWidgetMapper get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/datawidgetmapper.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()] get_submit_policy ( self ) Return current submit policy. Possible values: \"auto\", \"manual\" Returns: Type Description str submit policy Source code in prettyqt/widgets/datawidgetmapper.py def get_submit_policy ( self ) -> str : \"\"\"Return current submit policy. Possible values: \"auto\", \"manual\" Returns: submit policy \"\"\" return SUBMIT_POLICIES . inv [ self . submitPolicy ()] set_orientation ( self , orientation ) Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) set_submit_policy ( self , policy ) Set the submit policy of the mapper. Allowed values are \"auto\", \"manual\" Parameters: Name Type Description Default submit_policy submit_policy for the splitter required Exceptions: Type Description InvalidParamError submit_policy does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_submit_policy ( self , policy : str ): \"\"\"Set the submit policy of the mapper. Allowed values are \"auto\", \"manual\" Args: submit_policy: submit_policy for the splitter Raises: InvalidParamError: submit_policy does not exist \"\"\" if policy not in SUBMIT_POLICIES : raise InvalidParamError ( policy , SUBMIT_POLICIES ) self . setSubmitPolicy ( SUBMIT_POLICIES [ policy ]) dialog BaseDialog keyPressEvent ( self , e ) keyPressEvent(self, QKeyEvent) Source code in prettyqt/widgets/dialog.py def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e ) dialogbuttonbox DialogButtonBox add_button ( self , button , role = 'accept' , callback = None ) Add a button. Parameters: Name Type Description Default button Union[PyQt5.QtWidgets.QPushButton, str] button to add required role str role of the button 'accept' callback Optional[Callable] function to call when button gets clicked None Returns: Type Description PushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_button ( self , button : Union [ QtWidgets . QPushButton , str ], role : str = \"accept\" , callback : Optional [ Callable ] = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button add_default_button ( self , button , callback = None ) Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required callback Optional[Callable] function to call when button gets clicked None Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_default_button ( self , button : str , callback : Optional [ Callable ] = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn create ( ** kwargs ) classmethod create(self, window: sip.voidptr = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) Source code in prettyqt/widgets/dialogbuttonbox.py @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) return box get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/dialogbuttonbox.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()] set_orientation ( self , orientation ) Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the button box required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) dockwidget DockWidget Customized DockWidget class. Contains a custom TitleBar with maximise button filedialog FileDialog Simple dialog used to display some widget. directory ( self ) Return current directory. returns current directory level as a Pathlib object Returns: Type Description Path Pathlib object Source code in prettyqt/widgets/filedialog.py def directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( super () . directory ()) get_accept_mode ( self ) Return accept mode. possible values are \"save\", \"open\" Returns: Type Description str accept mode Source code in prettyqt/widgets/filedialog.py def get_accept_mode ( self ) -> str : \"\"\"Return accept mode. possible values are \"save\", \"open\" Returns: accept mode \"\"\" return ACCEPT_MODES . inv [ self . acceptMode ()] get_file_mode ( self ) Return file mode. possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: Type Description str file mode Source code in prettyqt/widgets/filedialog.py def get_file_mode ( self ) -> str : \"\"\"Return file mode. possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: file mode \"\"\" return MODES . inv [ self . fileMode ()] get_label_text ( self , label ) Return label text. possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py def get_label_text ( self , label ) -> str : \"\"\"Return label text. possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: label text \"\"\" return self . labelText ( LABELS . inv [ label ]) get_view_mode ( self ) Return view mode. possible values are \"detail\", \"list\" Returns: Type Description str view mode Source code in prettyqt/widgets/filedialog.py def get_view_mode ( self ) -> str : \"\"\"Return view mode. possible values are \"detail\", \"list\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()] set_accept_mode ( self , mode ) Set accept mode. possible values are \"save\", \"open\" Parameters: Name Type Description Default mode str accept mode to use required Exceptions: Type Description InvalidParamError invalid accept mode Source code in prettyqt/widgets/filedialog.py def set_accept_mode ( self , mode : str ): \"\"\"Set accept mode. possible values are \"save\", \"open\" Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODES : raise InvalidParamError ( mode , ACCEPT_MODES ) self . setAcceptMode ( ACCEPT_MODES [ mode ]) set_directory ( self , path ) Set start directory. Source code in prettyqt/widgets/filedialog.py def set_directory ( self , path : Union [ None , str , pathlib . Path ]): \"\"\"Set start directory.\"\"\" if isinstance ( path , pathlib . Path ): path = str ( path ) self . setDirectory ( path ) set_extension_filter ( self , extension_dict ) Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict Dict[str, List[str]] filter dictionary required Source code in prettyqt/widgets/filedialog.py def set_extension_filter ( self , extension_dict : Dict [ str , List [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str ) set_file_mode ( self , mode ) Set the file mode of the dialog. allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Parameters: Name Type Description Default mode str mode to use required Source code in prettyqt/widgets/filedialog.py def set_file_mode ( self , mode : str ): \"\"\"Set the file mode of the dialog. allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Args: mode: mode to use \"\"\" self . setFileMode ( MODES [ mode ]) set_label_text ( self , label , text ) Set the label text for button label. possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Parameters: Name Type Description Default label str button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py def set_label_text ( self , label : str , text : str ): \"\"\"Set the label text for button label. possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Args: label: button to set text for text: text to use \"\"\" if label not in LABELS : raise InvalidParamError ( label , LABELS ) self . setLabelText ( LABELS [ label ], text ) set_view_mode ( self , mode ) Set view mode. possible values are \"detail\", \"list\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/filedialog.py def set_view_mode ( self , mode : str ): \"\"\"Set view mode. possible values are \"detail\", \"list\" Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ]) filesystemmodel FileSystemModel Class to populate a filesystem treeview. data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/widgets/filesystemmodel.py def data ( self , index , role = QtCore . Qt . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role ) fontcombobox FontComboBox get_font_filters ( self ) Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: Type Description List[str] font filter list Source code in prettyqt/widgets/fontcombobox.py def get_font_filters ( self ) -> List [ str ]: \"\"\"Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()] set_font_filters ( self , * filters ) Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Parameters: Name Type Description Default filters str font filters to use () Exceptions: Type Description InvalidParamError invalid font filters Source code in prettyqt/widgets/fontcombobox.py def set_font_filters ( self , * filters : str ): \"\"\"Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags ) formlayout FormLayout __len__ ( self ) special Needed for PySide2. Source code in prettyqt/widgets/formlayout.py def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount () frame Frame get_frame_shadow ( self ) Return current frame shadow. Possible values: \"plain\", \"raised\", \"sunken\" Returns: Type Description str frame style Source code in prettyqt/widgets/frame.py def get_frame_shadow ( self ) -> str : \"\"\"Return current frame shadow. Possible values: \"plain\", \"raised\", \"sunken\" Returns: frame style \"\"\" return SHADOWS . inv [ self . frameShadow ()] get_frame_shape ( self ) Return current frame shape. Possible values: \"plain\", \"raised\", \"sunken\" Returns: Type Description str frame shape Source code in prettyqt/widgets/frame.py def get_frame_shape ( self ) -> str : \"\"\"Return current frame shape. Possible values: \"plain\", \"raised\", \"sunken\" Returns: frame shape \"\"\" return SHAPES . inv [ self . frameShape ()] set_frame_shadow ( self , style ) Set frame shadow. Allowed values are \"plain\", \"raised\", \"sunken\" Parameters: Name Type Description Default style str frame style to use required Exceptions: Type Description InvalidParamError style does not exist Source code in prettyqt/widgets/frame.py def set_frame_shadow ( self , style : str ): \"\"\"Set frame shadow. Allowed values are \"plain\", \"raised\", \"sunken\" Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style not in SHADOWS : raise InvalidParamError ( style , SHADOWS ) self . setFrameShadow ( SHADOWS [ style ]) set_frame_shape ( self , shape ) Set frame shape. Allowed values are \"plain\", \"raised\", \"sunken\" Parameters: Name Type Description Default shape str frame shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/widgets/frame.py def set_frame_shape ( self , shape : str ): \"\"\"Set frame shape. Allowed values are \"plain\", \"raised\", \"sunken\" Args: shape: frame shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in SHAPES : raise InvalidParamError ( shape , SHAPES ) self . setFrameShape ( SHAPES [ shape ]) graphicsitem GraphicsItem get_panel_modality ( self ) Get the current modality modes as a string. Possible values: \"none\", \"panel\", \"scene\" Returns: Type Description str panel modality str Source code in prettyqt/widgets/graphicsitem.py def get_panel_modality ( self ) -> str : \"\"\"Get the current modality modes as a string. Possible values: \"none\", \"panel\", \"scene\" Returns: panel modality str \"\"\" return MODALITIES . inv [ self . panelModality ()] set_panel_modality ( self , modality = 'window' ) Set panel modality. Valid values for modality: \"none\", \"panel\", \"scene\" Parameters: Name Type Description Default modality str panel modality 'window' Exceptions: Type Description InvalidParamError panel modality does not exist Source code in prettyqt/widgets/graphicsitem.py def set_panel_modality ( self , modality : str = \"window\" ) -> None : \"\"\"Set panel modality. Valid values for modality: \"none\", \"panel\", \"scene\" Args: modality: panel modality Raises: InvalidParamError: panel modality does not exist \"\"\" if modality not in MODALITIES : raise InvalidParamError ( modality , MODALITIES ) self . setPanelModality ( MODALITIES [ modality ]) graphicsscene GraphicsScene get_item_index_method ( self ) Return item index method. possible values are \"bsp_tree\", \"none\" Returns: Type Description str item index method Source code in prettyqt/widgets/graphicsscene.py def get_item_index_method ( self ) -> str : \"\"\"Return item index method. possible values are \"bsp_tree\", \"none\" Returns: item index method \"\"\" return ITEM_INDEX_METHODS . inv [ self . itemIndexMethod ()] set_item_index_method ( self , method ) Set item index method. possible values are \"bsp_tree\", \"none\" Parameters: Name Type Description Default method str item index method to use required Exceptions: Type Description InvalidParamError invalid item index method Source code in prettyqt/widgets/graphicsscene.py def set_item_index_method ( self , method : str ): \"\"\"Set item index method. possible values are \"bsp_tree\", \"none\" Args: method: item index method to use Raises: InvalidParamError: invalid item index method \"\"\" if method not in ITEM_INDEX_METHODS : raise InvalidParamError ( method , ITEM_INDEX_METHODS ) self . setItemIndexMethod ( ITEM_INDEX_METHODS [ method ]) graphicsview GraphicsView get_cache_mode ( self ) Return current cache mode. Possible values: \"none\", \"background\" Returns: Type Description str cache mode Source code in prettyqt/widgets/graphicsview.py def get_cache_mode ( self ) -> str : \"\"\"Return current cache mode. Possible values: \"none\", \"background\" Returns: cache mode \"\"\" return CACHE_MODES . inv [ self . cacheMode ()] get_drag_mode ( self ) Return current drag mode. Possible values: \"none\", \"scroll_hand\", \"rubber_band\" Returns: Type Description str drag mode Source code in prettyqt/widgets/graphicsview.py def get_drag_mode ( self ) -> str : \"\"\"Return current drag mode. Possible values: \"none\", \"scroll_hand\", \"rubber_band\" Returns: drag mode \"\"\" return DRAG_MODES . inv [ self . dragMode ()] get_resize_anchor ( self ) Return current resize anchor. Possible values: \"none\", \"view_center\", \"under_mouse\" Returns: Type Description str resize anchor Source code in prettyqt/widgets/graphicsview.py def get_resize_anchor ( self ) -> str : \"\"\"Return current resize anchor. Possible values: \"none\", \"view_center\", \"under_mouse\" Returns: resize anchor \"\"\" return VIEWPORT_ANCHORS . inv [ self . resizeAnchor ()] get_rubberband_selection_mode ( self ) Return current rubberband selection mode. Possible values: \"contains_shape\", \"intersects_shape\", \"contains_bounding_rect\", \"intersects_bounding_rect\" Returns: Type Description str rubberband selection mode Source code in prettyqt/widgets/graphicsview.py def get_rubberband_selection_mode ( self ) -> str : \"\"\"Return current rubberband selection mode. Possible values: \"contains_shape\", \"intersects_shape\", \"contains_bounding_rect\", \"intersects_bounding_rect\" Returns: rubberband selection mode \"\"\" return ITEM_SELECTION_MODES . inv [ self . rubberBandSelectionMode ()] get_transformation_anchor ( self ) Return current transformation anchor. Possible values: \"none\", \"view_center\", \"under_mouse\" Returns: Type Description str viewport anchor Source code in prettyqt/widgets/graphicsview.py def get_transformation_anchor ( self ) -> str : \"\"\"Return current transformation anchor. Possible values: \"none\", \"view_center\", \"under_mouse\" Returns: viewport anchor \"\"\" return VIEWPORT_ANCHORS . inv [ self . transformationAnchor ()] get_viewport_update_mode ( self ) Return current viewport update mode. Possible values: \"full\", \"minimal\", \"smart\", \"bounding_rect\", \"none\" Returns: Type Description str viewport update mode Source code in prettyqt/widgets/graphicsview.py def get_viewport_update_mode ( self ) -> str : \"\"\"Return current viewport update mode. Possible values: \"full\", \"minimal\", \"smart\", \"bounding_rect\", \"none\" Returns: viewport update mode \"\"\" return VIEWPORT_UPDATE_MODES . inv [ self . viewportUpdateMode ()] set_cache_mode ( self , mode ) Set the cache mode. Allowed values are \"none\", \"background\" Parameters: Name Type Description Default mode str cache mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_cache_mode ( self , mode : str ): \"\"\"Set the cache mode. Allowed values are \"none\", \"background\" Args: mode: cache mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ]) set_drag_mode ( self , mode ) Set the behavior for dragging the mouse while the left mouse button is pressed. Allowed values are \"none\", \"scroll_hand\", \"rubber_band\" Parameters: Name Type Description Default mode str drag mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_drag_mode ( self , mode : str ): \"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed. Allowed values are \"none\", \"scroll_hand\", \"rubber_band\" Args: mode: drag mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_MODES : raise InvalidParamError ( mode , DRAG_MODES ) self . setDragMode ( DRAG_MODES [ mode ]) set_resize_anchor ( self , mode ) Set how the view should position the scene during resizes. Allowed values are \"none\", \"view_center\", \"under_mouse\" Parameters: Name Type Description Default mode str resize anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_resize_anchor ( self , mode : str ): \"\"\"Set how the view should position the scene during resizes. Allowed values are \"none\", \"view_center\", \"under_mouse\" Args: mode: resize anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHORS : raise InvalidParamError ( mode , VIEWPORT_ANCHORS ) self . setResizeAnchor ( VIEWPORT_ANCHORS [ mode ]) set_rubberband_selection_mode ( self , mode ) Set the behavior for selecting items with a rubber band selection rectangle. Allowed values are \"contains_shape\", \"intersects_shape\", \"contains_bounding_rect\", \"intersects_bounding_rect\" Parameters: Name Type Description Default mode str rubberband selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_rubberband_selection_mode ( self , mode : str ): \"\"\"Set the behavior for selecting items with a rubber band selection rectangle. Allowed values are \"contains_shape\", \"intersects_shape\", \"contains_bounding_rect\", \"intersects_bounding_rect\" Args: mode: rubberband selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in ITEM_SELECTION_MODES : raise InvalidParamError ( mode , ITEM_SELECTION_MODES ) self . setRubberBandSelectionMode ( ITEM_SELECTION_MODES [ mode ]) set_transformation_anchor ( self , mode ) Set how the view should position the scene during transformations. Allowed values are \"none\", \"view_center\", \"under_mouse\" Parameters: Name Type Description Default mode str transformation anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_transformation_anchor ( self , mode : str ): \"\"\"Set how the view should position the scene during transformations. Allowed values are \"none\", \"view_center\", \"under_mouse\" Args: mode: transformation anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHORS : raise InvalidParamError ( mode , VIEWPORT_ANCHORS ) self . setTransformationAnchor ( VIEWPORT_ANCHORS [ mode ]) set_viewport_update_mode ( self , mode ) Set how the viewport should update its contents. Allowed values are \"full\", \"minimal\", \"smart\", \"bounding_rect\", \"none\" Parameters: Name Type Description Default mode str viewport update mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_viewport_update_mode ( self , mode : str ): \"\"\"Set how the viewport should update its contents. Allowed values are \"full\", \"minimal\", \"smart\", \"bounding_rect\", \"none\" Args: mode: viewport update mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_UPDATE_MODES : raise InvalidParamError ( mode , VIEWPORT_UPDATE_MODES ) self . setViewportUpdateMode ( VIEWPORT_UPDATE_MODES [ mode ]) graphicswidget GraphicsWidget get_focus_policy ( self ) Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: Type Description str str: Focus policy Source code in prettyqt/widgets/graphicswidget.py def get_focus_policy ( self ) -> str : \"\"\"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: str: Focus policy \"\"\" return FOCUS_POLICIES . inv [ self . focusPolicy ()] set_focus_policy ( self , policy ) Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Parameters: Name Type Description Default policy str Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/graphicswidget.py def set_focus_policy ( self , policy : str ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in FOCUS_POLICIES : raise InvalidParamError ( policy , FOCUS_POLICIES ) self . setFocusPolicy ( FOCUS_POLICIES [ policy ]) groupbox GroupBox GroupBox widget. A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets. headerview HeaderView contextMenuEvent ( self , event ) Context menu for our files tree. Source code in prettyqt/widgets/headerview.py def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) actions = self . get_header_actions () menu . add_actions ( actions ) menu . exec_ ( self . mapToGlobal ( event . pos ())) label Label get_text_format ( self ) Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str text format Source code in prettyqt/widgets/label.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()] get_text_interaction ( self ) Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: Type Description List[str] list of text interaction modes Source code in prettyqt/widgets/label.py def get_text_interaction ( self ) -> List [ str ]: \"\"\"Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()] set_alignment ( self , horizontal = None , vertical = None ) Set the alignment of the label's contents. Source code in prettyqt/widgets/label.py def set_alignment ( self , horizontal : Optional [ str ] = None , vertical : Optional [ str ] = None ): \"\"\"Set the alignment of the label's contents.\"\"\" if horizontal is None and vertical is not None : flag = V_ALIGNMENTS [ vertical ] elif vertical is None and horizontal is not None : flag = H_ALIGNMENTS [ horizontal ] elif vertical is not None and horizontal is not None : flag = V_ALIGNMENTS [ vertical ] | H_ALIGNMENTS [ horizontal ] else : return self . setAlignment ( flag ) return self set_indent ( self , indent ) Set the label's text indent in pixels. Source code in prettyqt/widgets/label.py def set_indent ( self , indent : int ) -> \"Label\" : \"\"\"Set the label's text indent in pixels.\"\"\" self . setIndent ( indent ) return self set_text ( self , text ) Set the label's text. Source code in prettyqt/widgets/label.py def set_text ( self , text : str ) -> \"Label\" : \"\"\"Set the label's text.\"\"\" self . setText ( text ) return self set_text_format ( self , text_format ) Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/label.py def set_text_format ( self , text_format : str ) -> \"Label\" : \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise InvalidParamError ( text_format , TEXT_FORMATS ) self . setTextFormat ( TEXT_FORMATS [ text_format ]) return self set_text_interaction ( self , * types ) Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Parameters: Name Type Description Default types str text interaction mode to use () Exceptions: Type Description InvalidParamError text interaction mode does not exist Source code in prettyqt/widgets/label.py def set_text_interaction ( self , * types : str ) -> \"Label\" : \"\"\"Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self set_weight ( self , weight ) Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/widgets/label.py def set_weight ( self , weight : str ) -> \"Label\" : \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) font = self . font () font . setWeight ( WEIGHTS [ weight ]) self . setFont ( font ) return self layout Layout get_size_mode ( self ) Return current size mode. Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: Type Description str size mode Source code in prettyqt/widgets/layout.py def get_size_mode ( self ) -> str : \"\"\"Return current size mode. Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: size mode \"\"\" return MODES . inv [ self . sizeConstraint ()] set_alignment ( self , alignment , item = None ) Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required item set alignment for specific child only None Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layout.py def set_alignment ( self , alignment : str , item = None ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) if item is not None : return self . setAlignment ( item , ALIGNMENTS [ alignment ]) else : return self . setAlignment ( ALIGNMENTS [ alignment ]) set_size_mode ( self , mode ) Set the size mode of the layout. Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Parameters: Name Type Description Default mode str size mode for the layout required Exceptions: Type Description InvalidParamError size mode does not exist Source code in prettyqt/widgets/layout.py def set_size_mode ( self , mode : str ): \"\"\"Set the size mode of the layout. Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setSizeConstraint ( MODES [ mode ]) lineedit LineEdit font ( self ) font(self) -> QFont Source code in prettyqt/widgets/lineedit.py def font ( self ) -> gui . Font : return gui . Font ( super () . font ()) get_echo_mode ( self ) Return echo mode. possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: Type Description str echo mode Source code in prettyqt/widgets/lineedit.py def get_echo_mode ( self ) -> str : \"\"\"Return echo mode. possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: echo mode \"\"\" return ECHO_MODES . inv [ self . echoMode ()] set_echo_mode ( self , mode ) Set echo mode. Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Parameters: Name Type Description Default mode str echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/lineedit.py def set_echo_mode ( self , mode : str ): \"\"\"Set echo mode. Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODES : raise InvalidParamError ( mode , ECHO_MODES ) self . setEchoMode ( ECHO_MODES [ mode ]) set_read_only ( self , value = True ) Set text to read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) listview ListView get_view_mode ( self ) Return view mode. possible values are \"list\", \"icon\" Returns: Type Description str view mode Source code in prettyqt/widgets/listview.py def get_view_mode ( self ) -> str : \"\"\"Return view mode. possible values are \"list\", \"icon\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()] set_view_mode ( self , mode ) Set view mode. possible values are \"list\", \"icon\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/listview.py def set_view_mode ( self , mode : str ): \"\"\"Set view mode. possible values are \"list\", \"icon\" Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ]) listwidgetitem ListWidgetItem get_checkstate ( self ) Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/listwidgetitem.py def get_checkstate ( self ) -> str : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()] set_checkstate ( self , state ) Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( STATES [ state ]) set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/listwidgetitem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) mainwindow MainWindow Class for our mainWindow. Includes all docks, a centralwidget and a toolbar add_toolbar ( self , toolbar , position = 'top' ) Adds a toolbar to the mainmenu at specified area. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default toolbar QToolBar toolbar to use required position str position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : str = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBar ( TOOLBAR_AREAS [ position ], toolbar ) add_toolbar_break ( self , position = 'top' ) Adds a toolbar break to the given area behind the last item. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default position str position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar_break ( self , position : str = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBarBreak ( TOOLBAR_AREAS [ position ]) createPopupMenu ( self ) createPopupMenu(self) -> QMenu Source code in prettyqt/widgets/mainwindow.py def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add_action ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add_action ( action ) return menu save_window_state ( self , recursive = False ) Save current window state as QSetting. Parameters: Name Type Description Default recursive bool Description False Source code in prettyqt/widgets/mainwindow.py def save_window_state ( self , recursive = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { name } ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state () toggle_fullscreen ( self ) Toggle between fullscreen and regular size. Source code in prettyqt/widgets/mainwindow.py def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen () mdiarea MdiArea get_tab_position ( self ) Return current tab position. Possible values: \"north\", \"south\", \"west\", \"east\" Returns: Type Description str tab position Source code in prettyqt/widgets/mdiarea.py def get_tab_position ( self ) -> str : \"\"\"Return current tab position. Possible values: \"north\", \"south\", \"west\", \"east\" Returns: tab position \"\"\" return TAB_POSITIONS . inv [ self . tabPosition ()] get_view_mode ( self ) Return current view mode. Possible values: \"default\", \"tabbed\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py def get_view_mode ( self ) -> str : \"\"\"Return current view mode. Possible values: \"default\", \"tabbed\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()] get_window_order ( self ) Return current window order. Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py def get_window_order ( self ) -> str : \"\"\"Return current window order. Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: view mode \"\"\" return WINDOW_ORDERS . inv [ self . activationOrder ()] set_tab_position ( self , position ) Set tab position for the MDI area. Valid values are \"north\", \"south\", \"west\", \"east\" Parameters: Name Type Description Default position str tabs position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/mdiarea.py def set_tab_position ( self , position : str ): \"\"\"Set tab position for the MDI area. Valid values are \"north\", \"south\", \"west\", \"east\" Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITIONS : raise InvalidParamError ( position , TAB_POSITIONS ) self . setTabPosition ( TAB_POSITIONS [ position ]) set_view_mode ( self , mode ) Set view mode for the MDI area. Valid values are \"default\", \"tabbed\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError view mode does not exist Source code in prettyqt/widgets/mdiarea.py def set_view_mode ( self , mode : str ): \"\"\"Set view mode for the MDI area. Valid values are \"default\", \"tabbed\" Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ]) set_window_order ( self , mode ) Set the window order behaviour for the MDI area. Valid values are \"creation\", \"stacking\", \"activation_history\" Parameters: Name Type Description Default mode str window order behaviour to use required Exceptions: Type Description InvalidParamError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py def set_window_order ( self , mode : str ): \"\"\"Set the window order behaviour for the MDI area. Valid values are \"creation\", \"stacking\", \"activation_history\" Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDERS : raise InvalidParamError ( mode , WINDOW_ORDERS ) self . setActivationOrder ( WINDOW_ORDERS [ mode ]) menu Menu add_action ( self , label , callback = None , icon = None , checkable = False , checked = False , shortcut = None , status_tip = None ) Add an action to the menu. Parameters: Name Type Description Default label Union[str, prettyqt.widgets.action.Action] Label for button required callback Callable gets called when action is triggered None icon Optional[Any] icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut Optional[str] Shortcut for action None status_tip Optional[str] Status tip to be shown in status bar None Returns: Type Description Action Action added to menu Source code in prettyqt/widgets/menu.py def add_action ( self , label : Union [ str , widgets . Action ], callback : Callable = None , icon : Optional [ Any ] = None , checkable : bool = False , checked : bool = False , shortcut : Optional [ str ] = None , status_tip : Optional [ str ] = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action add_separator ( self , text = None ) Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None Returns: Type Description WidgetAction Separator action Source code in prettyqt/widgets/menu.py def add_separator ( self , text : Optional [ str ] = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator set_icon ( self , icon ) Set the icon for the menu. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/menu.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) messagebox MessageBox add_button ( self , button ) Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/messagebox.py def add_button ( self , button : str ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ]) get_text_format ( self ) Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/messagebox.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()] set_icon ( self , icon ) Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/messagebox.py def set_icon ( self , icon : gui . icon . IconType ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) return None icon = gui . icon . get_icon ( icon ) self . setIconPixmap ( icon . get_pixmap ( size = 64 )) set_text_format ( self , text_format ) Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/messagebox.py def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise InvalidParamError ( text_format , TEXT_FORMATS ) self . setTextFormat ( TEXT_FORMATS [ text_format ]) plaintextedit PlainTextEdit set_line_wrap_mode ( self , mode ) Set line wrap mode. Allowed values are \"none\" and \"widget width\" Parameters: Name Type Description Default mode str line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_line_wrap_mode ( self , mode : str ): \"\"\"Set line wrap mode. Allowed values are \"none\" and \"widget width\" Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODES : raise InvalidParamError ( mode , LINE_WRAP_MODES ) self . setLineWrapMode ( LINE_WRAP_MODES [ mode ]) set_read_only ( self , value = True ) Make the PlainTextEdit read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) set_wrap_mode ( self , mode ) Set word wrap mode. Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Parameters: Name Type Description Default mode str word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_wrap_mode ( self , mode : str ): \"\"\"Set word wrap mode. Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in WRAP_MODES : raise InvalidParamError ( mode , WRAP_MODES ) self . setWordWrapMode ( WRAP_MODES [ mode ]) wheelEvent ( self , event ) Handle wheel event for zooming. Source code in prettyqt/widgets/plaintextedit.py def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event ) progressbar ProgressBar Progress dialog. wrapper for QtWidgets.QProgressBar get_alignment ( self ) Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description str alignment Source code in prettyqt/widgets/progressbar.py def get_alignment ( self ) -> str : \"\"\"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" return ALIGNMENTS . inv [ self . alignment ()] get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/progressbar.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()] get_text_direction ( self ) Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Type Description str Text direction Source code in prettyqt/widgets/progressbar.py def get_text_direction ( self ) -> str : \"\"\"Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inv [ self . textDirection ()] set_alignment ( self , alignment ) Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/progressbar.py def set_alignment ( self , alignment : str ): \"\"\"Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) self . setAlignment ( ALIGNMENTS [ alignment ]) set_orientation ( self , orientation ) Set the orientation of the progress bar. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the progress bar required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/progressbar.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the progress bar. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the progress bar Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) set_text_direction ( self , text_direction ) Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Parameters: Name Type Description Default text_direction str text direction for the layout required Exceptions: Type Description InvalidParamError text direction does not exist Source code in prettyqt/widgets/progressbar.py def set_text_direction ( self , text_direction : str ): \"\"\"Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ]) progressdialog ProgressDialog Progress dialog. Wrapper for QtWidgets.QProgressDialog sizepolicy SizePolicy get_control_type ( self ) Return control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: Type Description str control type Source code in prettyqt/widgets/sizepolicy.py def get_control_type ( self ) -> str : \"\"\"Return control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: control type \"\"\" return CONTROL_TYPES . inv [ self . controlType ()] get_horizontal_policy ( self ) Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str horizontal size policy Source code in prettyqt/widgets/sizepolicy.py def get_horizontal_policy ( self ) -> str : \"\"\"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: horizontal size policy \"\"\" return SIZE_POLICIES . inv [ self . horizontalPolicy ()] get_vertical_policy ( self ) Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str vertical size policy Source code in prettyqt/widgets/sizepolicy.py def get_vertical_policy ( self ) -> str : \"\"\"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: vertical size policy \"\"\" return SIZE_POLICIES . inv [ self . verticalPolicy ()] set_control_type ( self , mode ) Set the control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Parameters: Name Type Description Default mode str control type to set required Source code in prettyqt/widgets/sizepolicy.py def set_control_type ( self , mode : str ) -> None : \"\"\"Set the control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Args: mode: control type to set \"\"\" self . setControlType ( CONTROL_TYPES [ mode ]) set_horizontal_policy ( self , mode ) Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py def set_horizontal_policy ( self , mode : str ) -> None : \"\"\"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setHorizontalPolicy ( SIZE_POLICIES [ mode ]) set_vertical_policy ( self , mode ) Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py def set_vertical_policy ( self , mode : str ) -> None : \"\"\"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setVerticalPolicy ( SIZE_POLICIES [ mode ]) slider Slider get_tick_position ( self ) Return tick position. possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: Type Description str tick position Source code in prettyqt/widgets/slider.py def get_tick_position ( self ) -> str : \"\"\"Return tick position. possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: tick position \"\"\" val = TICK_POSITIONS . inv [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\" return val set_tick_position ( self , position ) Set the tick position for the slider. allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Parameters: Name Type Description Default position str position for the ticks required Source code in prettyqt/widgets/slider.py def set_tick_position ( self , position : str ): \"\"\"Set the tick position for the slider. allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITIONS : raise InvalidParamError ( position , TICK_POSITIONS ) self . setTickPosition ( TICK_POSITIONS [ position ]) splitter Splitter get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/splitter.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()] set_orientation ( self , orientation ) Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitter.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) styleoptionslider StyleOptionSlider is_horizontal ( self ) Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == QtCore . Qt . Horizontal is_vertical ( self ) Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == QtCore . Qt . Vertical set_horizontal ( self ) Set slider orientation to horizontal. Source code in prettyqt/widgets/styleoptionslider.py def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = QtCore . Qt . Horizontal set_vertical ( self ) Set slider orientation to vertical. Source code in prettyqt/widgets/styleoptionslider.py def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = QtCore . Qt . Vertical systemtrayicon SystemTrayIcon set_icon ( self , icon ) Set the system tray icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/systemtrayicon.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) tabbar TabBar get_elide_mode ( self ) Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: Type Description str elide mode Source code in prettyqt/widgets/tabbar.py def get_elide_mode ( self ) -> str : \"\"\"Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: elide mode \"\"\" return ELIDE_MODES . inv [ self . elideMode ()] get_remove_behaviour ( self ) Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: Type Description str remove behaviour Source code in prettyqt/widgets/tabbar.py def get_remove_behaviour ( self ) -> str : \"\"\"Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOURS . inv [ self . selectionBehaviorOnRemove ()] mouseDoubleClickEvent ( self , event ) mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/widgets/tabbar.py def mouseDoubleClickEvent ( self , event ): event . accept () self . on_detach . emit ( self . tabAt ( event . pos ()), self . mouse_cursor . pos ()) set_elide_mode ( self , mode ) Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Parameters: Name Type Description Default mode str elide mode to use required Exceptions: Type Description InvalidParamError invalid elide mode Source code in prettyqt/widgets/tabbar.py def set_elide_mode ( self , mode : str ) -> None : \"\"\"Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in ELIDE_MODES : raise InvalidParamError ( mode , ELIDE_MODES ) self . setElideMode ( ELIDE_MODES [ mode ]) set_icon_size ( self , size ) Set the icon size for the tabs. Parameters: Name Type Description Default size int height/width of the icons required Source code in prettyqt/widgets/tabbar.py def set_icon_size ( self , size : int ) -> None : \"\"\"Set the icon size for the tabs. Args: size: height/width of the icons \"\"\" self . setIconSize ( QtCore . QSize ( size , size )) set_remove_behaviour ( self , mode ) Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Parameters: Name Type Description Default mode str new remove behaviour required Source code in prettyqt/widgets/tabbar.py def set_remove_behaviour ( self , mode : str ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOURS : raise InvalidParamError ( mode , REMOVE_BEHAVIOURS ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOURS [ mode ]) tabwidget DetachedTab Window containing a detached tab. When a tab is detached, the contents are placed into this QMainWindow. The tab can be re-attached by closing the dialog Attributes: Name Type Description on_close signal, emitted when window is closed (widget, title, icon) closeEvent ( self , event ) closeEvent(self, QCloseEvent) Source code in prettyqt/widgets/tabwidget.py def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . id , self . windowIcon ()) TabWidget Widget for managing the tabs section. attach_tab ( self , widget , name , icon = None , insert_at = None ) Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Parameters: Name Type Description Default widget Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] the content widget from the DetachedTab window required name str the name of the detached tab required icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] the window icon for the detached tab None insert_at Optional[int] insert the re-attached tab at the given index None Source code in prettyqt/widgets/tabwidget.py def attach_tab ( self , widget : Union [ QtWidgets . QWidget , QtWidgets . QLayout ], name : str , icon : gui . icon . IconType = None , insert_at : Optional [ int ] = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (gui.icon.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True ) close_detached_tabs ( self ) Close all tabs that are currently detached. Source code in prettyqt/widgets/tabwidget.py def close_detached_tabs ( self ) -> None : \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close () detach_tab ( self , index , point ) Detach tab by removing its contents and placing them in a DetachedTab window. Parameters: Name Type Description Default index int index location of the tab to be detached required point QPoint screen pos for creating the new DetachedTab window required Returns: Type Description None None: Description Source code in prettyqt/widgets/tabwidget.py @autoslot . AutoSlot def detach_tab ( self , index : int , point : QtCore . QPoint ) -> None : \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content name = self . tabText ( index ) icon = self . tabIcon ( index ) if icon . isNull (): icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab get_tab_position ( self ) Return tab position. possible values are \"north\", \"south\", \"east\", \"west\" Returns: Type Description str tab position Source code in prettyqt/widgets/tabwidget.py def get_tab_position ( self ) -> str : \"\"\"Return tab position. possible values are \"north\", \"south\", \"east\", \"west\" Returns: tab position \"\"\" return TAB_POSITIONS . inv [ self . tabPosition ()] get_tab_shape ( self ) Return tab shape. possible values are \"rounded\", \"triangular\" Returns: Type Description str tab shape Source code in prettyqt/widgets/tabwidget.py def get_tab_shape ( self ) -> str : \"\"\"Return tab shape. possible values are \"rounded\", \"triangular\" Returns: tab shape \"\"\" return TAB_SHAPES . inv [ self . tabShape ()] open_widget ( self , widget , title = 'Unnamed' ) Create a tab containing delivered widget. Source code in prettyqt/widgets/tabwidget.py @autoslot . AutoSlot def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True ) set_tab_position ( self , position ) Set tab position for the tabwidget. Valid values are \"north\", \"south\", \"east\", \"west\" Parameters: Name Type Description Default position str tab position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_position ( self , position : str ) -> None : \"\"\"Set tab position for the tabwidget. Valid values are \"north\", \"south\", \"east\", \"west\" Args: position: tab position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITIONS : raise InvalidParamError ( position , TAB_POSITIONS ) self . setTabPosition ( TAB_POSITIONS [ position ]) set_tab_shape ( self , shape ) Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Parameters: Name Type Description Default shape str tab shape to use required Exceptions: Type Description InvalidParamError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_shape ( self , shape : str ) -> None : \"\"\"Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ]) toolbar ToolBar add_separator ( self , text = None , before = None ) Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None before QAction insert separator before specific action None Returns: Type Description QAction Separator action Source code in prettyqt/widgets/toolbar.py def add_separator ( self , text : Optional [ str ] = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label ) get_style ( self ) Return current style. Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: Type Description str style Source code in prettyqt/widgets/toolbar.py def get_style ( self ) -> str : \"\"\"Return current style. Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: style \"\"\" return STYLES . inv [ self . toolButtonStyle ()] is_area_allowed ( self , area ) Check if toolbar is allowed at specified area. Valid values for area: \"left\", \"right\", \"top\", \"bottom\", \"all\" Parameters: Name Type Description Default area str area of the toolbar required Exceptions: Type Description InvalidParamError area does not exist Source code in prettyqt/widgets/toolbar.py def is_area_allowed ( self , area : str ): \"\"\"Check if toolbar is allowed at specified area. Valid values for area: \"left\", \"right\", \"top\", \"bottom\", \"all\" Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in TOOLBAR_AREAS : raise InvalidParamError ( area , TOOLBAR_AREAS ) return self . isAreaAllowed ( TOOLBAR_AREAS [ area ]) toolbutton ToolButton get_arrow_type ( self ) Return arrow type. possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: Type Description str arrow type Source code in prettyqt/widgets/toolbutton.py def get_arrow_type ( self ) -> str : \"\"\"Return arrow type. possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: arrow type \"\"\" return ARROW_TYPES . inv [ self . arrowType ()] get_popup_mode ( self ) Return popup mode. possible values are \"delayed\", \"menu_button\", \"instant\" Returns: Type Description str popup mode Source code in prettyqt/widgets/toolbutton.py def get_popup_mode ( self ) -> str : \"\"\"Return popup mode. possible values are \"delayed\", \"menu_button\", \"instant\" Returns: popup mode \"\"\" return POPUP_MODES . inv [ self . popupMode ()] set_arrow_type ( self , mode ) Set the arrow type of the toolbutton. valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Parameters: Name Type Description Default mode str arrow type to use required Exceptions: Type Description InvalidParamError invalid arrow type Source code in prettyqt/widgets/toolbutton.py def set_arrow_type ( self , mode : str ): \"\"\"Set the arrow type of the toolbutton. valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in ARROW_TYPES : raise InvalidParamError ( mode , ARROW_TYPES ) self . setArrowType ( ARROW_TYPES [ mode ]) set_popup_mode ( self , mode ) Set the popup mode of the toolbutton. valid values are: \"delayed\", \"menu_button\", \"instant\" Parameters: Name Type Description Default mode str popup mode to use required Exceptions: Type Description InvalidParamError invalid popup mode Source code in prettyqt/widgets/toolbutton.py def set_popup_mode ( self , mode : str ): \"\"\"Set the popup mode of the toolbutton. valid values are: \"delayed\", \"menu_button\", \"instant\" Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODES : raise InvalidParamError ( mode , POPUP_MODES ) self . setPopupMode ( POPUP_MODES [ mode ]) treewidgetitem TreeWidgetItem get_checkstate ( self ) Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/treewidgetitem.py def get_checkstate ( self ) -> str : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ( 0 )] set_checkstate ( self , state ) Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( 0 , STATES [ state ]) set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/treewidgetitem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( 0 , icon ) undoview UndoView set_clean_icon ( self , icon ) Set the icon for the clean button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/undoview.py def set_clean_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setCleanIcon ( icon ) widget Widget get_contextmenu_policy ( self ) Return current contextmenu policy. Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Returns: Type Description str contextmenu policy Source code in prettyqt/widgets/widget.py def get_contextmenu_policy ( self ) -> str : \"\"\"Return current contextmenu policy. Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Returns: contextmenu policy \"\"\" return CONTEXT_POLICIES . inv [ self . contextMenuPolicy ()] get_focus_policy ( self ) Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: Type Description str str: Focus policy Source code in prettyqt/widgets/widget.py def get_focus_policy ( self ) -> str : \"\"\"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: str: Focus policy \"\"\" return FOCUS_POLICIES . inv [ self . focusPolicy ()] get_modality ( self ) Get the current modality modes as a string. Possible values: \"none\", \"window\", \"application\" Returns: Type Description str modality mode str Source code in prettyqt/widgets/widget.py def get_modality ( self ) -> str : \"\"\"Get the current modality modes as a string. Possible values: \"none\", \"window\", \"application\" Returns: modality mode str \"\"\" return MODALITIES . inv [ self . windowModality ()] resize ( self , * size ) resize(self, QSize) resize(self, int, int) Source code in prettyqt/widgets/widget.py def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size ) set_contextmenu_policy ( self , policy ) Set contextmenu policy for given item view. Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Parameters: Name Type Description Default policy str contextmenu policy to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_contextmenu_policy ( self , policy : str ) -> None : \"\"\"Set contextmenu policy for given item view. Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CONTEXT_POLICIES : raise InvalidParamError ( policy , CONTEXT_POLICIES ) self . setContextMenuPolicy ( CONTEXT_POLICIES [ policy ]) set_focus_policy ( self , policy ) Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Parameters: Name Type Description Default policy str Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/widget.py def set_focus_policy ( self , policy : str ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in FOCUS_POLICIES : raise InvalidParamError ( policy , FOCUS_POLICIES ) self . setFocusPolicy ( FOCUS_POLICIES [ policy ]) set_icon ( self , icon ) Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/widget.py def set_icon ( self , icon : gui . icon . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) set_modality ( self , modality = 'window' ) Set modality for the dialog. Valid values for modality: \"none\", \"window\", \"application\" Parameters: Name Type Description Default modality str modality for the main window 'window' Exceptions: Type Description InvalidParamError modality type does not exist Source code in prettyqt/widgets/widget.py def set_modality ( self , modality : str = \"window\" ) -> None : \"\"\"Set modality for the dialog. Valid values for modality: \"none\", \"window\", \"application\" Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in MODALITIES : raise InvalidParamError ( modality , MODALITIES ) self . setWindowModality ( MODALITIES [ modality ]) set_size_policy ( self , horizontal = None , vertical = None ) Set the sizes policy. possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default horizontal Optional[str] horizontal size policy None vertical Optional[str] vertical size policy None Source code in prettyqt/widgets/widget.py def set_size_policy ( self , horizontal : Optional [ str ] = None , vertical : Optional [ str ] = None ) -> None : \"\"\"Set the sizes policy. possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp )","title":"widgets"},{"location":"api/widgets.html#widgets-module","text":"","title":"widgets module"},{"location":"api/widgets.html#prettyqt.widgets","text":"widgets module. contains QtWidgets-based classes","title":"prettyqt.widgets"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton","text":"","title":"abstractbutton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton","text":"","title":"AbstractButton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton.set_icon","text":"Set the icon for the button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/abstractbutton.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview","text":"","title":"abstractitemview"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView","text":"","title":"AbstractItemView"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_behaviour","text":"Return current selection behaviour. Possible values: \"rows\", \"columns\", \"items\" Returns: Type Description str selection behaviour Source code in prettyqt/widgets/abstractitemview.py def get_selection_behaviour ( self ) -> str : \"\"\"Return current selection behaviour. Possible values: \"rows\", \"columns\", \"items\" Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOURS . inv [ self . selectionBehavior ()]","title":"get_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_mode","text":"Return current selection mode. Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/abstractitemview.py def get_selection_mode ( self ) -> str : \"\"\"Return current selection mode. Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.highlight_when_inactive","text":"Highlight items when widget does not have focus. Source code in prettyqt/widgets/abstractitemview.py def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p )","title":"highlight_when_inactive()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.jump_to_column","text":"Make sure column at given index is visible. scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return None idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx )","title":"jump_to_column()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.num_selected","text":"Return amount of selected rows. Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ())","title":"num_selected()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_bottom","text":"Override to use abstractitemview-way of scrolling to bottom. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_top","text":"Override to use abstractitemview-way of scrolling to top. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selectAll","text":"Override, we dont want to selectAll for too many items bc of performance. Source code in prettyqt/widgets/abstractitemview.py def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return None if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return None super () . selectAll ()","title":"selectAll()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_data","text":"Returns generator yielding selected userData. Source code in prettyqt/widgets/abstractitemview.py def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes ())","title":"selected_data()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_indexes","text":"Returns list of selected indexes in first row. Source code in prettyqt/widgets/abstractitemview.py def selected_indexes ( self ) -> List [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) return sorted ( indexes , key = lambda x : x . row ())","title":"selected_indexes()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_names","text":"Returns generator yielding item names. Source code in prettyqt/widgets/abstractitemview.py def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ())","title":"selected_names()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_rows","text":"Returns generator yielding row nums. Source code in prettyqt/widgets/abstractitemview.py def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ())","title":"selected_rows()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_horizontal_scroll_mode","text":"Set the horizontal scroll mode. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_horizontal_scroll_mode ( self , mode : str ): \"\"\"Set the horizontal scroll mode. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ])","title":"set_horizontal_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_model","text":"Delete old selection model explicitely, seems to help with memory usage. Source code in prettyqt/widgets/abstractitemview.py def set_model ( self , model : Optional [ QtCore . QAbstractItemModel ]): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model","title":"set_model()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_scroll_mode","text":"Set the scroll mode for both directions. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_scroll_mode ( self , mode : str ): \"\"\"Set the scroll mode for both directions. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ]) self . setVerticalScrollMode ( SCROLL_MODES [ mode ])","title":"set_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_behaviour","text":"Set selection behaviour for given item view. Allowed values are \"rows\", \"columns\", \"items\" Parameters: Name Type Description Default behaviour str selection behaviour to use required Exceptions: Type Description InvalidParamError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_behaviour ( self , behaviour : str ): \"\"\"Set selection behaviour for given item view. Allowed values are \"rows\", \"columns\", \"items\" Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOURS : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOURS ) self . setSelectionBehavior ( SELECTION_BEHAVIOURS [ behaviour ])","title":"set_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_mode","text":"Set selection mode for given item view. Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"Set selection mode for given item view. Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise InvalidParamError ( mode , SELECTION_MODES ) self . setSelectionMode ( SELECTION_MODES [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_vertical_scroll_mode","text":"Set the vertical scroll mode. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_vertical_scroll_mode ( self , mode : str ): \"\"\"Set the vertical scroll mode. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setVerticalScrollMode ( SCROLL_MODES [ mode ])","title":"set_vertical_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.toggle_select_all","text":"Select all items from list (deselect when all selected). Source code in prettyqt/widgets/abstractitemview.py def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return None if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll ()","title":"toggle_select_all()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea","text":"","title":"abstractscrollarea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea","text":"","title":"AbstractScrollArea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.get_size_adjust_policy","text":"Return size adjust policy. possible values are \"content\", \"first_show\", \"ignored\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def get_size_adjust_policy ( self ) -> str : \"\"\"Return size adjust policy. possible values are \"content\", \"first_show\", \"ignored\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_bottom","text":"Scroll to the bottom of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_top","text":"Scroll to the top of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_policy","text":"Set the horizontal scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_policy ( self , mode : str ): \"\"\"Set the horizontal scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_horizontal_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_width","text":"Set the horizontal scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" )","title":"set_horizontal_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_policy","text":"Set the policy for both scrollbars. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_policy ( self , mode : str ): \"\"\"Set the policy for both scrollbars. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_width","text":"Set the width for both scrollbars. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width )","title":"set_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_size_adjust_policy","text":"Set size adjust policy. Valid values are \"content\", \"first_show\", \"ignored\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def set_size_adjust_policy ( self , policy : str ): \"\"\"Set size adjust policy. Valid values are \"content\", \"first_show\", \"ignored\" Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise InvalidParamError ( policy , SIZE_POLICIES ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy )","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_policy","text":"Set the vertical scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_policy ( self , mode : str ): \"\"\"Set the vertical scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_vertical_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_width","text":"Set the vertical scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" )","title":"set_vertical_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider","text":"","title":"abstractslider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider","text":"","title":"AbstractSlider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/abstractslider.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.get_repeat_action","text":"Get current repeat action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Returns: Type Description str current repeat action Source code in prettyqt/widgets/abstractslider.py def get_repeat_action ( self ) -> str : \"\"\"Get current repeat action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Returns: current repeat action \"\"\" return SLIDER_ACTIONS . inv [ self . repeatAction ()]","title":"get_repeat_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_horizontal","text":"Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == QtCore . Qt . Horizontal","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_vertical","text":"Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == QtCore . Qt . Vertical","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_max","text":"Scroll to the maximum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ())","title":"scroll_to_max()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_min","text":"Scroll to the minimum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ())","title":"scroll_to_min()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_horizontal","text":"Set slider orientation to horizontal. Source code in prettyqt/widgets/abstractslider.py def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( QtCore . Qt . Horizontal )","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_orientation","text":"Set the orientation of the slider. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the slider required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/abstractslider.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the slider. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_repeat_action","text":"Set the repeat action. Valid values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Parameters: Name Type Description Default action str repeat action required Exceptions: Type Description InvalidParamError invalid repeat action Source code in prettyqt/widgets/abstractslider.py def set_repeat_action ( self , action : str , threshold : int = 500 , repeat_time : int = 50 ): \"\"\"Set the repeat action. Valid values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Args: action: repeat action Raises: InvalidParamError: invalid repeat action \"\"\" if action not in SLIDER_ACTIONS : raise InvalidParamError ( action , SLIDER_ACTIONS ) self . setRepeatAction ( SLIDER_ACTIONS [ action ], threshold , repeat_time )","title":"set_repeat_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_vertical","text":"Set slider orientation to vertical. Source code in prettyqt/widgets/abstractslider.py def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( QtCore . Qt . Vertical )","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.trigger_action","text":"Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Source code in prettyqt/widgets/abstractslider.py def trigger_action ( self , action : str ): \"\"\"Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" \"\"\" if action not in SLIDER_ACTIONS : raise InvalidParamError ( action , SLIDER_ACTIONS ) self . triggerAction ( SLIDER_ACTIONS [ action ])","title":"trigger_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox","text":"","title":"abstractspinbox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox","text":"","title":"AbstractSpinBox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_button_symbols","text":"Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: Type Description str button symbol type Source code in prettyqt/widgets/abstractspinbox.py def get_button_symbols ( self ) -> str : \"\"\"Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: button symbol type \"\"\" return SYMBOLS . inv [ self . buttonSymbols ()]","title":"get_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_correction_mode","text":"Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: Type Description str correction mode Source code in prettyqt/widgets/abstractspinbox.py def get_correction_mode ( self ) -> str : \"\"\"Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: correction mode \"\"\" return CORRECTION_MODES . inv [ self . correctionMode ()]","title":"get_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_step_type","text":"Return step type. possible values are \"default\", \"adaptive\" Returns: Type Description str step type Source code in prettyqt/widgets/abstractspinbox.py def get_step_type ( self ) -> str : \"\"\"Return step type. possible values are \"default\", \"adaptive\" Returns: step type \"\"\" return STEP_TYPES . inv [ self . stepType ()]","title":"get_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_button_symbols","text":"Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Parameters: Name Type Description Default mode str button symbol type to use required Exceptions: Type Description InvalidParamError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py def set_button_symbols ( self , mode : str ): \"\"\"Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ])","title":"set_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_correction_mode","text":"Set correction mode. possible values are \"to_previous\", \"to_nearest\" Parameters: Name Type Description Default mode str correction mode to use required Exceptions: Type Description InvalidParamError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py def set_correction_mode ( self , mode : str ): \"\"\"Set correction mode. possible values are \"to_previous\", \"to_nearest\" Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ])","title":"set_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_step_type","text":"Set step type. possible values are \"default\", \"adaptive\" Parameters: Name Type Description Default mode str step type to use required Exceptions: Type Description InvalidParamError invalid step type Source code in prettyqt/widgets/abstractspinbox.py def set_step_type ( self , mode : str ): \"\"\"Set step type. possible values are \"default\", \"adaptive\" Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ])","title":"set_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.action","text":"","title":"action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action","text":"","title":"Action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_menu_role","text":"Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: Type Description str menu role Source code in prettyqt/widgets/action.py def get_menu_role ( self ) -> str : \"\"\"Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: menu role \"\"\" return ROLES . inv [ self . menuRole ()]","title":"get_menu_role()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_priority","text":"Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: Type Description str priority Source code in prettyqt/widgets/action.py def get_priority ( self ) -> str : \"\"\"Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: priority \"\"\" return PRIORITIES . inv [ self . priority ()]","title":"get_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_shortcut_context","text":"Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: Type Description str shortcut context Source code in prettyqt/widgets/action.py def get_shortcut_context ( self ) -> str : \"\"\"Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: shortcut context \"\"\" return CONTEXTS . inv [ self . shortcutContext ()]","title":"get_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/action.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_menu_role","text":"Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Parameters: Name Type Description Default role str menu role required Exceptions: Type Description InvalidParamError menu role does not exist Source code in prettyqt/widgets/action.py def set_menu_role ( self , role : str ): \"\"\"Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ])","title":"set_menu_role()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_priority","text":"Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Parameters: Name Type Description Default priority str priority for the action required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/widgets/action.py def set_priority ( self , priority : str ): \"\"\"Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ])","title":"set_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_shortcut_context","text":"Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Parameters: Name Type Description Default context str shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/action.py def set_shortcut_context ( self , context : str ): \"\"\"Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in CONTEXTS : raise InvalidParamError ( context , CONTEXTS ) self . setShortcutContext ( CONTEXTS [ context ])","title":"set_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup","text":"","title":"actiongroup"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup","text":"","title":"ActionGroup"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.get_exclusion_policy","text":"Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: Type Description str exclusion policy Source code in prettyqt/widgets/actiongroup.py def get_exclusion_policy ( self ) -> str : \"\"\"Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: exclusion policy \"\"\" return POLICIES . inv [ self . exclusionPolicy ()]","title":"get_exclusion_policy()"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.set_exclusion_policy","text":"Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Parameters: Name Type Description Default policy Optional[str] exclusion policy to use required Exceptions: Type Description InvalidParamError exclusion policy does not exist Source code in prettyqt/widgets/actiongroup.py def set_exclusion_policy ( self , policy : Optional [ str ]): \"\"\"Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ])","title":"set_exclusion_policy()"},{"location":"api/widgets.html#prettyqt.widgets.application","text":"","title":"application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application","text":"","title":"Application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.copy_to_clipboard","text":"Sets clipboard to supplied text. Source code in prettyqt/widgets/application.py @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Clipboard ) cb . setText ( text , mode = cb . Clipboard )","title":"copy_to_clipboard()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.set_icon","text":"Set the default window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/application.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget","text":"","title":"calendarwidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget","text":"","title":"CalendarWidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.get_selection_mode","text":"Return current selection mode. Possible values: \"single\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/calendarwidget.py def get_selection_mode ( self ) -> str : \"\"\"Return current selection mode. Possible values: \"single\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.set_selection_mode","text":"Set selection mode for given calendar widget. Allowed values are \"single\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/calendarwidget.py def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"Set selection mode for given calendar widget. Allowed values are \"single\" or \"none\" Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise InvalidParamError ( mode , SELECTION_MODES ) self . setSelectionMode ( SELECTION_MODES [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox","text":"","title":"checkbox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox","text":"","title":"CheckBox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.get_checkstate","text":"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description bool checkstate Source code in prettyqt/widgets/checkbox.py def get_checkstate ( self ) -> bool : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.set_checkstate","text":"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/checkbox.py def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( STATES [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.combobox","text":"","title":"combobox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox","text":"","title":"ComboBox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_insert_policy","text":"Return insert policy. possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: Type Description str insert policy Source code in prettyqt/widgets/combobox.py def get_insert_policy ( self ) -> str : \"\"\"Return insert policy. possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: insert policy \"\"\" return INSERT_POLICIES . inv [ self . insertPolicy ()]","title":"get_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_size_adjust_policy","text":"Return size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/combobox.py def get_size_adjust_policy ( self ) -> str : \"\"\"Return size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_insert_policy","text":"Set insert policy. valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Parameters: Name Type Description Default policy str insert policy to use required Exceptions: Type Description InvalidParamError invalid insert policy Source code in prettyqt/widgets/combobox.py def set_insert_policy ( self , policy : str ): \"\"\"Set insert policy. valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICIES : raise InvalidParamError ( policy , INSERT_POLICIES ) policy = INSERT_POLICIES . get ( policy ) self . setInsertPolicy ( policy )","title":"set_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_size_adjust_policy","text":"Set size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/combobox.py def set_size_adjust_policy ( self , policy : str ): \"\"\"Set size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise InvalidParamError ( policy , SIZE_POLICIES ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy )","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.completer","text":"","title":"completer"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer","text":"","title":"Completer"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_completion_mode","text":"Return current completion mode. Possible values: \"popup\", \"inline\", \"unfiltered_popup\" Returns: Type Description str completion mode Source code in prettyqt/widgets/completer.py def get_completion_mode ( self ) -> str : \"\"\"Return current completion mode. Possible values: \"popup\", \"inline\", \"unfiltered_popup\" Returns: completion mode \"\"\" return COMPLETION_MODES . inv [ self . completionMode ()]","title":"get_completion_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_filter_mode","text":"Return current filter mode. Possible values: \"starts_with\", \"contains\", \"ends_with\" Returns: Type Description str filter mode Source code in prettyqt/widgets/completer.py def get_filter_mode ( self ) -> str : \"\"\"Return current filter mode. Possible values: \"starts_with\", \"contains\", \"ends_with\" Returns: filter mode \"\"\" return FILTER_MODES . inv [ self . filterMode ()]","title":"get_filter_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_sort_mode","text":"Return current sort mode. Possible values: \"unsorted\", \"case_sensitive\", \"case_insensitive\" Returns: Type Description str sort mode Source code in prettyqt/widgets/completer.py def get_sort_mode ( self ) -> str : \"\"\"Return current sort mode. Possible values: \"unsorted\", \"case_sensitive\", \"case_insensitive\" Returns: sort mode \"\"\" return SORT_MODES . inv [ self . modelSorting ()]","title":"get_sort_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_completion_mode","text":"Set completion mode to use. Allowed values are \"popup\", \"inline\", \"unfiltered_popup\" Parameters: Name Type Description Default mode str completion mode to use required Exceptions: Type Description InvalidParamError completion mode does not exist Source code in prettyqt/widgets/completer.py def set_completion_mode ( self , mode : str ): \"\"\"Set completion mode to use. Allowed values are \"popup\", \"inline\", \"unfiltered_popup\" Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODES : raise InvalidParamError ( mode , COMPLETION_MODES ) self . setCompletionMode ( COMPLETION_MODES [ mode ])","title":"set_completion_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_filter_mode","text":"Set filter mode to use. Allowed values are \"starts_with\", \"contains\", \"ends_with\" Parameters: Name Type Description Default mode str filter mode to use required Exceptions: Type Description InvalidParamError filter mode does not exist Source code in prettyqt/widgets/completer.py def set_filter_mode ( self , mode : str ): \"\"\"Set filter mode to use. Allowed values are \"starts_with\", \"contains\", \"ends_with\" Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in FILTER_MODES : raise InvalidParamError ( mode , FILTER_MODES ) self . setFilterMode ( FILTER_MODES [ mode ])","title":"set_filter_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_sort_mode","text":"Set sort mode to use. Allowed values are \"unsorted\", \"case_sensitive\", \"case_insensitive\" Parameters: Name Type Description Default mode Optional[str] sort mode to use required Exceptions: Type Description InvalidParamError sort mode does not exist Source code in prettyqt/widgets/completer.py def set_sort_mode ( self , mode : Optional [ str ]): \"\"\"Set sort mode to use. Allowed values are \"unsorted\", \"case_sensitive\", \"case_insensitive\" Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODES : raise InvalidParamError ( mode , SORT_MODES ) self . setModelSorting ( SORT_MODES [ mode ])","title":"set_sort_mode()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper","text":"","title":"datawidgetmapper"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper","text":"","title":"DataWidgetMapper"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/datawidgetmapper.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_submit_policy","text":"Return current submit policy. Possible values: \"auto\", \"manual\" Returns: Type Description str submit policy Source code in prettyqt/widgets/datawidgetmapper.py def get_submit_policy ( self ) -> str : \"\"\"Return current submit policy. Possible values: \"auto\", \"manual\" Returns: submit policy \"\"\" return SUBMIT_POLICIES . inv [ self . submitPolicy ()]","title":"get_submit_policy()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_orientation","text":"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_submit_policy","text":"Set the submit policy of the mapper. Allowed values are \"auto\", \"manual\" Parameters: Name Type Description Default submit_policy submit_policy for the splitter required Exceptions: Type Description InvalidParamError submit_policy does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_submit_policy ( self , policy : str ): \"\"\"Set the submit policy of the mapper. Allowed values are \"auto\", \"manual\" Args: submit_policy: submit_policy for the splitter Raises: InvalidParamError: submit_policy does not exist \"\"\" if policy not in SUBMIT_POLICIES : raise InvalidParamError ( policy , SUBMIT_POLICIES ) self . setSubmitPolicy ( SUBMIT_POLICIES [ policy ])","title":"set_submit_policy()"},{"location":"api/widgets.html#prettyqt.widgets.dialog","text":"","title":"dialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.BaseDialog","text":"","title":"BaseDialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.BaseDialog.keyPressEvent","text":"keyPressEvent(self, QKeyEvent) Source code in prettyqt/widgets/dialog.py def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e )","title":"keyPressEvent()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox","text":"","title":"dialogbuttonbox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox","text":"","title":"DialogButtonBox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_button","text":"Add a button. Parameters: Name Type Description Default button Union[PyQt5.QtWidgets.QPushButton, str] button to add required role str role of the button 'accept' callback Optional[Callable] function to call when button gets clicked None Returns: Type Description PushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_button ( self , button : Union [ QtWidgets . QPushButton , str ], role : str = \"accept\" , callback : Optional [ Callable ] = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_default_button","text":"Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required callback Optional[Callable] function to call when button gets clicked None Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_default_button ( self , button : str , callback : Optional [ Callable ] = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn","title":"add_default_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.create","text":"create(self, window: sip.voidptr = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) Source code in prettyqt/widgets/dialogbuttonbox.py @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) return box","title":"create()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/dialogbuttonbox.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.set_orientation","text":"Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the button box required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.dockwidget","text":"","title":"dockwidget"},{"location":"api/widgets.html#prettyqt.widgets.dockwidget.DockWidget","text":"Customized DockWidget class. Contains a custom TitleBar with maximise button","title":"DockWidget"},{"location":"api/widgets.html#prettyqt.widgets.filedialog","text":"","title":"filedialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog","text":"Simple dialog used to display some widget.","title":"FileDialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.directory","text":"Return current directory. returns current directory level as a Pathlib object Returns: Type Description Path Pathlib object Source code in prettyqt/widgets/filedialog.py def directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( super () . directory ())","title":"directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_accept_mode","text":"Return accept mode. possible values are \"save\", \"open\" Returns: Type Description str accept mode Source code in prettyqt/widgets/filedialog.py def get_accept_mode ( self ) -> str : \"\"\"Return accept mode. possible values are \"save\", \"open\" Returns: accept mode \"\"\" return ACCEPT_MODES . inv [ self . acceptMode ()]","title":"get_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_file_mode","text":"Return file mode. possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: Type Description str file mode Source code in prettyqt/widgets/filedialog.py def get_file_mode ( self ) -> str : \"\"\"Return file mode. possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: file mode \"\"\" return MODES . inv [ self . fileMode ()]","title":"get_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_label_text","text":"Return label text. possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py def get_label_text ( self , label ) -> str : \"\"\"Return label text. possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: label text \"\"\" return self . labelText ( LABELS . inv [ label ])","title":"get_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_view_mode","text":"Return view mode. possible values are \"detail\", \"list\" Returns: Type Description str view mode Source code in prettyqt/widgets/filedialog.py def get_view_mode ( self ) -> str : \"\"\"Return view mode. possible values are \"detail\", \"list\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_accept_mode","text":"Set accept mode. possible values are \"save\", \"open\" Parameters: Name Type Description Default mode str accept mode to use required Exceptions: Type Description InvalidParamError invalid accept mode Source code in prettyqt/widgets/filedialog.py def set_accept_mode ( self , mode : str ): \"\"\"Set accept mode. possible values are \"save\", \"open\" Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODES : raise InvalidParamError ( mode , ACCEPT_MODES ) self . setAcceptMode ( ACCEPT_MODES [ mode ])","title":"set_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_directory","text":"Set start directory. Source code in prettyqt/widgets/filedialog.py def set_directory ( self , path : Union [ None , str , pathlib . Path ]): \"\"\"Set start directory.\"\"\" if isinstance ( path , pathlib . Path ): path = str ( path ) self . setDirectory ( path )","title":"set_directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_extension_filter","text":"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict Dict[str, List[str]] filter dictionary required Source code in prettyqt/widgets/filedialog.py def set_extension_filter ( self , extension_dict : Dict [ str , List [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str )","title":"set_extension_filter()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_file_mode","text":"Set the file mode of the dialog. allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Parameters: Name Type Description Default mode str mode to use required Source code in prettyqt/widgets/filedialog.py def set_file_mode ( self , mode : str ): \"\"\"Set the file mode of the dialog. allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Args: mode: mode to use \"\"\" self . setFileMode ( MODES [ mode ])","title":"set_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_label_text","text":"Set the label text for button label. possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Parameters: Name Type Description Default label str button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py def set_label_text ( self , label : str , text : str ): \"\"\"Set the label text for button label. possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Args: label: button to set text for text: text to use \"\"\" if label not in LABELS : raise InvalidParamError ( label , LABELS ) self . setLabelText ( LABELS [ label ], text )","title":"set_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_view_mode","text":"Set view mode. possible values are \"detail\", \"list\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/filedialog.py def set_view_mode ( self , mode : str ): \"\"\"Set view mode. possible values are \"detail\", \"list\" Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel","text":"","title":"filesystemmodel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel","text":"Class to populate a filesystem treeview.","title":"FileSystemModel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/widgets/filesystemmodel.py def data ( self , index , role = QtCore . Qt . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role )","title":"data()"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox","text":"","title":"fontcombobox"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox","text":"","title":"FontComboBox"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.get_font_filters","text":"Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: Type Description List[str] font filter list Source code in prettyqt/widgets/fontcombobox.py def get_font_filters ( self ) -> List [ str ]: \"\"\"Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()]","title":"get_font_filters()"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.set_font_filters","text":"Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Parameters: Name Type Description Default filters str font filters to use () Exceptions: Type Description InvalidParamError invalid font filters Source code in prettyqt/widgets/fontcombobox.py def set_font_filters ( self , * filters : str ): \"\"\"Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags )","title":"set_font_filters()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout","text":"","title":"formlayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout","text":"","title":"FormLayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.__len__","text":"Needed for PySide2. Source code in prettyqt/widgets/formlayout.py def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/widgets.html#prettyqt.widgets.frame","text":"","title":"frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame","text":"","title":"Frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.get_frame_shadow","text":"Return current frame shadow. Possible values: \"plain\", \"raised\", \"sunken\" Returns: Type Description str frame style Source code in prettyqt/widgets/frame.py def get_frame_shadow ( self ) -> str : \"\"\"Return current frame shadow. Possible values: \"plain\", \"raised\", \"sunken\" Returns: frame style \"\"\" return SHADOWS . inv [ self . frameShadow ()]","title":"get_frame_shadow()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.get_frame_shape","text":"Return current frame shape. Possible values: \"plain\", \"raised\", \"sunken\" Returns: Type Description str frame shape Source code in prettyqt/widgets/frame.py def get_frame_shape ( self ) -> str : \"\"\"Return current frame shape. Possible values: \"plain\", \"raised\", \"sunken\" Returns: frame shape \"\"\" return SHAPES . inv [ self . frameShape ()]","title":"get_frame_shape()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.set_frame_shadow","text":"Set frame shadow. Allowed values are \"plain\", \"raised\", \"sunken\" Parameters: Name Type Description Default style str frame style to use required Exceptions: Type Description InvalidParamError style does not exist Source code in prettyqt/widgets/frame.py def set_frame_shadow ( self , style : str ): \"\"\"Set frame shadow. Allowed values are \"plain\", \"raised\", \"sunken\" Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style not in SHADOWS : raise InvalidParamError ( style , SHADOWS ) self . setFrameShadow ( SHADOWS [ style ])","title":"set_frame_shadow()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.set_frame_shape","text":"Set frame shape. Allowed values are \"plain\", \"raised\", \"sunken\" Parameters: Name Type Description Default shape str frame shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/widgets/frame.py def set_frame_shape ( self , shape : str ): \"\"\"Set frame shape. Allowed values are \"plain\", \"raised\", \"sunken\" Args: shape: frame shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in SHAPES : raise InvalidParamError ( shape , SHAPES ) self . setFrameShape ( SHAPES [ shape ])","title":"set_frame_shape()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem","text":"","title":"graphicsitem"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem","text":"","title":"GraphicsItem"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem.get_panel_modality","text":"Get the current modality modes as a string. Possible values: \"none\", \"panel\", \"scene\" Returns: Type Description str panel modality str Source code in prettyqt/widgets/graphicsitem.py def get_panel_modality ( self ) -> str : \"\"\"Get the current modality modes as a string. Possible values: \"none\", \"panel\", \"scene\" Returns: panel modality str \"\"\" return MODALITIES . inv [ self . panelModality ()]","title":"get_panel_modality()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem.set_panel_modality","text":"Set panel modality. Valid values for modality: \"none\", \"panel\", \"scene\" Parameters: Name Type Description Default modality str panel modality 'window' Exceptions: Type Description InvalidParamError panel modality does not exist Source code in prettyqt/widgets/graphicsitem.py def set_panel_modality ( self , modality : str = \"window\" ) -> None : \"\"\"Set panel modality. Valid values for modality: \"none\", \"panel\", \"scene\" Args: modality: panel modality Raises: InvalidParamError: panel modality does not exist \"\"\" if modality not in MODALITIES : raise InvalidParamError ( modality , MODALITIES ) self . setPanelModality ( MODALITIES [ modality ])","title":"set_panel_modality()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene","text":"","title":"graphicsscene"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene","text":"","title":"GraphicsScene"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.get_item_index_method","text":"Return item index method. possible values are \"bsp_tree\", \"none\" Returns: Type Description str item index method Source code in prettyqt/widgets/graphicsscene.py def get_item_index_method ( self ) -> str : \"\"\"Return item index method. possible values are \"bsp_tree\", \"none\" Returns: item index method \"\"\" return ITEM_INDEX_METHODS . inv [ self . itemIndexMethod ()]","title":"get_item_index_method()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.set_item_index_method","text":"Set item index method. possible values are \"bsp_tree\", \"none\" Parameters: Name Type Description Default method str item index method to use required Exceptions: Type Description InvalidParamError invalid item index method Source code in prettyqt/widgets/graphicsscene.py def set_item_index_method ( self , method : str ): \"\"\"Set item index method. possible values are \"bsp_tree\", \"none\" Args: method: item index method to use Raises: InvalidParamError: invalid item index method \"\"\" if method not in ITEM_INDEX_METHODS : raise InvalidParamError ( method , ITEM_INDEX_METHODS ) self . setItemIndexMethod ( ITEM_INDEX_METHODS [ method ])","title":"set_item_index_method()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview","text":"","title":"graphicsview"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView","text":"","title":"GraphicsView"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_cache_mode","text":"Return current cache mode. Possible values: \"none\", \"background\" Returns: Type Description str cache mode Source code in prettyqt/widgets/graphicsview.py def get_cache_mode ( self ) -> str : \"\"\"Return current cache mode. Possible values: \"none\", \"background\" Returns: cache mode \"\"\" return CACHE_MODES . inv [ self . cacheMode ()]","title":"get_cache_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_drag_mode","text":"Return current drag mode. Possible values: \"none\", \"scroll_hand\", \"rubber_band\" Returns: Type Description str drag mode Source code in prettyqt/widgets/graphicsview.py def get_drag_mode ( self ) -> str : \"\"\"Return current drag mode. Possible values: \"none\", \"scroll_hand\", \"rubber_band\" Returns: drag mode \"\"\" return DRAG_MODES . inv [ self . dragMode ()]","title":"get_drag_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_resize_anchor","text":"Return current resize anchor. Possible values: \"none\", \"view_center\", \"under_mouse\" Returns: Type Description str resize anchor Source code in prettyqt/widgets/graphicsview.py def get_resize_anchor ( self ) -> str : \"\"\"Return current resize anchor. Possible values: \"none\", \"view_center\", \"under_mouse\" Returns: resize anchor \"\"\" return VIEWPORT_ANCHORS . inv [ self . resizeAnchor ()]","title":"get_resize_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_rubberband_selection_mode","text":"Return current rubberband selection mode. Possible values: \"contains_shape\", \"intersects_shape\", \"contains_bounding_rect\", \"intersects_bounding_rect\" Returns: Type Description str rubberband selection mode Source code in prettyqt/widgets/graphicsview.py def get_rubberband_selection_mode ( self ) -> str : \"\"\"Return current rubberband selection mode. Possible values: \"contains_shape\", \"intersects_shape\", \"contains_bounding_rect\", \"intersects_bounding_rect\" Returns: rubberband selection mode \"\"\" return ITEM_SELECTION_MODES . inv [ self . rubberBandSelectionMode ()]","title":"get_rubberband_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_transformation_anchor","text":"Return current transformation anchor. Possible values: \"none\", \"view_center\", \"under_mouse\" Returns: Type Description str viewport anchor Source code in prettyqt/widgets/graphicsview.py def get_transformation_anchor ( self ) -> str : \"\"\"Return current transformation anchor. Possible values: \"none\", \"view_center\", \"under_mouse\" Returns: viewport anchor \"\"\" return VIEWPORT_ANCHORS . inv [ self . transformationAnchor ()]","title":"get_transformation_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_viewport_update_mode","text":"Return current viewport update mode. Possible values: \"full\", \"minimal\", \"smart\", \"bounding_rect\", \"none\" Returns: Type Description str viewport update mode Source code in prettyqt/widgets/graphicsview.py def get_viewport_update_mode ( self ) -> str : \"\"\"Return current viewport update mode. Possible values: \"full\", \"minimal\", \"smart\", \"bounding_rect\", \"none\" Returns: viewport update mode \"\"\" return VIEWPORT_UPDATE_MODES . inv [ self . viewportUpdateMode ()]","title":"get_viewport_update_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_cache_mode","text":"Set the cache mode. Allowed values are \"none\", \"background\" Parameters: Name Type Description Default mode str cache mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_cache_mode ( self , mode : str ): \"\"\"Set the cache mode. Allowed values are \"none\", \"background\" Args: mode: cache mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ])","title":"set_cache_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_drag_mode","text":"Set the behavior for dragging the mouse while the left mouse button is pressed. Allowed values are \"none\", \"scroll_hand\", \"rubber_band\" Parameters: Name Type Description Default mode str drag mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_drag_mode ( self , mode : str ): \"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed. Allowed values are \"none\", \"scroll_hand\", \"rubber_band\" Args: mode: drag mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_MODES : raise InvalidParamError ( mode , DRAG_MODES ) self . setDragMode ( DRAG_MODES [ mode ])","title":"set_drag_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_resize_anchor","text":"Set how the view should position the scene during resizes. Allowed values are \"none\", \"view_center\", \"under_mouse\" Parameters: Name Type Description Default mode str resize anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_resize_anchor ( self , mode : str ): \"\"\"Set how the view should position the scene during resizes. Allowed values are \"none\", \"view_center\", \"under_mouse\" Args: mode: resize anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHORS : raise InvalidParamError ( mode , VIEWPORT_ANCHORS ) self . setResizeAnchor ( VIEWPORT_ANCHORS [ mode ])","title":"set_resize_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_rubberband_selection_mode","text":"Set the behavior for selecting items with a rubber band selection rectangle. Allowed values are \"contains_shape\", \"intersects_shape\", \"contains_bounding_rect\", \"intersects_bounding_rect\" Parameters: Name Type Description Default mode str rubberband selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_rubberband_selection_mode ( self , mode : str ): \"\"\"Set the behavior for selecting items with a rubber band selection rectangle. Allowed values are \"contains_shape\", \"intersects_shape\", \"contains_bounding_rect\", \"intersects_bounding_rect\" Args: mode: rubberband selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in ITEM_SELECTION_MODES : raise InvalidParamError ( mode , ITEM_SELECTION_MODES ) self . setRubberBandSelectionMode ( ITEM_SELECTION_MODES [ mode ])","title":"set_rubberband_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_transformation_anchor","text":"Set how the view should position the scene during transformations. Allowed values are \"none\", \"view_center\", \"under_mouse\" Parameters: Name Type Description Default mode str transformation anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_transformation_anchor ( self , mode : str ): \"\"\"Set how the view should position the scene during transformations. Allowed values are \"none\", \"view_center\", \"under_mouse\" Args: mode: transformation anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHORS : raise InvalidParamError ( mode , VIEWPORT_ANCHORS ) self . setTransformationAnchor ( VIEWPORT_ANCHORS [ mode ])","title":"set_transformation_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_viewport_update_mode","text":"Set how the viewport should update its contents. Allowed values are \"full\", \"minimal\", \"smart\", \"bounding_rect\", \"none\" Parameters: Name Type Description Default mode str viewport update mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_viewport_update_mode ( self , mode : str ): \"\"\"Set how the viewport should update its contents. Allowed values are \"full\", \"minimal\", \"smart\", \"bounding_rect\", \"none\" Args: mode: viewport update mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_UPDATE_MODES : raise InvalidParamError ( mode , VIEWPORT_UPDATE_MODES ) self . setViewportUpdateMode ( VIEWPORT_UPDATE_MODES [ mode ])","title":"set_viewport_update_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget","text":"","title":"graphicswidget"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget","text":"","title":"GraphicsWidget"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget.get_focus_policy","text":"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: Type Description str str: Focus policy Source code in prettyqt/widgets/graphicswidget.py def get_focus_policy ( self ) -> str : \"\"\"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: str: Focus policy \"\"\" return FOCUS_POLICIES . inv [ self . focusPolicy ()]","title":"get_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget.set_focus_policy","text":"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Parameters: Name Type Description Default policy str Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/graphicswidget.py def set_focus_policy ( self , policy : str ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in FOCUS_POLICIES : raise InvalidParamError ( policy , FOCUS_POLICIES ) self . setFocusPolicy ( FOCUS_POLICIES [ policy ])","title":"set_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.groupbox","text":"","title":"groupbox"},{"location":"api/widgets.html#prettyqt.widgets.groupbox.GroupBox","text":"GroupBox widget. A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets.","title":"GroupBox"},{"location":"api/widgets.html#prettyqt.widgets.headerview","text":"","title":"headerview"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView","text":"","title":"HeaderView"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView.contextMenuEvent","text":"Context menu for our files tree. Source code in prettyqt/widgets/headerview.py def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) actions = self . get_header_actions () menu . add_actions ( actions ) menu . exec_ ( self . mapToGlobal ( event . pos ()))","title":"contextMenuEvent()"},{"location":"api/widgets.html#prettyqt.widgets.label","text":"","title":"label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label","text":"","title":"Label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_format","text":"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str text format Source code in prettyqt/widgets/label.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_interaction","text":"Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: Type Description List[str] list of text interaction modes Source code in prettyqt/widgets/label.py def get_text_interaction ( self ) -> List [ str ]: \"\"\"Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()]","title":"get_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_alignment","text":"Set the alignment of the label's contents. Source code in prettyqt/widgets/label.py def set_alignment ( self , horizontal : Optional [ str ] = None , vertical : Optional [ str ] = None ): \"\"\"Set the alignment of the label's contents.\"\"\" if horizontal is None and vertical is not None : flag = V_ALIGNMENTS [ vertical ] elif vertical is None and horizontal is not None : flag = H_ALIGNMENTS [ horizontal ] elif vertical is not None and horizontal is not None : flag = V_ALIGNMENTS [ vertical ] | H_ALIGNMENTS [ horizontal ] else : return self . setAlignment ( flag ) return self","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_indent","text":"Set the label's text indent in pixels. Source code in prettyqt/widgets/label.py def set_indent ( self , indent : int ) -> \"Label\" : \"\"\"Set the label's text indent in pixels.\"\"\" self . setIndent ( indent ) return self","title":"set_indent()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text","text":"Set the label's text. Source code in prettyqt/widgets/label.py def set_text ( self , text : str ) -> \"Label\" : \"\"\"Set the label's text.\"\"\" self . setText ( text ) return self","title":"set_text()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_format","text":"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/label.py def set_text_format ( self , text_format : str ) -> \"Label\" : \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise InvalidParamError ( text_format , TEXT_FORMATS ) self . setTextFormat ( TEXT_FORMATS [ text_format ]) return self","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_interaction","text":"Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Parameters: Name Type Description Default types str text interaction mode to use () Exceptions: Type Description InvalidParamError text interaction mode does not exist Source code in prettyqt/widgets/label.py def set_text_interaction ( self , * types : str ) -> \"Label\" : \"\"\"Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self","title":"set_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_weight","text":"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/widgets/label.py def set_weight ( self , weight : str ) -> \"Label\" : \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) font = self . font () font . setWeight ( WEIGHTS [ weight ]) self . setFont ( font ) return self","title":"set_weight()"},{"location":"api/widgets.html#prettyqt.widgets.layout","text":"","title":"layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout","text":"","title":"Layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.get_size_mode","text":"Return current size mode. Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: Type Description str size mode Source code in prettyqt/widgets/layout.py def get_size_mode ( self ) -> str : \"\"\"Return current size mode. Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: size mode \"\"\" return MODES . inv [ self . sizeConstraint ()]","title":"get_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_alignment","text":"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required item set alignment for specific child only None Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layout.py def set_alignment ( self , alignment : str , item = None ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) if item is not None : return self . setAlignment ( item , ALIGNMENTS [ alignment ]) else : return self . setAlignment ( ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_size_mode","text":"Set the size mode of the layout. Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Parameters: Name Type Description Default mode str size mode for the layout required Exceptions: Type Description InvalidParamError size mode does not exist Source code in prettyqt/widgets/layout.py def set_size_mode ( self , mode : str ): \"\"\"Set the size mode of the layout. Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setSizeConstraint ( MODES [ mode ])","title":"set_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit","text":"","title":"lineedit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit","text":"","title":"LineEdit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.font","text":"font(self) -> QFont Source code in prettyqt/widgets/lineedit.py def font ( self ) -> gui . Font : return gui . Font ( super () . font ())","title":"font()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_echo_mode","text":"Return echo mode. possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: Type Description str echo mode Source code in prettyqt/widgets/lineedit.py def get_echo_mode ( self ) -> str : \"\"\"Return echo mode. possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: echo mode \"\"\" return ECHO_MODES . inv [ self . echoMode ()]","title":"get_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_echo_mode","text":"Set echo mode. Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Parameters: Name Type Description Default mode str echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/lineedit.py def set_echo_mode ( self , mode : str ): \"\"\"Set echo mode. Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODES : raise InvalidParamError ( mode , ECHO_MODES ) self . setEchoMode ( ECHO_MODES [ mode ])","title":"set_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_read_only","text":"Set text to read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.listview","text":"","title":"listview"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView","text":"","title":"ListView"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_view_mode","text":"Return view mode. possible values are \"list\", \"icon\" Returns: Type Description str view mode Source code in prettyqt/widgets/listview.py def get_view_mode ( self ) -> str : \"\"\"Return view mode. possible values are \"list\", \"icon\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_view_mode","text":"Set view mode. possible values are \"list\", \"icon\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/listview.py def set_view_mode ( self , mode : str ): \"\"\"Set view mode. possible values are \"list\", \"icon\" Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem","text":"","title":"listwidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem","text":"","title":"ListWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.get_checkstate","text":"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/listwidgetitem.py def get_checkstate ( self ) -> str : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( STATES [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/listwidgetitem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow","text":"","title":"mainwindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow","text":"Class for our mainWindow. Includes all docks, a centralwidget and a toolbar","title":"MainWindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar","text":"Adds a toolbar to the mainmenu at specified area. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default toolbar QToolBar toolbar to use required position str position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : str = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBar ( TOOLBAR_AREAS [ position ], toolbar )","title":"add_toolbar()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar_break","text":"Adds a toolbar break to the given area behind the last item. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default position str position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar_break ( self , position : str = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBarBreak ( TOOLBAR_AREAS [ position ])","title":"add_toolbar_break()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.createPopupMenu","text":"createPopupMenu(self) -> QMenu Source code in prettyqt/widgets/mainwindow.py def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add_action ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add_action ( action ) return menu","title":"createPopupMenu()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.save_window_state","text":"Save current window state as QSetting. Parameters: Name Type Description Default recursive bool Description False Source code in prettyqt/widgets/mainwindow.py def save_window_state ( self , recursive = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { name } ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state ()","title":"save_window_state()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.toggle_fullscreen","text":"Toggle between fullscreen and regular size. Source code in prettyqt/widgets/mainwindow.py def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen ()","title":"toggle_fullscreen()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea","text":"","title":"mdiarea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea","text":"","title":"MdiArea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_tab_position","text":"Return current tab position. Possible values: \"north\", \"south\", \"west\", \"east\" Returns: Type Description str tab position Source code in prettyqt/widgets/mdiarea.py def get_tab_position ( self ) -> str : \"\"\"Return current tab position. Possible values: \"north\", \"south\", \"west\", \"east\" Returns: tab position \"\"\" return TAB_POSITIONS . inv [ self . tabPosition ()]","title":"get_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_view_mode","text":"Return current view mode. Possible values: \"default\", \"tabbed\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py def get_view_mode ( self ) -> str : \"\"\"Return current view mode. Possible values: \"default\", \"tabbed\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_window_order","text":"Return current window order. Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py def get_window_order ( self ) -> str : \"\"\"Return current window order. Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: view mode \"\"\" return WINDOW_ORDERS . inv [ self . activationOrder ()]","title":"get_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_tab_position","text":"Set tab position for the MDI area. Valid values are \"north\", \"south\", \"west\", \"east\" Parameters: Name Type Description Default position str tabs position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/mdiarea.py def set_tab_position ( self , position : str ): \"\"\"Set tab position for the MDI area. Valid values are \"north\", \"south\", \"west\", \"east\" Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITIONS : raise InvalidParamError ( position , TAB_POSITIONS ) self . setTabPosition ( TAB_POSITIONS [ position ])","title":"set_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_view_mode","text":"Set view mode for the MDI area. Valid values are \"default\", \"tabbed\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError view mode does not exist Source code in prettyqt/widgets/mdiarea.py def set_view_mode ( self , mode : str ): \"\"\"Set view mode for the MDI area. Valid values are \"default\", \"tabbed\" Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_window_order","text":"Set the window order behaviour for the MDI area. Valid values are \"creation\", \"stacking\", \"activation_history\" Parameters: Name Type Description Default mode str window order behaviour to use required Exceptions: Type Description InvalidParamError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py def set_window_order ( self , mode : str ): \"\"\"Set the window order behaviour for the MDI area. Valid values are \"creation\", \"stacking\", \"activation_history\" Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDERS : raise InvalidParamError ( mode , WINDOW_ORDERS ) self . setActivationOrder ( WINDOW_ORDERS [ mode ])","title":"set_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.menu","text":"","title":"menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu","text":"","title":"Menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_action","text":"Add an action to the menu. Parameters: Name Type Description Default label Union[str, prettyqt.widgets.action.Action] Label for button required callback Callable gets called when action is triggered None icon Optional[Any] icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut Optional[str] Shortcut for action None status_tip Optional[str] Status tip to be shown in status bar None Returns: Type Description Action Action added to menu Source code in prettyqt/widgets/menu.py def add_action ( self , label : Union [ str , widgets . Action ], callback : Callable = None , icon : Optional [ Any ] = None , checkable : bool = False , checked : bool = False , shortcut : Optional [ str ] = None , status_tip : Optional [ str ] = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action","title":"add_action()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_separator","text":"Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None Returns: Type Description WidgetAction Separator action Source code in prettyqt/widgets/menu.py def add_separator ( self , text : Optional [ str ] = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.set_icon","text":"Set the icon for the menu. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/menu.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox","text":"","title":"messagebox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox","text":"","title":"MessageBox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.add_button","text":"Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/messagebox.py def add_button ( self , button : str ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ])","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.get_text_format","text":"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/messagebox.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_icon","text":"Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/messagebox.py def set_icon ( self , icon : gui . icon . IconType ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) return None icon = gui . icon . get_icon ( icon ) self . setIconPixmap ( icon . get_pixmap ( size = 64 ))","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_text_format","text":"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/messagebox.py def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise InvalidParamError ( text_format , TEXT_FORMATS ) self . setTextFormat ( TEXT_FORMATS [ text_format ])","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit","text":"","title":"plaintextedit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit","text":"","title":"PlainTextEdit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_line_wrap_mode","text":"Set line wrap mode. Allowed values are \"none\" and \"widget width\" Parameters: Name Type Description Default mode str line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_line_wrap_mode ( self , mode : str ): \"\"\"Set line wrap mode. Allowed values are \"none\" and \"widget width\" Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODES : raise InvalidParamError ( mode , LINE_WRAP_MODES ) self . setLineWrapMode ( LINE_WRAP_MODES [ mode ])","title":"set_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_read_only","text":"Make the PlainTextEdit read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_wrap_mode","text":"Set word wrap mode. Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Parameters: Name Type Description Default mode str word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_wrap_mode ( self , mode : str ): \"\"\"Set word wrap mode. Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in WRAP_MODES : raise InvalidParamError ( mode , WRAP_MODES ) self . setWordWrapMode ( WRAP_MODES [ mode ])","title":"set_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.wheelEvent","text":"Handle wheel event for zooming. Source code in prettyqt/widgets/plaintextedit.py def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event )","title":"wheelEvent()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar","text":"","title":"progressbar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar","text":"Progress dialog. wrapper for QtWidgets.QProgressBar","title":"ProgressBar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_alignment","text":"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description str alignment Source code in prettyqt/widgets/progressbar.py def get_alignment ( self ) -> str : \"\"\"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" return ALIGNMENTS . inv [ self . alignment ()]","title":"get_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/progressbar.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_text_direction","text":"Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Type Description str Text direction Source code in prettyqt/widgets/progressbar.py def get_text_direction ( self ) -> str : \"\"\"Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inv [ self . textDirection ()]","title":"get_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_alignment","text":"Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/progressbar.py def set_alignment ( self , alignment : str ): \"\"\"Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) self . setAlignment ( ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_orientation","text":"Set the orientation of the progress bar. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the progress bar required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/progressbar.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the progress bar. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the progress bar Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_text_direction","text":"Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Parameters: Name Type Description Default text_direction str text direction for the layout required Exceptions: Type Description InvalidParamError text direction does not exist Source code in prettyqt/widgets/progressbar.py def set_text_direction ( self , text_direction : str ): \"\"\"Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ])","title":"set_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.progressdialog","text":"","title":"progressdialog"},{"location":"api/widgets.html#prettyqt.widgets.progressdialog.ProgressDialog","text":"Progress dialog. Wrapper for QtWidgets.QProgressDialog","title":"ProgressDialog"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy","text":"","title":"sizepolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy","text":"","title":"SizePolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_control_type","text":"Return control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: Type Description str control type Source code in prettyqt/widgets/sizepolicy.py def get_control_type ( self ) -> str : \"\"\"Return control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: control type \"\"\" return CONTROL_TYPES . inv [ self . controlType ()]","title":"get_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_horizontal_policy","text":"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str horizontal size policy Source code in prettyqt/widgets/sizepolicy.py def get_horizontal_policy ( self ) -> str : \"\"\"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: horizontal size policy \"\"\" return SIZE_POLICIES . inv [ self . horizontalPolicy ()]","title":"get_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_vertical_policy","text":"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str vertical size policy Source code in prettyqt/widgets/sizepolicy.py def get_vertical_policy ( self ) -> str : \"\"\"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: vertical size policy \"\"\" return SIZE_POLICIES . inv [ self . verticalPolicy ()]","title":"get_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_control_type","text":"Set the control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Parameters: Name Type Description Default mode str control type to set required Source code in prettyqt/widgets/sizepolicy.py def set_control_type ( self , mode : str ) -> None : \"\"\"Set the control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Args: mode: control type to set \"\"\" self . setControlType ( CONTROL_TYPES [ mode ])","title":"set_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_horizontal_policy","text":"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py def set_horizontal_policy ( self , mode : str ) -> None : \"\"\"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setHorizontalPolicy ( SIZE_POLICIES [ mode ])","title":"set_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_vertical_policy","text":"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py def set_vertical_policy ( self , mode : str ) -> None : \"\"\"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setVerticalPolicy ( SIZE_POLICIES [ mode ])","title":"set_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.slider","text":"","title":"slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider","text":"","title":"Slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.get_tick_position","text":"Return tick position. possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: Type Description str tick position Source code in prettyqt/widgets/slider.py def get_tick_position ( self ) -> str : \"\"\"Return tick position. possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: tick position \"\"\" val = TICK_POSITIONS . inv [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\" return val","title":"get_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.set_tick_position","text":"Set the tick position for the slider. allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Parameters: Name Type Description Default position str position for the ticks required Source code in prettyqt/widgets/slider.py def set_tick_position ( self , position : str ): \"\"\"Set the tick position for the slider. allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITIONS : raise InvalidParamError ( position , TICK_POSITIONS ) self . setTickPosition ( TICK_POSITIONS [ position ])","title":"set_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.splitter","text":"","title":"splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter","text":"","title":"Splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/splitter.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.set_orientation","text":"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitter.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider","text":"","title":"styleoptionslider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider","text":"","title":"StyleOptionSlider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_horizontal","text":"Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == QtCore . Qt . Horizontal","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_vertical","text":"Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == QtCore . Qt . Vertical","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_horizontal","text":"Set slider orientation to horizontal. Source code in prettyqt/widgets/styleoptionslider.py def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = QtCore . Qt . Horizontal","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_vertical","text":"Set slider orientation to vertical. Source code in prettyqt/widgets/styleoptionslider.py def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = QtCore . Qt . Vertical","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon","text":"","title":"systemtrayicon"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon","text":"","title":"SystemTrayIcon"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon.set_icon","text":"Set the system tray icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/systemtrayicon.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar","text":"","title":"tabbar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar","text":"","title":"TabBar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_elide_mode","text":"Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: Type Description str elide mode Source code in prettyqt/widgets/tabbar.py def get_elide_mode ( self ) -> str : \"\"\"Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: elide mode \"\"\" return ELIDE_MODES . inv [ self . elideMode ()]","title":"get_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_remove_behaviour","text":"Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: Type Description str remove behaviour Source code in prettyqt/widgets/tabbar.py def get_remove_behaviour ( self ) -> str : \"\"\"Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOURS . inv [ self . selectionBehaviorOnRemove ()]","title":"get_remove_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.mouseDoubleClickEvent","text":"mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/widgets/tabbar.py def mouseDoubleClickEvent ( self , event ): event . accept () self . on_detach . emit ( self . tabAt ( event . pos ()), self . mouse_cursor . pos ())","title":"mouseDoubleClickEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_elide_mode","text":"Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Parameters: Name Type Description Default mode str elide mode to use required Exceptions: Type Description InvalidParamError invalid elide mode Source code in prettyqt/widgets/tabbar.py def set_elide_mode ( self , mode : str ) -> None : \"\"\"Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in ELIDE_MODES : raise InvalidParamError ( mode , ELIDE_MODES ) self . setElideMode ( ELIDE_MODES [ mode ])","title":"set_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_icon_size","text":"Set the icon size for the tabs. Parameters: Name Type Description Default size int height/width of the icons required Source code in prettyqt/widgets/tabbar.py def set_icon_size ( self , size : int ) -> None : \"\"\"Set the icon size for the tabs. Args: size: height/width of the icons \"\"\" self . setIconSize ( QtCore . QSize ( size , size ))","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_remove_behaviour","text":"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Parameters: Name Type Description Default mode str new remove behaviour required Source code in prettyqt/widgets/tabbar.py def set_remove_behaviour ( self , mode : str ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOURS : raise InvalidParamError ( mode , REMOVE_BEHAVIOURS ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOURS [ mode ])","title":"set_remove_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget","text":"","title":"tabwidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab","text":"Window containing a detached tab. When a tab is detached, the contents are placed into this QMainWindow. The tab can be re-attached by closing the dialog Attributes: Name Type Description on_close signal, emitted when window is closed (widget, title, icon)","title":"DetachedTab"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab.closeEvent","text":"closeEvent(self, QCloseEvent) Source code in prettyqt/widgets/tabwidget.py def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . id , self . windowIcon ())","title":"closeEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget","text":"Widget for managing the tabs section.","title":"TabWidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.attach_tab","text":"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Parameters: Name Type Description Default widget Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] the content widget from the DetachedTab window required name str the name of the detached tab required icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] the window icon for the detached tab None insert_at Optional[int] insert the re-attached tab at the given index None Source code in prettyqt/widgets/tabwidget.py def attach_tab ( self , widget : Union [ QtWidgets . QWidget , QtWidgets . QLayout ], name : str , icon : gui . icon . IconType = None , insert_at : Optional [ int ] = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (gui.icon.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True )","title":"attach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.close_detached_tabs","text":"Close all tabs that are currently detached. Source code in prettyqt/widgets/tabwidget.py def close_detached_tabs ( self ) -> None : \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close ()","title":"close_detached_tabs()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.detach_tab","text":"Detach tab by removing its contents and placing them in a DetachedTab window. Parameters: Name Type Description Default index int index location of the tab to be detached required point QPoint screen pos for creating the new DetachedTab window required Returns: Type Description None None: Description Source code in prettyqt/widgets/tabwidget.py @autoslot . AutoSlot def detach_tab ( self , index : int , point : QtCore . QPoint ) -> None : \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content name = self . tabText ( index ) icon = self . tabIcon ( index ) if icon . isNull (): icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab","title":"detach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_position","text":"Return tab position. possible values are \"north\", \"south\", \"east\", \"west\" Returns: Type Description str tab position Source code in prettyqt/widgets/tabwidget.py def get_tab_position ( self ) -> str : \"\"\"Return tab position. possible values are \"north\", \"south\", \"east\", \"west\" Returns: tab position \"\"\" return TAB_POSITIONS . inv [ self . tabPosition ()]","title":"get_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_shape","text":"Return tab shape. possible values are \"rounded\", \"triangular\" Returns: Type Description str tab shape Source code in prettyqt/widgets/tabwidget.py def get_tab_shape ( self ) -> str : \"\"\"Return tab shape. possible values are \"rounded\", \"triangular\" Returns: tab shape \"\"\" return TAB_SHAPES . inv [ self . tabShape ()]","title":"get_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.open_widget","text":"Create a tab containing delivered widget. Source code in prettyqt/widgets/tabwidget.py @autoslot . AutoSlot def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True )","title":"open_widget()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_position","text":"Set tab position for the tabwidget. Valid values are \"north\", \"south\", \"east\", \"west\" Parameters: Name Type Description Default position str tab position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_position ( self , position : str ) -> None : \"\"\"Set tab position for the tabwidget. Valid values are \"north\", \"south\", \"east\", \"west\" Args: position: tab position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITIONS : raise InvalidParamError ( position , TAB_POSITIONS ) self . setTabPosition ( TAB_POSITIONS [ position ])","title":"set_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_shape","text":"Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Parameters: Name Type Description Default shape str tab shape to use required Exceptions: Type Description InvalidParamError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_shape ( self , shape : str ) -> None : \"\"\"Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ])","title":"set_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar","text":"","title":"toolbar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar","text":"","title":"ToolBar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.add_separator","text":"Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None before QAction insert separator before specific action None Returns: Type Description QAction Separator action Source code in prettyqt/widgets/toolbar.py def add_separator ( self , text : Optional [ str ] = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label )","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.get_style","text":"Return current style. Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: Type Description str style Source code in prettyqt/widgets/toolbar.py def get_style ( self ) -> str : \"\"\"Return current style. Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: style \"\"\" return STYLES . inv [ self . toolButtonStyle ()]","title":"get_style()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.is_area_allowed","text":"Check if toolbar is allowed at specified area. Valid values for area: \"left\", \"right\", \"top\", \"bottom\", \"all\" Parameters: Name Type Description Default area str area of the toolbar required Exceptions: Type Description InvalidParamError area does not exist Source code in prettyqt/widgets/toolbar.py def is_area_allowed ( self , area : str ): \"\"\"Check if toolbar is allowed at specified area. Valid values for area: \"left\", \"right\", \"top\", \"bottom\", \"all\" Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in TOOLBAR_AREAS : raise InvalidParamError ( area , TOOLBAR_AREAS ) return self . isAreaAllowed ( TOOLBAR_AREAS [ area ])","title":"is_area_allowed()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton","text":"","title":"toolbutton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton","text":"","title":"ToolButton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_arrow_type","text":"Return arrow type. possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: Type Description str arrow type Source code in prettyqt/widgets/toolbutton.py def get_arrow_type ( self ) -> str : \"\"\"Return arrow type. possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: arrow type \"\"\" return ARROW_TYPES . inv [ self . arrowType ()]","title":"get_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_popup_mode","text":"Return popup mode. possible values are \"delayed\", \"menu_button\", \"instant\" Returns: Type Description str popup mode Source code in prettyqt/widgets/toolbutton.py def get_popup_mode ( self ) -> str : \"\"\"Return popup mode. possible values are \"delayed\", \"menu_button\", \"instant\" Returns: popup mode \"\"\" return POPUP_MODES . inv [ self . popupMode ()]","title":"get_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_arrow_type","text":"Set the arrow type of the toolbutton. valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Parameters: Name Type Description Default mode str arrow type to use required Exceptions: Type Description InvalidParamError invalid arrow type Source code in prettyqt/widgets/toolbutton.py def set_arrow_type ( self , mode : str ): \"\"\"Set the arrow type of the toolbutton. valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in ARROW_TYPES : raise InvalidParamError ( mode , ARROW_TYPES ) self . setArrowType ( ARROW_TYPES [ mode ])","title":"set_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_popup_mode","text":"Set the popup mode of the toolbutton. valid values are: \"delayed\", \"menu_button\", \"instant\" Parameters: Name Type Description Default mode str popup mode to use required Exceptions: Type Description InvalidParamError invalid popup mode Source code in prettyqt/widgets/toolbutton.py def set_popup_mode ( self , mode : str ): \"\"\"Set the popup mode of the toolbutton. valid values are: \"delayed\", \"menu_button\", \"instant\" Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODES : raise InvalidParamError ( mode , POPUP_MODES ) self . setPopupMode ( POPUP_MODES [ mode ])","title":"set_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem","text":"","title":"treewidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem","text":"","title":"TreeWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_checkstate","text":"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/treewidgetitem.py def get_checkstate ( self ) -> str : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ( 0 )]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( 0 , STATES [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/treewidgetitem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( 0 , icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.undoview","text":"","title":"undoview"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView","text":"","title":"UndoView"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView.set_clean_icon","text":"Set the icon for the clean button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/undoview.py def set_clean_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setCleanIcon ( icon )","title":"set_clean_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget","text":"","title":"widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget","text":"","title":"Widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_contextmenu_policy","text":"Return current contextmenu policy. Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Returns: Type Description str contextmenu policy Source code in prettyqt/widgets/widget.py def get_contextmenu_policy ( self ) -> str : \"\"\"Return current contextmenu policy. Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Returns: contextmenu policy \"\"\" return CONTEXT_POLICIES . inv [ self . contextMenuPolicy ()]","title":"get_contextmenu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_focus_policy","text":"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: Type Description str str: Focus policy Source code in prettyqt/widgets/widget.py def get_focus_policy ( self ) -> str : \"\"\"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: str: Focus policy \"\"\" return FOCUS_POLICIES . inv [ self . focusPolicy ()]","title":"get_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_modality","text":"Get the current modality modes as a string. Possible values: \"none\", \"window\", \"application\" Returns: Type Description str modality mode str Source code in prettyqt/widgets/widget.py def get_modality ( self ) -> str : \"\"\"Get the current modality modes as a string. Possible values: \"none\", \"window\", \"application\" Returns: modality mode str \"\"\" return MODALITIES . inv [ self . windowModality ()]","title":"get_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.resize","text":"resize(self, QSize) resize(self, int, int) Source code in prettyqt/widgets/widget.py def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size )","title":"resize()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_contextmenu_policy","text":"Set contextmenu policy for given item view. Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Parameters: Name Type Description Default policy str contextmenu policy to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_contextmenu_policy ( self , policy : str ) -> None : \"\"\"Set contextmenu policy for given item view. Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CONTEXT_POLICIES : raise InvalidParamError ( policy , CONTEXT_POLICIES ) self . setContextMenuPolicy ( CONTEXT_POLICIES [ policy ])","title":"set_contextmenu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_focus_policy","text":"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Parameters: Name Type Description Default policy str Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/widget.py def set_focus_policy ( self , policy : str ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in FOCUS_POLICIES : raise InvalidParamError ( policy , FOCUS_POLICIES ) self . setFocusPolicy ( FOCUS_POLICIES [ policy ])","title":"set_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_icon","text":"Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/widget.py def set_icon ( self , icon : gui . icon . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_modality","text":"Set modality for the dialog. Valid values for modality: \"none\", \"window\", \"application\" Parameters: Name Type Description Default modality str modality for the main window 'window' Exceptions: Type Description InvalidParamError modality type does not exist Source code in prettyqt/widgets/widget.py def set_modality ( self , modality : str = \"window\" ) -> None : \"\"\"Set modality for the dialog. Valid values for modality: \"none\", \"window\", \"application\" Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in MODALITIES : raise InvalidParamError ( modality , MODALITIES ) self . setWindowModality ( MODALITIES [ modality ])","title":"set_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_size_policy","text":"Set the sizes policy. possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default horizontal Optional[str] horizontal size policy None vertical Optional[str] vertical size policy None Source code in prettyqt/widgets/widget.py def set_size_policy ( self , horizontal : Optional [ str ] = None , vertical : Optional [ str ] = None ) -> None : \"\"\"Set the sizes policy. possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp )","title":"set_size_policy()"}]}