{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"prettyqt: Pythonic layer on top of PyQt5 / PySide2 What is it? PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PySide2. Main Features Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module. Where to get it The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt Dependencies qtpy qtawesome bidict orjson regex docutils Installation from sources This project uses poetry for dependency management and packaging. Install this first. In the prettyqt directory (same one where you found this file after cloning the git repo), execute: poetry install License MIT Documentation The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/ Contributing to prettyqt All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Home"},{"location":"index.html#prettyqt-pythonic-layer-on-top-of-pyqt5-pyside2","text":"","title":"prettyqt: Pythonic layer on top of PyQt5 / PySide2"},{"location":"index.html#what-is-it","text":"PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PySide2.","title":"What is it?"},{"location":"index.html#main-features","text":"Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module.","title":"Main Features"},{"location":"index.html#where-to-get-it","text":"The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt","title":"Where to get it"},{"location":"index.html#dependencies","text":"qtpy qtawesome bidict orjson regex docutils","title":"Dependencies"},{"location":"index.html#installation-from-sources","text":"This project uses poetry for dependency management and packaging. Install this first. In the prettyqt directory (same one where you found this file after cloning the git repo), execute: poetry install","title":"Installation from sources"},{"location":"index.html#license","text":"MIT","title":"License"},{"location":"index.html#documentation","text":"The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/","title":"Documentation"},{"location":"index.html#contributing-to-prettyqt","text":"All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Contributing to prettyqt"},{"location":"changelog.html","text":"v0.147.0 (2020-12-13) Feat ToolBar : add get_allowed_areas method WebEnginePage : add some additional methods WebEngineSettings : add delitem method Application : add send/post_event methods v0.146.0 (2020-12-13) Fix correctly serialize AbstractGraphicsShapeItem Feat GuiApplication : add get_icon method PlainTextEdit : add get(_line)_wrap_mode methods GuiApplication : add get_application_state method v0.145.0 (2020-12-11) Fix GraphicsGridLayout : serialize correctly MediaRecorder : use correct module in set_video/audio_settings correct constant naming install_exceptionhook fix Feat GridLayout : add get/set_origin_corner methods BoxLayout : add get/set_direction methods NetworkCookieJar : add add and set_cookies_from_url methods NetworkCookie : add set_expiration_date method Translator : add bool method custom_widgets : add RoundProgressBar class DateTimeEdit : add some more methods related to sections get/set_icon_size work for some widgets CalendarWidget : add set_range method HeaderView : add generate_header_id method Widget : add edit_palette contextmanager and get_font method Palette : add brush methods custom_models : add ImportlibDistributionModel class v0.144.0 (2020-12-09) Fix Settings : iter through key-value pairs correct inheritance for QuickItem ColumnItemModel : correct get_width signature Feat qml : add QmlImageProviderbase class widgets : add TreeWidgetItemIterator class quick : add some more classes qml : add QmlParserStatus class Widget : add get_title method Painter : add get_text_rect method ListWidget : add add_item method v0.143.0 (2020-12-08) Fix ObjectBrowser fix Feat implement eq method for some more validator classes v0.142.1 (2020-12-07) Fix use our own SizeF class v0.142.0 (2020-12-07) Feat SizeF : add some methods to be on par with Size Size : add expanded_to method CompositeValidator : add some additional methods custom_validators : add eq method to validator classes TreeWidgetItem : add some more methods widgets : add TableWidgetSelectionRange class core : add Calendar class core : add SignalMapper class core : add StateMachine class core : add LockFile class core : add JsonDocument/JsonValue classes GeoCircle : allow tuple in ctor core : add SocketNotifier class widgets : add Shortcut class Fix Correctly inherit StyleItemDelegate v0.141.0 (2020-12-03) Feat core : add Collator(SortKey) classes Fix github actions fix v0.140.4 (2020-12-02) Fix docs build fix v0.140.3 (2020-12-02) Fix docs deployment v0.140.2 (2020-12-02) Fix deploy check for github actions v0.140.1 (2020-12-02) Fix github actions: conditional deploy step v0.140.0 (2020-12-02) Feat gui : add ColorSpace class v0.139.0 (2020-12-02) Feat FileInfo/Dir : fallback to pathlib.Path methods widgets : add Proxy/CommonStyle classes widgets : add Gesture classes core : add TemporaryDir class widgets : add WhatsThis class core : add ItemSelectionRange class FormLayout : add some more methods core : add ProcessEnvironment class gui : add StaticText class core : add PauseAnimation class v0.138.0 (2020-12-01) Feat core : add ChildEvent / TimerEvent classes core : add IdentityProxyModel class gui : add SessionManager class gui : add InputMethod class core : add AbstractEventDispatcher class widgets : add StackedWidget class widgets : add some events FileInfo : add some additional methods gui : add Vector3D class core : add MimeType / MimeDatabase classes core : add SaveFile class core : add SignalBlocker class core : add TimeLine class gui : add Bitmap class core : add RandomGenerator class FileDevice : add get_error method widgets : add Dial class widgets : add RubberBand class Wizard/WizardPage : add some more methods widgets : add GraphicsRotation / GraphicsScale classes widgets : add GraphicsTransform class widgets : add LCDNumber class widgets : add Scroller(Properties) classes core : add CommandLineParser/Option classes Pixmap : add some more methods gui : add Screen class Transform : add some more methods add Abstract/PlainTextTextDocumentLayout classes core : add BasicTimer class core : add Resource class core : add StorageInfo class core : add ElapsedTimer class core : add CryptographicHash class v0.137.1 (2020-11-27) Fix doc build fix v0.137.0 (2020-11-27) Feat core : add OperatingSystemVersion class PdfWriter : add set_page_margins method core : add MarginsF class core : Add TextStream class core : add ByteArrayMatcher AbstractItemModel : add check_index method PlaceManager : add search_place method core : add app method add bytes method to some classes utils : add Singleton metaclass icon : add add_pixmap method gui : Add PixmapCache Font : add some more methods v0.136.0 (2020-11-26) Feat location : add PlaceResult class location : add PlaceProposedSearchResult class location : add clone_from method to reply classes Object : add has_id method Fix emit inputandslider signal correctly on value change correct flag for constants.NO_CHILDREN v0.135.0 (2020-11-26) Feat WebEngineHistoryItem : add get_icon_url method location : add PlaceMatchReply / PlaceIdReply classes PlaceContentReply/PlaceSearchReply : add request methods gui : add TextListFormat class gui : add TextImageFormat class location : add some reply/result classes gui : add TextTableCellFormat class gui : add app method gui : add TextFrameFormat class Application : add get_font method add qthelp module quick : add QuickPaintedItem class gui : add TextBlockGroup class TextCharFormat : add get/set_vertical_alignment methods TextBlock : add contains method PaintDevice : add get_metric method GuiApplication : add get/set_layout_direction methods gui : add TextObject / TextLength / TextFrame / TextFormat classes core : add ItemSelection class GraphicsLayout : add set_margin method Fix correctly add items for GraphicsGridLayout v0.134.0 (2020-11-23) Feat core : add PersistentModelIndex class core : add PluginLoader class core : add Library class gui : add PainterPathStroker class gui : add ImageWriter / ImageReader / ImageIOHandler classes quick : add QuickItem / QuickWindow classes core : add install_message_handler method gui : add RasterWindow / PaintDeviceWindow / OpenGLWindow classes svg : add SvgGenerator class SplashScreen : allow pixmap for ctor icon : add get_available_sizes method widget : add set_attributes method gui : add Vector4D / Matrix4x4 classes custom_widgets : add StarDelegate class custom_delegates : add ProgressBarDelegate class widgets : add missing StyleOption classes WidgetItems : some more methods Painter : add backup_state contextmanager Fix KeySequenceEdit : correct repr correct coloring for WaitingSpinner v0.133.1 (2020-11-16) Fix test fix v0.133.0 (2020-11-16) Feat ComboBox : default param for add_items AbstractItemModel : add force_reset/force_layoutchange methods add location module gui : add FontMetricsF class GeoCoordinate : add bool method FontMetrics : add get_(tight_)bounding_rect methods Url : add to_string method network : add LocalServer / TcpServer classes multimediawidgets : add GraphicsVideoItem class mediaobject : add get_availability method add qt module v0.132.1 (2020-11-07) Fix import fix v0.132.0 (2020-11-07) Feat NetworkAccessManager : allow str for request network : add UdpSocket network : add NetworkAddressEntry / NetworkInterface classes add texttospeech module network : add NetworkDatagram class core : add DeadlineTimer class network : add HostAddress/AbstractSocket/TcpSocket classes network : add NetworkProxy class network : add HttpMultiPart class network : add HttpPart class NetworkRequest : add set/get_header methods v0.131.0 (2020-11-04) Feat webenginecore : add WebEngineHttpRequest class webenginewidgets : add WebEngineContextMenuData class webenginewidgets : add WebEngineScriptCollection class multimedia : add CameraExposure/CameraImageProcessing classes multimedia : add CameraFocus(Zone) classes webenginecore : add WebEngineUrlSchemeHandler v0.130.0 (2020-11-04) Feat WebEnginePage : add some settings methods webenginewidgets : add WebEngineSettings class add bluetooth module core : add Uuid class add quick module gui : add Surface and Window class multimedia : add ImageEncoderSettings multimedia : add MediaTimeRange and MediaTimeInterval classes v0.129.1 (2020-10-29) Fix fix tests fix multimedia tests for Travis Feat charts : add Legend class WebEnginePage : add get_history method qml : add JSValue(Iterator) class VideoWidget : option for fullscreen toggling via double click multimedia : add CameraViewFinderSettings multimedia : add VideoFrame class multimedia : add AbstractPlanarVideoBuffer class multimedia : add AbstractVideoBuffer class multimedia : add Camera class multimedia : add CameraInfo class gui : add Clipboard class multimedia : add AudioFormat class multimedia : add SoundEffect class charts : add PieSlice class charts : add BoxSet and CandlestickSet classes charts : add Axis-related classes charts : add BarSeries-related classes v0.128.1 (2020-10-25) Fix import fix v0.128.0 (2020-10-25) Feat custom_widgets : add ExpandableLine class ParallelAnimationGroup : add set_duration method charts : add Abstract/ValueAxis and PolarChart classes core : add SequentialAnimationGroup class AnimationGroup : allow slicing for indexing AnimationGroup : add add_property_animation method ChartView : add get/set_rubber_band methods Chart : add some more methods core : add Locale class core : add Margins class webenginewidgets : add some more modules Fix Chart : properly inherit from GraphicsWidget v0.127.1 (2020-10-20) Fix fix tests v0.127.0 (2020-10-20) Fix always import correct bindings for winextras module Url : allow initializing without arg Feat PainterPath : add set_fill_rule method PainterPath : add get_bounding_rect method GraphicsItem : add get_shape method MediaPlaylist : add get_media_url method start with webenginecore module core : add EventLoop class Widget : add get_font_info method custom_models : add PlaylistModel Translator : add get_file_path method add positioning module add some first QtQml classes core : add LibraryInfo class Application : add iter method Application : add get/set_navigation_mode methods Application : add get/is_effect_enabled methods custom_widgets : add Player class v0.126.0 (2020-10-08) Feat core : add Process class DateTime : add get/set_time_spec and get_date/time methods core : add Time class DateTime : add timezone methods core : add TimeZone class Pixmap : add create_dot classmethod v0.125.1 (2020-10-07) Fix import fix v0.125.0 (2020-10-07) Feat widgets : add Transition classes core : add Transition classes Fix fix Action.get_shortcut for NoneValue v0.124.0 (2020-10-05) Feat IODevice : add get_open_mode method Improve repr and add str method for Date and DateTime core : add TemporaryFile class FileDevice : add set/get_file_time methods MainWindow : allow setting central widget to None AbstractButton : add get_shortcut method Url : add from_user_input method WebEngineView : add get_url method FileInfo : support pathlib + add proper repr KeySequence : allow initializing with standard keys v0.123.1 (2020-09-29) Fix add missing State import in core module v0.123.0 (2020-09-29) Feat core : add State classes core : add TextBoundaryFinder class ProgressBar : add get/set_orientation methods + serialize work Action : allow setting callback with ctor WebEngineView : set subclassed WebEnginePage by default WebEnginePage : add some more methods and constants AbstractSlider : add get/set_orientation methods core : add FileInfo class webenginewidgets : add WebEngineProfile class v0.122.1 (2020-09-27) Fix use correct icon names v0.122.0 (2020-09-27) Feat gui : add PageLayout gui : add Movie class gui : add PageSize class gui : add FontInfo class core : add UrlQuery class add network module PropertyAnimation : add get/set_property_name methods core : add ParallelAnimationGroup widgets : add SizeGrip class widgets : add DataWidgetMapper class core : add StringListModel VersionNumber : add get_python_version gui : add Transform class Painter : add draw_polygon method add core.ByteArray v0.121.0 (2020-09-10) Feat Image : add setitem / getitem methods Line/LineF : add reversed and abs methods GraphicsScene : add get/set_item_index_method method Fix serialization fixes v0.120.0 (2020-08-27) Feat GraphicsWidget : add set_layout method GraphicsLayout : add some magic methods GraphicsScene : add add_item_group method widgets : add GraphicsAnchorLayout / GraphicsGridLayout / GraphicsLinearLayout widgets : add GraphicsItemGroup Layout : add delitem method Polygon/PolygonF : add repr and iter methods PainterPath : some additional methods GraphicsItems : add repr methods Line/LineF : add repr and iter Application : allow loading included language files via load_language_file widgets : add GraphicsView class Refactor PromptLineEdit rework v0.119.1 (2020-08-24) Fix add missing StyleOptionComplex class v0.119.0 (2020-08-24) Feat GraphicsScene : add some convenience methods widgets : add graphicsitem classes StylePainter : add draw_complex_control method gui : allow pickling some more classes core : add LineF class Widget : add get_palette() method widgets : add GraphicsPixmapItem / GraphicsScene GraphicsItem : add getitem and setitem methods widgets : add Blur/Colorize/DropShadowEffect Fix Graphicsitem collides methods fix KeySequence : pickling v0.118.2 (2020-08-17) Fix Fix tests v0.118.1 (2020-08-17) Fix MenuBar : fix add method v0.118.0 (2020-08-17) Refactor MenuBar : return subclassed types instead of qt classes Feat gui : add TextDocument / TextBlock / TextOption gui : add ConicalGradient / RadialGradient custom_widgets : add CollapsibleFrame GraphicsItem : add some more methods v0.117.0 (2020-08-16) Feat MimeData : add dict-like interface Timer : add get/set_type methods File : add repr and str methods Dir : add repr and truediv methods Frame : set/get_frame_shape, set/get_frame_shadow Splitter : add setitem method, and some more typing Polygon/PolygonF : pythonize core : add Abstract/Variant/PropertyAnimation and AnimationGroup core : add EasingCurve StyleOptionSlider : add get_orientation method Refactor SpanSlider : clean up code v0.116.0 (2020-08-13) Feat gui : add LinearGradient AbstractSlider : add get/set_repeat_action and trigger_action methods TabWidget : add get/set_tab_position methods Image/Pixmap : add bool method MenuBar : serialize stuff MdiArea : serialize stuff Brush : allow pickling + add get_texture_image method custom_widgets : add Timeline Pen : add methods for setting and getting style / join style / cap style Refactor Painter : rework set_pen / get_pen v0.115.0 (2020-08-12) Feat Polygon : add add_points method Object : add store_widget_states / restore_widget_states Painter : add paint_on, set_transparent_background, set_brush PainterPath : add add_rect method Application : add class_getitem Fix RegexEditor : correctly initialize dialog v0.114.1 (2020-08-12) Fix HeaderView : fix saving state v0.114.0 (2020-08-12) Refactor use AutoSlot decorator Feat add autoslot decorator add prettyqt.debug v0.113.0 (2020-08-10) Feat gui : add PainterPath class gui : add Polygon class gui : palette improvements core : add Line class core : add TransposeProxyModel / ConcatenateTablesProxyModel add ObjectBrowser widgets : add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect Action : \"checked\" param for ctor gui : some magic methods + get_matches for KeySequence core : allow pickling VersionNumber / Size / Dir gui : add Gradient class add ColumnItemModel / ColumnItem Settings : add set_values method Widget : spacing kwarg for set_layout Refactor add serialization stuff improve some repr methods v0.112.0 (2020-08-04) Feat utils : add install_exceptionhook method FileSystemModel : add some more shortcuts for set_root_path core : add VersionNumber class Application : add get_icon method MessageBox : add show_exception method Refactor improve compat with older Qt Versions Fix another test fix v0.111.1 (2020-08-03) Fix fix tests for Linux v0.111.0 (2020-08-03) Feat widgets : add FontComboBox StandardPaths : add class_getitem method Action : some more ctor kwargs Action : add get/set_menu_role methods, some pickle work Refactor custom Exception for wrong params Fix Menu : disable separator widgetAction v0.110.2 (2020-08-03) Fix fix broken LogTextEdit v0.110.1 (2020-08-03) Fix LogTextEdit : improve exception handling SidebarWidget : some fixes related to set_marker v0.110.0 (2020-08-02) Refactor improve serialization for listitems Validator pickle work Feat Image : allow pickling DataStream : add create_bytearray / write_bytearray / copy_data methods core : add DataStream class v0.109.0 (2020-08-02) Feat widget : add pretty method for devtools GridLayout : allow adding tuples/lists Refactor rework widget pickling move CheckboxDelegate to custom_delegates pickle stuff for undocommand v0.108.0 (2020-07-31) Feat custom_delegates : add IconDelegate and NoFocusDelegate TableWidet : add getitem and setitem methods Icon : add from_image method allow str for layout. getitem (uses objectName) SidebarWidget : add set_marker method Refactor move delegates to separate module v0.107.0 (2020-07-29) Feat GridLayout : also allow adding LayoutItems via add method v0.106.1 (2020-07-29) Fix TabWidget : correctly close detached tabs on app close pickle fixes for toolbar and dockwidget PygmentsHighlighter : catch pygments KeyError v0.106.0 (2020-07-26) Feat gui : add DesktopServices class multimedia : add AudioRecorder class core : add StandardPaths class widgets : add Undo classes v0.105.0 (2020-07-24) Feat MediaRecorder : some new methods sort_by_column for tableview and treeview multimedia : dict-setter and getter for encodersettings Refactor improve Url-Pathlib interoperability Fix PopupInfo : use PrimaryScreen geometry instead of screens[0] for positioning v0.104.0 (2020-07-23) Feat multimedia : add MediaRecorder AbstractItemModel : add getitem method multimedia : add VideoEncoderSettings / AudioEncoderSettings Refactor use subclassed core.Size v0.103.0 (2020-07-22) Feat ActionGroup : add getitem method MediaContent : add get_url method add multimediawidgets module add multimedia module PlainTextEdit : add allow_wheel_zoom method Object : name kwarg for find_parent method v0.102.0 (2020-07-21) Refactor move raise_dock to from Widget to Object SidebarWidget : some code cleanup, make settings button size configurable Widget : default state to True for set_attribute MainWindow : add return value for load_window_state Feat Object : add find_parent method PlainTextEdit : add style kwarg to set_syntaxhighlighter v0.101.1 (2020-07-20) Fix LogTextEdit : better integrate with custom qstylesheets v0.101.0 (2020-07-20) Feat MessageBox : add detail_text keyword argument to message method Fix correct return type for gui.icon.get_icon v0.100.0 (2020-07-20) Feat ToolTip : add show_text method GuiApplication : add set_override_cursor / restore_override_cursor methods GuiApplication : add override_cursor context manager v0.99.0 (2020-07-18) Refactor FileChooserButton : typing and fixes Dataset : typing and fixes SidebarWidget : use button map instead of attaching button to widget Feat AbstractItemView : add scroll_to method v0.98.5 (2020-07-17) Perf add icon cache Refactor use core.Settings for windows dark mode detection v0.98.4 (2020-07-15) Fix use qta default icon color instead of black for default v0.98.3 (2020-07-15) Refactor properly set stylesheets by using contextmanager FontDialog : do not override current_font contextmanager move current_font context manager to Widget class v0.98.2 (2020-07-15) Fix package name v0.98.1 (2020-07-15) Fix correctly reset stylesheet for widget validation background Refactor use qstylizer for stylesheet editing v0.98.0 (2020-07-15) Feat widgets : add StyleFactory Refactor FontDatabase : make add_fonts_from_folder a classmethod v0.97.0 (2020-07-15) Feat gui : add FontDatabase widgets : add Completer widgets : add ActionGroup v0.96.0 (2020-07-14) Feat SelectionWidget : default keyword argument for add_custom v0.95.0 (2020-07-14) Feat SelectionWidget : different options for custom type add PagedPaintDevice Widget : add set_margin method v0.94.0 (2020-07-14) Feat Widget : add Widget.font_metrics() SpacerItem : allow strings for size policy in ctor allow Mapping for listwidget.add_items Refactor change to {value: label} dicts for FlagSelectionWidget.add_items v0.93.1 (2020-07-14) Refactor typecheck for Mapping instead of dict for combobox / selectionwidget add_items method v0.93.0 (2020-07-14) Feat add register_extensions function to settings module Refactor Settings : do not override value method v0.92.1 (2020-07-14) Fix winextras test fix v0.92.0 (2020-07-14) Feat add widgets.SystemTrayIcon add winextras module Label : set_indent method v0.91.0 (2020-07-13) Feat SidebarWidget : allow choosing layout MainWindow : add show_blocking method v0.90.0 (2020-07-13) Feat Toolbar : allow combinations of allowed areas for set_allowed_areas SidebarWidget : add optional settings menu v0.89.1 (2020-07-13) Refactor SelectionWidget : switch to {data: label} dicts for add_items to be in line with RadioButton v0.89.0 (2020-07-13) Feat SidebarWidget : make button width configurable v0.88.1 (2020-07-13) Refactor ComboBox : use set_data for set_value Fix ComboBox : fix add_items method v0.88.0 (2020-07-13) Feat ComboBox : set_data method v0.87.0 (2020-07-13) Feat ComboBox : allow dict for add_items v0.86.3 (2020-07-12) Refactor RegexEditor : code cleanup v0.86.2 (2020-07-12) Fix another deployment fix v0.86.1 (2020-07-12) Fix deployment fix v0.86.0 (2020-07-12) Feat add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line v0.85.1 (2020-07-10) Fix add missing pygments requirement v0.85.0 (2020-07-10) Feat dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method Refactor CodeEditor : use pygments for syntax highlighting v0.84.0 (2020-07-10) Feat sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child v0.83.1 (2020-07-09) Refactor move set_icon from window classes to widget class v0.83.0 (2020-07-09) Feat add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager v0.82.0 (2020-07-09) Feat add Label.set_bold / set_italic / set_weight added Font.set_weight v0.81.0 (2020-07-08) Feat allow setting window icon color os dark mode detection v0.80.1 (2020-07-08) Fix Settings.value() returned wrong type v0.80.0 (2020-07-08) Feat add Widget.set_attribute add margin keyword argument to Widget.set_layout v0.79.1 (2020-07-08) Fix remove Qt logger on Application exit v0.79.0 (2020-07-08) Feat add widgets.Application.get_widget v0.78.0 (2020-07-08) Feat allow to save/load window state recursively. Saving needs to be done explicitely now. Fix some fixes for core.Settings dict interface properly preserve types in core.Settings v0.77.1 (2020-07-07) Refactor also allow qt flag for Splitter ctor Fix return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview 0.77.0 (2020-07-06) Feat allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages Fix fix Messagebox.message call Refactor dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars","title":"Changelog"},{"location":"changelog.html#v01470-2020-12-13","text":"","title":"v0.147.0 (2020-12-13)"},{"location":"changelog.html#feat","text":"ToolBar : add get_allowed_areas method WebEnginePage : add some additional methods WebEngineSettings : add delitem method Application : add send/post_event methods","title":"Feat"},{"location":"changelog.html#v01460-2020-12-13","text":"","title":"v0.146.0 (2020-12-13)"},{"location":"changelog.html#fix","text":"correctly serialize AbstractGraphicsShapeItem","title":"Fix"},{"location":"changelog.html#feat_1","text":"GuiApplication : add get_icon method PlainTextEdit : add get(_line)_wrap_mode methods GuiApplication : add get_application_state method","title":"Feat"},{"location":"changelog.html#v01450-2020-12-11","text":"","title":"v0.145.0 (2020-12-11)"},{"location":"changelog.html#fix_1","text":"GraphicsGridLayout : serialize correctly MediaRecorder : use correct module in set_video/audio_settings correct constant naming install_exceptionhook fix","title":"Fix"},{"location":"changelog.html#feat_2","text":"GridLayout : add get/set_origin_corner methods BoxLayout : add get/set_direction methods NetworkCookieJar : add add and set_cookies_from_url methods NetworkCookie : add set_expiration_date method Translator : add bool method custom_widgets : add RoundProgressBar class DateTimeEdit : add some more methods related to sections get/set_icon_size work for some widgets CalendarWidget : add set_range method HeaderView : add generate_header_id method Widget : add edit_palette contextmanager and get_font method Palette : add brush methods custom_models : add ImportlibDistributionModel class","title":"Feat"},{"location":"changelog.html#v01440-2020-12-09","text":"","title":"v0.144.0 (2020-12-09)"},{"location":"changelog.html#fix_2","text":"Settings : iter through key-value pairs correct inheritance for QuickItem ColumnItemModel : correct get_width signature","title":"Fix"},{"location":"changelog.html#feat_3","text":"qml : add QmlImageProviderbase class widgets : add TreeWidgetItemIterator class quick : add some more classes qml : add QmlParserStatus class Widget : add get_title method Painter : add get_text_rect method ListWidget : add add_item method","title":"Feat"},{"location":"changelog.html#v01430-2020-12-08","text":"","title":"v0.143.0 (2020-12-08)"},{"location":"changelog.html#fix_3","text":"ObjectBrowser fix","title":"Fix"},{"location":"changelog.html#feat_4","text":"implement eq method for some more validator classes","title":"Feat"},{"location":"changelog.html#v01421-2020-12-07","text":"","title":"v0.142.1 (2020-12-07)"},{"location":"changelog.html#fix_4","text":"use our own SizeF class","title":"Fix"},{"location":"changelog.html#v01420-2020-12-07","text":"","title":"v0.142.0 (2020-12-07)"},{"location":"changelog.html#feat_5","text":"SizeF : add some methods to be on par with Size Size : add expanded_to method CompositeValidator : add some additional methods custom_validators : add eq method to validator classes TreeWidgetItem : add some more methods widgets : add TableWidgetSelectionRange class core : add Calendar class core : add SignalMapper class core : add StateMachine class core : add LockFile class core : add JsonDocument/JsonValue classes GeoCircle : allow tuple in ctor core : add SocketNotifier class widgets : add Shortcut class","title":"Feat"},{"location":"changelog.html#fix_5","text":"Correctly inherit StyleItemDelegate","title":"Fix"},{"location":"changelog.html#v01410-2020-12-03","text":"","title":"v0.141.0 (2020-12-03)"},{"location":"changelog.html#feat_6","text":"core : add Collator(SortKey) classes","title":"Feat"},{"location":"changelog.html#fix_6","text":"github actions fix","title":"Fix"},{"location":"changelog.html#v01404-2020-12-02","text":"","title":"v0.140.4 (2020-12-02)"},{"location":"changelog.html#fix_7","text":"docs build fix","title":"Fix"},{"location":"changelog.html#v01403-2020-12-02","text":"","title":"v0.140.3 (2020-12-02)"},{"location":"changelog.html#fix_8","text":"docs deployment","title":"Fix"},{"location":"changelog.html#v01402-2020-12-02","text":"","title":"v0.140.2 (2020-12-02)"},{"location":"changelog.html#fix_9","text":"deploy check for github actions","title":"Fix"},{"location":"changelog.html#v01401-2020-12-02","text":"","title":"v0.140.1 (2020-12-02)"},{"location":"changelog.html#fix_10","text":"github actions: conditional deploy step","title":"Fix"},{"location":"changelog.html#v01400-2020-12-02","text":"","title":"v0.140.0 (2020-12-02)"},{"location":"changelog.html#feat_7","text":"gui : add ColorSpace class","title":"Feat"},{"location":"changelog.html#v01390-2020-12-02","text":"","title":"v0.139.0 (2020-12-02)"},{"location":"changelog.html#feat_8","text":"FileInfo/Dir : fallback to pathlib.Path methods widgets : add Proxy/CommonStyle classes widgets : add Gesture classes core : add TemporaryDir class widgets : add WhatsThis class core : add ItemSelectionRange class FormLayout : add some more methods core : add ProcessEnvironment class gui : add StaticText class core : add PauseAnimation class","title":"Feat"},{"location":"changelog.html#v01380-2020-12-01","text":"","title":"v0.138.0 (2020-12-01)"},{"location":"changelog.html#feat_9","text":"core : add ChildEvent / TimerEvent classes core : add IdentityProxyModel class gui : add SessionManager class gui : add InputMethod class core : add AbstractEventDispatcher class widgets : add StackedWidget class widgets : add some events FileInfo : add some additional methods gui : add Vector3D class core : add MimeType / MimeDatabase classes core : add SaveFile class core : add SignalBlocker class core : add TimeLine class gui : add Bitmap class core : add RandomGenerator class FileDevice : add get_error method widgets : add Dial class widgets : add RubberBand class Wizard/WizardPage : add some more methods widgets : add GraphicsRotation / GraphicsScale classes widgets : add GraphicsTransform class widgets : add LCDNumber class widgets : add Scroller(Properties) classes core : add CommandLineParser/Option classes Pixmap : add some more methods gui : add Screen class Transform : add some more methods add Abstract/PlainTextTextDocumentLayout classes core : add BasicTimer class core : add Resource class core : add StorageInfo class core : add ElapsedTimer class core : add CryptographicHash class","title":"Feat"},{"location":"changelog.html#v01371-2020-11-27","text":"","title":"v0.137.1 (2020-11-27)"},{"location":"changelog.html#fix_11","text":"doc build fix","title":"Fix"},{"location":"changelog.html#v01370-2020-11-27","text":"","title":"v0.137.0 (2020-11-27)"},{"location":"changelog.html#feat_10","text":"core : add OperatingSystemVersion class PdfWriter : add set_page_margins method core : add MarginsF class core : Add TextStream class core : add ByteArrayMatcher AbstractItemModel : add check_index method PlaceManager : add search_place method core : add app method add bytes method to some classes utils : add Singleton metaclass icon : add add_pixmap method gui : Add PixmapCache Font : add some more methods","title":"Feat"},{"location":"changelog.html#v01360-2020-11-26","text":"","title":"v0.136.0 (2020-11-26)"},{"location":"changelog.html#feat_11","text":"location : add PlaceResult class location : add PlaceProposedSearchResult class location : add clone_from method to reply classes Object : add has_id method","title":"Feat"},{"location":"changelog.html#fix_12","text":"emit inputandslider signal correctly on value change correct flag for constants.NO_CHILDREN","title":"Fix"},{"location":"changelog.html#v01350-2020-11-26","text":"","title":"v0.135.0 (2020-11-26)"},{"location":"changelog.html#feat_12","text":"WebEngineHistoryItem : add get_icon_url method location : add PlaceMatchReply / PlaceIdReply classes PlaceContentReply/PlaceSearchReply : add request methods gui : add TextListFormat class gui : add TextImageFormat class location : add some reply/result classes gui : add TextTableCellFormat class gui : add app method gui : add TextFrameFormat class Application : add get_font method add qthelp module quick : add QuickPaintedItem class gui : add TextBlockGroup class TextCharFormat : add get/set_vertical_alignment methods TextBlock : add contains method PaintDevice : add get_metric method GuiApplication : add get/set_layout_direction methods gui : add TextObject / TextLength / TextFrame / TextFormat classes core : add ItemSelection class GraphicsLayout : add set_margin method","title":"Feat"},{"location":"changelog.html#fix_13","text":"correctly add items for GraphicsGridLayout","title":"Fix"},{"location":"changelog.html#v01340-2020-11-23","text":"","title":"v0.134.0 (2020-11-23)"},{"location":"changelog.html#feat_13","text":"core : add PersistentModelIndex class core : add PluginLoader class core : add Library class gui : add PainterPathStroker class gui : add ImageWriter / ImageReader / ImageIOHandler classes quick : add QuickItem / QuickWindow classes core : add install_message_handler method gui : add RasterWindow / PaintDeviceWindow / OpenGLWindow classes svg : add SvgGenerator class SplashScreen : allow pixmap for ctor icon : add get_available_sizes method widget : add set_attributes method gui : add Vector4D / Matrix4x4 classes custom_widgets : add StarDelegate class custom_delegates : add ProgressBarDelegate class widgets : add missing StyleOption classes WidgetItems : some more methods Painter : add backup_state contextmanager","title":"Feat"},{"location":"changelog.html#fix_14","text":"KeySequenceEdit : correct repr correct coloring for WaitingSpinner","title":"Fix"},{"location":"changelog.html#v01331-2020-11-16","text":"","title":"v0.133.1 (2020-11-16)"},{"location":"changelog.html#fix_15","text":"test fix","title":"Fix"},{"location":"changelog.html#v01330-2020-11-16","text":"","title":"v0.133.0 (2020-11-16)"},{"location":"changelog.html#feat_14","text":"ComboBox : default param for add_items AbstractItemModel : add force_reset/force_layoutchange methods add location module gui : add FontMetricsF class GeoCoordinate : add bool method FontMetrics : add get_(tight_)bounding_rect methods Url : add to_string method network : add LocalServer / TcpServer classes multimediawidgets : add GraphicsVideoItem class mediaobject : add get_availability method add qt module","title":"Feat"},{"location":"changelog.html#v01321-2020-11-07","text":"","title":"v0.132.1 (2020-11-07)"},{"location":"changelog.html#fix_16","text":"import fix","title":"Fix"},{"location":"changelog.html#v01320-2020-11-07","text":"","title":"v0.132.0 (2020-11-07)"},{"location":"changelog.html#feat_15","text":"NetworkAccessManager : allow str for request network : add UdpSocket network : add NetworkAddressEntry / NetworkInterface classes add texttospeech module network : add NetworkDatagram class core : add DeadlineTimer class network : add HostAddress/AbstractSocket/TcpSocket classes network : add NetworkProxy class network : add HttpMultiPart class network : add HttpPart class NetworkRequest : add set/get_header methods","title":"Feat"},{"location":"changelog.html#v01310-2020-11-04","text":"","title":"v0.131.0 (2020-11-04)"},{"location":"changelog.html#feat_16","text":"webenginecore : add WebEngineHttpRequest class webenginewidgets : add WebEngineContextMenuData class webenginewidgets : add WebEngineScriptCollection class multimedia : add CameraExposure/CameraImageProcessing classes multimedia : add CameraFocus(Zone) classes webenginecore : add WebEngineUrlSchemeHandler","title":"Feat"},{"location":"changelog.html#v01300-2020-11-04","text":"","title":"v0.130.0 (2020-11-04)"},{"location":"changelog.html#feat_17","text":"WebEnginePage : add some settings methods webenginewidgets : add WebEngineSettings class add bluetooth module core : add Uuid class add quick module gui : add Surface and Window class multimedia : add ImageEncoderSettings multimedia : add MediaTimeRange and MediaTimeInterval classes","title":"Feat"},{"location":"changelog.html#v01291-2020-10-29","text":"","title":"v0.129.1 (2020-10-29)"},{"location":"changelog.html#fix_17","text":"fix tests fix multimedia tests for Travis","title":"Fix"},{"location":"changelog.html#feat_18","text":"charts : add Legend class WebEnginePage : add get_history method qml : add JSValue(Iterator) class VideoWidget : option for fullscreen toggling via double click multimedia : add CameraViewFinderSettings multimedia : add VideoFrame class multimedia : add AbstractPlanarVideoBuffer class multimedia : add AbstractVideoBuffer class multimedia : add Camera class multimedia : add CameraInfo class gui : add Clipboard class multimedia : add AudioFormat class multimedia : add SoundEffect class charts : add PieSlice class charts : add BoxSet and CandlestickSet classes charts : add Axis-related classes charts : add BarSeries-related classes","title":"Feat"},{"location":"changelog.html#v01281-2020-10-25","text":"","title":"v0.128.1 (2020-10-25)"},{"location":"changelog.html#fix_18","text":"import fix","title":"Fix"},{"location":"changelog.html#v01280-2020-10-25","text":"","title":"v0.128.0 (2020-10-25)"},{"location":"changelog.html#feat_19","text":"custom_widgets : add ExpandableLine class ParallelAnimationGroup : add set_duration method charts : add Abstract/ValueAxis and PolarChart classes core : add SequentialAnimationGroup class AnimationGroup : allow slicing for indexing AnimationGroup : add add_property_animation method ChartView : add get/set_rubber_band methods Chart : add some more methods core : add Locale class core : add Margins class webenginewidgets : add some more modules","title":"Feat"},{"location":"changelog.html#fix_19","text":"Chart : properly inherit from GraphicsWidget","title":"Fix"},{"location":"changelog.html#v01271-2020-10-20","text":"","title":"v0.127.1 (2020-10-20)"},{"location":"changelog.html#fix_20","text":"fix tests","title":"Fix"},{"location":"changelog.html#v01270-2020-10-20","text":"","title":"v0.127.0 (2020-10-20)"},{"location":"changelog.html#fix_21","text":"always import correct bindings for winextras module Url : allow initializing without arg","title":"Fix"},{"location":"changelog.html#feat_20","text":"PainterPath : add set_fill_rule method PainterPath : add get_bounding_rect method GraphicsItem : add get_shape method MediaPlaylist : add get_media_url method start with webenginecore module core : add EventLoop class Widget : add get_font_info method custom_models : add PlaylistModel Translator : add get_file_path method add positioning module add some first QtQml classes core : add LibraryInfo class Application : add iter method Application : add get/set_navigation_mode methods Application : add get/is_effect_enabled methods custom_widgets : add Player class","title":"Feat"},{"location":"changelog.html#v01260-2020-10-08","text":"","title":"v0.126.0 (2020-10-08)"},{"location":"changelog.html#feat_21","text":"core : add Process class DateTime : add get/set_time_spec and get_date/time methods core : add Time class DateTime : add timezone methods core : add TimeZone class Pixmap : add create_dot classmethod","title":"Feat"},{"location":"changelog.html#v01251-2020-10-07","text":"","title":"v0.125.1 (2020-10-07)"},{"location":"changelog.html#fix_22","text":"import fix","title":"Fix"},{"location":"changelog.html#v01250-2020-10-07","text":"","title":"v0.125.0 (2020-10-07)"},{"location":"changelog.html#feat_22","text":"widgets : add Transition classes core : add Transition classes","title":"Feat"},{"location":"changelog.html#fix_23","text":"fix Action.get_shortcut for NoneValue","title":"Fix"},{"location":"changelog.html#v01240-2020-10-05","text":"","title":"v0.124.0 (2020-10-05)"},{"location":"changelog.html#feat_23","text":"IODevice : add get_open_mode method Improve repr and add str method for Date and DateTime core : add TemporaryFile class FileDevice : add set/get_file_time methods MainWindow : allow setting central widget to None AbstractButton : add get_shortcut method Url : add from_user_input method WebEngineView : add get_url method FileInfo : support pathlib + add proper repr KeySequence : allow initializing with standard keys","title":"Feat"},{"location":"changelog.html#v01231-2020-09-29","text":"","title":"v0.123.1 (2020-09-29)"},{"location":"changelog.html#fix_24","text":"add missing State import in core module","title":"Fix"},{"location":"changelog.html#v01230-2020-09-29","text":"","title":"v0.123.0 (2020-09-29)"},{"location":"changelog.html#feat_24","text":"core : add State classes core : add TextBoundaryFinder class ProgressBar : add get/set_orientation methods + serialize work Action : allow setting callback with ctor WebEngineView : set subclassed WebEnginePage by default WebEnginePage : add some more methods and constants AbstractSlider : add get/set_orientation methods core : add FileInfo class webenginewidgets : add WebEngineProfile class","title":"Feat"},{"location":"changelog.html#v01221-2020-09-27","text":"","title":"v0.122.1 (2020-09-27)"},{"location":"changelog.html#fix_25","text":"use correct icon names","title":"Fix"},{"location":"changelog.html#v01220-2020-09-27","text":"","title":"v0.122.0 (2020-09-27)"},{"location":"changelog.html#feat_25","text":"gui : add PageLayout gui : add Movie class gui : add PageSize class gui : add FontInfo class core : add UrlQuery class add network module PropertyAnimation : add get/set_property_name methods core : add ParallelAnimationGroup widgets : add SizeGrip class widgets : add DataWidgetMapper class core : add StringListModel VersionNumber : add get_python_version gui : add Transform class Painter : add draw_polygon method add core.ByteArray","title":"Feat"},{"location":"changelog.html#v01210-2020-09-10","text":"","title":"v0.121.0 (2020-09-10)"},{"location":"changelog.html#feat_26","text":"Image : add setitem / getitem methods Line/LineF : add reversed and abs methods GraphicsScene : add get/set_item_index_method method","title":"Feat"},{"location":"changelog.html#fix_26","text":"serialization fixes","title":"Fix"},{"location":"changelog.html#v01200-2020-08-27","text":"","title":"v0.120.0 (2020-08-27)"},{"location":"changelog.html#feat_27","text":"GraphicsWidget : add set_layout method GraphicsLayout : add some magic methods GraphicsScene : add add_item_group method widgets : add GraphicsAnchorLayout / GraphicsGridLayout / GraphicsLinearLayout widgets : add GraphicsItemGroup Layout : add delitem method Polygon/PolygonF : add repr and iter methods PainterPath : some additional methods GraphicsItems : add repr methods Line/LineF : add repr and iter Application : allow loading included language files via load_language_file widgets : add GraphicsView class","title":"Feat"},{"location":"changelog.html#refactor","text":"PromptLineEdit rework","title":"Refactor"},{"location":"changelog.html#v01191-2020-08-24","text":"","title":"v0.119.1 (2020-08-24)"},{"location":"changelog.html#fix_27","text":"add missing StyleOptionComplex class","title":"Fix"},{"location":"changelog.html#v01190-2020-08-24","text":"","title":"v0.119.0 (2020-08-24)"},{"location":"changelog.html#feat_28","text":"GraphicsScene : add some convenience methods widgets : add graphicsitem classes StylePainter : add draw_complex_control method gui : allow pickling some more classes core : add LineF class Widget : add get_palette() method widgets : add GraphicsPixmapItem / GraphicsScene GraphicsItem : add getitem and setitem methods widgets : add Blur/Colorize/DropShadowEffect","title":"Feat"},{"location":"changelog.html#fix_28","text":"Graphicsitem collides methods fix KeySequence : pickling","title":"Fix"},{"location":"changelog.html#v01182-2020-08-17","text":"","title":"v0.118.2 (2020-08-17)"},{"location":"changelog.html#fix_29","text":"Fix tests","title":"Fix"},{"location":"changelog.html#v01181-2020-08-17","text":"","title":"v0.118.1 (2020-08-17)"},{"location":"changelog.html#fix_30","text":"MenuBar : fix add method","title":"Fix"},{"location":"changelog.html#v01180-2020-08-17","text":"","title":"v0.118.0 (2020-08-17)"},{"location":"changelog.html#refactor_1","text":"MenuBar : return subclassed types instead of qt classes","title":"Refactor"},{"location":"changelog.html#feat_29","text":"gui : add TextDocument / TextBlock / TextOption gui : add ConicalGradient / RadialGradient custom_widgets : add CollapsibleFrame GraphicsItem : add some more methods","title":"Feat"},{"location":"changelog.html#v01170-2020-08-16","text":"","title":"v0.117.0 (2020-08-16)"},{"location":"changelog.html#feat_30","text":"MimeData : add dict-like interface Timer : add get/set_type methods File : add repr and str methods Dir : add repr and truediv methods Frame : set/get_frame_shape, set/get_frame_shadow Splitter : add setitem method, and some more typing Polygon/PolygonF : pythonize core : add Abstract/Variant/PropertyAnimation and AnimationGroup core : add EasingCurve StyleOptionSlider : add get_orientation method","title":"Feat"},{"location":"changelog.html#refactor_2","text":"SpanSlider : clean up code","title":"Refactor"},{"location":"changelog.html#v01160-2020-08-13","text":"","title":"v0.116.0 (2020-08-13)"},{"location":"changelog.html#feat_31","text":"gui : add LinearGradient AbstractSlider : add get/set_repeat_action and trigger_action methods TabWidget : add get/set_tab_position methods Image/Pixmap : add bool method MenuBar : serialize stuff MdiArea : serialize stuff Brush : allow pickling + add get_texture_image method custom_widgets : add Timeline Pen : add methods for setting and getting style / join style / cap style","title":"Feat"},{"location":"changelog.html#refactor_3","text":"Painter : rework set_pen / get_pen","title":"Refactor"},{"location":"changelog.html#v01150-2020-08-12","text":"","title":"v0.115.0 (2020-08-12)"},{"location":"changelog.html#feat_32","text":"Polygon : add add_points method Object : add store_widget_states / restore_widget_states Painter : add paint_on, set_transparent_background, set_brush PainterPath : add add_rect method Application : add class_getitem","title":"Feat"},{"location":"changelog.html#fix_31","text":"RegexEditor : correctly initialize dialog","title":"Fix"},{"location":"changelog.html#v01141-2020-08-12","text":"","title":"v0.114.1 (2020-08-12)"},{"location":"changelog.html#fix_32","text":"HeaderView : fix saving state","title":"Fix"},{"location":"changelog.html#v01140-2020-08-12","text":"","title":"v0.114.0 (2020-08-12)"},{"location":"changelog.html#refactor_4","text":"use AutoSlot decorator","title":"Refactor"},{"location":"changelog.html#feat_33","text":"add autoslot decorator add prettyqt.debug","title":"Feat"},{"location":"changelog.html#v01130-2020-08-10","text":"","title":"v0.113.0 (2020-08-10)"},{"location":"changelog.html#feat_34","text":"gui : add PainterPath class gui : add Polygon class gui : palette improvements core : add Line class core : add TransposeProxyModel / ConcatenateTablesProxyModel add ObjectBrowser widgets : add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect Action : \"checked\" param for ctor gui : some magic methods + get_matches for KeySequence core : allow pickling VersionNumber / Size / Dir gui : add Gradient class add ColumnItemModel / ColumnItem Settings : add set_values method Widget : spacing kwarg for set_layout","title":"Feat"},{"location":"changelog.html#refactor_5","text":"add serialization stuff improve some repr methods","title":"Refactor"},{"location":"changelog.html#v01120-2020-08-04","text":"","title":"v0.112.0 (2020-08-04)"},{"location":"changelog.html#feat_35","text":"utils : add install_exceptionhook method FileSystemModel : add some more shortcuts for set_root_path core : add VersionNumber class Application : add get_icon method MessageBox : add show_exception method","title":"Feat"},{"location":"changelog.html#refactor_6","text":"improve compat with older Qt Versions","title":"Refactor"},{"location":"changelog.html#fix_33","text":"another test fix","title":"Fix"},{"location":"changelog.html#v01111-2020-08-03","text":"","title":"v0.111.1 (2020-08-03)"},{"location":"changelog.html#fix_34","text":"fix tests for Linux","title":"Fix"},{"location":"changelog.html#v01110-2020-08-03","text":"","title":"v0.111.0 (2020-08-03)"},{"location":"changelog.html#feat_36","text":"widgets : add FontComboBox StandardPaths : add class_getitem method Action : some more ctor kwargs Action : add get/set_menu_role methods, some pickle work","title":"Feat"},{"location":"changelog.html#refactor_7","text":"custom Exception for wrong params","title":"Refactor"},{"location":"changelog.html#fix_35","text":"Menu : disable separator widgetAction","title":"Fix"},{"location":"changelog.html#v01102-2020-08-03","text":"","title":"v0.110.2 (2020-08-03)"},{"location":"changelog.html#fix_36","text":"fix broken LogTextEdit","title":"Fix"},{"location":"changelog.html#v01101-2020-08-03","text":"","title":"v0.110.1 (2020-08-03)"},{"location":"changelog.html#fix_37","text":"LogTextEdit : improve exception handling SidebarWidget : some fixes related to set_marker","title":"Fix"},{"location":"changelog.html#v01100-2020-08-02","text":"","title":"v0.110.0 (2020-08-02)"},{"location":"changelog.html#refactor_8","text":"improve serialization for listitems Validator pickle work","title":"Refactor"},{"location":"changelog.html#feat_37","text":"Image : allow pickling DataStream : add create_bytearray / write_bytearray / copy_data methods core : add DataStream class","title":"Feat"},{"location":"changelog.html#v01090-2020-08-02","text":"","title":"v0.109.0 (2020-08-02)"},{"location":"changelog.html#feat_38","text":"widget : add pretty method for devtools GridLayout : allow adding tuples/lists","title":"Feat"},{"location":"changelog.html#refactor_9","text":"rework widget pickling move CheckboxDelegate to custom_delegates pickle stuff for undocommand","title":"Refactor"},{"location":"changelog.html#v01080-2020-07-31","text":"","title":"v0.108.0 (2020-07-31)"},{"location":"changelog.html#feat_39","text":"custom_delegates : add IconDelegate and NoFocusDelegate TableWidet : add getitem and setitem methods Icon : add from_image method allow str for layout. getitem (uses objectName) SidebarWidget : add set_marker method","title":"Feat"},{"location":"changelog.html#refactor_10","text":"move delegates to separate module","title":"Refactor"},{"location":"changelog.html#v01070-2020-07-29","text":"","title":"v0.107.0 (2020-07-29)"},{"location":"changelog.html#feat_40","text":"GridLayout : also allow adding LayoutItems via add method","title":"Feat"},{"location":"changelog.html#v01061-2020-07-29","text":"","title":"v0.106.1 (2020-07-29)"},{"location":"changelog.html#fix_38","text":"TabWidget : correctly close detached tabs on app close pickle fixes for toolbar and dockwidget PygmentsHighlighter : catch pygments KeyError","title":"Fix"},{"location":"changelog.html#v01060-2020-07-26","text":"","title":"v0.106.0 (2020-07-26)"},{"location":"changelog.html#feat_41","text":"gui : add DesktopServices class multimedia : add AudioRecorder class core : add StandardPaths class widgets : add Undo classes","title":"Feat"},{"location":"changelog.html#v01050-2020-07-24","text":"","title":"v0.105.0 (2020-07-24)"},{"location":"changelog.html#feat_42","text":"MediaRecorder : some new methods sort_by_column for tableview and treeview multimedia : dict-setter and getter for encodersettings","title":"Feat"},{"location":"changelog.html#refactor_11","text":"improve Url-Pathlib interoperability","title":"Refactor"},{"location":"changelog.html#fix_39","text":"PopupInfo : use PrimaryScreen geometry instead of screens[0] for positioning","title":"Fix"},{"location":"changelog.html#v01040-2020-07-23","text":"","title":"v0.104.0 (2020-07-23)"},{"location":"changelog.html#feat_43","text":"multimedia : add MediaRecorder AbstractItemModel : add getitem method multimedia : add VideoEncoderSettings / AudioEncoderSettings","title":"Feat"},{"location":"changelog.html#refactor_12","text":"use subclassed core.Size","title":"Refactor"},{"location":"changelog.html#v01030-2020-07-22","text":"","title":"v0.103.0 (2020-07-22)"},{"location":"changelog.html#feat_44","text":"ActionGroup : add getitem method MediaContent : add get_url method add multimediawidgets module add multimedia module PlainTextEdit : add allow_wheel_zoom method Object : name kwarg for find_parent method","title":"Feat"},{"location":"changelog.html#v01020-2020-07-21","text":"","title":"v0.102.0 (2020-07-21)"},{"location":"changelog.html#refactor_13","text":"move raise_dock to from Widget to Object SidebarWidget : some code cleanup, make settings button size configurable Widget : default state to True for set_attribute MainWindow : add return value for load_window_state","title":"Refactor"},{"location":"changelog.html#feat_45","text":"Object : add find_parent method PlainTextEdit : add style kwarg to set_syntaxhighlighter","title":"Feat"},{"location":"changelog.html#v01011-2020-07-20","text":"","title":"v0.101.1 (2020-07-20)"},{"location":"changelog.html#fix_40","text":"LogTextEdit : better integrate with custom qstylesheets","title":"Fix"},{"location":"changelog.html#v01010-2020-07-20","text":"","title":"v0.101.0 (2020-07-20)"},{"location":"changelog.html#feat_46","text":"MessageBox : add detail_text keyword argument to message method","title":"Feat"},{"location":"changelog.html#fix_41","text":"correct return type for gui.icon.get_icon","title":"Fix"},{"location":"changelog.html#v01000-2020-07-20","text":"","title":"v0.100.0 (2020-07-20)"},{"location":"changelog.html#feat_47","text":"ToolTip : add show_text method GuiApplication : add set_override_cursor / restore_override_cursor methods GuiApplication : add override_cursor context manager","title":"Feat"},{"location":"changelog.html#v0990-2020-07-18","text":"","title":"v0.99.0 (2020-07-18)"},{"location":"changelog.html#refactor_14","text":"FileChooserButton : typing and fixes Dataset : typing and fixes SidebarWidget : use button map instead of attaching button to widget","title":"Refactor"},{"location":"changelog.html#feat_48","text":"AbstractItemView : add scroll_to method","title":"Feat"},{"location":"changelog.html#v0985-2020-07-17","text":"","title":"v0.98.5 (2020-07-17)"},{"location":"changelog.html#perf","text":"add icon cache","title":"Perf"},{"location":"changelog.html#refactor_15","text":"use core.Settings for windows dark mode detection","title":"Refactor"},{"location":"changelog.html#v0984-2020-07-15","text":"","title":"v0.98.4 (2020-07-15)"},{"location":"changelog.html#fix_42","text":"use qta default icon color instead of black for default","title":"Fix"},{"location":"changelog.html#v0983-2020-07-15","text":"","title":"v0.98.3 (2020-07-15)"},{"location":"changelog.html#refactor_16","text":"properly set stylesheets by using contextmanager FontDialog : do not override current_font contextmanager move current_font context manager to Widget class","title":"Refactor"},{"location":"changelog.html#v0982-2020-07-15","text":"","title":"v0.98.2 (2020-07-15)"},{"location":"changelog.html#fix_43","text":"package name","title":"Fix"},{"location":"changelog.html#v0981-2020-07-15","text":"","title":"v0.98.1 (2020-07-15)"},{"location":"changelog.html#fix_44","text":"correctly reset stylesheet for widget validation background","title":"Fix"},{"location":"changelog.html#refactor_17","text":"use qstylizer for stylesheet editing","title":"Refactor"},{"location":"changelog.html#v0980-2020-07-15","text":"","title":"v0.98.0 (2020-07-15)"},{"location":"changelog.html#feat_49","text":"widgets : add StyleFactory","title":"Feat"},{"location":"changelog.html#refactor_18","text":"FontDatabase : make add_fonts_from_folder a classmethod","title":"Refactor"},{"location":"changelog.html#v0970-2020-07-15","text":"","title":"v0.97.0 (2020-07-15)"},{"location":"changelog.html#feat_50","text":"gui : add FontDatabase widgets : add Completer widgets : add ActionGroup","title":"Feat"},{"location":"changelog.html#v0960-2020-07-14","text":"","title":"v0.96.0 (2020-07-14)"},{"location":"changelog.html#feat_51","text":"SelectionWidget : default keyword argument for add_custom","title":"Feat"},{"location":"changelog.html#v0950-2020-07-14","text":"","title":"v0.95.0 (2020-07-14)"},{"location":"changelog.html#feat_52","text":"SelectionWidget : different options for custom type add PagedPaintDevice Widget : add set_margin method","title":"Feat"},{"location":"changelog.html#v0940-2020-07-14","text":"","title":"v0.94.0 (2020-07-14)"},{"location":"changelog.html#feat_53","text":"Widget : add Widget.font_metrics() SpacerItem : allow strings for size policy in ctor allow Mapping for listwidget.add_items","title":"Feat"},{"location":"changelog.html#refactor_19","text":"change to {value: label} dicts for FlagSelectionWidget.add_items","title":"Refactor"},{"location":"changelog.html#v0931-2020-07-14","text":"","title":"v0.93.1 (2020-07-14)"},{"location":"changelog.html#refactor_20","text":"typecheck for Mapping instead of dict for combobox / selectionwidget add_items method","title":"Refactor"},{"location":"changelog.html#v0930-2020-07-14","text":"","title":"v0.93.0 (2020-07-14)"},{"location":"changelog.html#feat_54","text":"add register_extensions function to settings module","title":"Feat"},{"location":"changelog.html#refactor_21","text":"Settings : do not override value method","title":"Refactor"},{"location":"changelog.html#v0921-2020-07-14","text":"","title":"v0.92.1 (2020-07-14)"},{"location":"changelog.html#fix_45","text":"winextras test fix","title":"Fix"},{"location":"changelog.html#v0920-2020-07-14","text":"","title":"v0.92.0 (2020-07-14)"},{"location":"changelog.html#feat_55","text":"add widgets.SystemTrayIcon add winextras module Label : set_indent method","title":"Feat"},{"location":"changelog.html#v0910-2020-07-13","text":"","title":"v0.91.0 (2020-07-13)"},{"location":"changelog.html#feat_56","text":"SidebarWidget : allow choosing layout MainWindow : add show_blocking method","title":"Feat"},{"location":"changelog.html#v0900-2020-07-13","text":"","title":"v0.90.0 (2020-07-13)"},{"location":"changelog.html#feat_57","text":"Toolbar : allow combinations of allowed areas for set_allowed_areas SidebarWidget : add optional settings menu","title":"Feat"},{"location":"changelog.html#v0891-2020-07-13","text":"","title":"v0.89.1 (2020-07-13)"},{"location":"changelog.html#refactor_22","text":"SelectionWidget : switch to {data: label} dicts for add_items to be in line with RadioButton","title":"Refactor"},{"location":"changelog.html#v0890-2020-07-13","text":"","title":"v0.89.0 (2020-07-13)"},{"location":"changelog.html#feat_58","text":"SidebarWidget : make button width configurable","title":"Feat"},{"location":"changelog.html#v0881-2020-07-13","text":"","title":"v0.88.1 (2020-07-13)"},{"location":"changelog.html#refactor_23","text":"ComboBox : use set_data for set_value","title":"Refactor"},{"location":"changelog.html#fix_46","text":"ComboBox : fix add_items method","title":"Fix"},{"location":"changelog.html#v0880-2020-07-13","text":"","title":"v0.88.0 (2020-07-13)"},{"location":"changelog.html#feat_59","text":"ComboBox : set_data method","title":"Feat"},{"location":"changelog.html#v0870-2020-07-13","text":"","title":"v0.87.0 (2020-07-13)"},{"location":"changelog.html#feat_60","text":"ComboBox : allow dict for add_items","title":"Feat"},{"location":"changelog.html#v0863-2020-07-12","text":"","title":"v0.86.3 (2020-07-12)"},{"location":"changelog.html#refactor_24","text":"RegexEditor : code cleanup","title":"Refactor"},{"location":"changelog.html#v0862-2020-07-12","text":"","title":"v0.86.2 (2020-07-12)"},{"location":"changelog.html#fix_47","text":"another deployment fix","title":"Fix"},{"location":"changelog.html#v0861-2020-07-12","text":"","title":"v0.86.1 (2020-07-12)"},{"location":"changelog.html#fix_48","text":"deployment fix","title":"Fix"},{"location":"changelog.html#v0860-2020-07-12","text":"","title":"v0.86.0 (2020-07-12)"},{"location":"changelog.html#feat_61","text":"add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line","title":"Feat"},{"location":"changelog.html#v0851-2020-07-10","text":"","title":"v0.85.1 (2020-07-10)"},{"location":"changelog.html#fix_49","text":"add missing pygments requirement","title":"Fix"},{"location":"changelog.html#v0850-2020-07-10","text":"","title":"v0.85.0 (2020-07-10)"},{"location":"changelog.html#feat_62","text":"dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method","title":"Feat"},{"location":"changelog.html#refactor_25","text":"CodeEditor : use pygments for syntax highlighting","title":"Refactor"},{"location":"changelog.html#v0840-2020-07-10","text":"","title":"v0.84.0 (2020-07-10)"},{"location":"changelog.html#feat_63","text":"sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child","title":"Feat"},{"location":"changelog.html#v0831-2020-07-09","text":"","title":"v0.83.1 (2020-07-09)"},{"location":"changelog.html#refactor_26","text":"move set_icon from window classes to widget class","title":"Refactor"},{"location":"changelog.html#v0830-2020-07-09","text":"","title":"v0.83.0 (2020-07-09)"},{"location":"changelog.html#feat_64","text":"add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager","title":"Feat"},{"location":"changelog.html#v0820-2020-07-09","text":"","title":"v0.82.0 (2020-07-09)"},{"location":"changelog.html#feat_65","text":"add Label.set_bold / set_italic / set_weight added Font.set_weight","title":"Feat"},{"location":"changelog.html#v0810-2020-07-08","text":"","title":"v0.81.0 (2020-07-08)"},{"location":"changelog.html#feat_66","text":"allow setting window icon color os dark mode detection","title":"Feat"},{"location":"changelog.html#v0801-2020-07-08","text":"","title":"v0.80.1 (2020-07-08)"},{"location":"changelog.html#fix_50","text":"Settings.value() returned wrong type","title":"Fix"},{"location":"changelog.html#v0800-2020-07-08","text":"","title":"v0.80.0 (2020-07-08)"},{"location":"changelog.html#feat_67","text":"add Widget.set_attribute add margin keyword argument to Widget.set_layout","title":"Feat"},{"location":"changelog.html#v0791-2020-07-08","text":"","title":"v0.79.1 (2020-07-08)"},{"location":"changelog.html#fix_51","text":"remove Qt logger on Application exit","title":"Fix"},{"location":"changelog.html#v0790-2020-07-08","text":"","title":"v0.79.0 (2020-07-08)"},{"location":"changelog.html#feat_68","text":"add widgets.Application.get_widget","title":"Feat"},{"location":"changelog.html#v0780-2020-07-08","text":"","title":"v0.78.0 (2020-07-08)"},{"location":"changelog.html#feat_69","text":"allow to save/load window state recursively. Saving needs to be done explicitely now.","title":"Feat"},{"location":"changelog.html#fix_52","text":"some fixes for core.Settings dict interface properly preserve types in core.Settings","title":"Fix"},{"location":"changelog.html#v0771-2020-07-07","text":"","title":"v0.77.1 (2020-07-07)"},{"location":"changelog.html#refactor_27","text":"also allow qt flag for Splitter ctor","title":"Refactor"},{"location":"changelog.html#fix_53","text":"return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview","title":"Fix"},{"location":"changelog.html#0770-2020-07-06","text":"","title":"0.77.0 (2020-07-06)"},{"location":"changelog.html#feat_70","text":"allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages","title":"Feat"},{"location":"changelog.html#fix_54","text":"fix Messagebox.message call","title":"Fix"},{"location":"changelog.html#refactor_28","text":"dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars","title":"Refactor"},{"location":"contributing.html","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs ~~~~~~~~~~~ Report bugs at https://github.com/phil65/prettyqt/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs ~~~~~~~~ Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features ~~~~~~~~~~~~~~~~~~ Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ~~~~~~~~~~~~~~~~~~~ PrettyQt could always use more documentation, whether as part of the official PrettyQt docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback ~~~~~~~~~~~~~~~ The best way to send feedback is to file an issue at https://github.com/phil65/prettyqt/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! Ready to contribute? Here's how to set up prettyqt for local development. Fork the prettyqt repo on GitHub. Clone your fork locally:: $ git clone git@github.com:your_name_here/prettyqt.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:: $ mkvirtualenv prettyqt $ cd prettyqt/ $ python setup.py develop Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests: $ flake8 prettyqt tests $ py.test To install required development libraries, run \"pip install -r requirements_dev.txt\". Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6 - 3.8. Check https://travis-ci.org/phil65/prettyqt/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Contributing"},{"location":"contributing.html#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing.html#types-of-contributions","text":"Report Bugs ~~~~~~~~~~~ Report bugs at https://github.com/phil65/prettyqt/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs ~~~~~~~~ Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features ~~~~~~~~~~~~~~~~~~ Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ~~~~~~~~~~~~~~~~~~~ PrettyQt could always use more documentation, whether as part of the official PrettyQt docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback ~~~~~~~~~~~~~~~ The best way to send feedback is to file an issue at https://github.com/phil65/prettyqt/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Types of Contributions"},{"location":"contributing.html#get-started","text":"Ready to contribute? Here's how to set up prettyqt for local development. Fork the prettyqt repo on GitHub. Clone your fork locally:: $ git clone git@github.com:your_name_here/prettyqt.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:: $ mkvirtualenv prettyqt $ cd prettyqt/ $ python setup.py develop Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests: $ flake8 prettyqt tests $ py.test To install required development libraries, run \"pip install -r requirements_dev.txt\". Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing.html#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6 - 3.8. Check https://travis-ci.org/phil65/prettyqt/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"api/bluetooth.html","text":"bluetooth module bluetooth module. contains QtBluetooth-based classes bluetoothdevicediscoveryagent BluetoothDeviceDiscoveryAgent get_inquiry_type ( self ) Get the current inquiry type. Returns: Type Description Literal['unlimited', 'limited'] inquiry type Source code in prettyqt/bluetooth/bluetoothdevicediscoveryagent.py def get_inquiry_type ( self ) -> InquiryTypeStr : \"\"\"Get the current inquiry type. Returns: inquiry type \"\"\" return INQUIRY_TYPES . inverse [ self . inquiryType ()] set_inquiry_type ( self , typ ) Set inquiry type. Parameters: Name Type Description Default typ Literal['unlimited', 'limited'] inquiry type required Exceptions: Type Description InvalidParamError inquiry type does not exist Source code in prettyqt/bluetooth/bluetoothdevicediscoveryagent.py def set_inquiry_type ( self , typ : InquiryTypeStr ): \"\"\"Set inquiry type. Args: typ: inquiry type Raises: InvalidParamError: inquiry type does not exist \"\"\" if typ not in INQUIRY_TYPES : raise InvalidParamError ( typ , INQUIRY_TYPES ) self . setInquiryType ( INQUIRY_TYPES [ typ ])","title":"bluetooth"},{"location":"api/bluetooth.html#bluetooth-module","text":"","title":"bluetooth module"},{"location":"api/bluetooth.html#prettyqt.bluetooth","text":"bluetooth module. contains QtBluetooth-based classes","title":"prettyqt.bluetooth"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothdevicediscoveryagent","text":"","title":"bluetoothdevicediscoveryagent"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothdevicediscoveryagent.BluetoothDeviceDiscoveryAgent","text":"","title":"BluetoothDeviceDiscoveryAgent"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothdevicediscoveryagent.BluetoothDeviceDiscoveryAgent.get_inquiry_type","text":"Get the current inquiry type. Returns: Type Description Literal['unlimited', 'limited'] inquiry type Source code in prettyqt/bluetooth/bluetoothdevicediscoveryagent.py def get_inquiry_type ( self ) -> InquiryTypeStr : \"\"\"Get the current inquiry type. Returns: inquiry type \"\"\" return INQUIRY_TYPES . inverse [ self . inquiryType ()]","title":"get_inquiry_type()"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothdevicediscoveryagent.BluetoothDeviceDiscoveryAgent.set_inquiry_type","text":"Set inquiry type. Parameters: Name Type Description Default typ Literal['unlimited', 'limited'] inquiry type required Exceptions: Type Description InvalidParamError inquiry type does not exist Source code in prettyqt/bluetooth/bluetoothdevicediscoveryagent.py def set_inquiry_type ( self , typ : InquiryTypeStr ): \"\"\"Set inquiry type. Args: typ: inquiry type Raises: InvalidParamError: inquiry type does not exist \"\"\" if typ not in INQUIRY_TYPES : raise InvalidParamError ( typ , INQUIRY_TYPES ) self . setInquiryType ( INQUIRY_TYPES [ typ ])","title":"set_inquiry_type()"},{"location":"api/charts.html","text":"charts module Charts module. abstractaxis AbstractAxis get_alignment ( self ) Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description Optional[str] alignment Source code in prettyqt/charts/abstractaxis.py def get_alignment ( self ) -> Optional [ str ]: \"\"\"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" alignment = self . alignment () if int ( alignment ) == 0 : return None return ALIGNMENTS . inverse [ alignment ] get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description Optional[str] orientation Source code in prettyqt/charts/abstractaxis.py def get_orientation ( self ) -> Optional [ str ]: \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" orientation = self . orientation () if int ( orientation ) == 0 : return None return ORIENTATIONS . inverse [ orientation ] abstractbarseries AbstractBarSeries get_labels_position ( self ) Return current labels position. Possible values: \"center\", \"inside_end\", \"inside_base\", \"outside_end\" Returns: Type Description str labels position Source code in prettyqt/charts/abstractbarseries.py def get_labels_position ( self ) -> str : \"\"\"Return current labels position. Possible values: \"center\", \"inside_end\", \"inside_base\", \"outside_end\" Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()] set_labels_position ( self , position ) Set the labels position. Allowed values are \"center\", \"inside_end\", \"inside_base\", \"outside_end\" Parameters: Name Type Description Default position str labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/abstractbarseries.py def set_labels_position ( self , position : str ): \"\"\"Set the labels position. Allowed values are \"center\", \"inside_end\", \"inside_base\", \"outside_end\" Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ]) abstractseries AbstractSeries QAbstractSeries with some custom properties. categoryaxis CategoryAxis get_labels_position ( self ) Return current labels position. Possible values: \"center\", \"on_value\" Returns: Type Description str labels position Source code in prettyqt/charts/categoryaxis.py def get_labels_position ( self ) -> str : \"\"\"Return current labels position. Possible values: \"center\", \"on_value\" Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()] set_labels_position ( self , position ) Set the labels position. Allowed values are \"center\", \"on_value\" Parameters: Name Type Description Default position str labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/categoryaxis.py def set_labels_position ( self , position : str ): \"\"\"Set the labels position. Allowed values are \"center\", \"on_value\" Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ]) chart Chart apply_nice_numbers ( self ) Adjust both axis to display nice round numbers. Source code in prettyqt/charts/chart.py def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers () update_boundaries ( self ) Set new min/max values based on axis. Source code in prettyqt/charts/chart.py def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min () zoom_by_factor ( self , factor ) Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y )) chartview ChartView get_rubber_band ( self ) Return current rubber band type. Returns: Type Description Literal['none', 'vertical', 'horizontal', 'rectangle'] Rubber band type Source code in prettyqt/charts/chartview.py def get_rubber_band ( self ) -> RubberBandStr : \"\"\"Return current rubber band type. Returns: Rubber band type \"\"\" return RUBBER_BAND . inverse [ self . rubberBand ()] keyPressEvent ( self , event ) Handle keypress events to allow navigation via keyboard. Source code in prettyqt/charts/chartview.py def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_0 : self . chart () . apply_nice_numbers () else : return super () . keyPressEvent ( event ) event . accept () mouseMoveEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . RightButton : if not self . last_mouse_pos : return None pos_diff = event . pos () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . pos () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event ) mousePressEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : cursor = gui . Cursor ( QtCore . Qt . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . pos () event . accept () super () . mousePressEvent ( event ) mouseReleaseEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return None super () . mouseReleaseEvent ( event ) save_as_image ( self ) Let user choose folder and save chart as an image file. Source code in prettyqt/charts/chartview.py @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return None self . chart () . show_legend () image = self . get_image () image . save ( filename [ 0 ]) self . chart () . hide_legend () set_rubber_band ( self , typ ) Set the rubber band type. Parameters: Name Type Description Default typ Literal['none', 'vertical', 'horizontal', 'rectangle'] rubber band type required Exceptions: Type Description InvalidParamError rubber band type does not exist Source code in prettyqt/charts/chartview.py def set_rubber_band ( self , typ : RubberBandStr ): \"\"\"Set the rubber band type. Args: typ: rubber band type Raises: InvalidParamError: rubber band type does not exist \"\"\" if typ not in RUBBER_BAND : raise InvalidParamError ( typ , RUBBER_BAND ) self . setRubberBand ( RUBBER_BAND [ typ ]) wheelEvent ( self , event ) Handle wheel event for zooming. Source code in prettyqt/charts/chartview.py def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct ) legend Legend get_alignment ( self ) Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description str alignment Source code in prettyqt/charts/legend.py def get_alignment ( self ) -> str : \"\"\"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" return ALIGNMENTS . inverse [ self . alignment ()] get_marker_shape ( self ) Return current marker shape. Possible values are \"default\", \"rectangle\", \"circle\", \"from_series\" Returns: Type Description str Marker shape Source code in prettyqt/charts/legend.py def get_marker_shape ( self ) -> str : \"\"\"Return current marker shape. Possible values are \"default\", \"rectangle\", \"circle\", \"from_series\" Returns: Marker shape \"\"\" return MARKER_SHAPES . inverse [ self . markerShape ()] set_alignment ( self , alignment ) Set the alignment of the legend. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the legend required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/charts/legend.py def set_alignment ( self , alignment : str ): \"\"\"Set the alignment of the legend. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the legend Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) self . setAlignment ( ALIGNMENTS [ alignment ]) set_marker_shape ( self , shape ) Set the marker shape. Allowed values are \"default\", \"rectangle\", \"circle\", \"from_series\" Parameters: Name Type Description Default shape str marker shape required Exceptions: Type Description InvalidParamError marker shape does not exist Source code in prettyqt/charts/legend.py def set_marker_shape ( self , shape : str ): \"\"\"Set the marker shape. Allowed values are \"default\", \"rectangle\", \"circle\", \"from_series\" Args: shape: marker shape Raises: InvalidParamError: marker shape does not exist \"\"\" if shape not in MARKER_SHAPES : raise InvalidParamError ( shape , MARKER_SHAPES ) self . setMarkerShape ( MARKER_SHAPES [ shape ]) lineseries LineSeries QLineSeries with some custom properties. pieslice PieSlice get_label_position ( self ) Return current label position. Returns: Type Description Literal['outside', 'inside_horizontal', 'inside_tangential', 'inside_normal'] label position Source code in prettyqt/charts/pieslice.py def get_label_position ( self ) -> LabelPositionStr : \"\"\"Return current label position. Returns: label position \"\"\" return LABEL_POSITION . inverse [ self . labelPosition ()] set_label_position ( self , position ) Set the label position. Parameters: Name Type Description Default position Literal['outside', 'inside_horizontal', 'inside_tangential', 'inside_normal'] label position required Exceptions: Type Description InvalidParamError label position does not exist Source code in prettyqt/charts/pieslice.py def set_label_position ( self , position : LabelPositionStr ): \"\"\"Set the label position. Args: position: label position Raises: InvalidParamError: label position does not exist \"\"\" if position not in LABEL_POSITION : raise InvalidParamError ( position , LABEL_POSITION ) self . setLabelPosition ( LABEL_POSITION [ position ]) valueaxis ValueAxis get_tick_type ( self ) Return current tick type. Possible values: \"dynamic\", \"fixed\" Returns: Type Description str tick_type Source code in prettyqt/charts/valueaxis.py def get_tick_type ( self ) -> str : \"\"\"Return current tick type. Possible values: \"dynamic\", \"fixed\" Returns: tick_type \"\"\" return TICK_TYPES . inverse [ self . tickType ()] set_tick_type ( self , tick_type ) Set the tick type of the legend. Allowed values are \"dynamic\", \"fixed\" Parameters: Name Type Description Default tick_type str tick type for the legend required Exceptions: Type Description InvalidParamError tick type does not exist Source code in prettyqt/charts/valueaxis.py def set_tick_type ( self , tick_type : str ): \"\"\"Set the tick type of the legend. Allowed values are \"dynamic\", \"fixed\" Args: tick_type: tick type for the legend Raises: InvalidParamError: tick type does not exist \"\"\" if tick_type not in TICK_TYPES : raise InvalidParamError ( tick_type , TICK_TYPES ) self . setTickType ( TICK_TYPES [ tick_type ]) xyseries XYSeries QXYSeries with some custom properties.","title":"charts"},{"location":"api/charts.html#charts-module","text":"","title":"charts module"},{"location":"api/charts.html#prettyqt.charts","text":"Charts module.","title":"prettyqt.charts"},{"location":"api/charts.html#prettyqt.charts.abstractaxis","text":"","title":"abstractaxis"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxis","text":"","title":"AbstractAxis"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxis.get_alignment","text":"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description Optional[str] alignment Source code in prettyqt/charts/abstractaxis.py def get_alignment ( self ) -> Optional [ str ]: \"\"\"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" alignment = self . alignment () if int ( alignment ) == 0 : return None return ALIGNMENTS . inverse [ alignment ]","title":"get_alignment()"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxis.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description Optional[str] orientation Source code in prettyqt/charts/abstractaxis.py def get_orientation ( self ) -> Optional [ str ]: \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" orientation = self . orientation () if int ( orientation ) == 0 : return None return ORIENTATIONS . inverse [ orientation ]","title":"get_orientation()"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries","text":"","title":"abstractbarseries"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeries","text":"","title":"AbstractBarSeries"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeries.get_labels_position","text":"Return current labels position. Possible values: \"center\", \"inside_end\", \"inside_base\", \"outside_end\" Returns: Type Description str labels position Source code in prettyqt/charts/abstractbarseries.py def get_labels_position ( self ) -> str : \"\"\"Return current labels position. Possible values: \"center\", \"inside_end\", \"inside_base\", \"outside_end\" Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()]","title":"get_labels_position()"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeries.set_labels_position","text":"Set the labels position. Allowed values are \"center\", \"inside_end\", \"inside_base\", \"outside_end\" Parameters: Name Type Description Default position str labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/abstractbarseries.py def set_labels_position ( self , position : str ): \"\"\"Set the labels position. Allowed values are \"center\", \"inside_end\", \"inside_base\", \"outside_end\" Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ])","title":"set_labels_position()"},{"location":"api/charts.html#prettyqt.charts.abstractseries","text":"","title":"abstractseries"},{"location":"api/charts.html#prettyqt.charts.abstractseries.AbstractSeries","text":"QAbstractSeries with some custom properties.","title":"AbstractSeries"},{"location":"api/charts.html#prettyqt.charts.categoryaxis","text":"","title":"categoryaxis"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis","text":"","title":"CategoryAxis"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.get_labels_position","text":"Return current labels position. Possible values: \"center\", \"on_value\" Returns: Type Description str labels position Source code in prettyqt/charts/categoryaxis.py def get_labels_position ( self ) -> str : \"\"\"Return current labels position. Possible values: \"center\", \"on_value\" Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()]","title":"get_labels_position()"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.set_labels_position","text":"Set the labels position. Allowed values are \"center\", \"on_value\" Parameters: Name Type Description Default position str labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/categoryaxis.py def set_labels_position ( self , position : str ): \"\"\"Set the labels position. Allowed values are \"center\", \"on_value\" Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ])","title":"set_labels_position()"},{"location":"api/charts.html#prettyqt.charts.chart","text":"","title":"chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart","text":"","title":"Chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.apply_nice_numbers","text":"Adjust both axis to display nice round numbers. Source code in prettyqt/charts/chart.py def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers ()","title":"apply_nice_numbers()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.update_boundaries","text":"Set new min/max values based on axis. Source code in prettyqt/charts/chart.py def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min ()","title":"update_boundaries()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.zoom_by_factor","text":"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y ))","title":"zoom_by_factor()"},{"location":"api/charts.html#prettyqt.charts.chartview","text":"","title":"chartview"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView","text":"","title":"ChartView"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.get_rubber_band","text":"Return current rubber band type. Returns: Type Description Literal['none', 'vertical', 'horizontal', 'rectangle'] Rubber band type Source code in prettyqt/charts/chartview.py def get_rubber_band ( self ) -> RubberBandStr : \"\"\"Return current rubber band type. Returns: Rubber band type \"\"\" return RUBBER_BAND . inverse [ self . rubberBand ()]","title":"get_rubber_band()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.keyPressEvent","text":"Handle keypress events to allow navigation via keyboard. Source code in prettyqt/charts/chartview.py def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_0 : self . chart () . apply_nice_numbers () else : return super () . keyPressEvent ( event ) event . accept ()","title":"keyPressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseMoveEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . RightButton : if not self . last_mouse_pos : return None pos_diff = event . pos () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . pos () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event )","title":"mouseMoveEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mousePressEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : cursor = gui . Cursor ( QtCore . Qt . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . pos () event . accept () super () . mousePressEvent ( event )","title":"mousePressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseReleaseEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return None super () . mouseReleaseEvent ( event )","title":"mouseReleaseEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.save_as_image","text":"Let user choose folder and save chart as an image file. Source code in prettyqt/charts/chartview.py @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return None self . chart () . show_legend () image = self . get_image () image . save ( filename [ 0 ]) self . chart () . hide_legend ()","title":"save_as_image()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.set_rubber_band","text":"Set the rubber band type. Parameters: Name Type Description Default typ Literal['none', 'vertical', 'horizontal', 'rectangle'] rubber band type required Exceptions: Type Description InvalidParamError rubber band type does not exist Source code in prettyqt/charts/chartview.py def set_rubber_band ( self , typ : RubberBandStr ): \"\"\"Set the rubber band type. Args: typ: rubber band type Raises: InvalidParamError: rubber band type does not exist \"\"\" if typ not in RUBBER_BAND : raise InvalidParamError ( typ , RUBBER_BAND ) self . setRubberBand ( RUBBER_BAND [ typ ])","title":"set_rubber_band()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.wheelEvent","text":"Handle wheel event for zooming. Source code in prettyqt/charts/chartview.py def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct )","title":"wheelEvent()"},{"location":"api/charts.html#prettyqt.charts.legend","text":"","title":"legend"},{"location":"api/charts.html#prettyqt.charts.legend.Legend","text":"","title":"Legend"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_alignment","text":"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description str alignment Source code in prettyqt/charts/legend.py def get_alignment ( self ) -> str : \"\"\"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" return ALIGNMENTS . inverse [ self . alignment ()]","title":"get_alignment()"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_marker_shape","text":"Return current marker shape. Possible values are \"default\", \"rectangle\", \"circle\", \"from_series\" Returns: Type Description str Marker shape Source code in prettyqt/charts/legend.py def get_marker_shape ( self ) -> str : \"\"\"Return current marker shape. Possible values are \"default\", \"rectangle\", \"circle\", \"from_series\" Returns: Marker shape \"\"\" return MARKER_SHAPES . inverse [ self . markerShape ()]","title":"get_marker_shape()"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_alignment","text":"Set the alignment of the legend. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the legend required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/charts/legend.py def set_alignment ( self , alignment : str ): \"\"\"Set the alignment of the legend. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the legend Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) self . setAlignment ( ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_marker_shape","text":"Set the marker shape. Allowed values are \"default\", \"rectangle\", \"circle\", \"from_series\" Parameters: Name Type Description Default shape str marker shape required Exceptions: Type Description InvalidParamError marker shape does not exist Source code in prettyqt/charts/legend.py def set_marker_shape ( self , shape : str ): \"\"\"Set the marker shape. Allowed values are \"default\", \"rectangle\", \"circle\", \"from_series\" Args: shape: marker shape Raises: InvalidParamError: marker shape does not exist \"\"\" if shape not in MARKER_SHAPES : raise InvalidParamError ( shape , MARKER_SHAPES ) self . setMarkerShape ( MARKER_SHAPES [ shape ])","title":"set_marker_shape()"},{"location":"api/charts.html#prettyqt.charts.lineseries","text":"","title":"lineseries"},{"location":"api/charts.html#prettyqt.charts.lineseries.LineSeries","text":"QLineSeries with some custom properties.","title":"LineSeries"},{"location":"api/charts.html#prettyqt.charts.pieslice","text":"","title":"pieslice"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice","text":"","title":"PieSlice"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.get_label_position","text":"Return current label position. Returns: Type Description Literal['outside', 'inside_horizontal', 'inside_tangential', 'inside_normal'] label position Source code in prettyqt/charts/pieslice.py def get_label_position ( self ) -> LabelPositionStr : \"\"\"Return current label position. Returns: label position \"\"\" return LABEL_POSITION . inverse [ self . labelPosition ()]","title":"get_label_position()"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.set_label_position","text":"Set the label position. Parameters: Name Type Description Default position Literal['outside', 'inside_horizontal', 'inside_tangential', 'inside_normal'] label position required Exceptions: Type Description InvalidParamError label position does not exist Source code in prettyqt/charts/pieslice.py def set_label_position ( self , position : LabelPositionStr ): \"\"\"Set the label position. Args: position: label position Raises: InvalidParamError: label position does not exist \"\"\" if position not in LABEL_POSITION : raise InvalidParamError ( position , LABEL_POSITION ) self . setLabelPosition ( LABEL_POSITION [ position ])","title":"set_label_position()"},{"location":"api/charts.html#prettyqt.charts.valueaxis","text":"","title":"valueaxis"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxis","text":"","title":"ValueAxis"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxis.get_tick_type","text":"Return current tick type. Possible values: \"dynamic\", \"fixed\" Returns: Type Description str tick_type Source code in prettyqt/charts/valueaxis.py def get_tick_type ( self ) -> str : \"\"\"Return current tick type. Possible values: \"dynamic\", \"fixed\" Returns: tick_type \"\"\" return TICK_TYPES . inverse [ self . tickType ()]","title":"get_tick_type()"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxis.set_tick_type","text":"Set the tick type of the legend. Allowed values are \"dynamic\", \"fixed\" Parameters: Name Type Description Default tick_type str tick type for the legend required Exceptions: Type Description InvalidParamError tick type does not exist Source code in prettyqt/charts/valueaxis.py def set_tick_type ( self , tick_type : str ): \"\"\"Set the tick type of the legend. Allowed values are \"dynamic\", \"fixed\" Args: tick_type: tick type for the legend Raises: InvalidParamError: tick type does not exist \"\"\" if tick_type not in TICK_TYPES : raise InvalidParamError ( tick_type , TICK_TYPES ) self . setTickType ( TICK_TYPES [ tick_type ])","title":"set_tick_type()"},{"location":"api/charts.html#prettyqt.charts.xyseries","text":"","title":"xyseries"},{"location":"api/charts.html#prettyqt.charts.xyseries.XYSeries","text":"QXYSeries with some custom properties.","title":"XYSeries"},{"location":"api/constants.html","text":"constants module Constants module.","title":"constants"},{"location":"api/constants.html#constants-module","text":"","title":"constants module"},{"location":"api/constants.html#prettyqt.constants","text":"Constants module.","title":"prettyqt.constants"},{"location":"api/core.html","text":"core module Core module. Contains QtCore-based classes abstractanimation AbstractAnimation get_direction ( self ) Get the current animation direction. Possible values: \"forward\", \"backward\" Returns: Type Description Literal['forward', 'backward'] animation direction Source code in prettyqt/core/abstractanimation.py def get_direction ( self ) -> DirectionStr : \"\"\"Get the current animation direction. Possible values: \"forward\", \"backward\" Returns: animation direction \"\"\" return DIRECTION . inverse [ self . direction ()] get_state ( self ) Get the current animation state. Possible values: \"stopped\", \"paused\", \"running\" Returns: Type Description Literal['stopped', 'paused', 'running'] animation state Source code in prettyqt/core/abstractanimation.py def get_state ( self ) -> StateStr : \"\"\"Get the current animation state. Possible values: \"stopped\", \"paused\", \"running\" Returns: animation state \"\"\" return STATE . inverse [ self . state ()] set_direction ( self , direction ) Set animation direction. Valid values: \"forward\", \"backward\" Parameters: Name Type Description Default direction Literal['forward', 'backward'] animation direction required Exceptions: Type Description InvalidParamError animation direction does not exist Source code in prettyqt/core/abstractanimation.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set animation direction. Valid values: \"forward\", \"backward\" Args: direction: animation direction Raises: InvalidParamError: animation direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) start_animation ( self , policy ) Start the animation. Valid values for policy: \"keep\", \"delete\" Parameters: Name Type Description Default policy Literal['keep', 'delete'] animation policy required Exceptions: Type Description InvalidParamError animation policy does not exist Source code in prettyqt/core/abstractanimation.py def start_animation ( self , policy : DeletionPolicyStr ): \"\"\"Start the animation. Valid values for policy: \"keep\", \"delete\" Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" if policy not in DELETION_POLICY : raise InvalidParamError ( policy , DELETION_POLICY ) self . start ( DELETION_POLICY [ policy ]) abstractitemmodel AbstractItemModel __len__ ( self ) special Return amount of rows. Source code in prettyqt/core/abstractitemmodel.py def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount () change_layout ( self ) Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit () reset_model ( self ) Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel () abstracttransition AbstractTransition get_transition_type ( self ) Return current transition type. Returns: Type Description Literal['exclusive', 'parallel'] transition type Source code in prettyqt/core/abstracttransition.py def get_transition_type ( self ) -> TransitionTypeStr : \"\"\"Return current transition type. Returns: transition type \"\"\" return TRANSITION_TYPE . inverse [ self . transitionType ()] set_transition_type ( self , typ ) Set transition type. Parameters: Name Type Description Default typ Literal['exclusive', 'parallel'] transition type to use required Exceptions: Type Description InvalidParamError transition type does not exist Source code in prettyqt/core/abstracttransition.py def set_transition_type ( self , typ : TransitionTypeStr ): \"\"\"Set transition type. Args: typ: transition type to use Raises: InvalidParamError: transition type does not exist \"\"\" if typ not in TRANSITION_TYPE : raise InvalidParamError ( typ , TRANSITION_TYPE ) self . setTransitionType ( TRANSITION_TYPE [ typ ]) bytearray ByteArray __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/bytearray.py def __reduce__ ( self ): return self . __class__ , ( bytes ( self ),) collator Collator is_case_sensitive ( self ) Return case sensitivity. Returns: Type Description bool case sensitivity Source code in prettyqt/core/collator.py def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ()) set_case_sensitive ( self , state ) Set case sensitivity. Parameters: Name Type Description Default state bool case sensitive required Source code in prettyqt/core/collator.py def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = QtCore . Qt . CaseSensitive if state else QtCore . Qt . CaseInsensitive self . setCaseSensitivity ( sensitivity ) commandlineparser CommandLineParser set_options_after_positional_arguments_mode ( self , mode ) Set the options after positional arguments mode. Parameters: Name Type Description Default mode Literal['compacted_short', 'long'] options after positional arguments mode required Exceptions: Type Description InvalidParamError options after positional arguments mode does not exist Source code in prettyqt/core/commandlineparser.py def set_options_after_positional_arguments_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the options after positional arguments mode. Args: mode: options after positional arguments mode Raises: InvalidParamError: options after positional arguments mode does not exist \"\"\" if mode not in OPTIONS_AFTER_POS_ARG : raise InvalidParamError ( mode , OPTIONS_AFTER_POS_ARG ) self . setOptionsAfterPositionalArgumentsMode ( OPTIONS_AFTER_POS_ARG [ mode ]) set_single_dash_word_option_mode ( self , mode ) Set the single dash word option mode. Parameters: Name Type Description Default mode Literal['compacted_short', 'long'] single dash word option mode required Exceptions: Type Description InvalidParamError single dash word option mode does not exist Source code in prettyqt/core/commandlineparser.py def set_single_dash_word_option_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the single dash word option mode. Args: mode: single dash word option mode Raises: InvalidParamError: single dash word option mode does not exist \"\"\" if mode not in SINGLE_DASH_WORD : raise InvalidParamError ( mode , SINGLE_DASH_WORD ) self . setSingleDashWordOptionMode ( SINGLE_DASH_WORD [ mode ]) datastream DataStream get_byte_order ( self ) Return byte order. Returns: Type Description Literal['big_endian', 'little_endian'] byte order Source code in prettyqt/core/datastream.py def get_byte_order ( self ) -> ByteOrderStr : \"\"\"Return byte order. Returns: byte order \"\"\" return BYTE_ORDER . inverse [ self . byteOrder ()] get_float_precision ( self ) Return floating point precision. Returns: Type Description Literal['single', 'double'] floating point precision Source code in prettyqt/core/datastream.py def get_float_precision ( self ) -> FloatPrecisionStr : \"\"\"Return floating point precision. Returns: floating point precision \"\"\" return FLOAT_PRECISION . inverse [ self . floatingPointPrecision ()] set_byte_order ( self , order ) Set byte order. Parameters: Name Type Description Default order Literal['big_endian', 'little_endian'] byte order to use required Exceptions: Type Description InvalidParamError invalid order Source code in prettyqt/core/datastream.py def set_byte_order ( self , order : ByteOrderStr ): \"\"\"Set byte order. Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ]) set_float_precision ( self , precision ) Set floating point precision. Parameters: Name Type Description Default precision Literal['single', 'double'] floating point precision required Exceptions: Type Description InvalidParamError invalid precision Source code in prettyqt/core/datastream.py def set_float_precision ( self , precision : FloatPrecisionStr ): \"\"\"Set floating point precision. Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOAT_PRECISION : raise InvalidParamError ( precision , FLOAT_PRECISION ) self . setFloatingPointPrecision ( FLOAT_PRECISION [ precision ]) date Date __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/date.py def __reduce__ ( self ): return self . __class__ , ( self . year (), self . month (), self . day ()) datetime DateTime __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/datetime.py def __reduce__ ( self ): return self . __class__ , ( self . date (), self . time ()) get_time_spec ( self ) Return current time specification. Returns: Type Description Literal['local_time', 'utc', 'offset_from_utc', 'timezone'] time specification Source code in prettyqt/core/datetime.py def get_time_spec ( self ) -> TimeSpecStr : \"\"\"Return current time specification. Returns: time specification \"\"\" return TIME_SPEC . inverse [ self . timeSpec ()] set_time_spec ( self , spec ) Set the time specification. Parameters: Name Type Description Default spec Literal['local_time', 'utc', 'offset_from_utc', 'timezone'] time specification to use required Exceptions: Type Description InvalidParamError time specification does not exist Source code in prettyqt/core/datetime.py def set_time_spec ( self , spec : TimeSpecStr ): \"\"\"Set the time specification. Args: spec: time specification to use Raises: InvalidParamError: time specification does not exist \"\"\" if spec not in TIME_SPEC : raise InvalidParamError ( spec , TIME_SPEC ) self . setTimeSpec ( TIME_SPEC [ spec ]) deadlinetimer DeadlineTimer get_type ( self ) Return current timer type. Possible values: \"precise\", \"coarse\", \"very_coarse\" Returns: Type Description Literal['precise', 'coarse', 'very_coarse'] timer type Source code in prettyqt/core/deadlinetimer.py def get_type ( self ) -> TypeStr : \"\"\"Return current timer type. Possible values: \"precise\", \"coarse\", \"very_coarse\" Returns: timer type \"\"\" return TYPE . inverse [ self . timerType ()] set_type ( self , typ ) Set the timer type. Allowed values are \"precise\", \"coarse\", \"very_coarse\" Parameters: Name Type Description Default typ Literal['precise', 'coarse', 'very_coarse'] timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/deadlinetimer.py def set_type ( self , typ : TypeStr ): \"\"\"Set the timer type. Allowed values are \"precise\", \"coarse\", \"very_coarse\" Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setTimerType ( TYPE [ typ ]) easingcurve EasingCurve get_type ( self ) Get the current easing curve type. Returns: Type Description Literal['linear', 'in_quad', 'out_quad', 'in_out_quad', 'out_in_quad', 'in_cubic', 'out_cubic', 'in_out_cubic', 'out_in_cubic', 'in_quart', 'out_quart', 'in_out_quart', 'out_in_quart', 'in_quint', 'out_quint', 'in_out_quint', 'out_in_quint', 'in_sine', 'out_sine', 'in_out_sine', 'out_in_sine', 'in_expo', 'out_expo', 'in_out_expo', 'out_in_expo', 'in_circ', 'out_circ', 'in_out_circ', 'out_in_circ', 'in_elastic', 'out_elastic', 'in_out_elastic', 'out_in_elastic', 'in_back', 'out_back', 'in_out_back', 'out_in_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'out_in_bounce', 'bezier_spline', 'tcb_spline', 'custom'] easing curve type Source code in prettyqt/core/easingcurve.py def get_type ( self ) -> TypeStr : \"\"\"Get the current easing curve type. Returns: easing curve type \"\"\" return TYPE . inverse [ self . type ()] set_type ( self , typ ) Set easing curve type. Parameters: Name Type Description Default typ Literal['linear', 'in_quad', 'out_quad', 'in_out_quad', 'out_in_quad', 'in_cubic', 'out_cubic', 'in_out_cubic', 'out_in_cubic', 'in_quart', 'out_quart', 'in_out_quart', 'out_in_quart', 'in_quint', 'out_quint', 'in_out_quint', 'out_in_quint', 'in_sine', 'out_sine', 'in_out_sine', 'out_in_sine', 'in_expo', 'out_expo', 'in_out_expo', 'out_in_expo', 'in_circ', 'out_circ', 'in_out_circ', 'out_in_circ', 'in_elastic', 'out_elastic', 'in_out_elastic', 'out_in_elastic', 'in_back', 'out_back', 'in_out_back', 'out_in_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'out_in_bounce', 'bezier_spline', 'tcb_spline', 'custom'] easing curve type required Exceptions: Type Description InvalidParamError easing curve type does not exist Source code in prettyqt/core/easingcurve.py def set_type ( self , typ : TypeStr ): \"\"\"Set easing curve type. Args: typ: easing curve type Raises: InvalidParamError: easing curve type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setType ( TYPE [ typ ]) elapsedtimer ElapsedTimer get_clock_type ( self ) Return current clock type. Possible values: \"system_time\", \"monotonic_clock\", \"tick_counter\", \"mach_absolute_time\", \"performance_counter\" Returns: Type Description Literal['system_time', 'monotonic_clock', 'tick_counter', 'mach_absolute_time', 'performance_counter'] clock type Source code in prettyqt/core/elapsedtimer.py def get_clock_type ( self ) -> ClockTypeStr : \"\"\"Return current clock type. Possible values: \"system_time\", \"monotonic_clock\", \"tick_counter\", \"mach_absolute_time\", \"performance_counter\" Returns: clock type \"\"\" return CLOCK_TYPE . inverse [ self . clockType ()] filedevice FileDevice get_error ( self ) Return file error status. Returns: Type Description Literal['none', 'read', 'write', 'fatal', 'resource', 'open', 'abort', 'time_out', 'unspecified', 'remove', 'rename', 'position', 'resize', 'permissions', 'copy'] file error status Source code in prettyqt/core/filedevice.py def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return FILE_ERROR . inverse [ self . error ()] get_file_time ( self , typ ) Return current file time. Returns: Type Description Optional[datetime.datetime] file time Source code in prettyqt/core/filedevice.py def get_file_time ( self , typ : FileTimeStr ) -> Optional [ datetime . datetime ]: \"\"\"Return current file time. Returns: file time \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) date = self . fileTime ( FILE_TIME [ typ ]) if not date : return None return to_datetime ( date ) set_file_time ( self , file_time , typ ) Set file time. Parameters: Name Type Description Default typ Literal['access', 'birth', 'metadata_change', 'modification'] file time to use required Exceptions: Type Description InvalidParamError file time does not exist Source code in prettyqt/core/filedevice.py def set_file_time ( self , file_time : Union [ QtCore . QDateTime , datetime . datetime ], typ : FileTimeStr ) -> bool : \"\"\"Set file time. Args: typ: file time to use Raises: InvalidParamError: file time does not exist \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) return self . setFileTime ( file_time , FILE_TIME [ typ ]) historystate HistoryState get_history_type ( self ) Return current history type. Returns: Type Description Literal['shallow', 'deep'] history type Source code in prettyqt/core/historystate.py def get_history_type ( self ) -> HistoryTypeStr : \"\"\"Return current history type. Returns: history type \"\"\" return HISTORY_TYPE . inverse [ self . historyType ()] set_history_type ( self , typ ) Set history type to use. Parameters: Name Type Description Default typ Literal['shallow', 'deep'] history type to use required Exceptions: Type Description InvalidParamError history type does not exist Source code in prettyqt/core/historystate.py def set_history_type ( self , typ : HistoryTypeStr ): \"\"\"Set history type to use. Args: typ: history type to use Raises: InvalidParamError: history type does not exist \"\"\" if typ not in HISTORY_TYPE : raise InvalidParamError ( typ , HISTORY_TYPE ) self . setHistoryType ( HISTORY_TYPE [ typ ]) line Line __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/line.py def __reduce__ ( self ): return self . __class__ , ( self . get_p1 (), self . get_p1 ()) linef LineF __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/linef.py def __reduce__ ( self ): return self . __class__ , ( self . get_p1 (), self . get_p1 ()) operatingsystemversion OperatingSystemVersion get_type ( self ) Get current os type. Returns: Type Description Literal['android', 'ios', 'mac_os', 'tv_os', 'watch_os', 'windows', 'unknown'] current os type Source code in prettyqt/core/operatingsystemversion.py def get_type ( self ) -> OsTypeStr : \"\"\"Get current os type. Returns: current os type \"\"\" return OS_TYPE . inverse [ self . type ()] point Point __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/point.py def __reduce__ ( self ): return self . __class__ , ( self . x (), self . y ()) pointf PointF __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/pointf.py def __reduce__ ( self ): return self . __class__ , ( self . x (), self . y ()) process Process set_input_channel_mode ( self , mode ) Set the input channel mode. possible values are \"managed\", \"forward\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_input_channel_mode ( self , mode : str ): \"\"\"Set the input channel mode. possible values are \"managed\", \"forward\" Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in INPUT_CHANNEL_MODES : raise InvalidParamError ( mode , INPUT_CHANNEL_MODES ) self . setInputChannelMode ( INPUT_CHANNEL_MODES [ mode ]) set_process_channel_mode ( self , mode ) Set the process channel mode. possible values are \"separate\", \"merged\", \"forwarded\", \"forwarded_error\", \"forwarded_output\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_process_channel_mode ( self , mode : str ): \"\"\"Set the process channel mode. possible values are \"separate\", \"merged\", \"forwarded\", \"forwarded_error\", \"forwarded_output\" Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in PROCESS_CHANNEL_MODES : raise InvalidParamError ( mode , PROCESS_CHANNEL_MODES ) self . setProcessChannelMode ( PROCESS_CHANNEL_MODES [ mode ]) set_read_channel ( self , channel ) Set the input channel channel. possible values are \"managed\", \"forwarded\" Parameters: Name Type Description Default channel str channel to set required Exceptions: Type Description InvalidParamError invalid channel Source code in prettyqt/core/process.py def set_read_channel ( self , channel : str ): \"\"\"Set the input channel channel. possible values are \"managed\", \"forwarded\" Args: channel: channel to set Raises: InvalidParamError: invalid channel \"\"\" if channel not in PROCESS_CHANNELS : raise InvalidParamError ( channel , PROCESS_CHANNELS ) self . setReadChannel ( PROCESS_CHANNELS [ channel ]) set_state ( self , state ) Set the process state. possible values are \"not_running\", \"starting\", \"running\" Parameters: Name Type Description Default state str state to set required Exceptions: Type Description InvalidParamError invalid state Source code in prettyqt/core/process.py def set_state ( self , state : str ): \"\"\"Set the process state. possible values are \"not_running\", \"starting\", \"running\" Args: state: state to set Raises: InvalidParamError: invalid state \"\"\" if state not in PROCESS_STATES : raise InvalidParamError ( state , PROCESS_STATES ) self . setProcessState ( PROCESS_STATES [ state ]) rect Rect __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/rect.py def __reduce__ ( self ): return self . __class__ , ( self . x (), self . y (), self . width (), self . height ()) rectf RectF __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/rectf.py def __reduce__ ( self ): return self . __class__ , ( self . x (), self . y (), self . width (), self . height ()) regularexpression RegularExpression globalMatch ( self , * args , ** kwargs ) globalMatch(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it ) match ( self , text , offset = 0 , match_type = 'normal' , anchored = False ) match(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py def match ( self , text : str , offset : int = 0 , match_type : MatchTypeStr = \"normal\" , anchored : bool = False , ) -> core . RegularExpressionMatch : if isinstance ( match_type , str ): match_type = MATCH_TYPE [ match_type ] if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , match_type , options ) return core . RegularExpressionMatch ( match ) settings Settings get_default_format () classmethod Return default settings format. Returns: Type Description Literal['user', 'system'] default settings format Source code in prettyqt/core/settings.py @classmethod def get_default_format ( cls ) -> FormatStr : \"\"\"Return default settings format. Returns: default settings format \"\"\" return FORMAT . inverse [ cls . defaultFormat ()] get_scope ( self ) Return scope. Returns: Type Description Literal['user', 'system'] scope Source code in prettyqt/core/settings.py def get_scope ( self ) -> ScopeStr : \"\"\"Return scope. Returns: scope \"\"\" return SCOPE . inverse [ self . scope ()] group ( self , prefix ) Context manager for setting groups. Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py @contextlib . contextmanager def group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup () read_array ( self , prefix ) Context manager for reading arrays. Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray () set_default_format ( fmt ) classmethod Set the default format. Parameters: Name Type Description Default fmt Literal['user', 'system'] the default format to use required Exceptions: Type Description InvalidParamError invalid format Source code in prettyqt/core/settings.py @classmethod def set_default_format ( cls , fmt : FormatStr ): \"\"\"Set the default format. Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) cls . setDefaultFormat ( FORMAT [ fmt ]) set_path ( fmt , scope , path ) classmethod Set the path to the settings file. Parameters: Name Type Description Default fmt Literal['user', 'system'] the default format to use required scope Literal['user', 'system'] the scope to use required Exceptions: Type Description InvalidParamError invalid format or scope Source code in prettyqt/core/settings.py @classmethod def set_path ( cls , fmt : FormatStr , scope : ScopeStr , path : Union [ str , pathlib . Path ]): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) if scope not in SCOPE : raise InvalidParamError ( scope , SCOPE ) cls . setPath ( FORMAT [ fmt ], SCOPE [ scope ], str ( path )) write_array ( self , prefix , size =- 1 ) Context manager for writing arrays. Parameters: Name Type Description Default prefix str prefix for settings array required size int size of settings array -1 Source code in prettyqt/core/settings.py @contextlib . contextmanager def write_array ( self , prefix : str , size : int = - 1 ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" self . beginWriteArray ( prefix , size ) yield None self . endArray () size Size __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/size.py def __reduce__ ( self ): return self . __class__ , ( self . width (), self . height ()) sizef SizeF __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/sizef.py def __reduce__ ( self ): return self . __class__ , ( self . width (), self . height ()) socketnotifier SocketNotifier get_type ( self ) Return socket event type. Possible values: \"read\", \"write\", \"exception\" Returns: Type Description Literal['read', 'write', 'exception'] socket event type Source code in prettyqt/core/socketnotifier.py def get_type ( self ) -> TypeStr : \"\"\"Return socket event type. Possible values: \"read\", \"write\", \"exception\" Returns: socket event type \"\"\" return TYPE . inverse [ self . type ()] state State get_child_mode ( self ) Return current child mode. Returns: Type Description Literal['exclusive', 'parallel'] child mode Source code in prettyqt/core/state.py def get_child_mode ( self ) -> ChildModeStr : \"\"\"Return current child mode. Returns: child mode \"\"\" return CHILD_MODE . inverse [ self . childMode ()] set_child_mode ( self , mode ) Set child mode to use. Parameters: Name Type Description Default mode Literal['exclusive', 'parallel'] child mode to use required Exceptions: Type Description InvalidParamError child mode does not exist Source code in prettyqt/core/state.py def set_child_mode ( self , mode : ChildModeStr ): \"\"\"Set child mode to use. Args: mode: child mode to use Raises: InvalidParamError: child mode does not exist \"\"\" if mode not in CHILD_MODE : raise InvalidParamError ( mode , CHILD_MODE ) self . setChildMode ( CHILD_MODE [ mode ]) statemachine StateMachine get_global_restore_policy ( self ) Return current restore policy. Possible values: \"restore\", \"dont_restore\" Returns: Type Description str restore policy Source code in prettyqt/core/statemachine.py def get_global_restore_policy ( self ) -> str : \"\"\"Return current restore policy. Possible values: \"restore\", \"dont_restore\" Returns: restore policy \"\"\" return core . state . RESTORE_POLICY . inverse [ self . globalRestorePolicy ()] set_global_restore_policy ( self , policy ) Set restore policy to use. Allowed values are \"restore\", \"dont_restore\" Parameters: Name Type Description Default policy str restore policy to use required Exceptions: Type Description InvalidParamError restore policy does not exist Source code in prettyqt/core/statemachine.py def set_global_restore_policy ( self , policy : str ): \"\"\"Set restore policy to use. Allowed values are \"restore\", \"dont_restore\" Args: policy: restore policy to use Raises: InvalidParamError: restore policy does not exist \"\"\" if policy not in core . state . RESTORE_POLICY : raise InvalidParamError ( policy , core . state . RESTORE_POLICY ) self . setGlobalRestorePolicy ( core . state . RESTORE_POLICY [ policy ]) textstream TextStream get_field_alignment ( self ) Get current field alignment. Possible values are \"left\", \"right\", \"center\", \"accounting_style\" Returns: Type Description str current field alignment Source code in prettyqt/core/textstream.py def get_field_alignment ( self ) -> str : \"\"\"Get current field alignment. Possible values are \"left\", \"right\", \"center\", \"accounting_style\" Returns: current field alignment \"\"\" return FIELD_ALIGNMENT . inverse [ self . fieldAlignment ()] get_real_number_notation ( self ) Get current real number notation. Possible values are \"scientific\", \"fixed\", \"smart\" Returns: Type Description str current real number notation Source code in prettyqt/core/textstream.py def get_real_number_notation ( self ) -> str : \"\"\"Get current real number notation. Possible values are \"scientific\", \"fixed\", \"smart\" Returns: current real number notation \"\"\" return REAL_NUMBER_NOTATION . inverse [ self . realNumberNotation ()] get_status ( self ) Get current status. Possible values are \"ok\", \"read_past_end\", \"read_corrupt_data\", \"write_failed\" Returns: Type Description str current status Source code in prettyqt/core/textstream.py def get_status ( self ) -> str : \"\"\"Get current status. Possible values are \"ok\", \"read_past_end\", \"read_corrupt_data\", \"write_failed\" Returns: current status \"\"\" return STATUS . inverse [ self . status ()] set_field_alignment ( self , alignment ) Set the field alignment. Valid values are \"left\", \"right\", \"center\", \"accounting_style\" Parameters: Name Type Description Default alignment str field alignment required Exceptions: Type Description InvalidParamError invalid field alignment Source code in prettyqt/core/textstream.py def set_field_alignment ( self , alignment : str ): \"\"\"Set the field alignment. Valid values are \"left\", \"right\", \"center\", \"accounting_style\" Args: alignment: field alignment Raises: InvalidParamError: invalid field alignment \"\"\" if alignment not in FIELD_ALIGNMENT : raise InvalidParamError ( alignment , FIELD_ALIGNMENT ) self . setFieldAlignment ( FIELD_ALIGNMENT [ alignment ]) set_real_number_notation ( self , notation ) Set the real number notation. Valid values are \"scientific\", \"fixed\", \"smart\" Parameters: Name Type Description Default notation str real number notation required Exceptions: Type Description InvalidParamError invalid real number notation Source code in prettyqt/core/textstream.py def set_real_number_notation ( self , notation : str ): \"\"\"Set the real number notation. Valid values are \"scientific\", \"fixed\", \"smart\" Args: notation: real number notation Raises: InvalidParamError: invalid real number notation \"\"\" if notation not in REAL_NUMBER_NOTATION : raise InvalidParamError ( notation , REAL_NUMBER_NOTATION ) self . setRealNumberNotation ( REAL_NUMBER_NOTATION [ notation ]) set_status ( self , status ) Set the status. Valid values are \"ok\", \"read_past_end\", \"read_corrupt_data\", \"write_failed\" Parameters: Name Type Description Default status str status required Exceptions: Type Description InvalidParamError invalid status Source code in prettyqt/core/textstream.py def set_status ( self , status : str ): \"\"\"Set the status. Valid values are \"ok\", \"read_past_end\", \"read_corrupt_data\", \"write_failed\" Args: status: status Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ]) time Time __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/time.py def __reduce__ ( self ): return self . __class__ , ( self . hour (), self . minute (), self . second (), self . msec ()) timeline TimeLine get_direction ( self ) Return current direction. Returns: Type Description Literal['forward', 'backward'] direction Source code in prettyqt/core/timeline.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()] get_state ( self ) Return current state. Returns: Type Description Literal['not_running', 'paused', 'running'] state Source code in prettyqt/core/timeline.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()] set_direction ( self , direction ) Set the direction. Parameters: Name Type Description Default direction Literal['forward', 'backward'] direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/core/timeline.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) timer Timer get_type ( self ) Return current timer type. Returns: Type Description TypeStr timer type Source code in prettyqt/core/timer.py def get_type ( self ) -> TypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return TYPE . inverse [ self . timerType ()] set_type ( self , typ ) Set the timer type. Parameters: Name Type Description Default typ TypeStr timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/timer.py def set_type ( self , typ : TypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setTimerType ( TYPE [ typ ]) url Url to_path ( self ) Get pathlib object from the URL. Returns: Type Description pathlib.Path Path Source code in prettyqt/core/url.py def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self )) versionnumber VersionNumber major ( self ) An integer representing the major version. Source code in prettyqt/core/versionnumber.py def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion () micro ( self ) An integer representing the micro version. Source code in prettyqt/core/versionnumber.py def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion () minor ( self ) An integer representing the minor version. Source code in prettyqt/core/versionnumber.py def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion ()","title":"core"},{"location":"api/core.html#core-module","text":"","title":"core module"},{"location":"api/core.html#prettyqt.core","text":"Core module. Contains QtCore-based classes","title":"prettyqt.core"},{"location":"api/core.html#prettyqt.core.abstractanimation","text":"","title":"abstractanimation"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation","text":"","title":"AbstractAnimation"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.get_direction","text":"Get the current animation direction. Possible values: \"forward\", \"backward\" Returns: Type Description Literal['forward', 'backward'] animation direction Source code in prettyqt/core/abstractanimation.py def get_direction ( self ) -> DirectionStr : \"\"\"Get the current animation direction. Possible values: \"forward\", \"backward\" Returns: animation direction \"\"\" return DIRECTION . inverse [ self . direction ()]","title":"get_direction()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.get_state","text":"Get the current animation state. Possible values: \"stopped\", \"paused\", \"running\" Returns: Type Description Literal['stopped', 'paused', 'running'] animation state Source code in prettyqt/core/abstractanimation.py def get_state ( self ) -> StateStr : \"\"\"Get the current animation state. Possible values: \"stopped\", \"paused\", \"running\" Returns: animation state \"\"\" return STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.set_direction","text":"Set animation direction. Valid values: \"forward\", \"backward\" Parameters: Name Type Description Default direction Literal['forward', 'backward'] animation direction required Exceptions: Type Description InvalidParamError animation direction does not exist Source code in prettyqt/core/abstractanimation.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set animation direction. Valid values: \"forward\", \"backward\" Args: direction: animation direction Raises: InvalidParamError: animation direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ])","title":"set_direction()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.start_animation","text":"Start the animation. Valid values for policy: \"keep\", \"delete\" Parameters: Name Type Description Default policy Literal['keep', 'delete'] animation policy required Exceptions: Type Description InvalidParamError animation policy does not exist Source code in prettyqt/core/abstractanimation.py def start_animation ( self , policy : DeletionPolicyStr ): \"\"\"Start the animation. Valid values for policy: \"keep\", \"delete\" Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" if policy not in DELETION_POLICY : raise InvalidParamError ( policy , DELETION_POLICY ) self . start ( DELETION_POLICY [ policy ])","title":"start_animation()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel","text":"","title":"abstractitemmodel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel","text":"","title":"AbstractItemModel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.__len__","text":"Return amount of rows. Source code in prettyqt/core/abstractitemmodel.py def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.change_layout","text":"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit ()","title":"change_layout()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.reset_model","text":"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel ()","title":"reset_model()"},{"location":"api/core.html#prettyqt.core.abstracttransition","text":"","title":"abstracttransition"},{"location":"api/core.html#prettyqt.core.abstracttransition.AbstractTransition","text":"","title":"AbstractTransition"},{"location":"api/core.html#prettyqt.core.abstracttransition.AbstractTransition.get_transition_type","text":"Return current transition type. Returns: Type Description Literal['exclusive', 'parallel'] transition type Source code in prettyqt/core/abstracttransition.py def get_transition_type ( self ) -> TransitionTypeStr : \"\"\"Return current transition type. Returns: transition type \"\"\" return TRANSITION_TYPE . inverse [ self . transitionType ()]","title":"get_transition_type()"},{"location":"api/core.html#prettyqt.core.abstracttransition.AbstractTransition.set_transition_type","text":"Set transition type. Parameters: Name Type Description Default typ Literal['exclusive', 'parallel'] transition type to use required Exceptions: Type Description InvalidParamError transition type does not exist Source code in prettyqt/core/abstracttransition.py def set_transition_type ( self , typ : TransitionTypeStr ): \"\"\"Set transition type. Args: typ: transition type to use Raises: InvalidParamError: transition type does not exist \"\"\" if typ not in TRANSITION_TYPE : raise InvalidParamError ( typ , TRANSITION_TYPE ) self . setTransitionType ( TRANSITION_TYPE [ typ ])","title":"set_transition_type()"},{"location":"api/core.html#prettyqt.core.bytearray","text":"","title":"bytearray"},{"location":"api/core.html#prettyqt.core.bytearray.ByteArray","text":"","title":"ByteArray"},{"location":"api/core.html#prettyqt.core.bytearray.ByteArray.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/bytearray.py def __reduce__ ( self ): return self . __class__ , ( bytes ( self ),)","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.collator","text":"","title":"collator"},{"location":"api/core.html#prettyqt.core.collator.Collator","text":"","title":"Collator"},{"location":"api/core.html#prettyqt.core.collator.Collator.is_case_sensitive","text":"Return case sensitivity. Returns: Type Description bool case sensitivity Source code in prettyqt/core/collator.py def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ())","title":"is_case_sensitive()"},{"location":"api/core.html#prettyqt.core.collator.Collator.set_case_sensitive","text":"Set case sensitivity. Parameters: Name Type Description Default state bool case sensitive required Source code in prettyqt/core/collator.py def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = QtCore . Qt . CaseSensitive if state else QtCore . Qt . CaseInsensitive self . setCaseSensitivity ( sensitivity )","title":"set_case_sensitive()"},{"location":"api/core.html#prettyqt.core.commandlineparser","text":"","title":"commandlineparser"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser","text":"","title":"CommandLineParser"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_options_after_positional_arguments_mode","text":"Set the options after positional arguments mode. Parameters: Name Type Description Default mode Literal['compacted_short', 'long'] options after positional arguments mode required Exceptions: Type Description InvalidParamError options after positional arguments mode does not exist Source code in prettyqt/core/commandlineparser.py def set_options_after_positional_arguments_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the options after positional arguments mode. Args: mode: options after positional arguments mode Raises: InvalidParamError: options after positional arguments mode does not exist \"\"\" if mode not in OPTIONS_AFTER_POS_ARG : raise InvalidParamError ( mode , OPTIONS_AFTER_POS_ARG ) self . setOptionsAfterPositionalArgumentsMode ( OPTIONS_AFTER_POS_ARG [ mode ])","title":"set_options_after_positional_arguments_mode()"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_single_dash_word_option_mode","text":"Set the single dash word option mode. Parameters: Name Type Description Default mode Literal['compacted_short', 'long'] single dash word option mode required Exceptions: Type Description InvalidParamError single dash word option mode does not exist Source code in prettyqt/core/commandlineparser.py def set_single_dash_word_option_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the single dash word option mode. Args: mode: single dash word option mode Raises: InvalidParamError: single dash word option mode does not exist \"\"\" if mode not in SINGLE_DASH_WORD : raise InvalidParamError ( mode , SINGLE_DASH_WORD ) self . setSingleDashWordOptionMode ( SINGLE_DASH_WORD [ mode ])","title":"set_single_dash_word_option_mode()"},{"location":"api/core.html#prettyqt.core.datastream","text":"","title":"datastream"},{"location":"api/core.html#prettyqt.core.datastream.DataStream","text":"","title":"DataStream"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_byte_order","text":"Return byte order. Returns: Type Description Literal['big_endian', 'little_endian'] byte order Source code in prettyqt/core/datastream.py def get_byte_order ( self ) -> ByteOrderStr : \"\"\"Return byte order. Returns: byte order \"\"\" return BYTE_ORDER . inverse [ self . byteOrder ()]","title":"get_byte_order()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_float_precision","text":"Return floating point precision. Returns: Type Description Literal['single', 'double'] floating point precision Source code in prettyqt/core/datastream.py def get_float_precision ( self ) -> FloatPrecisionStr : \"\"\"Return floating point precision. Returns: floating point precision \"\"\" return FLOAT_PRECISION . inverse [ self . floatingPointPrecision ()]","title":"get_float_precision()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_byte_order","text":"Set byte order. Parameters: Name Type Description Default order Literal['big_endian', 'little_endian'] byte order to use required Exceptions: Type Description InvalidParamError invalid order Source code in prettyqt/core/datastream.py def set_byte_order ( self , order : ByteOrderStr ): \"\"\"Set byte order. Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ])","title":"set_byte_order()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_float_precision","text":"Set floating point precision. Parameters: Name Type Description Default precision Literal['single', 'double'] floating point precision required Exceptions: Type Description InvalidParamError invalid precision Source code in prettyqt/core/datastream.py def set_float_precision ( self , precision : FloatPrecisionStr ): \"\"\"Set floating point precision. Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOAT_PRECISION : raise InvalidParamError ( precision , FLOAT_PRECISION ) self . setFloatingPointPrecision ( FLOAT_PRECISION [ precision ])","title":"set_float_precision()"},{"location":"api/core.html#prettyqt.core.date","text":"","title":"date"},{"location":"api/core.html#prettyqt.core.date.Date","text":"","title":"Date"},{"location":"api/core.html#prettyqt.core.date.Date.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/date.py def __reduce__ ( self ): return self . __class__ , ( self . year (), self . month (), self . day ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.datetime","text":"","title":"datetime"},{"location":"api/core.html#prettyqt.core.datetime.DateTime","text":"","title":"DateTime"},{"location":"api/core.html#prettyqt.core.datetime.DateTime.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/datetime.py def __reduce__ ( self ): return self . __class__ , ( self . date (), self . time ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.datetime.DateTime.get_time_spec","text":"Return current time specification. Returns: Type Description Literal['local_time', 'utc', 'offset_from_utc', 'timezone'] time specification Source code in prettyqt/core/datetime.py def get_time_spec ( self ) -> TimeSpecStr : \"\"\"Return current time specification. Returns: time specification \"\"\" return TIME_SPEC . inverse [ self . timeSpec ()]","title":"get_time_spec()"},{"location":"api/core.html#prettyqt.core.datetime.DateTime.set_time_spec","text":"Set the time specification. Parameters: Name Type Description Default spec Literal['local_time', 'utc', 'offset_from_utc', 'timezone'] time specification to use required Exceptions: Type Description InvalidParamError time specification does not exist Source code in prettyqt/core/datetime.py def set_time_spec ( self , spec : TimeSpecStr ): \"\"\"Set the time specification. Args: spec: time specification to use Raises: InvalidParamError: time specification does not exist \"\"\" if spec not in TIME_SPEC : raise InvalidParamError ( spec , TIME_SPEC ) self . setTimeSpec ( TIME_SPEC [ spec ])","title":"set_time_spec()"},{"location":"api/core.html#prettyqt.core.deadlinetimer","text":"","title":"deadlinetimer"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer","text":"","title":"DeadlineTimer"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.get_type","text":"Return current timer type. Possible values: \"precise\", \"coarse\", \"very_coarse\" Returns: Type Description Literal['precise', 'coarse', 'very_coarse'] timer type Source code in prettyqt/core/deadlinetimer.py def get_type ( self ) -> TypeStr : \"\"\"Return current timer type. Possible values: \"precise\", \"coarse\", \"very_coarse\" Returns: timer type \"\"\" return TYPE . inverse [ self . timerType ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.set_type","text":"Set the timer type. Allowed values are \"precise\", \"coarse\", \"very_coarse\" Parameters: Name Type Description Default typ Literal['precise', 'coarse', 'very_coarse'] timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/deadlinetimer.py def set_type ( self , typ : TypeStr ): \"\"\"Set the timer type. Allowed values are \"precise\", \"coarse\", \"very_coarse\" Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setTimerType ( TYPE [ typ ])","title":"set_type()"},{"location":"api/core.html#prettyqt.core.easingcurve","text":"","title":"easingcurve"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve","text":"","title":"EasingCurve"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.get_type","text":"Get the current easing curve type. Returns: Type Description Literal['linear', 'in_quad', 'out_quad', 'in_out_quad', 'out_in_quad', 'in_cubic', 'out_cubic', 'in_out_cubic', 'out_in_cubic', 'in_quart', 'out_quart', 'in_out_quart', 'out_in_quart', 'in_quint', 'out_quint', 'in_out_quint', 'out_in_quint', 'in_sine', 'out_sine', 'in_out_sine', 'out_in_sine', 'in_expo', 'out_expo', 'in_out_expo', 'out_in_expo', 'in_circ', 'out_circ', 'in_out_circ', 'out_in_circ', 'in_elastic', 'out_elastic', 'in_out_elastic', 'out_in_elastic', 'in_back', 'out_back', 'in_out_back', 'out_in_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'out_in_bounce', 'bezier_spline', 'tcb_spline', 'custom'] easing curve type Source code in prettyqt/core/easingcurve.py def get_type ( self ) -> TypeStr : \"\"\"Get the current easing curve type. Returns: easing curve type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.set_type","text":"Set easing curve type. Parameters: Name Type Description Default typ Literal['linear', 'in_quad', 'out_quad', 'in_out_quad', 'out_in_quad', 'in_cubic', 'out_cubic', 'in_out_cubic', 'out_in_cubic', 'in_quart', 'out_quart', 'in_out_quart', 'out_in_quart', 'in_quint', 'out_quint', 'in_out_quint', 'out_in_quint', 'in_sine', 'out_sine', 'in_out_sine', 'out_in_sine', 'in_expo', 'out_expo', 'in_out_expo', 'out_in_expo', 'in_circ', 'out_circ', 'in_out_circ', 'out_in_circ', 'in_elastic', 'out_elastic', 'in_out_elastic', 'out_in_elastic', 'in_back', 'out_back', 'in_out_back', 'out_in_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'out_in_bounce', 'bezier_spline', 'tcb_spline', 'custom'] easing curve type required Exceptions: Type Description InvalidParamError easing curve type does not exist Source code in prettyqt/core/easingcurve.py def set_type ( self , typ : TypeStr ): \"\"\"Set easing curve type. Args: typ: easing curve type Raises: InvalidParamError: easing curve type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setType ( TYPE [ typ ])","title":"set_type()"},{"location":"api/core.html#prettyqt.core.elapsedtimer","text":"","title":"elapsedtimer"},{"location":"api/core.html#prettyqt.core.elapsedtimer.ElapsedTimer","text":"","title":"ElapsedTimer"},{"location":"api/core.html#prettyqt.core.elapsedtimer.ElapsedTimer.get_clock_type","text":"Return current clock type. Possible values: \"system_time\", \"monotonic_clock\", \"tick_counter\", \"mach_absolute_time\", \"performance_counter\" Returns: Type Description Literal['system_time', 'monotonic_clock', 'tick_counter', 'mach_absolute_time', 'performance_counter'] clock type Source code in prettyqt/core/elapsedtimer.py def get_clock_type ( self ) -> ClockTypeStr : \"\"\"Return current clock type. Possible values: \"system_time\", \"monotonic_clock\", \"tick_counter\", \"mach_absolute_time\", \"performance_counter\" Returns: clock type \"\"\" return CLOCK_TYPE . inverse [ self . clockType ()]","title":"get_clock_type()"},{"location":"api/core.html#prettyqt.core.filedevice","text":"","title":"filedevice"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice","text":"","title":"FileDevice"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice.get_error","text":"Return file error status. Returns: Type Description Literal['none', 'read', 'write', 'fatal', 'resource', 'open', 'abort', 'time_out', 'unspecified', 'remove', 'rename', 'position', 'resize', 'permissions', 'copy'] file error status Source code in prettyqt/core/filedevice.py def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return FILE_ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice.get_file_time","text":"Return current file time. Returns: Type Description Optional[datetime.datetime] file time Source code in prettyqt/core/filedevice.py def get_file_time ( self , typ : FileTimeStr ) -> Optional [ datetime . datetime ]: \"\"\"Return current file time. Returns: file time \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) date = self . fileTime ( FILE_TIME [ typ ]) if not date : return None return to_datetime ( date )","title":"get_file_time()"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice.set_file_time","text":"Set file time. Parameters: Name Type Description Default typ Literal['access', 'birth', 'metadata_change', 'modification'] file time to use required Exceptions: Type Description InvalidParamError file time does not exist Source code in prettyqt/core/filedevice.py def set_file_time ( self , file_time : Union [ QtCore . QDateTime , datetime . datetime ], typ : FileTimeStr ) -> bool : \"\"\"Set file time. Args: typ: file time to use Raises: InvalidParamError: file time does not exist \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) return self . setFileTime ( file_time , FILE_TIME [ typ ])","title":"set_file_time()"},{"location":"api/core.html#prettyqt.core.historystate","text":"","title":"historystate"},{"location":"api/core.html#prettyqt.core.historystate.HistoryState","text":"","title":"HistoryState"},{"location":"api/core.html#prettyqt.core.historystate.HistoryState.get_history_type","text":"Return current history type. Returns: Type Description Literal['shallow', 'deep'] history type Source code in prettyqt/core/historystate.py def get_history_type ( self ) -> HistoryTypeStr : \"\"\"Return current history type. Returns: history type \"\"\" return HISTORY_TYPE . inverse [ self . historyType ()]","title":"get_history_type()"},{"location":"api/core.html#prettyqt.core.historystate.HistoryState.set_history_type","text":"Set history type to use. Parameters: Name Type Description Default typ Literal['shallow', 'deep'] history type to use required Exceptions: Type Description InvalidParamError history type does not exist Source code in prettyqt/core/historystate.py def set_history_type ( self , typ : HistoryTypeStr ): \"\"\"Set history type to use. Args: typ: history type to use Raises: InvalidParamError: history type does not exist \"\"\" if typ not in HISTORY_TYPE : raise InvalidParamError ( typ , HISTORY_TYPE ) self . setHistoryType ( HISTORY_TYPE [ typ ])","title":"set_history_type()"},{"location":"api/core.html#prettyqt.core.line","text":"","title":"line"},{"location":"api/core.html#prettyqt.core.line.Line","text":"","title":"Line"},{"location":"api/core.html#prettyqt.core.line.Line.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/line.py def __reduce__ ( self ): return self . __class__ , ( self . get_p1 (), self . get_p1 ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.linef","text":"","title":"linef"},{"location":"api/core.html#prettyqt.core.linef.LineF","text":"","title":"LineF"},{"location":"api/core.html#prettyqt.core.linef.LineF.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/linef.py def __reduce__ ( self ): return self . __class__ , ( self . get_p1 (), self . get_p1 ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.operatingsystemversion","text":"","title":"operatingsystemversion"},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion","text":"","title":"OperatingSystemVersion"},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion.get_type","text":"Get current os type. Returns: Type Description Literal['android', 'ios', 'mac_os', 'tv_os', 'watch_os', 'windows', 'unknown'] current os type Source code in prettyqt/core/operatingsystemversion.py def get_type ( self ) -> OsTypeStr : \"\"\"Get current os type. Returns: current os type \"\"\" return OS_TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.point","text":"","title":"point"},{"location":"api/core.html#prettyqt.core.point.Point","text":"","title":"Point"},{"location":"api/core.html#prettyqt.core.point.Point.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/point.py def __reduce__ ( self ): return self . __class__ , ( self . x (), self . y ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.pointf","text":"","title":"pointf"},{"location":"api/core.html#prettyqt.core.pointf.PointF","text":"","title":"PointF"},{"location":"api/core.html#prettyqt.core.pointf.PointF.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/pointf.py def __reduce__ ( self ): return self . __class__ , ( self . x (), self . y ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.process","text":"","title":"process"},{"location":"api/core.html#prettyqt.core.process.Process","text":"","title":"Process"},{"location":"api/core.html#prettyqt.core.process.Process.set_input_channel_mode","text":"Set the input channel mode. possible values are \"managed\", \"forward\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_input_channel_mode ( self , mode : str ): \"\"\"Set the input channel mode. possible values are \"managed\", \"forward\" Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in INPUT_CHANNEL_MODES : raise InvalidParamError ( mode , INPUT_CHANNEL_MODES ) self . setInputChannelMode ( INPUT_CHANNEL_MODES [ mode ])","title":"set_input_channel_mode()"},{"location":"api/core.html#prettyqt.core.process.Process.set_process_channel_mode","text":"Set the process channel mode. possible values are \"separate\", \"merged\", \"forwarded\", \"forwarded_error\", \"forwarded_output\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_process_channel_mode ( self , mode : str ): \"\"\"Set the process channel mode. possible values are \"separate\", \"merged\", \"forwarded\", \"forwarded_error\", \"forwarded_output\" Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in PROCESS_CHANNEL_MODES : raise InvalidParamError ( mode , PROCESS_CHANNEL_MODES ) self . setProcessChannelMode ( PROCESS_CHANNEL_MODES [ mode ])","title":"set_process_channel_mode()"},{"location":"api/core.html#prettyqt.core.process.Process.set_read_channel","text":"Set the input channel channel. possible values are \"managed\", \"forwarded\" Parameters: Name Type Description Default channel str channel to set required Exceptions: Type Description InvalidParamError invalid channel Source code in prettyqt/core/process.py def set_read_channel ( self , channel : str ): \"\"\"Set the input channel channel. possible values are \"managed\", \"forwarded\" Args: channel: channel to set Raises: InvalidParamError: invalid channel \"\"\" if channel not in PROCESS_CHANNELS : raise InvalidParamError ( channel , PROCESS_CHANNELS ) self . setReadChannel ( PROCESS_CHANNELS [ channel ])","title":"set_read_channel()"},{"location":"api/core.html#prettyqt.core.process.Process.set_state","text":"Set the process state. possible values are \"not_running\", \"starting\", \"running\" Parameters: Name Type Description Default state str state to set required Exceptions: Type Description InvalidParamError invalid state Source code in prettyqt/core/process.py def set_state ( self , state : str ): \"\"\"Set the process state. possible values are \"not_running\", \"starting\", \"running\" Args: state: state to set Raises: InvalidParamError: invalid state \"\"\" if state not in PROCESS_STATES : raise InvalidParamError ( state , PROCESS_STATES ) self . setProcessState ( PROCESS_STATES [ state ])","title":"set_state()"},{"location":"api/core.html#prettyqt.core.rect","text":"","title":"rect"},{"location":"api/core.html#prettyqt.core.rect.Rect","text":"","title":"Rect"},{"location":"api/core.html#prettyqt.core.rect.Rect.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/rect.py def __reduce__ ( self ): return self . __class__ , ( self . x (), self . y (), self . width (), self . height ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.rectf","text":"","title":"rectf"},{"location":"api/core.html#prettyqt.core.rectf.RectF","text":"","title":"RectF"},{"location":"api/core.html#prettyqt.core.rectf.RectF.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/rectf.py def __reduce__ ( self ): return self . __class__ , ( self . x (), self . y (), self . width (), self . height ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.regularexpression","text":"","title":"regularexpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression","text":"","title":"RegularExpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.globalMatch","text":"globalMatch(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it )","title":"globalMatch()"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.match","text":"match(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py def match ( self , text : str , offset : int = 0 , match_type : MatchTypeStr = \"normal\" , anchored : bool = False , ) -> core . RegularExpressionMatch : if isinstance ( match_type , str ): match_type = MATCH_TYPE [ match_type ] if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , match_type , options ) return core . RegularExpressionMatch ( match )","title":"match()"},{"location":"api/core.html#prettyqt.core.settings","text":"","title":"settings"},{"location":"api/core.html#prettyqt.core.settings.Settings","text":"","title":"Settings"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_default_format","text":"Return default settings format. Returns: Type Description Literal['user', 'system'] default settings format Source code in prettyqt/core/settings.py @classmethod def get_default_format ( cls ) -> FormatStr : \"\"\"Return default settings format. Returns: default settings format \"\"\" return FORMAT . inverse [ cls . defaultFormat ()]","title":"get_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_scope","text":"Return scope. Returns: Type Description Literal['user', 'system'] scope Source code in prettyqt/core/settings.py def get_scope ( self ) -> ScopeStr : \"\"\"Return scope. Returns: scope \"\"\" return SCOPE . inverse [ self . scope ()]","title":"get_scope()"},{"location":"api/core.html#prettyqt.core.settings.Settings.group","text":"Context manager for setting groups. Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py @contextlib . contextmanager def group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup ()","title":"group()"},{"location":"api/core.html#prettyqt.core.settings.Settings.read_array","text":"Context manager for reading arrays. Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray ()","title":"read_array()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_default_format","text":"Set the default format. Parameters: Name Type Description Default fmt Literal['user', 'system'] the default format to use required Exceptions: Type Description InvalidParamError invalid format Source code in prettyqt/core/settings.py @classmethod def set_default_format ( cls , fmt : FormatStr ): \"\"\"Set the default format. Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) cls . setDefaultFormat ( FORMAT [ fmt ])","title":"set_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_path","text":"Set the path to the settings file. Parameters: Name Type Description Default fmt Literal['user', 'system'] the default format to use required scope Literal['user', 'system'] the scope to use required Exceptions: Type Description InvalidParamError invalid format or scope Source code in prettyqt/core/settings.py @classmethod def set_path ( cls , fmt : FormatStr , scope : ScopeStr , path : Union [ str , pathlib . Path ]): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) if scope not in SCOPE : raise InvalidParamError ( scope , SCOPE ) cls . setPath ( FORMAT [ fmt ], SCOPE [ scope ], str ( path ))","title":"set_path()"},{"location":"api/core.html#prettyqt.core.settings.Settings.write_array","text":"Context manager for writing arrays. Parameters: Name Type Description Default prefix str prefix for settings array required size int size of settings array -1 Source code in prettyqt/core/settings.py @contextlib . contextmanager def write_array ( self , prefix : str , size : int = - 1 ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" self . beginWriteArray ( prefix , size ) yield None self . endArray ()","title":"write_array()"},{"location":"api/core.html#prettyqt.core.size","text":"","title":"size"},{"location":"api/core.html#prettyqt.core.size.Size","text":"","title":"Size"},{"location":"api/core.html#prettyqt.core.size.Size.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/size.py def __reduce__ ( self ): return self . __class__ , ( self . width (), self . height ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.sizef","text":"","title":"sizef"},{"location":"api/core.html#prettyqt.core.sizef.SizeF","text":"","title":"SizeF"},{"location":"api/core.html#prettyqt.core.sizef.SizeF.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/sizef.py def __reduce__ ( self ): return self . __class__ , ( self . width (), self . height ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.socketnotifier","text":"","title":"socketnotifier"},{"location":"api/core.html#prettyqt.core.socketnotifier.SocketNotifier","text":"","title":"SocketNotifier"},{"location":"api/core.html#prettyqt.core.socketnotifier.SocketNotifier.get_type","text":"Return socket event type. Possible values: \"read\", \"write\", \"exception\" Returns: Type Description Literal['read', 'write', 'exception'] socket event type Source code in prettyqt/core/socketnotifier.py def get_type ( self ) -> TypeStr : \"\"\"Return socket event type. Possible values: \"read\", \"write\", \"exception\" Returns: socket event type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.state","text":"","title":"state"},{"location":"api/core.html#prettyqt.core.state.State","text":"","title":"State"},{"location":"api/core.html#prettyqt.core.state.State.get_child_mode","text":"Return current child mode. Returns: Type Description Literal['exclusive', 'parallel'] child mode Source code in prettyqt/core/state.py def get_child_mode ( self ) -> ChildModeStr : \"\"\"Return current child mode. Returns: child mode \"\"\" return CHILD_MODE . inverse [ self . childMode ()]","title":"get_child_mode()"},{"location":"api/core.html#prettyqt.core.state.State.set_child_mode","text":"Set child mode to use. Parameters: Name Type Description Default mode Literal['exclusive', 'parallel'] child mode to use required Exceptions: Type Description InvalidParamError child mode does not exist Source code in prettyqt/core/state.py def set_child_mode ( self , mode : ChildModeStr ): \"\"\"Set child mode to use. Args: mode: child mode to use Raises: InvalidParamError: child mode does not exist \"\"\" if mode not in CHILD_MODE : raise InvalidParamError ( mode , CHILD_MODE ) self . setChildMode ( CHILD_MODE [ mode ])","title":"set_child_mode()"},{"location":"api/core.html#prettyqt.core.statemachine","text":"","title":"statemachine"},{"location":"api/core.html#prettyqt.core.statemachine.StateMachine","text":"","title":"StateMachine"},{"location":"api/core.html#prettyqt.core.statemachine.StateMachine.get_global_restore_policy","text":"Return current restore policy. Possible values: \"restore\", \"dont_restore\" Returns: Type Description str restore policy Source code in prettyqt/core/statemachine.py def get_global_restore_policy ( self ) -> str : \"\"\"Return current restore policy. Possible values: \"restore\", \"dont_restore\" Returns: restore policy \"\"\" return core . state . RESTORE_POLICY . inverse [ self . globalRestorePolicy ()]","title":"get_global_restore_policy()"},{"location":"api/core.html#prettyqt.core.statemachine.StateMachine.set_global_restore_policy","text":"Set restore policy to use. Allowed values are \"restore\", \"dont_restore\" Parameters: Name Type Description Default policy str restore policy to use required Exceptions: Type Description InvalidParamError restore policy does not exist Source code in prettyqt/core/statemachine.py def set_global_restore_policy ( self , policy : str ): \"\"\"Set restore policy to use. Allowed values are \"restore\", \"dont_restore\" Args: policy: restore policy to use Raises: InvalidParamError: restore policy does not exist \"\"\" if policy not in core . state . RESTORE_POLICY : raise InvalidParamError ( policy , core . state . RESTORE_POLICY ) self . setGlobalRestorePolicy ( core . state . RESTORE_POLICY [ policy ])","title":"set_global_restore_policy()"},{"location":"api/core.html#prettyqt.core.textstream","text":"","title":"textstream"},{"location":"api/core.html#prettyqt.core.textstream.TextStream","text":"","title":"TextStream"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_field_alignment","text":"Get current field alignment. Possible values are \"left\", \"right\", \"center\", \"accounting_style\" Returns: Type Description str current field alignment Source code in prettyqt/core/textstream.py def get_field_alignment ( self ) -> str : \"\"\"Get current field alignment. Possible values are \"left\", \"right\", \"center\", \"accounting_style\" Returns: current field alignment \"\"\" return FIELD_ALIGNMENT . inverse [ self . fieldAlignment ()]","title":"get_field_alignment()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_real_number_notation","text":"Get current real number notation. Possible values are \"scientific\", \"fixed\", \"smart\" Returns: Type Description str current real number notation Source code in prettyqt/core/textstream.py def get_real_number_notation ( self ) -> str : \"\"\"Get current real number notation. Possible values are \"scientific\", \"fixed\", \"smart\" Returns: current real number notation \"\"\" return REAL_NUMBER_NOTATION . inverse [ self . realNumberNotation ()]","title":"get_real_number_notation()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_status","text":"Get current status. Possible values are \"ok\", \"read_past_end\", \"read_corrupt_data\", \"write_failed\" Returns: Type Description str current status Source code in prettyqt/core/textstream.py def get_status ( self ) -> str : \"\"\"Get current status. Possible values are \"ok\", \"read_past_end\", \"read_corrupt_data\", \"write_failed\" Returns: current status \"\"\" return STATUS . inverse [ self . status ()]","title":"get_status()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_field_alignment","text":"Set the field alignment. Valid values are \"left\", \"right\", \"center\", \"accounting_style\" Parameters: Name Type Description Default alignment str field alignment required Exceptions: Type Description InvalidParamError invalid field alignment Source code in prettyqt/core/textstream.py def set_field_alignment ( self , alignment : str ): \"\"\"Set the field alignment. Valid values are \"left\", \"right\", \"center\", \"accounting_style\" Args: alignment: field alignment Raises: InvalidParamError: invalid field alignment \"\"\" if alignment not in FIELD_ALIGNMENT : raise InvalidParamError ( alignment , FIELD_ALIGNMENT ) self . setFieldAlignment ( FIELD_ALIGNMENT [ alignment ])","title":"set_field_alignment()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_real_number_notation","text":"Set the real number notation. Valid values are \"scientific\", \"fixed\", \"smart\" Parameters: Name Type Description Default notation str real number notation required Exceptions: Type Description InvalidParamError invalid real number notation Source code in prettyqt/core/textstream.py def set_real_number_notation ( self , notation : str ): \"\"\"Set the real number notation. Valid values are \"scientific\", \"fixed\", \"smart\" Args: notation: real number notation Raises: InvalidParamError: invalid real number notation \"\"\" if notation not in REAL_NUMBER_NOTATION : raise InvalidParamError ( notation , REAL_NUMBER_NOTATION ) self . setRealNumberNotation ( REAL_NUMBER_NOTATION [ notation ])","title":"set_real_number_notation()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_status","text":"Set the status. Valid values are \"ok\", \"read_past_end\", \"read_corrupt_data\", \"write_failed\" Parameters: Name Type Description Default status str status required Exceptions: Type Description InvalidParamError invalid status Source code in prettyqt/core/textstream.py def set_status ( self , status : str ): \"\"\"Set the status. Valid values are \"ok\", \"read_past_end\", \"read_corrupt_data\", \"write_failed\" Args: status: status Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ])","title":"set_status()"},{"location":"api/core.html#prettyqt.core.time","text":"","title":"time"},{"location":"api/core.html#prettyqt.core.time.Time","text":"","title":"Time"},{"location":"api/core.html#prettyqt.core.time.Time.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/time.py def __reduce__ ( self ): return self . __class__ , ( self . hour (), self . minute (), self . second (), self . msec ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.timeline","text":"","title":"timeline"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine","text":"","title":"TimeLine"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_direction","text":"Return current direction. Returns: Type Description Literal['forward', 'backward'] direction Source code in prettyqt/core/timeline.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()]","title":"get_direction()"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_state","text":"Return current state. Returns: Type Description Literal['not_running', 'paused', 'running'] state Source code in prettyqt/core/timeline.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.set_direction","text":"Set the direction. Parameters: Name Type Description Default direction Literal['forward', 'backward'] direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/core/timeline.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ])","title":"set_direction()"},{"location":"api/core.html#prettyqt.core.timer","text":"","title":"timer"},{"location":"api/core.html#prettyqt.core.timer.Timer","text":"","title":"Timer"},{"location":"api/core.html#prettyqt.core.timer.Timer.get_type","text":"Return current timer type. Returns: Type Description TypeStr timer type Source code in prettyqt/core/timer.py def get_type ( self ) -> TypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return TYPE . inverse [ self . timerType ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.timer.Timer.set_type","text":"Set the timer type. Parameters: Name Type Description Default typ TypeStr timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/timer.py def set_type ( self , typ : TypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setTimerType ( TYPE [ typ ])","title":"set_type()"},{"location":"api/core.html#prettyqt.core.url","text":"","title":"url"},{"location":"api/core.html#prettyqt.core.url.Url","text":"","title":"Url"},{"location":"api/core.html#prettyqt.core.url.Url.to_path","text":"Get pathlib object from the URL. Returns: Type Description pathlib.Path Path Source code in prettyqt/core/url.py def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self ))","title":"to_path()"},{"location":"api/core.html#prettyqt.core.versionnumber","text":"","title":"versionnumber"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber","text":"","title":"VersionNumber"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.major","text":"An integer representing the major version. Source code in prettyqt/core/versionnumber.py def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion ()","title":"major()"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.micro","text":"An integer representing the micro version. Source code in prettyqt/core/versionnumber.py def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion ()","title":"micro()"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.minor","text":"An integer representing the minor version. Source code in prettyqt/core/versionnumber.py def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion ()","title":"minor()"},{"location":"api/custom_delegates.html","text":"custom_delegates module Module containing custom delegate classes. buttondelegate ButtonDelegate createEditor ( self , parent , option , index ) createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/buttondelegate.py def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn setEditorData ( self , editor , index ) setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setEditorData ( self , editor , index ): pass setModelData ( self , editor , model , index ) setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setModelData ( self , editor , model , index ): pass checkboxdelegate CheckBoxDelegate Delegate that places a CheckBox in every cell. createEditor ( self , parent , option , index ) Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. Source code in prettyqt/custom_delegates/checkboxdelegate.py def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb setEditorData ( self , cb , index ) Override. set correct initial value for editor widget Source code in prettyqt/custom_delegates/checkboxdelegate.py def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection ) setModelData ( self , combo , model , index ) Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. Source code in prettyqt/custom_delegates/checkboxdelegate.py def setModelData ( self , combo , model , index ): \"\"\"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. \"\"\" dtype = self . dtypes [ combo . currentText ()] # s = model.data(index, model.DATA_ROLE) try : model . setData ( index , dtype , model . DTYPE_ROLE ) except ValueError as e : logger . error ( e ) icondelegate IconDelegate paint ( self , painter , option , index ) Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Parameters: Name Type Description Default painter QPainter painter to paint the icon required option QStyleOptionViewItem state of the item to be displayed required index QModelIndex index which gets decorated required Source code in prettyqt/custom_delegates/icondelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if value : margin = 10 mode = gui . Icon . Normal if not ( option . state & widgets . Style . State_Enabled ): mode = gui . Icon . Disabled elif option . state & widgets . Style . State_Selected : mode = gui . Icon . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QIcon ): state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) actualSize = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = core . Size ( min ( option . decorationSize . width (), actualSize . width ()), min ( option . decorationSize . height (), actualSize . height ()), ) r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) icon . paint ( painter , r , constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER , mode , state ) nofocusdelegate NoFocusDelegate paint ( self , painter , option , index ) paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/nofocusdelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . State_HasFocus : option . state = option . state ^ widgets . Style . State_HasFocus super () . paint ( painter , option , index ) progressbardelegate ProgressBarDelegate paint ( self , painter , option , index ) paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/progressbardelegate.py def paint ( self , painter , option , index ): progress = index . data () progressBar_option = widgets . StyleOptionProgressBar () progressBar_option . rect = option . rect progressBar_option . minimum = 0 progressBar_option . maximum = 100 progressBar_option . progress = progress progressBar_option . text = f \" { progress } %\" progressBar_option . textVisible = True widgets . Application . style () . drawControl ( widgets . Style . CE_ProgressBar , progressBar_option , painter ) radiodelegate RadioDelegate createEditor ( self , parent , option , index ) createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/radiodelegate.py def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ) -> widgets . Widget : editor = widgets . Widget ( parent ) editor . set_margin ( 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . button_group = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . set_margin ( 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . set_focus_policy ( \"none\" ) rb . installEventFilter ( self ) editor . button_group . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) editor . installEventFilter ( self ) return editor eventFilter ( self , source , event ) eventFilter(self, QObject, QEvent) -> bool Source code in prettyqt/custom_delegates/radiodelegate.py def eventFilter ( self , source : QtWidgets . QWidget , event : QtCore . QEvent ) -> bool : if event . type () == core . Event . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event ) setEditorData ( self , editor , index ) setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setEditorData ( self , editor : QtWidgets . QWidget , index : QtCore . QModelIndex ): value = index . data ( QtCore . Qt . DisplayRole ) if value in self . items : editor . button_group . button ( self . items . index ( value )) . setChecked ( True ) setModelData ( self , editor , model , index ) setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setModelData ( self , editor : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , index : QtCore . QModelIndex , ): button = editor . button_group . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], QtCore . Qt . DisplayRole ) self . choices [ button ] = index . row () updateEditorGeometry ( self , editor , option , index ) updateEditorGeometry(self, QWidget, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def updateEditorGeometry ( self , editor : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): rect = core . Rect ( option . rect ) min_width = editor . minimumSizeHint () . width () if rect . width () < min_width : rect . setWidth ( min_width ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) editor . setMask ( mask ) stardelegate StarDelegate A delegate class that allows us to render our star ratings. createEditor ( self , parent , option , index ) Create and return the StarEditor object we'll use to edit the StarRating. Source code in prettyqt/custom_delegates/stardelegate.py def createEditor ( self , parent , option , index ): \"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\" editor = StarEditor ( parent ) editor . editing_finished . connect ( self . commitAndCloseEditor ) return editor paint ( self , painter , option , index ) paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter , option , index ): star_rating = StarRating ( index . data ()) # If the row is currently selected, we need to make sure we # paint the background accordingly. if option . state & widgets . Style . State_Selected : # The original C++ example used option.palette.foreground() to # get the brush for painting, but there are a couple of # problems with that: # - foreground() is obsolete now, use windowText() instead # - more importantly, windowText() just returns a brush # containing a flat color, where sometimes the style # would have a nice subtle gradient or something. # Here we just use the brush of the painter object that's # passed in to us, which keeps the row highlighting nice # and consistent. painter . fillRect ( option . rect , painter . brush ()) # Now that we've painted the background, call star_rating.paint() # to paint the stars. star_rating . paint ( painter , option . rect , option . palette ) setEditorData ( self , editor , index ) Set the data to be displayed and edited by our custom editor. Source code in prettyqt/custom_delegates/stardelegate.py def setEditorData ( self , editor , index ): \"\"\"Set the data to be displayed and edited by our custom editor.\"\"\" editor . set_star_rating ( index . data ()) setModelData ( self , editor , model , index ) Get the data from our custom editor and stuffs it into the model. Source code in prettyqt/custom_delegates/stardelegate.py def setModelData ( self , editor , model , index ): \"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\" if index . column () == 3 : model . setData ( index , editor . star_rating . star_count ) else : super () . setModelData ( self , editor , model , index ) sizeHint ( self , option , index ) Return the size needed to display the item in a QSize object. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self , option , index ): \"\"\"Return the size needed to display the item in a QSize object.\"\"\" star_rating = StarRating ( index . data ()) return star_rating . sizeHint () StarEditor The custom editor for editing StarRatings. __init__ ( self , parent = None ) special Initialize the editor object, making sure we can watch mouse events. Source code in prettyqt/custom_delegates/stardelegate.py def __init__ ( self , parent : QtWidgets . QWidget = None ): \"\"\"Initialize the editor object, making sure we can watch mouse events.\"\"\" super () . __init__ ( parent ) self . setMouseTracking ( True ) self . setAutoFillBackground ( True ) self . star_rating = StarRating () mouseMoveEvent ( self , event ) Update stars on mouse move. Source code in prettyqt/custom_delegates/stardelegate.py def mouseMoveEvent ( self , event ): \"\"\"Update stars on mouse move.\"\"\" star = self . star_at_position ( event . x ()) if star != - 1 : self . star_rating . star_count = star self . update () mouseReleaseEvent ( self , event ) Once star rating was clicked, tell the delegate we're done editing. Source code in prettyqt/custom_delegates/stardelegate.py def mouseReleaseEvent ( self , event ): \"\"\"Once star rating was clicked, tell the delegate we're done editing.\"\"\" self . editing_finished . emit () paintEvent ( self , event ) Paint the editor, offloading the work to the StarRating class. Source code in prettyqt/custom_delegates/stardelegate.py def paintEvent ( self , event ): \"\"\"Paint the editor, offloading the work to the StarRating class.\"\"\" painter = gui . Painter ( self ) self . star_rating . paint ( painter , self . rect (), self . palette (), is_editable = True ) sizeHint ( self ) Tell the caller how big we are. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self ): \"\"\"Tell the caller how big we are.\"\"\" return self . star_rating . sizeHint () star_at_position ( self , x ) Calculate which star the user's mouse cursor is currently hovering over. Source code in prettyqt/custom_delegates/stardelegate.py def star_at_position ( self , x : int ) -> int : \"\"\"Calculate which star the user's mouse cursor is currently hovering over.\"\"\" val = x // ( self . star_rating . sizeHint () . width () // self . star_rating . max_stars ) + 1 if not 0 < val <= self . star_rating . max_stars : return - 1 return val StarRating Handle the actual painting of the stars themselves. paint ( self , painter , rect , palette , is_editable = False ) Paint the stars (and/or diamonds if we're in editing mode). Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter : QtGui . QPainter , rect : QtCore . QRect , palette : QtGui . QPalette , is_editable : bool = False , ): \"\"\"Paint the stars (and/or diamonds if we're in editing mode).\"\"\" painter . save () painter . setRenderHint ( painter . Antialiasing , True ) painter . setPen ( QtCore . Qt . NoPen ) painter . setBrush ( palette . highlight () if is_editable else palette . windowText ()) y_offset = ( rect . height () - PAINTING_SCALE_FACTOR ) / 2 painter . translate ( rect . x (), rect . y () + y_offset ) painter . scale ( PAINTING_SCALE_FACTOR , PAINTING_SCALE_FACTOR ) for i in range ( self . max_stars ): if i < self . star_count : painter . drawPolygon ( self . star_polygon , QtCore . Qt . WindingFill ) elif is_editable : painter . drawPolygon ( self . diamond_polygon , QtCore . Qt . WindingFill ) painter . translate ( 1.0 , 0.0 ) painter . restore () sizeHint ( self ) Tell the caller how big we are. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self ): \"\"\"Tell the caller how big we are.\"\"\" return PAINTING_SCALE_FACTOR * core . Size ( self . max_stars , 1 )","title":"custom_delegates"},{"location":"api/custom_delegates.html#custom_delegates-module","text":"","title":"custom_delegates module"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates","text":"Module containing custom delegate classes.","title":"prettyqt.custom_delegates"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate","text":"","title":"buttondelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate","text":"","title":"ButtonDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.createEditor","text":"createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/buttondelegate.py def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setEditorData","text":"setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setEditorData ( self , editor , index ): pass","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setModelData","text":"setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setModelData ( self , editor , model , index ): pass","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate","text":"","title":"checkboxdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate","text":"Delegate that places a CheckBox in every cell.","title":"CheckBoxDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.createEditor","text":"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. Source code in prettyqt/custom_delegates/checkboxdelegate.py def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.setEditorData","text":"Override. set correct initial value for editor widget Source code in prettyqt/custom_delegates/checkboxdelegate.py def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection )","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.setModelData","text":"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. Source code in prettyqt/custom_delegates/checkboxdelegate.py def setModelData ( self , combo , model , index ): \"\"\"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. \"\"\" dtype = self . dtypes [ combo . currentText ()] # s = model.data(index, model.DATA_ROLE) try : model . setData ( index , dtype , model . DTYPE_ROLE ) except ValueError as e : logger . error ( e )","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate","text":"","title":"icondelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate","text":"","title":"IconDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate.paint","text":"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Parameters: Name Type Description Default painter QPainter painter to paint the icon required option QStyleOptionViewItem state of the item to be displayed required index QModelIndex index which gets decorated required Source code in prettyqt/custom_delegates/icondelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if value : margin = 10 mode = gui . Icon . Normal if not ( option . state & widgets . Style . State_Enabled ): mode = gui . Icon . Disabled elif option . state & widgets . Style . State_Selected : mode = gui . Icon . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QIcon ): state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) actualSize = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = core . Size ( min ( option . decorationSize . width (), actualSize . width ()), min ( option . decorationSize . height (), actualSize . height ()), ) r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) icon . paint ( painter , r , constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER , mode , state )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate","text":"","title":"nofocusdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate","text":"","title":"NoFocusDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate.paint","text":"paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/nofocusdelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . State_HasFocus : option . state = option . state ^ widgets . Style . State_HasFocus super () . paint ( painter , option , index )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate","text":"","title":"progressbardelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate.ProgressBarDelegate","text":"","title":"ProgressBarDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate.ProgressBarDelegate.paint","text":"paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/progressbardelegate.py def paint ( self , painter , option , index ): progress = index . data () progressBar_option = widgets . StyleOptionProgressBar () progressBar_option . rect = option . rect progressBar_option . minimum = 0 progressBar_option . maximum = 100 progressBar_option . progress = progress progressBar_option . text = f \" { progress } %\" progressBar_option . textVisible = True widgets . Application . style () . drawControl ( widgets . Style . CE_ProgressBar , progressBar_option , painter )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate","text":"","title":"radiodelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate","text":"","title":"RadioDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.createEditor","text":"createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/radiodelegate.py def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ) -> widgets . Widget : editor = widgets . Widget ( parent ) editor . set_margin ( 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . button_group = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . set_margin ( 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . set_focus_policy ( \"none\" ) rb . installEventFilter ( self ) editor . button_group . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) editor . installEventFilter ( self ) return editor","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.eventFilter","text":"eventFilter(self, QObject, QEvent) -> bool Source code in prettyqt/custom_delegates/radiodelegate.py def eventFilter ( self , source : QtWidgets . QWidget , event : QtCore . QEvent ) -> bool : if event . type () == core . Event . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event )","title":"eventFilter()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setEditorData","text":"setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setEditorData ( self , editor : QtWidgets . QWidget , index : QtCore . QModelIndex ): value = index . data ( QtCore . Qt . DisplayRole ) if value in self . items : editor . button_group . button ( self . items . index ( value )) . setChecked ( True )","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setModelData","text":"setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setModelData ( self , editor : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , index : QtCore . QModelIndex , ): button = editor . button_group . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], QtCore . Qt . DisplayRole ) self . choices [ button ] = index . row ()","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.updateEditorGeometry","text":"updateEditorGeometry(self, QWidget, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def updateEditorGeometry ( self , editor : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): rect = core . Rect ( option . rect ) min_width = editor . minimumSizeHint () . width () if rect . width () < min_width : rect . setWidth ( min_width ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) editor . setMask ( mask )","title":"updateEditorGeometry()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate","text":"","title":"stardelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate","text":"A delegate class that allows us to render our star ratings.","title":"StarDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.createEditor","text":"Create and return the StarEditor object we'll use to edit the StarRating. Source code in prettyqt/custom_delegates/stardelegate.py def createEditor ( self , parent , option , index ): \"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\" editor = StarEditor ( parent ) editor . editing_finished . connect ( self . commitAndCloseEditor ) return editor","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.paint","text":"paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter , option , index ): star_rating = StarRating ( index . data ()) # If the row is currently selected, we need to make sure we # paint the background accordingly. if option . state & widgets . Style . State_Selected : # The original C++ example used option.palette.foreground() to # get the brush for painting, but there are a couple of # problems with that: # - foreground() is obsolete now, use windowText() instead # - more importantly, windowText() just returns a brush # containing a flat color, where sometimes the style # would have a nice subtle gradient or something. # Here we just use the brush of the painter object that's # passed in to us, which keeps the row highlighting nice # and consistent. painter . fillRect ( option . rect , painter . brush ()) # Now that we've painted the background, call star_rating.paint() # to paint the stars. star_rating . paint ( painter , option . rect , option . palette )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setEditorData","text":"Set the data to be displayed and edited by our custom editor. Source code in prettyqt/custom_delegates/stardelegate.py def setEditorData ( self , editor , index ): \"\"\"Set the data to be displayed and edited by our custom editor.\"\"\" editor . set_star_rating ( index . data ())","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setModelData","text":"Get the data from our custom editor and stuffs it into the model. Source code in prettyqt/custom_delegates/stardelegate.py def setModelData ( self , editor , model , index ): \"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\" if index . column () == 3 : model . setData ( index , editor . star_rating . star_count ) else : super () . setModelData ( self , editor , model , index )","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.sizeHint","text":"Return the size needed to display the item in a QSize object. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self , option , index ): \"\"\"Return the size needed to display the item in a QSize object.\"\"\" star_rating = StarRating ( index . data ()) return star_rating . sizeHint ()","title":"sizeHint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor","text":"The custom editor for editing StarRatings.","title":"StarEditor"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.__init__","text":"Initialize the editor object, making sure we can watch mouse events. Source code in prettyqt/custom_delegates/stardelegate.py def __init__ ( self , parent : QtWidgets . QWidget = None ): \"\"\"Initialize the editor object, making sure we can watch mouse events.\"\"\" super () . __init__ ( parent ) self . setMouseTracking ( True ) self . setAutoFillBackground ( True ) self . star_rating = StarRating ()","title":"__init__()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.mouseMoveEvent","text":"Update stars on mouse move. Source code in prettyqt/custom_delegates/stardelegate.py def mouseMoveEvent ( self , event ): \"\"\"Update stars on mouse move.\"\"\" star = self . star_at_position ( event . x ()) if star != - 1 : self . star_rating . star_count = star self . update ()","title":"mouseMoveEvent()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.mouseReleaseEvent","text":"Once star rating was clicked, tell the delegate we're done editing. Source code in prettyqt/custom_delegates/stardelegate.py def mouseReleaseEvent ( self , event ): \"\"\"Once star rating was clicked, tell the delegate we're done editing.\"\"\" self . editing_finished . emit ()","title":"mouseReleaseEvent()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.paintEvent","text":"Paint the editor, offloading the work to the StarRating class. Source code in prettyqt/custom_delegates/stardelegate.py def paintEvent ( self , event ): \"\"\"Paint the editor, offloading the work to the StarRating class.\"\"\" painter = gui . Painter ( self ) self . star_rating . paint ( painter , self . rect (), self . palette (), is_editable = True )","title":"paintEvent()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.sizeHint","text":"Tell the caller how big we are. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self ): \"\"\"Tell the caller how big we are.\"\"\" return self . star_rating . sizeHint ()","title":"sizeHint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.star_at_position","text":"Calculate which star the user's mouse cursor is currently hovering over. Source code in prettyqt/custom_delegates/stardelegate.py def star_at_position ( self , x : int ) -> int : \"\"\"Calculate which star the user's mouse cursor is currently hovering over.\"\"\" val = x // ( self . star_rating . sizeHint () . width () // self . star_rating . max_stars ) + 1 if not 0 < val <= self . star_rating . max_stars : return - 1 return val","title":"star_at_position()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarRating","text":"Handle the actual painting of the stars themselves.","title":"StarRating"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarRating.paint","text":"Paint the stars (and/or diamonds if we're in editing mode). Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter : QtGui . QPainter , rect : QtCore . QRect , palette : QtGui . QPalette , is_editable : bool = False , ): \"\"\"Paint the stars (and/or diamonds if we're in editing mode).\"\"\" painter . save () painter . setRenderHint ( painter . Antialiasing , True ) painter . setPen ( QtCore . Qt . NoPen ) painter . setBrush ( palette . highlight () if is_editable else palette . windowText ()) y_offset = ( rect . height () - PAINTING_SCALE_FACTOR ) / 2 painter . translate ( rect . x (), rect . y () + y_offset ) painter . scale ( PAINTING_SCALE_FACTOR , PAINTING_SCALE_FACTOR ) for i in range ( self . max_stars ): if i < self . star_count : painter . drawPolygon ( self . star_polygon , QtCore . Qt . WindingFill ) elif is_editable : painter . drawPolygon ( self . diamond_polygon , QtCore . Qt . WindingFill ) painter . translate ( 1.0 , 0.0 ) painter . restore ()","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarRating.sizeHint","text":"Tell the caller how big we are. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self ): \"\"\"Tell the caller how big we are.\"\"\" return PAINTING_SCALE_FACTOR * core . Size ( self . max_stars , 1 )","title":"sizeHint()"},{"location":"api/custom_models.html","text":"custom_models module Custom_models module. Contains custom models columnitemmodel ColumnItem dataclass Determines how an object attribute is shown. ColumnItemModel Model that provides an interface to an objectree that is build of TreeItems. columnCount ( self , _parent = None ) Return the number of columns in the tree. Source code in prettyqt/custom_models/columnitemmodel.py def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols ) data ( self , index , role ) Return the tree item at the given index and role. Source code in prettyqt/custom_models/columnitemmodel.py def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: func = self . _attr_cols [ col ] . label if func is None : return \"\" attr = func ( tree_item ) return attr . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None flags ( self , index ) flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/custom_models/columnitemmodel.py def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN col = index . column () return self . _attr_cols [ col ] . get_flag () headerData ( self , section , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/columnitemmodel.py def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None importlibdistributionmodel ImportlibDistributionModel columnCount ( self , parent =< PyQt5 . QtCore . QModelIndex object at 0x7f3093c879e0 > ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def columnCount ( self , parent = core . ModelIndex ()): return len ( self . HEADER ) if not parent . isValid () else 0 data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Name\" ] elif index . column () == 1 : dist = self . distributions [ index . row ()] return dist . version elif index . column () == 2 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Summary\" ] elif index . column () == 3 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Home-Page\" ] elif index . column () == 4 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Author\" ] elif index . column () == 5 : dist = self . distributions [ index . row ()] return dist . metadata [ \"License\" ] elif role == constants . USER_ROLE : dist = self . distributions [ index . row ()] return dist headerData ( self , offset , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] rowCount ( self , parent =< PyQt5 . QtCore . QModelIndex object at 0x7f3093c87890 > ) rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def rowCount ( self , parent = core . ModelIndex ()): return len ( self . distributions ) if not parent . isValid () else 0 playlistmodel PlaylistModel columnCount ( self , parent = None ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/playlistmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER ) data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/playlistmodel.py def data ( self , index : core . ModelIndex , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if self . _playlist is None : return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : location = self . _playlist . media ( index . row ()) . canonicalUrl () return core . FileInfo ( location . path ()) . fileName () return None rowCount ( self , parent = None ) rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/playlistmodel.py def rowCount ( self , parent = None ): if self . _playlist is None : return 0 return len ( self . _playlist ) regexmatchesmodel RegexMatchesModel columnCount ( self , parent = None ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER ) data ( self , index , role ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span () headerData ( self , offset , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] rowCount ( self , parent = None ) Required override for AbstractitemModels. Source code in prettyqt/custom_models/regexmatchesmodel.py def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches ) transposeproxymodel TransposeProxyModel columnCount ( self , parent = None ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def columnCount ( self , parent : Optional [ core . ModelIndex ] = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . rowCount ( parent ) data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def data ( self , index : core . ModelIndex , role = QtCore . Qt . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role ) headerData ( self , section , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def headerData ( self , section : int , orientation , role ): return self . _source_model . headerData ( section , orientation , role ) index ( self , row , column , parent = None ) index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def index ( self , row : int , column : int , parent : Optional [ core . ModelIndex ] = None ) -> core . ModelIndex : return self . createIndex ( row , column ) mapFromSource ( self , source_index ) mapFromSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapFromSource ( self , source_index : core . ModelIndex ) -> core . ModelIndex : return self . index ( source_index . column (), source_index . row ()) mapToSource ( self , proxy_index ) mapToSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapToSource ( self , proxy_index : core . ModelIndex ) -> core . ModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ()) parent ( self , index ) parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/custom_models/transposeproxymodel.py def parent ( self , index : core . ModelIndex ): return None rowCount ( self , parent = None ) rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def rowCount ( self , parent : Optional [ core . ModelIndex ] = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . columnCount ( parent ) setSourceModel ( self , source_model ) setSourceModel(self, QAbstractItemModel) Source code in prettyqt/custom_models/transposeproxymodel.py def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"custom_models"},{"location":"api/custom_models.html#custom_models-module","text":"","title":"custom_models module"},{"location":"api/custom_models.html#prettyqt.custom_models","text":"Custom_models module. Contains custom models","title":"prettyqt.custom_models"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel","text":"","title":"columnitemmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItem","text":"Determines how an object attribute is shown.","title":"ColumnItem"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel","text":"Model that provides an interface to an objectree that is build of TreeItems.","title":"ColumnItemModel"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.columnCount","text":"Return the number of columns in the tree. Source code in prettyqt/custom_models/columnitemmodel.py def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.data","text":"Return the tree item at the given index and role. Source code in prettyqt/custom_models/columnitemmodel.py def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: func = self . _attr_cols [ col ] . label if func is None : return \"\" attr = func ( tree_item ) return attr . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.flags","text":"flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/custom_models/columnitemmodel.py def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN col = index . column () return self . _attr_cols [ col ] . get_flag ()","title":"flags()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/columnitemmodel.py def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel","text":"","title":"importlibdistributionmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel","text":"","title":"ImportlibDistributionModel"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def columnCount ( self , parent = core . ModelIndex ()): return len ( self . HEADER ) if not parent . isValid () else 0","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Name\" ] elif index . column () == 1 : dist = self . distributions [ index . row ()] return dist . version elif index . column () == 2 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Summary\" ] elif index . column () == 3 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Home-Page\" ] elif index . column () == 4 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Author\" ] elif index . column () == 5 : dist = self . distributions [ index . row ()] return dist . metadata [ \"License\" ] elif role == constants . USER_ROLE : dist = self . distributions [ index . row ()] return dist","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ]","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.rowCount","text":"rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def rowCount ( self , parent = core . ModelIndex ()): return len ( self . distributions ) if not parent . isValid () else 0","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.playlistmodel","text":"","title":"playlistmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.playlistmodel.PlaylistModel","text":"","title":"PlaylistModel"},{"location":"api/custom_models.html#prettyqt.custom_models.playlistmodel.PlaylistModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/playlistmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.playlistmodel.PlaylistModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/playlistmodel.py def data ( self , index : core . ModelIndex , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if self . _playlist is None : return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : location = self . _playlist . media ( index . row ()) . canonicalUrl () return core . FileInfo ( location . path ()) . fileName () return None","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.playlistmodel.PlaylistModel.rowCount","text":"rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/playlistmodel.py def rowCount ( self , parent = None ): if self . _playlist is None : return 0 return len ( self . _playlist )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel","text":"","title":"regexmatchesmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel","text":"","title":"RegexMatchesModel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span ()","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ]","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.rowCount","text":"Required override for AbstractitemModels. Source code in prettyqt/custom_models/regexmatchesmodel.py def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel","text":"","title":"transposeproxymodel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel","text":"","title":"TransposeProxyModel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def columnCount ( self , parent : Optional [ core . ModelIndex ] = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . rowCount ( parent )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.data","text":"data(self, QModelIndex, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def data ( self , index : core . ModelIndex , role = QtCore . Qt . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role )","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def headerData ( self , section : int , orientation , role ): return self . _source_model . headerData ( section , orientation , role )","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.index","text":"index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def index ( self , row : int , column : int , parent : Optional [ core . ModelIndex ] = None ) -> core . ModelIndex : return self . createIndex ( row , column )","title":"index()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapFromSource","text":"mapFromSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapFromSource ( self , source_index : core . ModelIndex ) -> core . ModelIndex : return self . index ( source_index . column (), source_index . row ())","title":"mapFromSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapToSource","text":"mapToSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapToSource ( self , proxy_index : core . ModelIndex ) -> core . ModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ())","title":"mapToSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.parent","text":"parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/custom_models/transposeproxymodel.py def parent ( self , index : core . ModelIndex ): return None","title":"parent()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.rowCount","text":"rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def rowCount ( self , parent : Optional [ core . ModelIndex ] = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . columnCount ( parent )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.setSourceModel","text":"setSourceModel(self, QAbstractItemModel) Source code in prettyqt/custom_models/transposeproxymodel.py def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"setSourceModel()"},{"location":"api/custom_validators.html","text":"custom_validators module Custom_validators module. Contains custom validators compositevalidator CompositeValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/compositevalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] return ( min ( vals ), text , pos ) notemptyvalidator NotEmptyValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notemptyvalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos ) notzerovalidator NotZeroValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notzerovalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"0\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos ) pathvalidator PathValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/pathvalidator.py def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return ( self . Acceptable , text , pos ) return ( self . Intermediate , text , pos ) regexpatternvalidator RegexPatternValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexpatternvalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : compiled = re . compile ( text ) except sre_constants . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return ( self . Intermediate , text , pos ) except re . _regex_core . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return ( self . Intermediate , text , pos ) else : self . error_occured . emit ( \"\" ) self . pattern_updated . emit ( compiled ) return ( self . Acceptable , text , pos ) regexvalidators BaseRegexValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexvalidators.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , partial = True ) if match is None : return ( self . Invalid , text , pos ) if match . partial : return ( self . Intermediate , text , pos ) else : return ( self . Acceptable , text , pos )","title":"custom_validators"},{"location":"api/custom_validators.html#custom_validators-module","text":"","title":"custom_validators module"},{"location":"api/custom_validators.html#prettyqt.custom_validators","text":"Custom_validators module. Contains custom validators","title":"prettyqt.custom_validators"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator","text":"","title":"compositevalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator","text":"","title":"CompositeValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/compositevalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] return ( min ( vals ), text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator","text":"","title":"notemptyvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator","text":"","title":"NotEmptyValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notemptyvalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator","text":"","title":"notzerovalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator","text":"","title":"NotZeroValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notzerovalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"0\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator","text":"","title":"pathvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator","text":"","title":"PathValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/pathvalidator.py def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return ( self . Acceptable , text , pos ) return ( self . Intermediate , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator","text":"","title":"regexpatternvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator","text":"","title":"RegexPatternValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexpatternvalidator.py def validate ( self , text : str , pos : int = 0 ) -> tuple : # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : compiled = re . compile ( text ) except sre_constants . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return ( self . Intermediate , text , pos ) except re . _regex_core . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return ( self . Intermediate , text , pos ) else : self . error_occured . emit ( \"\" ) self . pattern_updated . emit ( compiled ) return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators","text":"","title":"regexvalidators"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator","text":"","title":"BaseRegexValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexvalidators.py def validate ( self , text : str , pos : int = 0 ) -> tuple : if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , partial = True ) if match is None : return ( self . Invalid , text , pos ) if match . partial : return ( self . Intermediate , text , pos ) else : return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_widgets.html","text":"custom_widgets module Module containing custom widget classes. codeeditor CodeEditor resizeEvent ( self , event ) resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/codeeditor.py def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect ) LineNumberArea paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/codeeditor.py def paintEvent ( self , event ): self . editor . line_area_paintevent ( event ) sizeHint ( self ) sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/codeeditor.py def sizeHint ( self ) -> core . Size : return core . Size ( self . editor . line_area_width (), 0 ) dataset DataItem set_pos ( self , col = 0 , colspan = None ) Set data item's position on a GUI layout. Source code in prettyqt/custom_widgets/dataset.py def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self DataSetMeta __new__ ( mcs , name , bases , dct ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct ) filechooserbutton FileChooserButton __init__ ( self , extensions = None , mode = 'save' , file_mode = 'existing_files' , root = None , parent = None ) special Initialize FileChooserButton. Parameters: Name Type Description Default extensions Optional[Dict[str, List[str]]] dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode Literal['save', 'open'] Accept mode (\"save\" or \"load\") 'save' file_mode Literal['existing_file', 'existing_files', 'any_file', 'directory'] File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' root Union[NoneType, str, pathlib.Path] Root path None parent Optional[PyQt5.QtWidgets.QWidget] parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py def __init__ ( self , extensions : Optional [ Dict [ str , List [ str ]]] = None , mode : widgets . filedialog . AcceptModeStr = \"save\" , file_mode : widgets . filedialog . FileModeStr = \"existing_files\" , root : Union [ None , str , pathlib . Path ] = None , parent : Optional [ QtWidgets . QWidget ] = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : Optional [ pathlib . Path ] = None self . extensions = extensions self . mode : widgets . filedialog . AcceptModeStr = mode self . file_mode : widgets . filedialog . FileModeStr = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout += self . lineedit action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout += self . button flowlayout FlowLayout addItem ( self , item ) addItem(self, QLayoutItem) Source code in prettyqt/custom_widgets/flowlayout.py def addItem ( self , item : QtWidgets . QLayoutItem ): self . items . append ( item ) count ( self ) count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py def count ( self ) -> int : return len ( self . items ) expandingDirections ( self ) expandingDirections(self) -> Qt.Orientations Source code in prettyqt/custom_widgets/flowlayout.py def expandingDirections ( self ) -> QtCore . Qt . Orientations : return QtCore . Qt . Orientations ( 0 ) hasHeightForWidth ( self ) hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py def hasHeightForWidth ( self ) -> bool : return True heightForWidth ( self , width ) heightForWidth(self, int) -> int Source code in prettyqt/custom_widgets/flowlayout.py def heightForWidth ( self , width : int ) -> int : return self . do_layout ( QtCore . QRect ( 0 , 0 , width , 0 ), True ) itemAt ( self , index ) itemAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def itemAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: if 0 <= index < len ( self . items ): return self . items [ index ] return None minimumSize ( self ) minimumSize(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def minimumSize ( self ) -> QtCore . QSize : size = QtCore . QSize () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += QtCore . QSize ( margin_width , margin_width ) return size setGeometry ( self , rect ) setGeometry(self, QRect) Source code in prettyqt/custom_widgets/flowlayout.py def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False ) sizeHint ( self ) sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def sizeHint ( self ) -> QtCore . QSize : return self . minimumSize () takeAt ( self , index ) takeAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def takeAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None labeledslider LabeledSlider paintEvent ( self , e ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/labeledslider.py def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PM_SliderSpaceAvailable , st_slider , self . sl ) painter = gui . Painter ( self ) for v , v_str in self . levels : # get the size of the label rect = painter . get_text_rect ( v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc self . bottom_margin = max ( self . bottom_margin , rect . height ()) self . layout . adjust_margins () if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . layout . adjust_margins () else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . layout . adjust_margins () painter . drawText ( left , bottom , v_str ) popupinfo PopupInfo Dialog overlay to show some info to user. show ( self , * args , ** kwargs ) show(self) Source code in prettyqt/custom_widgets/popupinfo.py def show ( self , * args , ** kwargs ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) // 2 y = ( screen_geo . height () - size . height ()) // 2 self . move ( x , y - 200 ) super () . show ( * args , ** kwargs ) self . timer . start ( 2500 ) promptlineedit Credits to PyQode Authors. PromptLineEdit Extends QLineEdit to show a prompt text and a clear icon. prompt_text: str property writable Gets/Sets the prompt text. paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/promptlineedit.py def paintEvent ( self , event ): super () . paintEvent ( event ) if not ( self . _prompt_text and not self . text () and self . isEnabled ()): return None option = widgets . StyleOptionFrame () self . initStyleOption ( option ) left , top , right , bottom = self . getTextMargins () va = self . style () . visualAlignment ( self . layoutDirection (), self . alignment ()) rect = ( self . style () . subElementRect ( widgets . Style . SE_LineEditContents , option , self ) . adjusted ( 2 , 0 , 0 , 0 ) . adjusted ( left , top , - right , - bottom ) ) fm = self . get_font_metrics () text = fm . elided_text ( self . _prompt_text , mode = \"right\" , width = rect . width ()) with gui . Painter ( self ) as painter : color = self . get_palette () . get_color ( \"text\" , \"disabled\" ) painter . setPen ( color ) painter . drawText ( rect , va , text ) resizeEvent ( self , event ) resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/promptlineedit.py def resizeEvent ( self , event ): # Adjusts Clear button position super () . resizeEvent ( event ) self . button . resize ( self . _margin , self . height () - 2 ) self . button . move ( self . width () - self . _margin - 3 , 1 ) set_button_visible ( self , visible ) Sets the clear button as visible . Parameters: Name Type Description Default visible bool Visibility of button required Source code in prettyqt/custom_widgets/promptlineedit.py def set_button_visible ( self , visible : bool ): \"\"\"Sets the clear button as ``visible``. Args: visible (bool): Visibility of button \"\"\" self . button . setVisible ( visible ) left , top , right , bottom = self . getTextMargins () if visible : right = self . _margin + self . _spacing else : right = 0 self . setTextMargins ( left , top , right , bottom ) regexeditor special Module containing classes related to the RegEx editor. editor This module contains the editor widget implementation. quick_ref Contains the quick reference widget. roundprogressbar RoundProgressBar paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/roundprogressbar.py def paintEvent ( self , event : gui . PaintEvent ): outer_radius = min ( self . width (), self . height ()) rect = core . RectF ( 1 , 1 , outer_radius - 2 , outer_radius - 2 ) with gui . Painter ( self ) as painter : painter . use_antialiasing () if self . bar_style != \"line\" : self . _rebuild_data_brush_if_needed () bg_rect = core . RectF ( 0 , 0 , outer_radius , outer_radius ) painter . fillRect ( bg_rect , self . palette () . window ()) self . _draw_base ( painter , rect ) self . _draw_value ( painter , rect , self . current_value ) inner_rect , inner_radius = self . _calculate_inner_rect ( outer_radius ) self . _draw_inner_background ( painter , inner_rect ) self . _draw_text ( painter , inner_rect , inner_radius , self . current_value ) spanslider SpanSlider mouseMoveEvent ( self , event ) mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PM_MaximumDragDistance , opt , self ) new_pos = self . _pixel_pos_to_value ( self . pick ( event . pos ()) - self . offset ) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . pos ()): new_pos = self . position # pick the preferred handle on the first movement if self . first_movement : if self . lower == self . upper : if new_pos < self . lower_value : self . _swap_controls () self . first_movement = False else : self . first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper - 1 ) if self . movement == \"free\" and new_pos > self . upper : self . _swap_controls () self . set_upper_pos ( new_pos ) else : self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower : self . _swap_controls () self . set_lower_pos ( new_pos ) else : self . set_upper_pos ( new_pos ) event . accept () mousePressEvent ( self , event ) mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . handle_mouse_press ( event . pos (), self . upper_pressed , self . upper , \"upper\" ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . handle_mouse_press ( event . pos (), self . lower_pressed , self . lower , \"lower\" ) self . first_movement = True event . accept () mouseReleaseEvent ( self , event ) mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SC_None self . update () paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/spanslider.py def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SC_SliderTickmarks painter . drawComplexControl ( SLIDER_STYLE , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . drawComplexControl ( SLIDER_STYLE , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () rect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) if self . is_horizontal (): rect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) self . _draw_span ( painter , rect ) # handles if self . last_pressed == \"lower\" : self . draw_handle ( painter , \"upper\" ) self . draw_handle ( painter , \"lower\" ) else : self . draw_handle ( painter , \"lower\" ) self . draw_handle ( painter , \"upper\" ) set_movement_mode ( self , mode ) Set movement mode. Valid values: \"no_crossing\", \"no_overlap\", \"free\" Parameters: Name Type Description Default mode str movement mode for the main window required Exceptions: Type Description ValueError movement mode type does not exist Source code in prettyqt/custom_widgets/spanslider.py def set_movement_mode ( self , mode : str ): \"\"\"Set movement mode. Valid values: \"no_crossing\", \"no_overlap\", \"free\" Args: mode: movement mode for the main window Raises: ValueError: movement mode type does not exist \"\"\" if mode not in MOVEMENT_MODE : raise ValueError ( \"Invalid movement mode\" ) self . movement = mode trigger_action ( self , action , main ) Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Source code in prettyqt/custom_widgets/spanslider.py def trigger_action ( self , action : str , main : bool ): value = 0 no = False up = False my_min = self . minimum () my_max = self . maximum () self . block_tracking = True main_control = main and self . main_control == \"upper\" alt_control = not main and self . main_control == \"lower\" is_upper_handle = main_control or alt_control val = self . upper if is_upper_handle else self . lower if action == \"single_step_add\" : up = is_upper_handle value = clamp ( val + self . singleStep (), my_min , my_max ) elif action == \"single_step_sub\" : up = is_upper_handle value = clamp ( val - self . singleStep (), my_min , my_max ) elif action == \"to_minimum\" : value = my_min up = is_upper_handle elif action == \"to_maximum\" : value = my_max up = is_upper_handle elif action == \"move\" : up = is_upper_handle no = True elif action == \"none\" : no = True if not no and not up : if self . movement == \"no_crossing\" : value = min ( value , self . upper ) elif self . movement == \"no_overlap\" : value = min ( value , self . upper - 1 ) if self . movement == \"free\" and value > self . upper : self . _swap_controls () self . set_upper_pos ( value ) else : self . set_lower_pos ( value ) elif not no : if self . movement == \"no_crossing\" : value = max ( value , self . lower ) elif self . movement == \"no_overlap\" : value = max ( value , self . lower + 1 ) if self . movement == \"free\" and value < self . lower : self . _swap_controls () self . set_lower_pos ( value ) else : self . set_upper_pos ( value ) self . block_tracking = False self . set_lower_value ( self . lower_pos ) self . set_upper_value ( self . upper_pos ) timeline Timeline enterEvent ( self , e ) enterEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def enterEvent ( self , e ): self . _is_in = True leaveEvent ( self , e ) leaveEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def leaveEvent ( self , e ): self . _is_in = False self . update () mouseMoveEvent ( self , e ) mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseMoveEvent ( self , e ): self . _position = e . pos () # if mouse is being pressed, update pointer if self . _clicking : x = self . _position . x () self . position_changed . emit ( x ) self . _check_selection ( x ) self . pointer_time_pos = x * self . get_scale () self . update () mousePressEvent ( self , e ) mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mousePressEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : x = e . pos () . x () self . position_changed . emit ( x ) self . pointer_time_pos = x * self . get_scale () self . _check_selection ( x ) self . update () self . _clicking = True # Set clicking check to true mouseReleaseEvent ( self , e ) mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseReleaseEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : self . _clicking = False # Set clicking check to false paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/timeline.py def paintEvent ( self , event ): qp = gui . Painter () w = 0 # Draw time scale = self . get_scale () with qp . paint_on ( self ): qp . set_color ( self . text_color ) qp . setFont ( self . font ) qp . use_antialiasing () while w <= self . width (): time_string = self . get_time_string ( w * scale ) qp . drawText ( w - 50 , 0 , 100 , 100 , QtCore . Qt . AlignHCenter , time_string ) w += 100 # Draw down line qp . set_pen ( color = PEN_COLOR , width = 5 ) qp . drawLine ( 0 , 40 , self . width (), 40 ) # Draw dash lines point = 0 qp . set_pen ( color = self . text_color ) qp . drawLine ( 0 , 40 , self . width (), 40 ) while point <= self . width (): y2 = 30 if point % 30 != 0 else 20 qp . drawLine ( 3 * point , 40 , 3 * point , y2 ) point += 10 if self . _position is not None and self . _is_in : qp . drawLine ( self . _position . x (), 0 , self . _position . x (), 40 ) poly = gui . Polygon () if self . _position is not None : val = self . pointer_time_pos / self . get_scale () line = core . Line ( val , 40 , val , self . height ()) poly . add_points (( val - 10 , 20 ), ( val + 10 , 20 ), ( val , 40 )) else : line = core . Line ( 0 , 0 , 0 , self . height ()) poly . add_points (( - 10 , 20 ), ( 10 , 20 ), ( 0 , 40 )) # Draw samples t = 0.0 for sample in self . video_samples : scaled_dur = sample . duration / scale scaled_t = t / scale t += sample . duration # Clear clip path with qp . clip_path () as path : rect = core . RectF ( scaled_t , 50 , scaled_dur , 200 ) path . addRoundedRect ( rect , 10 , 10 ) # Draw sample path = gui . PainterPath () qp . set_pen ( color = sample . color ) rect = core . RectF ( scaled_t , 50 , scaled_dur , 50 ) path . addRoundedRect ( rect , 10 , 10 ) sample . start_pos = scaled_t sample . end_pos = scaled_t + scaled_dur qp . fillPath ( path , sample . color ) qp . drawPath ( path ) # Draw preview pictures if sample . picture is None : continue pic_width = sample . picture . size () . width () if pic_width < scaled_dur : width = pic_width pic = sample . picture else : width = scaled_dur pic = sample . picture . copy ( 0 , 0 , scaled_dur , 45 ) with qp . clip_path () as path : rect = core . RectF ( scaled_t , 52.5 , width , 45 ) path . addRoundedRect ( rect , 10 , 10 ) rect = core . Rect ( scaled_t , 52.5 , width , 45 ) qp . drawPixmap ( rect , pic ) # Clear clip path with qp . clip_path () as path : path . add_rect ( self . rect ()) # Draw pointer qp . set_color ( PEN_COLOR ) qp . set_brush ( PEN_COLOR ) qp . drawPolygon ( poly ) qp . drawLine ( line ) waitingspinner The MIT License (MIT). Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. BaseWaitingSpinner paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( style = \"none\" ) painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length ) rect = core . RectF ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) for i in range ( self . _line_num ): with painter . backup_state (): rotate_angle = 360 * i / self . _line_num painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . RelativeSize ) WaitingSpinner paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event )","title":"custom_widgets"},{"location":"api/custom_widgets.html#custom_widgets-module","text":"","title":"custom_widgets module"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets","text":"Module containing custom widget classes.","title":"prettyqt.custom_widgets"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor","text":"","title":"codeeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor","text":"","title":"CodeEditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor.resizeEvent","text":"resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/codeeditor.py def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea","text":"","title":"LineNumberArea"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/codeeditor.py def paintEvent ( self , event ): self . editor . line_area_paintevent ( event )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.sizeHint","text":"sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/codeeditor.py def sizeHint ( self ) -> core . Size : return core . Size ( self . editor . line_area_width (), 0 )","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset","text":"","title":"dataset"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem","text":"","title":"DataItem"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem.set_pos","text":"Set data item's position on a GUI layout. Source code in prettyqt/custom_widgets/dataset.py def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self","title":"set_pos()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta","text":"","title":"DataSetMeta"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct )","title":"__new__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton","text":"","title":"filechooserbutton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton","text":"","title":"FileChooserButton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton.__init__","text":"Initialize FileChooserButton. Parameters: Name Type Description Default extensions Optional[Dict[str, List[str]]] dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode Literal['save', 'open'] Accept mode (\"save\" or \"load\") 'save' file_mode Literal['existing_file', 'existing_files', 'any_file', 'directory'] File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' root Union[NoneType, str, pathlib.Path] Root path None parent Optional[PyQt5.QtWidgets.QWidget] parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py def __init__ ( self , extensions : Optional [ Dict [ str , List [ str ]]] = None , mode : widgets . filedialog . AcceptModeStr = \"save\" , file_mode : widgets . filedialog . FileModeStr = \"existing_files\" , root : Union [ None , str , pathlib . Path ] = None , parent : Optional [ QtWidgets . QWidget ] = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : Optional [ pathlib . Path ] = None self . extensions = extensions self . mode : widgets . filedialog . AcceptModeStr = mode self . file_mode : widgets . filedialog . FileModeStr = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout += self . lineedit action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout += self . button","title":"__init__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout","text":"","title":"flowlayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout","text":"","title":"FlowLayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.addItem","text":"addItem(self, QLayoutItem) Source code in prettyqt/custom_widgets/flowlayout.py def addItem ( self , item : QtWidgets . QLayoutItem ): self . items . append ( item )","title":"addItem()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.count","text":"count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py def count ( self ) -> int : return len ( self . items )","title":"count()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.expandingDirections","text":"expandingDirections(self) -> Qt.Orientations Source code in prettyqt/custom_widgets/flowlayout.py def expandingDirections ( self ) -> QtCore . Qt . Orientations : return QtCore . Qt . Orientations ( 0 )","title":"expandingDirections()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.hasHeightForWidth","text":"hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py def hasHeightForWidth ( self ) -> bool : return True","title":"hasHeightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.heightForWidth","text":"heightForWidth(self, int) -> int Source code in prettyqt/custom_widgets/flowlayout.py def heightForWidth ( self , width : int ) -> int : return self . do_layout ( QtCore . QRect ( 0 , 0 , width , 0 ), True )","title":"heightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.itemAt","text":"itemAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def itemAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: if 0 <= index < len ( self . items ): return self . items [ index ] return None","title":"itemAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.minimumSize","text":"minimumSize(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def minimumSize ( self ) -> QtCore . QSize : size = QtCore . QSize () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += QtCore . QSize ( margin_width , margin_width ) return size","title":"minimumSize()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.setGeometry","text":"setGeometry(self, QRect) Source code in prettyqt/custom_widgets/flowlayout.py def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False )","title":"setGeometry()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.sizeHint","text":"sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def sizeHint ( self ) -> QtCore . QSize : return self . minimumSize ()","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.takeAt","text":"takeAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def takeAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None","title":"takeAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider","text":"","title":"labeledslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider","text":"","title":"LabeledSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/labeledslider.py def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PM_SliderSpaceAvailable , st_slider , self . sl ) painter = gui . Painter ( self ) for v , v_str in self . levels : # get the size of the label rect = painter . get_text_rect ( v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc self . bottom_margin = max ( self . bottom_margin , rect . height ()) self . layout . adjust_margins () if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . layout . adjust_margins () else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . layout . adjust_margins () painter . drawText ( left , bottom , v_str )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo","text":"","title":"popupinfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo","text":"Dialog overlay to show some info to user.","title":"PopupInfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo.show","text":"show(self) Source code in prettyqt/custom_widgets/popupinfo.py def show ( self , * args , ** kwargs ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) // 2 y = ( screen_geo . height () - size . height ()) // 2 self . move ( x , y - 200 ) super () . show ( * args , ** kwargs ) self . timer . start ( 2500 )","title":"show()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit","text":"Credits to PyQode Authors.","title":"promptlineedit"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit","text":"Extends QLineEdit to show a prompt text and a clear icon.","title":"PromptLineEdit"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.prompt_text","text":"Gets/Sets the prompt text.","title":"prompt_text"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/promptlineedit.py def paintEvent ( self , event ): super () . paintEvent ( event ) if not ( self . _prompt_text and not self . text () and self . isEnabled ()): return None option = widgets . StyleOptionFrame () self . initStyleOption ( option ) left , top , right , bottom = self . getTextMargins () va = self . style () . visualAlignment ( self . layoutDirection (), self . alignment ()) rect = ( self . style () . subElementRect ( widgets . Style . SE_LineEditContents , option , self ) . adjusted ( 2 , 0 , 0 , 0 ) . adjusted ( left , top , - right , - bottom ) ) fm = self . get_font_metrics () text = fm . elided_text ( self . _prompt_text , mode = \"right\" , width = rect . width ()) with gui . Painter ( self ) as painter : color = self . get_palette () . get_color ( \"text\" , \"disabled\" ) painter . setPen ( color ) painter . drawText ( rect , va , text )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.resizeEvent","text":"resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/promptlineedit.py def resizeEvent ( self , event ): # Adjusts Clear button position super () . resizeEvent ( event ) self . button . resize ( self . _margin , self . height () - 2 ) self . button . move ( self . width () - self . _margin - 3 , 1 )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.set_button_visible","text":"Sets the clear button as visible . Parameters: Name Type Description Default visible bool Visibility of button required Source code in prettyqt/custom_widgets/promptlineedit.py def set_button_visible ( self , visible : bool ): \"\"\"Sets the clear button as ``visible``. Args: visible (bool): Visibility of button \"\"\" self . button . setVisible ( visible ) left , top , right , bottom = self . getTextMargins () if visible : right = self . _margin + self . _spacing else : right = 0 self . setTextMargins ( left , top , right , bottom )","title":"set_button_visible()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor","text":"Module containing classes related to the RegEx editor.","title":"regexeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.editor","text":"This module contains the editor widget implementation.","title":"editor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.quick_ref","text":"Contains the quick reference widget.","title":"quick_ref"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar","text":"","title":"roundprogressbar"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar.RoundProgressBar","text":"","title":"RoundProgressBar"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar.RoundProgressBar.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/roundprogressbar.py def paintEvent ( self , event : gui . PaintEvent ): outer_radius = min ( self . width (), self . height ()) rect = core . RectF ( 1 , 1 , outer_radius - 2 , outer_radius - 2 ) with gui . Painter ( self ) as painter : painter . use_antialiasing () if self . bar_style != \"line\" : self . _rebuild_data_brush_if_needed () bg_rect = core . RectF ( 0 , 0 , outer_radius , outer_radius ) painter . fillRect ( bg_rect , self . palette () . window ()) self . _draw_base ( painter , rect ) self . _draw_value ( painter , rect , self . current_value ) inner_rect , inner_radius = self . _calculate_inner_rect ( outer_radius ) self . _draw_inner_background ( painter , inner_rect ) self . _draw_text ( painter , inner_rect , inner_radius , self . current_value )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider","text":"","title":"spanslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider","text":"","title":"SpanSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseMoveEvent","text":"mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PM_MaximumDragDistance , opt , self ) new_pos = self . _pixel_pos_to_value ( self . pick ( event . pos ()) - self . offset ) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . pos ()): new_pos = self . position # pick the preferred handle on the first movement if self . first_movement : if self . lower == self . upper : if new_pos < self . lower_value : self . _swap_controls () self . first_movement = False else : self . first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper - 1 ) if self . movement == \"free\" and new_pos > self . upper : self . _swap_controls () self . set_upper_pos ( new_pos ) else : self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower : self . _swap_controls () self . set_lower_pos ( new_pos ) else : self . set_upper_pos ( new_pos ) event . accept ()","title":"mouseMoveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mousePressEvent","text":"mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . handle_mouse_press ( event . pos (), self . upper_pressed , self . upper , \"upper\" ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . handle_mouse_press ( event . pos (), self . lower_pressed , self . lower , \"lower\" ) self . first_movement = True event . accept ()","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseReleaseEvent","text":"mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SC_None self . update ()","title":"mouseReleaseEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/spanslider.py def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SC_SliderTickmarks painter . drawComplexControl ( SLIDER_STYLE , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . drawComplexControl ( SLIDER_STYLE , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () rect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) if self . is_horizontal (): rect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) self . _draw_span ( painter , rect ) # handles if self . last_pressed == \"lower\" : self . draw_handle ( painter , \"upper\" ) self . draw_handle ( painter , \"lower\" ) else : self . draw_handle ( painter , \"lower\" ) self . draw_handle ( painter , \"upper\" )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.set_movement_mode","text":"Set movement mode. Valid values: \"no_crossing\", \"no_overlap\", \"free\" Parameters: Name Type Description Default mode str movement mode for the main window required Exceptions: Type Description ValueError movement mode type does not exist Source code in prettyqt/custom_widgets/spanslider.py def set_movement_mode ( self , mode : str ): \"\"\"Set movement mode. Valid values: \"no_crossing\", \"no_overlap\", \"free\" Args: mode: movement mode for the main window Raises: ValueError: movement mode type does not exist \"\"\" if mode not in MOVEMENT_MODE : raise ValueError ( \"Invalid movement mode\" ) self . movement = mode","title":"set_movement_mode()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.trigger_action","text":"Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Source code in prettyqt/custom_widgets/spanslider.py def trigger_action ( self , action : str , main : bool ): value = 0 no = False up = False my_min = self . minimum () my_max = self . maximum () self . block_tracking = True main_control = main and self . main_control == \"upper\" alt_control = not main and self . main_control == \"lower\" is_upper_handle = main_control or alt_control val = self . upper if is_upper_handle else self . lower if action == \"single_step_add\" : up = is_upper_handle value = clamp ( val + self . singleStep (), my_min , my_max ) elif action == \"single_step_sub\" : up = is_upper_handle value = clamp ( val - self . singleStep (), my_min , my_max ) elif action == \"to_minimum\" : value = my_min up = is_upper_handle elif action == \"to_maximum\" : value = my_max up = is_upper_handle elif action == \"move\" : up = is_upper_handle no = True elif action == \"none\" : no = True if not no and not up : if self . movement == \"no_crossing\" : value = min ( value , self . upper ) elif self . movement == \"no_overlap\" : value = min ( value , self . upper - 1 ) if self . movement == \"free\" and value > self . upper : self . _swap_controls () self . set_upper_pos ( value ) else : self . set_lower_pos ( value ) elif not no : if self . movement == \"no_crossing\" : value = max ( value , self . lower ) elif self . movement == \"no_overlap\" : value = max ( value , self . lower + 1 ) if self . movement == \"free\" and value < self . lower : self . _swap_controls () self . set_lower_pos ( value ) else : self . set_upper_pos ( value ) self . block_tracking = False self . set_lower_value ( self . lower_pos ) self . set_upper_value ( self . upper_pos )","title":"trigger_action()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline","text":"","title":"timeline"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline","text":"","title":"Timeline"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.enterEvent","text":"enterEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def enterEvent ( self , e ): self . _is_in = True","title":"enterEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.leaveEvent","text":"leaveEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def leaveEvent ( self , e ): self . _is_in = False self . update ()","title":"leaveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mouseMoveEvent","text":"mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseMoveEvent ( self , e ): self . _position = e . pos () # if mouse is being pressed, update pointer if self . _clicking : x = self . _position . x () self . position_changed . emit ( x ) self . _check_selection ( x ) self . pointer_time_pos = x * self . get_scale () self . update ()","title":"mouseMoveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mousePressEvent","text":"mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mousePressEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : x = e . pos () . x () self . position_changed . emit ( x ) self . pointer_time_pos = x * self . get_scale () self . _check_selection ( x ) self . update () self . _clicking = True # Set clicking check to true","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mouseReleaseEvent","text":"mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseReleaseEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : self . _clicking = False # Set clicking check to false","title":"mouseReleaseEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/timeline.py def paintEvent ( self , event ): qp = gui . Painter () w = 0 # Draw time scale = self . get_scale () with qp . paint_on ( self ): qp . set_color ( self . text_color ) qp . setFont ( self . font ) qp . use_antialiasing () while w <= self . width (): time_string = self . get_time_string ( w * scale ) qp . drawText ( w - 50 , 0 , 100 , 100 , QtCore . Qt . AlignHCenter , time_string ) w += 100 # Draw down line qp . set_pen ( color = PEN_COLOR , width = 5 ) qp . drawLine ( 0 , 40 , self . width (), 40 ) # Draw dash lines point = 0 qp . set_pen ( color = self . text_color ) qp . drawLine ( 0 , 40 , self . width (), 40 ) while point <= self . width (): y2 = 30 if point % 30 != 0 else 20 qp . drawLine ( 3 * point , 40 , 3 * point , y2 ) point += 10 if self . _position is not None and self . _is_in : qp . drawLine ( self . _position . x (), 0 , self . _position . x (), 40 ) poly = gui . Polygon () if self . _position is not None : val = self . pointer_time_pos / self . get_scale () line = core . Line ( val , 40 , val , self . height ()) poly . add_points (( val - 10 , 20 ), ( val + 10 , 20 ), ( val , 40 )) else : line = core . Line ( 0 , 0 , 0 , self . height ()) poly . add_points (( - 10 , 20 ), ( 10 , 20 ), ( 0 , 40 )) # Draw samples t = 0.0 for sample in self . video_samples : scaled_dur = sample . duration / scale scaled_t = t / scale t += sample . duration # Clear clip path with qp . clip_path () as path : rect = core . RectF ( scaled_t , 50 , scaled_dur , 200 ) path . addRoundedRect ( rect , 10 , 10 ) # Draw sample path = gui . PainterPath () qp . set_pen ( color = sample . color ) rect = core . RectF ( scaled_t , 50 , scaled_dur , 50 ) path . addRoundedRect ( rect , 10 , 10 ) sample . start_pos = scaled_t sample . end_pos = scaled_t + scaled_dur qp . fillPath ( path , sample . color ) qp . drawPath ( path ) # Draw preview pictures if sample . picture is None : continue pic_width = sample . picture . size () . width () if pic_width < scaled_dur : width = pic_width pic = sample . picture else : width = scaled_dur pic = sample . picture . copy ( 0 , 0 , scaled_dur , 45 ) with qp . clip_path () as path : rect = core . RectF ( scaled_t , 52.5 , width , 45 ) path . addRoundedRect ( rect , 10 , 10 ) rect = core . Rect ( scaled_t , 52.5 , width , 45 ) qp . drawPixmap ( rect , pic ) # Clear clip path with qp . clip_path () as path : path . add_rect ( self . rect ()) # Draw pointer qp . set_color ( PEN_COLOR ) qp . set_brush ( PEN_COLOR ) qp . drawPolygon ( poly ) qp . drawLine ( line )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner","text":"The MIT License (MIT). Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"waitingspinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner","text":"","title":"BaseWaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( style = \"none\" ) painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length ) rect = core . RectF ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) for i in range ( self . _line_num ): with painter . backup_state (): rotate_angle = 360 * i / self . _line_num painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . RelativeSize )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner","text":"","title":"WaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event )","title":"paintEvent()"},{"location":"api/gui.html","text":"gui module Gui module. Contains QtGui-based classes color Color __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/color.py def __reduce__ ( self ): return self . __class__ , ( self . red (), self . green (), self . blue (), self . alpha ()) from_text ( text ) classmethod Create a QColor from specified string. Source code in prettyqt/gui/color.py @classmethod def from_text ( cls , text ): \"\"\"Create a QColor from specified string.\"\"\" color = cls () text = str ( text ) if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color colorspace ColorSpace get_primaries ( self ) Return current primaries. Possible values: \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Returns: Type Description str primaries Source code in prettyqt/gui/colorspace.py def get_primaries ( self ) -> str : \"\"\"Return current primaries. Possible values: \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Returns: primaries \"\"\" return PRIMARIES . inverse [ self . primaries ()] get_transfer_function ( self ) Return current transfer function. Possible values: \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Returns: Type Description str transfer function Source code in prettyqt/gui/colorspace.py def get_transfer_function ( self ) -> str : \"\"\"Return current transfer function. Possible values: \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Returns: transfer function \"\"\" return TRANSFER_FUNCTION . inverse [ self . transferFunction ()] set_primaries ( self , primaries ) Set primaries. Allowed values are \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Parameters: Name Type Description Default primaries str primaries to use required Exceptions: Type Description InvalidParamError primaries do not exist Source code in prettyqt/gui/colorspace.py def set_primaries ( self , primaries : str ): \"\"\"Set primaries. Allowed values are \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Args: primaries: primaries to use Raises: InvalidParamError: primaries do not exist \"\"\" if primaries not in PRIMARIES : raise InvalidParamError ( primaries , PRIMARIES ) self . setPrimaries ( PRIMARIES [ primaries ]) set_transfer_function ( self , fn , gamma = 0.0 ) Set transfer function. Allowed values are \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Parameters: Name Type Description Default fn str transfer function to use required Exceptions: Type Description InvalidParamError transfer function do not exist Source code in prettyqt/gui/colorspace.py def set_transfer_function ( self , fn : str , gamma : float = 0.0 ): \"\"\"Set transfer function. Allowed values are \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Args: fn: transfer function to use Raises: InvalidParamError: transfer function do not exist \"\"\" if fn not in TRANSFER_FUNCTION : raise InvalidParamError ( fn , TRANSFER_FUNCTION ) self . setTransferFunction ( TRANSFER_FUNCTION [ fn ], gamma ) cursor Cursor get_shape ( self ) Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: Type Description str cursor shape Source code in prettyqt/gui/cursor.py def get_shape ( self ) -> str : \"\"\"Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: cursor shape \"\"\" return SHAPES . inverse [ self . shape ()] set_shape ( self , shape ) Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Parameters: Name Type Description Default shape str shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/gui/cursor.py def set_shape ( self , shape : str ): \"\"\"Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in SHAPES : raise InvalidParamError ( shape , SHAPES ) self . setShape ( SHAPES [ shape ]) font Font get_capitalization ( self ) Get current font capitalization. Possible values are \"mixed_case\", \"all_uppercase\", all_lowercase\", \"small_caps\", \"capitalize\" Returns: Type Description str current font capitalization Source code in prettyqt/gui/font.py def get_capitalization ( self ) -> str : \"\"\"Get current font capitalization. Possible values are \"mixed_case\", \"all_uppercase\", all_lowercase\", \"small_caps\", \"capitalize\" Returns: current font capitalization \"\"\" return CAPITALIZATION . inverse [ self . capitalization ()] get_hinting_preference ( self ) Get current hinting preference. Possible values are \"default\", \"none\", \"vertical\", \"full\" Returns: Type Description str current hinting preference Source code in prettyqt/gui/font.py def get_hinting_preference ( self ) -> str : \"\"\"Get current hinting preference. Possible values are \"default\", \"none\", \"vertical\", \"full\" Returns: current hinting preference \"\"\" return HINTING_PREFERENCE . inverse [ self . hintingPreference ()] get_letter_spacing_type ( self ) Get current letter spacing type. Possible values are \"percentage\", \"absolute\" Returns: Type Description str current letter spacing type Source code in prettyqt/gui/font.py def get_letter_spacing_type ( self ) -> str : \"\"\"Get current letter spacing type. Possible values are \"percentage\", \"absolute\" Returns: current letter spacing type \"\"\" return SPACING_TYPE . inverse [ self . letterSpacingType ()] get_style ( self ) Get current font style. Possible values are \"normal\", \"italic\", \"oblique\" Returns: Type Description str current font style Source code in prettyqt/gui/font.py def get_style ( self ) -> str : \"\"\"Get current font style. Possible values are \"normal\", \"italic\", \"oblique\" Returns: current font style \"\"\" return STYLE . inverse [ self . style ()] get_weight ( self ) Get current font weight. Possible values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Returns: Type Description str current font weight Source code in prettyqt/gui/font.py def get_weight ( self ) -> str : \"\"\"Get current font weight. Possible values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Returns: current font weight \"\"\" return WEIGHTS . inverse [ self . weight ()] set_capitalization ( self , capitalization ) Set the font capitalization. Valid values are \"mixed_case\", \"all_uppercase\", all_lowercase\", \"small_caps\", \"capitalize\" Parameters: Name Type Description Default capitalization str font capitalization required Exceptions: Type Description InvalidParamError invalid font capitalization Source code in prettyqt/gui/font.py def set_capitalization ( self , capitalization : str ): \"\"\"Set the font capitalization. Valid values are \"mixed_case\", \"all_uppercase\", all_lowercase\", \"small_caps\", \"capitalize\" Args: capitalization: font capitalization Raises: InvalidParamError: invalid font capitalization \"\"\" if capitalization not in CAPITALIZATION : raise InvalidParamError ( capitalization , CAPITALIZATION ) self . setCapitalization ( CAPITALIZATION [ capitalization ]) set_hinting_preference ( self , preference ) Set the hinting preference. Valid values are \"default\", \"none\", \"vertical\", \"full\" Parameters: Name Type Description Default preference str hinting preference required Exceptions: Type Description InvalidParamError invalid hinting preference Source code in prettyqt/gui/font.py def set_hinting_preference ( self , preference : str ): \"\"\"Set the hinting preference. Valid values are \"default\", \"none\", \"vertical\", \"full\" Args: preference: hinting preference Raises: InvalidParamError: invalid hinting preference \"\"\" if preference not in HINTING_PREFERENCE : raise InvalidParamError ( preference , HINTING_PREFERENCE ) self . setHintingPreference ( HINTING_PREFERENCE [ preference ]) set_letter_spacing ( self , typ , spacing ) Set the letter spacing. Valid values are \"percentage\", \"absolute\" Parameters: Name Type Description Default typ str letter spacing type required spacing float spacing required Exceptions: Type Description InvalidParamError invalid letter spacing type Source code in prettyqt/gui/font.py def set_letter_spacing ( self , typ : str , spacing : float ): \"\"\"Set the letter spacing. Valid values are \"percentage\", \"absolute\" Args: typ: letter spacing type spacing: spacing Raises: InvalidParamError: invalid letter spacing type \"\"\" if typ not in SPACING_TYPE : raise InvalidParamError ( typ , SPACING_TYPE ) self . setLetterSpacing ( SPACING_TYPE [ typ ], spacing ) set_style ( self , style ) Set the font style. Valid values are \"normal\", \"italic\", \"oblique\" Parameters: Name Type Description Default style str font style required Exceptions: Type Description InvalidParamError invalid font style Source code in prettyqt/gui/font.py def set_style ( self , style : str ): \"\"\"Set the font style. Valid values are \"normal\", \"italic\", \"oblique\" Args: style: font style Raises: InvalidParamError: invalid font style \"\"\" if style not in STYLE : raise InvalidParamError ( style , STYLE ) self . setStyle ( STYLE [ style ]) set_style_hint ( self , hint ) Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str style hint required Exceptions: Type Description InvalidParamError invalid style hint Source code in prettyqt/gui/font.py def set_style_hint ( self , hint : str ): \"\"\"Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ]) set_weight ( self , weight ) Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/font.py def set_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) self . setWeight ( WEIGHTS [ weight ]) gradient Gradient get_coordinate_mode ( self ) Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: Type Description str coordinate mode Source code in prettyqt/gui/gradient.py def get_coordinate_mode ( self ) -> str : \"\"\"Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: coordinate mode \"\"\" return COORDINATE_MODES . inverse [ self . coordinateMode ()] get_spread ( self ) Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: Type Description str spread method Source code in prettyqt/gui/gradient.py def get_spread ( self ) -> str : \"\"\"Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: spread method \"\"\" return SPREADS . inverse [ self . spread ()] get_type ( self ) Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: Type Description str gradient type Source code in prettyqt/gui/gradient.py def get_type ( self ) -> str : \"\"\"Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: gradient type \"\"\" return TYPES . inverse [ self . type ()] set_coordinate_mode ( self , mode ) Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Parameters: Name Type Description Default mode str coordinate mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/gradient.py def set_coordinate_mode ( self , mode : str ): \"\"\"Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODES : raise InvalidParamError ( mode , COORDINATE_MODES ) self . setCoordinateMode ( COORDINATE_MODES [ mode ]) set_spread ( self , method ) Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Parameters: Name Type Description Default method str spread method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/gui/gradient.py def set_spread ( self , method : str ): \"\"\"Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREADS : raise InvalidParamError ( method , SPREADS ) self . setSpread ( SPREADS [ method ]) guiapplication GuiApplication copy_to_clipboard ( text ) classmethod Sets clipboard to supplied text. Source code in prettyqt/gui/guiapplication.py @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Clipboard ) cb . setText ( text , mode = cb . Clipboard ) get_application_state () classmethod Get the current application state. Returns: Type Description List[Literal['suspended', 'hidden', 'inactive', 'active']] application state Source code in prettyqt/gui/guiapplication.py @classmethod def get_application_state ( cls ) -> List [ ApplicationStateStr ]: \"\"\"Get the current application state. Returns: application state \"\"\" return [ k for k , v in APPLICATION_STATES . items () if v & cls . applicationState ()] get_layout_direction ( self ) Get the current layout direction. Returns: Type Description Literal['left_to_right', 'right_to_left', 'auto'] layout direction Source code in prettyqt/gui/guiapplication.py def get_layout_direction ( self ) -> LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return LAYOUT_DIRECTION . inverse [ self . layoutDirection ()] set_icon ( self , icon ) Set the default window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/gui/guiapplication.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) set_layout_direction ( self , direction ) Set layout direction. Parameters: Name Type Description Default direction Literal['left_to_right', 'right_to_left', 'auto'] layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/guiapplication.py def set_layout_direction ( self , direction : LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in LAYOUT_DIRECTION : raise InvalidParamError ( direction , LAYOUT_DIRECTION ) self . setLayoutDirection ( LAYOUT_DIRECTION [ direction ]) icon get_icon ( icon , color = None , as_qicon = False ) Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. Source code in prettyqt/gui/icon.py def get_icon ( icon : IconType , color : Optional [ str ] = None , as_qicon : bool = False ) -> QtGui . QIcon : \"\"\"Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. \"\"\" if isinstance ( icon , QtGui . QIcon ): return icon if as_qicon else Icon ( icon ) if isinstance ( icon , pathlib . Path ): icon = str ( icon ) if ( icon , color , as_qicon ) in icon_cache : return icon_cache [( icon , color , as_qicon )] if isinstance ( icon , str ) and icon . startswith ( \"mdi.\" ): if color is not None : new = qta . icon ( icon , color = color ) else : new = qta . icon ( icon ) else : new = QtGui . QIcon ( icon ) icon = new if as_qicon else Icon ( new ) icon_cache [( icon , color , as_qicon )] = icon return icon imageiohandler ImageIOHandler get_option ( self , option ) Return the value assigned to option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Parameters: Name Type Description Default option str option to get required Returns: Type Description Any option Source code in prettyqt/gui/imageiohandler.py def get_option ( self , option : str ) -> Any : \"\"\"Return the value assigned to option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Args: option: option to get Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . option ( IMAGE_OPTION [ option ]) set_option ( self , option , value ) Set option to given value. Allowed values are \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Parameters: Name Type Description Default option str option to use required value value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/gui/imageiohandler.py def set_option ( self , option : str , value ): \"\"\"Set option to given value. Allowed values are \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) self . setOption ( IMAGE_OPTION [ option ], value ) supports_option ( self , option ) Return whether the image handler supports given option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Parameters: Name Type Description Default option str option to check required Returns: Type Description bool option Source code in prettyqt/gui/imageiohandler.py def supports_option ( self , option : str ) -> bool : \"\"\"Return whether the image handler supports given option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Args: option: option to check Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . supportsOption ( IMAGE_OPTION [ option ]) imagereader ImageReader get_error ( self ) Return error type. possible values are \"file_not_found\", \"device\", \"unsupported_format\", \"invalid_image\", \"unknown\" Returns: Type Description str error type Source code in prettyqt/gui/imagereader.py def get_error ( self ) -> str : \"\"\"Return error type. possible values are \"file_not_found\", \"device\", \"unsupported_format\", \"invalid_image\", \"unknown\" Returns: error type \"\"\" return IMAGE_READER_ERROR . inverse [ self . error ()] get_transformation ( self ) Return the transformation and orientation the image has been set to. Possible values: \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Returns: Type Description str transformation Source code in prettyqt/gui/imagereader.py def get_transformation ( self ) -> str : \"\"\"Return the transformation and orientation the image has been set to. Possible values: \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Returns: transformation \"\"\" return TRANSFORMATIONS . inverse [ self . transformation ()] supports_option ( self , option ) Return whether the image handler supports given option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quallity\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Parameters: Name Type Description Default option str option to check required Returns: Type Description bool option Source code in prettyqt/gui/imagereader.py def supports_option ( self , option : str ) -> bool : \"\"\"Return whether the image handler supports given option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quallity\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Args: option: option to check Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . supportsOption ( IMAGE_OPTION [ option ]) imagewriter ImageWriter get_error ( self ) Return error type. possible values are \"device\", \"unsupported_format\", \"invalid_image\", \"unknown\" Returns: Type Description str error type Source code in prettyqt/gui/imagewriter.py def get_error ( self ) -> str : \"\"\"Return error type. possible values are \"device\", \"unsupported_format\", \"invalid_image\", \"unknown\" Returns: error type \"\"\" return IMAGE_WRITER_ERROR . inverse [ self . error ()] get_transformation ( self ) Return the transformation and orientation the image has been set to. Possible values: \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Returns: Type Description str transformation Source code in prettyqt/gui/imagewriter.py def get_transformation ( self ) -> str : \"\"\"Return the transformation and orientation the image has been set to. Possible values: \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Returns: transformation \"\"\" return TRANSFORMATIONS . inverse [ self . transformation ()] set_transformation ( self , origin ) Set the image transformations metadata including orientation. Allowed values are \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Parameters: Name Type Description Default origin str transformation to use required Exceptions: Type Description InvalidParamError transformation does not exist Source code in prettyqt/gui/imagewriter.py def set_transformation ( self , origin : str ): \"\"\"Set the image transformations metadata including orientation. Allowed values are \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Args: origin: transformation to use Raises: InvalidParamError: transformation does not exist \"\"\" if origin not in TRANSFORMATIONS : raise InvalidParamError ( origin , TRANSFORMATIONS ) self . setTransformation ( TRANSFORMATIONS [ origin ]) keysequence KeySequence __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/keysequence.py def __reduce__ ( self ): return self . __class__ , ( self . toString (),) movie Movie get_cache_mode ( self ) Get the current cache mode. Possible values: \"none\", \"all\" Returns: Type Description str cache mode Source code in prettyqt/gui/movie.py def get_cache_mode ( self ) -> str : \"\"\"Get the current cache mode. Possible values: \"none\", \"all\" Returns: cache mode \"\"\" return CACHE_MODES . inverse [ self . cacheMode ()] set_cache_mode ( self , mode ) Set cache mode. Valid values for cache_mode: \"none\", \"all\" Parameters: Name Type Description Default mode str cache mode required Exceptions: Type Description InvalidParamError cache mode does not exist Source code in prettyqt/gui/movie.py def set_cache_mode ( self , mode : str ): \"\"\"Set cache mode. Valid values for cache_mode: \"none\", \"all\" Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ]) openglwindow OpenGLWindow get_update_behaviour ( self ) Get the window update hehaviour. Possible values: \"no_partial\", \"partial_blit\", \"partial_blend\" Returns: Type Description str update behaviour Source code in prettyqt/gui/openglwindow.py def get_update_behaviour ( self ) -> str : \"\"\"Get the window update hehaviour. Possible values: \"no_partial\", \"partial_blit\", \"partial_blend\" Returns: update behaviour \"\"\" return UPDATE_BEHAVIOUR . inverse [ self . updateBehavior ()] pagelayout PageLayout get_mode ( self ) Get the current mode. Possible values: \"standard\", \"full_page\" Returns: Type Description str mode Source code in prettyqt/gui/pagelayout.py def get_mode ( self ) -> str : \"\"\"Get the current mode. Possible values: \"standard\", \"full_page\" Returns: mode \"\"\" return MODES . inverse [ self . mode ()] get_orientation ( self ) Get the current orientation. Possible values: \"portrait\", \"landscape\" Returns: Type Description str orientation Source code in prettyqt/gui/pagelayout.py def get_orientation ( self ) -> str : \"\"\"Get the current orientation. Possible values: \"portrait\", \"landscape\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()] get_units ( self ) Get the current unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: Type Description str unit Source code in prettyqt/gui/pagelayout.py def get_units ( self ) -> str : \"\"\"Get the current unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: unit \"\"\" return UNITS . inverse [ self . units ()] set_mode ( self , mode ) Set mode. Valid values for mode: \"standard\", \"full_page\" Parameters: Name Type Description Default mode str mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/pagelayout.py def set_mode ( self , mode : str ): \"\"\"Set mode. Valid values for mode: \"standard\", \"full_page\" Args: mode: mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setMode ( MODES [ mode ]) set_orientation ( self , orientation ) Set orientation. Valid values for orientation: \"portrait\", \"landscape\" Parameters: Name Type Description Default orientation str orientation required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/gui/pagelayout.py def set_orientation ( self , orientation : str ): \"\"\"Set orientation. Valid values for orientation: \"portrait\", \"landscape\" Args: orientation: orientation Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) set_units ( self , unit ) Set unit. Valid values for units: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Parameters: Name Type Description Default unit str unit required Exceptions: Type Description InvalidParamError unit does not exist Source code in prettyqt/gui/pagelayout.py def set_units ( self , unit : str ): \"\"\"Set unit. Valid values for units: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Args: unit: unit Raises: InvalidParamError: unit does not exist \"\"\" if unit not in UNITS : raise InvalidParamError ( unit , UNITS ) self . setUnits ( UNITS [ unit ]) pagesize PageSize get_definition_units ( self ) Get the definition unit. Returns: Type Description Literal['millimeter', 'point', 'inch', 'pica', 'didot', 'cicero'] unit Source code in prettyqt/gui/pagesize.py def get_definition_units ( self ) -> UnitStr : \"\"\"Get the definition unit. Returns: unit \"\"\" units = self . definitionUnits () if units == - 1 : raise ValueError ( \"Invalid page size\" ) return UNITS . inverse [ units ] get_id ( self ) Get the standard page size id. Returns: Type Description str page size id Source code in prettyqt/gui/pagesize.py def get_id ( self ) -> str : \"\"\"Get the standard page size id. Returns: page size id \"\"\" return PAGE_SIZE_ID . inverse [ self . id ()] paintdevice PaintDevice get_metric ( self , metric ) Return metric information. Possible values: \"center\", \"on_value\" Parameters: Name Type Description Default metric str metric information to get required Returns: Type Description int metric information Source code in prettyqt/gui/paintdevice.py def get_metric ( self , metric : str ) -> int : \"\"\"Return metric information. Possible values: \"center\", \"on_value\" Args: metric: metric information to get Returns: metric information \"\"\" if metric not in METRICS : raise InvalidParamError ( metric , METRICS ) return self . metric ( METRICS [ metric ]) painter Painter get_composition_mode ( self ) Get the current composition mode. Returns: Type Description Literal['source_over', 'destination_over', 'clear', 'source', 'destination', 'source_in', 'destination_in', 'source_out', 'destination_out', 'source_atop', 'destination_atop'] composition mode Source code in prettyqt/gui/painter.py def get_composition_mode ( self ) -> CompositionModeStr : \"\"\"Get the current composition mode. Returns: composition mode \"\"\" return COMPOSITION_MODE . inverse [ self . compositionMode ()] get_pen ( self ) Return current pen. Returns: Type Description Pen current pen Source code in prettyqt/gui/painter.py def get_pen ( self ) -> gui . Pen : \"\"\"Return current pen. Returns: current pen \"\"\" return gui . Pen ( self . pen ()) set_composition_mode ( self , mode ) Set the current composition mode. Exceptions: Type Description InvalidParamError composition mode does not exist Source code in prettyqt/gui/painter.py def set_composition_mode ( self , mode : CompositionModeStr ): \"\"\"Set the current composition mode. Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMPOSITION_MODE : raise InvalidParamError ( mode , COMPOSITION_MODE ) self . setCompositionMode ( COMPOSITION_MODE [ mode ]) set_pen ( self , style = 'solid' , width = 1.0 , color = 'black' , join_style = 'bevel' , cap_style = 'square' ) Set pen to use. Parameters: Name Type Description Default style Literal['solid', 'none', 'cross', 'linear_gradient', 'radial_gradient'] pen style to use 'solid' width float pen width 1.0 color Union[str, int, PyQt5.QtGui.QRgba64, PyQt5.QtCore.Qt.GlobalColor, PyQt5.QtGui.QColor, tuple] pen color 'black' join_style Literal['miter', 'bevel', 'roundsvg_miter'] pen join style to use 'bevel' cap_style Literal['flat', 'square', 'round'] pen cap style to use 'square' Source code in prettyqt/gui/painter.py def set_pen ( self , style : PatternStr = \"solid\" , width : float = 1.0 , color : colors . ColorType = \"black\" , join_style : gui . pen . JoinStyleStr = \"bevel\" , cap_style : gui . pen . CapStyleStr = \"square\" , ): \"\"\"Set pen to use. Args: style: pen style to use width: pen width color: pen color join_style: pen join style to use cap_style: pen cap style to use \"\"\" pen = gui . Pen () pen . set_style ( style ) pen . set_cap_style ( cap_style ) pen . set_join_style ( join_style ) pen . setWidthF ( width ) pen . set_color ( color ) self . setPen ( pen ) painterpath PainterPath get_fill_rule ( self ) Return current fill rule. Possible values: \"odd_even\", \"winding\" Returns: Type Description FillRuleStr fill rule Source code in prettyqt/gui/painterpath.py def get_fill_rule ( self ) -> FillRuleStr : \"\"\"Return current fill rule. Possible values: \"odd_even\", \"winding\" Returns: fill rule \"\"\" return FILL_RULE . inverse [ self . fillRule ()] set_fill_rule ( self , rule ) Set fill rule. Allowed values are \"odd_even\", \"winding\" Parameters: Name Type Description Default rule FillRuleStr fill rule to use required Exceptions: Type Description InvalidParamError fill rule does not exist Source code in prettyqt/gui/painterpath.py def set_fill_rule ( self , rule : FillRuleStr ): \"\"\"Set fill rule. Allowed values are \"odd_even\", \"winding\" Args: rule: fill rule to use Raises: InvalidParamError: fill rule does not exist \"\"\" if rule not in FILL_RULE : raise InvalidParamError ( rule , FILL_RULE ) self . setFillRule ( FILL_RULE [ rule ]) painterpathstroker PainterPathStroker get_cap_style ( self ) Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: Type Description str cap style Source code in prettyqt/gui/painterpathstroker.py def get_cap_style ( self ) -> str : \"\"\"Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: cap style \"\"\" return CAP_STYLES . inverse [ self . capStyle ()] get_join_style ( self ) Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: Type Description str join style Source code in prettyqt/gui/painterpathstroker.py def get_join_style ( self ) -> str : \"\"\"Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: join style \"\"\" return JOIN_STYLES . inverse [ self . joinStyle ()] set_cap_style ( self , style ) Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Parameters: Name Type Description Default style str cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_cap_style ( self , style : str ): \"\"\"Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in CAP_STYLES : raise InvalidParamError ( style , CAP_STYLES ) self . setCapStyle ( CAP_STYLES [ style ]) set_join_style ( self , style ) Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Parameters: Name Type Description Default style str join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_join_style ( self , style : str ): \"\"\"Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in JOIN_STYLES : raise InvalidParamError ( style , JOIN_STYLES ) self . setJoinStyle ( JOIN_STYLES [ style ]) pen Pen get_cap_style ( self ) Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: Type Description Literal['flat', 'square', 'round'] cap style Source code in prettyqt/gui/pen.py def get_cap_style ( self ) -> CapStyleStr : \"\"\"Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: cap style \"\"\" return CAP_STYLE . inverse [ self . capStyle ()] get_join_style ( self ) Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: Type Description Literal['miter', 'bevel', 'roundsvg_miter'] join style Source code in prettyqt/gui/pen.py def get_join_style ( self ) -> JoinStyleStr : \"\"\"Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: join style \"\"\" return JOIN_STYLE . inverse [ self . joinStyle ()] get_style ( self ) Return current pen style. Possible values: \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Returns: Type Description str pen style Source code in prettyqt/gui/pen.py def get_style ( self ) -> str : \"\"\"Return current pen style. Possible values: \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Returns: pen style \"\"\" return PEN_STYLE . inverse [ self . style ()] set_cap_style ( self , style ) Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Parameters: Name Type Description Default style Literal['flat', 'square', 'round'] cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/pen.py def set_cap_style ( self , style : CapStyleStr ): \"\"\"Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in CAP_STYLE : raise InvalidParamError ( style , CAP_STYLE ) self . setCapStyle ( CAP_STYLE [ style ]) set_join_style ( self , style ) Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Parameters: Name Type Description Default style Literal['miter', 'bevel', 'roundsvg_miter'] join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/pen.py def set_join_style ( self , style : JoinStyleStr ): \"\"\"Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in JOIN_STYLE : raise InvalidParamError ( style , JOIN_STYLE ) self . setJoinStyle ( JOIN_STYLE [ style ]) set_style ( self , style ) Set pen style to use. Allowed values are \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Parameters: Name Type Description Default style str pen style to use required Exceptions: Type Description InvalidParamError pen style does not exist Source code in prettyqt/gui/pen.py def set_style ( self , style : str ): \"\"\"Set pen style to use. Allowed values are \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Args: style: pen style to use Raises: InvalidParamError: pen style does not exist \"\"\" if style not in PEN_STYLE : raise InvalidParamError ( style , PEN_STYLE ) self . setStyle ( PEN_STYLE [ style ]) polygon Polygon __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/polygon.py def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () sessionmanager SessionManager get_restart_hint ( self ) Return current restart hint. Possible values: \"if_running\", \"anyway\", \"immediatly\", \"never\" Returns: Type Description str restart hint Source code in prettyqt/gui/sessionmanager.py def get_restart_hint ( self ) -> str : \"\"\"Return current restart hint. Possible values: \"if_running\", \"anyway\", \"immediatly\", \"never\" Returns: restart hint \"\"\" return RESTART_HINT . inverse [ self . restartHint ()] set_restart_hint ( self , style ) Set the restart hint. Allowed values are \"if_running\", \"anyway\", \"immediatly\", \"never\" Parameters: Name Type Description Default style str restart hint required Exceptions: Type Description InvalidParamError restart hint does not exist Source code in prettyqt/gui/sessionmanager.py def set_restart_hint ( self , style : str ): \"\"\"Set the restart hint. Allowed values are \"if_running\", \"anyway\", \"immediatly\", \"never\" Args: style: restart hint Raises: InvalidParamError: restart hint does not exist \"\"\" if style not in RESTART_HINT : raise InvalidParamError ( style , RESTART_HINT ) self . setRestartHint ( RESTART_HINT [ style ]) standarditem StandardItem clone ( self ) clone(self) -> QStandardItem Source code in prettyqt/gui/standarditem.py def clone ( self ): item = self . __class__ () core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/gui/standarditem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) statictext StaticText get_performance_hint ( self ) Return current performance hint. Possible values: \"moderate\", \"aggressive\" Returns: Type Description str performance hint Source code in prettyqt/gui/statictext.py def get_performance_hint ( self ) -> str : \"\"\"Return current performance hint. Possible values: \"moderate\", \"aggressive\" Returns: performance hint \"\"\" return PERFORMANCE_HINT . inverse [ self . performanceHint ()] get_text_format ( self ) Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str text format Source code in prettyqt/gui/statictext.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] set_performance_hint ( self , hint ) Set the performance hint. Allowed values are \"moderate\", \"aggressive\" Parameters: Name Type Description Default hint str performance hint to use required Exceptions: Type Description InvalidParamError performance hint does not exist Source code in prettyqt/gui/statictext.py def set_performance_hint ( self , hint : str ): \"\"\"Set the performance hint. Allowed values are \"moderate\", \"aggressive\" Args: hint: performance hint to use Raises: InvalidParamError: performance hint does not exist \"\"\" if hint not in PERFORMANCE_HINT : raise InvalidParamError ( hint , PERFORMANCE_HINT ) self . setPerformanceHint ( PERFORMANCE_HINT [ hint ]) set_text_format ( self , text_format ) Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/gui/statictext.py def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) surface Surface get_surface_class ( self ) Get the current surface class. Possible values: \"window\", \"offscreen\" Returns: Type Description str surface class Source code in prettyqt/gui/surface.py def get_surface_class ( self ) -> str : \"\"\"Get the current surface class. Possible values: \"window\", \"offscreen\" Returns: surface class \"\"\" return SURFACE_CLASS . inverse [ self . surfaceClass ()] get_surface_type ( self ) Get the current surface type. Possible values: \"raster\", \"open_gl\", \"raster_gl\", \"open_vg\", \"vulkan\", \"metal\" Returns: Type Description str surface type Source code in prettyqt/gui/surface.py def get_surface_type ( self ) -> str : \"\"\"Get the current surface type. Possible values: \"raster\", \"open_gl\", \"raster_gl\", \"open_vg\", \"vulkan\", \"metal\" Returns: surface type \"\"\" return SURFACE_TYPES . inverse [ self . surfaceType ()] syntaxhighlighter SyntaxHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt ) textblockuserdata TextBlockUserData Storage for the user data associated with each line. textcharformat TextCharFormat get_font_weight ( self ) Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: Type Description str current font weight Source code in prettyqt/gui/textcharformat.py def get_font_weight ( self ) -> str : \"\"\"Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: current font weight \"\"\" return gui . font . WEIGHTS . inverse [ self . fontWeight ()] get_underline_style ( self ) Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: Type Description str current underline style Source code in prettyqt/gui/textcharformat.py def get_underline_style ( self ) -> str : \"\"\"Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: current underline style \"\"\" return UNDERLINE_STYLES . inverse [ self . underlineStyle ()] get_vertical_alignment ( self ) Get current vertical alignment. Possible values: \"normal\", \"super_script\", \"sub_script\", \"middle\", \"bottom\", \"top\", \"baseline\" Returns: Type Description str current vertical alignment Source code in prettyqt/gui/textcharformat.py def get_vertical_alignment ( self ) -> str : \"\"\"Get current vertical alignment. Possible values: \"normal\", \"super_script\", \"sub_script\", \"middle\", \"bottom\", \"top\", \"baseline\" Returns: current vertical alignment \"\"\" return VERTICAL_ALIGNMENT . inverse [ self . verticalAlignment ()] set_font_style_hint ( self , hint ) Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str font style hint required Exceptions: Type Description InvalidParamError invalid font style hint Source code in prettyqt/gui/textcharformat.py def set_font_style_hint ( self , hint : str ): \"\"\"Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in gui . font . STYLE_HINTS : raise InvalidParamError ( hint , gui . font . STYLE_HINTS ) self . setFontStyleHint ( gui . font . STYLE_HINTS [ hint ]) set_font_weight ( self , weight ) Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/textcharformat.py def set_font_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHTS : raise InvalidParamError ( weight , gui . font . WEIGHTS ) self . setFontWeight ( gui . font . WEIGHTS [ weight ]) set_underline_style ( self , style ) Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Parameters: Name Type Description Default style str underline style required Exceptions: Type Description InvalidParamError invalid underline style Source code in prettyqt/gui/textcharformat.py def set_underline_style ( self , style : str ): \"\"\"Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLES : raise InvalidParamError ( style , UNDERLINE_STYLES ) self . setUnderlineStyle ( UNDERLINE_STYLES [ style ]) set_vertical_alignment ( self , alignment ) Set the vertical alignment. Valid values: \"normal\", \"super_script\", \"sub_script\", \"middle\", \"bottom\", \"top\", \"baseline\" Parameters: Name Type Description Default alignment str vertical alignment required Exceptions: Type Description InvalidParamError invalid vertical alignment Source code in prettyqt/gui/textcharformat.py def set_vertical_alignment ( self , alignment : str ): \"\"\"Set the vertical alignment. Valid values: \"normal\", \"super_script\", \"sub_script\", \"middle\", \"bottom\", \"top\", \"baseline\" Args: alignment: vertical alignment Raises: InvalidParamError: invalid vertical alignment \"\"\" if alignment not in VERTICAL_ALIGNMENT : raise InvalidParamError ( alignment , VERTICAL_ALIGNMENT ) self . setVerticalAlignment ( VERTICAL_ALIGNMENT [ alignment ]) textcursor TextCursor edit_block ( self ) Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock () select ( self , selection ) select(self, QTextCursor.SelectionType) Source code in prettyqt/gui/textcursor.py def select ( self , selection ): if selection in SELECTION_TYPES : selection = SELECTION_TYPES [ selection ] super () . select ( selection ) select_text ( self , start_pos , end_pos ) Select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos Union[int, str] Start position required end_pos Union[int, str] End position required Source code in prettyqt/gui/textcursor.py def select_text ( self , start_pos : Union [ int , str ], end_pos : Union [ int , str ]) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText () set_position ( self , pos , mode = 'move' ) Set cursor to given position. Parameters: Name Type Description Default pos int Cursor position required mode str Move mode 'move' Source code in prettyqt/gui/textcursor.py def set_position ( self , pos : int , mode : str = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODES [ mode ]) textdocument TextDocument clear_stacks ( self , stack ) Clear undo / redo stack. Allowed values are \"undo\", \"redo\", \"undo_and_redo\" Parameters: Name Type Description Default stack str stack to clear required Exceptions: Type Description InvalidParamError stack type does not exist Source code in prettyqt/gui/textdocument.py def clear_stacks ( self , stack : str ): \"\"\"Clear undo / redo stack. Allowed values are \"undo\", \"redo\", \"undo_and_redo\" Args: stack: stack to clear Raises: InvalidParamError: stack type does not exist \"\"\" if stack not in STACKS : raise InvalidParamError ( stack , STACKS ) self . clearUndoRedoStacks ( STACKS [ stack ]) get_default_cursor_move_style ( self ) Return current cursor move style. Possible values: \"logical\", \"visual\" Returns: Type Description str cursor move style Source code in prettyqt/gui/textdocument.py def get_default_cursor_move_style ( self ) -> str : \"\"\"Return current cursor move style. Possible values: \"logical\", \"visual\" Returns: cursor move style \"\"\" return CURSOR_MOVE_STYLES . inverse [ self . defaultCursorMoveStyle ()] set_default_cursor_move_style ( self , style ) Set the cursor move style. Allowed values are \"logical\", \"visual\" Parameters: Name Type Description Default style str cursor move style required Exceptions: Type Description InvalidParamError cursor move style does not exist Source code in prettyqt/gui/textdocument.py def set_default_cursor_move_style ( self , style : str ): \"\"\"Set the cursor move style. Allowed values are \"logical\", \"visual\" Args: style: cursor move style Raises: InvalidParamError: cursor move style does not exist \"\"\" if style not in CURSOR_MOVE_STYLES : raise InvalidParamError ( style , CURSOR_MOVE_STYLES ) self . setDefaultCursorMoveStyle ( CURSOR_MOVE_STYLES [ style ]) textformat TextFormat get_layout_direction ( self ) Get the current layout direction. Possible values: \"left_to_right\", \"right_to_left\", \"auto\" Returns: Type Description str layout direction Source code in prettyqt/gui/textformat.py def get_layout_direction ( self ) -> str : \"\"\"Get the current layout direction. Possible values: \"left_to_right\", \"right_to_left\", \"auto\" Returns: layout direction \"\"\" return LAYOUT_DIRECTIONS . inverse [ self . layoutDirection ()] set_layout_direction ( self , direction ) Set layout direction. Valid values: \"left_to_right\", \"right_to_left\", \"auto\" Parameters: Name Type Description Default direction str layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/textformat.py def set_layout_direction ( self , direction : str ): \"\"\"Set layout direction. Valid values: \"left_to_right\", \"right_to_left\", \"auto\" Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in LAYOUT_DIRECTIONS : raise InvalidParamError ( direction , LAYOUT_DIRECTIONS ) self . setLayoutDirection ( LAYOUT_DIRECTIONS [ direction ]) textframeformat TextFrameFormat get_border_style ( self ) Get the current border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: Type Description str border style Source code in prettyqt/gui/textframeformat.py def get_border_style ( self ) -> str : \"\"\"Get the current border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: border style \"\"\" return BORDER_STYLES . inverse [ self . borderStyle ()] get_page_break_policy ( self ) Get the current page break policy. Possible values: \"auto\", \"always_before\", \"always_after\" Returns: Type Description str page break policy Source code in prettyqt/gui/textframeformat.py def get_page_break_policy ( self ) -> str : \"\"\"Get the current page break policy. Possible values: \"auto\", \"always_before\", \"always_after\" Returns: page break policy \"\"\" return gui . textformat . PAGE_BREAK_FLAG . inverse [ self . pageBreakPolicy ()] get_position ( self ) Get the current position. Possible values: \"in_flow\", \"flow_left\", \"flow_right\" Returns: Type Description str position Source code in prettyqt/gui/textframeformat.py def get_position ( self ) -> str : \"\"\"Get the current position. Possible values: \"in_flow\", \"flow_left\", \"flow_right\" Returns: position \"\"\" return POSITIONS . inverse [ self . position ()] set_border_style ( self , style ) Set border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/textframeformat.py def set_border_style ( self , style : str ): \"\"\"Set border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in BORDER_STYLES : raise InvalidParamError ( style , BORDER_STYLES ) self . setBorderStyle ( BORDER_STYLES [ style ]) set_page_break_policy ( self , policy ) Set page break policy. Valid values: \"auto\", \"always_before\", \"always_after\" Parameters: Name Type Description Default policy str page break policy required Exceptions: Type Description InvalidParamError page break policy does not exist Source code in prettyqt/gui/textframeformat.py def set_page_break_policy ( self , policy : str ): \"\"\"Set page break policy. Valid values: \"auto\", \"always_before\", \"always_after\" Args: policy: page break policy Raises: InvalidParamError: page break policy does not exist \"\"\" if policy not in gui . textformat . PAGE_BREAK_FLAG : raise InvalidParamError ( policy , gui . textformat . PAGE_BREAK_FLAG ) self . setPageBreakPolicy ( gui . textformat . PAGE_BREAK_FLAG [ policy ]) set_position ( self , position ) Set position. Valid values: \"in_flow\", \"flow_left\", \"flow_right\" Parameters: Name Type Description Default position str position required Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/gui/textframeformat.py def set_position ( self , position : str ): \"\"\"Set position. Valid values: \"in_flow\", \"flow_left\", \"flow_right\" Args: position: position Raises: InvalidParamError: position does not exist \"\"\" if position not in POSITIONS : raise InvalidParamError ( position , POSITIONS ) self . setPosition ( POSITIONS [ position ]) textlength TextLength get_type ( self ) Return type of this length object. Possible values: \"variable\", \"fixed\", \"percentage\" Returns: Type Description str timer type Source code in prettyqt/gui/textlength.py def get_type ( self ) -> str : \"\"\"Return type of this length object. Possible values: \"variable\", \"fixed\", \"percentage\" Returns: timer type \"\"\" return TYPES . inverse [ self . type ()] textlistformat TextListFormat get_style ( self ) Get current style. Possible values are \"disc\", \"circle\", square\", \"decimal\", \"lower_alpha\", \"upper_alpha\", \"lower_roman\", upper_roman\" Returns: Type Description str current style Source code in prettyqt/gui/textlistformat.py def get_style ( self ) -> str : \"\"\"Get current style. Possible values are \"disc\", \"circle\", square\", \"decimal\", \"lower_alpha\", \"upper_alpha\", \"lower_roman\", upper_roman\" Returns: current style \"\"\" return STYLES . inverse [ self . style ()] set_style ( self , style ) Set the style. Valid values are \"disc\", \"circle\", square\", \"decimal\", \"lower_alpha\", \"upper_alpha\", \"lower_roman\", upper_roman\" Parameters: Name Type Description Default style str style required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/gui/textlistformat.py def set_style ( self , style : str ): \"\"\"Set the style. Valid values are \"disc\", \"circle\", square\", \"decimal\", \"lower_alpha\", \"upper_alpha\", \"lower_roman\", upper_roman\" Args: style: style Raises: InvalidParamError: invalid style \"\"\" if style not in STYLES : raise InvalidParamError ( style , STYLES ) self . setStyle ( STYLES [ style ]) texttablecellformat TextTableCellFormat get_bottom_border_style ( self ) Get the current bottom border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: Type Description str bottom border style Source code in prettyqt/gui/texttablecellformat.py def get_bottom_border_style ( self ) -> str : \"\"\"Get the current bottom border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: bottom border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . bottomBorderStyle ()] get_left_border_style ( self ) Get the current left border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: Type Description str left border style Source code in prettyqt/gui/texttablecellformat.py def get_left_border_style ( self ) -> str : \"\"\"Get the current left border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: left border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . leftBorderStyle ()] get_right_border_style ( self ) Get the current right border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: Type Description str right border style Source code in prettyqt/gui/texttablecellformat.py def get_right_border_style ( self ) -> str : \"\"\"Get the current right border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: right border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . rightBorderStyle ()] get_top_border_style ( self ) Get the current top border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: Type Description str top border style Source code in prettyqt/gui/texttablecellformat.py def get_top_border_style ( self ) -> str : \"\"\"Get the current top border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: top border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . topBorderStyle ()] set_border_style ( self , style ) Set border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_border_style ( self , style : str ): \"\"\"Set border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_bottom_border_style ( self , style ) Set bottom border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str bottom border style required Exceptions: Type Description InvalidParamError bottom border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_bottom_border_style ( self , style : str ): \"\"\"Set bottom border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: bottom border style Raises: InvalidParamError: bottom border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBottomBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_left_border_style ( self , style ) Set left border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str left border style required Exceptions: Type Description InvalidParamError left border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_left_border_style ( self , style : str ): \"\"\"Set left border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: left border style Raises: InvalidParamError: left border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setLeftBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_right_border_style ( self , style ) Set right border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str right border style required Exceptions: Type Description InvalidParamError right border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_right_border_style ( self , style : str ): \"\"\"Set right border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: right border style Raises: InvalidParamError: right border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setRightBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_top_border_style ( self , style ) Set top border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str top border style required Exceptions: Type Description InvalidParamError top border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_top_border_style ( self , style : str ): \"\"\"Set top border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: top border style Raises: InvalidParamError: top border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setTopBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) transform Transform __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/transform.py def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () validator Validator __radd__ ( self , other ) special Needed for sum(). Source code in prettyqt/gui/validator.py def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other ) window Window get_visibility ( self ) Get the current window visibility. Possible values: \"windowed\", \"maximized\", \"minimized\", \"fullscreen\", \"automatic\", \"hidden\" Returns: Type Description str window visibility Source code in prettyqt/gui/window.py def get_visibility ( self ) -> str : \"\"\"Get the current window visibility. Possible values: \"windowed\", \"maximized\", \"minimized\", \"fullscreen\", \"automatic\", \"hidden\" Returns: window visibility \"\"\" return VISIBILITIES . inverse [ self . visibility ()] set_visibility ( self , visibility ) Set window visibility. Valid values: \"windowed\", \"maximized\", \"minimized\", \"fullscreen\", \"automatic\", \"hidden\" Parameters: Name Type Description Default visibility str window visibility required Exceptions: Type Description InvalidParamError window visibility does not exist Source code in prettyqt/gui/window.py def set_visibility ( self , visibility : str ): \"\"\"Set window visibility. Valid values: \"windowed\", \"maximized\", \"minimized\", \"fullscreen\", \"automatic\", \"hidden\" Args: visibility: window visibility Raises: InvalidParamError: window visibility does not exist \"\"\" if visibility not in VISIBILITIES : raise InvalidParamError ( visibility , VISIBILITIES ) self . setVisibility ( VISIBILITIES [ visibility ])","title":"gui"},{"location":"api/gui.html#gui-module","text":"","title":"gui module"},{"location":"api/gui.html#prettyqt.gui","text":"Gui module. Contains QtGui-based classes","title":"prettyqt.gui"},{"location":"api/gui.html#prettyqt.gui.color","text":"","title":"color"},{"location":"api/gui.html#prettyqt.gui.color.Color","text":"","title":"Color"},{"location":"api/gui.html#prettyqt.gui.color.Color.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/color.py def __reduce__ ( self ): return self . __class__ , ( self . red (), self . green (), self . blue (), self . alpha ())","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.color.Color.from_text","text":"Create a QColor from specified string. Source code in prettyqt/gui/color.py @classmethod def from_text ( cls , text ): \"\"\"Create a QColor from specified string.\"\"\" color = cls () text = str ( text ) if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color","title":"from_text()"},{"location":"api/gui.html#prettyqt.gui.colorspace","text":"","title":"colorspace"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace","text":"","title":"ColorSpace"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_primaries","text":"Return current primaries. Possible values: \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Returns: Type Description str primaries Source code in prettyqt/gui/colorspace.py def get_primaries ( self ) -> str : \"\"\"Return current primaries. Possible values: \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Returns: primaries \"\"\" return PRIMARIES . inverse [ self . primaries ()]","title":"get_primaries()"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_transfer_function","text":"Return current transfer function. Possible values: \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Returns: Type Description str transfer function Source code in prettyqt/gui/colorspace.py def get_transfer_function ( self ) -> str : \"\"\"Return current transfer function. Possible values: \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Returns: transfer function \"\"\" return TRANSFER_FUNCTION . inverse [ self . transferFunction ()]","title":"get_transfer_function()"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_primaries","text":"Set primaries. Allowed values are \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Parameters: Name Type Description Default primaries str primaries to use required Exceptions: Type Description InvalidParamError primaries do not exist Source code in prettyqt/gui/colorspace.py def set_primaries ( self , primaries : str ): \"\"\"Set primaries. Allowed values are \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Args: primaries: primaries to use Raises: InvalidParamError: primaries do not exist \"\"\" if primaries not in PRIMARIES : raise InvalidParamError ( primaries , PRIMARIES ) self . setPrimaries ( PRIMARIES [ primaries ])","title":"set_primaries()"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_transfer_function","text":"Set transfer function. Allowed values are \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Parameters: Name Type Description Default fn str transfer function to use required Exceptions: Type Description InvalidParamError transfer function do not exist Source code in prettyqt/gui/colorspace.py def set_transfer_function ( self , fn : str , gamma : float = 0.0 ): \"\"\"Set transfer function. Allowed values are \"custom\", \"srgb\", \"adobe_rgb\", \"dci_p3_d65\", \"pro_photo_rgb\" Args: fn: transfer function to use Raises: InvalidParamError: transfer function do not exist \"\"\" if fn not in TRANSFER_FUNCTION : raise InvalidParamError ( fn , TRANSFER_FUNCTION ) self . setTransferFunction ( TRANSFER_FUNCTION [ fn ], gamma )","title":"set_transfer_function()"},{"location":"api/gui.html#prettyqt.gui.cursor","text":"","title":"cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor","text":"","title":"Cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.get_shape","text":"Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: Type Description str cursor shape Source code in prettyqt/gui/cursor.py def get_shape ( self ) -> str : \"\"\"Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: cursor shape \"\"\" return SHAPES . inverse [ self . shape ()]","title":"get_shape()"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.set_shape","text":"Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Parameters: Name Type Description Default shape str shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/gui/cursor.py def set_shape ( self , shape : str ): \"\"\"Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in SHAPES : raise InvalidParamError ( shape , SHAPES ) self . setShape ( SHAPES [ shape ])","title":"set_shape()"},{"location":"api/gui.html#prettyqt.gui.font","text":"","title":"font"},{"location":"api/gui.html#prettyqt.gui.font.Font","text":"","title":"Font"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_capitalization","text":"Get current font capitalization. Possible values are \"mixed_case\", \"all_uppercase\", all_lowercase\", \"small_caps\", \"capitalize\" Returns: Type Description str current font capitalization Source code in prettyqt/gui/font.py def get_capitalization ( self ) -> str : \"\"\"Get current font capitalization. Possible values are \"mixed_case\", \"all_uppercase\", all_lowercase\", \"small_caps\", \"capitalize\" Returns: current font capitalization \"\"\" return CAPITALIZATION . inverse [ self . capitalization ()]","title":"get_capitalization()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_hinting_preference","text":"Get current hinting preference. Possible values are \"default\", \"none\", \"vertical\", \"full\" Returns: Type Description str current hinting preference Source code in prettyqt/gui/font.py def get_hinting_preference ( self ) -> str : \"\"\"Get current hinting preference. Possible values are \"default\", \"none\", \"vertical\", \"full\" Returns: current hinting preference \"\"\" return HINTING_PREFERENCE . inverse [ self . hintingPreference ()]","title":"get_hinting_preference()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_letter_spacing_type","text":"Get current letter spacing type. Possible values are \"percentage\", \"absolute\" Returns: Type Description str current letter spacing type Source code in prettyqt/gui/font.py def get_letter_spacing_type ( self ) -> str : \"\"\"Get current letter spacing type. Possible values are \"percentage\", \"absolute\" Returns: current letter spacing type \"\"\" return SPACING_TYPE . inverse [ self . letterSpacingType ()]","title":"get_letter_spacing_type()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_style","text":"Get current font style. Possible values are \"normal\", \"italic\", \"oblique\" Returns: Type Description str current font style Source code in prettyqt/gui/font.py def get_style ( self ) -> str : \"\"\"Get current font style. Possible values are \"normal\", \"italic\", \"oblique\" Returns: current font style \"\"\" return STYLE . inverse [ self . style ()]","title":"get_style()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_weight","text":"Get current font weight. Possible values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Returns: Type Description str current font weight Source code in prettyqt/gui/font.py def get_weight ( self ) -> str : \"\"\"Get current font weight. Possible values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Returns: current font weight \"\"\" return WEIGHTS . inverse [ self . weight ()]","title":"get_weight()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_capitalization","text":"Set the font capitalization. Valid values are \"mixed_case\", \"all_uppercase\", all_lowercase\", \"small_caps\", \"capitalize\" Parameters: Name Type Description Default capitalization str font capitalization required Exceptions: Type Description InvalidParamError invalid font capitalization Source code in prettyqt/gui/font.py def set_capitalization ( self , capitalization : str ): \"\"\"Set the font capitalization. Valid values are \"mixed_case\", \"all_uppercase\", all_lowercase\", \"small_caps\", \"capitalize\" Args: capitalization: font capitalization Raises: InvalidParamError: invalid font capitalization \"\"\" if capitalization not in CAPITALIZATION : raise InvalidParamError ( capitalization , CAPITALIZATION ) self . setCapitalization ( CAPITALIZATION [ capitalization ])","title":"set_capitalization()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_hinting_preference","text":"Set the hinting preference. Valid values are \"default\", \"none\", \"vertical\", \"full\" Parameters: Name Type Description Default preference str hinting preference required Exceptions: Type Description InvalidParamError invalid hinting preference Source code in prettyqt/gui/font.py def set_hinting_preference ( self , preference : str ): \"\"\"Set the hinting preference. Valid values are \"default\", \"none\", \"vertical\", \"full\" Args: preference: hinting preference Raises: InvalidParamError: invalid hinting preference \"\"\" if preference not in HINTING_PREFERENCE : raise InvalidParamError ( preference , HINTING_PREFERENCE ) self . setHintingPreference ( HINTING_PREFERENCE [ preference ])","title":"set_hinting_preference()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_letter_spacing","text":"Set the letter spacing. Valid values are \"percentage\", \"absolute\" Parameters: Name Type Description Default typ str letter spacing type required spacing float spacing required Exceptions: Type Description InvalidParamError invalid letter spacing type Source code in prettyqt/gui/font.py def set_letter_spacing ( self , typ : str , spacing : float ): \"\"\"Set the letter spacing. Valid values are \"percentage\", \"absolute\" Args: typ: letter spacing type spacing: spacing Raises: InvalidParamError: invalid letter spacing type \"\"\" if typ not in SPACING_TYPE : raise InvalidParamError ( typ , SPACING_TYPE ) self . setLetterSpacing ( SPACING_TYPE [ typ ], spacing )","title":"set_letter_spacing()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style","text":"Set the font style. Valid values are \"normal\", \"italic\", \"oblique\" Parameters: Name Type Description Default style str font style required Exceptions: Type Description InvalidParamError invalid font style Source code in prettyqt/gui/font.py def set_style ( self , style : str ): \"\"\"Set the font style. Valid values are \"normal\", \"italic\", \"oblique\" Args: style: font style Raises: InvalidParamError: invalid font style \"\"\" if style not in STYLE : raise InvalidParamError ( style , STYLE ) self . setStyle ( STYLE [ style ])","title":"set_style()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style_hint","text":"Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str style hint required Exceptions: Type Description InvalidParamError invalid style hint Source code in prettyqt/gui/font.py def set_style_hint ( self , hint : str ): \"\"\"Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ])","title":"set_style_hint()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_weight","text":"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/font.py def set_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) self . setWeight ( WEIGHTS [ weight ])","title":"set_weight()"},{"location":"api/gui.html#prettyqt.gui.gradient","text":"","title":"gradient"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient","text":"","title":"Gradient"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_coordinate_mode","text":"Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: Type Description str coordinate mode Source code in prettyqt/gui/gradient.py def get_coordinate_mode ( self ) -> str : \"\"\"Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: coordinate mode \"\"\" return COORDINATE_MODES . inverse [ self . coordinateMode ()]","title":"get_coordinate_mode()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_spread","text":"Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: Type Description str spread method Source code in prettyqt/gui/gradient.py def get_spread ( self ) -> str : \"\"\"Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: spread method \"\"\" return SPREADS . inverse [ self . spread ()]","title":"get_spread()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_type","text":"Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: Type Description str gradient type Source code in prettyqt/gui/gradient.py def get_type ( self ) -> str : \"\"\"Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: gradient type \"\"\" return TYPES . inverse [ self . type ()]","title":"get_type()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.set_coordinate_mode","text":"Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Parameters: Name Type Description Default mode str coordinate mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/gradient.py def set_coordinate_mode ( self , mode : str ): \"\"\"Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODES : raise InvalidParamError ( mode , COORDINATE_MODES ) self . setCoordinateMode ( COORDINATE_MODES [ mode ])","title":"set_coordinate_mode()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.set_spread","text":"Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Parameters: Name Type Description Default method str spread method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/gui/gradient.py def set_spread ( self , method : str ): \"\"\"Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREADS : raise InvalidParamError ( method , SPREADS ) self . setSpread ( SPREADS [ method ])","title":"set_spread()"},{"location":"api/gui.html#prettyqt.gui.guiapplication","text":"","title":"guiapplication"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication","text":"","title":"GuiApplication"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.copy_to_clipboard","text":"Sets clipboard to supplied text. Source code in prettyqt/gui/guiapplication.py @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Clipboard ) cb . setText ( text , mode = cb . Clipboard )","title":"copy_to_clipboard()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.get_application_state","text":"Get the current application state. Returns: Type Description List[Literal['suspended', 'hidden', 'inactive', 'active']] application state Source code in prettyqt/gui/guiapplication.py @classmethod def get_application_state ( cls ) -> List [ ApplicationStateStr ]: \"\"\"Get the current application state. Returns: application state \"\"\" return [ k for k , v in APPLICATION_STATES . items () if v & cls . applicationState ()]","title":"get_application_state()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.get_layout_direction","text":"Get the current layout direction. Returns: Type Description Literal['left_to_right', 'right_to_left', 'auto'] layout direction Source code in prettyqt/gui/guiapplication.py def get_layout_direction ( self ) -> LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return LAYOUT_DIRECTION . inverse [ self . layoutDirection ()]","title":"get_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.set_icon","text":"Set the default window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/gui/guiapplication.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.set_layout_direction","text":"Set layout direction. Parameters: Name Type Description Default direction Literal['left_to_right', 'right_to_left', 'auto'] layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/guiapplication.py def set_layout_direction ( self , direction : LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in LAYOUT_DIRECTION : raise InvalidParamError ( direction , LAYOUT_DIRECTION ) self . setLayoutDirection ( LAYOUT_DIRECTION [ direction ])","title":"set_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.icon","text":"","title":"icon"},{"location":"api/gui.html#prettyqt.gui.icon.get_icon","text":"Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. Source code in prettyqt/gui/icon.py def get_icon ( icon : IconType , color : Optional [ str ] = None , as_qicon : bool = False ) -> QtGui . QIcon : \"\"\"Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. \"\"\" if isinstance ( icon , QtGui . QIcon ): return icon if as_qicon else Icon ( icon ) if isinstance ( icon , pathlib . Path ): icon = str ( icon ) if ( icon , color , as_qicon ) in icon_cache : return icon_cache [( icon , color , as_qicon )] if isinstance ( icon , str ) and icon . startswith ( \"mdi.\" ): if color is not None : new = qta . icon ( icon , color = color ) else : new = qta . icon ( icon ) else : new = QtGui . QIcon ( icon ) icon = new if as_qicon else Icon ( new ) icon_cache [( icon , color , as_qicon )] = icon return icon","title":"get_icon()"},{"location":"api/gui.html#prettyqt.gui.imageiohandler","text":"","title":"imageiohandler"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler","text":"","title":"ImageIOHandler"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.get_option","text":"Return the value assigned to option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Parameters: Name Type Description Default option str option to get required Returns: Type Description Any option Source code in prettyqt/gui/imageiohandler.py def get_option ( self , option : str ) -> Any : \"\"\"Return the value assigned to option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Args: option: option to get Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . option ( IMAGE_OPTION [ option ])","title":"get_option()"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.set_option","text":"Set option to given value. Allowed values are \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Parameters: Name Type Description Default option str option to use required value value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/gui/imageiohandler.py def set_option ( self , option : str , value ): \"\"\"Set option to given value. Allowed values are \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) self . setOption ( IMAGE_OPTION [ option ], value )","title":"set_option()"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.supports_option","text":"Return whether the image handler supports given option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Parameters: Name Type Description Default option str option to check required Returns: Type Description bool option Source code in prettyqt/gui/imageiohandler.py def supports_option ( self , option : str ) -> bool : \"\"\"Return whether the image handler supports given option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quality\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Args: option: option to check Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . supportsOption ( IMAGE_OPTION [ option ])","title":"supports_option()"},{"location":"api/gui.html#prettyqt.gui.imagereader","text":"","title":"imagereader"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader","text":"","title":"ImageReader"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_error","text":"Return error type. possible values are \"file_not_found\", \"device\", \"unsupported_format\", \"invalid_image\", \"unknown\" Returns: Type Description str error type Source code in prettyqt/gui/imagereader.py def get_error ( self ) -> str : \"\"\"Return error type. possible values are \"file_not_found\", \"device\", \"unsupported_format\", \"invalid_image\", \"unknown\" Returns: error type \"\"\" return IMAGE_READER_ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_transformation","text":"Return the transformation and orientation the image has been set to. Possible values: \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Returns: Type Description str transformation Source code in prettyqt/gui/imagereader.py def get_transformation ( self ) -> str : \"\"\"Return the transformation and orientation the image has been set to. Possible values: \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Returns: transformation \"\"\" return TRANSFORMATIONS . inverse [ self . transformation ()]","title":"get_transformation()"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.supports_option","text":"Return whether the image handler supports given option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quallity\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Parameters: Name Type Description Default option str option to check required Returns: Type Description bool option Source code in prettyqt/gui/imagereader.py def supports_option ( self , option : str ) -> bool : \"\"\"Return whether the image handler supports given option. Possible values: \"size\", \"clip_rect\", \"scaled_size\", \"scaled_clip_rect\", \"description\", \"compression_ratio\", \"gamma\", \"quallity\", \"name\", \"subtype\", \"incremental_reading\", \"endianness\", \"animation\", \"background_color\", \"image_format\", \"supported_sub_types\", \"optimized_write\", \"progressive_scan_write\", \"image_transformation\", \"transformation_by_default\" Args: option: option to check Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . supportsOption ( IMAGE_OPTION [ option ])","title":"supports_option()"},{"location":"api/gui.html#prettyqt.gui.imagewriter","text":"","title":"imagewriter"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter","text":"","title":"ImageWriter"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_error","text":"Return error type. possible values are \"device\", \"unsupported_format\", \"invalid_image\", \"unknown\" Returns: Type Description str error type Source code in prettyqt/gui/imagewriter.py def get_error ( self ) -> str : \"\"\"Return error type. possible values are \"device\", \"unsupported_format\", \"invalid_image\", \"unknown\" Returns: error type \"\"\" return IMAGE_WRITER_ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_transformation","text":"Return the transformation and orientation the image has been set to. Possible values: \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Returns: Type Description str transformation Source code in prettyqt/gui/imagewriter.py def get_transformation ( self ) -> str : \"\"\"Return the transformation and orientation the image has been set to. Possible values: \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Returns: transformation \"\"\" return TRANSFORMATIONS . inverse [ self . transformation ()]","title":"get_transformation()"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.set_transformation","text":"Set the image transformations metadata including orientation. Allowed values are \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Parameters: Name Type Description Default origin str transformation to use required Exceptions: Type Description InvalidParamError transformation does not exist Source code in prettyqt/gui/imagewriter.py def set_transformation ( self , origin : str ): \"\"\"Set the image transformations metadata including orientation. Allowed values are \"none\", \"mirror\", \"flip\", \"rotate_180\", \"roate_90\", \"mirror_and_rotate_90\", \"flip_and_rotate_90\", \"rotate_270\" Args: origin: transformation to use Raises: InvalidParamError: transformation does not exist \"\"\" if origin not in TRANSFORMATIONS : raise InvalidParamError ( origin , TRANSFORMATIONS ) self . setTransformation ( TRANSFORMATIONS [ origin ])","title":"set_transformation()"},{"location":"api/gui.html#prettyqt.gui.keysequence","text":"","title":"keysequence"},{"location":"api/gui.html#prettyqt.gui.keysequence.KeySequence","text":"","title":"KeySequence"},{"location":"api/gui.html#prettyqt.gui.keysequence.KeySequence.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/keysequence.py def __reduce__ ( self ): return self . __class__ , ( self . toString (),)","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.movie","text":"","title":"movie"},{"location":"api/gui.html#prettyqt.gui.movie.Movie","text":"","title":"Movie"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_cache_mode","text":"Get the current cache mode. Possible values: \"none\", \"all\" Returns: Type Description str cache mode Source code in prettyqt/gui/movie.py def get_cache_mode ( self ) -> str : \"\"\"Get the current cache mode. Possible values: \"none\", \"all\" Returns: cache mode \"\"\" return CACHE_MODES . inverse [ self . cacheMode ()]","title":"get_cache_mode()"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.set_cache_mode","text":"Set cache mode. Valid values for cache_mode: \"none\", \"all\" Parameters: Name Type Description Default mode str cache mode required Exceptions: Type Description InvalidParamError cache mode does not exist Source code in prettyqt/gui/movie.py def set_cache_mode ( self , mode : str ): \"\"\"Set cache mode. Valid values for cache_mode: \"none\", \"all\" Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ])","title":"set_cache_mode()"},{"location":"api/gui.html#prettyqt.gui.openglwindow","text":"","title":"openglwindow"},{"location":"api/gui.html#prettyqt.gui.openglwindow.OpenGLWindow","text":"","title":"OpenGLWindow"},{"location":"api/gui.html#prettyqt.gui.openglwindow.OpenGLWindow.get_update_behaviour","text":"Get the window update hehaviour. Possible values: \"no_partial\", \"partial_blit\", \"partial_blend\" Returns: Type Description str update behaviour Source code in prettyqt/gui/openglwindow.py def get_update_behaviour ( self ) -> str : \"\"\"Get the window update hehaviour. Possible values: \"no_partial\", \"partial_blit\", \"partial_blend\" Returns: update behaviour \"\"\" return UPDATE_BEHAVIOUR . inverse [ self . updateBehavior ()]","title":"get_update_behaviour()"},{"location":"api/gui.html#prettyqt.gui.pagelayout","text":"","title":"pagelayout"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout","text":"","title":"PageLayout"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_mode","text":"Get the current mode. Possible values: \"standard\", \"full_page\" Returns: Type Description str mode Source code in prettyqt/gui/pagelayout.py def get_mode ( self ) -> str : \"\"\"Get the current mode. Possible values: \"standard\", \"full_page\" Returns: mode \"\"\" return MODES . inverse [ self . mode ()]","title":"get_mode()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_orientation","text":"Get the current orientation. Possible values: \"portrait\", \"landscape\" Returns: Type Description str orientation Source code in prettyqt/gui/pagelayout.py def get_orientation ( self ) -> str : \"\"\"Get the current orientation. Possible values: \"portrait\", \"landscape\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_units","text":"Get the current unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: Type Description str unit Source code in prettyqt/gui/pagelayout.py def get_units ( self ) -> str : \"\"\"Get the current unit. Possible values: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Returns: unit \"\"\" return UNITS . inverse [ self . units ()]","title":"get_units()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_mode","text":"Set mode. Valid values for mode: \"standard\", \"full_page\" Parameters: Name Type Description Default mode str mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/pagelayout.py def set_mode ( self , mode : str ): \"\"\"Set mode. Valid values for mode: \"standard\", \"full_page\" Args: mode: mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setMode ( MODES [ mode ])","title":"set_mode()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_orientation","text":"Set orientation. Valid values for orientation: \"portrait\", \"landscape\" Parameters: Name Type Description Default orientation str orientation required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/gui/pagelayout.py def set_orientation ( self , orientation : str ): \"\"\"Set orientation. Valid values for orientation: \"portrait\", \"landscape\" Args: orientation: orientation Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_units","text":"Set unit. Valid values for units: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Parameters: Name Type Description Default unit str unit required Exceptions: Type Description InvalidParamError unit does not exist Source code in prettyqt/gui/pagelayout.py def set_units ( self , unit : str ): \"\"\"Set unit. Valid values for units: \"millimeter\", \"point\", \"inch\", \"pica\", \"didot\", \"cicero\" Args: unit: unit Raises: InvalidParamError: unit does not exist \"\"\" if unit not in UNITS : raise InvalidParamError ( unit , UNITS ) self . setUnits ( UNITS [ unit ])","title":"set_units()"},{"location":"api/gui.html#prettyqt.gui.pagesize","text":"","title":"pagesize"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize","text":"","title":"PageSize"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_definition_units","text":"Get the definition unit. Returns: Type Description Literal['millimeter', 'point', 'inch', 'pica', 'didot', 'cicero'] unit Source code in prettyqt/gui/pagesize.py def get_definition_units ( self ) -> UnitStr : \"\"\"Get the definition unit. Returns: unit \"\"\" units = self . definitionUnits () if units == - 1 : raise ValueError ( \"Invalid page size\" ) return UNITS . inverse [ units ]","title":"get_definition_units()"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_id","text":"Get the standard page size id. Returns: Type Description str page size id Source code in prettyqt/gui/pagesize.py def get_id ( self ) -> str : \"\"\"Get the standard page size id. Returns: page size id \"\"\" return PAGE_SIZE_ID . inverse [ self . id ()]","title":"get_id()"},{"location":"api/gui.html#prettyqt.gui.paintdevice","text":"","title":"paintdevice"},{"location":"api/gui.html#prettyqt.gui.paintdevice.PaintDevice","text":"","title":"PaintDevice"},{"location":"api/gui.html#prettyqt.gui.paintdevice.PaintDevice.get_metric","text":"Return metric information. Possible values: \"center\", \"on_value\" Parameters: Name Type Description Default metric str metric information to get required Returns: Type Description int metric information Source code in prettyqt/gui/paintdevice.py def get_metric ( self , metric : str ) -> int : \"\"\"Return metric information. Possible values: \"center\", \"on_value\" Args: metric: metric information to get Returns: metric information \"\"\" if metric not in METRICS : raise InvalidParamError ( metric , METRICS ) return self . metric ( METRICS [ metric ])","title":"get_metric()"},{"location":"api/gui.html#prettyqt.gui.painter","text":"","title":"painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter","text":"","title":"Painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_composition_mode","text":"Get the current composition mode. Returns: Type Description Literal['source_over', 'destination_over', 'clear', 'source', 'destination', 'source_in', 'destination_in', 'source_out', 'destination_out', 'source_atop', 'destination_atop'] composition mode Source code in prettyqt/gui/painter.py def get_composition_mode ( self ) -> CompositionModeStr : \"\"\"Get the current composition mode. Returns: composition mode \"\"\" return COMPOSITION_MODE . inverse [ self . compositionMode ()]","title":"get_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_pen","text":"Return current pen. Returns: Type Description Pen current pen Source code in prettyqt/gui/painter.py def get_pen ( self ) -> gui . Pen : \"\"\"Return current pen. Returns: current pen \"\"\" return gui . Pen ( self . pen ())","title":"get_pen()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_composition_mode","text":"Set the current composition mode. Exceptions: Type Description InvalidParamError composition mode does not exist Source code in prettyqt/gui/painter.py def set_composition_mode ( self , mode : CompositionModeStr ): \"\"\"Set the current composition mode. Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMPOSITION_MODE : raise InvalidParamError ( mode , COMPOSITION_MODE ) self . setCompositionMode ( COMPOSITION_MODE [ mode ])","title":"set_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_pen","text":"Set pen to use. Parameters: Name Type Description Default style Literal['solid', 'none', 'cross', 'linear_gradient', 'radial_gradient'] pen style to use 'solid' width float pen width 1.0 color Union[str, int, PyQt5.QtGui.QRgba64, PyQt5.QtCore.Qt.GlobalColor, PyQt5.QtGui.QColor, tuple] pen color 'black' join_style Literal['miter', 'bevel', 'roundsvg_miter'] pen join style to use 'bevel' cap_style Literal['flat', 'square', 'round'] pen cap style to use 'square' Source code in prettyqt/gui/painter.py def set_pen ( self , style : PatternStr = \"solid\" , width : float = 1.0 , color : colors . ColorType = \"black\" , join_style : gui . pen . JoinStyleStr = \"bevel\" , cap_style : gui . pen . CapStyleStr = \"square\" , ): \"\"\"Set pen to use. Args: style: pen style to use width: pen width color: pen color join_style: pen join style to use cap_style: pen cap style to use \"\"\" pen = gui . Pen () pen . set_style ( style ) pen . set_cap_style ( cap_style ) pen . set_join_style ( join_style ) pen . setWidthF ( width ) pen . set_color ( color ) self . setPen ( pen )","title":"set_pen()"},{"location":"api/gui.html#prettyqt.gui.painterpath","text":"","title":"painterpath"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath","text":"","title":"PainterPath"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.get_fill_rule","text":"Return current fill rule. Possible values: \"odd_even\", \"winding\" Returns: Type Description FillRuleStr fill rule Source code in prettyqt/gui/painterpath.py def get_fill_rule ( self ) -> FillRuleStr : \"\"\"Return current fill rule. Possible values: \"odd_even\", \"winding\" Returns: fill rule \"\"\" return FILL_RULE . inverse [ self . fillRule ()]","title":"get_fill_rule()"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.set_fill_rule","text":"Set fill rule. Allowed values are \"odd_even\", \"winding\" Parameters: Name Type Description Default rule FillRuleStr fill rule to use required Exceptions: Type Description InvalidParamError fill rule does not exist Source code in prettyqt/gui/painterpath.py def set_fill_rule ( self , rule : FillRuleStr ): \"\"\"Set fill rule. Allowed values are \"odd_even\", \"winding\" Args: rule: fill rule to use Raises: InvalidParamError: fill rule does not exist \"\"\" if rule not in FILL_RULE : raise InvalidParamError ( rule , FILL_RULE ) self . setFillRule ( FILL_RULE [ rule ])","title":"set_fill_rule()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker","text":"","title":"painterpathstroker"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker","text":"","title":"PainterPathStroker"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_cap_style","text":"Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: Type Description str cap style Source code in prettyqt/gui/painterpathstroker.py def get_cap_style ( self ) -> str : \"\"\"Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: cap style \"\"\" return CAP_STYLES . inverse [ self . capStyle ()]","title":"get_cap_style()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_join_style","text":"Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: Type Description str join style Source code in prettyqt/gui/painterpathstroker.py def get_join_style ( self ) -> str : \"\"\"Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: join style \"\"\" return JOIN_STYLES . inverse [ self . joinStyle ()]","title":"get_join_style()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_cap_style","text":"Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Parameters: Name Type Description Default style str cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_cap_style ( self , style : str ): \"\"\"Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in CAP_STYLES : raise InvalidParamError ( style , CAP_STYLES ) self . setCapStyle ( CAP_STYLES [ style ])","title":"set_cap_style()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_join_style","text":"Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Parameters: Name Type Description Default style str join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_join_style ( self , style : str ): \"\"\"Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in JOIN_STYLES : raise InvalidParamError ( style , JOIN_STYLES ) self . setJoinStyle ( JOIN_STYLES [ style ])","title":"set_join_style()"},{"location":"api/gui.html#prettyqt.gui.pen","text":"","title":"pen"},{"location":"api/gui.html#prettyqt.gui.pen.Pen","text":"","title":"Pen"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_cap_style","text":"Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: Type Description Literal['flat', 'square', 'round'] cap style Source code in prettyqt/gui/pen.py def get_cap_style ( self ) -> CapStyleStr : \"\"\"Return current cap style. Possible values: \"flat\", \"square\", \"round\" Returns: cap style \"\"\" return CAP_STYLE . inverse [ self . capStyle ()]","title":"get_cap_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_join_style","text":"Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: Type Description Literal['miter', 'bevel', 'roundsvg_miter'] join style Source code in prettyqt/gui/pen.py def get_join_style ( self ) -> JoinStyleStr : \"\"\"Return current join style. Possible values: \"miter\", \"bevel\", \"round\", \"svg_miter\" Returns: join style \"\"\" return JOIN_STYLE . inverse [ self . joinStyle ()]","title":"get_join_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_style","text":"Return current pen style. Possible values: \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Returns: Type Description str pen style Source code in prettyqt/gui/pen.py def get_style ( self ) -> str : \"\"\"Return current pen style. Possible values: \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Returns: pen style \"\"\" return PEN_STYLE . inverse [ self . style ()]","title":"get_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_cap_style","text":"Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Parameters: Name Type Description Default style Literal['flat', 'square', 'round'] cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/pen.py def set_cap_style ( self , style : CapStyleStr ): \"\"\"Set cap style to use. Allowed values are \"flat\", \"square\", \"round\" Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in CAP_STYLE : raise InvalidParamError ( style , CAP_STYLE ) self . setCapStyle ( CAP_STYLE [ style ])","title":"set_cap_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_join_style","text":"Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Parameters: Name Type Description Default style Literal['miter', 'bevel', 'roundsvg_miter'] join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/pen.py def set_join_style ( self , style : JoinStyleStr ): \"\"\"Set join style to use. Allowed values are \"miter\", \"bevel\", \"round\", \"svg_miter\" Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in JOIN_STYLE : raise InvalidParamError ( style , JOIN_STYLE ) self . setJoinStyle ( JOIN_STYLE [ style ])","title":"set_join_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_style","text":"Set pen style to use. Allowed values are \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Parameters: Name Type Description Default style str pen style to use required Exceptions: Type Description InvalidParamError pen style does not exist Source code in prettyqt/gui/pen.py def set_style ( self , style : str ): \"\"\"Set pen style to use. Allowed values are \"none\", \"solid\", \"dash\", \"dot\", \"dash_dot\", \"dash_dot_dot\", \"custom_dash\" Args: style: pen style to use Raises: InvalidParamError: pen style does not exist \"\"\" if style not in PEN_STYLE : raise InvalidParamError ( style , PEN_STYLE ) self . setStyle ( PEN_STYLE [ style ])","title":"set_style()"},{"location":"api/gui.html#prettyqt.gui.polygon","text":"","title":"polygon"},{"location":"api/gui.html#prettyqt.gui.polygon.Polygon","text":"","title":"Polygon"},{"location":"api/gui.html#prettyqt.gui.polygon.Polygon.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/polygon.py def __reduce__ ( self ): return type ( self ), (), self . __getstate__ ()","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.sessionmanager","text":"","title":"sessionmanager"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager","text":"","title":"SessionManager"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.get_restart_hint","text":"Return current restart hint. Possible values: \"if_running\", \"anyway\", \"immediatly\", \"never\" Returns: Type Description str restart hint Source code in prettyqt/gui/sessionmanager.py def get_restart_hint ( self ) -> str : \"\"\"Return current restart hint. Possible values: \"if_running\", \"anyway\", \"immediatly\", \"never\" Returns: restart hint \"\"\" return RESTART_HINT . inverse [ self . restartHint ()]","title":"get_restart_hint()"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.set_restart_hint","text":"Set the restart hint. Allowed values are \"if_running\", \"anyway\", \"immediatly\", \"never\" Parameters: Name Type Description Default style str restart hint required Exceptions: Type Description InvalidParamError restart hint does not exist Source code in prettyqt/gui/sessionmanager.py def set_restart_hint ( self , style : str ): \"\"\"Set the restart hint. Allowed values are \"if_running\", \"anyway\", \"immediatly\", \"never\" Args: style: restart hint Raises: InvalidParamError: restart hint does not exist \"\"\" if style not in RESTART_HINT : raise InvalidParamError ( style , RESTART_HINT ) self . setRestartHint ( RESTART_HINT [ style ])","title":"set_restart_hint()"},{"location":"api/gui.html#prettyqt.gui.standarditem","text":"","title":"standarditem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem","text":"","title":"StandardItem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.clone","text":"clone(self) -> QStandardItem Source code in prettyqt/gui/standarditem.py def clone ( self ): item = self . __class__ () core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item","title":"clone()"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/gui/standarditem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/gui.html#prettyqt.gui.statictext","text":"","title":"statictext"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText","text":"","title":"StaticText"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_performance_hint","text":"Return current performance hint. Possible values: \"moderate\", \"aggressive\" Returns: Type Description str performance hint Source code in prettyqt/gui/statictext.py def get_performance_hint ( self ) -> str : \"\"\"Return current performance hint. Possible values: \"moderate\", \"aggressive\" Returns: performance hint \"\"\" return PERFORMANCE_HINT . inverse [ self . performanceHint ()]","title":"get_performance_hint()"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_text_format","text":"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str text format Source code in prettyqt/gui/statictext.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_performance_hint","text":"Set the performance hint. Allowed values are \"moderate\", \"aggressive\" Parameters: Name Type Description Default hint str performance hint to use required Exceptions: Type Description InvalidParamError performance hint does not exist Source code in prettyqt/gui/statictext.py def set_performance_hint ( self , hint : str ): \"\"\"Set the performance hint. Allowed values are \"moderate\", \"aggressive\" Args: hint: performance hint to use Raises: InvalidParamError: performance hint does not exist \"\"\" if hint not in PERFORMANCE_HINT : raise InvalidParamError ( hint , PERFORMANCE_HINT ) self . setPerformanceHint ( PERFORMANCE_HINT [ hint ])","title":"set_performance_hint()"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_text_format","text":"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/gui/statictext.py def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ])","title":"set_text_format()"},{"location":"api/gui.html#prettyqt.gui.surface","text":"","title":"surface"},{"location":"api/gui.html#prettyqt.gui.surface.Surface","text":"","title":"Surface"},{"location":"api/gui.html#prettyqt.gui.surface.Surface.get_surface_class","text":"Get the current surface class. Possible values: \"window\", \"offscreen\" Returns: Type Description str surface class Source code in prettyqt/gui/surface.py def get_surface_class ( self ) -> str : \"\"\"Get the current surface class. Possible values: \"window\", \"offscreen\" Returns: surface class \"\"\" return SURFACE_CLASS . inverse [ self . surfaceClass ()]","title":"get_surface_class()"},{"location":"api/gui.html#prettyqt.gui.surface.Surface.get_surface_type","text":"Get the current surface type. Possible values: \"raster\", \"open_gl\", \"raster_gl\", \"open_vg\", \"vulkan\", \"metal\" Returns: Type Description str surface type Source code in prettyqt/gui/surface.py def get_surface_type ( self ) -> str : \"\"\"Get the current surface type. Possible values: \"raster\", \"open_gl\", \"raster_gl\", \"open_vg\", \"vulkan\", \"metal\" Returns: surface type \"\"\" return SURFACE_TYPES . inverse [ self . surfaceType ()]","title":"get_surface_type()"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter","text":"","title":"syntaxhighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter","text":"","title":"SyntaxHighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt )","title":"highlightBlock()"},{"location":"api/gui.html#prettyqt.gui.textblockuserdata","text":"","title":"textblockuserdata"},{"location":"api/gui.html#prettyqt.gui.textblockuserdata.TextBlockUserData","text":"Storage for the user data associated with each line.","title":"TextBlockUserData"},{"location":"api/gui.html#prettyqt.gui.textcharformat","text":"","title":"textcharformat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat","text":"","title":"TextCharFormat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_font_weight","text":"Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: Type Description str current font weight Source code in prettyqt/gui/textcharformat.py def get_font_weight ( self ) -> str : \"\"\"Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: current font weight \"\"\" return gui . font . WEIGHTS . inverse [ self . fontWeight ()]","title":"get_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_underline_style","text":"Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: Type Description str current underline style Source code in prettyqt/gui/textcharformat.py def get_underline_style ( self ) -> str : \"\"\"Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: current underline style \"\"\" return UNDERLINE_STYLES . inverse [ self . underlineStyle ()]","title":"get_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_vertical_alignment","text":"Get current vertical alignment. Possible values: \"normal\", \"super_script\", \"sub_script\", \"middle\", \"bottom\", \"top\", \"baseline\" Returns: Type Description str current vertical alignment Source code in prettyqt/gui/textcharformat.py def get_vertical_alignment ( self ) -> str : \"\"\"Get current vertical alignment. Possible values: \"normal\", \"super_script\", \"sub_script\", \"middle\", \"bottom\", \"top\", \"baseline\" Returns: current vertical alignment \"\"\" return VERTICAL_ALIGNMENT . inverse [ self . verticalAlignment ()]","title":"get_vertical_alignment()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_style_hint","text":"Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str font style hint required Exceptions: Type Description InvalidParamError invalid font style hint Source code in prettyqt/gui/textcharformat.py def set_font_style_hint ( self , hint : str ): \"\"\"Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in gui . font . STYLE_HINTS : raise InvalidParamError ( hint , gui . font . STYLE_HINTS ) self . setFontStyleHint ( gui . font . STYLE_HINTS [ hint ])","title":"set_font_style_hint()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_weight","text":"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/textcharformat.py def set_font_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHTS : raise InvalidParamError ( weight , gui . font . WEIGHTS ) self . setFontWeight ( gui . font . WEIGHTS [ weight ])","title":"set_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_underline_style","text":"Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Parameters: Name Type Description Default style str underline style required Exceptions: Type Description InvalidParamError invalid underline style Source code in prettyqt/gui/textcharformat.py def set_underline_style ( self , style : str ): \"\"\"Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLES : raise InvalidParamError ( style , UNDERLINE_STYLES ) self . setUnderlineStyle ( UNDERLINE_STYLES [ style ])","title":"set_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_vertical_alignment","text":"Set the vertical alignment. Valid values: \"normal\", \"super_script\", \"sub_script\", \"middle\", \"bottom\", \"top\", \"baseline\" Parameters: Name Type Description Default alignment str vertical alignment required Exceptions: Type Description InvalidParamError invalid vertical alignment Source code in prettyqt/gui/textcharformat.py def set_vertical_alignment ( self , alignment : str ): \"\"\"Set the vertical alignment. Valid values: \"normal\", \"super_script\", \"sub_script\", \"middle\", \"bottom\", \"top\", \"baseline\" Args: alignment: vertical alignment Raises: InvalidParamError: invalid vertical alignment \"\"\" if alignment not in VERTICAL_ALIGNMENT : raise InvalidParamError ( alignment , VERTICAL_ALIGNMENT ) self . setVerticalAlignment ( VERTICAL_ALIGNMENT [ alignment ])","title":"set_vertical_alignment()"},{"location":"api/gui.html#prettyqt.gui.textcursor","text":"","title":"textcursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor","text":"","title":"TextCursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.edit_block","text":"Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock ()","title":"edit_block()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select","text":"select(self, QTextCursor.SelectionType) Source code in prettyqt/gui/textcursor.py def select ( self , selection ): if selection in SELECTION_TYPES : selection = SELECTION_TYPES [ selection ] super () . select ( selection )","title":"select()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select_text","text":"Select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos Union[int, str] Start position required end_pos Union[int, str] End position required Source code in prettyqt/gui/textcursor.py def select_text ( self , start_pos : Union [ int , str ], end_pos : Union [ int , str ]) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText ()","title":"select_text()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.set_position","text":"Set cursor to given position. Parameters: Name Type Description Default pos int Cursor position required mode str Move mode 'move' Source code in prettyqt/gui/textcursor.py def set_position ( self , pos : int , mode : str = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODES [ mode ])","title":"set_position()"},{"location":"api/gui.html#prettyqt.gui.textdocument","text":"","title":"textdocument"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument","text":"","title":"TextDocument"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.clear_stacks","text":"Clear undo / redo stack. Allowed values are \"undo\", \"redo\", \"undo_and_redo\" Parameters: Name Type Description Default stack str stack to clear required Exceptions: Type Description InvalidParamError stack type does not exist Source code in prettyqt/gui/textdocument.py def clear_stacks ( self , stack : str ): \"\"\"Clear undo / redo stack. Allowed values are \"undo\", \"redo\", \"undo_and_redo\" Args: stack: stack to clear Raises: InvalidParamError: stack type does not exist \"\"\" if stack not in STACKS : raise InvalidParamError ( stack , STACKS ) self . clearUndoRedoStacks ( STACKS [ stack ])","title":"clear_stacks()"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.get_default_cursor_move_style","text":"Return current cursor move style. Possible values: \"logical\", \"visual\" Returns: Type Description str cursor move style Source code in prettyqt/gui/textdocument.py def get_default_cursor_move_style ( self ) -> str : \"\"\"Return current cursor move style. Possible values: \"logical\", \"visual\" Returns: cursor move style \"\"\" return CURSOR_MOVE_STYLES . inverse [ self . defaultCursorMoveStyle ()]","title":"get_default_cursor_move_style()"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.set_default_cursor_move_style","text":"Set the cursor move style. Allowed values are \"logical\", \"visual\" Parameters: Name Type Description Default style str cursor move style required Exceptions: Type Description InvalidParamError cursor move style does not exist Source code in prettyqt/gui/textdocument.py def set_default_cursor_move_style ( self , style : str ): \"\"\"Set the cursor move style. Allowed values are \"logical\", \"visual\" Args: style: cursor move style Raises: InvalidParamError: cursor move style does not exist \"\"\" if style not in CURSOR_MOVE_STYLES : raise InvalidParamError ( style , CURSOR_MOVE_STYLES ) self . setDefaultCursorMoveStyle ( CURSOR_MOVE_STYLES [ style ])","title":"set_default_cursor_move_style()"},{"location":"api/gui.html#prettyqt.gui.textformat","text":"","title":"textformat"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormat","text":"","title":"TextFormat"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormat.get_layout_direction","text":"Get the current layout direction. Possible values: \"left_to_right\", \"right_to_left\", \"auto\" Returns: Type Description str layout direction Source code in prettyqt/gui/textformat.py def get_layout_direction ( self ) -> str : \"\"\"Get the current layout direction. Possible values: \"left_to_right\", \"right_to_left\", \"auto\" Returns: layout direction \"\"\" return LAYOUT_DIRECTIONS . inverse [ self . layoutDirection ()]","title":"get_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormat.set_layout_direction","text":"Set layout direction. Valid values: \"left_to_right\", \"right_to_left\", \"auto\" Parameters: Name Type Description Default direction str layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/textformat.py def set_layout_direction ( self , direction : str ): \"\"\"Set layout direction. Valid values: \"left_to_right\", \"right_to_left\", \"auto\" Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in LAYOUT_DIRECTIONS : raise InvalidParamError ( direction , LAYOUT_DIRECTIONS ) self . setLayoutDirection ( LAYOUT_DIRECTIONS [ direction ])","title":"set_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.textframeformat","text":"","title":"textframeformat"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat","text":"","title":"TextFrameFormat"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_border_style","text":"Get the current border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: Type Description str border style Source code in prettyqt/gui/textframeformat.py def get_border_style ( self ) -> str : \"\"\"Get the current border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: border style \"\"\" return BORDER_STYLES . inverse [ self . borderStyle ()]","title":"get_border_style()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_page_break_policy","text":"Get the current page break policy. Possible values: \"auto\", \"always_before\", \"always_after\" Returns: Type Description str page break policy Source code in prettyqt/gui/textframeformat.py def get_page_break_policy ( self ) -> str : \"\"\"Get the current page break policy. Possible values: \"auto\", \"always_before\", \"always_after\" Returns: page break policy \"\"\" return gui . textformat . PAGE_BREAK_FLAG . inverse [ self . pageBreakPolicy ()]","title":"get_page_break_policy()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_position","text":"Get the current position. Possible values: \"in_flow\", \"flow_left\", \"flow_right\" Returns: Type Description str position Source code in prettyqt/gui/textframeformat.py def get_position ( self ) -> str : \"\"\"Get the current position. Possible values: \"in_flow\", \"flow_left\", \"flow_right\" Returns: position \"\"\" return POSITIONS . inverse [ self . position ()]","title":"get_position()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_border_style","text":"Set border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/textframeformat.py def set_border_style ( self , style : str ): \"\"\"Set border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in BORDER_STYLES : raise InvalidParamError ( style , BORDER_STYLES ) self . setBorderStyle ( BORDER_STYLES [ style ])","title":"set_border_style()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_page_break_policy","text":"Set page break policy. Valid values: \"auto\", \"always_before\", \"always_after\" Parameters: Name Type Description Default policy str page break policy required Exceptions: Type Description InvalidParamError page break policy does not exist Source code in prettyqt/gui/textframeformat.py def set_page_break_policy ( self , policy : str ): \"\"\"Set page break policy. Valid values: \"auto\", \"always_before\", \"always_after\" Args: policy: page break policy Raises: InvalidParamError: page break policy does not exist \"\"\" if policy not in gui . textformat . PAGE_BREAK_FLAG : raise InvalidParamError ( policy , gui . textformat . PAGE_BREAK_FLAG ) self . setPageBreakPolicy ( gui . textformat . PAGE_BREAK_FLAG [ policy ])","title":"set_page_break_policy()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_position","text":"Set position. Valid values: \"in_flow\", \"flow_left\", \"flow_right\" Parameters: Name Type Description Default position str position required Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/gui/textframeformat.py def set_position ( self , position : str ): \"\"\"Set position. Valid values: \"in_flow\", \"flow_left\", \"flow_right\" Args: position: position Raises: InvalidParamError: position does not exist \"\"\" if position not in POSITIONS : raise InvalidParamError ( position , POSITIONS ) self . setPosition ( POSITIONS [ position ])","title":"set_position()"},{"location":"api/gui.html#prettyqt.gui.textlength","text":"","title":"textlength"},{"location":"api/gui.html#prettyqt.gui.textlength.TextLength","text":"","title":"TextLength"},{"location":"api/gui.html#prettyqt.gui.textlength.TextLength.get_type","text":"Return type of this length object. Possible values: \"variable\", \"fixed\", \"percentage\" Returns: Type Description str timer type Source code in prettyqt/gui/textlength.py def get_type ( self ) -> str : \"\"\"Return type of this length object. Possible values: \"variable\", \"fixed\", \"percentage\" Returns: timer type \"\"\" return TYPES . inverse [ self . type ()]","title":"get_type()"},{"location":"api/gui.html#prettyqt.gui.textlistformat","text":"","title":"textlistformat"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat","text":"","title":"TextListFormat"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.get_style","text":"Get current style. Possible values are \"disc\", \"circle\", square\", \"decimal\", \"lower_alpha\", \"upper_alpha\", \"lower_roman\", upper_roman\" Returns: Type Description str current style Source code in prettyqt/gui/textlistformat.py def get_style ( self ) -> str : \"\"\"Get current style. Possible values are \"disc\", \"circle\", square\", \"decimal\", \"lower_alpha\", \"upper_alpha\", \"lower_roman\", upper_roman\" Returns: current style \"\"\" return STYLES . inverse [ self . style ()]","title":"get_style()"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.set_style","text":"Set the style. Valid values are \"disc\", \"circle\", square\", \"decimal\", \"lower_alpha\", \"upper_alpha\", \"lower_roman\", upper_roman\" Parameters: Name Type Description Default style str style required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/gui/textlistformat.py def set_style ( self , style : str ): \"\"\"Set the style. Valid values are \"disc\", \"circle\", square\", \"decimal\", \"lower_alpha\", \"upper_alpha\", \"lower_roman\", upper_roman\" Args: style: style Raises: InvalidParamError: invalid style \"\"\" if style not in STYLES : raise InvalidParamError ( style , STYLES ) self . setStyle ( STYLES [ style ])","title":"set_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat","text":"","title":"texttablecellformat"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat","text":"","title":"TextTableCellFormat"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_bottom_border_style","text":"Get the current bottom border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: Type Description str bottom border style Source code in prettyqt/gui/texttablecellformat.py def get_bottom_border_style ( self ) -> str : \"\"\"Get the current bottom border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: bottom border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . bottomBorderStyle ()]","title":"get_bottom_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_left_border_style","text":"Get the current left border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: Type Description str left border style Source code in prettyqt/gui/texttablecellformat.py def get_left_border_style ( self ) -> str : \"\"\"Get the current left border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: left border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . leftBorderStyle ()]","title":"get_left_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_right_border_style","text":"Get the current right border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: Type Description str right border style Source code in prettyqt/gui/texttablecellformat.py def get_right_border_style ( self ) -> str : \"\"\"Get the current right border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: right border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . rightBorderStyle ()]","title":"get_right_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_top_border_style","text":"Get the current top border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: Type Description str top border style Source code in prettyqt/gui/texttablecellformat.py def get_top_border_style ( self ) -> str : \"\"\"Get the current top border style. Possible values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Returns: top border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . topBorderStyle ()]","title":"get_top_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_border_style","text":"Set border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_border_style ( self , style : str ): \"\"\"Set border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_bottom_border_style","text":"Set bottom border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str bottom border style required Exceptions: Type Description InvalidParamError bottom border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_bottom_border_style ( self , style : str ): \"\"\"Set bottom border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: bottom border style Raises: InvalidParamError: bottom border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBottomBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_bottom_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_left_border_style","text":"Set left border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str left border style required Exceptions: Type Description InvalidParamError left border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_left_border_style ( self , style : str ): \"\"\"Set left border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: left border style Raises: InvalidParamError: left border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setLeftBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_left_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_right_border_style","text":"Set right border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str right border style required Exceptions: Type Description InvalidParamError right border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_right_border_style ( self , style : str ): \"\"\"Set right border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: right border style Raises: InvalidParamError: right border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setRightBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_right_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_top_border_style","text":"Set top border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Parameters: Name Type Description Default style str top border style required Exceptions: Type Description InvalidParamError top border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_top_border_style ( self , style : str ): \"\"\"Set top border style. Valid values: \"none\", \"dotted\", \"dashed\", \"solid\", \"double\", \"dot_dash\", \"dot_dot_dash\", \"groove\", \"ridge\", \"inset\", \"outset\" Args: style: top border style Raises: InvalidParamError: top border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setTopBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_top_border_style()"},{"location":"api/gui.html#prettyqt.gui.transform","text":"","title":"transform"},{"location":"api/gui.html#prettyqt.gui.transform.Transform","text":"","title":"Transform"},{"location":"api/gui.html#prettyqt.gui.transform.Transform.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/transform.py def __reduce__ ( self ): return type ( self ), (), self . __getstate__ ()","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.validator","text":"","title":"validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator","text":"","title":"Validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator.__radd__","text":"Needed for sum(). Source code in prettyqt/gui/validator.py def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other )","title":"__radd__()"},{"location":"api/gui.html#prettyqt.gui.window","text":"","title":"window"},{"location":"api/gui.html#prettyqt.gui.window.Window","text":"","title":"Window"},{"location":"api/gui.html#prettyqt.gui.window.Window.get_visibility","text":"Get the current window visibility. Possible values: \"windowed\", \"maximized\", \"minimized\", \"fullscreen\", \"automatic\", \"hidden\" Returns: Type Description str window visibility Source code in prettyqt/gui/window.py def get_visibility ( self ) -> str : \"\"\"Get the current window visibility. Possible values: \"windowed\", \"maximized\", \"minimized\", \"fullscreen\", \"automatic\", \"hidden\" Returns: window visibility \"\"\" return VISIBILITIES . inverse [ self . visibility ()]","title":"get_visibility()"},{"location":"api/gui.html#prettyqt.gui.window.Window.set_visibility","text":"Set window visibility. Valid values: \"windowed\", \"maximized\", \"minimized\", \"fullscreen\", \"automatic\", \"hidden\" Parameters: Name Type Description Default visibility str window visibility required Exceptions: Type Description InvalidParamError window visibility does not exist Source code in prettyqt/gui/window.py def set_visibility ( self , visibility : str ): \"\"\"Set window visibility. Valid values: \"windowed\", \"maximized\", \"minimized\", \"fullscreen\", \"automatic\", \"hidden\" Args: visibility: window visibility Raises: InvalidParamError: window visibility does not exist \"\"\" if visibility not in VISIBILITIES : raise InvalidParamError ( visibility , VISIBILITIES ) self . setVisibility ( VISIBILITIES [ visibility ])","title":"set_visibility()"},{"location":"api/location.html","text":"location module Location module. geomaneuver GeoManeuver get_direction ( self ) Return current direction. Possible values: \"none\", \"forward\", \"bear_right\", \"light_right\", \"right\", \"hard_right\", \"u_turn_right\", \"bear_left\", \"light_left\", \"left\", \"hard_left\", \"u_turn_left\" Returns: Type Description str Direction Source code in prettyqt/location/geomaneuver.py def get_direction ( self ) -> str : \"\"\"Return current direction. Possible values: \"none\", \"forward\", \"bear_right\", \"light_right\", \"right\", \"hard_right\", \"u_turn_right\", \"bear_left\", \"light_left\", \"left\", \"hard_left\", \"u_turn_left\" Returns: Direction \"\"\" return INSTRUCTION_DIRECTION . inverse [ self . direction ()] set_direction ( self , direction ) Set the direction. Allowed values are \"none\", \"forward\", \"bear_right\", \"light_right\", \"right\", \"hard_right\", \"u_turn_right\", \"bear_left\", \"light_left\", \"left\", \"hard_left\", \"u_turn_left\" Parameters: Name Type Description Default direction str Direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/location/geomaneuver.py def set_direction ( self , direction : str ): \"\"\"Set the direction. Allowed values are \"none\", \"forward\", \"bear_right\", \"light_right\", \"right\", \"hard_right\", \"u_turn_right\", \"bear_left\", \"light_left\", \"left\", \"hard_left\", \"u_turn_left\" Args: direction: Direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in INSTRUCTION_DIRECTION : raise InvalidParamError ( direction , INSTRUCTION_DIRECTION ) self . setDirection ( INSTRUCTION_DIRECTION [ direction ]) georouterequest GeoRouteRequest get_feature_weight ( self , feature ) Return current feature weight. Possible values for weight: \"neutral\", \"prefer\", \"require\", \"avoid\", \"disallow\" Returns: Type Description str Feature weight Source code in prettyqt/location/georouterequest.py def get_feature_weight ( self , feature : str ) -> str : \"\"\"Return current feature weight. Possible values for weight: \"neutral\", \"prefer\", \"require\", \"avoid\", \"disallow\" Returns: Feature weight \"\"\" if feature not in FEATURE_TYPES : raise InvalidParamError ( feature , FEATURE_TYPES ) return FEATURE_WEIGHTS . inverse [ self . featureWeight ( FEATURE_TYPES [ feature ])] get_route_optimization ( self ) Return current route optimization. Possible values: \"shortest\", \"fastest\", \"most_economic\", \"most_scenic\" Returns: Type Description str Route optimization Source code in prettyqt/location/georouterequest.py def get_route_optimization ( self ) -> str : \"\"\"Return current route optimization. Possible values: \"shortest\", \"fastest\", \"most_economic\", \"most_scenic\" Returns: Route optimization \"\"\" return ROUTE_OPTIMIZATION . inverse [ self . routeOptimization ()] set_feature_weight ( self , feature , weight ) Set the feature weight. Allowed values for weight: \"neutral\", \"prefer\", \"require\", \"avoid\", \"disallow\" Parameters: Name Type Description Default feature str Feature type required weight str Feature weight required Exceptions: Type Description InvalidParamError feature weight / type does not exist Source code in prettyqt/location/georouterequest.py def set_feature_weight ( self , feature : str , weight : str ): \"\"\"Set the feature weight. Allowed values for weight: \"neutral\", \"prefer\", \"require\", \"avoid\", \"disallow\" Args: feature: Feature type weight: Feature weight Raises: InvalidParamError: feature weight / type does not exist \"\"\" if weight not in FEATURE_WEIGHTS : raise InvalidParamError ( weight , FEATURE_WEIGHTS ) if feature not in FEATURE_TYPES : raise InvalidParamError ( feature , FEATURE_TYPES ) self . setFeatureWeight ( FEATURE_TYPES [ feature ], FEATURE_WEIGHTS [ weight ]) set_route_optimization ( self , optimization ) Set the route optimization. Allowed values are \"shortest\", \"fastest\", \"most_economic\", \"most_scenic\" Parameters: Name Type Description Default optimization str Route optimization required Exceptions: Type Description InvalidParamError route optimization does not exist Source code in prettyqt/location/georouterequest.py def set_route_optimization ( self , optimization : str ): \"\"\"Set the route optimization. Allowed values are \"shortest\", \"fastest\", \"most_economic\", \"most_scenic\" Args: optimization: Route optimization Raises: InvalidParamError: route optimization does not exist \"\"\" if optimization not in ROUTE_OPTIMIZATION : raise InvalidParamError ( optimization , ROUTE_OPTIMIZATION ) self . setRouteOptimization ( ROUTE_OPTIMIZATION [ optimization ]) place Place get_visibility ( self ) Return visibility. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Type Description str Visibility Source code in prettyqt/location/place.py def get_visibility ( self ) -> str : \"\"\"Return visibility. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Visibility \"\"\" return VISIBILITY . inverse [ self . visibility ()] placecategory PlaceCategory get_visibility ( self ) Return the visibility of the place. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Type Description str Visibility Source code in prettyqt/location/placecategory.py def get_visibility ( self ) -> str : \"\"\"Return the visibility of the place. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Visibility \"\"\" return VISIBILITY . inverse [ self . visibility ()] placecontent PlaceContent get_type ( self ) Return the visibility of the place. Possible values are \"none\", \"image\", \"review\", \"editorial\", \"custom\" Returns: Type Description str Place type Source code in prettyqt/location/placecontent.py def get_type ( self ) -> str : \"\"\"Return the visibility of the place. Possible values are \"none\", \"image\", \"review\", \"editorial\", \"custom\" Returns: Place type \"\"\" return TYPE . inverse [ self . type ()] placecontentrequest PlaceContentRequest get_content_type ( self ) Return current content type. Possible values: \"none\", \"image\", \"review\", \"editorial\", \"custom\" Returns: Type Description str Relevance type Source code in prettyqt/location/placecontentrequest.py def get_content_type ( self ) -> str : \"\"\"Return current content type. Possible values: \"none\", \"image\", \"review\", \"editorial\", \"custom\" Returns: Relevance type \"\"\" return location . placecontent . TYPE . inverse [ self . contentType ()] set_content_type ( self , typ ) Set the content type. Allowed values are \"none\", \"image\", \"review\", \"editorial\", \"custom\" Parameters: Name Type Description Default typ str Relevance type required Exceptions: Type Description InvalidParamError content type does not exist Source code in prettyqt/location/placecontentrequest.py def set_content_type ( self , typ : str ): \"\"\"Set the content type. Allowed values are \"none\", \"image\", \"review\", \"editorial\", \"custom\" Args: typ: Relevance type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in location . placecontent . TYPE : raise InvalidParamError ( typ , location . placecontent . TYPE ) self . setContentType ( location . placecontent . TYPE [ typ ]) placeidreply PlaceIdReply get_operation_type ( self ) Get current operation_type. Possible values: \"save_place\", \"remove_place\", save_category\", \"remove_category\" Returns: Type Description str current operation_type Source code in prettyqt/location/placeidreply.py def get_operation_type ( self ) -> str : \"\"\"Get current operation_type. Possible values: \"save_place\", \"remove_place\", save_category\", \"remove_category\" Returns: current operation_type \"\"\" return OPERATION_TYPES . inverse [ self . operationType ()] placereply PlaceReply get_error ( self ) Return error type. possible values: \"none\" \"place_does_not_exist\", \"category_does_not_exist\", \"communication\", \"parse\", \"permissions\", \"unsupported\", \"bad_argument\", \"cancel\", \"unknown\" Returns: Type Description str Error type Source code in prettyqt/location/placereply.py def get_error ( self ) -> str : \"\"\"Return error type. possible values: \"none\" \"place_does_not_exist\", \"category_does_not_exist\", \"communication\", \"parse\", \"permissions\", \"unsupported\", \"bad_argument\", \"cancel\", \"unknown\" Returns: Error type \"\"\" return ERROR . inverse [ self . error ()] get_type ( self ) Return type. possible values: \"generic\" \"details\", \"search\", \"search_suggestion\", \"content\", \"id\", \"match\", Returns: Type Description str Type Source code in prettyqt/location/placereply.py def get_type ( self ) -> str : \"\"\"Return type. possible values: \"generic\" \"details\", \"search\", \"search_suggestion\", \"content\", \"id\", \"match\", Returns: Type \"\"\" return TYPE . inverse [ self . type ()] placesearchrequest PlaceSearchRequest get_relevance_hint ( self ) Return current relevance hint. Possible values: \"unspecified\", \"distance\", \"lexical_place_name\" Returns: Type Description str Relevance hint Source code in prettyqt/location/placesearchrequest.py def get_relevance_hint ( self ) -> str : \"\"\"Return current relevance hint. Possible values: \"unspecified\", \"distance\", \"lexical_place_name\" Returns: Relevance hint \"\"\" return RELEVANCE_HINT . inverse [ self . relevanceHint ()] get_visibility_scope ( self ) Return the scope of the visibility. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Type Description str Visibility scope Source code in prettyqt/location/placesearchrequest.py def get_visibility_scope ( self ) -> str : \"\"\"Return the scope of the visibility. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Visibility scope \"\"\" return VISIBILITY . inverse [ self . visibilityScope ()] set_relevance_hint ( self , hint ) Set the relevance hint. Allowed values are \"unspecified\", \"distance\", \"lexical_place_name\" Parameters: Name Type Description Default hint str Relevance hint required Exceptions: Type Description InvalidParamError relevance hint does not exist Source code in prettyqt/location/placesearchrequest.py def set_relevance_hint ( self , hint : str ): \"\"\"Set the relevance hint. Allowed values are \"unspecified\", \"distance\", \"lexical_place_name\" Args: hint: Relevance hint Raises: InvalidParamError: relevance hint does not exist \"\"\" if hint not in RELEVANCE_HINT : raise InvalidParamError ( hint , RELEVANCE_HINT ) self . setRelevanceHint ( RELEVANCE_HINT [ hint ]) placesearchresult PlaceSearchResult get_type ( self ) Return result type. possible values: \"unknown\" \"place\", \"proposed_search\", Returns: Type Description str Result type Source code in prettyqt/location/placesearchresult.py def get_type ( self ) -> str : \"\"\"Return result type. possible values: \"unknown\" \"place\", \"proposed_search\", Returns: Result type \"\"\" return TYPE . inverse [ self . type ()]","title":"location"},{"location":"api/location.html#location-module","text":"","title":"location module"},{"location":"api/location.html#prettyqt.location","text":"Location module.","title":"prettyqt.location"},{"location":"api/location.html#prettyqt.location.geomaneuver","text":"","title":"geomaneuver"},{"location":"api/location.html#prettyqt.location.geomaneuver.GeoManeuver","text":"","title":"GeoManeuver"},{"location":"api/location.html#prettyqt.location.geomaneuver.GeoManeuver.get_direction","text":"Return current direction. Possible values: \"none\", \"forward\", \"bear_right\", \"light_right\", \"right\", \"hard_right\", \"u_turn_right\", \"bear_left\", \"light_left\", \"left\", \"hard_left\", \"u_turn_left\" Returns: Type Description str Direction Source code in prettyqt/location/geomaneuver.py def get_direction ( self ) -> str : \"\"\"Return current direction. Possible values: \"none\", \"forward\", \"bear_right\", \"light_right\", \"right\", \"hard_right\", \"u_turn_right\", \"bear_left\", \"light_left\", \"left\", \"hard_left\", \"u_turn_left\" Returns: Direction \"\"\" return INSTRUCTION_DIRECTION . inverse [ self . direction ()]","title":"get_direction()"},{"location":"api/location.html#prettyqt.location.geomaneuver.GeoManeuver.set_direction","text":"Set the direction. Allowed values are \"none\", \"forward\", \"bear_right\", \"light_right\", \"right\", \"hard_right\", \"u_turn_right\", \"bear_left\", \"light_left\", \"left\", \"hard_left\", \"u_turn_left\" Parameters: Name Type Description Default direction str Direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/location/geomaneuver.py def set_direction ( self , direction : str ): \"\"\"Set the direction. Allowed values are \"none\", \"forward\", \"bear_right\", \"light_right\", \"right\", \"hard_right\", \"u_turn_right\", \"bear_left\", \"light_left\", \"left\", \"hard_left\", \"u_turn_left\" Args: direction: Direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in INSTRUCTION_DIRECTION : raise InvalidParamError ( direction , INSTRUCTION_DIRECTION ) self . setDirection ( INSTRUCTION_DIRECTION [ direction ])","title":"set_direction()"},{"location":"api/location.html#prettyqt.location.georouterequest","text":"","title":"georouterequest"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest","text":"","title":"GeoRouteRequest"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.get_feature_weight","text":"Return current feature weight. Possible values for weight: \"neutral\", \"prefer\", \"require\", \"avoid\", \"disallow\" Returns: Type Description str Feature weight Source code in prettyqt/location/georouterequest.py def get_feature_weight ( self , feature : str ) -> str : \"\"\"Return current feature weight. Possible values for weight: \"neutral\", \"prefer\", \"require\", \"avoid\", \"disallow\" Returns: Feature weight \"\"\" if feature not in FEATURE_TYPES : raise InvalidParamError ( feature , FEATURE_TYPES ) return FEATURE_WEIGHTS . inverse [ self . featureWeight ( FEATURE_TYPES [ feature ])]","title":"get_feature_weight()"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.get_route_optimization","text":"Return current route optimization. Possible values: \"shortest\", \"fastest\", \"most_economic\", \"most_scenic\" Returns: Type Description str Route optimization Source code in prettyqt/location/georouterequest.py def get_route_optimization ( self ) -> str : \"\"\"Return current route optimization. Possible values: \"shortest\", \"fastest\", \"most_economic\", \"most_scenic\" Returns: Route optimization \"\"\" return ROUTE_OPTIMIZATION . inverse [ self . routeOptimization ()]","title":"get_route_optimization()"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.set_feature_weight","text":"Set the feature weight. Allowed values for weight: \"neutral\", \"prefer\", \"require\", \"avoid\", \"disallow\" Parameters: Name Type Description Default feature str Feature type required weight str Feature weight required Exceptions: Type Description InvalidParamError feature weight / type does not exist Source code in prettyqt/location/georouterequest.py def set_feature_weight ( self , feature : str , weight : str ): \"\"\"Set the feature weight. Allowed values for weight: \"neutral\", \"prefer\", \"require\", \"avoid\", \"disallow\" Args: feature: Feature type weight: Feature weight Raises: InvalidParamError: feature weight / type does not exist \"\"\" if weight not in FEATURE_WEIGHTS : raise InvalidParamError ( weight , FEATURE_WEIGHTS ) if feature not in FEATURE_TYPES : raise InvalidParamError ( feature , FEATURE_TYPES ) self . setFeatureWeight ( FEATURE_TYPES [ feature ], FEATURE_WEIGHTS [ weight ])","title":"set_feature_weight()"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.set_route_optimization","text":"Set the route optimization. Allowed values are \"shortest\", \"fastest\", \"most_economic\", \"most_scenic\" Parameters: Name Type Description Default optimization str Route optimization required Exceptions: Type Description InvalidParamError route optimization does not exist Source code in prettyqt/location/georouterequest.py def set_route_optimization ( self , optimization : str ): \"\"\"Set the route optimization. Allowed values are \"shortest\", \"fastest\", \"most_economic\", \"most_scenic\" Args: optimization: Route optimization Raises: InvalidParamError: route optimization does not exist \"\"\" if optimization not in ROUTE_OPTIMIZATION : raise InvalidParamError ( optimization , ROUTE_OPTIMIZATION ) self . setRouteOptimization ( ROUTE_OPTIMIZATION [ optimization ])","title":"set_route_optimization()"},{"location":"api/location.html#prettyqt.location.place","text":"","title":"place"},{"location":"api/location.html#prettyqt.location.place.Place","text":"","title":"Place"},{"location":"api/location.html#prettyqt.location.place.Place.get_visibility","text":"Return visibility. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Type Description str Visibility Source code in prettyqt/location/place.py def get_visibility ( self ) -> str : \"\"\"Return visibility. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Visibility \"\"\" return VISIBILITY . inverse [ self . visibility ()]","title":"get_visibility()"},{"location":"api/location.html#prettyqt.location.placecategory","text":"","title":"placecategory"},{"location":"api/location.html#prettyqt.location.placecategory.PlaceCategory","text":"","title":"PlaceCategory"},{"location":"api/location.html#prettyqt.location.placecategory.PlaceCategory.get_visibility","text":"Return the visibility of the place. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Type Description str Visibility Source code in prettyqt/location/placecategory.py def get_visibility ( self ) -> str : \"\"\"Return the visibility of the place. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Visibility \"\"\" return VISIBILITY . inverse [ self . visibility ()]","title":"get_visibility()"},{"location":"api/location.html#prettyqt.location.placecontent","text":"","title":"placecontent"},{"location":"api/location.html#prettyqt.location.placecontent.PlaceContent","text":"","title":"PlaceContent"},{"location":"api/location.html#prettyqt.location.placecontent.PlaceContent.get_type","text":"Return the visibility of the place. Possible values are \"none\", \"image\", \"review\", \"editorial\", \"custom\" Returns: Type Description str Place type Source code in prettyqt/location/placecontent.py def get_type ( self ) -> str : \"\"\"Return the visibility of the place. Possible values are \"none\", \"image\", \"review\", \"editorial\", \"custom\" Returns: Place type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/location.html#prettyqt.location.placecontentrequest","text":"","title":"placecontentrequest"},{"location":"api/location.html#prettyqt.location.placecontentrequest.PlaceContentRequest","text":"","title":"PlaceContentRequest"},{"location":"api/location.html#prettyqt.location.placecontentrequest.PlaceContentRequest.get_content_type","text":"Return current content type. Possible values: \"none\", \"image\", \"review\", \"editorial\", \"custom\" Returns: Type Description str Relevance type Source code in prettyqt/location/placecontentrequest.py def get_content_type ( self ) -> str : \"\"\"Return current content type. Possible values: \"none\", \"image\", \"review\", \"editorial\", \"custom\" Returns: Relevance type \"\"\" return location . placecontent . TYPE . inverse [ self . contentType ()]","title":"get_content_type()"},{"location":"api/location.html#prettyqt.location.placecontentrequest.PlaceContentRequest.set_content_type","text":"Set the content type. Allowed values are \"none\", \"image\", \"review\", \"editorial\", \"custom\" Parameters: Name Type Description Default typ str Relevance type required Exceptions: Type Description InvalidParamError content type does not exist Source code in prettyqt/location/placecontentrequest.py def set_content_type ( self , typ : str ): \"\"\"Set the content type. Allowed values are \"none\", \"image\", \"review\", \"editorial\", \"custom\" Args: typ: Relevance type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in location . placecontent . TYPE : raise InvalidParamError ( typ , location . placecontent . TYPE ) self . setContentType ( location . placecontent . TYPE [ typ ])","title":"set_content_type()"},{"location":"api/location.html#prettyqt.location.placeidreply","text":"","title":"placeidreply"},{"location":"api/location.html#prettyqt.location.placeidreply.PlaceIdReply","text":"","title":"PlaceIdReply"},{"location":"api/location.html#prettyqt.location.placeidreply.PlaceIdReply.get_operation_type","text":"Get current operation_type. Possible values: \"save_place\", \"remove_place\", save_category\", \"remove_category\" Returns: Type Description str current operation_type Source code in prettyqt/location/placeidreply.py def get_operation_type ( self ) -> str : \"\"\"Get current operation_type. Possible values: \"save_place\", \"remove_place\", save_category\", \"remove_category\" Returns: current operation_type \"\"\" return OPERATION_TYPES . inverse [ self . operationType ()]","title":"get_operation_type()"},{"location":"api/location.html#prettyqt.location.placereply","text":"","title":"placereply"},{"location":"api/location.html#prettyqt.location.placereply.PlaceReply","text":"","title":"PlaceReply"},{"location":"api/location.html#prettyqt.location.placereply.PlaceReply.get_error","text":"Return error type. possible values: \"none\" \"place_does_not_exist\", \"category_does_not_exist\", \"communication\", \"parse\", \"permissions\", \"unsupported\", \"bad_argument\", \"cancel\", \"unknown\" Returns: Type Description str Error type Source code in prettyqt/location/placereply.py def get_error ( self ) -> str : \"\"\"Return error type. possible values: \"none\" \"place_does_not_exist\", \"category_does_not_exist\", \"communication\", \"parse\", \"permissions\", \"unsupported\", \"bad_argument\", \"cancel\", \"unknown\" Returns: Error type \"\"\" return ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/location.html#prettyqt.location.placereply.PlaceReply.get_type","text":"Return type. possible values: \"generic\" \"details\", \"search\", \"search_suggestion\", \"content\", \"id\", \"match\", Returns: Type Description str Type Source code in prettyqt/location/placereply.py def get_type ( self ) -> str : \"\"\"Return type. possible values: \"generic\" \"details\", \"search\", \"search_suggestion\", \"content\", \"id\", \"match\", Returns: Type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/location.html#prettyqt.location.placesearchrequest","text":"","title":"placesearchrequest"},{"location":"api/location.html#prettyqt.location.placesearchrequest.PlaceSearchRequest","text":"","title":"PlaceSearchRequest"},{"location":"api/location.html#prettyqt.location.placesearchrequest.PlaceSearchRequest.get_relevance_hint","text":"Return current relevance hint. Possible values: \"unspecified\", \"distance\", \"lexical_place_name\" Returns: Type Description str Relevance hint Source code in prettyqt/location/placesearchrequest.py def get_relevance_hint ( self ) -> str : \"\"\"Return current relevance hint. Possible values: \"unspecified\", \"distance\", \"lexical_place_name\" Returns: Relevance hint \"\"\" return RELEVANCE_HINT . inverse [ self . relevanceHint ()]","title":"get_relevance_hint()"},{"location":"api/location.html#prettyqt.location.placesearchrequest.PlaceSearchRequest.get_visibility_scope","text":"Return the scope of the visibility. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Type Description str Visibility scope Source code in prettyqt/location/placesearchrequest.py def get_visibility_scope ( self ) -> str : \"\"\"Return the scope of the visibility. Possible values are \"unspecified\", \"device\", \"private\", \"public\" Returns: Visibility scope \"\"\" return VISIBILITY . inverse [ self . visibilityScope ()]","title":"get_visibility_scope()"},{"location":"api/location.html#prettyqt.location.placesearchrequest.PlaceSearchRequest.set_relevance_hint","text":"Set the relevance hint. Allowed values are \"unspecified\", \"distance\", \"lexical_place_name\" Parameters: Name Type Description Default hint str Relevance hint required Exceptions: Type Description InvalidParamError relevance hint does not exist Source code in prettyqt/location/placesearchrequest.py def set_relevance_hint ( self , hint : str ): \"\"\"Set the relevance hint. Allowed values are \"unspecified\", \"distance\", \"lexical_place_name\" Args: hint: Relevance hint Raises: InvalidParamError: relevance hint does not exist \"\"\" if hint not in RELEVANCE_HINT : raise InvalidParamError ( hint , RELEVANCE_HINT ) self . setRelevanceHint ( RELEVANCE_HINT [ hint ])","title":"set_relevance_hint()"},{"location":"api/location.html#prettyqt.location.placesearchresult","text":"","title":"placesearchresult"},{"location":"api/location.html#prettyqt.location.placesearchresult.PlaceSearchResult","text":"","title":"PlaceSearchResult"},{"location":"api/location.html#prettyqt.location.placesearchresult.PlaceSearchResult.get_type","text":"Return result type. possible values: \"unknown\" \"place\", \"proposed_search\", Returns: Type Description str Result type Source code in prettyqt/location/placesearchresult.py def get_type ( self ) -> str : \"\"\"Return result type. possible values: \"unknown\" \"place\", \"proposed_search\", Returns: Result type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/multimedia.html","text":"multimedia module Multimedia module. abstractvideobuffer AbstractVideoBuffer get_handle_type ( self ) Return current handle type. Possible values: \"none\", \"gl_texture\", \"xv_shm_image\", \"core_image\", \"pixmap\", \"egl_image\", \"user\" Returns: Type Description str handle type Source code in prettyqt/multimedia/abstractvideobuffer.py def get_handle_type ( self ) -> str : \"\"\"Return current handle type. Possible values: \"none\", \"gl_texture\", \"xv_shm_image\", \"core_image\", \"pixmap\", \"egl_image\", \"user\" Returns: handle type \"\"\" return HANDLE_TYPES . inverse [ self . handleType ()] get_map_mode ( self ) Return current map mode. Possible values: \"not_mapped\", \"read_only\", \"write_only\", \"read_write\" Returns: Type Description str map mode Source code in prettyqt/multimedia/abstractvideobuffer.py def get_map_mode ( self ) -> str : \"\"\"Return current map mode. Possible values: \"not_mapped\", \"read_only\", \"write_only\", \"read_write\" Returns: map mode \"\"\" return MAP_MODE . inverse [ self . mapMode ()] map ( self , mode , num_bytes , bytes_per_line = 4 ) map(self, QAbstractVideoBuffer.MapMode) -> Tuple[sip.voidptr, int, int] Source code in prettyqt/multimedia/abstractvideobuffer.py def map ( self , mode : Union [ int , str ], num_bytes : int , bytes_per_line : int = 4 , ): if mode in MAP_MODE : mode = MAP_MODE [ mode ] super () . map ( mode , num_bytes , bytes_per_line ) audioencodersettings Settings dataclass Settings(bitrate: 'int', channel_count: 'int', codec: 'str', encoding_mode: 'str', encoding_options: 'Dict[str, Any]', quality: 'str', sample_rate: 'int') audioformat Settings dataclass Settings(sample_rate: 'int', channel_count: 'int', sample_size: 'int', byte_order: 'str', sample_type: 'str', codec: 'str') camera Camera get_capture_mode ( self ) Return current capture mode. Possible values: \"viewfinder\", \"still_image\", \"video\" Returns: Type Description str capture mode Source code in prettyqt/multimedia/camera.py def get_capture_mode ( self ) -> str : \"\"\"Return current capture mode. Possible values: \"viewfinder\", \"still_image\", \"video\" Returns: capture mode \"\"\" return CAPTURE_MODES . inverse [ self . captureMode ()] get_error ( self ) Return current error state. Possible values: \"none\", \"camera\", \"invalid_request\", \"service_missing\", \"not_supported_feature\" Returns: Type Description str error state Source code in prettyqt/multimedia/camera.py def get_error ( self ) -> str : \"\"\"Return current error state. Possible values: \"none\", \"camera\", \"invalid_request\", \"service_missing\", \"not_supported_feature\" Returns: error state \"\"\" return ERRORS . inverse [ self . error ()] get_lock_status ( self ) Return current lock status. Possible values: \"unlocked\", \"searching\", \"locked\" Returns: Type Description str lock status Source code in prettyqt/multimedia/camera.py def get_lock_status ( self ) -> str : \"\"\"Return current lock status. Possible values: \"unlocked\", \"searching\", \"locked\" Returns: lock status \"\"\" return LOCK_STATUS . inverse [ self . lockStatus ()] get_state ( self ) Return current state. Possible values: \"unloaded\", \"loaded\", \"active\" Returns: Type Description str state Source code in prettyqt/multimedia/camera.py def get_state ( self ) -> str : \"\"\"Return current state. Possible values: \"unloaded\", \"loaded\", \"active\" Returns: state \"\"\" return STATES . inverse [ self . state ()] get_status ( self ) Return current status. Possible values: \"active\", \"starting\", \"stopping\", \"standby\", \"loaded\", \"loading\", \"unloading\", \"unloaded\", \"unavailable\" Returns: Type Description str status Source code in prettyqt/multimedia/camera.py def get_status ( self ) -> str : \"\"\"Return current status. Possible values: \"active\", \"starting\", \"stopping\", \"standby\", \"loaded\", \"loading\", \"unloading\", \"unloaded\", \"unavailable\" Returns: status \"\"\" return STATUS . inverse [ self . status ()] set_capture_mode ( self , position ) Set the capture mode. Allowed values are \"viewfinder\", \"still_image\", \"video\" Parameters: Name Type Description Default position str capture mode required Exceptions: Type Description InvalidParamError capture mode does not exist Source code in prettyqt/multimedia/camera.py def set_capture_mode ( self , position : str ): \"\"\"Set the capture mode. Allowed values are \"viewfinder\", \"still_image\", \"video\" Args: position: capture mode Raises: InvalidParamError: capture mode does not exist \"\"\" if position not in CAPTURE_MODES : raise InvalidParamError ( position , CAPTURE_MODES ) self . setCaptureMode ( CAPTURE_MODES [ position ]) cameraexposure CameraExposure get_exposure_mode ( self ) Return current exposure mode. Possible values: \"auto\", \"manual\", \"portrait\", \"night\", \"backlight\", \"spotlight\", \"sports\", \"snow\", \"beach\", \"large_aperture\", \"small_aperture\", \"action\", \"landscape\", \"night_portrait\", \"theatre\", \"sunset\", \"steady_photo\", \"fireworks\", \"party\", \"candlelight\", \"barcode\", \"mode_vendor\" Returns: Type Description str exposure mode Source code in prettyqt/multimedia/cameraexposure.py def get_exposure_mode ( self ) -> str : \"\"\"Return current exposure mode. Possible values: \"auto\", \"manual\", \"portrait\", \"night\", \"backlight\", \"spotlight\", \"sports\", \"snow\", \"beach\", \"large_aperture\", \"small_aperture\", \"action\", \"landscape\", \"night_portrait\", \"theatre\", \"sunset\", \"steady_photo\", \"fireworks\", \"party\", \"candlelight\", \"barcode\", \"mode_vendor\" Returns: exposure mode \"\"\" return EXPOSURE_MODES . inverse [ self . item . exposureMode ()] get_flash_mode ( self ) Return current flash mode. Possible values: \"auto\", \"flash_on\", \"flash_off\", \"red_eye_reduction\", \"fill\", \"torch\", \"video_light\", \"sync_front_curtain\", \"sync_rear_curtain\", \"manual\" Returns: Type Description str flash mode Source code in prettyqt/multimedia/cameraexposure.py def get_flash_mode ( self ) -> str : \"\"\"Return current flash mode. Possible values: \"auto\", \"flash_on\", \"flash_off\", \"red_eye_reduction\", \"fill\", \"torch\", \"video_light\", \"sync_front_curtain\", \"sync_rear_curtain\", \"manual\" Returns: flash mode \"\"\" return FLASH_MODES . inverse [ self . item . flashMode ()] get_metering_mode ( self ) Return current metering mode. Possible values: \"matrix\", \"average\", \"spot\" Returns: Type Description str metering mode Source code in prettyqt/multimedia/cameraexposure.py def get_metering_mode ( self ) -> str : \"\"\"Return current metering mode. Possible values: \"matrix\", \"average\", \"spot\" Returns: metering mode \"\"\" return METERING_MODES . inverse [ self . item . meteringMode ()] set_exposure_mode ( self , mode ) Set the exposure mode. Allowed values are \"auto\", \"manual\", \"portrait\", \"night\", \"backlight\", \"spotlight\", \"sports\", \"snow\", \"beach\", \"large_aperture\", \"small_aperture\", \"action\", \"landscape\", \"night_portrait\", \"theatre\", \"sunset\", \"steady_photo\", \"fireworks\", \"party\", \"candlelight\", \"barcode\", \"mode_vendor\" Parameters: Name Type Description Default mode str exposure mode required Exceptions: Type Description InvalidParamError exposure mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_exposure_mode ( self , mode : str ): \"\"\"Set the exposure mode. Allowed values are \"auto\", \"manual\", \"portrait\", \"night\", \"backlight\", \"spotlight\", \"sports\", \"snow\", \"beach\", \"large_aperture\", \"small_aperture\", \"action\", \"landscape\", \"night_portrait\", \"theatre\", \"sunset\", \"steady_photo\", \"fireworks\", \"party\", \"candlelight\", \"barcode\", \"mode_vendor\" Args: mode: exposure mode Raises: InvalidParamError: exposure mode does not exist \"\"\" if mode not in EXPOSURE_MODES : raise InvalidParamError ( mode , EXPOSURE_MODES ) self . item . setExposureMode ( EXPOSURE_MODES [ mode ]) set_flash_mode ( self , mode ) Set the flash mode. Allowed values are \"auto\", \"flash_on\", \"flash_off\", \"red_eye_reduction\", \"fill\", \"torch\", \"video_light\", \"sync_front_curtain\", \"sync_rear_curtain\", \"manual\" Parameters: Name Type Description Default mode str flash mode required Exceptions: Type Description InvalidParamError flash mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_flash_mode ( self , mode : str ): \"\"\"Set the flash mode. Allowed values are \"auto\", \"flash_on\", \"flash_off\", \"red_eye_reduction\", \"fill\", \"torch\", \"video_light\", \"sync_front_curtain\", \"sync_rear_curtain\", \"manual\" Args: mode: flash mode Raises: InvalidParamError: flash mode does not exist \"\"\" if mode not in FLASH_MODES : raise InvalidParamError ( mode , FLASH_MODES ) self . item . setFlashMode ( FLASH_MODES [ mode ]) set_metering_mode ( self , mode ) Set the metering mode. Allowed values are \"matrix\", \"average\", \"spot\" Parameters: Name Type Description Default mode str metering mode required Exceptions: Type Description InvalidParamError metering mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_metering_mode ( self , mode : str ): \"\"\"Set the metering mode. Allowed values are \"matrix\", \"average\", \"spot\" Args: mode: metering mode Raises: InvalidParamError: metering mode does not exist \"\"\" if mode not in METERING_MODES : raise InvalidParamError ( mode , METERING_MODES ) self . item . setMeteringMode ( METERING_MODES [ mode ]) camerafocus CameraFocus get_focus_mode ( self ) Return current focus mode. Possible values: \"manual\", \"hyperfocal\", \"infinity\", \"auto\", \"continuous\", \"macro\" Returns: Type Description str focus mode Source code in prettyqt/multimedia/camerafocus.py def get_focus_mode ( self ) -> str : \"\"\"Return current focus mode. Possible values: \"manual\", \"hyperfocal\", \"infinity\", \"auto\", \"continuous\", \"macro\" Returns: focus mode \"\"\" return FOCUS_MODES . inverse [ self . item . focusMode ()] get_focus_point_mode ( self ) Return current focus point mode. Possible values: \"auto\", \"center\", \"face_detection\", \"custom\" Returns: Type Description str focus point mode Source code in prettyqt/multimedia/camerafocus.py def get_focus_point_mode ( self ) -> str : \"\"\"Return current focus point mode. Possible values: \"auto\", \"center\", \"face_detection\", \"custom\" Returns: focus point mode \"\"\" return FOCUS_POINT_MODES . inverse [ self . item . focusPointMode ()] set_focus_mode ( self , mode ) Set the focus mode. Allowed values are \"manual\", \"hyperfocal\", \"infinity\", \"auto\", \"continuous\", \"macro\" Parameters: Name Type Description Default mode str focus mode required Exceptions: Type Description InvalidParamError focus mode does not exist Source code in prettyqt/multimedia/camerafocus.py def set_focus_mode ( self , mode : str ): \"\"\"Set the focus mode. Allowed values are \"manual\", \"hyperfocal\", \"infinity\", \"auto\", \"continuous\", \"macro\" Args: mode: focus mode Raises: InvalidParamError: focus mode does not exist \"\"\" if mode not in FOCUS_MODES : raise InvalidParamError ( mode , FOCUS_MODES ) self . item . setFocusMode ( FOCUS_MODES [ mode ]) set_focus_point_mode ( self , mode ) Set the focus mode. Allowed values are \"auto\", \"center\", \"face_detection\", \"custom\" Parameters: Name Type Description Default mode str focus point mode required Exceptions: Type Description InvalidParamError focus point mode does not exist Source code in prettyqt/multimedia/camerafocus.py def set_focus_point_mode ( self , mode : str ): \"\"\"Set the focus mode. Allowed values are \"auto\", \"center\", \"face_detection\", \"custom\" Args: mode: focus point mode Raises: InvalidParamError: focus point mode does not exist \"\"\" if mode not in FOCUS_POINT_MODES : raise InvalidParamError ( mode , FOCUS_POINT_MODES ) self . item . setFocusPointMode ( FOCUS_POINT_MODES [ mode ]) camerafocuszone CameraFocusZone get_focus_mode ( self ) Return current focus mode. Possible values: \"invalid\", \"unused\", \"selected\", \"focused\" Returns: Type Description str focus mode Source code in prettyqt/multimedia/camerafocuszone.py def get_focus_mode ( self ) -> str : \"\"\"Return current focus mode. Possible values: \"invalid\", \"unused\", \"selected\", \"focused\" Returns: focus mode \"\"\" return FOCUS_ZONE_STATUS . inverse [ self . status ()] cameraimageprocessing CameraImageProcessing get_color_filter ( self ) Return current exposure mode. Possible values: \"none\", \"grayscale\", \"negative\", \"solarize\", \"sepia\", \"posterize\", \"whiteboard\", \"blackboard\", \"aqua\", \"vendor\" Returns: Type Description str color filter Source code in prettyqt/multimedia/cameraimageprocessing.py def get_color_filter ( self ) -> str : \"\"\"Return current exposure mode. Possible values: \"none\", \"grayscale\", \"negative\", \"solarize\", \"sepia\", \"posterize\", \"whiteboard\", \"blackboard\", \"aqua\", \"vendor\" Returns: color filter \"\"\" return COLOR_FILTERS . inverse [ self . item . colorFilter ()] get_white_balance_mode ( self ) Return current white balance mode. Possible values: \"auto\", \"manual\", \"sunlight\", \"cloudy\", \"shade\", \"tungsten\", \"fluorescent\", \"flash\", \"sunset\", \"vendor\" Returns: Type Description str white balance mode Source code in prettyqt/multimedia/cameraimageprocessing.py def get_white_balance_mode ( self ) -> str : \"\"\"Return current white balance mode. Possible values: \"auto\", \"manual\", \"sunlight\", \"cloudy\", \"shade\", \"tungsten\", \"fluorescent\", \"flash\", \"sunset\", \"vendor\" Returns: white balance mode \"\"\" return WHITE_BALANCE_MODE . inverse [ self . item . whiteBalanceMode ()] set_color_filter ( self , mode ) Set the color filter. Allowed values are \"none\", \"grayscale\", \"negative\", \"solarize\", \"sepia\", \"posterize\", \"whiteboard\", \"blackboard\", \"aqua\", \"vendor\" Parameters: Name Type Description Default mode str color filter required Exceptions: Type Description InvalidParamError color filter does not exist Source code in prettyqt/multimedia/cameraimageprocessing.py def set_color_filter ( self , mode : str ): \"\"\"Set the color filter. Allowed values are \"none\", \"grayscale\", \"negative\", \"solarize\", \"sepia\", \"posterize\", \"whiteboard\", \"blackboard\", \"aqua\", \"vendor\" Args: mode: color filter Raises: InvalidParamError: color filter does not exist \"\"\" if mode not in COLOR_FILTERS : raise InvalidParamError ( mode , COLOR_FILTERS ) self . item . setColorFilter ( COLOR_FILTERS [ mode ]) set_white_balance_mode ( self , mode ) Set the white balance mode. Allowed values are \"auto\", \"manual\", \"sunlight\", \"cloudy\", \"shade\", \"tungsten\", \"fluorescent\", \"flash\", \"sunset\", \"vendor\" Parameters: Name Type Description Default mode str white balance mode required Exceptions: Type Description InvalidParamError white balance mode does not exist Source code in prettyqt/multimedia/cameraimageprocessing.py def set_white_balance_mode ( self , mode : str ): \"\"\"Set the white balance mode. Allowed values are \"auto\", \"manual\", \"sunlight\", \"cloudy\", \"shade\", \"tungsten\", \"fluorescent\", \"flash\", \"sunset\", \"vendor\" Args: mode: white balance mode Raises: InvalidParamError: white balance mode does not exist \"\"\" if mode not in WHITE_BALANCE_MODE : raise InvalidParamError ( mode , WHITE_BALANCE_MODE ) self . item . setWhiteBalanceMode ( WHITE_BALANCE_MODE [ mode ]) cameraviewfindersettings Settings dataclass Settings(maximum_framerate: 'int', minimum_framerate: 'int', pixel_aspect_ratio: 'Tuple[int, int]', pixel_format: 'str', resolution: 'Tuple[int, int]') imageencodersettings Settings dataclass Settings(codec: 'str', encoding_options: 'Dict[str, Any]', quality: 'str', resolution: 'Tuple[int, int]') mediaobject MediaObject get_availability ( self ) Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: Type Description str availability status Source code in prettyqt/multimedia/mediaobject.py def get_availability ( self ) -> str : \"\"\"Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: availability status \"\"\" return AVAILABILITY_STATUS . inverse [ self . availability ()] mediaplayer MediaPlayer get_media_status ( self ) Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: Type Description str media status Source code in prettyqt/multimedia/mediaplayer.py def get_media_status ( self ) -> str : \"\"\"Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: media status \"\"\" return MEDIA_STATUS . inverse [ self . mediaStatus ()] get_state ( self ) Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: Type Description str state Source code in prettyqt/multimedia/mediaplayer.py def get_state ( self ) -> str : \"\"\"Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: state \"\"\" return STATES . inverse [ self . state ()] mediaplaylist MediaPlaylist get_playback_mode ( self ) Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: Type Description str playback mode Source code in prettyqt/multimedia/mediaplaylist.py def get_playback_mode ( self ) -> str : \"\"\"Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: playback mode \"\"\" return PLAYBACK_MODES . inverse [ self . playbackMode ()] set_playback_mode ( self , mode ) Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Parameters: Name Type Description Default mode str playback mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/multimedia/mediaplaylist.py def set_playback_mode ( self , mode : str ): \"\"\"Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Args: mode: playback mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in PLAYBACK_MODES : raise InvalidParamError ( mode , PLAYBACK_MODES ) self . setPlaybackMode ( PLAYBACK_MODES [ mode ]) mediarecorder MediaRecorder get_availability ( self ) Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: Type Description str availability status Source code in prettyqt/multimedia/mediarecorder.py def get_availability ( self ) -> str : \"\"\"Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: availability status \"\"\" return AVAILABILITY_STATUS . inverse [ self . availability ()] videoencodersettings Settings dataclass Settings(bitrate: 'int', codec: 'str', encoding_mode: 'str', encoding_options: 'Dict[str, Any]', quality: 'str', frame_rate: 'float', resolution: 'Tuple[int, int]') videoframe VideoFrame get_field_type ( self ) Set field type. Valid values: \"progressive_frame\", \"top_field\", \"bottom_field\", \"interlaced_frame\" Source code in prettyqt/multimedia/videoframe.py def get_field_type ( self ) -> str : \"\"\"Set field type. Valid values: \"progressive_frame\", \"top_field\", \"bottom_field\", \"interlaced_frame\" \"\"\" return FIELD_TYPES . inverse [ self . fieldType ()] set_field_type ( self , typ ) Return current field type. Possible values: \"progressive_frame\", \"top_field\", \"bottom_field\", \"interlaced_frame\" Parameters: Name Type Description Default typ str capture mode required Exceptions: Type Description InvalidParamError capture mode does not exist Source code in prettyqt/multimedia/videoframe.py def set_field_type ( self , typ : str ): \"\"\"Return current field type. Possible values: \"progressive_frame\", \"top_field\", \"bottom_field\", \"interlaced_frame\" Args: typ: capture mode Raises: InvalidParamError: capture mode does not exist \"\"\" if typ not in FIELD_TYPES : raise InvalidParamError ( typ , FIELD_TYPES ) self . setFieldType ( FIELD_TYPES [ typ ])","title":"multimedia"},{"location":"api/multimedia.html#multimedia-module","text":"","title":"multimedia module"},{"location":"api/multimedia.html#prettyqt.multimedia","text":"Multimedia module.","title":"prettyqt.multimedia"},{"location":"api/multimedia.html#prettyqt.multimedia.abstractvideobuffer","text":"","title":"abstractvideobuffer"},{"location":"api/multimedia.html#prettyqt.multimedia.abstractvideobuffer.AbstractVideoBuffer","text":"","title":"AbstractVideoBuffer"},{"location":"api/multimedia.html#prettyqt.multimedia.abstractvideobuffer.AbstractVideoBuffer.get_handle_type","text":"Return current handle type. Possible values: \"none\", \"gl_texture\", \"xv_shm_image\", \"core_image\", \"pixmap\", \"egl_image\", \"user\" Returns: Type Description str handle type Source code in prettyqt/multimedia/abstractvideobuffer.py def get_handle_type ( self ) -> str : \"\"\"Return current handle type. Possible values: \"none\", \"gl_texture\", \"xv_shm_image\", \"core_image\", \"pixmap\", \"egl_image\", \"user\" Returns: handle type \"\"\" return HANDLE_TYPES . inverse [ self . handleType ()]","title":"get_handle_type()"},{"location":"api/multimedia.html#prettyqt.multimedia.abstractvideobuffer.AbstractVideoBuffer.get_map_mode","text":"Return current map mode. Possible values: \"not_mapped\", \"read_only\", \"write_only\", \"read_write\" Returns: Type Description str map mode Source code in prettyqt/multimedia/abstractvideobuffer.py def get_map_mode ( self ) -> str : \"\"\"Return current map mode. Possible values: \"not_mapped\", \"read_only\", \"write_only\", \"read_write\" Returns: map mode \"\"\" return MAP_MODE . inverse [ self . mapMode ()]","title":"get_map_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.abstractvideobuffer.AbstractVideoBuffer.map","text":"map(self, QAbstractVideoBuffer.MapMode) -> Tuple[sip.voidptr, int, int] Source code in prettyqt/multimedia/abstractvideobuffer.py def map ( self , mode : Union [ int , str ], num_bytes : int , bytes_per_line : int = 4 , ): if mode in MAP_MODE : mode = MAP_MODE [ mode ] super () . map ( mode , num_bytes , bytes_per_line )","title":"map()"},{"location":"api/multimedia.html#prettyqt.multimedia.audioencodersettings","text":"","title":"audioencodersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.audioencodersettings.Settings","text":"Settings(bitrate: 'int', channel_count: 'int', codec: 'str', encoding_mode: 'str', encoding_options: 'Dict[str, Any]', quality: 'str', sample_rate: 'int')","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.audioformat","text":"","title":"audioformat"},{"location":"api/multimedia.html#prettyqt.multimedia.audioformat.Settings","text":"Settings(sample_rate: 'int', channel_count: 'int', sample_size: 'int', byte_order: 'str', sample_type: 'str', codec: 'str')","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.camera","text":"","title":"camera"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera","text":"","title":"Camera"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_capture_mode","text":"Return current capture mode. Possible values: \"viewfinder\", \"still_image\", \"video\" Returns: Type Description str capture mode Source code in prettyqt/multimedia/camera.py def get_capture_mode ( self ) -> str : \"\"\"Return current capture mode. Possible values: \"viewfinder\", \"still_image\", \"video\" Returns: capture mode \"\"\" return CAPTURE_MODES . inverse [ self . captureMode ()]","title":"get_capture_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_error","text":"Return current error state. Possible values: \"none\", \"camera\", \"invalid_request\", \"service_missing\", \"not_supported_feature\" Returns: Type Description str error state Source code in prettyqt/multimedia/camera.py def get_error ( self ) -> str : \"\"\"Return current error state. Possible values: \"none\", \"camera\", \"invalid_request\", \"service_missing\", \"not_supported_feature\" Returns: error state \"\"\" return ERRORS . inverse [ self . error ()]","title":"get_error()"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_lock_status","text":"Return current lock status. Possible values: \"unlocked\", \"searching\", \"locked\" Returns: Type Description str lock status Source code in prettyqt/multimedia/camera.py def get_lock_status ( self ) -> str : \"\"\"Return current lock status. Possible values: \"unlocked\", \"searching\", \"locked\" Returns: lock status \"\"\" return LOCK_STATUS . inverse [ self . lockStatus ()]","title":"get_lock_status()"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_state","text":"Return current state. Possible values: \"unloaded\", \"loaded\", \"active\" Returns: Type Description str state Source code in prettyqt/multimedia/camera.py def get_state ( self ) -> str : \"\"\"Return current state. Possible values: \"unloaded\", \"loaded\", \"active\" Returns: state \"\"\" return STATES . inverse [ self . state ()]","title":"get_state()"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_status","text":"Return current status. Possible values: \"active\", \"starting\", \"stopping\", \"standby\", \"loaded\", \"loading\", \"unloading\", \"unloaded\", \"unavailable\" Returns: Type Description str status Source code in prettyqt/multimedia/camera.py def get_status ( self ) -> str : \"\"\"Return current status. Possible values: \"active\", \"starting\", \"stopping\", \"standby\", \"loaded\", \"loading\", \"unloading\", \"unloaded\", \"unavailable\" Returns: status \"\"\" return STATUS . inverse [ self . status ()]","title":"get_status()"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.set_capture_mode","text":"Set the capture mode. Allowed values are \"viewfinder\", \"still_image\", \"video\" Parameters: Name Type Description Default position str capture mode required Exceptions: Type Description InvalidParamError capture mode does not exist Source code in prettyqt/multimedia/camera.py def set_capture_mode ( self , position : str ): \"\"\"Set the capture mode. Allowed values are \"viewfinder\", \"still_image\", \"video\" Args: position: capture mode Raises: InvalidParamError: capture mode does not exist \"\"\" if position not in CAPTURE_MODES : raise InvalidParamError ( position , CAPTURE_MODES ) self . setCaptureMode ( CAPTURE_MODES [ position ])","title":"set_capture_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure","text":"","title":"cameraexposure"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure","text":"","title":"CameraExposure"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.get_exposure_mode","text":"Return current exposure mode. Possible values: \"auto\", \"manual\", \"portrait\", \"night\", \"backlight\", \"spotlight\", \"sports\", \"snow\", \"beach\", \"large_aperture\", \"small_aperture\", \"action\", \"landscape\", \"night_portrait\", \"theatre\", \"sunset\", \"steady_photo\", \"fireworks\", \"party\", \"candlelight\", \"barcode\", \"mode_vendor\" Returns: Type Description str exposure mode Source code in prettyqt/multimedia/cameraexposure.py def get_exposure_mode ( self ) -> str : \"\"\"Return current exposure mode. Possible values: \"auto\", \"manual\", \"portrait\", \"night\", \"backlight\", \"spotlight\", \"sports\", \"snow\", \"beach\", \"large_aperture\", \"small_aperture\", \"action\", \"landscape\", \"night_portrait\", \"theatre\", \"sunset\", \"steady_photo\", \"fireworks\", \"party\", \"candlelight\", \"barcode\", \"mode_vendor\" Returns: exposure mode \"\"\" return EXPOSURE_MODES . inverse [ self . item . exposureMode ()]","title":"get_exposure_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.get_flash_mode","text":"Return current flash mode. Possible values: \"auto\", \"flash_on\", \"flash_off\", \"red_eye_reduction\", \"fill\", \"torch\", \"video_light\", \"sync_front_curtain\", \"sync_rear_curtain\", \"manual\" Returns: Type Description str flash mode Source code in prettyqt/multimedia/cameraexposure.py def get_flash_mode ( self ) -> str : \"\"\"Return current flash mode. Possible values: \"auto\", \"flash_on\", \"flash_off\", \"red_eye_reduction\", \"fill\", \"torch\", \"video_light\", \"sync_front_curtain\", \"sync_rear_curtain\", \"manual\" Returns: flash mode \"\"\" return FLASH_MODES . inverse [ self . item . flashMode ()]","title":"get_flash_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.get_metering_mode","text":"Return current metering mode. Possible values: \"matrix\", \"average\", \"spot\" Returns: Type Description str metering mode Source code in prettyqt/multimedia/cameraexposure.py def get_metering_mode ( self ) -> str : \"\"\"Return current metering mode. Possible values: \"matrix\", \"average\", \"spot\" Returns: metering mode \"\"\" return METERING_MODES . inverse [ self . item . meteringMode ()]","title":"get_metering_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.set_exposure_mode","text":"Set the exposure mode. Allowed values are \"auto\", \"manual\", \"portrait\", \"night\", \"backlight\", \"spotlight\", \"sports\", \"snow\", \"beach\", \"large_aperture\", \"small_aperture\", \"action\", \"landscape\", \"night_portrait\", \"theatre\", \"sunset\", \"steady_photo\", \"fireworks\", \"party\", \"candlelight\", \"barcode\", \"mode_vendor\" Parameters: Name Type Description Default mode str exposure mode required Exceptions: Type Description InvalidParamError exposure mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_exposure_mode ( self , mode : str ): \"\"\"Set the exposure mode. Allowed values are \"auto\", \"manual\", \"portrait\", \"night\", \"backlight\", \"spotlight\", \"sports\", \"snow\", \"beach\", \"large_aperture\", \"small_aperture\", \"action\", \"landscape\", \"night_portrait\", \"theatre\", \"sunset\", \"steady_photo\", \"fireworks\", \"party\", \"candlelight\", \"barcode\", \"mode_vendor\" Args: mode: exposure mode Raises: InvalidParamError: exposure mode does not exist \"\"\" if mode not in EXPOSURE_MODES : raise InvalidParamError ( mode , EXPOSURE_MODES ) self . item . setExposureMode ( EXPOSURE_MODES [ mode ])","title":"set_exposure_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.set_flash_mode","text":"Set the flash mode. Allowed values are \"auto\", \"flash_on\", \"flash_off\", \"red_eye_reduction\", \"fill\", \"torch\", \"video_light\", \"sync_front_curtain\", \"sync_rear_curtain\", \"manual\" Parameters: Name Type Description Default mode str flash mode required Exceptions: Type Description InvalidParamError flash mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_flash_mode ( self , mode : str ): \"\"\"Set the flash mode. Allowed values are \"auto\", \"flash_on\", \"flash_off\", \"red_eye_reduction\", \"fill\", \"torch\", \"video_light\", \"sync_front_curtain\", \"sync_rear_curtain\", \"manual\" Args: mode: flash mode Raises: InvalidParamError: flash mode does not exist \"\"\" if mode not in FLASH_MODES : raise InvalidParamError ( mode , FLASH_MODES ) self . item . setFlashMode ( FLASH_MODES [ mode ])","title":"set_flash_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.set_metering_mode","text":"Set the metering mode. Allowed values are \"matrix\", \"average\", \"spot\" Parameters: Name Type Description Default mode str metering mode required Exceptions: Type Description InvalidParamError metering mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_metering_mode ( self , mode : str ): \"\"\"Set the metering mode. Allowed values are \"matrix\", \"average\", \"spot\" Args: mode: metering mode Raises: InvalidParamError: metering mode does not exist \"\"\" if mode not in METERING_MODES : raise InvalidParamError ( mode , METERING_MODES ) self . item . setMeteringMode ( METERING_MODES [ mode ])","title":"set_metering_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus","text":"","title":"camerafocus"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus.CameraFocus","text":"","title":"CameraFocus"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus.CameraFocus.get_focus_mode","text":"Return current focus mode. Possible values: \"manual\", \"hyperfocal\", \"infinity\", \"auto\", \"continuous\", \"macro\" Returns: Type Description str focus mode Source code in prettyqt/multimedia/camerafocus.py def get_focus_mode ( self ) -> str : \"\"\"Return current focus mode. Possible values: \"manual\", \"hyperfocal\", \"infinity\", \"auto\", \"continuous\", \"macro\" Returns: focus mode \"\"\" return FOCUS_MODES . inverse [ self . item . focusMode ()]","title":"get_focus_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus.CameraFocus.get_focus_point_mode","text":"Return current focus point mode. Possible values: \"auto\", \"center\", \"face_detection\", \"custom\" Returns: Type Description str focus point mode Source code in prettyqt/multimedia/camerafocus.py def get_focus_point_mode ( self ) -> str : \"\"\"Return current focus point mode. Possible values: \"auto\", \"center\", \"face_detection\", \"custom\" Returns: focus point mode \"\"\" return FOCUS_POINT_MODES . inverse [ self . item . focusPointMode ()]","title":"get_focus_point_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus.CameraFocus.set_focus_mode","text":"Set the focus mode. Allowed values are \"manual\", \"hyperfocal\", \"infinity\", \"auto\", \"continuous\", \"macro\" Parameters: Name Type Description Default mode str focus mode required Exceptions: Type Description InvalidParamError focus mode does not exist Source code in prettyqt/multimedia/camerafocus.py def set_focus_mode ( self , mode : str ): \"\"\"Set the focus mode. Allowed values are \"manual\", \"hyperfocal\", \"infinity\", \"auto\", \"continuous\", \"macro\" Args: mode: focus mode Raises: InvalidParamError: focus mode does not exist \"\"\" if mode not in FOCUS_MODES : raise InvalidParamError ( mode , FOCUS_MODES ) self . item . setFocusMode ( FOCUS_MODES [ mode ])","title":"set_focus_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus.CameraFocus.set_focus_point_mode","text":"Set the focus mode. Allowed values are \"auto\", \"center\", \"face_detection\", \"custom\" Parameters: Name Type Description Default mode str focus point mode required Exceptions: Type Description InvalidParamError focus point mode does not exist Source code in prettyqt/multimedia/camerafocus.py def set_focus_point_mode ( self , mode : str ): \"\"\"Set the focus mode. Allowed values are \"auto\", \"center\", \"face_detection\", \"custom\" Args: mode: focus point mode Raises: InvalidParamError: focus point mode does not exist \"\"\" if mode not in FOCUS_POINT_MODES : raise InvalidParamError ( mode , FOCUS_POINT_MODES ) self . item . setFocusPointMode ( FOCUS_POINT_MODES [ mode ])","title":"set_focus_point_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocuszone","text":"","title":"camerafocuszone"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocuszone.CameraFocusZone","text":"","title":"CameraFocusZone"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocuszone.CameraFocusZone.get_focus_mode","text":"Return current focus mode. Possible values: \"invalid\", \"unused\", \"selected\", \"focused\" Returns: Type Description str focus mode Source code in prettyqt/multimedia/camerafocuszone.py def get_focus_mode ( self ) -> str : \"\"\"Return current focus mode. Possible values: \"invalid\", \"unused\", \"selected\", \"focused\" Returns: focus mode \"\"\" return FOCUS_ZONE_STATUS . inverse [ self . status ()]","title":"get_focus_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing","text":"","title":"cameraimageprocessing"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing.CameraImageProcessing","text":"","title":"CameraImageProcessing"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing.CameraImageProcessing.get_color_filter","text":"Return current exposure mode. Possible values: \"none\", \"grayscale\", \"negative\", \"solarize\", \"sepia\", \"posterize\", \"whiteboard\", \"blackboard\", \"aqua\", \"vendor\" Returns: Type Description str color filter Source code in prettyqt/multimedia/cameraimageprocessing.py def get_color_filter ( self ) -> str : \"\"\"Return current exposure mode. Possible values: \"none\", \"grayscale\", \"negative\", \"solarize\", \"sepia\", \"posterize\", \"whiteboard\", \"blackboard\", \"aqua\", \"vendor\" Returns: color filter \"\"\" return COLOR_FILTERS . inverse [ self . item . colorFilter ()]","title":"get_color_filter()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing.CameraImageProcessing.get_white_balance_mode","text":"Return current white balance mode. Possible values: \"auto\", \"manual\", \"sunlight\", \"cloudy\", \"shade\", \"tungsten\", \"fluorescent\", \"flash\", \"sunset\", \"vendor\" Returns: Type Description str white balance mode Source code in prettyqt/multimedia/cameraimageprocessing.py def get_white_balance_mode ( self ) -> str : \"\"\"Return current white balance mode. Possible values: \"auto\", \"manual\", \"sunlight\", \"cloudy\", \"shade\", \"tungsten\", \"fluorescent\", \"flash\", \"sunset\", \"vendor\" Returns: white balance mode \"\"\" return WHITE_BALANCE_MODE . inverse [ self . item . whiteBalanceMode ()]","title":"get_white_balance_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing.CameraImageProcessing.set_color_filter","text":"Set the color filter. Allowed values are \"none\", \"grayscale\", \"negative\", \"solarize\", \"sepia\", \"posterize\", \"whiteboard\", \"blackboard\", \"aqua\", \"vendor\" Parameters: Name Type Description Default mode str color filter required Exceptions: Type Description InvalidParamError color filter does not exist Source code in prettyqt/multimedia/cameraimageprocessing.py def set_color_filter ( self , mode : str ): \"\"\"Set the color filter. Allowed values are \"none\", \"grayscale\", \"negative\", \"solarize\", \"sepia\", \"posterize\", \"whiteboard\", \"blackboard\", \"aqua\", \"vendor\" Args: mode: color filter Raises: InvalidParamError: color filter does not exist \"\"\" if mode not in COLOR_FILTERS : raise InvalidParamError ( mode , COLOR_FILTERS ) self . item . setColorFilter ( COLOR_FILTERS [ mode ])","title":"set_color_filter()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing.CameraImageProcessing.set_white_balance_mode","text":"Set the white balance mode. Allowed values are \"auto\", \"manual\", \"sunlight\", \"cloudy\", \"shade\", \"tungsten\", \"fluorescent\", \"flash\", \"sunset\", \"vendor\" Parameters: Name Type Description Default mode str white balance mode required Exceptions: Type Description InvalidParamError white balance mode does not exist Source code in prettyqt/multimedia/cameraimageprocessing.py def set_white_balance_mode ( self , mode : str ): \"\"\"Set the white balance mode. Allowed values are \"auto\", \"manual\", \"sunlight\", \"cloudy\", \"shade\", \"tungsten\", \"fluorescent\", \"flash\", \"sunset\", \"vendor\" Args: mode: white balance mode Raises: InvalidParamError: white balance mode does not exist \"\"\" if mode not in WHITE_BALANCE_MODE : raise InvalidParamError ( mode , WHITE_BALANCE_MODE ) self . item . setWhiteBalanceMode ( WHITE_BALANCE_MODE [ mode ])","title":"set_white_balance_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraviewfindersettings","text":"","title":"cameraviewfindersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraviewfindersettings.Settings","text":"Settings(maximum_framerate: 'int', minimum_framerate: 'int', pixel_aspect_ratio: 'Tuple[int, int]', pixel_format: 'str', resolution: 'Tuple[int, int]')","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.imageencodersettings","text":"","title":"imageencodersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.imageencodersettings.Settings","text":"Settings(codec: 'str', encoding_options: 'Dict[str, Any]', quality: 'str', resolution: 'Tuple[int, int]')","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaobject","text":"","title":"mediaobject"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaobject.MediaObject","text":"","title":"MediaObject"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaobject.MediaObject.get_availability","text":"Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: Type Description str availability status Source code in prettyqt/multimedia/mediaobject.py def get_availability ( self ) -> str : \"\"\"Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: availability status \"\"\" return AVAILABILITY_STATUS . inverse [ self . availability ()]","title":"get_availability()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer","text":"","title":"mediaplayer"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer","text":"","title":"MediaPlayer"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_media_status","text":"Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: Type Description str media status Source code in prettyqt/multimedia/mediaplayer.py def get_media_status ( self ) -> str : \"\"\"Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: media status \"\"\" return MEDIA_STATUS . inverse [ self . mediaStatus ()]","title":"get_media_status()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_state","text":"Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: Type Description str state Source code in prettyqt/multimedia/mediaplayer.py def get_state ( self ) -> str : \"\"\"Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: state \"\"\" return STATES . inverse [ self . state ()]","title":"get_state()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist","text":"","title":"mediaplaylist"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist","text":"","title":"MediaPlaylist"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist.get_playback_mode","text":"Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: Type Description str playback mode Source code in prettyqt/multimedia/mediaplaylist.py def get_playback_mode ( self ) -> str : \"\"\"Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: playback mode \"\"\" return PLAYBACK_MODES . inverse [ self . playbackMode ()]","title":"get_playback_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist.set_playback_mode","text":"Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Parameters: Name Type Description Default mode str playback mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/multimedia/mediaplaylist.py def set_playback_mode ( self , mode : str ): \"\"\"Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Args: mode: playback mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in PLAYBACK_MODES : raise InvalidParamError ( mode , PLAYBACK_MODES ) self . setPlaybackMode ( PLAYBACK_MODES [ mode ])","title":"set_playback_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder","text":"","title":"mediarecorder"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder","text":"","title":"MediaRecorder"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder.get_availability","text":"Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: Type Description str availability status Source code in prettyqt/multimedia/mediarecorder.py def get_availability ( self ) -> str : \"\"\"Return availability status. Possible values: \"available\", \"service_missing\", \"resource_error\", \"busy\" Returns: availability status \"\"\" return AVAILABILITY_STATUS . inverse [ self . availability ()]","title":"get_availability()"},{"location":"api/multimedia.html#prettyqt.multimedia.videoencodersettings","text":"","title":"videoencodersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.videoencodersettings.Settings","text":"Settings(bitrate: 'int', codec: 'str', encoding_mode: 'str', encoding_options: 'Dict[str, Any]', quality: 'str', frame_rate: 'float', resolution: 'Tuple[int, int]')","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.videoframe","text":"","title":"videoframe"},{"location":"api/multimedia.html#prettyqt.multimedia.videoframe.VideoFrame","text":"","title":"VideoFrame"},{"location":"api/multimedia.html#prettyqt.multimedia.videoframe.VideoFrame.get_field_type","text":"Set field type. Valid values: \"progressive_frame\", \"top_field\", \"bottom_field\", \"interlaced_frame\" Source code in prettyqt/multimedia/videoframe.py def get_field_type ( self ) -> str : \"\"\"Set field type. Valid values: \"progressive_frame\", \"top_field\", \"bottom_field\", \"interlaced_frame\" \"\"\" return FIELD_TYPES . inverse [ self . fieldType ()]","title":"get_field_type()"},{"location":"api/multimedia.html#prettyqt.multimedia.videoframe.VideoFrame.set_field_type","text":"Return current field type. Possible values: \"progressive_frame\", \"top_field\", \"bottom_field\", \"interlaced_frame\" Parameters: Name Type Description Default typ str capture mode required Exceptions: Type Description InvalidParamError capture mode does not exist Source code in prettyqt/multimedia/videoframe.py def set_field_type ( self , typ : str ): \"\"\"Return current field type. Possible values: \"progressive_frame\", \"top_field\", \"bottom_field\", \"interlaced_frame\" Args: typ: capture mode Raises: InvalidParamError: capture mode does not exist \"\"\" if typ not in FIELD_TYPES : raise InvalidParamError ( typ , FIELD_TYPES ) self . setFieldType ( FIELD_TYPES [ typ ])","title":"set_field_type()"},{"location":"api/multimediawidgets.html","text":"multimediawidgets module Multimediawidgets module. graphicsvideoitem GraphicsVideoItem get_aspect_ratio_mode ( self ) Return current aspect ratio mode. Possible values: \"ignore\", \"keep\", \"keep_by_expanding\" Returns: Type Description str aspect ratio mode Source code in prettyqt/multimediawidgets/graphicsvideoitem.py def get_aspect_ratio_mode ( self ) -> str : \"\"\"Return current aspect ratio mode. Possible values: \"ignore\", \"keep\", \"keep_by_expanding\" Returns: aspect ratio mode \"\"\" return ASPECT_RATIO_MODES . inverse [ self . aspectRatioMode ()] set_aspect_ratio_mode ( self , mode ) Set the aspect ratio mode. Allowed values are \"ignore\", \"keep\", \"keep_by_expanding\" Parameters: Name Type Description Default mode str aspect ratio mode required Exceptions: Type Description InvalidParamError aspect ratio mode does not exist Source code in prettyqt/multimediawidgets/graphicsvideoitem.py def set_aspect_ratio_mode ( self , mode : str ): \"\"\"Set the aspect ratio mode. Allowed values are \"ignore\", \"keep\", \"keep_by_expanding\" Args: mode: aspect ratio mode Raises: InvalidParamError: aspect ratio mode does not exist \"\"\" if mode not in ASPECT_RATIO_MODES : raise InvalidParamError ( mode , ASPECT_RATIO_MODES ) self . setAspectRatioMode ( ASPECT_RATIO_MODES [ mode ]) videowidget VideoWidget mouseDoubleClickEvent ( self , event ) mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/multimediawidgets/videowidget.py def mouseDoubleClickEvent ( self , event ): if event . button () == QtCore . Qt . LeftButton and self . doubleclick_for_fullscreen : self . setFullScreen ( not self . isFullScreen ()) event . accept () return super () . mouseDoubleClickEvent ( event )","title":"multimediawidgets"},{"location":"api/multimediawidgets.html#multimediawidgets-module","text":"","title":"multimediawidgets module"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets","text":"Multimediawidgets module.","title":"prettyqt.multimediawidgets"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.graphicsvideoitem","text":"","title":"graphicsvideoitem"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.graphicsvideoitem.GraphicsVideoItem","text":"","title":"GraphicsVideoItem"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.graphicsvideoitem.GraphicsVideoItem.get_aspect_ratio_mode","text":"Return current aspect ratio mode. Possible values: \"ignore\", \"keep\", \"keep_by_expanding\" Returns: Type Description str aspect ratio mode Source code in prettyqt/multimediawidgets/graphicsvideoitem.py def get_aspect_ratio_mode ( self ) -> str : \"\"\"Return current aspect ratio mode. Possible values: \"ignore\", \"keep\", \"keep_by_expanding\" Returns: aspect ratio mode \"\"\" return ASPECT_RATIO_MODES . inverse [ self . aspectRatioMode ()]","title":"get_aspect_ratio_mode()"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.graphicsvideoitem.GraphicsVideoItem.set_aspect_ratio_mode","text":"Set the aspect ratio mode. Allowed values are \"ignore\", \"keep\", \"keep_by_expanding\" Parameters: Name Type Description Default mode str aspect ratio mode required Exceptions: Type Description InvalidParamError aspect ratio mode does not exist Source code in prettyqt/multimediawidgets/graphicsvideoitem.py def set_aspect_ratio_mode ( self , mode : str ): \"\"\"Set the aspect ratio mode. Allowed values are \"ignore\", \"keep\", \"keep_by_expanding\" Args: mode: aspect ratio mode Raises: InvalidParamError: aspect ratio mode does not exist \"\"\" if mode not in ASPECT_RATIO_MODES : raise InvalidParamError ( mode , ASPECT_RATIO_MODES ) self . setAspectRatioMode ( ASPECT_RATIO_MODES [ mode ])","title":"set_aspect_ratio_mode()"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.videowidget","text":"","title":"videowidget"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.videowidget.VideoWidget","text":"","title":"VideoWidget"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.videowidget.VideoWidget.mouseDoubleClickEvent","text":"mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/multimediawidgets/videowidget.py def mouseDoubleClickEvent ( self , event ): if event . button () == QtCore . Qt . LeftButton and self . doubleclick_for_fullscreen : self . setFullScreen ( not self . isFullScreen ()) event . accept () return super () . mouseDoubleClickEvent ( event )","title":"mouseDoubleClickEvent()"},{"location":"api/network.html","text":"network module Network module. Contains QtNetWork-based classes abstractsocket AbstractSocket bind ( self , address , port = 0 , bind_mode = 'default_for_platform' ) bind(self, Union[QHostAddress, QHostAddress.SpecialAddress], port: int = 0, mode: Union[QAbstractSocket.BindMode, QAbstractSocket.BindFlag] = QAbstractSocket.DefaultForPlatform) -> bool bind(self, port: int = 0, mode: Union[QAbstractSocket.BindMode, QAbstractSocket.BindFlag] = QAbstractSocket.DefaultForPlatform) -> bool Source code in prettyqt/network/abstractsocket.py def bind ( self , address : Union [ str , QtNetwork . QHostAddress ], port : int = 0 , bind_mode : Union [ int , str ] = \"default_for_platform\" , ): if isinstance ( address , str ): address = QtNetwork . QHostAddress ( address ) if bind_mode in BIND_MODE : bind_mode = BIND_MODE [ bind_mode ] super () . bind ( address , port , bind_mode ) set_pause_mode ( self , mode ) Set pause mode. Valid values: \"never\", \"on_ssl_errors\" Parameters: Name Type Description Default mode str pause mode required Exceptions: Type Description InvalidParamError pause mode does not exist Source code in prettyqt/network/abstractsocket.py def set_pause_mode ( self , mode : str ): \"\"\"Set pause mode. Valid values: \"never\", \"on_ssl_errors\" Args: mode: pause mode Raises: InvalidParamError: pause mode does not exist \"\"\" if mode not in PAUSE_MODE : raise InvalidParamError ( mode , PAUSE_MODE ) self . setPauseMode ( PAUSE_MODE [ mode ]) httpmultipart HttpMultiPart set_content_type ( self , typ ) Set content type. Valid values: \"mixed\", \"related\", \"form\", \"alternative\" Parameters: Name Type Description Default typ str content type required Exceptions: Type Description InvalidParamError content type does not exist Source code in prettyqt/network/httpmultipart.py def set_content_type ( self , typ : str ): \"\"\"Set content type. Valid values: \"mixed\", \"related\", \"form\", \"alternative\" Args: typ: content type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in CONTENT_TYPES : raise InvalidParamError ( typ , CONTENT_TYPES ) self . setContentType ( CONTENT_TYPES [ typ ]) networkaccessmanager NetworkAccessManager get ( self , request ) get(self, QNetworkRequest) -> QNetworkReply Source code in prettyqt/network/networkaccessmanager.py def get ( self , request : Union [ str , QtCore . QUrl , QtNetwork . QNetworkRequest ]): if isinstance ( request , str ): request = core . Url ( request ) request = network . NetworkRequest ( request ) return super () . get ( request ) get_redirect_policy ( self ) Get the current redirect policy. Possible values: \"manual\", \"no_less_safe\", \"same_origin\", \"user_verified\" Returns: Type Description str redirect policy Source code in prettyqt/network/networkaccessmanager.py def get_redirect_policy ( self ) -> str : \"\"\"Get the current redirect policy. Possible values: \"manual\", \"no_less_safe\", \"same_origin\", \"user_verified\" Returns: redirect policy \"\"\" return REDIRECT_POLICIES . inverse [ self . redirectPolicy ()] set_redirect_policy ( self , policy ) Set redirect policy. Valid values: \"manual\", \"no_less_safe\", \"same_origin\", \"user_verified\" Parameters: Name Type Description Default policy str redirect policy required Exceptions: Type Description InvalidParamError redirect policy does not exist Source code in prettyqt/network/networkaccessmanager.py def set_redirect_policy ( self , policy : str ): \"\"\"Set redirect policy. Valid values: \"manual\", \"no_less_safe\", \"same_origin\", \"user_verified\" Args: policy: redirect policy Raises: InvalidParamError: redirect policy does not exist \"\"\" if policy not in REDIRECT_POLICIES : raise InvalidParamError ( policy , REDIRECT_POLICIES ) self . setRedirectPolicy ( REDIRECT_POLICIES [ policy ]) networkaddressentry NetworkAddressEntry get_dns_eligibility ( self ) Return whether this address is eligible for publication in the DNS. Possible values: \"unknown\", \"eligible\", \"ineligible\" Returns: Type Description str DNS eligibility Source code in prettyqt/network/networkaddressentry.py def get_dns_eligibility ( self ) -> str : \"\"\"Return whether this address is eligible for publication in the DNS. Possible values: \"unknown\", \"eligible\", \"ineligible\" Returns: DNS eligibility \"\"\" return DNS_ELIGIBILITY_STATUS . inverse [ self . dnsEligibility ()] set_dns_eligibility ( self , status ) Set the DNS eligibility flag for this address to status. Valid values: \"unknown\", \"eligible\", \"ineligible\" Parameters: Name Type Description Default status str DNS eligibility status required Exceptions: Type Description InvalidParamError dns eligibility status does not exist Source code in prettyqt/network/networkaddressentry.py def set_dns_eligibility ( self , status : str ): \"\"\"Set the DNS eligibility flag for this address to status. Valid values: \"unknown\", \"eligible\", \"ineligible\" Args: status: DNS eligibility status Raises: InvalidParamError: dns eligibility status does not exist \"\"\" if status not in DNS_ELIGIBILITY_STATUS : raise InvalidParamError ( status , DNS_ELIGIBILITY_STATUS ) self . setDnsEligibility ( DNS_ELIGIBILITY_STATUS [ status ]) networkinterface NetworkInterface get_type ( self ) Get the interface type. Possible values: \"unknown\", \"loopback\", \"virtual\", \"ethernet\", \"wifi\", \"can_bus\", \"fddi\", \"ppp\", \"slip\", \"phonet\" \"ieee802154\", \"sixlowpan\", \"ieee80216\", \"ieee1394\" Returns: Type Description str interface type Source code in prettyqt/network/networkinterface.py def get_type ( self ) -> str : \"\"\"Get the interface type. Possible values: \"unknown\", \"loopback\", \"virtual\", \"ethernet\", \"wifi\", \"can_bus\", \"fddi\", \"ppp\", \"slip\", \"phonet\" \"ieee802154\", \"sixlowpan\", \"ieee80216\", \"ieee1394\" Returns: interface type \"\"\" return INTERFACE_TYPES . inverse [ self . type ()] networkproxy NetworkProxy get_type ( self ) Get the proxy type. Possible values: \"none\", \"default\", \"socks5\", \"http\", \"http_caching\", \"ftp_caching\" Returns: Type Description str type Source code in prettyqt/network/networkproxy.py def get_type ( self ) -> str : \"\"\"Get the proxy type. Possible values: \"none\", \"default\", \"socks5\", \"http\", \"http_caching\", \"ftp_caching\" Returns: type \"\"\" return PROXY_TYPES . inverse [ self . type ()] set_type ( self , typ ) Set proxy type. Valid values: \"none\", \"default\", \"socks5\", \"http\", \"http_caching\", \"ftp_caching\" Parameters: Name Type Description Default typ str proxy type required Exceptions: Type Description InvalidParamError proxy type does not exist Source code in prettyqt/network/networkproxy.py def set_type ( self , typ : str ): \"\"\"Set proxy type. Valid values: \"none\", \"default\", \"socks5\", \"http\", \"http_caching\", \"ftp_caching\" Args: typ: proxy type Raises: InvalidParamError: proxy type does not exist \"\"\" if typ not in PROXY_TYPES : raise InvalidParamError ( typ , PROXY_TYPES ) self . setType ( PROXY_TYPES [ typ ]) networkrequest NetworkRequest get_priority ( self ) Get the current priority. Possible values: \"high\", \"normal\", \"low\" Returns: Type Description str priority Source code in prettyqt/network/networkrequest.py def get_priority ( self ) -> str : \"\"\"Get the current priority. Possible values: \"high\", \"normal\", \"low\" Returns: priority \"\"\" return PRIORITIES . inverse [ self . priority ()] set_priority ( self , priority ) Set priority. Valid values for priority: \"high\", \"normal\", \"low\" Parameters: Name Type Description Default priority str priority required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/network/networkrequest.py def set_priority ( self , priority : str ): \"\"\"Set priority. Valid values for priority: \"high\", \"normal\", \"low\" Args: priority: priority Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ]) tcpserver TcpServer listen ( self , address , port = 0 ) listen(self, address: Union[QHostAddress, QHostAddress.SpecialAddress] = QHostAddress.Any, port: int = 0) -> bool Source code in prettyqt/network/tcpserver.py def listen ( self , address : Union [ str , QtNetwork . QHostAddress ], port : int = 0 ) -> bool : if isinstance ( address , str ): address = network . HostAddress ( address ) return super () . listen ( address , port )","title":"network"},{"location":"api/network.html#network-module","text":"","title":"network module"},{"location":"api/network.html#prettyqt.network","text":"Network module. Contains QtNetWork-based classes","title":"prettyqt.network"},{"location":"api/network.html#prettyqt.network.abstractsocket","text":"","title":"abstractsocket"},{"location":"api/network.html#prettyqt.network.abstractsocket.AbstractSocket","text":"","title":"AbstractSocket"},{"location":"api/network.html#prettyqt.network.abstractsocket.AbstractSocket.bind","text":"bind(self, Union[QHostAddress, QHostAddress.SpecialAddress], port: int = 0, mode: Union[QAbstractSocket.BindMode, QAbstractSocket.BindFlag] = QAbstractSocket.DefaultForPlatform) -> bool bind(self, port: int = 0, mode: Union[QAbstractSocket.BindMode, QAbstractSocket.BindFlag] = QAbstractSocket.DefaultForPlatform) -> bool Source code in prettyqt/network/abstractsocket.py def bind ( self , address : Union [ str , QtNetwork . QHostAddress ], port : int = 0 , bind_mode : Union [ int , str ] = \"default_for_platform\" , ): if isinstance ( address , str ): address = QtNetwork . QHostAddress ( address ) if bind_mode in BIND_MODE : bind_mode = BIND_MODE [ bind_mode ] super () . bind ( address , port , bind_mode )","title":"bind()"},{"location":"api/network.html#prettyqt.network.abstractsocket.AbstractSocket.set_pause_mode","text":"Set pause mode. Valid values: \"never\", \"on_ssl_errors\" Parameters: Name Type Description Default mode str pause mode required Exceptions: Type Description InvalidParamError pause mode does not exist Source code in prettyqt/network/abstractsocket.py def set_pause_mode ( self , mode : str ): \"\"\"Set pause mode. Valid values: \"never\", \"on_ssl_errors\" Args: mode: pause mode Raises: InvalidParamError: pause mode does not exist \"\"\" if mode not in PAUSE_MODE : raise InvalidParamError ( mode , PAUSE_MODE ) self . setPauseMode ( PAUSE_MODE [ mode ])","title":"set_pause_mode()"},{"location":"api/network.html#prettyqt.network.httpmultipart","text":"","title":"httpmultipart"},{"location":"api/network.html#prettyqt.network.httpmultipart.HttpMultiPart","text":"","title":"HttpMultiPart"},{"location":"api/network.html#prettyqt.network.httpmultipart.HttpMultiPart.set_content_type","text":"Set content type. Valid values: \"mixed\", \"related\", \"form\", \"alternative\" Parameters: Name Type Description Default typ str content type required Exceptions: Type Description InvalidParamError content type does not exist Source code in prettyqt/network/httpmultipart.py def set_content_type ( self , typ : str ): \"\"\"Set content type. Valid values: \"mixed\", \"related\", \"form\", \"alternative\" Args: typ: content type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in CONTENT_TYPES : raise InvalidParamError ( typ , CONTENT_TYPES ) self . setContentType ( CONTENT_TYPES [ typ ])","title":"set_content_type()"},{"location":"api/network.html#prettyqt.network.networkaccessmanager","text":"","title":"networkaccessmanager"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager","text":"","title":"NetworkAccessManager"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.get","text":"get(self, QNetworkRequest) -> QNetworkReply Source code in prettyqt/network/networkaccessmanager.py def get ( self , request : Union [ str , QtCore . QUrl , QtNetwork . QNetworkRequest ]): if isinstance ( request , str ): request = core . Url ( request ) request = network . NetworkRequest ( request ) return super () . get ( request )","title":"get()"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.get_redirect_policy","text":"Get the current redirect policy. Possible values: \"manual\", \"no_less_safe\", \"same_origin\", \"user_verified\" Returns: Type Description str redirect policy Source code in prettyqt/network/networkaccessmanager.py def get_redirect_policy ( self ) -> str : \"\"\"Get the current redirect policy. Possible values: \"manual\", \"no_less_safe\", \"same_origin\", \"user_verified\" Returns: redirect policy \"\"\" return REDIRECT_POLICIES . inverse [ self . redirectPolicy ()]","title":"get_redirect_policy()"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.set_redirect_policy","text":"Set redirect policy. Valid values: \"manual\", \"no_less_safe\", \"same_origin\", \"user_verified\" Parameters: Name Type Description Default policy str redirect policy required Exceptions: Type Description InvalidParamError redirect policy does not exist Source code in prettyqt/network/networkaccessmanager.py def set_redirect_policy ( self , policy : str ): \"\"\"Set redirect policy. Valid values: \"manual\", \"no_less_safe\", \"same_origin\", \"user_verified\" Args: policy: redirect policy Raises: InvalidParamError: redirect policy does not exist \"\"\" if policy not in REDIRECT_POLICIES : raise InvalidParamError ( policy , REDIRECT_POLICIES ) self . setRedirectPolicy ( REDIRECT_POLICIES [ policy ])","title":"set_redirect_policy()"},{"location":"api/network.html#prettyqt.network.networkaddressentry","text":"","title":"networkaddressentry"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry","text":"","title":"NetworkAddressEntry"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.get_dns_eligibility","text":"Return whether this address is eligible for publication in the DNS. Possible values: \"unknown\", \"eligible\", \"ineligible\" Returns: Type Description str DNS eligibility Source code in prettyqt/network/networkaddressentry.py def get_dns_eligibility ( self ) -> str : \"\"\"Return whether this address is eligible for publication in the DNS. Possible values: \"unknown\", \"eligible\", \"ineligible\" Returns: DNS eligibility \"\"\" return DNS_ELIGIBILITY_STATUS . inverse [ self . dnsEligibility ()]","title":"get_dns_eligibility()"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.set_dns_eligibility","text":"Set the DNS eligibility flag for this address to status. Valid values: \"unknown\", \"eligible\", \"ineligible\" Parameters: Name Type Description Default status str DNS eligibility status required Exceptions: Type Description InvalidParamError dns eligibility status does not exist Source code in prettyqt/network/networkaddressentry.py def set_dns_eligibility ( self , status : str ): \"\"\"Set the DNS eligibility flag for this address to status. Valid values: \"unknown\", \"eligible\", \"ineligible\" Args: status: DNS eligibility status Raises: InvalidParamError: dns eligibility status does not exist \"\"\" if status not in DNS_ELIGIBILITY_STATUS : raise InvalidParamError ( status , DNS_ELIGIBILITY_STATUS ) self . setDnsEligibility ( DNS_ELIGIBILITY_STATUS [ status ])","title":"set_dns_eligibility()"},{"location":"api/network.html#prettyqt.network.networkinterface","text":"","title":"networkinterface"},{"location":"api/network.html#prettyqt.network.networkinterface.NetworkInterface","text":"","title":"NetworkInterface"},{"location":"api/network.html#prettyqt.network.networkinterface.NetworkInterface.get_type","text":"Get the interface type. Possible values: \"unknown\", \"loopback\", \"virtual\", \"ethernet\", \"wifi\", \"can_bus\", \"fddi\", \"ppp\", \"slip\", \"phonet\" \"ieee802154\", \"sixlowpan\", \"ieee80216\", \"ieee1394\" Returns: Type Description str interface type Source code in prettyqt/network/networkinterface.py def get_type ( self ) -> str : \"\"\"Get the interface type. Possible values: \"unknown\", \"loopback\", \"virtual\", \"ethernet\", \"wifi\", \"can_bus\", \"fddi\", \"ppp\", \"slip\", \"phonet\" \"ieee802154\", \"sixlowpan\", \"ieee80216\", \"ieee1394\" Returns: interface type \"\"\" return INTERFACE_TYPES . inverse [ self . type ()]","title":"get_type()"},{"location":"api/network.html#prettyqt.network.networkproxy","text":"","title":"networkproxy"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy","text":"","title":"NetworkProxy"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.get_type","text":"Get the proxy type. Possible values: \"none\", \"default\", \"socks5\", \"http\", \"http_caching\", \"ftp_caching\" Returns: Type Description str type Source code in prettyqt/network/networkproxy.py def get_type ( self ) -> str : \"\"\"Get the proxy type. Possible values: \"none\", \"default\", \"socks5\", \"http\", \"http_caching\", \"ftp_caching\" Returns: type \"\"\" return PROXY_TYPES . inverse [ self . type ()]","title":"get_type()"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.set_type","text":"Set proxy type. Valid values: \"none\", \"default\", \"socks5\", \"http\", \"http_caching\", \"ftp_caching\" Parameters: Name Type Description Default typ str proxy type required Exceptions: Type Description InvalidParamError proxy type does not exist Source code in prettyqt/network/networkproxy.py def set_type ( self , typ : str ): \"\"\"Set proxy type. Valid values: \"none\", \"default\", \"socks5\", \"http\", \"http_caching\", \"ftp_caching\" Args: typ: proxy type Raises: InvalidParamError: proxy type does not exist \"\"\" if typ not in PROXY_TYPES : raise InvalidParamError ( typ , PROXY_TYPES ) self . setType ( PROXY_TYPES [ typ ])","title":"set_type()"},{"location":"api/network.html#prettyqt.network.networkrequest","text":"","title":"networkrequest"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest","text":"","title":"NetworkRequest"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.get_priority","text":"Get the current priority. Possible values: \"high\", \"normal\", \"low\" Returns: Type Description str priority Source code in prettyqt/network/networkrequest.py def get_priority ( self ) -> str : \"\"\"Get the current priority. Possible values: \"high\", \"normal\", \"low\" Returns: priority \"\"\" return PRIORITIES . inverse [ self . priority ()]","title":"get_priority()"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.set_priority","text":"Set priority. Valid values for priority: \"high\", \"normal\", \"low\" Parameters: Name Type Description Default priority str priority required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/network/networkrequest.py def set_priority ( self , priority : str ): \"\"\"Set priority. Valid values for priority: \"high\", \"normal\", \"low\" Args: priority: priority Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ])","title":"set_priority()"},{"location":"api/network.html#prettyqt.network.tcpserver","text":"","title":"tcpserver"},{"location":"api/network.html#prettyqt.network.tcpserver.TcpServer","text":"","title":"TcpServer"},{"location":"api/network.html#prettyqt.network.tcpserver.TcpServer.listen","text":"listen(self, address: Union[QHostAddress, QHostAddress.SpecialAddress] = QHostAddress.Any, port: int = 0) -> bool Source code in prettyqt/network/tcpserver.py def listen ( self , address : Union [ str , QtNetwork . QHostAddress ], port : int = 0 ) -> bool : if isinstance ( address , str ): address = network . HostAddress ( address ) return super () . listen ( address , port )","title":"listen()"},{"location":"api/objbrowser.html","text":"objbrowser module Objbrowser package. attribute_model Module that defines AttributeModel. safe_data_fn ( obj_fn , log_exceptions = False ) Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function Source code in prettyqt/objbrowser/attribute_model.py def safe_data_fn ( obj_fn : Callable , log_exceptions : bool = False , ) -> Callable : \"\"\"Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function \"\"\" def data_fn ( tree_item : treeitem . TreeItem ) -> str : \"\"\"Call the obj_fn(tree_item.obj). Returns empty string in case of an error \"\"\" try : return str ( obj_fn ( tree_item . obj )) except Exception as ex : if log_exceptions : logger . exception ( ex ) return \"\" return data_fn objectbrowser Object browser GUI in Qt. ObjectBrowser Object browser main application window. __init__ ( self , obj , name = '' ) special Constructor. :param obj: any Python object or variable :param name: name of the object as it will appear in the root node Source code in prettyqt/objbrowser/objectbrowser.py def __init__ ( self , obj , name : str = \"\" ): \"\"\"Constructor. :param obj: any Python object or variable :param name: name of the object as it will appear in the root node \"\"\" super () . __init__ () self . _instance_nr = self . _add_instance () self . set_icon ( \"mdi.language-python\" ) # Model self . _attr_cols = DEFAULT_ATTR_COLS self . _attr_details = DEFAULT_ATTR_DETAILS logger . debug ( \"Reading model settings for window: %d \" , self . _instance_nr ) with core . Settings ( settings_id = self . _settings_group_name ( \"model\" )) as settings : self . _auto_refresh = settings . get ( \"auto_refresh\" , False ) logger . debug ( \"read auto_refresh: %r \" , self . _auto_refresh ) self . _refresh_rate = settings . get ( \"refresh_rate\" , 2 ) logger . debug ( \"read refresh_rate: %r \" , self . _refresh_rate ) show_callable_attributes = settings . get ( \"show_callable_attributes\" , True ) logger . debug ( \"read show_callable_attributes: %r \" , show_callable_attributes ) show_special_attributes = settings . get ( \"show_special_attributes\" , True ) logger . debug ( \"read show_special_attributes: %r \" , show_special_attributes ) self . _tree_model = objectbrowsertreemodel . ObjectBrowserTreeModel ( obj , name , attr_cols = self . _attr_cols ) self . _proxy_tree_model = objectbrowsertreemodel . ObjectBrowserTreeProxyModel ( show_callable_attributes = show_callable_attributes , show_special_attributes = show_special_attributes , ) self . _proxy_tree_model . setSourceModel ( self . _tree_model ) # self._proxy_tree_model.setSortRole(RegistryTableModel.SORT_ROLE) self . _proxy_tree_model . setDynamicSortFilter ( True ) # self._proxy_tree_model.setSortCaseSensitivity(Qt.CaseInsensitive) # Views self . _setup_actions () self . _setup_views () self . _setup_menu () self . set_title ( \"Object browser\" ) self . _read_view_settings () assert self . _refresh_rate > 0 , \"refresh_rate must be > 0. Got: {} \" . format ( self . _refresh_rate ) self . _refresh_timer = core . Timer ( self ) self . _refresh_timer . setInterval ( self . _refresh_rate * 1000 ) self . _refresh_timer . timeout . connect ( self . _tree_model . refresh_tree ) # Update views with model self . toggle_special_attribute_action . setChecked ( show_special_attributes ) self . toggle_callable_action . setChecked ( show_callable_attributes ) self . toggle_auto_refresh_action . setChecked ( self . _auto_refresh ) # Select first row so that a hidden root node will not be selected. first_row_index = self . _proxy_tree_model . first_item_index () self . obj_tree . setCurrentIndex ( first_row_index ) if self . _tree_model . inspected_node_is_visible : self . obj_tree . expand ( first_row_index ) browse ( * args , ** kwargs ) classmethod Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The args and *kwargs will be passed to the ObjectBrowser constructor. Source code in prettyqt/objbrowser/objectbrowser.py @classmethod def browse ( cls , * args , ** kwargs ): \"\"\"Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The *args and **kwargs will be passed to the ObjectBrowser constructor. \"\"\" cls . app = widgets . app () # keeping reference to prevent garbage collection. cls . app . setOrganizationName ( \"phil65\" ) cls . app . setApplicationName ( \"PrettyQt\" ) object_browser = cls ( * args , ** kwargs ) object_browser . show () object_browser . raise_ () assert cls . app is not None , \"QApplication object doesn't exist yet.\" return cls . app . main_loop () closeEvent ( self , event ) Called when the window is closed. Source code in prettyqt/objbrowser/objectbrowser.py def closeEvent ( self , event ): \"\"\"Called when the window is closed.\"\"\" logger . debug ( \"closeEvent\" ) self . _write_model_settings () self . _write_view_settings () self . _finalize () self . close () event . accept () \"\"\"Set the reference in the browser list to None.\"\"\" idx = self . _browsers . index ( self ) self . _browsers [ idx ] = None logger . debug ( \"Closed window %s \" , self . _instance_nr ) toggle_auto_refresh ( self , checked ) Toggle auto-refresh on/off. Source code in prettyqt/objbrowser/objectbrowser.py def toggle_auto_refresh ( self , checked ): \"\"\"Toggle auto-refresh on/off.\"\"\" if checked : logger . info ( \"Auto-refresh on. Rate %g seconds\" , self . _refresh_rate ) self . _refresh_timer . start () else : logger . info ( \"Auto-refresh off\" ) self . _refresh_timer . stop () self . _auto_refresh = checked objectbrowsertreemodel Module that defines the TreeModel. https://github.com/PySide/Examples/blob/master/examples/itemviews/simpletreemodel /simpletreemodel.py ObjectBrowserTreeItem Tree node class that can be used to build trees of objects. is_callable_attribute: bool property readonly Return true if the items is an attribute and it is callable. is_special_attribute: bool property readonly Return true if the item represents a dunder attribute. ObjectBrowserTreeModel Model that provides an interface to an objectree that is build of tree items. inspected_node_is_visible property readonly Return True if the inspected node is visible. In that case an invisible root node has been added. root_item: ObjectBrowserTreeItem property readonly The root ObjectBrowserTreeItem. __init__ ( self , obj , obj_name = '' , attr_cols = None , parent = None ) special Constructor. Parameters: Name Type Description Default obj Any Object to inspect required obj_name str Name of the object '' attr_cols Optional[List[custom_models.ColumnItem]] List of Column items None parent Optional[QtCore.QObject] Description None Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , obj : Any , obj_name : str = \"\" , attr_cols : Optional [ List [ custom_models . ColumnItem ]] = None , parent : Optional [ QtCore . QObject ] = None , ): \"\"\"Constructor. Args: obj (Any): Object to inspect obj_name (str, optional): Name of the object attr_cols (None, optional): List of Column items parent (None, optional): Description \"\"\" super () . __init__ ( attr_cols = attr_cols , parent = parent ) # The root_item is always invisible. If the obj_name is the empty string, the # inspectedItem will be the invisible root_item. If the obj_name is given, # an invisible root item will be added and the inspectedItem will be its # only child. In that case the inspected item will be visible. self . _inspected_node_is_visible = obj_name != \"\" if self . _inspected_node_is_visible : self . _root_item = ObjectBrowserTreeItem ( None , \"<invisible_root>\" , \"<invisible_root>\" , None ) self . _root_item . children_fetched = True self . inspected_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . _root_item . append_child ( self . inspected_item ) else : # The root itself will be invisible self . _root_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . inspected_item = self . _root_item # Fetch all items of the root so we can select the first row in the ctor. root_index = self . index ( 0 , 0 ) self . fetchMore ( root_index ) canFetchMore ( self , parent = None ) canFetchMore(self, QModelIndex) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def canFetchMore ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : result = not self . tree_item ( parent ) . children_fetched # logger.debug(\"canFetchMore: {} = {}\".format(parent, result)) return result fetchMore ( self , parent = None ) Fetches the children given the model index of a parent node. Adds the children to the parent. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def fetchMore ( self , parent : Optional [ core . ModelIndex ] = None ): \"\"\"Fetches the children given the model index of a parent node. Adds the children to the parent. \"\"\" parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return parent_item = self . tree_item ( parent ) if parent_item . children_fetched : return tree_items = self . _fetch_object_children ( parent_item . obj , parent_item . obj_path ) with self . insert_rows ( 0 , len ( tree_items ) - 1 , parent ): for tree_item in tree_items : parent_item . append_child ( tree_item ) parent_item . children_fetched = True flags ( self , index ) flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def flags ( self , index : core . ModelIndex ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE hasChildren ( self , parent = None ) hasChildren(self, parent: QModelIndex = QModelIndex()) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def hasChildren ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : return self . tree_item ( parent ) . has_children index ( self , row , column , parent = None ) index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def index ( self , row : int , column : int , parent : Optional [ core . ModelIndex ] = None ) -> core . ModelIndex : if parent is None : logger . debug ( \"parent is None\" ) parent = core . ModelIndex () parent_item = self . tree_item ( parent ) if not self . hasIndex ( row , column , parent ): logger . debug ( \"hasIndex is False: ( %s , %s ) %r \" , row , column , parent_item ) # logger.warn(\"Parent index model: {!r} != {!r}\".format(parent.model(), self)) return core . ModelIndex () child_item = parent_item . child ( row ) # logger.debug(\" {}\".format(child_item.obj_path)) if child_item : return self . createIndex ( row , column , child_item ) else : logger . warn ( \"no child_item\" ) return core . ModelIndex () inspected_index ( self ) The model index that point to the inspectedItem. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def inspected_index ( self ) -> core . ModelIndex : \"\"\"The model index that point to the inspectedItem.\"\"\" if self . inspected_node_is_visible : return self . createIndex ( 0 , 0 , self . inspected_item ) else : return self . root_index () parent ( self , index ) parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def parent ( self , index : core . ModelIndex ) -> QtCore . QModelindex : if not index . isValid (): return core . ModelIndex () child_item = index . internalPointer () parent_item = child_item . parent () if parent_item is None or parent_item == self . root_item : return core . ModelIndex () return self . createIndex ( parent_item . row (), 0 , parent_item ) refresh_tree ( self ) Refreshes the tree model from the underlying root object. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def refresh_tree ( self ): \"\"\"Refreshes the tree model from the underlying root object.\"\"\" logger . info ( \"\" ) logger . info ( \"refresh_tree: %s \" , self . root_item ) root_item = self . tree_item ( self . root_index ()) logger . info ( \" root_item: %s (idx= %s )\" , root_item , self . root_index ()) inspected_item = self . tree_item ( self . inspected_index ()) logger . info ( \" inspected_item: %s (idx= %s )\" , inspected_item , self . inspected_index () ) assert ( root_item is inspected_item ) != self . inspected_node_is_visible , \"sanity check\" self . _aux_refresh_tree ( self . inspected_index ()) logger . debug ( \"After _aux_refresh_tree, root_obj: %s \" , helpers . cut_off_str ( self . root_item . obj , 80 ), ) self . root_item . pretty_print () # Emit the dataChanged signal for all cells. This is faster than checking which # nodes have changed, which may be slow for some underlying Python objects. bottom_row = self . rowCount () - 1 right_column = self . columnCount () - 1 top_left = self . index ( 0 , 0 ) bottom_right = self . index ( bottom_row , right_column ) logger . debug ( f \"bottom_right: ( { bottom_row } , { right_column } )\" ) self . dataChanged . emit ( top_left , bottom_right ) root_index ( self ) The index that returns the root element (same as an invalid index). Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def root_index ( self ) -> core . ModelIndex : # TODO: needed? \"\"\"The index that returns the root element (same as an invalid index).\"\"\" return core . ModelIndex () rowCount ( self , parent = None ) rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def rowCount ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : # This is taken from the PyQt simpletreemodel example. return 0 else : return self . tree_item ( parent ) . child_count () ObjectBrowserTreeProxyModel Proxy model that overrides the sorting and can filter out items. __init__ ( self , show_callable_attributes = True , show_special_attributes = True , parent = None ) special Constructor. :param show_callable_attributes: if True the callables objects, i.e. objects (such as function) that a call method, will be displayed (in brown). If False they are hidden. :param show_special_attributes: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , show_callable_attributes : bool = True , show_special_attributes : bool = True , parent = None , ): \"\"\"Constructor. :param show_callable_attributes: if True the callables objects, i.e. objects (such as function) that a __call__ method, will be displayed (in brown). If False they are hidden. :param show_special_attributes: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget \"\"\" super () . __init__ ( parent ) self . _show_callables = show_callable_attributes self . _show_special_attributes = show_special_attributes filterAcceptsRow ( self , source_row , source_parent_index ) Return true if the item should be included in the model. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def filterAcceptsRow ( self , source_row : int , source_parent_index : core . ModelIndex ): \"\"\"Return true if the item should be included in the model.\"\"\" parent_item = self . sourceModel () . tree_item ( source_parent_index ) tree_item = parent_item . child ( source_row ) accept = ( self . _show_special_attributes or not tree_item . is_special_attribute ) and ( self . _show_callables or not tree_item . is_callable_attribute ) # logger.debug(\"filterAcceptsRow = {}: {}\".format(accept, tree_item)) return accept first_item_index ( self ) Return the first child of the root item. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def first_item_index ( self ) -> core . ModelIndex : \"\"\"Return the first child of the root item.\"\"\" # We cannot just call the same function of the source model because the first node # there may be hidden. source_root_index = self . sourceModel () . root_index () proxy_root_index = self . mapFromSource ( source_root_index ) first_item_index = self . index ( 0 , 0 , proxy_root_index ) return first_item_index set_show_callables ( self , show_callables ) Show/hide show_callables which have a call attribute. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_callables ( self , show_callables : bool ): \"\"\"Show/hide show_callables which have a __call__ attribute.\"\"\" logger . debug ( \"set_show_callables: %s \" , show_callables ) self . _show_callables = show_callables self . invalidateFilter () set_show_special_attributes ( self , show_special_attributes ) Show/hide special attributes which begin with an underscore. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_special_attributes ( self , show_special_attributes : bool ): \"\"\"Show/hide special attributes which begin with an underscore.\"\"\" logger . debug ( \"set_show_special_attributes: %s \" , show_special_attributes ) self . _show_special_attributes = show_special_attributes self . invalidateFilter ()","title":"objbrowser"},{"location":"api/objbrowser.html#objbrowser-module","text":"","title":"objbrowser module"},{"location":"api/objbrowser.html#prettyqt.objbrowser","text":"Objbrowser package.","title":"prettyqt.objbrowser"},{"location":"api/objbrowser.html#prettyqt.objbrowser.attribute_model","text":"Module that defines AttributeModel.","title":"attribute_model"},{"location":"api/objbrowser.html#prettyqt.objbrowser.attribute_model.safe_data_fn","text":"Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function Source code in prettyqt/objbrowser/attribute_model.py def safe_data_fn ( obj_fn : Callable , log_exceptions : bool = False , ) -> Callable : \"\"\"Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function \"\"\" def data_fn ( tree_item : treeitem . TreeItem ) -> str : \"\"\"Call the obj_fn(tree_item.obj). Returns empty string in case of an error \"\"\" try : return str ( obj_fn ( tree_item . obj )) except Exception as ex : if log_exceptions : logger . exception ( ex ) return \"\" return data_fn","title":"safe_data_fn()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser","text":"Object browser GUI in Qt.","title":"objectbrowser"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser","text":"Object browser main application window.","title":"ObjectBrowser"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.__init__","text":"Constructor. :param obj: any Python object or variable :param name: name of the object as it will appear in the root node Source code in prettyqt/objbrowser/objectbrowser.py def __init__ ( self , obj , name : str = \"\" ): \"\"\"Constructor. :param obj: any Python object or variable :param name: name of the object as it will appear in the root node \"\"\" super () . __init__ () self . _instance_nr = self . _add_instance () self . set_icon ( \"mdi.language-python\" ) # Model self . _attr_cols = DEFAULT_ATTR_COLS self . _attr_details = DEFAULT_ATTR_DETAILS logger . debug ( \"Reading model settings for window: %d \" , self . _instance_nr ) with core . Settings ( settings_id = self . _settings_group_name ( \"model\" )) as settings : self . _auto_refresh = settings . get ( \"auto_refresh\" , False ) logger . debug ( \"read auto_refresh: %r \" , self . _auto_refresh ) self . _refresh_rate = settings . get ( \"refresh_rate\" , 2 ) logger . debug ( \"read refresh_rate: %r \" , self . _refresh_rate ) show_callable_attributes = settings . get ( \"show_callable_attributes\" , True ) logger . debug ( \"read show_callable_attributes: %r \" , show_callable_attributes ) show_special_attributes = settings . get ( \"show_special_attributes\" , True ) logger . debug ( \"read show_special_attributes: %r \" , show_special_attributes ) self . _tree_model = objectbrowsertreemodel . ObjectBrowserTreeModel ( obj , name , attr_cols = self . _attr_cols ) self . _proxy_tree_model = objectbrowsertreemodel . ObjectBrowserTreeProxyModel ( show_callable_attributes = show_callable_attributes , show_special_attributes = show_special_attributes , ) self . _proxy_tree_model . setSourceModel ( self . _tree_model ) # self._proxy_tree_model.setSortRole(RegistryTableModel.SORT_ROLE) self . _proxy_tree_model . setDynamicSortFilter ( True ) # self._proxy_tree_model.setSortCaseSensitivity(Qt.CaseInsensitive) # Views self . _setup_actions () self . _setup_views () self . _setup_menu () self . set_title ( \"Object browser\" ) self . _read_view_settings () assert self . _refresh_rate > 0 , \"refresh_rate must be > 0. Got: {} \" . format ( self . _refresh_rate ) self . _refresh_timer = core . Timer ( self ) self . _refresh_timer . setInterval ( self . _refresh_rate * 1000 ) self . _refresh_timer . timeout . connect ( self . _tree_model . refresh_tree ) # Update views with model self . toggle_special_attribute_action . setChecked ( show_special_attributes ) self . toggle_callable_action . setChecked ( show_callable_attributes ) self . toggle_auto_refresh_action . setChecked ( self . _auto_refresh ) # Select first row so that a hidden root node will not be selected. first_row_index = self . _proxy_tree_model . first_item_index () self . obj_tree . setCurrentIndex ( first_row_index ) if self . _tree_model . inspected_node_is_visible : self . obj_tree . expand ( first_row_index )","title":"__init__()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.browse","text":"Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The args and *kwargs will be passed to the ObjectBrowser constructor. Source code in prettyqt/objbrowser/objectbrowser.py @classmethod def browse ( cls , * args , ** kwargs ): \"\"\"Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The *args and **kwargs will be passed to the ObjectBrowser constructor. \"\"\" cls . app = widgets . app () # keeping reference to prevent garbage collection. cls . app . setOrganizationName ( \"phil65\" ) cls . app . setApplicationName ( \"PrettyQt\" ) object_browser = cls ( * args , ** kwargs ) object_browser . show () object_browser . raise_ () assert cls . app is not None , \"QApplication object doesn't exist yet.\" return cls . app . main_loop ()","title":"browse()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.closeEvent","text":"Called when the window is closed. Source code in prettyqt/objbrowser/objectbrowser.py def closeEvent ( self , event ): \"\"\"Called when the window is closed.\"\"\" logger . debug ( \"closeEvent\" ) self . _write_model_settings () self . _write_view_settings () self . _finalize () self . close () event . accept () \"\"\"Set the reference in the browser list to None.\"\"\" idx = self . _browsers . index ( self ) self . _browsers [ idx ] = None logger . debug ( \"Closed window %s \" , self . _instance_nr )","title":"closeEvent()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.toggle_auto_refresh","text":"Toggle auto-refresh on/off. Source code in prettyqt/objbrowser/objectbrowser.py def toggle_auto_refresh ( self , checked ): \"\"\"Toggle auto-refresh on/off.\"\"\" if checked : logger . info ( \"Auto-refresh on. Rate %g seconds\" , self . _refresh_rate ) self . _refresh_timer . start () else : logger . info ( \"Auto-refresh off\" ) self . _refresh_timer . stop () self . _auto_refresh = checked","title":"toggle_auto_refresh()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel","text":"Module that defines the TreeModel. https://github.com/PySide/Examples/blob/master/examples/itemviews/simpletreemodel /simpletreemodel.py","title":"objectbrowsertreemodel"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem","text":"Tree node class that can be used to build trees of objects.","title":"ObjectBrowserTreeItem"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem.is_callable_attribute","text":"Return true if the items is an attribute and it is callable.","title":"is_callable_attribute"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem.is_special_attribute","text":"Return true if the item represents a dunder attribute.","title":"is_special_attribute"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel","text":"Model that provides an interface to an objectree that is build of tree items.","title":"ObjectBrowserTreeModel"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.inspected_node_is_visible","text":"Return True if the inspected node is visible. In that case an invisible root node has been added.","title":"inspected_node_is_visible"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.root_item","text":"The root ObjectBrowserTreeItem.","title":"root_item"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.__init__","text":"Constructor. Parameters: Name Type Description Default obj Any Object to inspect required obj_name str Name of the object '' attr_cols Optional[List[custom_models.ColumnItem]] List of Column items None parent Optional[QtCore.QObject] Description None Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , obj : Any , obj_name : str = \"\" , attr_cols : Optional [ List [ custom_models . ColumnItem ]] = None , parent : Optional [ QtCore . QObject ] = None , ): \"\"\"Constructor. Args: obj (Any): Object to inspect obj_name (str, optional): Name of the object attr_cols (None, optional): List of Column items parent (None, optional): Description \"\"\" super () . __init__ ( attr_cols = attr_cols , parent = parent ) # The root_item is always invisible. If the obj_name is the empty string, the # inspectedItem will be the invisible root_item. If the obj_name is given, # an invisible root item will be added and the inspectedItem will be its # only child. In that case the inspected item will be visible. self . _inspected_node_is_visible = obj_name != \"\" if self . _inspected_node_is_visible : self . _root_item = ObjectBrowserTreeItem ( None , \"<invisible_root>\" , \"<invisible_root>\" , None ) self . _root_item . children_fetched = True self . inspected_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . _root_item . append_child ( self . inspected_item ) else : # The root itself will be invisible self . _root_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . inspected_item = self . _root_item # Fetch all items of the root so we can select the first row in the ctor. root_index = self . index ( 0 , 0 ) self . fetchMore ( root_index )","title":"__init__()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.canFetchMore","text":"canFetchMore(self, QModelIndex) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def canFetchMore ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : result = not self . tree_item ( parent ) . children_fetched # logger.debug(\"canFetchMore: {} = {}\".format(parent, result)) return result","title":"canFetchMore()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.fetchMore","text":"Fetches the children given the model index of a parent node. Adds the children to the parent. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def fetchMore ( self , parent : Optional [ core . ModelIndex ] = None ): \"\"\"Fetches the children given the model index of a parent node. Adds the children to the parent. \"\"\" parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return parent_item = self . tree_item ( parent ) if parent_item . children_fetched : return tree_items = self . _fetch_object_children ( parent_item . obj , parent_item . obj_path ) with self . insert_rows ( 0 , len ( tree_items ) - 1 , parent ): for tree_item in tree_items : parent_item . append_child ( tree_item ) parent_item . children_fetched = True","title":"fetchMore()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.flags","text":"flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def flags ( self , index : core . ModelIndex ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE","title":"flags()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.hasChildren","text":"hasChildren(self, parent: QModelIndex = QModelIndex()) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def hasChildren ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : return self . tree_item ( parent ) . has_children","title":"hasChildren()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.index","text":"index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def index ( self , row : int , column : int , parent : Optional [ core . ModelIndex ] = None ) -> core . ModelIndex : if parent is None : logger . debug ( \"parent is None\" ) parent = core . ModelIndex () parent_item = self . tree_item ( parent ) if not self . hasIndex ( row , column , parent ): logger . debug ( \"hasIndex is False: ( %s , %s ) %r \" , row , column , parent_item ) # logger.warn(\"Parent index model: {!r} != {!r}\".format(parent.model(), self)) return core . ModelIndex () child_item = parent_item . child ( row ) # logger.debug(\" {}\".format(child_item.obj_path)) if child_item : return self . createIndex ( row , column , child_item ) else : logger . warn ( \"no child_item\" ) return core . ModelIndex ()","title":"index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.inspected_index","text":"The model index that point to the inspectedItem. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def inspected_index ( self ) -> core . ModelIndex : \"\"\"The model index that point to the inspectedItem.\"\"\" if self . inspected_node_is_visible : return self . createIndex ( 0 , 0 , self . inspected_item ) else : return self . root_index ()","title":"inspected_index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.parent","text":"parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def parent ( self , index : core . ModelIndex ) -> QtCore . QModelindex : if not index . isValid (): return core . ModelIndex () child_item = index . internalPointer () parent_item = child_item . parent () if parent_item is None or parent_item == self . root_item : return core . ModelIndex () return self . createIndex ( parent_item . row (), 0 , parent_item )","title":"parent()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.refresh_tree","text":"Refreshes the tree model from the underlying root object. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def refresh_tree ( self ): \"\"\"Refreshes the tree model from the underlying root object.\"\"\" logger . info ( \"\" ) logger . info ( \"refresh_tree: %s \" , self . root_item ) root_item = self . tree_item ( self . root_index ()) logger . info ( \" root_item: %s (idx= %s )\" , root_item , self . root_index ()) inspected_item = self . tree_item ( self . inspected_index ()) logger . info ( \" inspected_item: %s (idx= %s )\" , inspected_item , self . inspected_index () ) assert ( root_item is inspected_item ) != self . inspected_node_is_visible , \"sanity check\" self . _aux_refresh_tree ( self . inspected_index ()) logger . debug ( \"After _aux_refresh_tree, root_obj: %s \" , helpers . cut_off_str ( self . root_item . obj , 80 ), ) self . root_item . pretty_print () # Emit the dataChanged signal for all cells. This is faster than checking which # nodes have changed, which may be slow for some underlying Python objects. bottom_row = self . rowCount () - 1 right_column = self . columnCount () - 1 top_left = self . index ( 0 , 0 ) bottom_right = self . index ( bottom_row , right_column ) logger . debug ( f \"bottom_right: ( { bottom_row } , { right_column } )\" ) self . dataChanged . emit ( top_left , bottom_right )","title":"refresh_tree()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.root_index","text":"The index that returns the root element (same as an invalid index). Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def root_index ( self ) -> core . ModelIndex : # TODO: needed? \"\"\"The index that returns the root element (same as an invalid index).\"\"\" return core . ModelIndex ()","title":"root_index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.rowCount","text":"rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def rowCount ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : # This is taken from the PyQt simpletreemodel example. return 0 else : return self . tree_item ( parent ) . child_count ()","title":"rowCount()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel","text":"Proxy model that overrides the sorting and can filter out items.","title":"ObjectBrowserTreeProxyModel"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.__init__","text":"Constructor. :param show_callable_attributes: if True the callables objects, i.e. objects (such as function) that a call method, will be displayed (in brown). If False they are hidden. :param show_special_attributes: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , show_callable_attributes : bool = True , show_special_attributes : bool = True , parent = None , ): \"\"\"Constructor. :param show_callable_attributes: if True the callables objects, i.e. objects (such as function) that a __call__ method, will be displayed (in brown). If False they are hidden. :param show_special_attributes: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget \"\"\" super () . __init__ ( parent ) self . _show_callables = show_callable_attributes self . _show_special_attributes = show_special_attributes","title":"__init__()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.filterAcceptsRow","text":"Return true if the item should be included in the model. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def filterAcceptsRow ( self , source_row : int , source_parent_index : core . ModelIndex ): \"\"\"Return true if the item should be included in the model.\"\"\" parent_item = self . sourceModel () . tree_item ( source_parent_index ) tree_item = parent_item . child ( source_row ) accept = ( self . _show_special_attributes or not tree_item . is_special_attribute ) and ( self . _show_callables or not tree_item . is_callable_attribute ) # logger.debug(\"filterAcceptsRow = {}: {}\".format(accept, tree_item)) return accept","title":"filterAcceptsRow()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.first_item_index","text":"Return the first child of the root item. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def first_item_index ( self ) -> core . ModelIndex : \"\"\"Return the first child of the root item.\"\"\" # We cannot just call the same function of the source model because the first node # there may be hidden. source_root_index = self . sourceModel () . root_index () proxy_root_index = self . mapFromSource ( source_root_index ) first_item_index = self . index ( 0 , 0 , proxy_root_index ) return first_item_index","title":"first_item_index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.set_show_callables","text":"Show/hide show_callables which have a call attribute. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_callables ( self , show_callables : bool ): \"\"\"Show/hide show_callables which have a __call__ attribute.\"\"\" logger . debug ( \"set_show_callables: %s \" , show_callables ) self . _show_callables = show_callables self . invalidateFilter ()","title":"set_show_callables()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.set_show_special_attributes","text":"Show/hide special attributes which begin with an underscore. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_special_attributes ( self , show_special_attributes : bool ): \"\"\"Show/hide special attributes which begin with an underscore.\"\"\" logger . debug ( \"set_show_special_attributes: %s \" , show_special_attributes ) self . _show_special_attributes = show_special_attributes self . invalidateFilter ()","title":"set_show_special_attributes()"},{"location":"api/positioning.html","text":"positioning module Positioning module. Contains QtPositioning-based classes geoareamonitorsource GeoAreaMonitorSource get_error ( self ) Return error type. possible values: \"access_error\" \"insufficient_pos_info\", \"none\", \"unkown_source\" Returns: Type Description str error type Source code in prettyqt/positioning/geoareamonitorsource.py def get_error ( self ) -> str : \"\"\"Return error type. possible values: \"access_error\" \"insufficient_pos_info\", \"none\", \"unkown_source\" Returns: error type \"\"\" return ERRORS . inverse [ self . error ()] geopositioninfosource GeoPositionInfoSource get_error ( self ) Return error type. possible values are \"access_error\" \"closed_error\", \"none\", \"unkown_source\" Returns: Type Description str error type Source code in prettyqt/positioning/geopositioninfosource.py def get_error ( self ) -> str : \"\"\"Return error type. possible values are \"access_error\" \"closed_error\", \"none\", \"unkown_source\" Returns: error type \"\"\" return ERRORS . inverse [ self . error ()] get_preferred_positioning_methods ( self ) Return list of preferred positioning methods. possible included values are \"none\", \"satellite\", \"non_satellite\", \"all\" Returns: Type Description List[str] list of preferred positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_preferred_positioning_methods ( self ) -> List [ str ]: \"\"\"Return list of preferred positioning methods. possible included values are \"none\", \"satellite\", \"non_satellite\", \"all\" Returns: list of preferred positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . preferredPositioningMethods () ] get_supported_positioning_methods ( self ) Return list of supported positioning methods. possible included values are \"none\", \"satellite\", \"non_satellite\", \"all\" Returns: Type Description List[str] list of supported positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_supported_positioning_methods ( self ) -> List [ str ]: \"\"\"Return list of supported positioning methods. possible included values are \"none\", \"satellite\", \"non_satellite\", \"all\" Returns: list of supported positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . supportedPositioningMethods () ] set_preferred_positioning_methods ( self , * methods ) Set preferred positioning methods. valid values are \"none\", \"satellite\", \"non_satellite\", \"all\" Parameters: Name Type Description Default methods str positioning methods to use () Exceptions: Type Description InvalidParamError invalid positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def set_preferred_positioning_methods ( self , * methods : str ): \"\"\"Set preferred positioning methods. valid values are \"none\", \"satellite\", \"non_satellite\", \"all\" Args: methods: positioning methods to use Raises: InvalidParamError: invalid positioning methods \"\"\" for item in methods : if item not in POSITIONING_METHODS : raise InvalidParamError ( item , POSITIONING_METHODS ) flags = helpers . merge_flags ( methods , POSITIONING_METHODS ) self . setPreferredPositioningMethods ( flags ) geosatelliteinfo GeoSatelliteInfo get_satellite_system ( self ) Return satellite system. possible values are \"undefined\", \"gps\", \"glonass\" Returns: Type Description bool satellite system Source code in prettyqt/positioning/geosatelliteinfo.py def get_satellite_system ( self ) -> bool : \"\"\"Return satellite system. possible values are \"undefined\", \"gps\", \"glonass\" Returns: satellite system \"\"\" return SATELLITE_SYSTEMS . inverse [ self . satelliteSystem ()] set_satellite_system ( self , system ) Set satellite system. valid values are: \"undefined\", \"gps\", \"glonass\" Parameters: Name Type Description Default system str satellite system to use required Exceptions: Type Description InvalidParamError invalid system Source code in prettyqt/positioning/geosatelliteinfo.py def set_satellite_system ( self , system : str ): \"\"\"Set satellite system. valid values are: \"undefined\", \"gps\", \"glonass\" Args: system: satellite system to use Raises: InvalidParamError: invalid system \"\"\" if system not in SATELLITE_SYSTEMS : raise InvalidParamError ( system , SATELLITE_SYSTEMS ) self . setSatelliteSystem ( SATELLITE_SYSTEMS [ system ]) geosatelliteinfosource GeoSatelliteInfoSource get_error ( self ) Return error type. possible values are \"access_error\" \"closed_error\", \"none\", \"unkown_source\" Returns: Type Description str error type Source code in prettyqt/positioning/geosatelliteinfosource.py def get_error ( self ) -> str : \"\"\"Return error type. possible values are \"access_error\" \"closed_error\", \"none\", \"unkown_source\" Returns: error type \"\"\" return ERRORS . inverse [ self . error ()]","title":"positioning"},{"location":"api/positioning.html#positioning-module","text":"","title":"positioning module"},{"location":"api/positioning.html#prettyqt.positioning","text":"Positioning module. Contains QtPositioning-based classes","title":"prettyqt.positioning"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource","text":"","title":"geoareamonitorsource"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource.GeoAreaMonitorSource","text":"","title":"GeoAreaMonitorSource"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource.GeoAreaMonitorSource.get_error","text":"Return error type. possible values: \"access_error\" \"insufficient_pos_info\", \"none\", \"unkown_source\" Returns: Type Description str error type Source code in prettyqt/positioning/geoareamonitorsource.py def get_error ( self ) -> str : \"\"\"Return error type. possible values: \"access_error\" \"insufficient_pos_info\", \"none\", \"unkown_source\" Returns: error type \"\"\" return ERRORS . inverse [ self . error ()]","title":"get_error()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource","text":"","title":"geopositioninfosource"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource","text":"","title":"GeoPositionInfoSource"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.get_error","text":"Return error type. possible values are \"access_error\" \"closed_error\", \"none\", \"unkown_source\" Returns: Type Description str error type Source code in prettyqt/positioning/geopositioninfosource.py def get_error ( self ) -> str : \"\"\"Return error type. possible values are \"access_error\" \"closed_error\", \"none\", \"unkown_source\" Returns: error type \"\"\" return ERRORS . inverse [ self . error ()]","title":"get_error()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.get_preferred_positioning_methods","text":"Return list of preferred positioning methods. possible included values are \"none\", \"satellite\", \"non_satellite\", \"all\" Returns: Type Description List[str] list of preferred positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_preferred_positioning_methods ( self ) -> List [ str ]: \"\"\"Return list of preferred positioning methods. possible included values are \"none\", \"satellite\", \"non_satellite\", \"all\" Returns: list of preferred positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . preferredPositioningMethods () ]","title":"get_preferred_positioning_methods()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.get_supported_positioning_methods","text":"Return list of supported positioning methods. possible included values are \"none\", \"satellite\", \"non_satellite\", \"all\" Returns: Type Description List[str] list of supported positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_supported_positioning_methods ( self ) -> List [ str ]: \"\"\"Return list of supported positioning methods. possible included values are \"none\", \"satellite\", \"non_satellite\", \"all\" Returns: list of supported positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . supportedPositioningMethods () ]","title":"get_supported_positioning_methods()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.set_preferred_positioning_methods","text":"Set preferred positioning methods. valid values are \"none\", \"satellite\", \"non_satellite\", \"all\" Parameters: Name Type Description Default methods str positioning methods to use () Exceptions: Type Description InvalidParamError invalid positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def set_preferred_positioning_methods ( self , * methods : str ): \"\"\"Set preferred positioning methods. valid values are \"none\", \"satellite\", \"non_satellite\", \"all\" Args: methods: positioning methods to use Raises: InvalidParamError: invalid positioning methods \"\"\" for item in methods : if item not in POSITIONING_METHODS : raise InvalidParamError ( item , POSITIONING_METHODS ) flags = helpers . merge_flags ( methods , POSITIONING_METHODS ) self . setPreferredPositioningMethods ( flags )","title":"set_preferred_positioning_methods()"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo","text":"","title":"geosatelliteinfo"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo","text":"","title":"GeoSatelliteInfo"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.get_satellite_system","text":"Return satellite system. possible values are \"undefined\", \"gps\", \"glonass\" Returns: Type Description bool satellite system Source code in prettyqt/positioning/geosatelliteinfo.py def get_satellite_system ( self ) -> bool : \"\"\"Return satellite system. possible values are \"undefined\", \"gps\", \"glonass\" Returns: satellite system \"\"\" return SATELLITE_SYSTEMS . inverse [ self . satelliteSystem ()]","title":"get_satellite_system()"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.set_satellite_system","text":"Set satellite system. valid values are: \"undefined\", \"gps\", \"glonass\" Parameters: Name Type Description Default system str satellite system to use required Exceptions: Type Description InvalidParamError invalid system Source code in prettyqt/positioning/geosatelliteinfo.py def set_satellite_system ( self , system : str ): \"\"\"Set satellite system. valid values are: \"undefined\", \"gps\", \"glonass\" Args: system: satellite system to use Raises: InvalidParamError: invalid system \"\"\" if system not in SATELLITE_SYSTEMS : raise InvalidParamError ( system , SATELLITE_SYSTEMS ) self . setSatelliteSystem ( SATELLITE_SYSTEMS [ system ])","title":"set_satellite_system()"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource","text":"","title":"geosatelliteinfosource"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource.GeoSatelliteInfoSource","text":"","title":"GeoSatelliteInfoSource"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource.GeoSatelliteInfoSource.get_error","text":"Return error type. possible values are \"access_error\" \"closed_error\", \"none\", \"unkown_source\" Returns: Type Description str error type Source code in prettyqt/positioning/geosatelliteinfosource.py def get_error ( self ) -> str : \"\"\"Return error type. possible values are \"access_error\" \"closed_error\", \"none\", \"unkown_source\" Returns: error type \"\"\" return ERRORS . inverse [ self . error ()]","title":"get_error()"},{"location":"api/qml.html","text":"qml module Qml module. Contains QtQml-based classes jsvalue JSValue from_object ( obj , jsengine ) classmethod Convert any python object into a QJSValue (must happen in GUI thread). Source code in prettyqt/qml/jsvalue.py @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls () qmlengine QmlEngine get_object_ownership ( self , obj ) Return object ownership. possible values: \"cpp\", \"javascript\" Returns: Type Description str object ownership Source code in prettyqt/qml/qmlengine.py def get_object_ownership ( self , obj : QtCore . QObject ) -> str : \"\"\"Return object ownership. possible values: \"cpp\", \"javascript\" Returns: object ownership \"\"\" return OBJECT_OWNERSHIPS . inverse [ self . objectOwnership ( obj )] set_object_ownership ( self , obj , mode ) Set the object ownership. valid values: \"cpp\", \"javascript\" Parameters: Name Type Description Default mode str object ownership to use required Exceptions: Type Description InvalidParamError invalid object ownership Source code in prettyqt/qml/qmlengine.py def set_object_ownership ( self , obj : QtCore . QObject , mode : str ): \"\"\"Set the object ownership. valid values: \"cpp\", \"javascript\" Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIPS : raise InvalidParamError ( mode , OBJECT_OWNERSHIPS ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIPS [ mode ])","title":"qml"},{"location":"api/qml.html#qml-module","text":"","title":"qml module"},{"location":"api/qml.html#prettyqt.qml","text":"Qml module. Contains QtQml-based classes","title":"prettyqt.qml"},{"location":"api/qml.html#prettyqt.qml.jsvalue","text":"","title":"jsvalue"},{"location":"api/qml.html#prettyqt.qml.jsvalue.JSValue","text":"","title":"JSValue"},{"location":"api/qml.html#prettyqt.qml.jsvalue.JSValue.from_object","text":"Convert any python object into a QJSValue (must happen in GUI thread). Source code in prettyqt/qml/jsvalue.py @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls ()","title":"from_object()"},{"location":"api/qml.html#prettyqt.qml.qmlengine","text":"","title":"qmlengine"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngine","text":"","title":"QmlEngine"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngine.get_object_ownership","text":"Return object ownership. possible values: \"cpp\", \"javascript\" Returns: Type Description str object ownership Source code in prettyqt/qml/qmlengine.py def get_object_ownership ( self , obj : QtCore . QObject ) -> str : \"\"\"Return object ownership. possible values: \"cpp\", \"javascript\" Returns: object ownership \"\"\" return OBJECT_OWNERSHIPS . inverse [ self . objectOwnership ( obj )]","title":"get_object_ownership()"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngine.set_object_ownership","text":"Set the object ownership. valid values: \"cpp\", \"javascript\" Parameters: Name Type Description Default mode str object ownership to use required Exceptions: Type Description InvalidParamError invalid object ownership Source code in prettyqt/qml/qmlengine.py def set_object_ownership ( self , obj : QtCore . QObject , mode : str ): \"\"\"Set the object ownership. valid values: \"cpp\", \"javascript\" Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIPS : raise InvalidParamError ( mode , OBJECT_OWNERSHIPS ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIPS [ mode ])","title":"set_object_ownership()"},{"location":"api/qthelp.html","text":"qthelp module qthelp module. contains QtHelp-based classes","title":"qthelp"},{"location":"api/qthelp.html#qthelp-module","text":"","title":"qthelp module"},{"location":"api/qthelp.html#prettyqt.qthelp","text":"qthelp module. contains QtHelp-based classes","title":"prettyqt.qthelp"},{"location":"api/quick.html","text":"quick module quick module. contains QtQuick-based classes quickitem QuickItem get_transform_origin ( self ) Return the render type of text-like elements in Qt Quick. Possible values: \"top_left\", \"top\", \"top_right\", \"left\", \"center\", \"right\", \"bottom_left\", \"bottom\", \"bottom_right\" Returns: Type Description str transform origin Source code in prettyqt/quick/quickitem.py def get_transform_origin ( self ) -> str : \"\"\"Return the render type of text-like elements in Qt Quick. Possible values: \"top_left\", \"top\", \"top_right\", \"left\", \"center\", \"right\", \"bottom_left\", \"bottom\", \"bottom_right\" Returns: transform origin \"\"\" return TRANSFORM_ORIGIN . inverse [ self . transformOrigin ()] set_transform_origin ( self , origin ) Set the origin point around which scale and rotation transform. The default is \"center\". Allowed values are \"top_left\", \"top\", \"top_right\", \"left\", \"center\", \"right\", \"bottom_left\", \"bottom\", \"bottom_right\" Parameters: Name Type Description Default origin str transform origin to use required Exceptions: Type Description InvalidParamError transform origin does not exist Source code in prettyqt/quick/quickitem.py def set_transform_origin ( self , origin : str ): \"\"\"Set the origin point around which scale and rotation transform. The default is \"center\". Allowed values are \"top_left\", \"top\", \"top_right\", \"left\", \"center\", \"right\", \"bottom_left\", \"bottom\", \"bottom_right\" Args: origin: transform origin to use Raises: InvalidParamError: transform origin does not exist \"\"\" if origin not in TRANSFORM_ORIGIN : raise InvalidParamError ( origin , TRANSFORM_ORIGIN ) self . setTransformOrigin ( TRANSFORM_ORIGIN [ origin ]) quickpainteditem QuickPaintedItem get_render_target ( self ) Return the render target. Possible values: \"image\", \"framebuffer_object\", \"inverted_y_framebuffer_object\" Returns: Type Description str render target Source code in prettyqt/quick/quickpainteditem.py def get_render_target ( self ) -> str : \"\"\"Return the render target. Possible values: \"image\", \"framebuffer_object\", \"inverted_y_framebuffer_object\" Returns: render target \"\"\" return RENDER_TARGET . inverse [ self . renderTarget ()] set_render_target ( self , target ) Set the render target. Allowed values are \"image\", \"framebuffer_object\", \"inverted_y_framebuffer_object\" Parameters: Name Type Description Default target str render target to use required Exceptions: Type Description InvalidParamError render target does not exist Source code in prettyqt/quick/quickpainteditem.py def set_render_target ( self , target : str ): \"\"\"Set the render target. Allowed values are \"image\", \"framebuffer_object\", \"inverted_y_framebuffer_object\" Args: target: render target to use Raises: InvalidParamError: render target does not exist \"\"\" if target not in RENDER_TARGET : raise InvalidParamError ( target , RENDER_TARGET ) self . setRenderTarget ( RENDER_TARGET [ target ]) quickwindow QuickWindow get_text_render_type () staticmethod Return the render type of text-like elements in Qt Quick. Possible values: \"qt_text\", \"native_text\" Returns: Type Description str text render type Source code in prettyqt/quick/quickwindow.py @staticmethod def get_text_render_type () -> str : \"\"\"Return the render type of text-like elements in Qt Quick. Possible values: \"qt_text\", \"native_text\" Returns: text render type \"\"\" return TEXT_RENDER_TYPE . inverse [ QuickWindow . textRenderType ()] set_text_render_type ( typ ) staticmethod Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Allowed values are \"qt_text\", \"native_text\" Parameters: Name Type Description Default typ str text render type to use required Exceptions: Type Description InvalidParamError text render type does not exist Source code in prettyqt/quick/quickwindow.py @staticmethod def set_text_render_type ( typ : str ): \"\"\"Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Allowed values are \"qt_text\", \"native_text\" Args: typ: text render type to use Raises: InvalidParamError: text render type does not exist \"\"\" if typ not in TEXT_RENDER_TYPE : raise InvalidParamError ( typ , TEXT_RENDER_TYPE ) QuickWindow . setTextRenderType ( TEXT_RENDER_TYPE [ typ ])","title":"quick"},{"location":"api/quick.html#quick-module","text":"","title":"quick module"},{"location":"api/quick.html#prettyqt.quick","text":"quick module. contains QtQuick-based classes","title":"prettyqt.quick"},{"location":"api/quick.html#prettyqt.quick.quickitem","text":"","title":"quickitem"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItem","text":"","title":"QuickItem"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItem.get_transform_origin","text":"Return the render type of text-like elements in Qt Quick. Possible values: \"top_left\", \"top\", \"top_right\", \"left\", \"center\", \"right\", \"bottom_left\", \"bottom\", \"bottom_right\" Returns: Type Description str transform origin Source code in prettyqt/quick/quickitem.py def get_transform_origin ( self ) -> str : \"\"\"Return the render type of text-like elements in Qt Quick. Possible values: \"top_left\", \"top\", \"top_right\", \"left\", \"center\", \"right\", \"bottom_left\", \"bottom\", \"bottom_right\" Returns: transform origin \"\"\" return TRANSFORM_ORIGIN . inverse [ self . transformOrigin ()]","title":"get_transform_origin()"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItem.set_transform_origin","text":"Set the origin point around which scale and rotation transform. The default is \"center\". Allowed values are \"top_left\", \"top\", \"top_right\", \"left\", \"center\", \"right\", \"bottom_left\", \"bottom\", \"bottom_right\" Parameters: Name Type Description Default origin str transform origin to use required Exceptions: Type Description InvalidParamError transform origin does not exist Source code in prettyqt/quick/quickitem.py def set_transform_origin ( self , origin : str ): \"\"\"Set the origin point around which scale and rotation transform. The default is \"center\". Allowed values are \"top_left\", \"top\", \"top_right\", \"left\", \"center\", \"right\", \"bottom_left\", \"bottom\", \"bottom_right\" Args: origin: transform origin to use Raises: InvalidParamError: transform origin does not exist \"\"\" if origin not in TRANSFORM_ORIGIN : raise InvalidParamError ( origin , TRANSFORM_ORIGIN ) self . setTransformOrigin ( TRANSFORM_ORIGIN [ origin ])","title":"set_transform_origin()"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem","text":"","title":"quickpainteditem"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem","text":"","title":"QuickPaintedItem"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.get_render_target","text":"Return the render target. Possible values: \"image\", \"framebuffer_object\", \"inverted_y_framebuffer_object\" Returns: Type Description str render target Source code in prettyqt/quick/quickpainteditem.py def get_render_target ( self ) -> str : \"\"\"Return the render target. Possible values: \"image\", \"framebuffer_object\", \"inverted_y_framebuffer_object\" Returns: render target \"\"\" return RENDER_TARGET . inverse [ self . renderTarget ()]","title":"get_render_target()"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.set_render_target","text":"Set the render target. Allowed values are \"image\", \"framebuffer_object\", \"inverted_y_framebuffer_object\" Parameters: Name Type Description Default target str render target to use required Exceptions: Type Description InvalidParamError render target does not exist Source code in prettyqt/quick/quickpainteditem.py def set_render_target ( self , target : str ): \"\"\"Set the render target. Allowed values are \"image\", \"framebuffer_object\", \"inverted_y_framebuffer_object\" Args: target: render target to use Raises: InvalidParamError: render target does not exist \"\"\" if target not in RENDER_TARGET : raise InvalidParamError ( target , RENDER_TARGET ) self . setRenderTarget ( RENDER_TARGET [ target ])","title":"set_render_target()"},{"location":"api/quick.html#prettyqt.quick.quickwindow","text":"","title":"quickwindow"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow","text":"","title":"QuickWindow"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow.get_text_render_type","text":"Return the render type of text-like elements in Qt Quick. Possible values: \"qt_text\", \"native_text\" Returns: Type Description str text render type Source code in prettyqt/quick/quickwindow.py @staticmethod def get_text_render_type () -> str : \"\"\"Return the render type of text-like elements in Qt Quick. Possible values: \"qt_text\", \"native_text\" Returns: text render type \"\"\" return TEXT_RENDER_TYPE . inverse [ QuickWindow . textRenderType ()]","title":"get_text_render_type()"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow.set_text_render_type","text":"Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Allowed values are \"qt_text\", \"native_text\" Parameters: Name Type Description Default typ str text render type to use required Exceptions: Type Description InvalidParamError text render type does not exist Source code in prettyqt/quick/quickwindow.py @staticmethod def set_text_render_type ( typ : str ): \"\"\"Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Allowed values are \"qt_text\", \"native_text\" Args: typ: text render type to use Raises: InvalidParamError: text render type does not exist \"\"\" if typ not in TEXT_RENDER_TYPE : raise InvalidParamError ( typ , TEXT_RENDER_TYPE ) QuickWindow . setTextRenderType ( TEXT_RENDER_TYPE [ typ ])","title":"set_text_render_type()"},{"location":"api/scintilla.html","text":"scintilla module Module containing QSciScintilla-related classes. sciscintilla SciScintilla scroll_to_bottom ( self ) Scroll to the bottom of the scroll area. Source code in prettyqt/scintilla/sciscintilla.py def scroll_to_bottom ( self ): self . ensureLineVisible ( self . lines ())","title":"scintilla"},{"location":"api/scintilla.html#scintilla-module","text":"","title":"scintilla module"},{"location":"api/scintilla.html#prettyqt.scintilla","text":"Module containing QSciScintilla-related classes.","title":"prettyqt.scintilla"},{"location":"api/scintilla.html#prettyqt.scintilla.sciscintilla","text":"","title":"sciscintilla"},{"location":"api/scintilla.html#prettyqt.scintilla.sciscintilla.SciScintilla","text":"","title":"SciScintilla"},{"location":"api/scintilla.html#prettyqt.scintilla.sciscintilla.SciScintilla.scroll_to_bottom","text":"Scroll to the bottom of the scroll area. Source code in prettyqt/scintilla/sciscintilla.py def scroll_to_bottom ( self ): self . ensureLineVisible ( self . lines ())","title":"scroll_to_bottom()"},{"location":"api/svg.html","text":"svg module svg module. contains QtSvg-based classes","title":"svg"},{"location":"api/svg.html#svg-module","text":"","title":"svg module"},{"location":"api/svg.html#prettyqt.svg","text":"svg module. contains QtSvg-based classes","title":"prettyqt.svg"},{"location":"api/syntaxhighlighters.html","text":"syntaxhighlighters module syntaxhighlighters module. contains some custom syntax highlighers highlightrule HighlightRule dataclass HighlightRule(regex: Union[str, List[str]] = '', color: str = 'black', italic: bool = False, bold: bool = False, minimal: bool = False, font_size: Union[float, NoneType] = None, nth: int = 0, fmt: prettyqt.gui.textcharformat.TextCharFormat = TextCharFormat(2)) __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format () jsonhighlighter JsonHighlighter highlightBlock ( self , text ) Highlight a block of code using the rules outlined in the Constructor. Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT ) markdownhighlighter Syntax highlighter for Markdown markup language. MarkdownHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE ) pygmentshighlighter PygmentsHighlighter Syntax highlighter that uses Pygments for parsing. highlightBlock ( self , string ) Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack set_style ( self , style ) Sets the style to the specified Pygments style. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style ( self , style : Union [ str , Style ]): \"\"\"Sets the style to the specified Pygments style.\"\"\" if isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches () set_style_sheet ( self , stylesheet ) Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style_sheet ( self , stylesheet : str ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches () get_tokens_unprocessed ( self , text , stack = ( 'root' ,)) Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def get_tokens_unprocessed ( self , text : str , stack = ( \"root\" ,)): \"\"\"Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while 1 : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if type ( action ) is _TokenType : yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , \"wrong state def: %r \" % new_state statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" pos += 1 statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos , Text , \" \\n \" continue yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack ) qstring_length ( text ) Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def qstring_length ( text : str ) -> int : \"\"\"Tries to compute what the length of an utf16-encoded QString would be.\"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length pythonhighlighter Syntax highlighter for the programming language Python. PythonHighlighter Syntax highlighter for the Python language. highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE ) match_multiline ( self , text , delimiter , in_state , style ) Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def match_multiline ( self , text , delimiter , in_state , style ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : start = delimiter . indexIn ( text ) # Move past this match add = delimiter . matchedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter end = delimiter . indexIn ( text , start + add ) # Ending delimiter on this line? if end >= add : length = end - start + add + delimiter . matchedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . indexIn ( text , start + length ) # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state regexmatchhighlighter RegexMatchHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i ) xmlhighlighter Based on http://www.yasinuludag.com/blog/?p=49 . XmlHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . indexIn ( text ) while start_index >= 0 : end_index = VALUE_END_EXPRESSION . indexIn ( text , start_index ) if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : matched_len = VALUE_END_EXPRESSION . matchedLength () comment_len = end_index - start_index + matched_len self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . indexIn ( text , start_index + comment_len ) yamlhighlighter YamlHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . indexIn ( text ) if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"syntaxhighlighters"},{"location":"api/syntaxhighlighters.html#syntaxhighlighters-module","text":"","title":"syntaxhighlighters module"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters","text":"syntaxhighlighters module. contains some custom syntax highlighers","title":"prettyqt.syntaxhighlighters"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule","text":"","title":"highlightrule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule","text":"HighlightRule(regex: Union[str, List[str]] = '', color: str = 'black', italic: bool = False, bold: bool = False, minimal: bool = False, font_size: Union[float, NoneType] = None, nth: int = 0, fmt: prettyqt.gui.textcharformat.TextCharFormat = TextCharFormat(2))","title":"HighlightRule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format ()","title":"__init_subclass__()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter","text":"","title":"jsonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter","text":"","title":"JsonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter.highlightBlock","text":"Highlight a block of code using the rules outlined in the Constructor. Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter","text":"Syntax highlighter for Markdown markup language.","title":"markdownhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter","text":"","title":"MarkdownHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter","text":"","title":"pygmentshighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter","text":"Syntax highlighter that uses Pygments for parsing.","title":"PygmentsHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.highlightBlock","text":"Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style","text":"Sets the style to the specified Pygments style. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style ( self , style : Union [ str , Style ]): \"\"\"Sets the style to the specified Pygments style.\"\"\" if isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches ()","title":"set_style()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style_sheet","text":"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style_sheet ( self , stylesheet : str ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches ()","title":"set_style_sheet()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.get_tokens_unprocessed","text":"Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def get_tokens_unprocessed ( self , text : str , stack = ( \"root\" ,)): \"\"\"Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while 1 : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if type ( action ) is _TokenType : yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , \"wrong state def: %r \" % new_state statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" pos += 1 statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos , Text , \" \\n \" continue yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack )","title":"get_tokens_unprocessed()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.qstring_length","text":"Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def qstring_length ( text : str ) -> int : \"\"\"Tries to compute what the length of an utf16-encoded QString would be.\"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length","title":"qstring_length()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter","text":"Syntax highlighter for the programming language Python.","title":"pythonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter","text":"Syntax highlighter for the Python language.","title":"PythonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.match_multiline","text":"Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def match_multiline ( self , text , delimiter , in_state , style ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : start = delimiter . indexIn ( text ) # Move past this match add = delimiter . matchedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter end = delimiter . indexIn ( text , start + add ) # Ending delimiter on this line? if end >= add : length = end - start + add + delimiter . matchedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . indexIn ( text , start + length ) # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state","title":"match_multiline()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter","text":"","title":"regexmatchhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter","text":"","title":"RegexMatchHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter","text":"Based on http://www.yasinuludag.com/blog/?p=49 .","title":"xmlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter","text":"","title":"XmlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . indexIn ( text ) while start_index >= 0 : end_index = VALUE_END_EXPRESSION . indexIn ( text , start_index ) if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : matched_len = VALUE_END_EXPRESSION . matchedLength () comment_len = end_index - start_index + matched_len self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . indexIn ( text , start_index + comment_len )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter","text":"","title":"yamlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter","text":"","title":"YamlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . indexIn ( text ) if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"highlightBlock()"},{"location":"api/texttospeech.html","text":"qml module Qml module. Contains QtQml-based classes jsvalue JSValue from_object ( obj , jsengine ) classmethod Convert any python object into a QJSValue (must happen in GUI thread). Source code in prettyqt/qml/jsvalue.py @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls () qmlengine QmlEngine get_object_ownership ( self , obj ) Return object ownership. possible values: \"cpp\", \"javascript\" Returns: Type Description str object ownership Source code in prettyqt/qml/qmlengine.py def get_object_ownership ( self , obj : QtCore . QObject ) -> str : \"\"\"Return object ownership. possible values: \"cpp\", \"javascript\" Returns: object ownership \"\"\" return OBJECT_OWNERSHIPS . inverse [ self . objectOwnership ( obj )] set_object_ownership ( self , obj , mode ) Set the object ownership. valid values: \"cpp\", \"javascript\" Parameters: Name Type Description Default mode str object ownership to use required Exceptions: Type Description InvalidParamError invalid object ownership Source code in prettyqt/qml/qmlengine.py def set_object_ownership ( self , obj : QtCore . QObject , mode : str ): \"\"\"Set the object ownership. valid values: \"cpp\", \"javascript\" Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIPS : raise InvalidParamError ( mode , OBJECT_OWNERSHIPS ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIPS [ mode ])","title":"texttospeech"},{"location":"api/texttospeech.html#qml-module","text":"","title":"qml module"},{"location":"api/texttospeech.html#prettyqt.qml","text":"Qml module. Contains QtQml-based classes","title":"prettyqt.qml"},{"location":"api/texttospeech.html#prettyqt.qml.jsvalue","text":"","title":"jsvalue"},{"location":"api/texttospeech.html#prettyqt.qml.jsvalue.JSValue","text":"","title":"JSValue"},{"location":"api/texttospeech.html#prettyqt.qml.jsvalue.JSValue.from_object","text":"Convert any python object into a QJSValue (must happen in GUI thread). Source code in prettyqt/qml/jsvalue.py @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls ()","title":"from_object()"},{"location":"api/texttospeech.html#prettyqt.qml.qmlengine","text":"","title":"qmlengine"},{"location":"api/texttospeech.html#prettyqt.qml.qmlengine.QmlEngine","text":"","title":"QmlEngine"},{"location":"api/texttospeech.html#prettyqt.qml.qmlengine.QmlEngine.get_object_ownership","text":"Return object ownership. possible values: \"cpp\", \"javascript\" Returns: Type Description str object ownership Source code in prettyqt/qml/qmlengine.py def get_object_ownership ( self , obj : QtCore . QObject ) -> str : \"\"\"Return object ownership. possible values: \"cpp\", \"javascript\" Returns: object ownership \"\"\" return OBJECT_OWNERSHIPS . inverse [ self . objectOwnership ( obj )]","title":"get_object_ownership()"},{"location":"api/texttospeech.html#prettyqt.qml.qmlengine.QmlEngine.set_object_ownership","text":"Set the object ownership. valid values: \"cpp\", \"javascript\" Parameters: Name Type Description Default mode str object ownership to use required Exceptions: Type Description InvalidParamError invalid object ownership Source code in prettyqt/qml/qmlengine.py def set_object_ownership ( self , obj : QtCore . QObject , mode : str ): \"\"\"Set the object ownership. valid values: \"cpp\", \"javascript\" Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIPS : raise InvalidParamError ( mode , OBJECT_OWNERSHIPS ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIPS [ mode ])","title":"set_object_ownership()"},{"location":"api/webenginecore.html","text":"webenginecore module Webenginewidgets module. contains QtWebEngineCore-based classes webenginehttprequest WebEngineHttpRequest get_method ( self ) Get the method this WebEngine request is using. Possible values: \"post\", \"get\" Returns: Type Description str method Source code in prettyqt/webenginecore/webenginehttprequest.py def get_method ( self ) -> str : \"\"\"Get the method this WebEngine request is using. Possible values: \"post\", \"get\" Returns: method \"\"\" return METHODS . inverse [ self . method ()] set_method ( self , method ) Set method this WebEngine request is using. Valid values for method: \"post\", \"get\" Parameters: Name Type Description Default method str method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/webenginecore/webenginehttprequest.py def set_method ( self , method : str ): \"\"\"Set method this WebEngine request is using. Valid values for method: \"post\", \"get\" Args: method: method Raises: InvalidParamError: method does not exist \"\"\" if method not in METHODS : raise InvalidParamError ( method , METHODS ) self . setMethod ( METHODS [ method ]) webengineurlscheme WebEngineUrlScheme get_syntax ( self ) Return syntax. Returns: Type Description SyntaxStr syntax Source code in prettyqt/webenginecore/webengineurlscheme.py def get_syntax ( self ) -> SyntaxStr : \"\"\"Return syntax. Returns: syntax \"\"\" return SYNTAX . inverse [ self . syntax ()] set_syntax ( self , syntax ) Set syntax. Parameters: Name Type Description Default syntax SyntaxStr syntax to use required Exceptions: Type Description InvalidParamError syntax does not exist Source code in prettyqt/webenginecore/webengineurlscheme.py def set_syntax ( self , syntax : SyntaxStr ): \"\"\"Set syntax. Args: syntax: syntax to use Raises: InvalidParamError: syntax does not exist \"\"\" if syntax not in SYNTAX : raise InvalidParamError ( syntax , SYNTAX ) self . setSyntax ( SYNTAX [ syntax ])","title":"webenginecore"},{"location":"api/webenginecore.html#webenginecore-module","text":"","title":"webenginecore module"},{"location":"api/webenginecore.html#prettyqt.webenginecore","text":"Webenginewidgets module. contains QtWebEngineCore-based classes","title":"prettyqt.webenginecore"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest","text":"","title":"webenginehttprequest"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest","text":"","title":"WebEngineHttpRequest"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.get_method","text":"Get the method this WebEngine request is using. Possible values: \"post\", \"get\" Returns: Type Description str method Source code in prettyqt/webenginecore/webenginehttprequest.py def get_method ( self ) -> str : \"\"\"Get the method this WebEngine request is using. Possible values: \"post\", \"get\" Returns: method \"\"\" return METHODS . inverse [ self . method ()]","title":"get_method()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.set_method","text":"Set method this WebEngine request is using. Valid values for method: \"post\", \"get\" Parameters: Name Type Description Default method str method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/webenginecore/webenginehttprequest.py def set_method ( self , method : str ): \"\"\"Set method this WebEngine request is using. Valid values for method: \"post\", \"get\" Args: method: method Raises: InvalidParamError: method does not exist \"\"\" if method not in METHODS : raise InvalidParamError ( method , METHODS ) self . setMethod ( METHODS [ method ])","title":"set_method()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme","text":"","title":"webengineurlscheme"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme","text":"","title":"WebEngineUrlScheme"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.get_syntax","text":"Return syntax. Returns: Type Description SyntaxStr syntax Source code in prettyqt/webenginecore/webengineurlscheme.py def get_syntax ( self ) -> SyntaxStr : \"\"\"Return syntax. Returns: syntax \"\"\" return SYNTAX . inverse [ self . syntax ()]","title":"get_syntax()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.set_syntax","text":"Set syntax. Parameters: Name Type Description Default syntax SyntaxStr syntax to use required Exceptions: Type Description InvalidParamError syntax does not exist Source code in prettyqt/webenginecore/webengineurlscheme.py def set_syntax ( self , syntax : SyntaxStr ): \"\"\"Set syntax. Args: syntax: syntax to use Raises: InvalidParamError: syntax does not exist \"\"\" if syntax not in SYNTAX : raise InvalidParamError ( syntax , SYNTAX ) self . setSyntax ( SYNTAX [ syntax ])","title":"set_syntax()"},{"location":"api/webenginewidgets.html","text":"webenginewidgets module Webenginewidgets module. contains QtWebEngineWidgets-based classes webenginedownloaditem WebEngineDownloadItem get_save_page_format ( self ) Return current save page format. Possible values are \"unknown\", \"single_html\", \"complete_html\", \"mime_html\" Returns: Type Description str Save page format Source code in prettyqt/webenginewidgets/webenginedownloaditem.py def get_save_page_format ( self ) -> str : \"\"\"Return current save page format. Possible values are \"unknown\", \"single_html\", \"complete_html\", \"mime_html\" Returns: Save page format \"\"\" return SAVE_PAGE_FORMATS . inverse [ self . item . savePageFormat ()] set_save_page_format ( self , fmt ) Set the save page format. Allowed values are \"unknown\", \"single_html\", \"complete_html\", \"mime_html\" Parameters: Name Type Description Default fmt str save page format for the layout required Exceptions: Type Description InvalidParamError save page format does not exist Source code in prettyqt/webenginewidgets/webenginedownloaditem.py def set_save_page_format ( self , fmt : str ): \"\"\"Set the save page format. Allowed values are \"unknown\", \"single_html\", \"complete_html\", \"mime_html\" Args: fmt: save page format for the layout Raises: InvalidParamError: save page format does not exist \"\"\" if fmt not in SAVE_PAGE_FORMATS : raise InvalidParamError ( fmt , SAVE_PAGE_FORMATS ) self . item . setSavePageFormat ( SAVE_PAGE_FORMATS [ fmt ]) webenginepage WebEnginePage A web engine page holds the HTML document contents, link history + actions. find_text ( self , string , backward = False , case_sensitive = False , callback = None ) Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable[[bool], NoneType] result callback None Source code in prettyqt/webenginewidgets/webenginepage.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = self . FindFlag () if case_sensitive : flag |= self . FindCaseSensitively if backward : flag |= self . FindBackward self . findText ( string , flag , callback ) get_lifecycle_state ( self ) Get the current lifecycle state. Returns: Type Description Literal['active', 'frozen', 'discarded'] lifecycle state Source code in prettyqt/webenginewidgets/webenginepage.py def get_lifecycle_state ( self ) -> LifecycleStateStr : \"\"\"Get the current lifecycle state. Returns: lifecycle state \"\"\" return LIFECYCLE_STATE . inverse [ self . lifecycleState ()] load_url ( self , url ) Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webenginepage.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) set_lifecycle_state ( self , state ) Set lifecycle state. Parameters: Name Type Description Default state Literal['active', 'frozen', 'discarded'] lifecycle state required Exceptions: Type Description InvalidParamError lifecycle state does not exist Source code in prettyqt/webenginewidgets/webenginepage.py def set_lifecycle_state ( self , state : LifecycleStateStr ): \"\"\"Set lifecycle state. Args: state: lifecycle state Raises: InvalidParamError: lifecycle state does not exist \"\"\" if state not in LIFECYCLE_STATE : raise InvalidParamError ( state , LIFECYCLE_STATE ) self . setLifecycleState ( LIFECYCLE_STATE [ state ]) set_url ( self , url ) Set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webenginepage.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom ) Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webenginepage.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom ) webengineprofile WebEngineProfile get_http_cache_type ( self ) Return current http cache type. Returns: Type Description Literal['none', 'disk', 'memory'] Http cache type Source code in prettyqt/webenginewidgets/webengineprofile.py def get_http_cache_type ( self ) -> HttpCacheTypeStr : \"\"\"Return current http cache type. Returns: Http cache type \"\"\" return HTTP_CACHE_TYPE . inverse [ self . httpCacheType ()] get_persistent_cookie_policy ( self ) Return current persistent cookie policy. Returns: Type Description Literal['none', 'allow', 'force'] Persistent cookie policy Source code in prettyqt/webenginewidgets/webengineprofile.py def get_persistent_cookie_policy ( self ) -> PersistentCookiePolicyStr : \"\"\"Return current persistent cookie policy. Returns: Persistent cookie policy \"\"\" return PERSISTENT_COOKIE_POLICY . inverse [ self . persistentCookiesPolicy ()] set_http_cache_type ( self , typ ) Set the http cache type. Parameters: Name Type Description Default typ Literal['none', 'disk', 'memory'] http cache type required Exceptions: Type Description InvalidParamError Cache type does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_http_cache_type ( self , typ : HttpCacheTypeStr ): \"\"\"Set the http cache type. Args: typ: http cache type Raises: InvalidParamError: Cache type does not exist \"\"\" if typ not in HTTP_CACHE_TYPE : raise InvalidParamError ( typ , HTTP_CACHE_TYPE ) self . setHttpCacheType ( HTTP_CACHE_TYPE [ typ ]) set_persistent_cookie_policy ( self , policy ) Set the persistent cookie policy. Parameters: Name Type Description Default policy Literal['none', 'allow', 'force'] persistent cookie policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_persistent_cookie_policy ( self , policy : PersistentCookiePolicyStr ): \"\"\"Set the persistent cookie policy. Args: policy: persistent cookie policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in PERSISTENT_COOKIE_POLICY : raise InvalidParamError ( policy , PERSISTENT_COOKIE_POLICY ) self . setPersistentCookiesPolicy ( PERSISTENT_COOKIE_POLICY [ policy ]) webenginescript WebEngineScript get_injection_point ( self ) Return injection point. Returns: Type Description Literal['document_creation', 'document_ready', 'deferred'] injection point Source code in prettyqt/webenginewidgets/webenginescript.py def get_injection_point ( self ) -> InjectionPointStr : \"\"\"Return injection point. Returns: injection point \"\"\" return INJECTION_POINT . inverse [ self . injectionPoint ()] set_injection_point ( self , point ) Set injection point. Parameters: Name Type Description Default point Literal['document_creation', 'document_ready', 'deferred'] injection point to use required Exceptions: Type Description InvalidParamError injection point does not exist Source code in prettyqt/webenginewidgets/webenginescript.py def set_injection_point ( self , point : InjectionPointStr ): \"\"\"Set injection point. Args: point: injection point to use Raises: InvalidParamError: injection point does not exist \"\"\" if point not in INJECTION_POINT : raise InvalidParamError ( point , INJECTION_POINT ) self . setInjectionPoint ( INJECTION_POINT [ point ]) webenginesettings WebEngineSettings get_font_family ( self , family ) Return the actual font family for the specified generic font family. Parameters: Name Type Description Default family Literal['standard', 'fixed', 'serif', 'sans_serif', 'cursive', 'fantasy', 'pictograph'] generic font family required Returns: Type Description str Font family Source code in prettyqt/webenginewidgets/webenginesettings.py def get_font_family ( self , family : FontFamilyStr ) -> str : \"\"\"Return the actual font family for the specified generic font family. Args: family: generic font family Returns: Font family \"\"\" return self . item . fontFamily ( FONT_FAMILY [ family ]) get_font_size ( self , typ ) Return the default font size for type in pixels. Parameters: Name Type Description Default typ Literal['minimum', 'minimum_logical', 'default', 'default_fixed'] font size type required Returns: Type Description int Font size Source code in prettyqt/webenginewidgets/webenginesettings.py def get_font_size ( self , typ : FontSizeStr ) -> int : \"\"\"Return the default font size for type in pixels. Args: typ: font size type Returns: Font size \"\"\" return self . item . fontSize ( FONT_SIZE [ typ ]) get_unknown_url_scheme_policy ( self ) Return current unknown url scheme policy. Returns: Type Description Literal['disallow', 'allow_from_user_interaction', 'allow_all'] Unknown url scheme policy Source code in prettyqt/webenginewidgets/webenginesettings.py def get_unknown_url_scheme_policy ( self ) -> UnknownUrlSchemePolicyStr : \"\"\"Return current unknown url scheme policy. Returns: Unknown url scheme policy \"\"\" return UNKNOWN_URL_SCHEME_POLICY . inverse [ self . item . unknownUrlSchemePolicy ()] set_font_family ( self , which , family ) Set the actual font family to family for the specified generic family, which. Parameters: Name Type Description Default which Literal['standard', 'fixed', 'serif', 'sans_serif', 'cursive', 'fantasy', 'pictograph'] family to set required family str generic family required Exceptions: Type Description InvalidParamError Font family does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_font_family ( self , which : FontFamilyStr , family : str ): \"\"\"Set the actual font family to family for the specified generic family, which. Args: which: family to set family: generic family Raises: InvalidParamError: Font family does not exist \"\"\" if which not in FONT_FAMILY : raise InvalidParamError ( which , FONT_FAMILY ) self . item . setFontFamily ( FONT_FAMILY [ which ], family ) set_font_size ( self , typ , size ) Set the font size for type to size in pixels. Parameters: Name Type Description Default typ Literal['minimum', 'minimum_logical', 'default', 'default_fixed'] font size type required size int size in pixels required Exceptions: Type Description InvalidParamError Font size does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_font_size ( self , typ : FontSizeStr , size : int ): \"\"\"Set the font size for type to size in pixels. Args: typ: font size type size: size in pixels Raises: InvalidParamError: Font size does not exist \"\"\" if typ not in FONT_SIZE : raise InvalidParamError ( typ , FONT_SIZE ) self . item . setFontSize ( FONT_SIZE [ typ ], size ) set_unknown_url_scheme_policy ( self , policy ) Set the unknown url scheme policy. Parameters: Name Type Description Default policy Literal['disallow', 'allow_from_user_interaction', 'allow_all'] unknown url scheme policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_unknown_url_scheme_policy ( self , policy : UnknownUrlSchemePolicyStr ): \"\"\"Set the unknown url scheme policy. Args: policy: unknown url scheme policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in UNKNOWN_URL_SCHEME_POLICY : raise InvalidParamError ( policy , UNKNOWN_URL_SCHEME_POLICY ) self . item . setUnknownUrlSchemePolicy ( UNKNOWN_URL_SCHEME_POLICY [ policy ]) webengineview WebEngineView find_text ( self , string , backward = False , case_sensitive = False , callback = None ) Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable[[bool], NoneType] result callback None Source code in prettyqt/webenginewidgets/webengineview.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlag () if case_sensitive : flag |= QtWebEngineWidgets . QWebEnginePage . FindCaseSensitively if backward : flag |= QtWebEngineWidgets . QWebEnginePage . FindBackward self . findText ( string , flag , callback ) load_url ( self , url ) Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webengineview.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) set_url ( self , url ) Set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webengineview.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom ) Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"webenginewidgets"},{"location":"api/webenginewidgets.html#webenginewidgets-module","text":"","title":"webenginewidgets module"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets","text":"Webenginewidgets module. contains QtWebEngineWidgets-based classes","title":"prettyqt.webenginewidgets"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginedownloaditem","text":"","title":"webenginedownloaditem"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginedownloaditem.WebEngineDownloadItem","text":"","title":"WebEngineDownloadItem"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginedownloaditem.WebEngineDownloadItem.get_save_page_format","text":"Return current save page format. Possible values are \"unknown\", \"single_html\", \"complete_html\", \"mime_html\" Returns: Type Description str Save page format Source code in prettyqt/webenginewidgets/webenginedownloaditem.py def get_save_page_format ( self ) -> str : \"\"\"Return current save page format. Possible values are \"unknown\", \"single_html\", \"complete_html\", \"mime_html\" Returns: Save page format \"\"\" return SAVE_PAGE_FORMATS . inverse [ self . item . savePageFormat ()]","title":"get_save_page_format()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginedownloaditem.WebEngineDownloadItem.set_save_page_format","text":"Set the save page format. Allowed values are \"unknown\", \"single_html\", \"complete_html\", \"mime_html\" Parameters: Name Type Description Default fmt str save page format for the layout required Exceptions: Type Description InvalidParamError save page format does not exist Source code in prettyqt/webenginewidgets/webenginedownloaditem.py def set_save_page_format ( self , fmt : str ): \"\"\"Set the save page format. Allowed values are \"unknown\", \"single_html\", \"complete_html\", \"mime_html\" Args: fmt: save page format for the layout Raises: InvalidParamError: save page format does not exist \"\"\" if fmt not in SAVE_PAGE_FORMATS : raise InvalidParamError ( fmt , SAVE_PAGE_FORMATS ) self . item . setSavePageFormat ( SAVE_PAGE_FORMATS [ fmt ])","title":"set_save_page_format()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage","text":"","title":"webenginepage"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage","text":"A web engine page holds the HTML document contents, link history + actions.","title":"WebEnginePage"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.find_text","text":"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable[[bool], NoneType] result callback None Source code in prettyqt/webenginewidgets/webenginepage.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = self . FindFlag () if case_sensitive : flag |= self . FindCaseSensitively if backward : flag |= self . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.get_lifecycle_state","text":"Get the current lifecycle state. Returns: Type Description Literal['active', 'frozen', 'discarded'] lifecycle state Source code in prettyqt/webenginewidgets/webenginepage.py def get_lifecycle_state ( self ) -> LifecycleStateStr : \"\"\"Get the current lifecycle state. Returns: lifecycle state \"\"\" return LIFECYCLE_STATE . inverse [ self . lifecycleState ()]","title":"get_lifecycle_state()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.load_url","text":"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webenginepage.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_lifecycle_state","text":"Set lifecycle state. Parameters: Name Type Description Default state Literal['active', 'frozen', 'discarded'] lifecycle state required Exceptions: Type Description InvalidParamError lifecycle state does not exist Source code in prettyqt/webenginewidgets/webenginepage.py def set_lifecycle_state ( self , state : LifecycleStateStr ): \"\"\"Set lifecycle state. Args: state: lifecycle state Raises: InvalidParamError: lifecycle state does not exist \"\"\" if state not in LIFECYCLE_STATE : raise InvalidParamError ( state , LIFECYCLE_STATE ) self . setLifecycleState ( LIFECYCLE_STATE [ state ])","title":"set_lifecycle_state()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_url","text":"Set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webenginepage.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_zoom","text":"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webenginepage.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile","text":"","title":"webengineprofile"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile","text":"","title":"WebEngineProfile"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.get_http_cache_type","text":"Return current http cache type. Returns: Type Description Literal['none', 'disk', 'memory'] Http cache type Source code in prettyqt/webenginewidgets/webengineprofile.py def get_http_cache_type ( self ) -> HttpCacheTypeStr : \"\"\"Return current http cache type. Returns: Http cache type \"\"\" return HTTP_CACHE_TYPE . inverse [ self . httpCacheType ()]","title":"get_http_cache_type()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.get_persistent_cookie_policy","text":"Return current persistent cookie policy. Returns: Type Description Literal['none', 'allow', 'force'] Persistent cookie policy Source code in prettyqt/webenginewidgets/webengineprofile.py def get_persistent_cookie_policy ( self ) -> PersistentCookiePolicyStr : \"\"\"Return current persistent cookie policy. Returns: Persistent cookie policy \"\"\" return PERSISTENT_COOKIE_POLICY . inverse [ self . persistentCookiesPolicy ()]","title":"get_persistent_cookie_policy()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.set_http_cache_type","text":"Set the http cache type. Parameters: Name Type Description Default typ Literal['none', 'disk', 'memory'] http cache type required Exceptions: Type Description InvalidParamError Cache type does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_http_cache_type ( self , typ : HttpCacheTypeStr ): \"\"\"Set the http cache type. Args: typ: http cache type Raises: InvalidParamError: Cache type does not exist \"\"\" if typ not in HTTP_CACHE_TYPE : raise InvalidParamError ( typ , HTTP_CACHE_TYPE ) self . setHttpCacheType ( HTTP_CACHE_TYPE [ typ ])","title":"set_http_cache_type()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.set_persistent_cookie_policy","text":"Set the persistent cookie policy. Parameters: Name Type Description Default policy Literal['none', 'allow', 'force'] persistent cookie policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_persistent_cookie_policy ( self , policy : PersistentCookiePolicyStr ): \"\"\"Set the persistent cookie policy. Args: policy: persistent cookie policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in PERSISTENT_COOKIE_POLICY : raise InvalidParamError ( policy , PERSISTENT_COOKIE_POLICY ) self . setPersistentCookiesPolicy ( PERSISTENT_COOKIE_POLICY [ policy ])","title":"set_persistent_cookie_policy()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginescript","text":"","title":"webenginescript"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginescript.WebEngineScript","text":"","title":"WebEngineScript"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginescript.WebEngineScript.get_injection_point","text":"Return injection point. Returns: Type Description Literal['document_creation', 'document_ready', 'deferred'] injection point Source code in prettyqt/webenginewidgets/webenginescript.py def get_injection_point ( self ) -> InjectionPointStr : \"\"\"Return injection point. Returns: injection point \"\"\" return INJECTION_POINT . inverse [ self . injectionPoint ()]","title":"get_injection_point()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginescript.WebEngineScript.set_injection_point","text":"Set injection point. Parameters: Name Type Description Default point Literal['document_creation', 'document_ready', 'deferred'] injection point to use required Exceptions: Type Description InvalidParamError injection point does not exist Source code in prettyqt/webenginewidgets/webenginescript.py def set_injection_point ( self , point : InjectionPointStr ): \"\"\"Set injection point. Args: point: injection point to use Raises: InvalidParamError: injection point does not exist \"\"\" if point not in INJECTION_POINT : raise InvalidParamError ( point , INJECTION_POINT ) self . setInjectionPoint ( INJECTION_POINT [ point ])","title":"set_injection_point()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings","text":"","title":"webenginesettings"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings","text":"","title":"WebEngineSettings"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.get_font_family","text":"Return the actual font family for the specified generic font family. Parameters: Name Type Description Default family Literal['standard', 'fixed', 'serif', 'sans_serif', 'cursive', 'fantasy', 'pictograph'] generic font family required Returns: Type Description str Font family Source code in prettyqt/webenginewidgets/webenginesettings.py def get_font_family ( self , family : FontFamilyStr ) -> str : \"\"\"Return the actual font family for the specified generic font family. Args: family: generic font family Returns: Font family \"\"\" return self . item . fontFamily ( FONT_FAMILY [ family ])","title":"get_font_family()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.get_font_size","text":"Return the default font size for type in pixels. Parameters: Name Type Description Default typ Literal['minimum', 'minimum_logical', 'default', 'default_fixed'] font size type required Returns: Type Description int Font size Source code in prettyqt/webenginewidgets/webenginesettings.py def get_font_size ( self , typ : FontSizeStr ) -> int : \"\"\"Return the default font size for type in pixels. Args: typ: font size type Returns: Font size \"\"\" return self . item . fontSize ( FONT_SIZE [ typ ])","title":"get_font_size()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.get_unknown_url_scheme_policy","text":"Return current unknown url scheme policy. Returns: Type Description Literal['disallow', 'allow_from_user_interaction', 'allow_all'] Unknown url scheme policy Source code in prettyqt/webenginewidgets/webenginesettings.py def get_unknown_url_scheme_policy ( self ) -> UnknownUrlSchemePolicyStr : \"\"\"Return current unknown url scheme policy. Returns: Unknown url scheme policy \"\"\" return UNKNOWN_URL_SCHEME_POLICY . inverse [ self . item . unknownUrlSchemePolicy ()]","title":"get_unknown_url_scheme_policy()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.set_font_family","text":"Set the actual font family to family for the specified generic family, which. Parameters: Name Type Description Default which Literal['standard', 'fixed', 'serif', 'sans_serif', 'cursive', 'fantasy', 'pictograph'] family to set required family str generic family required Exceptions: Type Description InvalidParamError Font family does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_font_family ( self , which : FontFamilyStr , family : str ): \"\"\"Set the actual font family to family for the specified generic family, which. Args: which: family to set family: generic family Raises: InvalidParamError: Font family does not exist \"\"\" if which not in FONT_FAMILY : raise InvalidParamError ( which , FONT_FAMILY ) self . item . setFontFamily ( FONT_FAMILY [ which ], family )","title":"set_font_family()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.set_font_size","text":"Set the font size for type to size in pixels. Parameters: Name Type Description Default typ Literal['minimum', 'minimum_logical', 'default', 'default_fixed'] font size type required size int size in pixels required Exceptions: Type Description InvalidParamError Font size does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_font_size ( self , typ : FontSizeStr , size : int ): \"\"\"Set the font size for type to size in pixels. Args: typ: font size type size: size in pixels Raises: InvalidParamError: Font size does not exist \"\"\" if typ not in FONT_SIZE : raise InvalidParamError ( typ , FONT_SIZE ) self . item . setFontSize ( FONT_SIZE [ typ ], size )","title":"set_font_size()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.set_unknown_url_scheme_policy","text":"Set the unknown url scheme policy. Parameters: Name Type Description Default policy Literal['disallow', 'allow_from_user_interaction', 'allow_all'] unknown url scheme policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_unknown_url_scheme_policy ( self , policy : UnknownUrlSchemePolicyStr ): \"\"\"Set the unknown url scheme policy. Args: policy: unknown url scheme policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in UNKNOWN_URL_SCHEME_POLICY : raise InvalidParamError ( policy , UNKNOWN_URL_SCHEME_POLICY ) self . item . setUnknownUrlSchemePolicy ( UNKNOWN_URL_SCHEME_POLICY [ policy ])","title":"set_unknown_url_scheme_policy()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview","text":"","title":"webengineview"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView","text":"","title":"WebEngineView"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.find_text","text":"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable[[bool], NoneType] result callback None Source code in prettyqt/webenginewidgets/webengineview.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlag () if case_sensitive : flag |= QtWebEngineWidgets . QWebEnginePage . FindCaseSensitively if backward : flag |= QtWebEngineWidgets . QWebEnginePage . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.load_url","text":"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webengineview.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_url","text":"Set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webengineview.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_zoom","text":"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/widgets.html","text":"widgets module widgets module. contains QtWidgets-based classes abstractbutton AbstractButton set_icon ( self , icon ) Set the icon for the button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/abstractbutton.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) set_icon_size ( self , size ) Set size of the icon. Source code in prettyqt/widgets/abstractbutton.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icon.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) abstractitemview AbstractItemView get_selection_behaviour ( self ) Return current selection behaviour. Returns: Type Description Literal['rows', 'columns', 'items'] selection behaviour Source code in prettyqt/widgets/abstractitemview.py def get_selection_behaviour ( self ) -> SELECTION_BEHAVIOUR_STR : \"\"\"Return current selection behaviour. Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOUR . inverse [ self . selectionBehavior ()] get_selection_mode ( self ) Return current selection mode. Returns: Type Description Literal['single', 'extended', 'multi', 'none'] selection mode Source code in prettyqt/widgets/abstractitemview.py def get_selection_mode ( self ) -> SELECTION_MODE_STR : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()] highlight_when_inactive ( self ) Highlight items when widget does not have focus. Source code in prettyqt/widgets/abstractitemview.py def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p ) jump_to_column ( self , col_num ) Make sure column at given index is visible. scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return None idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx ) num_selected ( self ) Return amount of selected rows. Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ()) scroll_to_bottom ( self ) Override to use abstractitemview-way of scrolling to bottom. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom () scroll_to_top ( self ) Override to use abstractitemview-way of scrolling to top. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop () selectAll ( self ) Override, we dont want to selectAll for too many items bc of performance. Source code in prettyqt/widgets/abstractitemview.py def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return None if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return None super () . selectAll () selected_data ( self ) Returns generator yielding selected userData. Source code in prettyqt/widgets/abstractitemview.py def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes ()) selected_indexes ( self ) Returns list of selected indexes in first row. Source code in prettyqt/widgets/abstractitemview.py def selected_indexes ( self ) -> List [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) return sorted ( indexes , key = lambda x : x . row ()) selected_names ( self ) Returns generator yielding item names. Source code in prettyqt/widgets/abstractitemview.py def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ()) selected_rows ( self ) Returns generator yielding row nums. Source code in prettyqt/widgets/abstractitemview.py def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ()) set_horizontal_scroll_mode ( self , mode ) Set the horizontal scroll mode. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_horizontal_scroll_mode ( self , mode : SCROLL_MODE_STR ): \"\"\"Set the horizontal scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) set_model ( self , model ) Delete old selection model explicitely, seems to help with memory usage. Source code in prettyqt/widgets/abstractitemview.py def set_model ( self , model : Optional [ QtCore . QAbstractItemModel ]): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model set_scroll_mode ( self , mode ) Set the scroll mode for both directions. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_scroll_mode ( self , mode : SCROLL_MODE_STR ): \"\"\"Set the scroll mode for both directions. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) self . setVerticalScrollMode ( SCROLL_MODE [ mode ]) set_selection_behaviour ( self , behaviour ) Set selection behaviour for given item view. Parameters: Name Type Description Default behaviour Literal['rows', 'columns', 'items'] selection behaviour to use required Exceptions: Type Description InvalidParamError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_behaviour ( self , behaviour : SELECTION_BEHAVIOUR_STR ): \"\"\"Set selection behaviour for given item view. Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOUR : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOUR ) self . setSelectionBehavior ( SELECTION_BEHAVIOUR [ behaviour ]) set_selection_mode ( self , mode ) Set selection mode for given item view. Parameters: Name Type Description Default mode Optional[Literal['single', 'extended', 'multi', 'none']] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_mode ( self , mode : Optional [ SELECTION_MODE_STR ]): \"\"\"Set selection mode for given item view. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ]) set_vertical_scroll_mode ( self , mode ) Set the vertical scroll mode. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_vertical_scroll_mode ( self , mode : SCROLL_MODE_STR ): \"\"\"Set the vertical scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setVerticalScrollMode ( SCROLL_MODE [ mode ]) toggle_select_all ( self ) Select all items from list (deselect when all selected). Source code in prettyqt/widgets/abstractitemview.py def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return None if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll () abstractscrollarea AbstractScrollArea get_size_adjust_policy ( self ) Return size adjust policy. Returns: Type Description Literal['content', 'first_show', 'ignored'] size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def get_size_adjust_policy ( self ) -> SizePolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_POLICY . inverse [ self . sizeAdjustPolicy ()] scroll_to_bottom ( self ) Scroll to the bottom of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max () scroll_to_top ( self ) Scroll to the top of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min () set_horizontal_scrollbar_policy ( self , mode ) Set the horizontal scrollbar visibility. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_policy ( self , mode : ScrollBarPolicyStr ): \"\"\"Set the horizontal scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_horizontal_scrollbar_width ( self , width ) Set the horizontal scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) set_scrollbar_policy ( self , mode ) Set the policy for both scrollbars. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_policy ( self , mode : ScrollBarPolicyStr ): \"\"\"Set the policy for both scrollbars. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_scrollbar_width ( self , width ) Set the width for both scrollbars. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width ) set_size_adjust_policy ( self , policy ) Set size adjust policy. Parameters: Name Type Description Default policy Literal['content', 'first_show', 'ignored'] size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def set_size_adjust_policy ( self , policy : SizePolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICY : raise InvalidParamError ( policy , SIZE_POLICY ) self . setSizeAdjustPolicy ( SIZE_POLICY [ policy ]) set_vertical_scrollbar_policy ( self , mode ) Set the vertical scrollbar visibility. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_policy ( self , mode : ScrollBarPolicyStr ): \"\"\"Set the vertical scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_vertical_scrollbar_width ( self , width ) Set the vertical scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) abstractslider AbstractSlider get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/abstractslider.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()] get_repeat_action ( self ) Get current repeat action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Returns: Type Description str current repeat action Source code in prettyqt/widgets/abstractslider.py def get_repeat_action ( self ) -> str : \"\"\"Get current repeat action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Returns: current repeat action \"\"\" return SLIDER_ACTIONS . inverse [ self . repeatAction ()] is_horizontal ( self ) Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == QtCore . Qt . Horizontal is_vertical ( self ) Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == QtCore . Qt . Vertical scroll_to_max ( self ) Scroll to the maximum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ()) scroll_to_min ( self ) Scroll to the minimum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ()) set_horizontal ( self ) Set slider orientation to horizontal. Source code in prettyqt/widgets/abstractslider.py def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( QtCore . Qt . Horizontal ) set_orientation ( self , orientation ) Set the orientation of the slider. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the slider required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/abstractslider.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the slider. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) set_repeat_action ( self , action , threshold = 500 , repeat_time = 50 ) Set the repeat action. Valid values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Parameters: Name Type Description Default action str repeat action required Exceptions: Type Description InvalidParamError invalid repeat action Source code in prettyqt/widgets/abstractslider.py def set_repeat_action ( self , action : str , threshold : int = 500 , repeat_time : int = 50 ): \"\"\"Set the repeat action. Valid values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Args: action: repeat action Raises: InvalidParamError: invalid repeat action \"\"\" if action not in SLIDER_ACTIONS : raise InvalidParamError ( action , SLIDER_ACTIONS ) self . setRepeatAction ( SLIDER_ACTIONS [ action ], threshold , repeat_time ) set_vertical ( self ) Set slider orientation to vertical. Source code in prettyqt/widgets/abstractslider.py def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( QtCore . Qt . Vertical ) trigger_action ( self , action ) Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Source code in prettyqt/widgets/abstractslider.py def trigger_action ( self , action : str ): \"\"\"Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" \"\"\" if action not in SLIDER_ACTIONS : raise InvalidParamError ( action , SLIDER_ACTIONS ) self . triggerAction ( SLIDER_ACTIONS [ action ]) abstractspinbox AbstractSpinBox get_button_symbols ( self ) Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: Type Description str button symbol type Source code in prettyqt/widgets/abstractspinbox.py def get_button_symbols ( self ) -> str : \"\"\"Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: button symbol type \"\"\" return SYMBOLS . inverse [ self . buttonSymbols ()] get_correction_mode ( self ) Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: Type Description str correction mode Source code in prettyqt/widgets/abstractspinbox.py def get_correction_mode ( self ) -> str : \"\"\"Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: correction mode \"\"\" return CORRECTION_MODES . inverse [ self . correctionMode ()] get_step_type ( self ) Return step type. possible values are \"default\", \"adaptive\" Returns: Type Description str step type Source code in prettyqt/widgets/abstractspinbox.py def get_step_type ( self ) -> str : \"\"\"Return step type. possible values are \"default\", \"adaptive\" Returns: step type \"\"\" return STEP_TYPES . inverse [ self . stepType ()] set_button_symbols ( self , mode ) Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Parameters: Name Type Description Default mode str button symbol type to use required Exceptions: Type Description InvalidParamError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py def set_button_symbols ( self , mode : str ): \"\"\"Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ]) set_correction_mode ( self , mode ) Set correction mode. possible values are \"to_previous\", \"to_nearest\" Parameters: Name Type Description Default mode str correction mode to use required Exceptions: Type Description InvalidParamError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py def set_correction_mode ( self , mode : str ): \"\"\"Set correction mode. possible values are \"to_previous\", \"to_nearest\" Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ]) set_step_type ( self , mode ) Set step type. possible values are \"default\", \"adaptive\" Parameters: Name Type Description Default mode str step type to use required Exceptions: Type Description InvalidParamError invalid step type Source code in prettyqt/widgets/abstractspinbox.py def set_step_type ( self , mode : str ): \"\"\"Set step type. possible values are \"default\", \"adaptive\" Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ]) action Action get_menu_role ( self ) Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: Type Description str menu role Source code in prettyqt/widgets/action.py def get_menu_role ( self ) -> str : \"\"\"Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: menu role \"\"\" return ROLES . inverse [ self . menuRole ()] get_priority ( self ) Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: Type Description str priority Source code in prettyqt/widgets/action.py def get_priority ( self ) -> str : \"\"\"Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: priority \"\"\" return PRIORITIES . inverse [ self . priority ()] get_shortcut_context ( self ) Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: Type Description str shortcut context Source code in prettyqt/widgets/action.py def get_shortcut_context ( self ) -> str : \"\"\"Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: shortcut context \"\"\" return CONTEXTS . inverse [ self . shortcutContext ()] set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/action.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) set_menu_role ( self , role ) Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Parameters: Name Type Description Default role str menu role required Exceptions: Type Description InvalidParamError menu role does not exist Source code in prettyqt/widgets/action.py def set_menu_role ( self , role : str ): \"\"\"Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ]) set_priority ( self , priority ) Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Parameters: Name Type Description Default priority str priority for the action required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/widgets/action.py def set_priority ( self , priority : str ): \"\"\"Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ]) set_shortcut_context ( self , context ) Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Parameters: Name Type Description Default context str shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/action.py def set_shortcut_context ( self , context : str ): \"\"\"Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in CONTEXTS : raise InvalidParamError ( context , CONTEXTS ) self . setShortcutContext ( CONTEXTS [ context ]) actiongroup ActionGroup get_exclusion_policy ( self ) Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: Type Description str exclusion policy Source code in prettyqt/widgets/actiongroup.py def get_exclusion_policy ( self ) -> str : \"\"\"Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: exclusion policy \"\"\" return POLICIES . inverse [ self . exclusionPolicy ()] set_exclusion_policy ( self , policy ) Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Parameters: Name Type Description Default policy Optional[str] exclusion policy to use required Exceptions: Type Description InvalidParamError exclusion policy does not exist Source code in prettyqt/widgets/actiongroup.py def set_exclusion_policy ( self , policy : Optional [ str ]): \"\"\"Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ]) application Application get_navigation_mode ( self ) Return navigation mode. possible values: \"none\", \"keypad_tab_order\", \"keypad_directional\", \"cursor_auto\", \"cursor_force_visible\" Returns: Type Description str navigation mode Source code in prettyqt/widgets/application.py def get_navigation_mode ( self ) -> str : \"\"\"Return navigation mode. possible values: \"none\", \"keypad_tab_order\", \"keypad_directional\", \"cursor_auto\", \"cursor_force_visible\" Returns: navigation mode \"\"\" return NAVIGATION_MODES . inverse [ self . navigationMode ()] is_effect_enabled ( self , effect ) Return desktop effect state. possible values are \"animate_menu\", \"fade_menu\", \"animate_combo\", \"animate_tooltip\", \"fade_tooltip\", \"animate_toolbox\" Returns: Type Description str desktop effect state Source code in prettyqt/widgets/application.py def is_effect_enabled ( self , effect : str ) -> str : \"\"\"Return desktop effect state. possible values are \"animate_menu\", \"fade_menu\", \"animate_combo\", \"animate_tooltip\", \"fade_tooltip\", \"animate_toolbox\" Returns: desktop effect state \"\"\" return self . isEffectEnabled ( UI_EFFECTS [ effect ]) set_effect_enabled ( self , effect , enabled = True ) Set the enabled state of a desktop effect. valid values are: \"animate_menu\", \"fade_menu\", \"animate_combo\", \"animate_tooltip\", \"fade_tooltip\", \"animate_toolbox\" Parameters: Name Type Description Default effect str desktop effect to set required enabled bool new state True Exceptions: Type Description InvalidParamError invalid desktop effect Source code in prettyqt/widgets/application.py def set_effect_enabled ( self , effect : str , enabled : bool = True ): \"\"\"Set the enabled state of a desktop effect. valid values are: \"animate_menu\", \"fade_menu\", \"animate_combo\", \"animate_tooltip\", \"fade_tooltip\", \"animate_toolbox\" Args: effect: desktop effect to set enabled: new state Raises: InvalidParamError: invalid desktop effect \"\"\" if effect not in UI_EFFECTS : raise InvalidParamError ( effect , UI_EFFECTS ) self . setEffectEnabled ( UI_EFFECTS [ effect ]) set_navigation_mode ( self , mode ) Set the navigation mode. valid values: \"none\", \"keypad_tab_order\", \"keypad_directional\", \"cursor_auto\", \"cursor_force_visible\" Parameters: Name Type Description Default mode str navigation mode to use required Exceptions: Type Description InvalidParamError invalid navigation mode Source code in prettyqt/widgets/application.py def set_navigation_mode ( self , mode : str ): \"\"\"Set the navigation mode. valid values: \"none\", \"keypad_tab_order\", \"keypad_directional\", \"cursor_auto\", \"cursor_force_visible\" Args: mode: navigation mode to use Raises: InvalidParamError: invalid navigation mode \"\"\" if mode not in NAVIGATION_MODES : raise InvalidParamError ( mode , NAVIGATION_MODES ) self . setNavigationMode ( NAVIGATION_MODES [ mode ]) boxlayout BoxLayout get_direction ( self ) Return current direction. Returns: Type Description Literal['left_to_right', 'right_to_left', 'top_to_bottom', 'bottom_to_top'] direction Source code in prettyqt/widgets/boxlayout.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()] set_direction ( self , direction ) Set the direction. Parameters: Name Type Description Default direction Literal['left_to_right', 'right_to_left', 'top_to_bottom', 'bottom_to_top'] direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/widgets/boxlayout.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) calendarwidget CalendarWidget get_selection_mode ( self ) Return current selection mode. Returns: Type Description Literal['none', 'single'] selection mode Source code in prettyqt/widgets/calendarwidget.py def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()] set_selection_mode ( self , mode ) Set selection mode for given calendar widget. Parameters: Name Type Description Default mode Optional[Literal['none', 'single']] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/calendarwidget.py def set_selection_mode ( self , mode : Optional [ SelectionModeStr ]): \"\"\"Set selection mode for given calendar widget. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ]) checkbox CheckBox get_checkstate ( self ) Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/checkbox.py def get_checkstate ( self ) -> StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return STATE . inverse [ self . checkState ()] set_checkstate ( self , state ) Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/checkbox.py def set_checkstate ( self , state : StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATE : raise InvalidParamError ( state , STATE ) self . setCheckState ( STATE [ state ]) combobox ComboBox get_insert_policy ( self ) Return insert policy. Returns: Type Description Literal['no_insert', 'top', 'current', 'bottom', 'after_current', 'before_current', 'alphabetically'] insert policy Source code in prettyqt/widgets/combobox.py def get_insert_policy ( self ) -> InsertPolicyStr : \"\"\"Return insert policy. Returns: insert policy \"\"\" return INSERT_POLICY . inverse [ self . insertPolicy ()] get_size_adjust_policy ( self ) Return size adjust policy. Returns: Type Description Literal['content', 'first_show', 'min_length', 'min_length_with_icon'] size adjust policy Source code in prettyqt/widgets/combobox.py def get_size_adjust_policy ( self ) -> SizeAdjustPolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_ADJUST_POLICY . inverse [ self . sizeAdjustPolicy ()] set_icon_size ( self , size ) Set size of the icons. Source code in prettyqt/widgets/combobox.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) set_insert_policy ( self , policy ) Set insert policy. Parameters: Name Type Description Default policy Literal['no_insert', 'top', 'current', 'bottom', 'after_current', 'before_current', 'alphabetically'] insert policy to use required Exceptions: Type Description InvalidParamError invalid insert policy Source code in prettyqt/widgets/combobox.py def set_insert_policy ( self , policy : InsertPolicyStr ): \"\"\"Set insert policy. Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICY : raise InvalidParamError ( policy , INSERT_POLICY ) self . setInsertPolicy ( INSERT_POLICY [ policy ]) set_size_adjust_policy ( self , policy ) Set size adjust policy. Parameters: Name Type Description Default policy Literal['content', 'first_show', 'min_length', 'min_length_with_icon'] size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/combobox.py def set_size_adjust_policy ( self , policy : SizeAdjustPolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_ADJUST_POLICY : raise InvalidParamError ( policy , SIZE_ADJUST_POLICY ) policy = SIZE_ADJUST_POLICY [ policy ] self . setSizeAdjustPolicy ( policy ) completer Completer get_completion_mode ( self ) Return current completion mode. Returns: Type Description Literal['popup', 'inline', 'unfiltered_popup'] completion mode Source code in prettyqt/widgets/completer.py def get_completion_mode ( self ) -> CompletionModeStr : \"\"\"Return current completion mode. Returns: completion mode \"\"\" return COMPLETION_MODE . inverse [ self . completionMode ()] get_filter_mode ( self ) Return current filter mode. Returns: Type Description Literal['starts_with', 'contains', 'ends_with'] filter mode Source code in prettyqt/widgets/completer.py def get_filter_mode ( self ) -> FilterModeStr : \"\"\"Return current filter mode. Returns: filter mode \"\"\" return FILTER_MODE . inverse [ self . filterMode ()] get_sort_mode ( self ) Return current sort mode. Returns: Type Description Literal['unsorted', 'case_sensitive', 'case_insensitive'] sort mode Source code in prettyqt/widgets/completer.py def get_sort_mode ( self ) -> SortModeStr : \"\"\"Return current sort mode. Returns: sort mode \"\"\" return SORT_MODE . inverse [ self . modelSorting ()] set_completion_mode ( self , mode ) Set completion mode to use. Parameters: Name Type Description Default mode Literal['popup', 'inline', 'unfiltered_popup'] completion mode to use required Exceptions: Type Description InvalidParamError completion mode does not exist Source code in prettyqt/widgets/completer.py def set_completion_mode ( self , mode : CompletionModeStr ): \"\"\"Set completion mode to use. Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODE : raise InvalidParamError ( mode , COMPLETION_MODE ) self . setCompletionMode ( COMPLETION_MODE [ mode ]) set_filter_mode ( self , mode ) Set filter mode to use. Parameters: Name Type Description Default mode Literal['starts_with', 'contains', 'ends_with'] filter mode to use required Exceptions: Type Description InvalidParamError filter mode does not exist Source code in prettyqt/widgets/completer.py def set_filter_mode ( self , mode : FilterModeStr ): \"\"\"Set filter mode to use. Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in FILTER_MODE : raise InvalidParamError ( mode , FILTER_MODE ) self . setFilterMode ( FILTER_MODE [ mode ]) set_sort_mode ( self , mode ) Set sort mode to use. Parameters: Name Type Description Default mode Optional[Literal['unsorted', 'case_sensitive', 'case_insensitive']] sort mode to use required Exceptions: Type Description InvalidParamError sort mode does not exist Source code in prettyqt/widgets/completer.py def set_sort_mode ( self , mode : Optional [ SortModeStr ]): \"\"\"Set sort mode to use. Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODE : raise InvalidParamError ( mode , SORT_MODE ) self . setModelSorting ( SORT_MODE [ mode ]) datawidgetmapper DataWidgetMapper get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/datawidgetmapper.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()] get_submit_policy ( self ) Return current submit policy. Possible values: \"auto\", \"manual\" Returns: Type Description str submit policy Source code in prettyqt/widgets/datawidgetmapper.py def get_submit_policy ( self ) -> str : \"\"\"Return current submit policy. Possible values: \"auto\", \"manual\" Returns: submit policy \"\"\" return SUBMIT_POLICIES . inverse [ self . submitPolicy ()] set_orientation ( self , orientation ) Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) set_submit_policy ( self , policy ) Set the submit policy of the mapper. Allowed values are \"auto\", \"manual\" Parameters: Name Type Description Default policy str submit_policy for the splitter required Exceptions: Type Description InvalidParamError submit_policy does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_submit_policy ( self , policy : str ): \"\"\"Set the submit policy of the mapper. Allowed values are \"auto\", \"manual\" Args: policy: submit_policy for the splitter Raises: InvalidParamError: submit_policy does not exist \"\"\" if policy not in SUBMIT_POLICIES : raise InvalidParamError ( policy , SUBMIT_POLICIES ) self . setSubmitPolicy ( SUBMIT_POLICIES [ policy ]) dialog BaseDialog keyPressEvent ( self , e ) keyPressEvent(self, QKeyEvent) Source code in prettyqt/widgets/dialog.py def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e ) dialogbuttonbox DialogButtonBox add_button ( self , button , role = 'accept' , callback = None ) Add a button. Parameters: Name Type Description Default button Union[PyQt5.QtWidgets.QPushButton, str] button to add required role str role of the button 'accept' callback Optional[Callable] function to call when button gets clicked None Returns: Type Description PushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_button ( self , button : Union [ QtWidgets . QPushButton , str ], role : str = \"accept\" , callback : Optional [ Callable ] = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button add_default_button ( self , button , callback = None ) Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required callback Optional[Callable] function to call when button gets clicked None Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_default_button ( self , button : str , callback : Optional [ Callable ] = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn create ( ** kwargs ) classmethod create(self, window: sip.voidptr = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) Source code in prettyqt/widgets/dialogbuttonbox.py @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) return box get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/dialogbuttonbox.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()] set_orientation ( self , orientation ) Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the button box required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) dockwidget DockWidget Customized DockWidget class. Contains a custom TitleBar with maximise button filedialog FileDialog Simple dialog used to display some widget. get_accept_mode ( self ) Return accept mode. Returns: Type Description Literal['save', 'open'] accept mode Source code in prettyqt/widgets/filedialog.py def get_accept_mode ( self ) -> AcceptModeStr : \"\"\"Return accept mode. Returns: accept mode \"\"\" return ACCEPT_MODE . inverse [ self . acceptMode ()] get_directory ( self ) Return current directory. returns current directory level as a Pathlib object Returns: Type Description Path Pathlib object Source code in prettyqt/widgets/filedialog.py def get_directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( self . directory () . absolutePath ()) get_file_mode ( self ) Return file mode. Returns: Type Description Literal['existing_file', 'existing_files', 'any_file', 'directory'] file mode Source code in prettyqt/widgets/filedialog.py def get_file_mode ( self ) -> FileModeStr : \"\"\"Return file mode. Returns: file mode \"\"\" return FILE_MODE . inverse [ self . fileMode ()] get_label_text ( self , label ) Return label text. Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py def get_label_text ( self , label : LabelStr ) -> str : \"\"\"Return label text. Returns: label text \"\"\" return self . labelText ( LABEL [ label ]) get_view_mode ( self ) Return view mode. Returns: Type Description Literal['detail', 'list'] view mode Source code in prettyqt/widgets/filedialog.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] set_accept_mode ( self , mode ) Set accept mode. Parameters: Name Type Description Default mode Literal['save', 'open'] accept mode to use required Exceptions: Type Description InvalidParamError invalid accept mode Source code in prettyqt/widgets/filedialog.py def set_accept_mode ( self , mode : AcceptModeStr ): \"\"\"Set accept mode. Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODE : raise InvalidParamError ( mode , ACCEPT_MODE ) self . setAcceptMode ( ACCEPT_MODE [ mode ]) set_directory ( self , path ) Set start directory. Source code in prettyqt/widgets/filedialog.py def set_directory ( self , path : Union [ None , str , pathlib . Path ]): \"\"\"Set start directory.\"\"\" if isinstance ( path , pathlib . Path ): path = str ( path ) self . setDirectory ( path ) set_extension_filter ( self , extension_dict ) Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict Dict[str, List[str]] filter dictionary required Source code in prettyqt/widgets/filedialog.py def set_extension_filter ( self , extension_dict : Dict [ str , List [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str ) set_file_mode ( self , mode ) Set the file mode of the dialog. Parameters: Name Type Description Default mode Literal['existing_file', 'existing_files', 'any_file', 'directory'] mode to use required Source code in prettyqt/widgets/filedialog.py def set_file_mode ( self , mode : FileModeStr ): \"\"\"Set the file mode of the dialog. Args: mode: mode to use \"\"\" self . setFileMode ( FILE_MODE [ mode ]) set_label_text ( self , label , text ) Set the label text for button label. Parameters: Name Type Description Default label Literal['look_in', 'filename', 'filetype', 'accept'] button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py def set_label_text ( self , label : LabelStr , text : str ): \"\"\"Set the label text for button label. Args: label: button to set text for text: text to use \"\"\" if label not in LABEL : raise InvalidParamError ( label , LABEL ) self . setLabelText ( LABEL [ label ], text ) set_view_mode ( self , mode ) Set view mode. Parameters: Name Type Description Default mode Literal['detail', 'list'] view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/filedialog.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) filesystemmodel FileSystemModel Class to populate a filesystem treeview. data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/widgets/filesystemmodel.py def data ( self , index , role = QtCore . Qt . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role ) fontcombobox FontComboBox get_font_filters ( self ) Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: Type Description List[str] font filter list Source code in prettyqt/widgets/fontcombobox.py def get_font_filters ( self ) -> List [ str ]: \"\"\"Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()] set_font_filters ( self , * filters ) Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Parameters: Name Type Description Default filters str font filters to use () Exceptions: Type Description InvalidParamError invalid font filters Source code in prettyqt/widgets/fontcombobox.py def set_font_filters ( self , * filters : str ): \"\"\"Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags ) formlayout FormLayout __len__ ( self ) special Needed for PySide2. Source code in prettyqt/widgets/formlayout.py def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount () get_field_growth_policy ( self ) Return current field growth policy. Returns: Type Description FieldGrowthPolicyStr field growth policy Source code in prettyqt/widgets/formlayout.py def get_field_growth_policy ( self ) -> FieldGrowthPolicyStr : \"\"\"Return current field growth policy. Returns: field growth policy \"\"\" return FIELD_GROWTH_POLICY . inverse [ self . fieldGrowthPolicy ()] get_row_wrap_policy ( self ) Return current row wrap policy. Returns: Type Description RowWrapPolicyStr row wrap policy Source code in prettyqt/widgets/formlayout.py def get_row_wrap_policy ( self ) -> RowWrapPolicyStr : \"\"\"Return current row wrap policy. Returns: row wrap policy \"\"\" return ROW_WRAP_POLICY . inverse [ self . rowWrapPolicy ()] set_field_growth_policy ( self , policy ) Set field growth policy to use. Parameters: Name Type Description Default policy FieldGrowthPolicyStr field growth policy to use required Exceptions: Type Description InvalidParamError field growth policy does not exist Source code in prettyqt/widgets/formlayout.py def set_field_growth_policy ( self , policy : FieldGrowthPolicyStr ): \"\"\"Set field growth policy to use. Args: policy: field growth policy to use Raises: InvalidParamError: field growth policy does not exist \"\"\" if policy not in FIELD_GROWTH_POLICY : raise InvalidParamError ( policy , FIELD_GROWTH_POLICY ) self . setFieldGrowthPolicy ( FIELD_GROWTH_POLICY [ policy ]) set_row_wrap_policy ( self , policy ) Set row wrap policy to use. Parameters: Name Type Description Default policy RowWrapPolicyStr row wrap policy to use required Exceptions: Type Description InvalidParamError row wrap policy does not exist Source code in prettyqt/widgets/formlayout.py def set_row_wrap_policy ( self , policy : RowWrapPolicyStr ): \"\"\"Set row wrap policy to use. Args: policy: row wrap policy to use Raises: InvalidParamError: row wrap policy does not exist \"\"\" if policy not in ROW_WRAP_POLICY : raise InvalidParamError ( policy , ROW_WRAP_POLICY ) self . setRowWrapPolicy ( ROW_WRAP_POLICY [ policy ]) frame Frame get_frame_shadow ( self ) Return current frame shadow. Returns: Type Description Literal['plain', 'raised', 'sunken'] frame style Source code in prettyqt/widgets/frame.py def get_frame_shadow ( self ) -> ShadowStr : \"\"\"Return current frame shadow. Returns: frame style \"\"\" return SHADOW . inverse [ self . frameShadow ()] get_frame_shape ( self ) Return current frame shape. Returns: Type Description Literal['no_frame', 'box', 'panel', 'styled_panel', 'h_line', 'v_line', 'win_panel'] frame shape Source code in prettyqt/widgets/frame.py def get_frame_shape ( self ) -> FrameShapeStr : \"\"\"Return current frame shape. Returns: frame shape \"\"\" return FRAME_SHAPE . inverse [ self . frameShape ()] set_frame_shadow ( self , style ) Set frame shadow. Parameters: Name Type Description Default style Literal['plain', 'raised', 'sunken'] frame style to use required Exceptions: Type Description InvalidParamError style does not exist Source code in prettyqt/widgets/frame.py def set_frame_shadow ( self , style : ShadowStr ): \"\"\"Set frame shadow. Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style not in SHADOW : raise InvalidParamError ( style , SHADOW ) self . setFrameShadow ( SHADOW [ style ]) set_frame_shape ( self , shape ) Set frame shape. Parameters: Name Type Description Default shape Literal['no_frame', 'box', 'panel', 'styled_panel', 'h_line', 'v_line', 'win_panel'] frame shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/widgets/frame.py def set_frame_shape ( self , shape : FrameShapeStr ): \"\"\"Set frame shape. Args: shape: frame shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in FRAME_SHAPE : raise InvalidParamError ( shape , FRAME_SHAPE ) self . setFrameShape ( FRAME_SHAPE [ shape ]) gesture Gesture get_gesture_cancel_policy ( self ) Return current gesture cancel policy. Returns: Type Description Literal['none', 'all_in_context'] gesture cancel policy Source code in prettyqt/widgets/gesture.py def get_gesture_cancel_policy ( self ) -> GestureCancelPolicyStr : \"\"\"Return current gesture cancel policy. Returns: gesture cancel policy \"\"\" return GESTURE_CANCEL_POLICY . inverse [ self . gestureCancelPolicy ()] get_gesture_type ( self ) Return current gesture type. Returns: Type Description Literal['tap', 'tap_and_hold', 'pan', 'pinch', 'swipe', 'custom'] gesture type Source code in prettyqt/widgets/gesture.py def get_gesture_type ( self ) -> GestureTypeStr : \"\"\"Return current gesture type. Returns: gesture type \"\"\" return GESTURE_TYPE . inverse [ self . gestureType ()] get_state ( self ) Return current state. Returns: Type Description Literal['none', 'started', 'updated', 'finished', 'canceled'] state Source code in prettyqt/widgets/gesture.py def get_state ( self ) -> GestureStateStr : \"\"\"Return current state. Returns: state \"\"\" return GESTURE_STATE . inverse [ self . state ()] set_gesture_cancel_policy ( self , policy ) Set gesture cancel policy. Parameters: Name Type Description Default policy Literal['none', 'all_in_context'] gesture cancel policy to use required Exceptions: Type Description InvalidParamError gesture cancel policy does not exist Source code in prettyqt/widgets/gesture.py def set_gesture_cancel_policy ( self , policy : GestureCancelPolicyStr ): \"\"\"Set gesture cancel policy. Args: policy: gesture cancel policy to use Raises: InvalidParamError: gesture cancel policy does not exist \"\"\" if policy not in GESTURE_CANCEL_POLICY : raise InvalidParamError ( policy , GESTURE_CANCEL_POLICY ) self . setGestureCancelPolicy ( GESTURE_CANCEL_POLICY [ policy ]) graphicsitem GraphicsItem get_panel_modality ( self ) Get the current modality modes as a string. Returns: Type Description Literal['none', 'panel', 'scene'] panel modality Source code in prettyqt/widgets/graphicsitem.py def get_panel_modality ( self ) -> PanelModalityStr : \"\"\"Get the current modality modes as a string. Returns: panel modality \"\"\" return MODALITY . inverse [ self . panelModality ()] set_panel_modality ( self , modality ) Set panel modality. Parameters: Name Type Description Default modality Literal['none', 'panel', 'scene'] panel modality required Exceptions: Type Description InvalidParamError panel modality does not exist Source code in prettyqt/widgets/graphicsitem.py def set_panel_modality ( self , modality : PanelModalityStr ) -> None : \"\"\"Set panel modality. Args: modality: panel modality Raises: InvalidParamError: panel modality does not exist \"\"\" if modality not in MODALITY : raise InvalidParamError ( modality , MODALITY ) self . setPanelModality ( MODALITY [ modality ]) graphicsscene GraphicsScene get_item_index_method ( self ) Return item index method. Returns: Type Description Literal['bsp_tree', 'none'] item index method Source code in prettyqt/widgets/graphicsscene.py def get_item_index_method ( self ) -> ItemIndexMethodStr : \"\"\"Return item index method. Returns: item index method \"\"\" return ITEM_INDEX_METHOD . inverse [ self . itemIndexMethod ()] set_item_index_method ( self , method ) Set item index method. Parameters: Name Type Description Default method Literal['bsp_tree', 'none'] item index method to use required Exceptions: Type Description InvalidParamError invalid item index method Source code in prettyqt/widgets/graphicsscene.py def set_item_index_method ( self , method : ItemIndexMethodStr ): \"\"\"Set item index method. Args: method: item index method to use Raises: InvalidParamError: invalid item index method \"\"\" if method not in ITEM_INDEX_METHOD : raise InvalidParamError ( method , ITEM_INDEX_METHOD ) self . setItemIndexMethod ( ITEM_INDEX_METHOD [ method ]) graphicsview GraphicsView get_cache_mode ( self ) Return current cache mode. Returns: Type Description Literal['none', 'background'] cache mode Source code in prettyqt/widgets/graphicsview.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Return current cache mode. Returns: cache mode \"\"\" return CACHE_MODES . inverse [ self . cacheMode ()] get_drag_mode ( self ) Return current drag mode. Returns: Type Description Literal['none', 'scroll_hand', 'rubber_band'] drag mode Source code in prettyqt/widgets/graphicsview.py def get_drag_mode ( self ) -> DragModeStr : \"\"\"Return current drag mode. Returns: drag mode \"\"\" return DRAG_MODE . inverse [ self . dragMode ()] get_resize_anchor ( self ) Return current resize anchor. Returns: Type Description Literal['none', 'scroll_hand', 'rubber_band'] resize anchor Source code in prettyqt/widgets/graphicsview.py def get_resize_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current resize anchor. Returns: resize anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . resizeAnchor ()] get_rubberband_selection_mode ( self ) Return current rubberband selection mode. Returns: Type Description Literal['contains_shape', 'intersects_shape', 'contains_bounding_rect', 'intersects_bounding_rect'] rubberband selection mode Source code in prettyqt/widgets/graphicsview.py def get_rubberband_selection_mode ( self ) -> ItemSelectionModeStr : \"\"\"Return current rubberband selection mode. Returns: rubberband selection mode \"\"\" return ITEM_SELECTION_MODE . inverse [ self . rubberBandSelectionMode ()] get_transformation_anchor ( self ) Return current transformation anchor. Returns: Type Description Literal['none', 'scroll_hand', 'rubber_band'] viewport anchor Source code in prettyqt/widgets/graphicsview.py def get_transformation_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current transformation anchor. Returns: viewport anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . transformationAnchor ()] get_viewport_update_mode ( self ) Return current viewport update mode. Returns: Type Description Literal['full', 'minimal', 'smart', 'bounding_rect', 'none'] viewport update mode Source code in prettyqt/widgets/graphicsview.py def get_viewport_update_mode ( self ) -> ViewportUpdateModeStr : \"\"\"Return current viewport update mode. Returns: viewport update mode \"\"\" return VIEWPORT_UPDATE_MODE . inverse [ self . viewportUpdateMode ()] set_cache_mode ( self , mode ) Set the cache mode. Parameters: Name Type Description Default mode Literal['none', 'background'] cache mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set the cache mode. Args: mode: cache mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ]) set_drag_mode ( self , mode ) Set the behavior for dragging the mouse while the left mouse button is pressed. Parameters: Name Type Description Default mode Literal['none', 'scroll_hand', 'rubber_band'] drag mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_drag_mode ( self , mode : DragModeStr ): \"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed. Args: mode: drag mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_MODE : raise InvalidParamError ( mode , DRAG_MODE ) self . setDragMode ( DRAG_MODE [ mode ]) set_resize_anchor ( self , mode ) Set how the view should position the scene during resizes. Parameters: Name Type Description Default mode Literal['none', 'scroll_hand', 'rubber_band'] resize anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_resize_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during resizes. Args: mode: resize anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setResizeAnchor ( VIEWPORT_ANCHOR [ mode ]) set_rubberband_selection_mode ( self , mode ) Set the behavior for selecting items with a rubber band selection rectangle. Parameters: Name Type Description Default mode Literal['contains_shape', 'intersects_shape', 'contains_bounding_rect', 'intersects_bounding_rect'] rubberband selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_rubberband_selection_mode ( self , mode : ItemSelectionModeStr ): \"\"\"Set the behavior for selecting items with a rubber band selection rectangle. Args: mode: rubberband selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in ITEM_SELECTION_MODE : raise InvalidParamError ( mode , ITEM_SELECTION_MODE ) self . setRubberBandSelectionMode ( ITEM_SELECTION_MODE [ mode ]) set_transformation_anchor ( self , mode ) Set how the view should position the scene during transformations. Parameters: Name Type Description Default mode Literal['none', 'scroll_hand', 'rubber_band'] transformation anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_transformation_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during transformations. Args: mode: transformation anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setTransformationAnchor ( VIEWPORT_ANCHOR [ mode ]) set_viewport_update_mode ( self , mode ) Set how the viewport should update its contents. Parameters: Name Type Description Default mode Literal['full', 'minimal', 'smart', 'bounding_rect', 'none'] viewport update mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_viewport_update_mode ( self , mode : ViewportUpdateModeStr ): \"\"\"Set how the viewport should update its contents. Args: mode: viewport update mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_UPDATE_MODE : raise InvalidParamError ( mode , VIEWPORT_UPDATE_MODE ) self . setViewportUpdateMode ( VIEWPORT_UPDATE_MODE [ mode ]) graphicswidget GraphicsWidget get_focus_policy ( self ) Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: Type Description str str: Focus policy Source code in prettyqt/widgets/graphicswidget.py def get_focus_policy ( self ) -> str : \"\"\"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: str: Focus policy \"\"\" return FOCUS_POLICIES . inverse [ self . focusPolicy ()] set_focus_policy ( self , policy ) Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Parameters: Name Type Description Default policy str Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/graphicswidget.py def set_focus_policy ( self , policy : str ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in FOCUS_POLICIES : raise InvalidParamError ( policy , FOCUS_POLICIES ) self . setFocusPolicy ( FOCUS_POLICIES [ policy ]) gridlayout GridLayout get_origin_corner ( self ) Return current origin corner. Returns: Type Description Literal['top_left', 'top_right', 'bottom_left', 'bottom_right'] origin corner Source code in prettyqt/widgets/gridlayout.py def get_origin_corner ( self ) -> CornerStr : \"\"\"Return current origin corner. Returns: origin corner \"\"\" return CORNER . inverse [ self . originCorner ()] set_origin_corner ( self , corner ) Set the origin corner. Parameters: Name Type Description Default corner Literal['top_left', 'top_right', 'bottom_left', 'bottom_right'] origin corner required Exceptions: Type Description InvalidParamError corner does not exist Source code in prettyqt/widgets/gridlayout.py def set_origin_corner ( self , corner : CornerStr ): \"\"\"Set the origin corner. Args: corner: origin corner Raises: InvalidParamError: corner does not exist \"\"\" if corner not in CORNER : raise InvalidParamError ( corner , CORNER ) self . setOriginCorner ( CORNER [ corner ]) groupbox GroupBox GroupBox widget. A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets. headerview HeaderView contextMenuEvent ( self , event ) Context menu for our files tree. Source code in prettyqt/widgets/headerview.py def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) actions = self . get_header_actions () menu . add_actions ( actions ) menu . exec_ ( self . mapToGlobal ( event . pos ())) label Label get_text_format ( self ) Return current text format. Returns: Type Description TextFormatStr text format Source code in prettyqt/widgets/label.py def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] get_text_interaction ( self ) Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: Type Description List[str] list of text interaction modes Source code in prettyqt/widgets/label.py def get_text_interaction ( self ) -> List [ str ]: \"\"\"Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()] set_alignment ( self , horizontal = None , vertical = None ) Set the alignment of the label's contents. Source code in prettyqt/widgets/label.py def set_alignment ( self , horizontal : Optional [ str ] = None , vertical : Optional [ str ] = None ): \"\"\"Set the alignment of the label's contents.\"\"\" if horizontal is None and vertical is not None : flag = V_ALIGNMENTS [ vertical ] elif vertical is None and horizontal is not None : flag = H_ALIGNMENTS [ horizontal ] elif vertical is not None and horizontal is not None : flag = V_ALIGNMENTS [ vertical ] | H_ALIGNMENTS [ horizontal ] else : return self . setAlignment ( flag ) return self set_indent ( self , indent ) Set the label's text indent in pixels. Source code in prettyqt/widgets/label.py def set_indent ( self , indent : int ) -> Label : \"\"\"Set the label's text indent in pixels.\"\"\" self . setIndent ( indent ) return self set_text ( self , text ) Set the label's text. Source code in prettyqt/widgets/label.py def set_text ( self , text : str ) -> Label : \"\"\"Set the label's text.\"\"\" self . setText ( text ) return self set_text_format ( self , text_format ) Set the text format. Parameters: Name Type Description Default text_format TextFormatStr text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/label.py def set_text_format ( self , text_format : TextFormatStr ) -> Label : \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) return self set_text_interaction ( self , * types ) Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Parameters: Name Type Description Default types str text interaction mode to use () Exceptions: Type Description InvalidParamError text interaction mode does not exist Source code in prettyqt/widgets/label.py def set_text_interaction ( self , * types : str ) -> Label : \"\"\"Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self set_weight ( self , weight ) Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/widgets/label.py def set_weight ( self , weight : str ) -> Label : \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHTS : raise InvalidParamError ( weight , gui . font . WEIGHTS ) font = self . font () font . setWeight ( gui . font . WEIGHTS [ weight ]) self . setFont ( font ) return self layout Layout get_size_mode ( self ) Return current size mode. Returns: Type Description Literal['default', 'fixed', 'minimum', 'maximum', 'min_and_max', 'none'] size mode Source code in prettyqt/widgets/layout.py def get_size_mode ( self ) -> SizeConstraintStr : \"\"\"Return current size mode. Returns: size mode \"\"\" return SIZE_CONSTRAINT . inverse [ self . sizeConstraint ()] set_alignment ( self , alignment , item = None ) Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Parameters: Name Type Description Default alignment Literal['left', 'right', 'top', 'bottom'] alignment for the layout required item Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] set alignment for specific child only None Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layout.py def set_alignment ( self , alignment : AlignmentStr , item : Optional [ Union [ QtWidgets . QWidget , QtWidgets . QLayout ]] = None , ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) if item is not None : return self . setAlignment ( item , ALIGNMENTS [ alignment ]) else : return self . setAlignment ( ALIGNMENTS [ alignment ]) set_size_mode ( self , mode ) Set the size mode of the layout. Parameters: Name Type Description Default mode Literal['default', 'fixed', 'minimum', 'maximum', 'min_and_max', 'none'] size mode for the layout required Exceptions: Type Description InvalidParamError size mode does not exist Source code in prettyqt/widgets/layout.py def set_size_mode ( self , mode : SizeConstraintStr ): \"\"\"Set the size mode of the layout. Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in SIZE_CONSTRAINT : raise InvalidParamError ( mode , SIZE_CONSTRAINT ) self . setSizeConstraint ( SIZE_CONSTRAINT [ mode ]) lcdnumber LCDNumber get_mode ( self ) Return current lcd mode. Returns: Type Description Literal['hex', 'decimal', 'octal', 'binary'] lcd mode Source code in prettyqt/widgets/lcdnumber.py def get_mode ( self ) -> ModeStr : \"\"\"Return current lcd mode. Returns: lcd mode \"\"\" return MODE . inverse [ self . mode ()] get_segment_style ( self ) Return current segment style. Returns: Type Description Literal['outline', 'filled', 'flat'] segment style Source code in prettyqt/widgets/lcdnumber.py def get_segment_style ( self ) -> SegmentStyleStr : \"\"\"Return current segment style. Returns: segment style \"\"\" return SEGMENT_STYLE . inverse [ self . segmentStyle ()] set_mode ( self , mode ) Set the lcd mode. Parameters: Name Type Description Default mode Literal['hex', 'decimal', 'octal', 'binary'] lcd mode to use required Exceptions: Type Description InvalidParamError lcd mode does not exist Source code in prettyqt/widgets/lcdnumber.py def set_mode ( self , mode : ModeStr ): \"\"\"Set the lcd mode. Args: mode: lcd mode to use Raises: InvalidParamError: lcd mode does not exist \"\"\" if mode not in MODE : raise InvalidParamError ( mode , MODE ) self . setMode ( MODE [ mode ]) set_segment_style ( self , mode ) Set the segment style. Parameters: Name Type Description Default mode Literal['outline', 'filled', 'flat'] segment style to use required Exceptions: Type Description InvalidParamError segment style does not exist Source code in prettyqt/widgets/lcdnumber.py def set_segment_style ( self , mode : SegmentStyleStr ): \"\"\"Set the segment style. Args: mode: segment style to use Raises: InvalidParamError: segment style does not exist \"\"\" if mode not in SEGMENT_STYLE : raise InvalidParamError ( mode , SEGMENT_STYLE ) self . setSegmentStyle ( SEGMENT_STYLE [ mode ]) lineedit LineEdit font ( self ) font(self) -> QFont Source code in prettyqt/widgets/lineedit.py def font ( self ) -> gui . Font : return gui . Font ( super () . font ()) get_echo_mode ( self ) Return echo mode. Returns: Type Description Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode Source code in prettyqt/widgets/lineedit.py def get_echo_mode ( self ) -> EchoModeStr : \"\"\"Return echo mode. Returns: echo mode \"\"\" return ECHO_MODES . inverse [ self . echoMode ()] set_echo_mode ( self , mode ) Set echo mode. Parameters: Name Type Description Default mode Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/lineedit.py def set_echo_mode ( self , mode : EchoModeStr ): \"\"\"Set echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODES : raise InvalidParamError ( mode , ECHO_MODES ) self . setEchoMode ( ECHO_MODES [ mode ]) set_read_only ( self , value = True ) Set text to read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) listview ListView get_view_mode ( self ) Return view mode. possible values are \"list\", \"icon\" Returns: Type Description str view mode Source code in prettyqt/widgets/listview.py def get_view_mode ( self ) -> str : \"\"\"Return view mode. possible values are \"list\", \"icon\" Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] set_view_mode ( self , mode ) Set view mode. possible values are \"list\", \"icon\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/listview.py def set_view_mode ( self , mode : str ): \"\"\"Set view mode. possible values are \"list\", \"icon\" Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) listwidgetitem ListWidgetItem get_checkstate ( self ) Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/listwidgetitem.py def get_checkstate ( self ) -> StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return STATE . inverse [ self . checkState ()] set_checkstate ( self , state ) Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py def set_checkstate ( self , state : StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATE : raise InvalidParamError ( state , STATE ) self . setCheckState ( STATE [ state ]) set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/listwidgetitem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) mainwindow MainWindow Class for our mainWindow. Includes all docks, a centralwidget and a toolbar add_toolbar ( self , toolbar , position = 'top' ) Adds a toolbar to the mainmenu at specified area. Parameters: Name Type Description Default toolbar QToolBar toolbar to use required position Literal['top', 'bottom', 'left', 'right', 'all', 'none'] position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBar ( TOOLBAR_AREAS [ position ], toolbar ) add_toolbar_break ( self , position = 'top' ) Adds a toolbar break to the given area behind the last item. Parameters: Name Type Description Default position Literal['top', 'bottom', 'left', 'right', 'all', 'none'] position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar_break ( self , position : ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBarBreak ( TOOLBAR_AREAS [ position ]) createPopupMenu ( self ) createPopupMenu(self) -> QMenu Source code in prettyqt/widgets/mainwindow.py def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add ( action ) return menu save_window_state ( self , recursive = False ) Save current window state as QSetting. Parameters: Name Type Description Default recursive bool Description False Source code in prettyqt/widgets/mainwindow.py def save_window_state ( self , recursive : bool = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { self . windowTitle () !r} ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state () toggle_fullscreen ( self ) Toggle between fullscreen and regular size. Source code in prettyqt/widgets/mainwindow.py def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen () mdiarea MdiArea get_tab_position ( self ) Return current tab position. Returns: Type Description Literal['north', 'south', 'west', 'east'] tab position Source code in prettyqt/widgets/mdiarea.py def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return current tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()] get_view_mode ( self ) Return current view mode. Returns: Type Description Literal['default', 'tabbed'] view mode Source code in prettyqt/widgets/mdiarea.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return current view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] get_window_order ( self ) Return current window order. Returns: Type Description Literal['creation', 'stacking', 'activation_history'] view mode Source code in prettyqt/widgets/mdiarea.py def get_window_order ( self ) -> WindowOrderStr : \"\"\"Return current window order. Returns: view mode \"\"\" return WINDOW_ORDER . inverse [ self . activationOrder ()] set_tab_position ( self , position ) Set tab position for the MDI area. Parameters: Name Type Description Default position Literal['north', 'south', 'west', 'east'] tabs position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/mdiarea.py def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the MDI area. Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ]) set_view_mode ( self , mode ) Set view mode for the MDI area. Parameters: Name Type Description Default mode Literal['default', 'tabbed'] view mode to use required Exceptions: Type Description InvalidParamError view mode does not exist Source code in prettyqt/widgets/mdiarea.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode for the MDI area. Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) set_window_order ( self , mode ) Set the window order behaviour for the MDI area. Parameters: Name Type Description Default mode Literal['creation', 'stacking', 'activation_history'] window order behaviour to use required Exceptions: Type Description InvalidParamError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py def set_window_order ( self , mode : WindowOrderStr ): \"\"\"Set the window order behaviour for the MDI area. Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDER : raise InvalidParamError ( mode , WINDOW_ORDER ) self . setActivationOrder ( WINDOW_ORDER [ mode ]) menu Menu add_action ( self , label , callback = None , icon = None , checkable = False , checked = False , shortcut = None , status_tip = None ) Add an action to the menu. Parameters: Name Type Description Default label Union[str, prettyqt.widgets.action.Action] Label for button required callback Callable gets called when action is triggered None icon Optional[Any] icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut Optional[str] Shortcut for action None status_tip Optional[str] Status tip to be shown in status bar None Returns: Type Description Action Action added to menu Source code in prettyqt/widgets/menu.py def add_action ( self , label : Union [ str , widgets . Action ], callback : Callable = None , icon : Optional [ Any ] = None , checkable : bool = False , checked : bool = False , shortcut : Optional [ str ] = None , status_tip : Optional [ str ] = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action add_separator ( self , text = None ) Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None Returns: Type Description WidgetAction Separator action Source code in prettyqt/widgets/menu.py def add_separator ( self , text : Optional [ str ] = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator set_icon ( self , icon ) Set the icon for the menu. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/menu.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) messagebox MessageBox add_button ( self , button ) Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/messagebox.py def add_button ( self , button : str ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ]) get_text_format ( self ) Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/messagebox.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] set_icon ( self , icon ) Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/messagebox.py def set_icon ( self , icon : gui . icon . IconType ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) return None icon = gui . icon . get_icon ( icon ) self . setIconPixmap ( icon . get_pixmap ( size = 64 )) set_text_format ( self , text_format ) Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/messagebox.py def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) plaintextedit PlainTextEdit get_line_wrap_mode ( self ) Get the current wrap mode. Returns: Type Description Literal['none', 'widget_width'] Wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()] get_wrap_mode ( self ) Get the current word wrap mode. Returns: Type Description str Word wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_wrap_mode ( self ) -> str : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return WRAP_MODE . inverse [ self . wordWrapMode ()] set_line_wrap_mode ( self , mode ) Set line wrap mode. Parameters: Name Type Description Default mode Literal['none', 'widget_width'] line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ]) set_read_only ( self , value = True ) Make the PlainTextEdit read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) set_wrap_mode ( self , mode ) Set word wrap mode. Parameters: Name Type Description Default mode Literal['none', 'word', 'anywhere', 'boundary_or_anywhere'] word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_wrap_mode ( self , mode : WrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in WRAP_MODE : raise InvalidParamError ( mode , WRAP_MODE ) self . setWordWrapMode ( WRAP_MODE [ mode ]) wheelEvent ( self , event ) Handle wheel event for zooming. Source code in prettyqt/widgets/plaintextedit.py def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event ) progressbar ProgressBar Progress dialog. wrapper for QtWidgets.QProgressBar get_alignment ( self ) Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description str alignment Source code in prettyqt/widgets/progressbar.py def get_alignment ( self ) -> str : \"\"\"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" return ALIGNMENTS . inverse [ self . alignment ()] get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/progressbar.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()] get_text_direction ( self ) Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Type Description str Text direction Source code in prettyqt/widgets/progressbar.py def get_text_direction ( self ) -> str : \"\"\"Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inverse [ self . textDirection ()] set_alignment ( self , alignment ) Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/progressbar.py def set_alignment ( self , alignment : str ): \"\"\"Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) self . setAlignment ( ALIGNMENTS [ alignment ]) set_orientation ( self , orientation ) Set the orientation of the progress bar. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the progress bar required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/progressbar.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the progress bar. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the progress bar Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) set_text_direction ( self , text_direction ) Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Parameters: Name Type Description Default text_direction str text direction for the layout required Exceptions: Type Description InvalidParamError text direction does not exist Source code in prettyqt/widgets/progressbar.py def set_text_direction ( self , text_direction : str ): \"\"\"Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ]) progressdialog ProgressDialog Progress dialog. Wrapper for QtWidgets.QProgressDialog scroller Scroller get_state ( self ) Return current state. Possible values: \"inactive\", \"pressed\", \"dragging\", \"scrolling\" Returns: Type Description str state Source code in prettyqt/widgets/scroller.py def get_state ( self ) -> str : \"\"\"Return current state. Possible values: \"inactive\", \"pressed\", \"dragging\", \"scrolling\" Returns: state \"\"\" return STATE . inverse [ self . state ()] scrollerproperties ScrollerProperties get_scroll_metric ( self , metric ) Return scroll metric. Possible values: \"mouse_press_event_delay\", \"drag_start_distance\", \"drag_velocity_smoothing_factor\", \"axis_lock_threshold\", \"scrolling_curve\", \"deceleration_factor\", \"minimum_velocity\", \"maximum_velocity\", \"maximum_click_through_velocity\", \"accelerating_flick_maximum_time\", \"accelerating_flick_speedup_factor\", \"snap_position_ratio\", \"snap_time\", \"overshoot_drag_resistance_factor\", \"overshoot_drag_distance_factor\", \"overshoot_scroll_distance_factor\", \"overshoot_scroll_time\", \"horizontal_overshoot_policy\", \"vertical_overshoot_policy\", \"frame_rate\", \"scroll_metric_count\" Parameters: Name Type Description Default metric str Scroll metric to get required Exceptions: Type Description InvalidParamError metric does not exist Returns: Type Description Any state Source code in prettyqt/widgets/scrollerproperties.py def get_scroll_metric ( self , metric : str ) -> Any : \"\"\"Return scroll metric. Possible values: \"mouse_press_event_delay\", \"drag_start_distance\", \"drag_velocity_smoothing_factor\", \"axis_lock_threshold\", \"scrolling_curve\", \"deceleration_factor\", \"minimum_velocity\", \"maximum_velocity\", \"maximum_click_through_velocity\", \"accelerating_flick_maximum_time\", \"accelerating_flick_speedup_factor\", \"snap_position_ratio\", \"snap_time\", \"overshoot_drag_resistance_factor\", \"overshoot_drag_distance_factor\", \"overshoot_scroll_distance_factor\", \"overshoot_scroll_time\", \"horizontal_overshoot_policy\", \"vertical_overshoot_policy\", \"frame_rate\", \"scroll_metric_count\" Args: metric: Scroll metric to get Raises: InvalidParamError: metric does not exist Returns: state \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) return self . scrollMetric ( SCROLL_METRIC [ metric ]) set_scroll_metric ( self , metric , value ) Set scroll metric. Possible values: \"mouse_press_event_delay\", \"drag_start_distance\", \"drag_velocity_smoothing_factor\", \"axis_lock_threshold\", \"scrolling_curve\", \"deceleration_factor\", \"minimum_velocity\", \"maximum_velocity\", \"maximum_click_through_velocity\", \"accelerating_flick_maximum_time\", \"accelerating_flick_speedup_factor\", \"snap_position_ratio\", \"snap_time\", \"overshoot_drag_resistance_factor\", \"overshoot_drag_distance_factor\", \"overshoot_scroll_distance_factor\", \"overshoot_scroll_time\", \"horizontal_overshoot_policy\", \"vertical_overshoot_policy\", \"frame_rate\", \"scroll_metric_count\" Parameters: Name Type Description Default metric str Scroll metric to set required value Any Value to set required Exceptions: Type Description InvalidParamError metric does not exist Source code in prettyqt/widgets/scrollerproperties.py def set_scroll_metric ( self , metric : str , value : Any ): \"\"\"Set scroll metric. Possible values: \"mouse_press_event_delay\", \"drag_start_distance\", \"drag_velocity_smoothing_factor\", \"axis_lock_threshold\", \"scrolling_curve\", \"deceleration_factor\", \"minimum_velocity\", \"maximum_velocity\", \"maximum_click_through_velocity\", \"accelerating_flick_maximum_time\", \"accelerating_flick_speedup_factor\", \"snap_position_ratio\", \"snap_time\", \"overshoot_drag_resistance_factor\", \"overshoot_drag_distance_factor\", \"overshoot_scroll_distance_factor\", \"overshoot_scroll_time\", \"horizontal_overshoot_policy\", \"vertical_overshoot_policy\", \"frame_rate\", \"scroll_metric_count\" Args: metric: Scroll metric to set value: Value to set Raises: InvalidParamError: metric does not exist \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) self . setScrollMetric ( SCROLL_METRIC [ metric ], value ) shortcut Shortcut get_context ( self ) Return shortcut context. Returns: Type Description Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context Source code in prettyqt/widgets/shortcut.py def get_context ( self ) -> ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return CONTEXT . inverse [ self . context ()] get_key ( self ) Return the shortcut's key sequence. Returns: Type Description KeySequence Key sequence Source code in prettyqt/widgets/shortcut.py def get_key ( self ) -> gui . KeySequence : \"\"\"Return the shortcut's key sequence. Returns: Key sequence \"\"\" return gui . KeySequence ( self . key ()) set_context ( self , context ) Set shortcut context. Parameters: Name Type Description Default context Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/shortcut.py def set_context ( self , context : ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in CONTEXT : raise InvalidParamError ( context , CONTEXT ) self . setContext ( CONTEXT [ context ]) sizepolicy SizePolicy get_control_type ( self ) Return control type. Returns: Type Description Literal['default', 'buttonbox', 'checkbox', 'combobox', 'frame', 'groupbox', 'label', 'line', 'lineedit', 'pushbutton', 'radiobutton', 'slider', 'spinbox', 'tabwidget', 'toolbutton'] control type Source code in prettyqt/widgets/sizepolicy.py def get_control_type ( self ) -> ControlTypeStr : \"\"\"Return control type. Returns: control type \"\"\" return CONTROL_TYPE . inverse [ self . controlType ()] get_horizontal_policy ( self ) Return size policy. Returns: Type Description Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] horizontal size policy Source code in prettyqt/widgets/sizepolicy.py def get_horizontal_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: horizontal size policy \"\"\" return SIZE_POLICY . inverse [ self . horizontalPolicy ()] get_vertical_policy ( self ) Return size policy. Returns: Type Description Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] vertical size policy Source code in prettyqt/widgets/sizepolicy.py def get_vertical_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: vertical size policy \"\"\" return SIZE_POLICY . inverse [ self . verticalPolicy ()] set_control_type ( self , typ ) Set the control type. Parameters: Name Type Description Default typ Literal['default', 'buttonbox', 'checkbox', 'combobox', 'frame', 'groupbox', 'label', 'line', 'lineedit', 'pushbutton', 'radiobutton', 'slider', 'spinbox', 'tabwidget', 'toolbutton'] control type to set required Exceptions: Type Description InvalidParamError control type does not exist Source code in prettyqt/widgets/sizepolicy.py def set_control_type ( self , typ : ControlTypeStr ) -> None : \"\"\"Set the control type. Args: typ: control type to set Raises: InvalidParamError: control type does not exist \"\"\" if typ not in CONTROL_TYPE : raise InvalidParamError ( typ , CONTROL_TYPE ) self . setControlType ( CONTROL_TYPE [ typ ]) set_horizontal_policy ( self , policy ) Set the horizontal policy. Parameters: Name Type Description Default policy Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_horizontal_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setHorizontalPolicy ( SIZE_POLICY [ policy ]) set_vertical_policy ( self , policy ) Set the horizontal policy. Parameters: Name Type Description Default policy Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_vertical_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setVerticalPolicy ( SIZE_POLICY [ policy ]) slider Slider get_tick_position ( self ) Return tick position. Returns: Type Description Literal['none', 'both_sides', 'above', 'below'] tick position Source code in prettyqt/widgets/slider.py def get_tick_position ( self ) -> TickPositionStr : \"\"\"Return tick position. Returns: tick position \"\"\" val = TICK_POSITION . inverse [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\" return val set_tick_position ( self , position ) Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Parameters: Name Type Description Default position Literal['none', 'both_sides', 'above', 'below', 'left', 'right'] position for the ticks required Source code in prettyqt/widgets/slider.py def set_tick_position ( self , position : TickPositionAllStr ): \"\"\"Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITION : raise InvalidParamError ( position , TICK_POSITION ) self . setTickPosition ( TICK_POSITION [ position ]) splitter Splitter get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/splitter.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()] set_orientation ( self , orientation ) Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitter.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) styleoptionslider StyleOptionSlider is_horizontal ( self ) Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == QtCore . Qt . Horizontal is_vertical ( self ) Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == QtCore . Qt . Vertical set_horizontal ( self ) Set slider orientation to horizontal. Source code in prettyqt/widgets/styleoptionslider.py def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = QtCore . Qt . Horizontal set_vertical ( self ) Set slider orientation to vertical. Source code in prettyqt/widgets/styleoptionslider.py def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = QtCore . Qt . Vertical swipegesture SwipeGesture get_horizontal_direction ( self ) Return horizontal direction of the gesture. Possible values: \"none\", \"left, \"right\" Returns: Type Description str horizontal direction Source code in prettyqt/widgets/swipegesture.py def get_horizontal_direction ( self ) -> str : \"\"\"Return horizontal direction of the gesture. Possible values: \"none\", \"left, \"right\" Returns: horizontal direction \"\"\" return SWIPE_DIRECTION . inverse [ self . horizontalDirection ()] get_vertical_direction ( self ) Return vertical direction of the gesture. Possible values: \"none\", \"up, \"down\" Returns: Type Description str vertical direction Source code in prettyqt/widgets/swipegesture.py def get_vertical_direction ( self ) -> str : \"\"\"Return vertical direction of the gesture. Possible values: \"none\", \"up, \"down\" Returns: vertical direction \"\"\" return SWIPE_DIRECTION . inverse [ self . verticalDirection ()] systemtrayicon SystemTrayIcon set_icon ( self , icon ) Set the system tray icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/systemtrayicon.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) tabbar TabBar get_elide_mode ( self ) Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: Type Description str elide mode Source code in prettyqt/widgets/tabbar.py def get_elide_mode ( self ) -> str : \"\"\"Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: elide mode \"\"\" return ELIDE_MODES . inverse [ self . elideMode ()] get_remove_behaviour ( self ) Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: Type Description str remove behaviour Source code in prettyqt/widgets/tabbar.py def get_remove_behaviour ( self ) -> str : \"\"\"Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOURS . inverse [ self . selectionBehaviorOnRemove ()] mouseDoubleClickEvent ( self , event ) mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/widgets/tabbar.py def mouseDoubleClickEvent ( self , event ): event . accept () self . on_detach . emit ( self . tabAt ( event . pos ()), self . mouse_cursor . pos ()) set_elide_mode ( self , mode ) Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Parameters: Name Type Description Default mode str elide mode to use required Exceptions: Type Description InvalidParamError invalid elide mode Source code in prettyqt/widgets/tabbar.py def set_elide_mode ( self , mode : str ) -> None : \"\"\"Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in ELIDE_MODES : raise InvalidParamError ( mode , ELIDE_MODES ) self . setElideMode ( ELIDE_MODES [ mode ]) set_icon_size ( self , size ) Set size of the icons. Source code in prettyqt/widgets/tabbar.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) set_selection_behavior_on_remove ( self , mode ) Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Parameters: Name Type Description Default mode str new remove behaviour required Source code in prettyqt/widgets/tabbar.py def set_selection_behavior_on_remove ( self , mode : str ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOURS : raise InvalidParamError ( mode , REMOVE_BEHAVIOURS ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOURS [ mode ]) tablewidgetitem TableWidgetItem get_checkstate ( self ) Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/tablewidgetitem.py def get_checkstate ( self ) -> StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return STATE . inverse [ self . checkState ()] set_checkstate ( self , state ) Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/tablewidgetitem.py def set_checkstate ( self , state : StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATE : raise InvalidParamError ( state , STATE ) self . setCheckState ( STATE [ state ]) set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/tablewidgetitem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) tabwidget DetachedTab Window containing a detached tab. When a tab is detached, the contents are placed into this QMainWindow. The tab can be re-attached by closing the dialog Attributes: Name Type Description on_close signal, emitted when window is closed (widget, title, icon) closeEvent ( self , event ) closeEvent(self, QCloseEvent) Source code in prettyqt/widgets/tabwidget.py def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . get_id (), self . windowIcon ()) TabWidget Widget for managing the tabs section. attach_tab ( self , widget , name , icon = None , insert_at = None ) Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Parameters: Name Type Description Default widget Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] the content widget from the DetachedTab window required name str the name of the detached tab required icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] the window icon for the detached tab None insert_at Optional[int] insert the re-attached tab at the given index None Source code in prettyqt/widgets/tabwidget.py def attach_tab ( self , widget : Union [ QtWidgets . QWidget , QtWidgets . QLayout ], name : str , icon : gui . icon . IconType = None , insert_at : Optional [ int ] = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (gui.icon.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True ) close_detached_tabs ( self ) Close all tabs that are currently detached. Source code in prettyqt/widgets/tabwidget.py def close_detached_tabs ( self ) -> None : \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close () detach_tab ( self , index , point ) Detach tab by removing its contents and placing them in a DetachedTab window. Parameters: Name Type Description Default index int index location of the tab to be detached required point QPoint screen pos for creating the new DetachedTab window required Returns: Type Description None None: Description Source code in prettyqt/widgets/tabwidget.py @autoslot . AutoSlot def detach_tab ( self , index : int , point : QtCore . QPoint ) -> None : \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content name = self . tabText ( index ) icon = self . tabIcon ( index ) if icon . isNull (): icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab get_tab_position ( self ) Return tab position. possible values are \"north\", \"south\", \"east\", \"west\" Returns: Type Description str tab position Source code in prettyqt/widgets/tabwidget.py def get_tab_position ( self ) -> str : \"\"\"Return tab position. possible values are \"north\", \"south\", \"east\", \"west\" Returns: tab position \"\"\" return TAB_POSITIONS . inverse [ self . tabPosition ()] get_tab_shape ( self ) Return tab shape. possible values are \"rounded\", \"triangular\" Returns: Type Description str tab shape Source code in prettyqt/widgets/tabwidget.py def get_tab_shape ( self ) -> str : \"\"\"Return tab shape. possible values are \"rounded\", \"triangular\" Returns: tab shape \"\"\" return TAB_SHAPES . inverse [ self . tabShape ()] open_widget ( self , widget , title = 'Unnamed' ) Create a tab containing delivered widget. Source code in prettyqt/widgets/tabwidget.py @autoslot . AutoSlot def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True ) set_tab_position ( self , position ) Set tab position for the tabwidget. Valid values are \"north\", \"south\", \"east\", \"west\" Parameters: Name Type Description Default position str tab position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_position ( self , position : str ) -> None : \"\"\"Set tab position for the tabwidget. Valid values are \"north\", \"south\", \"east\", \"west\" Args: position: tab position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITIONS : raise InvalidParamError ( position , TAB_POSITIONS ) self . setTabPosition ( TAB_POSITIONS [ position ]) set_tab_shape ( self , shape ) Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Parameters: Name Type Description Default shape str tab shape to use required Exceptions: Type Description InvalidParamError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_shape ( self , shape : str ) -> None : \"\"\"Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ]) toolbar ToolBar add_separator ( self , text = None , before = None ) Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None before QAction insert separator before specific action None Returns: Type Description QAction Separator action Source code in prettyqt/widgets/toolbar.py def add_separator ( self , text : Optional [ str ] = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label ) get_style ( self ) Return current style. Returns: Type Description Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] style Source code in prettyqt/widgets/toolbar.py def get_style ( self ) -> StyleStr : \"\"\"Return current style. Returns: style \"\"\" return STYLE . inverse [ self . toolButtonStyle ()] is_area_allowed ( self , area ) Check if toolbar is allowed at specified area. Parameters: Name Type Description Default area Literal['left', 'right', 'top', 'bottom', 'all', 'none'] area of the toolbar required Exceptions: Type Description InvalidParamError area does not exist Source code in prettyqt/widgets/toolbar.py def is_area_allowed ( self , area : ToolbarAreaStr ) -> bool : \"\"\"Check if toolbar is allowed at specified area. Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in TOOLBAR_AREAS : raise InvalidParamError ( area , TOOLBAR_AREAS ) return self . isAreaAllowed ( TOOLBAR_AREAS [ area ]) set_icon_size ( self , size ) Set size of the icons. Source code in prettyqt/widgets/toolbar.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) toolbutton ToolButton get_arrow_type ( self ) Return arrow type. Returns: Type Description Literal['none', 'up', 'down', 'left', 'right'] arrow type Source code in prettyqt/widgets/toolbutton.py def get_arrow_type ( self ) -> ArrowTypeStr : \"\"\"Return arrow type. Returns: arrow type \"\"\" return ARROW_TYPE . inverse [ self . arrowType ()] get_popup_mode ( self ) Return popup mode. Returns: Type Description Literal['delayed', 'menu_button', 'instant'] popup mode Source code in prettyqt/widgets/toolbutton.py def get_popup_mode ( self ) -> PopupModeStr : \"\"\"Return popup mode. Returns: popup mode \"\"\" return POPUP_MODE . inverse [ self . popupMode ()] get_style ( self ) Return toolbutton style. Returns: Type Description Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] toolbutton style Source code in prettyqt/widgets/toolbutton.py def get_style ( self ) -> StyleStr : \"\"\"Return toolbutton style. Returns: toolbutton style \"\"\" return STYLE . inverse [ self . toolButtonStyle ()] set_arrow_type ( self , mode ) Set the arrow type of the toolbutton. Parameters: Name Type Description Default mode Literal['none', 'up', 'down', 'left', 'right'] arrow type to use required Exceptions: Type Description InvalidParamError invalid arrow type Source code in prettyqt/widgets/toolbutton.py def set_arrow_type ( self , mode : ArrowTypeStr ): \"\"\"Set the arrow type of the toolbutton. Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in ARROW_TYPE : raise InvalidParamError ( mode , ARROW_TYPE ) self . setArrowType ( ARROW_TYPE [ mode ]) set_popup_mode ( self , mode ) Set the popup mode of the toolbutton. Parameters: Name Type Description Default mode Literal['delayed', 'menu_button', 'instant'] popup mode to use required Exceptions: Type Description InvalidParamError invalid popup mode Source code in prettyqt/widgets/toolbutton.py def set_popup_mode ( self , mode : PopupModeStr ): \"\"\"Set the popup mode of the toolbutton. Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODE : raise InvalidParamError ( mode , POPUP_MODE ) self . setPopupMode ( POPUP_MODE [ mode ]) set_style ( self , style ) Set the toolbutton style. Parameters: Name Type Description Default style Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] style to use required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/widgets/toolbutton.py def set_style ( self , style : StyleStr ): \"\"\"Set the toolbutton style. Args: style: style to use Raises: InvalidParamError: invalid style \"\"\" if style not in STYLE : raise InvalidParamError ( style , STYLE ) self . setToolButtonStyle ( STYLE [ style ]) treewidgetitem TreeWidgetItem get_checkstate ( self , column = 0 ) Return checkstate. Parameters: Name Type Description Default column int column 0 Returns: Type Description StateStr checkstate Source code in prettyqt/widgets/treewidgetitem.py def get_checkstate ( self , column : int = 0 ) -> StateStr : \"\"\"Return checkstate. Args: column: column Returns: checkstate \"\"\" return STATE . inverse [ self . checkState ( column )] get_child_indicator_policy ( self ) Return current child indicator policy. Returns: Type Description ChildIndicatorPolicyStr child indicator policy Source code in prettyqt/widgets/treewidgetitem.py def get_child_indicator_policy ( self ) -> ChildIndicatorPolicyStr : \"\"\"Return current child indicator policy. Returns: child indicator policy \"\"\" return CHILD_INDICATOR_POLICY . inverse [ self . childIndicatorPolicy ()] set_checkstate ( self , state , column = 0 ) Set checkstate of the checkbox. Parameters: Name Type Description Default state StateStr checkstate to use required column int column 0 Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py def set_checkstate ( self , state : StateStr , column : int = 0 ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use column: column Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATE : raise InvalidParamError ( state , STATE ) self . setCheckState ( column , STATE [ state ]) set_child_indicator_policy ( self , policy ) Set the child indicator policy. Parameters: Name Type Description Default policy ChildIndicatorPolicyStr child indicator policy required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/treewidgetitem.py def set_child_indicator_policy ( self , policy : ChildIndicatorPolicyStr ): \"\"\"Set the child indicator policy. Args: policy: child indicator policy Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CHILD_INDICATOR_POLICY : raise InvalidParamError ( policy , CHILD_INDICATOR_POLICY ) self . setChildIndicatorPolicy ( CHILD_INDICATOR_POLICY [ policy ]) set_icon ( self , icon , column = 0 ) Set the icon for the action. Parameters: Name Type Description Default icon gui.icon.IconType icon to use required column int column 0 Source code in prettyqt/widgets/treewidgetitem.py def set_icon ( self , icon : gui . icon . IconType , column : int = 0 ): \"\"\"Set the icon for the action. Args: icon: icon to use column: column \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( column , icon ) undoview UndoView set_clean_icon ( self , icon ) Set the icon for the clean button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/undoview.py def set_clean_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setCleanIcon ( icon ) widget Widget get_contextmenu_policy ( self ) Return current contextmenu policy. Returns: Type Description Literal['none', 'prevent', 'default', 'actions', 'custom'] contextmenu policy Source code in prettyqt/widgets/widget.py def get_contextmenu_policy ( self ) -> ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return CONTEXT_POLICY . inverse [ self . contextMenuPolicy ()] get_focus_policy ( self ) Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: Type Description str str: Focus policy Source code in prettyqt/widgets/widget.py def get_focus_policy ( self ) -> str : \"\"\"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: str: Focus policy \"\"\" return FOCUS_POLICIES . inverse [ self . focusPolicy ()] get_modality ( self ) Get the current modality modes as a string. Returns: Type Description Literal['none', 'prevent', 'default', 'actions', 'custom'] modality mode Source code in prettyqt/widgets/widget.py def get_modality ( self ) -> ModalityStr : \"\"\"Get the current modality modes as a string. Returns: modality mode \"\"\" return MODALITY . inverse [ self . windowModality ()] resize ( self , * size ) resize(self, QSize) resize(self, int, int) Source code in prettyqt/widgets/widget.py def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size ) set_contextmenu_policy ( self , policy ) Set contextmenu policy for given item view. Parameters: Name Type Description Default policy Literal['none', 'prevent', 'default', 'actions', 'custom'] contextmenu policy to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_contextmenu_policy ( self , policy : ContextPolicyStr ) -> None : \"\"\"Set contextmenu policy for given item view. Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CONTEXT_POLICY : raise InvalidParamError ( policy , CONTEXT_POLICY ) self . setContextMenuPolicy ( CONTEXT_POLICY [ policy ]) set_focus_policy ( self , policy ) Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Parameters: Name Type Description Default policy str Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/widget.py def set_focus_policy ( self , policy : str ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in FOCUS_POLICIES : raise InvalidParamError ( policy , FOCUS_POLICIES ) self . setFocusPolicy ( FOCUS_POLICIES [ policy ]) set_icon ( self , icon ) Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/widget.py def set_icon ( self , icon : gui . icon . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) set_modality ( self , modality ) Set modality for the dialog. Parameters: Name Type Description Default modality Literal['none', 'prevent', 'default', 'actions', 'custom'] modality for the main window required Exceptions: Type Description InvalidParamError modality type does not exist Source code in prettyqt/widgets/widget.py def set_modality ( self , modality : ModalityStr ) -> None : \"\"\"Set modality for the dialog. Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in MODALITY : raise InvalidParamError ( modality , MODALITY ) self . setWindowModality ( MODALITY [ modality ]) set_size_policy ( self , horizontal = None , vertical = None ) Set the sizes policy. Parameters: Name Type Description Default horizontal Optional[Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored']] horizontal size policy None vertical Optional[Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored']] vertical size policy None Source code in prettyqt/widgets/widget.py def set_size_policy ( self , horizontal : Optional [ widgets . sizepolicy . SizePolicyStr ] = None , vertical : Optional [ widgets . sizepolicy . SizePolicyStr ] = None , ) -> None : \"\"\"Set the sizes policy. Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp ) wizard Wizard get_button_text ( self , button_type ) Return text for given button type. Parameters: Name Type Description Default button_type str button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizard.py def get_button_text ( self , button_type : str ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . buttonText ( WIZARD_BUTTON [ button_type ]) get_option ( self , option ) Return the value assigned to option. Possible values: \"independent_pages\", \"ignore_subtitles\", \"extended_watermark_bitmap\", \"no_default_button\", \"no_back_button_on_start_page\", \"no_back_button_on_last_page\", \"disabled_back_button_on_last_page\", \"next_button_on_last_page\", \"finish_button_on_early_pages\", \"no_cancel_button\", \"cancel_button_on_left\", \"help_button\", \"help_button_on_right\", \"custom_button_1\", \"custom_button_2\", \"custom_button_3\", \"no_cancel_button_on_last_page\" Parameters: Name Type Description Default option str option to get required Returns: Type Description bool option Source code in prettyqt/widgets/wizard.py def get_option ( self , option : str ) -> bool : \"\"\"Return the value assigned to option. Possible values: \"independent_pages\", \"ignore_subtitles\", \"extended_watermark_bitmap\", \"no_default_button\", \"no_back_button_on_start_page\", \"no_back_button_on_last_page\", \"disabled_back_button_on_last_page\", \"next_button_on_last_page\", \"finish_button_on_early_pages\", \"no_cancel_button\", \"cancel_button_on_left\", \"help_button\", \"help_button_on_right\", \"custom_button_1\", \"custom_button_2\", \"custom_button_3\", \"no_cancel_button_on_last_page\" Args: option: option to get Returns: option \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) return self . testOption ( WIZARD_OPTIONS [ option ]) get_subtitle_format ( self ) Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str subtitle format Source code in prettyqt/widgets/wizard.py def get_subtitle_format ( self ) -> str : \"\"\"Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: subtitle format \"\"\" return TEXT_FORMATS . inverse [ self . subTitleFormat ()] get_title_format ( self ) Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str title format Source code in prettyqt/widgets/wizard.py def get_title_format ( self ) -> str : \"\"\"Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: title format \"\"\" return TEXT_FORMATS . inverse [ self . titleFormat ()] get_wizard_style ( self ) Return current wizard style. Possible values are \"classic\", \"modern\", \"mac\", \"aero\" Returns: Type Description str Wizard style Source code in prettyqt/widgets/wizard.py def get_wizard_style ( self ) -> str : \"\"\"Return current wizard style. Possible values are \"classic\", \"modern\", \"mac\", \"aero\" Returns: Wizard style \"\"\" return WIZARD_STYLE . inverse [ self . wizardStyle ()] set_button_text ( self , button_type , value ) Set text for given button type. Parameters: Name Type Description Default button_type str button to get text from required value str text to set required Source code in prettyqt/widgets/wizard.py def set_button_text ( self , button_type : str , value : str ) -> str : \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . setButtonText ( WIZARD_BUTTON [ button_type ], value ) set_option ( self , option , value ) Set option to given value. Allowed values: \"independent_pages\", \"ignore_subtitles\", \"extended_watermark_bitmap\", \"no_default_button\", \"no_back_button_on_start_page\", \"no_back_button_on_last_page\", \"disabled_back_button_on_last_page\", \"next_button_on_last_page\", \"finish_button_on_early_pages\", \"no_cancel_button\", \"cancel_button_on_left\", \"help_button\", \"help_button_on_right\", \"custom_button_1\", \"custom_button_2\", \"custom_button_3\", \"no_cancel_button_on_last_page\" Parameters: Name Type Description Default option str option to use required value bool value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/widgets/wizard.py def set_option ( self , option : str , value : bool ): \"\"\"Set option to given value. Allowed values: \"independent_pages\", \"ignore_subtitles\", \"extended_watermark_bitmap\", \"no_default_button\", \"no_back_button_on_start_page\", \"no_back_button_on_last_page\", \"disabled_back_button_on_last_page\", \"next_button_on_last_page\", \"finish_button_on_early_pages\", \"no_cancel_button\", \"cancel_button_on_left\", \"help_button\", \"help_button_on_right\", \"custom_button_1\", \"custom_button_2\", \"custom_button_3\", \"no_cancel_button_on_last_page\" Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) self . setOption ( WIZARD_OPTIONS [ option ], value ) set_subtitle_format ( self , fmt ) Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt str subtitle format to use required Exceptions: Type Description InvalidParamError subtitle format does not exist Source code in prettyqt/widgets/wizard.py def set_subtitle_format ( self , fmt : str ): \"\"\"Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: subtitle format to use Raises: InvalidParamError: subtitle format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setSubTitleFormat ( TEXT_FORMATS [ fmt ]) set_title_format ( self , fmt ) Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt str title format to use required Exceptions: Type Description InvalidParamError title format does not exist Source code in prettyqt/widgets/wizard.py def set_title_format ( self , fmt : str ): \"\"\"Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: title format to use Raises: InvalidParamError: title format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setTitleFormat ( TEXT_FORMATS [ fmt ]) set_wizard_style ( self , style ) Set the wizard style. Allowed values are \"classic\", \"modern\", \"mac\", \"aero\" Parameters: Name Type Description Default style str wizard style required Exceptions: Type Description InvalidParamError wizard style does not exist Source code in prettyqt/widgets/wizard.py def set_wizard_style ( self , style : str ): \"\"\"Set the wizard style. Allowed values are \"classic\", \"modern\", \"mac\", \"aero\" Args: style: wizard style Raises: InvalidParamError: wizard style does not exist \"\"\" if style not in WIZARD_STYLE : raise InvalidParamError ( style , WIZARD_STYLE ) self . setWizardStyle ( WIZARD_STYLE [ style ]) wizardpage WizardPage get_button_text ( self , button_type ) Return text for given button type. Parameters: Name Type Description Default button_type str button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizardpage.py def get_button_text ( self , button_type : str ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) return self . buttonText ( widgets . wizard . WIZARD_BUTTON [ button_type ]) set_button_text ( self , button_type , value ) Set text for given button type. Parameters: Name Type Description Default button_type str button to get text from required value str text to set required Source code in prettyqt/widgets/wizardpage.py def set_button_text ( self , button_type : str , value : str ) -> str : \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) return self . setButtonText ( widgets . wizard . WIZARD_BUTTON [ button_type ], value )","title":"widgets"},{"location":"api/widgets.html#widgets-module","text":"","title":"widgets module"},{"location":"api/widgets.html#prettyqt.widgets","text":"widgets module. contains QtWidgets-based classes","title":"prettyqt.widgets"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton","text":"","title":"abstractbutton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton","text":"","title":"AbstractButton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton.set_icon","text":"Set the icon for the button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/abstractbutton.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton.set_icon_size","text":"Set size of the icon. Source code in prettyqt/widgets/abstractbutton.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icon.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview","text":"","title":"abstractitemview"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView","text":"","title":"AbstractItemView"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_behaviour","text":"Return current selection behaviour. Returns: Type Description Literal['rows', 'columns', 'items'] selection behaviour Source code in prettyqt/widgets/abstractitemview.py def get_selection_behaviour ( self ) -> SELECTION_BEHAVIOUR_STR : \"\"\"Return current selection behaviour. Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOUR . inverse [ self . selectionBehavior ()]","title":"get_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_mode","text":"Return current selection mode. Returns: Type Description Literal['single', 'extended', 'multi', 'none'] selection mode Source code in prettyqt/widgets/abstractitemview.py def get_selection_mode ( self ) -> SELECTION_MODE_STR : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.highlight_when_inactive","text":"Highlight items when widget does not have focus. Source code in prettyqt/widgets/abstractitemview.py def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p )","title":"highlight_when_inactive()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.jump_to_column","text":"Make sure column at given index is visible. scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return None idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx )","title":"jump_to_column()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.num_selected","text":"Return amount of selected rows. Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ())","title":"num_selected()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_bottom","text":"Override to use abstractitemview-way of scrolling to bottom. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_top","text":"Override to use abstractitemview-way of scrolling to top. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selectAll","text":"Override, we dont want to selectAll for too many items bc of performance. Source code in prettyqt/widgets/abstractitemview.py def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return None if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return None super () . selectAll ()","title":"selectAll()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_data","text":"Returns generator yielding selected userData. Source code in prettyqt/widgets/abstractitemview.py def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes ())","title":"selected_data()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_indexes","text":"Returns list of selected indexes in first row. Source code in prettyqt/widgets/abstractitemview.py def selected_indexes ( self ) -> List [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) return sorted ( indexes , key = lambda x : x . row ())","title":"selected_indexes()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_names","text":"Returns generator yielding item names. Source code in prettyqt/widgets/abstractitemview.py def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ())","title":"selected_names()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_rows","text":"Returns generator yielding row nums. Source code in prettyqt/widgets/abstractitemview.py def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ())","title":"selected_rows()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_horizontal_scroll_mode","text":"Set the horizontal scroll mode. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_horizontal_scroll_mode ( self , mode : SCROLL_MODE_STR ): \"\"\"Set the horizontal scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ])","title":"set_horizontal_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_model","text":"Delete old selection model explicitely, seems to help with memory usage. Source code in prettyqt/widgets/abstractitemview.py def set_model ( self , model : Optional [ QtCore . QAbstractItemModel ]): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model","title":"set_model()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_scroll_mode","text":"Set the scroll mode for both directions. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_scroll_mode ( self , mode : SCROLL_MODE_STR ): \"\"\"Set the scroll mode for both directions. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) self . setVerticalScrollMode ( SCROLL_MODE [ mode ])","title":"set_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_behaviour","text":"Set selection behaviour for given item view. Parameters: Name Type Description Default behaviour Literal['rows', 'columns', 'items'] selection behaviour to use required Exceptions: Type Description InvalidParamError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_behaviour ( self , behaviour : SELECTION_BEHAVIOUR_STR ): \"\"\"Set selection behaviour for given item view. Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOUR : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOUR ) self . setSelectionBehavior ( SELECTION_BEHAVIOUR [ behaviour ])","title":"set_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_mode","text":"Set selection mode for given item view. Parameters: Name Type Description Default mode Optional[Literal['single', 'extended', 'multi', 'none']] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_mode ( self , mode : Optional [ SELECTION_MODE_STR ]): \"\"\"Set selection mode for given item view. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_vertical_scroll_mode","text":"Set the vertical scroll mode. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_vertical_scroll_mode ( self , mode : SCROLL_MODE_STR ): \"\"\"Set the vertical scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setVerticalScrollMode ( SCROLL_MODE [ mode ])","title":"set_vertical_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.toggle_select_all","text":"Select all items from list (deselect when all selected). Source code in prettyqt/widgets/abstractitemview.py def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return None if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll ()","title":"toggle_select_all()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea","text":"","title":"abstractscrollarea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea","text":"","title":"AbstractScrollArea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.get_size_adjust_policy","text":"Return size adjust policy. Returns: Type Description Literal['content', 'first_show', 'ignored'] size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def get_size_adjust_policy ( self ) -> SizePolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_POLICY . inverse [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_bottom","text":"Scroll to the bottom of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_top","text":"Scroll to the top of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_policy","text":"Set the horizontal scrollbar visibility. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_policy ( self , mode : ScrollBarPolicyStr ): \"\"\"Set the horizontal scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_horizontal_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_width","text":"Set the horizontal scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" )","title":"set_horizontal_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_policy","text":"Set the policy for both scrollbars. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_policy ( self , mode : ScrollBarPolicyStr ): \"\"\"Set the policy for both scrollbars. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_width","text":"Set the width for both scrollbars. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width )","title":"set_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_size_adjust_policy","text":"Set size adjust policy. Parameters: Name Type Description Default policy Literal['content', 'first_show', 'ignored'] size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def set_size_adjust_policy ( self , policy : SizePolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICY : raise InvalidParamError ( policy , SIZE_POLICY ) self . setSizeAdjustPolicy ( SIZE_POLICY [ policy ])","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_policy","text":"Set the vertical scrollbar visibility. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_policy ( self , mode : ScrollBarPolicyStr ): \"\"\"Set the vertical scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_vertical_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_width","text":"Set the vertical scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" )","title":"set_vertical_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider","text":"","title":"abstractslider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider","text":"","title":"AbstractSlider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/abstractslider.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.get_repeat_action","text":"Get current repeat action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Returns: Type Description str current repeat action Source code in prettyqt/widgets/abstractslider.py def get_repeat_action ( self ) -> str : \"\"\"Get current repeat action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Returns: current repeat action \"\"\" return SLIDER_ACTIONS . inverse [ self . repeatAction ()]","title":"get_repeat_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_horizontal","text":"Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == QtCore . Qt . Horizontal","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_vertical","text":"Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == QtCore . Qt . Vertical","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_max","text":"Scroll to the maximum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ())","title":"scroll_to_max()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_min","text":"Scroll to the minimum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ())","title":"scroll_to_min()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_horizontal","text":"Set slider orientation to horizontal. Source code in prettyqt/widgets/abstractslider.py def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( QtCore . Qt . Horizontal )","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_orientation","text":"Set the orientation of the slider. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the slider required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/abstractslider.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the slider. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_repeat_action","text":"Set the repeat action. Valid values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Parameters: Name Type Description Default action str repeat action required Exceptions: Type Description InvalidParamError invalid repeat action Source code in prettyqt/widgets/abstractslider.py def set_repeat_action ( self , action : str , threshold : int = 500 , repeat_time : int = 50 ): \"\"\"Set the repeat action. Valid values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Args: action: repeat action Raises: InvalidParamError: invalid repeat action \"\"\" if action not in SLIDER_ACTIONS : raise InvalidParamError ( action , SLIDER_ACTIONS ) self . setRepeatAction ( SLIDER_ACTIONS [ action ], threshold , repeat_time )","title":"set_repeat_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_vertical","text":"Set slider orientation to vertical. Source code in prettyqt/widgets/abstractslider.py def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( QtCore . Qt . Vertical )","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.trigger_action","text":"Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" Source code in prettyqt/widgets/abstractslider.py def trigger_action ( self , action : str ): \"\"\"Trigger slider action. Possible values are \"none\", \"single_step_add\", \"single_step_sub\", \"page_step_add\", \"page_step_sub\", \"to_minimum\", \"to_maximum\", \"move\" \"\"\" if action not in SLIDER_ACTIONS : raise InvalidParamError ( action , SLIDER_ACTIONS ) self . triggerAction ( SLIDER_ACTIONS [ action ])","title":"trigger_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox","text":"","title":"abstractspinbox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox","text":"","title":"AbstractSpinBox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_button_symbols","text":"Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: Type Description str button symbol type Source code in prettyqt/widgets/abstractspinbox.py def get_button_symbols ( self ) -> str : \"\"\"Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: button symbol type \"\"\" return SYMBOLS . inverse [ self . buttonSymbols ()]","title":"get_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_correction_mode","text":"Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: Type Description str correction mode Source code in prettyqt/widgets/abstractspinbox.py def get_correction_mode ( self ) -> str : \"\"\"Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: correction mode \"\"\" return CORRECTION_MODES . inverse [ self . correctionMode ()]","title":"get_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_step_type","text":"Return step type. possible values are \"default\", \"adaptive\" Returns: Type Description str step type Source code in prettyqt/widgets/abstractspinbox.py def get_step_type ( self ) -> str : \"\"\"Return step type. possible values are \"default\", \"adaptive\" Returns: step type \"\"\" return STEP_TYPES . inverse [ self . stepType ()]","title":"get_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_button_symbols","text":"Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Parameters: Name Type Description Default mode str button symbol type to use required Exceptions: Type Description InvalidParamError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py def set_button_symbols ( self , mode : str ): \"\"\"Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ])","title":"set_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_correction_mode","text":"Set correction mode. possible values are \"to_previous\", \"to_nearest\" Parameters: Name Type Description Default mode str correction mode to use required Exceptions: Type Description InvalidParamError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py def set_correction_mode ( self , mode : str ): \"\"\"Set correction mode. possible values are \"to_previous\", \"to_nearest\" Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ])","title":"set_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_step_type","text":"Set step type. possible values are \"default\", \"adaptive\" Parameters: Name Type Description Default mode str step type to use required Exceptions: Type Description InvalidParamError invalid step type Source code in prettyqt/widgets/abstractspinbox.py def set_step_type ( self , mode : str ): \"\"\"Set step type. possible values are \"default\", \"adaptive\" Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ])","title":"set_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.action","text":"","title":"action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action","text":"","title":"Action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_menu_role","text":"Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: Type Description str menu role Source code in prettyqt/widgets/action.py def get_menu_role ( self ) -> str : \"\"\"Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: menu role \"\"\" return ROLES . inverse [ self . menuRole ()]","title":"get_menu_role()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_priority","text":"Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: Type Description str priority Source code in prettyqt/widgets/action.py def get_priority ( self ) -> str : \"\"\"Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: priority \"\"\" return PRIORITIES . inverse [ self . priority ()]","title":"get_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_shortcut_context","text":"Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: Type Description str shortcut context Source code in prettyqt/widgets/action.py def get_shortcut_context ( self ) -> str : \"\"\"Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: shortcut context \"\"\" return CONTEXTS . inverse [ self . shortcutContext ()]","title":"get_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/action.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_menu_role","text":"Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Parameters: Name Type Description Default role str menu role required Exceptions: Type Description InvalidParamError menu role does not exist Source code in prettyqt/widgets/action.py def set_menu_role ( self , role : str ): \"\"\"Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ])","title":"set_menu_role()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_priority","text":"Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Parameters: Name Type Description Default priority str priority for the action required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/widgets/action.py def set_priority ( self , priority : str ): \"\"\"Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ])","title":"set_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_shortcut_context","text":"Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Parameters: Name Type Description Default context str shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/action.py def set_shortcut_context ( self , context : str ): \"\"\"Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in CONTEXTS : raise InvalidParamError ( context , CONTEXTS ) self . setShortcutContext ( CONTEXTS [ context ])","title":"set_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup","text":"","title":"actiongroup"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup","text":"","title":"ActionGroup"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.get_exclusion_policy","text":"Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: Type Description str exclusion policy Source code in prettyqt/widgets/actiongroup.py def get_exclusion_policy ( self ) -> str : \"\"\"Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: exclusion policy \"\"\" return POLICIES . inverse [ self . exclusionPolicy ()]","title":"get_exclusion_policy()"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.set_exclusion_policy","text":"Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Parameters: Name Type Description Default policy Optional[str] exclusion policy to use required Exceptions: Type Description InvalidParamError exclusion policy does not exist Source code in prettyqt/widgets/actiongroup.py def set_exclusion_policy ( self , policy : Optional [ str ]): \"\"\"Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ])","title":"set_exclusion_policy()"},{"location":"api/widgets.html#prettyqt.widgets.application","text":"","title":"application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application","text":"","title":"Application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.get_navigation_mode","text":"Return navigation mode. possible values: \"none\", \"keypad_tab_order\", \"keypad_directional\", \"cursor_auto\", \"cursor_force_visible\" Returns: Type Description str navigation mode Source code in prettyqt/widgets/application.py def get_navigation_mode ( self ) -> str : \"\"\"Return navigation mode. possible values: \"none\", \"keypad_tab_order\", \"keypad_directional\", \"cursor_auto\", \"cursor_force_visible\" Returns: navigation mode \"\"\" return NAVIGATION_MODES . inverse [ self . navigationMode ()]","title":"get_navigation_mode()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.is_effect_enabled","text":"Return desktop effect state. possible values are \"animate_menu\", \"fade_menu\", \"animate_combo\", \"animate_tooltip\", \"fade_tooltip\", \"animate_toolbox\" Returns: Type Description str desktop effect state Source code in prettyqt/widgets/application.py def is_effect_enabled ( self , effect : str ) -> str : \"\"\"Return desktop effect state. possible values are \"animate_menu\", \"fade_menu\", \"animate_combo\", \"animate_tooltip\", \"fade_tooltip\", \"animate_toolbox\" Returns: desktop effect state \"\"\" return self . isEffectEnabled ( UI_EFFECTS [ effect ])","title":"is_effect_enabled()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.set_effect_enabled","text":"Set the enabled state of a desktop effect. valid values are: \"animate_menu\", \"fade_menu\", \"animate_combo\", \"animate_tooltip\", \"fade_tooltip\", \"animate_toolbox\" Parameters: Name Type Description Default effect str desktop effect to set required enabled bool new state True Exceptions: Type Description InvalidParamError invalid desktop effect Source code in prettyqt/widgets/application.py def set_effect_enabled ( self , effect : str , enabled : bool = True ): \"\"\"Set the enabled state of a desktop effect. valid values are: \"animate_menu\", \"fade_menu\", \"animate_combo\", \"animate_tooltip\", \"fade_tooltip\", \"animate_toolbox\" Args: effect: desktop effect to set enabled: new state Raises: InvalidParamError: invalid desktop effect \"\"\" if effect not in UI_EFFECTS : raise InvalidParamError ( effect , UI_EFFECTS ) self . setEffectEnabled ( UI_EFFECTS [ effect ])","title":"set_effect_enabled()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.set_navigation_mode","text":"Set the navigation mode. valid values: \"none\", \"keypad_tab_order\", \"keypad_directional\", \"cursor_auto\", \"cursor_force_visible\" Parameters: Name Type Description Default mode str navigation mode to use required Exceptions: Type Description InvalidParamError invalid navigation mode Source code in prettyqt/widgets/application.py def set_navigation_mode ( self , mode : str ): \"\"\"Set the navigation mode. valid values: \"none\", \"keypad_tab_order\", \"keypad_directional\", \"cursor_auto\", \"cursor_force_visible\" Args: mode: navigation mode to use Raises: InvalidParamError: invalid navigation mode \"\"\" if mode not in NAVIGATION_MODES : raise InvalidParamError ( mode , NAVIGATION_MODES ) self . setNavigationMode ( NAVIGATION_MODES [ mode ])","title":"set_navigation_mode()"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout","text":"","title":"boxlayout"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayout","text":"","title":"BoxLayout"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayout.get_direction","text":"Return current direction. Returns: Type Description Literal['left_to_right', 'right_to_left', 'top_to_bottom', 'bottom_to_top'] direction Source code in prettyqt/widgets/boxlayout.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()]","title":"get_direction()"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayout.set_direction","text":"Set the direction. Parameters: Name Type Description Default direction Literal['left_to_right', 'right_to_left', 'top_to_bottom', 'bottom_to_top'] direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/widgets/boxlayout.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ])","title":"set_direction()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget","text":"","title":"calendarwidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget","text":"","title":"CalendarWidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.get_selection_mode","text":"Return current selection mode. Returns: Type Description Literal['none', 'single'] selection mode Source code in prettyqt/widgets/calendarwidget.py def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.set_selection_mode","text":"Set selection mode for given calendar widget. Parameters: Name Type Description Default mode Optional[Literal['none', 'single']] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/calendarwidget.py def set_selection_mode ( self , mode : Optional [ SelectionModeStr ]): \"\"\"Set selection mode for given calendar widget. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox","text":"","title":"checkbox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox","text":"","title":"CheckBox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.get_checkstate","text":"Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/checkbox.py def get_checkstate ( self ) -> StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return STATE . inverse [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/checkbox.py def set_checkstate ( self , state : StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATE : raise InvalidParamError ( state , STATE ) self . setCheckState ( STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.combobox","text":"","title":"combobox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox","text":"","title":"ComboBox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_insert_policy","text":"Return insert policy. Returns: Type Description Literal['no_insert', 'top', 'current', 'bottom', 'after_current', 'before_current', 'alphabetically'] insert policy Source code in prettyqt/widgets/combobox.py def get_insert_policy ( self ) -> InsertPolicyStr : \"\"\"Return insert policy. Returns: insert policy \"\"\" return INSERT_POLICY . inverse [ self . insertPolicy ()]","title":"get_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_size_adjust_policy","text":"Return size adjust policy. Returns: Type Description Literal['content', 'first_show', 'min_length', 'min_length_with_icon'] size adjust policy Source code in prettyqt/widgets/combobox.py def get_size_adjust_policy ( self ) -> SizeAdjustPolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_ADJUST_POLICY . inverse [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_icon_size","text":"Set size of the icons. Source code in prettyqt/widgets/combobox.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_insert_policy","text":"Set insert policy. Parameters: Name Type Description Default policy Literal['no_insert', 'top', 'current', 'bottom', 'after_current', 'before_current', 'alphabetically'] insert policy to use required Exceptions: Type Description InvalidParamError invalid insert policy Source code in prettyqt/widgets/combobox.py def set_insert_policy ( self , policy : InsertPolicyStr ): \"\"\"Set insert policy. Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICY : raise InvalidParamError ( policy , INSERT_POLICY ) self . setInsertPolicy ( INSERT_POLICY [ policy ])","title":"set_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_size_adjust_policy","text":"Set size adjust policy. Parameters: Name Type Description Default policy Literal['content', 'first_show', 'min_length', 'min_length_with_icon'] size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/combobox.py def set_size_adjust_policy ( self , policy : SizeAdjustPolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_ADJUST_POLICY : raise InvalidParamError ( policy , SIZE_ADJUST_POLICY ) policy = SIZE_ADJUST_POLICY [ policy ] self . setSizeAdjustPolicy ( policy )","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.completer","text":"","title":"completer"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer","text":"","title":"Completer"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_completion_mode","text":"Return current completion mode. Returns: Type Description Literal['popup', 'inline', 'unfiltered_popup'] completion mode Source code in prettyqt/widgets/completer.py def get_completion_mode ( self ) -> CompletionModeStr : \"\"\"Return current completion mode. Returns: completion mode \"\"\" return COMPLETION_MODE . inverse [ self . completionMode ()]","title":"get_completion_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_filter_mode","text":"Return current filter mode. Returns: Type Description Literal['starts_with', 'contains', 'ends_with'] filter mode Source code in prettyqt/widgets/completer.py def get_filter_mode ( self ) -> FilterModeStr : \"\"\"Return current filter mode. Returns: filter mode \"\"\" return FILTER_MODE . inverse [ self . filterMode ()]","title":"get_filter_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_sort_mode","text":"Return current sort mode. Returns: Type Description Literal['unsorted', 'case_sensitive', 'case_insensitive'] sort mode Source code in prettyqt/widgets/completer.py def get_sort_mode ( self ) -> SortModeStr : \"\"\"Return current sort mode. Returns: sort mode \"\"\" return SORT_MODE . inverse [ self . modelSorting ()]","title":"get_sort_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_completion_mode","text":"Set completion mode to use. Parameters: Name Type Description Default mode Literal['popup', 'inline', 'unfiltered_popup'] completion mode to use required Exceptions: Type Description InvalidParamError completion mode does not exist Source code in prettyqt/widgets/completer.py def set_completion_mode ( self , mode : CompletionModeStr ): \"\"\"Set completion mode to use. Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODE : raise InvalidParamError ( mode , COMPLETION_MODE ) self . setCompletionMode ( COMPLETION_MODE [ mode ])","title":"set_completion_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_filter_mode","text":"Set filter mode to use. Parameters: Name Type Description Default mode Literal['starts_with', 'contains', 'ends_with'] filter mode to use required Exceptions: Type Description InvalidParamError filter mode does not exist Source code in prettyqt/widgets/completer.py def set_filter_mode ( self , mode : FilterModeStr ): \"\"\"Set filter mode to use. Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in FILTER_MODE : raise InvalidParamError ( mode , FILTER_MODE ) self . setFilterMode ( FILTER_MODE [ mode ])","title":"set_filter_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_sort_mode","text":"Set sort mode to use. Parameters: Name Type Description Default mode Optional[Literal['unsorted', 'case_sensitive', 'case_insensitive']] sort mode to use required Exceptions: Type Description InvalidParamError sort mode does not exist Source code in prettyqt/widgets/completer.py def set_sort_mode ( self , mode : Optional [ SortModeStr ]): \"\"\"Set sort mode to use. Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODE : raise InvalidParamError ( mode , SORT_MODE ) self . setModelSorting ( SORT_MODE [ mode ])","title":"set_sort_mode()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper","text":"","title":"datawidgetmapper"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper","text":"","title":"DataWidgetMapper"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/datawidgetmapper.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_submit_policy","text":"Return current submit policy. Possible values: \"auto\", \"manual\" Returns: Type Description str submit policy Source code in prettyqt/widgets/datawidgetmapper.py def get_submit_policy ( self ) -> str : \"\"\"Return current submit policy. Possible values: \"auto\", \"manual\" Returns: submit policy \"\"\" return SUBMIT_POLICIES . inverse [ self . submitPolicy ()]","title":"get_submit_policy()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_orientation","text":"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_submit_policy","text":"Set the submit policy of the mapper. Allowed values are \"auto\", \"manual\" Parameters: Name Type Description Default policy str submit_policy for the splitter required Exceptions: Type Description InvalidParamError submit_policy does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_submit_policy ( self , policy : str ): \"\"\"Set the submit policy of the mapper. Allowed values are \"auto\", \"manual\" Args: policy: submit_policy for the splitter Raises: InvalidParamError: submit_policy does not exist \"\"\" if policy not in SUBMIT_POLICIES : raise InvalidParamError ( policy , SUBMIT_POLICIES ) self . setSubmitPolicy ( SUBMIT_POLICIES [ policy ])","title":"set_submit_policy()"},{"location":"api/widgets.html#prettyqt.widgets.dialog","text":"","title":"dialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.BaseDialog","text":"","title":"BaseDialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.BaseDialog.keyPressEvent","text":"keyPressEvent(self, QKeyEvent) Source code in prettyqt/widgets/dialog.py def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e )","title":"keyPressEvent()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox","text":"","title":"dialogbuttonbox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox","text":"","title":"DialogButtonBox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_button","text":"Add a button. Parameters: Name Type Description Default button Union[PyQt5.QtWidgets.QPushButton, str] button to add required role str role of the button 'accept' callback Optional[Callable] function to call when button gets clicked None Returns: Type Description PushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_button ( self , button : Union [ QtWidgets . QPushButton , str ], role : str = \"accept\" , callback : Optional [ Callable ] = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_default_button","text":"Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required callback Optional[Callable] function to call when button gets clicked None Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_default_button ( self , button : str , callback : Optional [ Callable ] = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn","title":"add_default_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.create","text":"create(self, window: sip.voidptr = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) Source code in prettyqt/widgets/dialogbuttonbox.py @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) return box","title":"create()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/dialogbuttonbox.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.set_orientation","text":"Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the button box required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.dockwidget","text":"","title":"dockwidget"},{"location":"api/widgets.html#prettyqt.widgets.dockwidget.DockWidget","text":"Customized DockWidget class. Contains a custom TitleBar with maximise button","title":"DockWidget"},{"location":"api/widgets.html#prettyqt.widgets.filedialog","text":"","title":"filedialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog","text":"Simple dialog used to display some widget.","title":"FileDialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_accept_mode","text":"Return accept mode. Returns: Type Description Literal['save', 'open'] accept mode Source code in prettyqt/widgets/filedialog.py def get_accept_mode ( self ) -> AcceptModeStr : \"\"\"Return accept mode. Returns: accept mode \"\"\" return ACCEPT_MODE . inverse [ self . acceptMode ()]","title":"get_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_directory","text":"Return current directory. returns current directory level as a Pathlib object Returns: Type Description Path Pathlib object Source code in prettyqt/widgets/filedialog.py def get_directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( self . directory () . absolutePath ())","title":"get_directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_file_mode","text":"Return file mode. Returns: Type Description Literal['existing_file', 'existing_files', 'any_file', 'directory'] file mode Source code in prettyqt/widgets/filedialog.py def get_file_mode ( self ) -> FileModeStr : \"\"\"Return file mode. Returns: file mode \"\"\" return FILE_MODE . inverse [ self . fileMode ()]","title":"get_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_label_text","text":"Return label text. Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py def get_label_text ( self , label : LabelStr ) -> str : \"\"\"Return label text. Returns: label text \"\"\" return self . labelText ( LABEL [ label ])","title":"get_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_view_mode","text":"Return view mode. Returns: Type Description Literal['detail', 'list'] view mode Source code in prettyqt/widgets/filedialog.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_accept_mode","text":"Set accept mode. Parameters: Name Type Description Default mode Literal['save', 'open'] accept mode to use required Exceptions: Type Description InvalidParamError invalid accept mode Source code in prettyqt/widgets/filedialog.py def set_accept_mode ( self , mode : AcceptModeStr ): \"\"\"Set accept mode. Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODE : raise InvalidParamError ( mode , ACCEPT_MODE ) self . setAcceptMode ( ACCEPT_MODE [ mode ])","title":"set_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_directory","text":"Set start directory. Source code in prettyqt/widgets/filedialog.py def set_directory ( self , path : Union [ None , str , pathlib . Path ]): \"\"\"Set start directory.\"\"\" if isinstance ( path , pathlib . Path ): path = str ( path ) self . setDirectory ( path )","title":"set_directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_extension_filter","text":"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict Dict[str, List[str]] filter dictionary required Source code in prettyqt/widgets/filedialog.py def set_extension_filter ( self , extension_dict : Dict [ str , List [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str )","title":"set_extension_filter()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_file_mode","text":"Set the file mode of the dialog. Parameters: Name Type Description Default mode Literal['existing_file', 'existing_files', 'any_file', 'directory'] mode to use required Source code in prettyqt/widgets/filedialog.py def set_file_mode ( self , mode : FileModeStr ): \"\"\"Set the file mode of the dialog. Args: mode: mode to use \"\"\" self . setFileMode ( FILE_MODE [ mode ])","title":"set_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_label_text","text":"Set the label text for button label. Parameters: Name Type Description Default label Literal['look_in', 'filename', 'filetype', 'accept'] button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py def set_label_text ( self , label : LabelStr , text : str ): \"\"\"Set the label text for button label. Args: label: button to set text for text: text to use \"\"\" if label not in LABEL : raise InvalidParamError ( label , LABEL ) self . setLabelText ( LABEL [ label ], text )","title":"set_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_view_mode","text":"Set view mode. Parameters: Name Type Description Default mode Literal['detail', 'list'] view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/filedialog.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel","text":"","title":"filesystemmodel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel","text":"Class to populate a filesystem treeview.","title":"FileSystemModel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/widgets/filesystemmodel.py def data ( self , index , role = QtCore . Qt . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role )","title":"data()"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox","text":"","title":"fontcombobox"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox","text":"","title":"FontComboBox"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.get_font_filters","text":"Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: Type Description List[str] font filter list Source code in prettyqt/widgets/fontcombobox.py def get_font_filters ( self ) -> List [ str ]: \"\"\"Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()]","title":"get_font_filters()"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.set_font_filters","text":"Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Parameters: Name Type Description Default filters str font filters to use () Exceptions: Type Description InvalidParamError invalid font filters Source code in prettyqt/widgets/fontcombobox.py def set_font_filters ( self , * filters : str ): \"\"\"Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags )","title":"set_font_filters()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout","text":"","title":"formlayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout","text":"","title":"FormLayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.__len__","text":"Needed for PySide2. Source code in prettyqt/widgets/formlayout.py def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_field_growth_policy","text":"Return current field growth policy. Returns: Type Description FieldGrowthPolicyStr field growth policy Source code in prettyqt/widgets/formlayout.py def get_field_growth_policy ( self ) -> FieldGrowthPolicyStr : \"\"\"Return current field growth policy. Returns: field growth policy \"\"\" return FIELD_GROWTH_POLICY . inverse [ self . fieldGrowthPolicy ()]","title":"get_field_growth_policy()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_row_wrap_policy","text":"Return current row wrap policy. Returns: Type Description RowWrapPolicyStr row wrap policy Source code in prettyqt/widgets/formlayout.py def get_row_wrap_policy ( self ) -> RowWrapPolicyStr : \"\"\"Return current row wrap policy. Returns: row wrap policy \"\"\" return ROW_WRAP_POLICY . inverse [ self . rowWrapPolicy ()]","title":"get_row_wrap_policy()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_field_growth_policy","text":"Set field growth policy to use. Parameters: Name Type Description Default policy FieldGrowthPolicyStr field growth policy to use required Exceptions: Type Description InvalidParamError field growth policy does not exist Source code in prettyqt/widgets/formlayout.py def set_field_growth_policy ( self , policy : FieldGrowthPolicyStr ): \"\"\"Set field growth policy to use. Args: policy: field growth policy to use Raises: InvalidParamError: field growth policy does not exist \"\"\" if policy not in FIELD_GROWTH_POLICY : raise InvalidParamError ( policy , FIELD_GROWTH_POLICY ) self . setFieldGrowthPolicy ( FIELD_GROWTH_POLICY [ policy ])","title":"set_field_growth_policy()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_row_wrap_policy","text":"Set row wrap policy to use. Parameters: Name Type Description Default policy RowWrapPolicyStr row wrap policy to use required Exceptions: Type Description InvalidParamError row wrap policy does not exist Source code in prettyqt/widgets/formlayout.py def set_row_wrap_policy ( self , policy : RowWrapPolicyStr ): \"\"\"Set row wrap policy to use. Args: policy: row wrap policy to use Raises: InvalidParamError: row wrap policy does not exist \"\"\" if policy not in ROW_WRAP_POLICY : raise InvalidParamError ( policy , ROW_WRAP_POLICY ) self . setRowWrapPolicy ( ROW_WRAP_POLICY [ policy ])","title":"set_row_wrap_policy()"},{"location":"api/widgets.html#prettyqt.widgets.frame","text":"","title":"frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame","text":"","title":"Frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.get_frame_shadow","text":"Return current frame shadow. Returns: Type Description Literal['plain', 'raised', 'sunken'] frame style Source code in prettyqt/widgets/frame.py def get_frame_shadow ( self ) -> ShadowStr : \"\"\"Return current frame shadow. Returns: frame style \"\"\" return SHADOW . inverse [ self . frameShadow ()]","title":"get_frame_shadow()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.get_frame_shape","text":"Return current frame shape. Returns: Type Description Literal['no_frame', 'box', 'panel', 'styled_panel', 'h_line', 'v_line', 'win_panel'] frame shape Source code in prettyqt/widgets/frame.py def get_frame_shape ( self ) -> FrameShapeStr : \"\"\"Return current frame shape. Returns: frame shape \"\"\" return FRAME_SHAPE . inverse [ self . frameShape ()]","title":"get_frame_shape()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.set_frame_shadow","text":"Set frame shadow. Parameters: Name Type Description Default style Literal['plain', 'raised', 'sunken'] frame style to use required Exceptions: Type Description InvalidParamError style does not exist Source code in prettyqt/widgets/frame.py def set_frame_shadow ( self , style : ShadowStr ): \"\"\"Set frame shadow. Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style not in SHADOW : raise InvalidParamError ( style , SHADOW ) self . setFrameShadow ( SHADOW [ style ])","title":"set_frame_shadow()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.set_frame_shape","text":"Set frame shape. Parameters: Name Type Description Default shape Literal['no_frame', 'box', 'panel', 'styled_panel', 'h_line', 'v_line', 'win_panel'] frame shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/widgets/frame.py def set_frame_shape ( self , shape : FrameShapeStr ): \"\"\"Set frame shape. Args: shape: frame shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in FRAME_SHAPE : raise InvalidParamError ( shape , FRAME_SHAPE ) self . setFrameShape ( FRAME_SHAPE [ shape ])","title":"set_frame_shape()"},{"location":"api/widgets.html#prettyqt.widgets.gesture","text":"","title":"gesture"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture","text":"","title":"Gesture"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.get_gesture_cancel_policy","text":"Return current gesture cancel policy. Returns: Type Description Literal['none', 'all_in_context'] gesture cancel policy Source code in prettyqt/widgets/gesture.py def get_gesture_cancel_policy ( self ) -> GestureCancelPolicyStr : \"\"\"Return current gesture cancel policy. Returns: gesture cancel policy \"\"\" return GESTURE_CANCEL_POLICY . inverse [ self . gestureCancelPolicy ()]","title":"get_gesture_cancel_policy()"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.get_gesture_type","text":"Return current gesture type. Returns: Type Description Literal['tap', 'tap_and_hold', 'pan', 'pinch', 'swipe', 'custom'] gesture type Source code in prettyqt/widgets/gesture.py def get_gesture_type ( self ) -> GestureTypeStr : \"\"\"Return current gesture type. Returns: gesture type \"\"\" return GESTURE_TYPE . inverse [ self . gestureType ()]","title":"get_gesture_type()"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.get_state","text":"Return current state. Returns: Type Description Literal['none', 'started', 'updated', 'finished', 'canceled'] state Source code in prettyqt/widgets/gesture.py def get_state ( self ) -> GestureStateStr : \"\"\"Return current state. Returns: state \"\"\" return GESTURE_STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.set_gesture_cancel_policy","text":"Set gesture cancel policy. Parameters: Name Type Description Default policy Literal['none', 'all_in_context'] gesture cancel policy to use required Exceptions: Type Description InvalidParamError gesture cancel policy does not exist Source code in prettyqt/widgets/gesture.py def set_gesture_cancel_policy ( self , policy : GestureCancelPolicyStr ): \"\"\"Set gesture cancel policy. Args: policy: gesture cancel policy to use Raises: InvalidParamError: gesture cancel policy does not exist \"\"\" if policy not in GESTURE_CANCEL_POLICY : raise InvalidParamError ( policy , GESTURE_CANCEL_POLICY ) self . setGestureCancelPolicy ( GESTURE_CANCEL_POLICY [ policy ])","title":"set_gesture_cancel_policy()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem","text":"","title":"graphicsitem"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem","text":"","title":"GraphicsItem"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem.get_panel_modality","text":"Get the current modality modes as a string. Returns: Type Description Literal['none', 'panel', 'scene'] panel modality Source code in prettyqt/widgets/graphicsitem.py def get_panel_modality ( self ) -> PanelModalityStr : \"\"\"Get the current modality modes as a string. Returns: panel modality \"\"\" return MODALITY . inverse [ self . panelModality ()]","title":"get_panel_modality()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem.set_panel_modality","text":"Set panel modality. Parameters: Name Type Description Default modality Literal['none', 'panel', 'scene'] panel modality required Exceptions: Type Description InvalidParamError panel modality does not exist Source code in prettyqt/widgets/graphicsitem.py def set_panel_modality ( self , modality : PanelModalityStr ) -> None : \"\"\"Set panel modality. Args: modality: panel modality Raises: InvalidParamError: panel modality does not exist \"\"\" if modality not in MODALITY : raise InvalidParamError ( modality , MODALITY ) self . setPanelModality ( MODALITY [ modality ])","title":"set_panel_modality()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene","text":"","title":"graphicsscene"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene","text":"","title":"GraphicsScene"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.get_item_index_method","text":"Return item index method. Returns: Type Description Literal['bsp_tree', 'none'] item index method Source code in prettyqt/widgets/graphicsscene.py def get_item_index_method ( self ) -> ItemIndexMethodStr : \"\"\"Return item index method. Returns: item index method \"\"\" return ITEM_INDEX_METHOD . inverse [ self . itemIndexMethod ()]","title":"get_item_index_method()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.set_item_index_method","text":"Set item index method. Parameters: Name Type Description Default method Literal['bsp_tree', 'none'] item index method to use required Exceptions: Type Description InvalidParamError invalid item index method Source code in prettyqt/widgets/graphicsscene.py def set_item_index_method ( self , method : ItemIndexMethodStr ): \"\"\"Set item index method. Args: method: item index method to use Raises: InvalidParamError: invalid item index method \"\"\" if method not in ITEM_INDEX_METHOD : raise InvalidParamError ( method , ITEM_INDEX_METHOD ) self . setItemIndexMethod ( ITEM_INDEX_METHOD [ method ])","title":"set_item_index_method()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview","text":"","title":"graphicsview"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView","text":"","title":"GraphicsView"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_cache_mode","text":"Return current cache mode. Returns: Type Description Literal['none', 'background'] cache mode Source code in prettyqt/widgets/graphicsview.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Return current cache mode. Returns: cache mode \"\"\" return CACHE_MODES . inverse [ self . cacheMode ()]","title":"get_cache_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_drag_mode","text":"Return current drag mode. Returns: Type Description Literal['none', 'scroll_hand', 'rubber_band'] drag mode Source code in prettyqt/widgets/graphicsview.py def get_drag_mode ( self ) -> DragModeStr : \"\"\"Return current drag mode. Returns: drag mode \"\"\" return DRAG_MODE . inverse [ self . dragMode ()]","title":"get_drag_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_resize_anchor","text":"Return current resize anchor. Returns: Type Description Literal['none', 'scroll_hand', 'rubber_band'] resize anchor Source code in prettyqt/widgets/graphicsview.py def get_resize_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current resize anchor. Returns: resize anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . resizeAnchor ()]","title":"get_resize_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_rubberband_selection_mode","text":"Return current rubberband selection mode. Returns: Type Description Literal['contains_shape', 'intersects_shape', 'contains_bounding_rect', 'intersects_bounding_rect'] rubberband selection mode Source code in prettyqt/widgets/graphicsview.py def get_rubberband_selection_mode ( self ) -> ItemSelectionModeStr : \"\"\"Return current rubberband selection mode. Returns: rubberband selection mode \"\"\" return ITEM_SELECTION_MODE . inverse [ self . rubberBandSelectionMode ()]","title":"get_rubberband_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_transformation_anchor","text":"Return current transformation anchor. Returns: Type Description Literal['none', 'scroll_hand', 'rubber_band'] viewport anchor Source code in prettyqt/widgets/graphicsview.py def get_transformation_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current transformation anchor. Returns: viewport anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . transformationAnchor ()]","title":"get_transformation_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_viewport_update_mode","text":"Return current viewport update mode. Returns: Type Description Literal['full', 'minimal', 'smart', 'bounding_rect', 'none'] viewport update mode Source code in prettyqt/widgets/graphicsview.py def get_viewport_update_mode ( self ) -> ViewportUpdateModeStr : \"\"\"Return current viewport update mode. Returns: viewport update mode \"\"\" return VIEWPORT_UPDATE_MODE . inverse [ self . viewportUpdateMode ()]","title":"get_viewport_update_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_cache_mode","text":"Set the cache mode. Parameters: Name Type Description Default mode Literal['none', 'background'] cache mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set the cache mode. Args: mode: cache mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ])","title":"set_cache_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_drag_mode","text":"Set the behavior for dragging the mouse while the left mouse button is pressed. Parameters: Name Type Description Default mode Literal['none', 'scroll_hand', 'rubber_band'] drag mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_drag_mode ( self , mode : DragModeStr ): \"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed. Args: mode: drag mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_MODE : raise InvalidParamError ( mode , DRAG_MODE ) self . setDragMode ( DRAG_MODE [ mode ])","title":"set_drag_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_resize_anchor","text":"Set how the view should position the scene during resizes. Parameters: Name Type Description Default mode Literal['none', 'scroll_hand', 'rubber_band'] resize anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_resize_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during resizes. Args: mode: resize anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setResizeAnchor ( VIEWPORT_ANCHOR [ mode ])","title":"set_resize_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_rubberband_selection_mode","text":"Set the behavior for selecting items with a rubber band selection rectangle. Parameters: Name Type Description Default mode Literal['contains_shape', 'intersects_shape', 'contains_bounding_rect', 'intersects_bounding_rect'] rubberband selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_rubberband_selection_mode ( self , mode : ItemSelectionModeStr ): \"\"\"Set the behavior for selecting items with a rubber band selection rectangle. Args: mode: rubberband selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in ITEM_SELECTION_MODE : raise InvalidParamError ( mode , ITEM_SELECTION_MODE ) self . setRubberBandSelectionMode ( ITEM_SELECTION_MODE [ mode ])","title":"set_rubberband_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_transformation_anchor","text":"Set how the view should position the scene during transformations. Parameters: Name Type Description Default mode Literal['none', 'scroll_hand', 'rubber_band'] transformation anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_transformation_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during transformations. Args: mode: transformation anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setTransformationAnchor ( VIEWPORT_ANCHOR [ mode ])","title":"set_transformation_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_viewport_update_mode","text":"Set how the viewport should update its contents. Parameters: Name Type Description Default mode Literal['full', 'minimal', 'smart', 'bounding_rect', 'none'] viewport update mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_viewport_update_mode ( self , mode : ViewportUpdateModeStr ): \"\"\"Set how the viewport should update its contents. Args: mode: viewport update mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_UPDATE_MODE : raise InvalidParamError ( mode , VIEWPORT_UPDATE_MODE ) self . setViewportUpdateMode ( VIEWPORT_UPDATE_MODE [ mode ])","title":"set_viewport_update_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget","text":"","title":"graphicswidget"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget","text":"","title":"GraphicsWidget"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget.get_focus_policy","text":"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: Type Description str str: Focus policy Source code in prettyqt/widgets/graphicswidget.py def get_focus_policy ( self ) -> str : \"\"\"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: str: Focus policy \"\"\" return FOCUS_POLICIES . inverse [ self . focusPolicy ()]","title":"get_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget.set_focus_policy","text":"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Parameters: Name Type Description Default policy str Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/graphicswidget.py def set_focus_policy ( self , policy : str ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in FOCUS_POLICIES : raise InvalidParamError ( policy , FOCUS_POLICIES ) self . setFocusPolicy ( FOCUS_POLICIES [ policy ])","title":"set_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout","text":"","title":"gridlayout"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout","text":"","title":"GridLayout"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.get_origin_corner","text":"Return current origin corner. Returns: Type Description Literal['top_left', 'top_right', 'bottom_left', 'bottom_right'] origin corner Source code in prettyqt/widgets/gridlayout.py def get_origin_corner ( self ) -> CornerStr : \"\"\"Return current origin corner. Returns: origin corner \"\"\" return CORNER . inverse [ self . originCorner ()]","title":"get_origin_corner()"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.set_origin_corner","text":"Set the origin corner. Parameters: Name Type Description Default corner Literal['top_left', 'top_right', 'bottom_left', 'bottom_right'] origin corner required Exceptions: Type Description InvalidParamError corner does not exist Source code in prettyqt/widgets/gridlayout.py def set_origin_corner ( self , corner : CornerStr ): \"\"\"Set the origin corner. Args: corner: origin corner Raises: InvalidParamError: corner does not exist \"\"\" if corner not in CORNER : raise InvalidParamError ( corner , CORNER ) self . setOriginCorner ( CORNER [ corner ])","title":"set_origin_corner()"},{"location":"api/widgets.html#prettyqt.widgets.groupbox","text":"","title":"groupbox"},{"location":"api/widgets.html#prettyqt.widgets.groupbox.GroupBox","text":"GroupBox widget. A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets.","title":"GroupBox"},{"location":"api/widgets.html#prettyqt.widgets.headerview","text":"","title":"headerview"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView","text":"","title":"HeaderView"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView.contextMenuEvent","text":"Context menu for our files tree. Source code in prettyqt/widgets/headerview.py def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) actions = self . get_header_actions () menu . add_actions ( actions ) menu . exec_ ( self . mapToGlobal ( event . pos ()))","title":"contextMenuEvent()"},{"location":"api/widgets.html#prettyqt.widgets.label","text":"","title":"label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label","text":"","title":"Label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_format","text":"Return current text format. Returns: Type Description TextFormatStr text format Source code in prettyqt/widgets/label.py def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_interaction","text":"Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: Type Description List[str] list of text interaction modes Source code in prettyqt/widgets/label.py def get_text_interaction ( self ) -> List [ str ]: \"\"\"Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()]","title":"get_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_alignment","text":"Set the alignment of the label's contents. Source code in prettyqt/widgets/label.py def set_alignment ( self , horizontal : Optional [ str ] = None , vertical : Optional [ str ] = None ): \"\"\"Set the alignment of the label's contents.\"\"\" if horizontal is None and vertical is not None : flag = V_ALIGNMENTS [ vertical ] elif vertical is None and horizontal is not None : flag = H_ALIGNMENTS [ horizontal ] elif vertical is not None and horizontal is not None : flag = V_ALIGNMENTS [ vertical ] | H_ALIGNMENTS [ horizontal ] else : return self . setAlignment ( flag ) return self","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_indent","text":"Set the label's text indent in pixels. Source code in prettyqt/widgets/label.py def set_indent ( self , indent : int ) -> Label : \"\"\"Set the label's text indent in pixels.\"\"\" self . setIndent ( indent ) return self","title":"set_indent()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text","text":"Set the label's text. Source code in prettyqt/widgets/label.py def set_text ( self , text : str ) -> Label : \"\"\"Set the label's text.\"\"\" self . setText ( text ) return self","title":"set_text()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_format","text":"Set the text format. Parameters: Name Type Description Default text_format TextFormatStr text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/label.py def set_text_format ( self , text_format : TextFormatStr ) -> Label : \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) return self","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_interaction","text":"Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Parameters: Name Type Description Default types str text interaction mode to use () Exceptions: Type Description InvalidParamError text interaction mode does not exist Source code in prettyqt/widgets/label.py def set_text_interaction ( self , * types : str ) -> Label : \"\"\"Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self","title":"set_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_weight","text":"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/widgets/label.py def set_weight ( self , weight : str ) -> Label : \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHTS : raise InvalidParamError ( weight , gui . font . WEIGHTS ) font = self . font () font . setWeight ( gui . font . WEIGHTS [ weight ]) self . setFont ( font ) return self","title":"set_weight()"},{"location":"api/widgets.html#prettyqt.widgets.layout","text":"","title":"layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout","text":"","title":"Layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.get_size_mode","text":"Return current size mode. Returns: Type Description Literal['default', 'fixed', 'minimum', 'maximum', 'min_and_max', 'none'] size mode Source code in prettyqt/widgets/layout.py def get_size_mode ( self ) -> SizeConstraintStr : \"\"\"Return current size mode. Returns: size mode \"\"\" return SIZE_CONSTRAINT . inverse [ self . sizeConstraint ()]","title":"get_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_alignment","text":"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Parameters: Name Type Description Default alignment Literal['left', 'right', 'top', 'bottom'] alignment for the layout required item Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] set alignment for specific child only None Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layout.py def set_alignment ( self , alignment : AlignmentStr , item : Optional [ Union [ QtWidgets . QWidget , QtWidgets . QLayout ]] = None , ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) if item is not None : return self . setAlignment ( item , ALIGNMENTS [ alignment ]) else : return self . setAlignment ( ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_size_mode","text":"Set the size mode of the layout. Parameters: Name Type Description Default mode Literal['default', 'fixed', 'minimum', 'maximum', 'min_and_max', 'none'] size mode for the layout required Exceptions: Type Description InvalidParamError size mode does not exist Source code in prettyqt/widgets/layout.py def set_size_mode ( self , mode : SizeConstraintStr ): \"\"\"Set the size mode of the layout. Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in SIZE_CONSTRAINT : raise InvalidParamError ( mode , SIZE_CONSTRAINT ) self . setSizeConstraint ( SIZE_CONSTRAINT [ mode ])","title":"set_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber","text":"","title":"lcdnumber"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber","text":"","title":"LCDNumber"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_mode","text":"Return current lcd mode. Returns: Type Description Literal['hex', 'decimal', 'octal', 'binary'] lcd mode Source code in prettyqt/widgets/lcdnumber.py def get_mode ( self ) -> ModeStr : \"\"\"Return current lcd mode. Returns: lcd mode \"\"\" return MODE . inverse [ self . mode ()]","title":"get_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_segment_style","text":"Return current segment style. Returns: Type Description Literal['outline', 'filled', 'flat'] segment style Source code in prettyqt/widgets/lcdnumber.py def get_segment_style ( self ) -> SegmentStyleStr : \"\"\"Return current segment style. Returns: segment style \"\"\" return SEGMENT_STYLE . inverse [ self . segmentStyle ()]","title":"get_segment_style()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_mode","text":"Set the lcd mode. Parameters: Name Type Description Default mode Literal['hex', 'decimal', 'octal', 'binary'] lcd mode to use required Exceptions: Type Description InvalidParamError lcd mode does not exist Source code in prettyqt/widgets/lcdnumber.py def set_mode ( self , mode : ModeStr ): \"\"\"Set the lcd mode. Args: mode: lcd mode to use Raises: InvalidParamError: lcd mode does not exist \"\"\" if mode not in MODE : raise InvalidParamError ( mode , MODE ) self . setMode ( MODE [ mode ])","title":"set_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_segment_style","text":"Set the segment style. Parameters: Name Type Description Default mode Literal['outline', 'filled', 'flat'] segment style to use required Exceptions: Type Description InvalidParamError segment style does not exist Source code in prettyqt/widgets/lcdnumber.py def set_segment_style ( self , mode : SegmentStyleStr ): \"\"\"Set the segment style. Args: mode: segment style to use Raises: InvalidParamError: segment style does not exist \"\"\" if mode not in SEGMENT_STYLE : raise InvalidParamError ( mode , SEGMENT_STYLE ) self . setSegmentStyle ( SEGMENT_STYLE [ mode ])","title":"set_segment_style()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit","text":"","title":"lineedit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit","text":"","title":"LineEdit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.font","text":"font(self) -> QFont Source code in prettyqt/widgets/lineedit.py def font ( self ) -> gui . Font : return gui . Font ( super () . font ())","title":"font()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_echo_mode","text":"Return echo mode. Returns: Type Description Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode Source code in prettyqt/widgets/lineedit.py def get_echo_mode ( self ) -> EchoModeStr : \"\"\"Return echo mode. Returns: echo mode \"\"\" return ECHO_MODES . inverse [ self . echoMode ()]","title":"get_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_echo_mode","text":"Set echo mode. Parameters: Name Type Description Default mode Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/lineedit.py def set_echo_mode ( self , mode : EchoModeStr ): \"\"\"Set echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODES : raise InvalidParamError ( mode , ECHO_MODES ) self . setEchoMode ( ECHO_MODES [ mode ])","title":"set_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_read_only","text":"Set text to read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.listview","text":"","title":"listview"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView","text":"","title":"ListView"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_view_mode","text":"Return view mode. possible values are \"list\", \"icon\" Returns: Type Description str view mode Source code in prettyqt/widgets/listview.py def get_view_mode ( self ) -> str : \"\"\"Return view mode. possible values are \"list\", \"icon\" Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_view_mode","text":"Set view mode. possible values are \"list\", \"icon\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/listview.py def set_view_mode ( self , mode : str ): \"\"\"Set view mode. possible values are \"list\", \"icon\" Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem","text":"","title":"listwidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem","text":"","title":"ListWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.get_checkstate","text":"Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/listwidgetitem.py def get_checkstate ( self ) -> StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return STATE . inverse [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py def set_checkstate ( self , state : StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATE : raise InvalidParamError ( state , STATE ) self . setCheckState ( STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/listwidgetitem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow","text":"","title":"mainwindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow","text":"Class for our mainWindow. Includes all docks, a centralwidget and a toolbar","title":"MainWindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar","text":"Adds a toolbar to the mainmenu at specified area. Parameters: Name Type Description Default toolbar QToolBar toolbar to use required position Literal['top', 'bottom', 'left', 'right', 'all', 'none'] position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBar ( TOOLBAR_AREAS [ position ], toolbar )","title":"add_toolbar()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar_break","text":"Adds a toolbar break to the given area behind the last item. Parameters: Name Type Description Default position Literal['top', 'bottom', 'left', 'right', 'all', 'none'] position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar_break ( self , position : ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBarBreak ( TOOLBAR_AREAS [ position ])","title":"add_toolbar_break()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.createPopupMenu","text":"createPopupMenu(self) -> QMenu Source code in prettyqt/widgets/mainwindow.py def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add ( action ) return menu","title":"createPopupMenu()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.save_window_state","text":"Save current window state as QSetting. Parameters: Name Type Description Default recursive bool Description False Source code in prettyqt/widgets/mainwindow.py def save_window_state ( self , recursive : bool = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { self . windowTitle () !r} ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state ()","title":"save_window_state()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.toggle_fullscreen","text":"Toggle between fullscreen and regular size. Source code in prettyqt/widgets/mainwindow.py def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen ()","title":"toggle_fullscreen()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea","text":"","title":"mdiarea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea","text":"","title":"MdiArea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_tab_position","text":"Return current tab position. Returns: Type Description Literal['north', 'south', 'west', 'east'] tab position Source code in prettyqt/widgets/mdiarea.py def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return current tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()]","title":"get_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_view_mode","text":"Return current view mode. Returns: Type Description Literal['default', 'tabbed'] view mode Source code in prettyqt/widgets/mdiarea.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return current view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_window_order","text":"Return current window order. Returns: Type Description Literal['creation', 'stacking', 'activation_history'] view mode Source code in prettyqt/widgets/mdiarea.py def get_window_order ( self ) -> WindowOrderStr : \"\"\"Return current window order. Returns: view mode \"\"\" return WINDOW_ORDER . inverse [ self . activationOrder ()]","title":"get_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_tab_position","text":"Set tab position for the MDI area. Parameters: Name Type Description Default position Literal['north', 'south', 'west', 'east'] tabs position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/mdiarea.py def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the MDI area. Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ])","title":"set_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_view_mode","text":"Set view mode for the MDI area. Parameters: Name Type Description Default mode Literal['default', 'tabbed'] view mode to use required Exceptions: Type Description InvalidParamError view mode does not exist Source code in prettyqt/widgets/mdiarea.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode for the MDI area. Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_window_order","text":"Set the window order behaviour for the MDI area. Parameters: Name Type Description Default mode Literal['creation', 'stacking', 'activation_history'] window order behaviour to use required Exceptions: Type Description InvalidParamError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py def set_window_order ( self , mode : WindowOrderStr ): \"\"\"Set the window order behaviour for the MDI area. Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDER : raise InvalidParamError ( mode , WINDOW_ORDER ) self . setActivationOrder ( WINDOW_ORDER [ mode ])","title":"set_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.menu","text":"","title":"menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu","text":"","title":"Menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_action","text":"Add an action to the menu. Parameters: Name Type Description Default label Union[str, prettyqt.widgets.action.Action] Label for button required callback Callable gets called when action is triggered None icon Optional[Any] icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut Optional[str] Shortcut for action None status_tip Optional[str] Status tip to be shown in status bar None Returns: Type Description Action Action added to menu Source code in prettyqt/widgets/menu.py def add_action ( self , label : Union [ str , widgets . Action ], callback : Callable = None , icon : Optional [ Any ] = None , checkable : bool = False , checked : bool = False , shortcut : Optional [ str ] = None , status_tip : Optional [ str ] = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action","title":"add_action()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_separator","text":"Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None Returns: Type Description WidgetAction Separator action Source code in prettyqt/widgets/menu.py def add_separator ( self , text : Optional [ str ] = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.set_icon","text":"Set the icon for the menu. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/menu.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox","text":"","title":"messagebox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox","text":"","title":"MessageBox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.add_button","text":"Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/messagebox.py def add_button ( self , button : str ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ])","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.get_text_format","text":"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/messagebox.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_icon","text":"Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/messagebox.py def set_icon ( self , icon : gui . icon . IconType ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) return None icon = gui . icon . get_icon ( icon ) self . setIconPixmap ( icon . get_pixmap ( size = 64 ))","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_text_format","text":"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/messagebox.py def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ])","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit","text":"","title":"plaintextedit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit","text":"","title":"PlainTextEdit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.get_line_wrap_mode","text":"Get the current wrap mode. Returns: Type Description Literal['none', 'widget_width'] Wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()]","title":"get_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.get_wrap_mode","text":"Get the current word wrap mode. Returns: Type Description str Word wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_wrap_mode ( self ) -> str : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return WRAP_MODE . inverse [ self . wordWrapMode ()]","title":"get_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_line_wrap_mode","text":"Set line wrap mode. Parameters: Name Type Description Default mode Literal['none', 'widget_width'] line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ])","title":"set_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_read_only","text":"Make the PlainTextEdit read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_wrap_mode","text":"Set word wrap mode. Parameters: Name Type Description Default mode Literal['none', 'word', 'anywhere', 'boundary_or_anywhere'] word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_wrap_mode ( self , mode : WrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in WRAP_MODE : raise InvalidParamError ( mode , WRAP_MODE ) self . setWordWrapMode ( WRAP_MODE [ mode ])","title":"set_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.wheelEvent","text":"Handle wheel event for zooming. Source code in prettyqt/widgets/plaintextedit.py def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event )","title":"wheelEvent()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar","text":"","title":"progressbar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar","text":"Progress dialog. wrapper for QtWidgets.QProgressBar","title":"ProgressBar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_alignment","text":"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description str alignment Source code in prettyqt/widgets/progressbar.py def get_alignment ( self ) -> str : \"\"\"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" return ALIGNMENTS . inverse [ self . alignment ()]","title":"get_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/progressbar.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_text_direction","text":"Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Type Description str Text direction Source code in prettyqt/widgets/progressbar.py def get_text_direction ( self ) -> str : \"\"\"Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inverse [ self . textDirection ()]","title":"get_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_alignment","text":"Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/progressbar.py def set_alignment ( self , alignment : str ): \"\"\"Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) self . setAlignment ( ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_orientation","text":"Set the orientation of the progress bar. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the progress bar required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/progressbar.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the progress bar. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the progress bar Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_text_direction","text":"Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Parameters: Name Type Description Default text_direction str text direction for the layout required Exceptions: Type Description InvalidParamError text direction does not exist Source code in prettyqt/widgets/progressbar.py def set_text_direction ( self , text_direction : str ): \"\"\"Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ])","title":"set_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.progressdialog","text":"","title":"progressdialog"},{"location":"api/widgets.html#prettyqt.widgets.progressdialog.ProgressDialog","text":"Progress dialog. Wrapper for QtWidgets.QProgressDialog","title":"ProgressDialog"},{"location":"api/widgets.html#prettyqt.widgets.scroller","text":"","title":"scroller"},{"location":"api/widgets.html#prettyqt.widgets.scroller.Scroller","text":"","title":"Scroller"},{"location":"api/widgets.html#prettyqt.widgets.scroller.Scroller.get_state","text":"Return current state. Possible values: \"inactive\", \"pressed\", \"dragging\", \"scrolling\" Returns: Type Description str state Source code in prettyqt/widgets/scroller.py def get_state ( self ) -> str : \"\"\"Return current state. Possible values: \"inactive\", \"pressed\", \"dragging\", \"scrolling\" Returns: state \"\"\" return STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties","text":"","title":"scrollerproperties"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties","text":"","title":"ScrollerProperties"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.get_scroll_metric","text":"Return scroll metric. Possible values: \"mouse_press_event_delay\", \"drag_start_distance\", \"drag_velocity_smoothing_factor\", \"axis_lock_threshold\", \"scrolling_curve\", \"deceleration_factor\", \"minimum_velocity\", \"maximum_velocity\", \"maximum_click_through_velocity\", \"accelerating_flick_maximum_time\", \"accelerating_flick_speedup_factor\", \"snap_position_ratio\", \"snap_time\", \"overshoot_drag_resistance_factor\", \"overshoot_drag_distance_factor\", \"overshoot_scroll_distance_factor\", \"overshoot_scroll_time\", \"horizontal_overshoot_policy\", \"vertical_overshoot_policy\", \"frame_rate\", \"scroll_metric_count\" Parameters: Name Type Description Default metric str Scroll metric to get required Exceptions: Type Description InvalidParamError metric does not exist Returns: Type Description Any state Source code in prettyqt/widgets/scrollerproperties.py def get_scroll_metric ( self , metric : str ) -> Any : \"\"\"Return scroll metric. Possible values: \"mouse_press_event_delay\", \"drag_start_distance\", \"drag_velocity_smoothing_factor\", \"axis_lock_threshold\", \"scrolling_curve\", \"deceleration_factor\", \"minimum_velocity\", \"maximum_velocity\", \"maximum_click_through_velocity\", \"accelerating_flick_maximum_time\", \"accelerating_flick_speedup_factor\", \"snap_position_ratio\", \"snap_time\", \"overshoot_drag_resistance_factor\", \"overshoot_drag_distance_factor\", \"overshoot_scroll_distance_factor\", \"overshoot_scroll_time\", \"horizontal_overshoot_policy\", \"vertical_overshoot_policy\", \"frame_rate\", \"scroll_metric_count\" Args: metric: Scroll metric to get Raises: InvalidParamError: metric does not exist Returns: state \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) return self . scrollMetric ( SCROLL_METRIC [ metric ])","title":"get_scroll_metric()"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.set_scroll_metric","text":"Set scroll metric. Possible values: \"mouse_press_event_delay\", \"drag_start_distance\", \"drag_velocity_smoothing_factor\", \"axis_lock_threshold\", \"scrolling_curve\", \"deceleration_factor\", \"minimum_velocity\", \"maximum_velocity\", \"maximum_click_through_velocity\", \"accelerating_flick_maximum_time\", \"accelerating_flick_speedup_factor\", \"snap_position_ratio\", \"snap_time\", \"overshoot_drag_resistance_factor\", \"overshoot_drag_distance_factor\", \"overshoot_scroll_distance_factor\", \"overshoot_scroll_time\", \"horizontal_overshoot_policy\", \"vertical_overshoot_policy\", \"frame_rate\", \"scroll_metric_count\" Parameters: Name Type Description Default metric str Scroll metric to set required value Any Value to set required Exceptions: Type Description InvalidParamError metric does not exist Source code in prettyqt/widgets/scrollerproperties.py def set_scroll_metric ( self , metric : str , value : Any ): \"\"\"Set scroll metric. Possible values: \"mouse_press_event_delay\", \"drag_start_distance\", \"drag_velocity_smoothing_factor\", \"axis_lock_threshold\", \"scrolling_curve\", \"deceleration_factor\", \"minimum_velocity\", \"maximum_velocity\", \"maximum_click_through_velocity\", \"accelerating_flick_maximum_time\", \"accelerating_flick_speedup_factor\", \"snap_position_ratio\", \"snap_time\", \"overshoot_drag_resistance_factor\", \"overshoot_drag_distance_factor\", \"overshoot_scroll_distance_factor\", \"overshoot_scroll_time\", \"horizontal_overshoot_policy\", \"vertical_overshoot_policy\", \"frame_rate\", \"scroll_metric_count\" Args: metric: Scroll metric to set value: Value to set Raises: InvalidParamError: metric does not exist \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) self . setScrollMetric ( SCROLL_METRIC [ metric ], value )","title":"set_scroll_metric()"},{"location":"api/widgets.html#prettyqt.widgets.shortcut","text":"","title":"shortcut"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut","text":"","title":"Shortcut"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.get_context","text":"Return shortcut context. Returns: Type Description Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context Source code in prettyqt/widgets/shortcut.py def get_context ( self ) -> ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return CONTEXT . inverse [ self . context ()]","title":"get_context()"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.get_key","text":"Return the shortcut's key sequence. Returns: Type Description KeySequence Key sequence Source code in prettyqt/widgets/shortcut.py def get_key ( self ) -> gui . KeySequence : \"\"\"Return the shortcut's key sequence. Returns: Key sequence \"\"\" return gui . KeySequence ( self . key ())","title":"get_key()"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.set_context","text":"Set shortcut context. Parameters: Name Type Description Default context Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/shortcut.py def set_context ( self , context : ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in CONTEXT : raise InvalidParamError ( context , CONTEXT ) self . setContext ( CONTEXT [ context ])","title":"set_context()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy","text":"","title":"sizepolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy","text":"","title":"SizePolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_control_type","text":"Return control type. Returns: Type Description Literal['default', 'buttonbox', 'checkbox', 'combobox', 'frame', 'groupbox', 'label', 'line', 'lineedit', 'pushbutton', 'radiobutton', 'slider', 'spinbox', 'tabwidget', 'toolbutton'] control type Source code in prettyqt/widgets/sizepolicy.py def get_control_type ( self ) -> ControlTypeStr : \"\"\"Return control type. Returns: control type \"\"\" return CONTROL_TYPE . inverse [ self . controlType ()]","title":"get_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_horizontal_policy","text":"Return size policy. Returns: Type Description Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] horizontal size policy Source code in prettyqt/widgets/sizepolicy.py def get_horizontal_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: horizontal size policy \"\"\" return SIZE_POLICY . inverse [ self . horizontalPolicy ()]","title":"get_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_vertical_policy","text":"Return size policy. Returns: Type Description Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] vertical size policy Source code in prettyqt/widgets/sizepolicy.py def get_vertical_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: vertical size policy \"\"\" return SIZE_POLICY . inverse [ self . verticalPolicy ()]","title":"get_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_control_type","text":"Set the control type. Parameters: Name Type Description Default typ Literal['default', 'buttonbox', 'checkbox', 'combobox', 'frame', 'groupbox', 'label', 'line', 'lineedit', 'pushbutton', 'radiobutton', 'slider', 'spinbox', 'tabwidget', 'toolbutton'] control type to set required Exceptions: Type Description InvalidParamError control type does not exist Source code in prettyqt/widgets/sizepolicy.py def set_control_type ( self , typ : ControlTypeStr ) -> None : \"\"\"Set the control type. Args: typ: control type to set Raises: InvalidParamError: control type does not exist \"\"\" if typ not in CONTROL_TYPE : raise InvalidParamError ( typ , CONTROL_TYPE ) self . setControlType ( CONTROL_TYPE [ typ ])","title":"set_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_horizontal_policy","text":"Set the horizontal policy. Parameters: Name Type Description Default policy Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_horizontal_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setHorizontalPolicy ( SIZE_POLICY [ policy ])","title":"set_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_vertical_policy","text":"Set the horizontal policy. Parameters: Name Type Description Default policy Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_vertical_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setVerticalPolicy ( SIZE_POLICY [ policy ])","title":"set_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.slider","text":"","title":"slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider","text":"","title":"Slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.get_tick_position","text":"Return tick position. Returns: Type Description Literal['none', 'both_sides', 'above', 'below'] tick position Source code in prettyqt/widgets/slider.py def get_tick_position ( self ) -> TickPositionStr : \"\"\"Return tick position. Returns: tick position \"\"\" val = TICK_POSITION . inverse [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\" return val","title":"get_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.set_tick_position","text":"Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Parameters: Name Type Description Default position Literal['none', 'both_sides', 'above', 'below', 'left', 'right'] position for the ticks required Source code in prettyqt/widgets/slider.py def set_tick_position ( self , position : TickPositionAllStr ): \"\"\"Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITION : raise InvalidParamError ( position , TICK_POSITION ) self . setTickPosition ( TICK_POSITION [ position ])","title":"set_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.splitter","text":"","title":"splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter","text":"","title":"Splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/splitter.py def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.set_orientation","text":"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitter.py def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider","text":"","title":"styleoptionslider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider","text":"","title":"StyleOptionSlider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_horizontal","text":"Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == QtCore . Qt . Horizontal","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_vertical","text":"Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == QtCore . Qt . Vertical","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_horizontal","text":"Set slider orientation to horizontal. Source code in prettyqt/widgets/styleoptionslider.py def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = QtCore . Qt . Horizontal","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_vertical","text":"Set slider orientation to vertical. Source code in prettyqt/widgets/styleoptionslider.py def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = QtCore . Qt . Vertical","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture","text":"","title":"swipegesture"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGesture","text":"","title":"SwipeGesture"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGesture.get_horizontal_direction","text":"Return horizontal direction of the gesture. Possible values: \"none\", \"left, \"right\" Returns: Type Description str horizontal direction Source code in prettyqt/widgets/swipegesture.py def get_horizontal_direction ( self ) -> str : \"\"\"Return horizontal direction of the gesture. Possible values: \"none\", \"left, \"right\" Returns: horizontal direction \"\"\" return SWIPE_DIRECTION . inverse [ self . horizontalDirection ()]","title":"get_horizontal_direction()"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGesture.get_vertical_direction","text":"Return vertical direction of the gesture. Possible values: \"none\", \"up, \"down\" Returns: Type Description str vertical direction Source code in prettyqt/widgets/swipegesture.py def get_vertical_direction ( self ) -> str : \"\"\"Return vertical direction of the gesture. Possible values: \"none\", \"up, \"down\" Returns: vertical direction \"\"\" return SWIPE_DIRECTION . inverse [ self . verticalDirection ()]","title":"get_vertical_direction()"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon","text":"","title":"systemtrayicon"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon","text":"","title":"SystemTrayIcon"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon.set_icon","text":"Set the system tray icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/systemtrayicon.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar","text":"","title":"tabbar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar","text":"","title":"TabBar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_elide_mode","text":"Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: Type Description str elide mode Source code in prettyqt/widgets/tabbar.py def get_elide_mode ( self ) -> str : \"\"\"Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: elide mode \"\"\" return ELIDE_MODES . inverse [ self . elideMode ()]","title":"get_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_remove_behaviour","text":"Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: Type Description str remove behaviour Source code in prettyqt/widgets/tabbar.py def get_remove_behaviour ( self ) -> str : \"\"\"Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOURS . inverse [ self . selectionBehaviorOnRemove ()]","title":"get_remove_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.mouseDoubleClickEvent","text":"mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/widgets/tabbar.py def mouseDoubleClickEvent ( self , event ): event . accept () self . on_detach . emit ( self . tabAt ( event . pos ()), self . mouse_cursor . pos ())","title":"mouseDoubleClickEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_elide_mode","text":"Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Parameters: Name Type Description Default mode str elide mode to use required Exceptions: Type Description InvalidParamError invalid elide mode Source code in prettyqt/widgets/tabbar.py def set_elide_mode ( self , mode : str ) -> None : \"\"\"Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in ELIDE_MODES : raise InvalidParamError ( mode , ELIDE_MODES ) self . setElideMode ( ELIDE_MODES [ mode ])","title":"set_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_icon_size","text":"Set size of the icons. Source code in prettyqt/widgets/tabbar.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_selection_behavior_on_remove","text":"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Parameters: Name Type Description Default mode str new remove behaviour required Source code in prettyqt/widgets/tabbar.py def set_selection_behavior_on_remove ( self , mode : str ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOURS : raise InvalidParamError ( mode , REMOVE_BEHAVIOURS ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOURS [ mode ])","title":"set_selection_behavior_on_remove()"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem","text":"","title":"tablewidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem","text":"","title":"TableWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.get_checkstate","text":"Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/tablewidgetitem.py def get_checkstate ( self ) -> StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return STATE . inverse [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/tablewidgetitem.py def set_checkstate ( self , state : StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATE : raise InvalidParamError ( state , STATE ) self . setCheckState ( STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/tablewidgetitem.py def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget","text":"","title":"tabwidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab","text":"Window containing a detached tab. When a tab is detached, the contents are placed into this QMainWindow. The tab can be re-attached by closing the dialog Attributes: Name Type Description on_close signal, emitted when window is closed (widget, title, icon)","title":"DetachedTab"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab.closeEvent","text":"closeEvent(self, QCloseEvent) Source code in prettyqt/widgets/tabwidget.py def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . get_id (), self . windowIcon ())","title":"closeEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget","text":"Widget for managing the tabs section.","title":"TabWidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.attach_tab","text":"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Parameters: Name Type Description Default widget Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] the content widget from the DetachedTab window required name str the name of the detached tab required icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] the window icon for the detached tab None insert_at Optional[int] insert the re-attached tab at the given index None Source code in prettyqt/widgets/tabwidget.py def attach_tab ( self , widget : Union [ QtWidgets . QWidget , QtWidgets . QLayout ], name : str , icon : gui . icon . IconType = None , insert_at : Optional [ int ] = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (gui.icon.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True )","title":"attach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.close_detached_tabs","text":"Close all tabs that are currently detached. Source code in prettyqt/widgets/tabwidget.py def close_detached_tabs ( self ) -> None : \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close ()","title":"close_detached_tabs()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.detach_tab","text":"Detach tab by removing its contents and placing them in a DetachedTab window. Parameters: Name Type Description Default index int index location of the tab to be detached required point QPoint screen pos for creating the new DetachedTab window required Returns: Type Description None None: Description Source code in prettyqt/widgets/tabwidget.py @autoslot . AutoSlot def detach_tab ( self , index : int , point : QtCore . QPoint ) -> None : \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content name = self . tabText ( index ) icon = self . tabIcon ( index ) if icon . isNull (): icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab","title":"detach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_position","text":"Return tab position. possible values are \"north\", \"south\", \"east\", \"west\" Returns: Type Description str tab position Source code in prettyqt/widgets/tabwidget.py def get_tab_position ( self ) -> str : \"\"\"Return tab position. possible values are \"north\", \"south\", \"east\", \"west\" Returns: tab position \"\"\" return TAB_POSITIONS . inverse [ self . tabPosition ()]","title":"get_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_shape","text":"Return tab shape. possible values are \"rounded\", \"triangular\" Returns: Type Description str tab shape Source code in prettyqt/widgets/tabwidget.py def get_tab_shape ( self ) -> str : \"\"\"Return tab shape. possible values are \"rounded\", \"triangular\" Returns: tab shape \"\"\" return TAB_SHAPES . inverse [ self . tabShape ()]","title":"get_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.open_widget","text":"Create a tab containing delivered widget. Source code in prettyqt/widgets/tabwidget.py @autoslot . AutoSlot def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True )","title":"open_widget()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_position","text":"Set tab position for the tabwidget. Valid values are \"north\", \"south\", \"east\", \"west\" Parameters: Name Type Description Default position str tab position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_position ( self , position : str ) -> None : \"\"\"Set tab position for the tabwidget. Valid values are \"north\", \"south\", \"east\", \"west\" Args: position: tab position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITIONS : raise InvalidParamError ( position , TAB_POSITIONS ) self . setTabPosition ( TAB_POSITIONS [ position ])","title":"set_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_shape","text":"Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Parameters: Name Type Description Default shape str tab shape to use required Exceptions: Type Description InvalidParamError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_shape ( self , shape : str ) -> None : \"\"\"Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ])","title":"set_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar","text":"","title":"toolbar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar","text":"","title":"ToolBar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.add_separator","text":"Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None before QAction insert separator before specific action None Returns: Type Description QAction Separator action Source code in prettyqt/widgets/toolbar.py def add_separator ( self , text : Optional [ str ] = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label )","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.get_style","text":"Return current style. Returns: Type Description Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] style Source code in prettyqt/widgets/toolbar.py def get_style ( self ) -> StyleStr : \"\"\"Return current style. Returns: style \"\"\" return STYLE . inverse [ self . toolButtonStyle ()]","title":"get_style()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.is_area_allowed","text":"Check if toolbar is allowed at specified area. Parameters: Name Type Description Default area Literal['left', 'right', 'top', 'bottom', 'all', 'none'] area of the toolbar required Exceptions: Type Description InvalidParamError area does not exist Source code in prettyqt/widgets/toolbar.py def is_area_allowed ( self , area : ToolbarAreaStr ) -> bool : \"\"\"Check if toolbar is allowed at specified area. Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in TOOLBAR_AREAS : raise InvalidParamError ( area , TOOLBAR_AREAS ) return self . isAreaAllowed ( TOOLBAR_AREAS [ area ])","title":"is_area_allowed()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.set_icon_size","text":"Set size of the icons. Source code in prettyqt/widgets/toolbar.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton","text":"","title":"toolbutton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton","text":"","title":"ToolButton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_arrow_type","text":"Return arrow type. Returns: Type Description Literal['none', 'up', 'down', 'left', 'right'] arrow type Source code in prettyqt/widgets/toolbutton.py def get_arrow_type ( self ) -> ArrowTypeStr : \"\"\"Return arrow type. Returns: arrow type \"\"\" return ARROW_TYPE . inverse [ self . arrowType ()]","title":"get_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_popup_mode","text":"Return popup mode. Returns: Type Description Literal['delayed', 'menu_button', 'instant'] popup mode Source code in prettyqt/widgets/toolbutton.py def get_popup_mode ( self ) -> PopupModeStr : \"\"\"Return popup mode. Returns: popup mode \"\"\" return POPUP_MODE . inverse [ self . popupMode ()]","title":"get_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_style","text":"Return toolbutton style. Returns: Type Description Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] toolbutton style Source code in prettyqt/widgets/toolbutton.py def get_style ( self ) -> StyleStr : \"\"\"Return toolbutton style. Returns: toolbutton style \"\"\" return STYLE . inverse [ self . toolButtonStyle ()]","title":"get_style()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_arrow_type","text":"Set the arrow type of the toolbutton. Parameters: Name Type Description Default mode Literal['none', 'up', 'down', 'left', 'right'] arrow type to use required Exceptions: Type Description InvalidParamError invalid arrow type Source code in prettyqt/widgets/toolbutton.py def set_arrow_type ( self , mode : ArrowTypeStr ): \"\"\"Set the arrow type of the toolbutton. Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in ARROW_TYPE : raise InvalidParamError ( mode , ARROW_TYPE ) self . setArrowType ( ARROW_TYPE [ mode ])","title":"set_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_popup_mode","text":"Set the popup mode of the toolbutton. Parameters: Name Type Description Default mode Literal['delayed', 'menu_button', 'instant'] popup mode to use required Exceptions: Type Description InvalidParamError invalid popup mode Source code in prettyqt/widgets/toolbutton.py def set_popup_mode ( self , mode : PopupModeStr ): \"\"\"Set the popup mode of the toolbutton. Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODE : raise InvalidParamError ( mode , POPUP_MODE ) self . setPopupMode ( POPUP_MODE [ mode ])","title":"set_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_style","text":"Set the toolbutton style. Parameters: Name Type Description Default style Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] style to use required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/widgets/toolbutton.py def set_style ( self , style : StyleStr ): \"\"\"Set the toolbutton style. Args: style: style to use Raises: InvalidParamError: invalid style \"\"\" if style not in STYLE : raise InvalidParamError ( style , STYLE ) self . setToolButtonStyle ( STYLE [ style ])","title":"set_style()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem","text":"","title":"treewidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem","text":"","title":"TreeWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_checkstate","text":"Return checkstate. Parameters: Name Type Description Default column int column 0 Returns: Type Description StateStr checkstate Source code in prettyqt/widgets/treewidgetitem.py def get_checkstate ( self , column : int = 0 ) -> StateStr : \"\"\"Return checkstate. Args: column: column Returns: checkstate \"\"\" return STATE . inverse [ self . checkState ( column )]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_child_indicator_policy","text":"Return current child indicator policy. Returns: Type Description ChildIndicatorPolicyStr child indicator policy Source code in prettyqt/widgets/treewidgetitem.py def get_child_indicator_policy ( self ) -> ChildIndicatorPolicyStr : \"\"\"Return current child indicator policy. Returns: child indicator policy \"\"\" return CHILD_INDICATOR_POLICY . inverse [ self . childIndicatorPolicy ()]","title":"get_child_indicator_policy()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state StateStr checkstate to use required column int column 0 Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py def set_checkstate ( self , state : StateStr , column : int = 0 ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use column: column Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATE : raise InvalidParamError ( state , STATE ) self . setCheckState ( column , STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_child_indicator_policy","text":"Set the child indicator policy. Parameters: Name Type Description Default policy ChildIndicatorPolicyStr child indicator policy required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/treewidgetitem.py def set_child_indicator_policy ( self , policy : ChildIndicatorPolicyStr ): \"\"\"Set the child indicator policy. Args: policy: child indicator policy Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CHILD_INDICATOR_POLICY : raise InvalidParamError ( policy , CHILD_INDICATOR_POLICY ) self . setChildIndicatorPolicy ( CHILD_INDICATOR_POLICY [ policy ])","title":"set_child_indicator_policy()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon gui.icon.IconType icon to use required column int column 0 Source code in prettyqt/widgets/treewidgetitem.py def set_icon ( self , icon : gui . icon . IconType , column : int = 0 ): \"\"\"Set the icon for the action. Args: icon: icon to use column: column \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( column , icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.undoview","text":"","title":"undoview"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView","text":"","title":"UndoView"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView.set_clean_icon","text":"Set the icon for the clean button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/undoview.py def set_clean_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setCleanIcon ( icon )","title":"set_clean_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget","text":"","title":"widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget","text":"","title":"Widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_contextmenu_policy","text":"Return current contextmenu policy. Returns: Type Description Literal['none', 'prevent', 'default', 'actions', 'custom'] contextmenu policy Source code in prettyqt/widgets/widget.py def get_contextmenu_policy ( self ) -> ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return CONTEXT_POLICY . inverse [ self . contextMenuPolicy ()]","title":"get_contextmenu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_focus_policy","text":"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: Type Description str str: Focus policy Source code in prettyqt/widgets/widget.py def get_focus_policy ( self ) -> str : \"\"\"Return waay the widget accepts keyboard focus. Possible values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Returns: str: Focus policy \"\"\" return FOCUS_POLICIES . inverse [ self . focusPolicy ()]","title":"get_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_modality","text":"Get the current modality modes as a string. Returns: Type Description Literal['none', 'prevent', 'default', 'actions', 'custom'] modality mode Source code in prettyqt/widgets/widget.py def get_modality ( self ) -> ModalityStr : \"\"\"Get the current modality modes as a string. Returns: modality mode \"\"\" return MODALITY . inverse [ self . windowModality ()]","title":"get_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.resize","text":"resize(self, QSize) resize(self, int, int) Source code in prettyqt/widgets/widget.py def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size )","title":"resize()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_contextmenu_policy","text":"Set contextmenu policy for given item view. Parameters: Name Type Description Default policy Literal['none', 'prevent', 'default', 'actions', 'custom'] contextmenu policy to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_contextmenu_policy ( self , policy : ContextPolicyStr ) -> None : \"\"\"Set contextmenu policy for given item view. Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CONTEXT_POLICY : raise InvalidParamError ( policy , CONTEXT_POLICY ) self . setContextMenuPolicy ( CONTEXT_POLICY [ policy ])","title":"set_contextmenu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_focus_policy","text":"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Parameters: Name Type Description Default policy str Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/widget.py def set_focus_policy ( self , policy : str ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Accepted values: \"tab\", \"click\", \"strong\", \"wheel\", \"none\" Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in FOCUS_POLICIES : raise InvalidParamError ( policy , FOCUS_POLICIES ) self . setFocusPolicy ( FOCUS_POLICIES [ policy ])","title":"set_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_icon","text":"Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/widget.py def set_icon ( self , icon : gui . icon . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_modality","text":"Set modality for the dialog. Parameters: Name Type Description Default modality Literal['none', 'prevent', 'default', 'actions', 'custom'] modality for the main window required Exceptions: Type Description InvalidParamError modality type does not exist Source code in prettyqt/widgets/widget.py def set_modality ( self , modality : ModalityStr ) -> None : \"\"\"Set modality for the dialog. Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in MODALITY : raise InvalidParamError ( modality , MODALITY ) self . setWindowModality ( MODALITY [ modality ])","title":"set_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_size_policy","text":"Set the sizes policy. Parameters: Name Type Description Default horizontal Optional[Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored']] horizontal size policy None vertical Optional[Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored']] vertical size policy None Source code in prettyqt/widgets/widget.py def set_size_policy ( self , horizontal : Optional [ widgets . sizepolicy . SizePolicyStr ] = None , vertical : Optional [ widgets . sizepolicy . SizePolicyStr ] = None , ) -> None : \"\"\"Set the sizes policy. Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp )","title":"set_size_policy()"},{"location":"api/widgets.html#prettyqt.widgets.wizard","text":"","title":"wizard"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard","text":"","title":"Wizard"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_button_text","text":"Return text for given button type. Parameters: Name Type Description Default button_type str button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizard.py def get_button_text ( self , button_type : str ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . buttonText ( WIZARD_BUTTON [ button_type ])","title":"get_button_text()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_option","text":"Return the value assigned to option. Possible values: \"independent_pages\", \"ignore_subtitles\", \"extended_watermark_bitmap\", \"no_default_button\", \"no_back_button_on_start_page\", \"no_back_button_on_last_page\", \"disabled_back_button_on_last_page\", \"next_button_on_last_page\", \"finish_button_on_early_pages\", \"no_cancel_button\", \"cancel_button_on_left\", \"help_button\", \"help_button_on_right\", \"custom_button_1\", \"custom_button_2\", \"custom_button_3\", \"no_cancel_button_on_last_page\" Parameters: Name Type Description Default option str option to get required Returns: Type Description bool option Source code in prettyqt/widgets/wizard.py def get_option ( self , option : str ) -> bool : \"\"\"Return the value assigned to option. Possible values: \"independent_pages\", \"ignore_subtitles\", \"extended_watermark_bitmap\", \"no_default_button\", \"no_back_button_on_start_page\", \"no_back_button_on_last_page\", \"disabled_back_button_on_last_page\", \"next_button_on_last_page\", \"finish_button_on_early_pages\", \"no_cancel_button\", \"cancel_button_on_left\", \"help_button\", \"help_button_on_right\", \"custom_button_1\", \"custom_button_2\", \"custom_button_3\", \"no_cancel_button_on_last_page\" Args: option: option to get Returns: option \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) return self . testOption ( WIZARD_OPTIONS [ option ])","title":"get_option()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_subtitle_format","text":"Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str subtitle format Source code in prettyqt/widgets/wizard.py def get_subtitle_format ( self ) -> str : \"\"\"Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: subtitle format \"\"\" return TEXT_FORMATS . inverse [ self . subTitleFormat ()]","title":"get_subtitle_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_title_format","text":"Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str title format Source code in prettyqt/widgets/wizard.py def get_title_format ( self ) -> str : \"\"\"Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: title format \"\"\" return TEXT_FORMATS . inverse [ self . titleFormat ()]","title":"get_title_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_wizard_style","text":"Return current wizard style. Possible values are \"classic\", \"modern\", \"mac\", \"aero\" Returns: Type Description str Wizard style Source code in prettyqt/widgets/wizard.py def get_wizard_style ( self ) -> str : \"\"\"Return current wizard style. Possible values are \"classic\", \"modern\", \"mac\", \"aero\" Returns: Wizard style \"\"\" return WIZARD_STYLE . inverse [ self . wizardStyle ()]","title":"get_wizard_style()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_button_text","text":"Set text for given button type. Parameters: Name Type Description Default button_type str button to get text from required value str text to set required Source code in prettyqt/widgets/wizard.py def set_button_text ( self , button_type : str , value : str ) -> str : \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . setButtonText ( WIZARD_BUTTON [ button_type ], value )","title":"set_button_text()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_option","text":"Set option to given value. Allowed values: \"independent_pages\", \"ignore_subtitles\", \"extended_watermark_bitmap\", \"no_default_button\", \"no_back_button_on_start_page\", \"no_back_button_on_last_page\", \"disabled_back_button_on_last_page\", \"next_button_on_last_page\", \"finish_button_on_early_pages\", \"no_cancel_button\", \"cancel_button_on_left\", \"help_button\", \"help_button_on_right\", \"custom_button_1\", \"custom_button_2\", \"custom_button_3\", \"no_cancel_button_on_last_page\" Parameters: Name Type Description Default option str option to use required value bool value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/widgets/wizard.py def set_option ( self , option : str , value : bool ): \"\"\"Set option to given value. Allowed values: \"independent_pages\", \"ignore_subtitles\", \"extended_watermark_bitmap\", \"no_default_button\", \"no_back_button_on_start_page\", \"no_back_button_on_last_page\", \"disabled_back_button_on_last_page\", \"next_button_on_last_page\", \"finish_button_on_early_pages\", \"no_cancel_button\", \"cancel_button_on_left\", \"help_button\", \"help_button_on_right\", \"custom_button_1\", \"custom_button_2\", \"custom_button_3\", \"no_cancel_button_on_last_page\" Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) self . setOption ( WIZARD_OPTIONS [ option ], value )","title":"set_option()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_subtitle_format","text":"Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt str subtitle format to use required Exceptions: Type Description InvalidParamError subtitle format does not exist Source code in prettyqt/widgets/wizard.py def set_subtitle_format ( self , fmt : str ): \"\"\"Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: subtitle format to use Raises: InvalidParamError: subtitle format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setSubTitleFormat ( TEXT_FORMATS [ fmt ])","title":"set_subtitle_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_title_format","text":"Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt str title format to use required Exceptions: Type Description InvalidParamError title format does not exist Source code in prettyqt/widgets/wizard.py def set_title_format ( self , fmt : str ): \"\"\"Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: title format to use Raises: InvalidParamError: title format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setTitleFormat ( TEXT_FORMATS [ fmt ])","title":"set_title_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_wizard_style","text":"Set the wizard style. Allowed values are \"classic\", \"modern\", \"mac\", \"aero\" Parameters: Name Type Description Default style str wizard style required Exceptions: Type Description InvalidParamError wizard style does not exist Source code in prettyqt/widgets/wizard.py def set_wizard_style ( self , style : str ): \"\"\"Set the wizard style. Allowed values are \"classic\", \"modern\", \"mac\", \"aero\" Args: style: wizard style Raises: InvalidParamError: wizard style does not exist \"\"\" if style not in WIZARD_STYLE : raise InvalidParamError ( style , WIZARD_STYLE ) self . setWizardStyle ( WIZARD_STYLE [ style ])","title":"set_wizard_style()"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage","text":"","title":"wizardpage"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPage","text":"","title":"WizardPage"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPage.get_button_text","text":"Return text for given button type. Parameters: Name Type Description Default button_type str button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizardpage.py def get_button_text ( self , button_type : str ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) return self . buttonText ( widgets . wizard . WIZARD_BUTTON [ button_type ])","title":"get_button_text()"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPage.set_button_text","text":"Set text for given button type. Parameters: Name Type Description Default button_type str button to get text from required value str text to set required Source code in prettyqt/widgets/wizardpage.py def set_button_text ( self , button_type : str , value : str ) -> str : \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) return self . setButtonText ( widgets . wizard . WIZARD_BUTTON [ button_type ], value )","title":"set_button_text()"}]}