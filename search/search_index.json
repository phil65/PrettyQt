{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"prettyqt: Pythonic layer on top of PyQt5 / PySide2 What is it? PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PySide2. Main Features Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module. Where to get it The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt Dependencies qtpy qtawesome bidict orjson regex docutils Installation from sources This project uses poetry for dependency management and packaging. Install this first. In the prettyqt directory (same one where you found this file after cloning the git repo), execute: poetry install License MIT Documentation The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/ Contributing to pandas All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Home"},{"location":"index.html#prettyqt-pythonic-layer-on-top-of-pyqt5-pyside2","text":"","title":"prettyqt: Pythonic layer on top of PyQt5 / PySide2"},{"location":"index.html#what-is-it","text":"PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PySide2.","title":"What is it?"},{"location":"index.html#main-features","text":"Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module.","title":"Main Features"},{"location":"index.html#where-to-get-it","text":"The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt","title":"Where to get it"},{"location":"index.html#dependencies","text":"qtpy qtawesome bidict orjson regex docutils","title":"Dependencies"},{"location":"index.html#installation-from-sources","text":"This project uses poetry for dependency management and packaging. Install this first. In the prettyqt directory (same one where you found this file after cloning the git repo), execute: poetry install","title":"Installation from sources"},{"location":"index.html#license","text":"MIT","title":"License"},{"location":"index.html#documentation","text":"The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/","title":"Documentation"},{"location":"index.html#contributing-to-pandas","text":"All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Contributing to pandas"},{"location":"changelog.html","text":"v0.113.0 (2020-08-10) Feat gui : add PainterPath class gui : add Polygon class gui : palette improvements core : add Line class core : add TransposeProxyModel / ConcatenateTablesProxyModel add ObjectBrowser widgets : add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect Action : \"checked\" param for ctor gui : some magic methods + get_matches for KeySequence core : allow pickling VersionNumber / Size / Dir gui : add Gradient class add ColumnItemModel / ColumnItem Settings : add set_values method Widget : spacing kwarg for set_layout Refactor add serialization stuff improve some repr methods v0.112.0 (2020-08-04) Feat utils : add install_exceptionhook method FileSystemModel : add some more shortcuts for set_root_path core : add VersionNumber class Application : add get_icon method MessageBox : add show_exception method Refactor improve compat with older Qt Versions Fix another test fix v0.111.1 (2020-08-03) Fix fix tests for Linux v0.111.0 (2020-08-03) Feat widgets : add FontComboBox StandardPaths : add class_getitem method Action : some more ctor kwargs Action : add get/set_menu_role methods, some pickle work Refactor custom Exception for wrong params Fix Menu : disable separator widgetAction v0.110.2 (2020-08-03) Fix fix broken LogTextEdit v0.110.1 (2020-08-03) Fix LogTextEdit : improve exception handling SidebarWidget : some fixes related to set_marker v0.110.0 (2020-08-02) Refactor improve serialization for listitems Validator pickle work Feat Image : allow pickling DataStream : add create_bytearray / write_bytearray / copy_data methods core : add DataStream class v0.109.0 (2020-08-02) Feat widget : add pretty method for devtools GridLayout : allow adding tuples/lists Refactor rework widget pickling move CheckboxDelegate to custom_delegates pickle stuff for undocommand v0.108.0 (2020-07-31) Feat custom_delegates : add IconDelegate and NoFocusDelegate TableWidet : add getitem and setitem methods Icon : add from_image method allow str for layout. getitem (uses objectName) SidebarWidget : add set_marker method Refactor move delegates to separate module v0.107.0 (2020-07-29) Feat GridLayout : also allow adding LayoutItems via add method v0.106.1 (2020-07-29) Fix TabWidget : correctly close detached tabs on app close pickle fixes for toolbar and dockwidget PygmentsHighlighter : catch pygments KeyError v0.106.0 (2020-07-26) Feat gui : add DesktopServices class multimedia : add AudioRecorder class core : add StandardPaths class widgets : add Undo classes v0.105.0 (2020-07-24) Feat MediaRecorder : some new methods sort_by_column for tableview and treeview multimedia : dict-setter and getter for encodersettings Refactor improve Url-Pathlib interoperability Fix PopupInfo : use PrimaryScreen geometry instead of screens[0] for positioning v0.104.0 (2020-07-23) Feat multimedia : add MediaRecorder AbstractItemModel : add getitem method multimedia : add VideoEncoderSettings / AudioEncoderSettings Refactor use subclassed core.Size v0.103.0 (2020-07-22) Feat ActionGroup : add getitem method MediaContent : add get_url method add multimediawidgets module add multimedia module PlainTextEdit : add allow_wheel_zoom method Object : name kwarg for find_parent method v0.102.0 (2020-07-21) Refactor move raise_dock to from Widget to Object SidebarWidget : some code cleanup, make settings button size configurable Widget : default state to True for set_attribute MainWindow : add return value for load_window_state Feat Object : add find_parent method PlainTextEdit : add style kwarg to set_syntaxhighlighter v0.101.1 (2020-07-20) Fix LogTextEdit : better integrate with custom qstylesheets v0.101.0 (2020-07-20) Feat MessageBox : add detail_text keyword argument to message method Fix correct return type for gui.icon.get_icon v0.100.0 (2020-07-20) Feat ToolTip : add show_text method GuiApplication : add set_override_cursor / restore_override_cursor methods GuiApplication : add override_cursor context manager v0.99.0 (2020-07-18) Refactor FileChooserButton : typing and fixes Dataset : typing and fixes SidebarWidget : use button map instead of attaching button to widget Feat AbstractItemView : add scroll_to method v0.98.5 (2020-07-17) Perf add icon cache Refactor use core.Settings for windows dark mode detection v0.98.4 (2020-07-15) Fix use qta default icon color instead of black for default v0.98.3 (2020-07-15) Refactor properly set stylesheets by using contextmanager FontDialog : do not override current_font contextmanager move current_font context manager to Widget class v0.98.2 (2020-07-15) Fix package name v0.98.1 (2020-07-15) Fix correctly reset stylesheet for widget validation background Refactor use qstylizer for stylesheet editing v0.98.0 (2020-07-15) Feat widgets : add StyleFactory Refactor FontDatabase : make add_fonts_from_folder a classmethod v0.97.0 (2020-07-15) Feat gui : add FontDatabase widgets : add Completer widgets : add ActionGroup v0.96.0 (2020-07-14) Feat SelectionWidget : default keyword argument for add_custom v0.95.0 (2020-07-14) Feat SelectionWidget : different options for custom type add PagedPaintDevice Widget : add set_margin method v0.94.0 (2020-07-14) Feat Widget : add Widget.font_metrics() SpacerItem : allow strings for size policy in ctor allow Mapping for listwidget.add_items Refactor change to {value: label} dicts for FlagSelectionWidget.add_items v0.93.1 (2020-07-14) Refactor typecheck for Mapping instead of dict for combobox / selectionwidget add_items method v0.93.0 (2020-07-14) Feat add register_extensions function to settings module Refactor Settings : do not override value method v0.92.1 (2020-07-14) Fix winextras test fix v0.92.0 (2020-07-14) Feat add widgets.SystemTrayIcon add winextras module Label : set_indent method v0.91.0 (2020-07-13) Feat SidebarWidget : allow choosing layout MainWindow : add show_blocking method v0.90.0 (2020-07-13) Feat Toolbar : allow combinations of allowed areas for set_allowed_areas SidebarWidget : add optional settings menu v0.89.1 (2020-07-13) Refactor SelectionWidget : switch to {data: label} dicts for add_items to be in line with RadioButton v0.89.0 (2020-07-13) Feat SidebarWidget : make button width configurable v0.88.1 (2020-07-13) Refactor ComboBox : use set_data for set_value Fix ComboBox : fix add_items method v0.88.0 (2020-07-13) Feat ComboBox : set_data method v0.87.0 (2020-07-13) Feat ComboBox : allow dict for add_items v0.86.3 (2020-07-12) Refactor RegexEditor : code cleanup v0.86.2 (2020-07-12) Fix another deployment fix v0.86.1 (2020-07-12) Fix deployment fix v0.86.0 (2020-07-12) Feat add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line v0.85.1 (2020-07-10) Fix add missing pygments requirement v0.85.0 (2020-07-10) Feat dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method Refactor CodeEditor : use pygments for syntax highlighting v0.84.0 (2020-07-10) Feat sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child v0.83.1 (2020-07-09) Refactor move set_icon from window classes to widget class v0.83.0 (2020-07-09) Feat add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager v0.82.0 (2020-07-09) Feat add Label.set_bold / set_italic / set_weight added Font.set_weight v0.81.0 (2020-07-08) Feat allow setting window icon color os dark mode detection v0.80.1 (2020-07-08) Fix Settings.value() returned wrong type v0.80.0 (2020-07-08) Feat add Widget.set_attribute add margin keyword argument to Widget.set_layout v0.79.1 (2020-07-08) Fix remove Qt logger on Application exit v0.79.0 (2020-07-08) Feat add widgets.Application.get_widget v0.78.0 (2020-07-08) Feat allow to save/load window state recursively. Saving needs to be done explicitely now. Fix some fixes for core.Settings dict interface properly preserve types in core.Settings v0.77.1 (2020-07-07) Refactor also allow qt flag for Splitter ctor Fix return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview 0.77.0 (2020-07-06) Feat allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages Fix fix Messagebox.message call Refactor dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars","title":"Changelog"},{"location":"changelog.html#v01130-2020-08-10","text":"","title":"v0.113.0 (2020-08-10)"},{"location":"changelog.html#feat","text":"gui : add PainterPath class gui : add Polygon class gui : palette improvements core : add Line class core : add TransposeProxyModel / ConcatenateTablesProxyModel add ObjectBrowser widgets : add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect Action : \"checked\" param for ctor gui : some magic methods + get_matches for KeySequence core : allow pickling VersionNumber / Size / Dir gui : add Gradient class add ColumnItemModel / ColumnItem Settings : add set_values method Widget : spacing kwarg for set_layout","title":"Feat"},{"location":"changelog.html#refactor","text":"add serialization stuff improve some repr methods","title":"Refactor"},{"location":"changelog.html#v01120-2020-08-04","text":"","title":"v0.112.0 (2020-08-04)"},{"location":"changelog.html#feat_1","text":"utils : add install_exceptionhook method FileSystemModel : add some more shortcuts for set_root_path core : add VersionNumber class Application : add get_icon method MessageBox : add show_exception method","title":"Feat"},{"location":"changelog.html#refactor_1","text":"improve compat with older Qt Versions","title":"Refactor"},{"location":"changelog.html#fix","text":"another test fix","title":"Fix"},{"location":"changelog.html#v01111-2020-08-03","text":"","title":"v0.111.1 (2020-08-03)"},{"location":"changelog.html#fix_1","text":"fix tests for Linux","title":"Fix"},{"location":"changelog.html#v01110-2020-08-03","text":"","title":"v0.111.0 (2020-08-03)"},{"location":"changelog.html#feat_2","text":"widgets : add FontComboBox StandardPaths : add class_getitem method Action : some more ctor kwargs Action : add get/set_menu_role methods, some pickle work","title":"Feat"},{"location":"changelog.html#refactor_2","text":"custom Exception for wrong params","title":"Refactor"},{"location":"changelog.html#fix_2","text":"Menu : disable separator widgetAction","title":"Fix"},{"location":"changelog.html#v01102-2020-08-03","text":"","title":"v0.110.2 (2020-08-03)"},{"location":"changelog.html#fix_3","text":"fix broken LogTextEdit","title":"Fix"},{"location":"changelog.html#v01101-2020-08-03","text":"","title":"v0.110.1 (2020-08-03)"},{"location":"changelog.html#fix_4","text":"LogTextEdit : improve exception handling SidebarWidget : some fixes related to set_marker","title":"Fix"},{"location":"changelog.html#v01100-2020-08-02","text":"","title":"v0.110.0 (2020-08-02)"},{"location":"changelog.html#refactor_3","text":"improve serialization for listitems Validator pickle work","title":"Refactor"},{"location":"changelog.html#feat_3","text":"Image : allow pickling DataStream : add create_bytearray / write_bytearray / copy_data methods core : add DataStream class","title":"Feat"},{"location":"changelog.html#v01090-2020-08-02","text":"","title":"v0.109.0 (2020-08-02)"},{"location":"changelog.html#feat_4","text":"widget : add pretty method for devtools GridLayout : allow adding tuples/lists","title":"Feat"},{"location":"changelog.html#refactor_4","text":"rework widget pickling move CheckboxDelegate to custom_delegates pickle stuff for undocommand","title":"Refactor"},{"location":"changelog.html#v01080-2020-07-31","text":"","title":"v0.108.0 (2020-07-31)"},{"location":"changelog.html#feat_5","text":"custom_delegates : add IconDelegate and NoFocusDelegate TableWidet : add getitem and setitem methods Icon : add from_image method allow str for layout. getitem (uses objectName) SidebarWidget : add set_marker method","title":"Feat"},{"location":"changelog.html#refactor_5","text":"move delegates to separate module","title":"Refactor"},{"location":"changelog.html#v01070-2020-07-29","text":"","title":"v0.107.0 (2020-07-29)"},{"location":"changelog.html#feat_6","text":"GridLayout : also allow adding LayoutItems via add method","title":"Feat"},{"location":"changelog.html#v01061-2020-07-29","text":"","title":"v0.106.1 (2020-07-29)"},{"location":"changelog.html#fix_5","text":"TabWidget : correctly close detached tabs on app close pickle fixes for toolbar and dockwidget PygmentsHighlighter : catch pygments KeyError","title":"Fix"},{"location":"changelog.html#v01060-2020-07-26","text":"","title":"v0.106.0 (2020-07-26)"},{"location":"changelog.html#feat_7","text":"gui : add DesktopServices class multimedia : add AudioRecorder class core : add StandardPaths class widgets : add Undo classes","title":"Feat"},{"location":"changelog.html#v01050-2020-07-24","text":"","title":"v0.105.0 (2020-07-24)"},{"location":"changelog.html#feat_8","text":"MediaRecorder : some new methods sort_by_column for tableview and treeview multimedia : dict-setter and getter for encodersettings","title":"Feat"},{"location":"changelog.html#refactor_6","text":"improve Url-Pathlib interoperability","title":"Refactor"},{"location":"changelog.html#fix_6","text":"PopupInfo : use PrimaryScreen geometry instead of screens[0] for positioning","title":"Fix"},{"location":"changelog.html#v01040-2020-07-23","text":"","title":"v0.104.0 (2020-07-23)"},{"location":"changelog.html#feat_9","text":"multimedia : add MediaRecorder AbstractItemModel : add getitem method multimedia : add VideoEncoderSettings / AudioEncoderSettings","title":"Feat"},{"location":"changelog.html#refactor_7","text":"use subclassed core.Size","title":"Refactor"},{"location":"changelog.html#v01030-2020-07-22","text":"","title":"v0.103.0 (2020-07-22)"},{"location":"changelog.html#feat_10","text":"ActionGroup : add getitem method MediaContent : add get_url method add multimediawidgets module add multimedia module PlainTextEdit : add allow_wheel_zoom method Object : name kwarg for find_parent method","title":"Feat"},{"location":"changelog.html#v01020-2020-07-21","text":"","title":"v0.102.0 (2020-07-21)"},{"location":"changelog.html#refactor_8","text":"move raise_dock to from Widget to Object SidebarWidget : some code cleanup, make settings button size configurable Widget : default state to True for set_attribute MainWindow : add return value for load_window_state","title":"Refactor"},{"location":"changelog.html#feat_11","text":"Object : add find_parent method PlainTextEdit : add style kwarg to set_syntaxhighlighter","title":"Feat"},{"location":"changelog.html#v01011-2020-07-20","text":"","title":"v0.101.1 (2020-07-20)"},{"location":"changelog.html#fix_7","text":"LogTextEdit : better integrate with custom qstylesheets","title":"Fix"},{"location":"changelog.html#v01010-2020-07-20","text":"","title":"v0.101.0 (2020-07-20)"},{"location":"changelog.html#feat_12","text":"MessageBox : add detail_text keyword argument to message method","title":"Feat"},{"location":"changelog.html#fix_8","text":"correct return type for gui.icon.get_icon","title":"Fix"},{"location":"changelog.html#v01000-2020-07-20","text":"","title":"v0.100.0 (2020-07-20)"},{"location":"changelog.html#feat_13","text":"ToolTip : add show_text method GuiApplication : add set_override_cursor / restore_override_cursor methods GuiApplication : add override_cursor context manager","title":"Feat"},{"location":"changelog.html#v0990-2020-07-18","text":"","title":"v0.99.0 (2020-07-18)"},{"location":"changelog.html#refactor_9","text":"FileChooserButton : typing and fixes Dataset : typing and fixes SidebarWidget : use button map instead of attaching button to widget","title":"Refactor"},{"location":"changelog.html#feat_14","text":"AbstractItemView : add scroll_to method","title":"Feat"},{"location":"changelog.html#v0985-2020-07-17","text":"","title":"v0.98.5 (2020-07-17)"},{"location":"changelog.html#perf","text":"add icon cache","title":"Perf"},{"location":"changelog.html#refactor_10","text":"use core.Settings for windows dark mode detection","title":"Refactor"},{"location":"changelog.html#v0984-2020-07-15","text":"","title":"v0.98.4 (2020-07-15)"},{"location":"changelog.html#fix_9","text":"use qta default icon color instead of black for default","title":"Fix"},{"location":"changelog.html#v0983-2020-07-15","text":"","title":"v0.98.3 (2020-07-15)"},{"location":"changelog.html#refactor_11","text":"properly set stylesheets by using contextmanager FontDialog : do not override current_font contextmanager move current_font context manager to Widget class","title":"Refactor"},{"location":"changelog.html#v0982-2020-07-15","text":"","title":"v0.98.2 (2020-07-15)"},{"location":"changelog.html#fix_10","text":"package name","title":"Fix"},{"location":"changelog.html#v0981-2020-07-15","text":"","title":"v0.98.1 (2020-07-15)"},{"location":"changelog.html#fix_11","text":"correctly reset stylesheet for widget validation background","title":"Fix"},{"location":"changelog.html#refactor_12","text":"use qstylizer for stylesheet editing","title":"Refactor"},{"location":"changelog.html#v0980-2020-07-15","text":"","title":"v0.98.0 (2020-07-15)"},{"location":"changelog.html#feat_15","text":"widgets : add StyleFactory","title":"Feat"},{"location":"changelog.html#refactor_13","text":"FontDatabase : make add_fonts_from_folder a classmethod","title":"Refactor"},{"location":"changelog.html#v0970-2020-07-15","text":"","title":"v0.97.0 (2020-07-15)"},{"location":"changelog.html#feat_16","text":"gui : add FontDatabase widgets : add Completer widgets : add ActionGroup","title":"Feat"},{"location":"changelog.html#v0960-2020-07-14","text":"","title":"v0.96.0 (2020-07-14)"},{"location":"changelog.html#feat_17","text":"SelectionWidget : default keyword argument for add_custom","title":"Feat"},{"location":"changelog.html#v0950-2020-07-14","text":"","title":"v0.95.0 (2020-07-14)"},{"location":"changelog.html#feat_18","text":"SelectionWidget : different options for custom type add PagedPaintDevice Widget : add set_margin method","title":"Feat"},{"location":"changelog.html#v0940-2020-07-14","text":"","title":"v0.94.0 (2020-07-14)"},{"location":"changelog.html#feat_19","text":"Widget : add Widget.font_metrics() SpacerItem : allow strings for size policy in ctor allow Mapping for listwidget.add_items","title":"Feat"},{"location":"changelog.html#refactor_14","text":"change to {value: label} dicts for FlagSelectionWidget.add_items","title":"Refactor"},{"location":"changelog.html#v0931-2020-07-14","text":"","title":"v0.93.1 (2020-07-14)"},{"location":"changelog.html#refactor_15","text":"typecheck for Mapping instead of dict for combobox / selectionwidget add_items method","title":"Refactor"},{"location":"changelog.html#v0930-2020-07-14","text":"","title":"v0.93.0 (2020-07-14)"},{"location":"changelog.html#feat_20","text":"add register_extensions function to settings module","title":"Feat"},{"location":"changelog.html#refactor_16","text":"Settings : do not override value method","title":"Refactor"},{"location":"changelog.html#v0921-2020-07-14","text":"","title":"v0.92.1 (2020-07-14)"},{"location":"changelog.html#fix_12","text":"winextras test fix","title":"Fix"},{"location":"changelog.html#v0920-2020-07-14","text":"","title":"v0.92.0 (2020-07-14)"},{"location":"changelog.html#feat_21","text":"add widgets.SystemTrayIcon add winextras module Label : set_indent method","title":"Feat"},{"location":"changelog.html#v0910-2020-07-13","text":"","title":"v0.91.0 (2020-07-13)"},{"location":"changelog.html#feat_22","text":"SidebarWidget : allow choosing layout MainWindow : add show_blocking method","title":"Feat"},{"location":"changelog.html#v0900-2020-07-13","text":"","title":"v0.90.0 (2020-07-13)"},{"location":"changelog.html#feat_23","text":"Toolbar : allow combinations of allowed areas for set_allowed_areas SidebarWidget : add optional settings menu","title":"Feat"},{"location":"changelog.html#v0891-2020-07-13","text":"","title":"v0.89.1 (2020-07-13)"},{"location":"changelog.html#refactor_17","text":"SelectionWidget : switch to {data: label} dicts for add_items to be in line with RadioButton","title":"Refactor"},{"location":"changelog.html#v0890-2020-07-13","text":"","title":"v0.89.0 (2020-07-13)"},{"location":"changelog.html#feat_24","text":"SidebarWidget : make button width configurable","title":"Feat"},{"location":"changelog.html#v0881-2020-07-13","text":"","title":"v0.88.1 (2020-07-13)"},{"location":"changelog.html#refactor_18","text":"ComboBox : use set_data for set_value","title":"Refactor"},{"location":"changelog.html#fix_13","text":"ComboBox : fix add_items method","title":"Fix"},{"location":"changelog.html#v0880-2020-07-13","text":"","title":"v0.88.0 (2020-07-13)"},{"location":"changelog.html#feat_25","text":"ComboBox : set_data method","title":"Feat"},{"location":"changelog.html#v0870-2020-07-13","text":"","title":"v0.87.0 (2020-07-13)"},{"location":"changelog.html#feat_26","text":"ComboBox : allow dict for add_items","title":"Feat"},{"location":"changelog.html#v0863-2020-07-12","text":"","title":"v0.86.3 (2020-07-12)"},{"location":"changelog.html#refactor_19","text":"RegexEditor : code cleanup","title":"Refactor"},{"location":"changelog.html#v0862-2020-07-12","text":"","title":"v0.86.2 (2020-07-12)"},{"location":"changelog.html#fix_14","text":"another deployment fix","title":"Fix"},{"location":"changelog.html#v0861-2020-07-12","text":"","title":"v0.86.1 (2020-07-12)"},{"location":"changelog.html#fix_15","text":"deployment fix","title":"Fix"},{"location":"changelog.html#v0860-2020-07-12","text":"","title":"v0.86.0 (2020-07-12)"},{"location":"changelog.html#feat_27","text":"add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line","title":"Feat"},{"location":"changelog.html#v0851-2020-07-10","text":"","title":"v0.85.1 (2020-07-10)"},{"location":"changelog.html#fix_16","text":"add missing pygments requirement","title":"Fix"},{"location":"changelog.html#v0850-2020-07-10","text":"","title":"v0.85.0 (2020-07-10)"},{"location":"changelog.html#feat_28","text":"dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method","title":"Feat"},{"location":"changelog.html#refactor_20","text":"CodeEditor : use pygments for syntax highlighting","title":"Refactor"},{"location":"changelog.html#v0840-2020-07-10","text":"","title":"v0.84.0 (2020-07-10)"},{"location":"changelog.html#feat_29","text":"sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child","title":"Feat"},{"location":"changelog.html#v0831-2020-07-09","text":"","title":"v0.83.1 (2020-07-09)"},{"location":"changelog.html#refactor_21","text":"move set_icon from window classes to widget class","title":"Refactor"},{"location":"changelog.html#v0830-2020-07-09","text":"","title":"v0.83.0 (2020-07-09)"},{"location":"changelog.html#feat_30","text":"add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager","title":"Feat"},{"location":"changelog.html#v0820-2020-07-09","text":"","title":"v0.82.0 (2020-07-09)"},{"location":"changelog.html#feat_31","text":"add Label.set_bold / set_italic / set_weight added Font.set_weight","title":"Feat"},{"location":"changelog.html#v0810-2020-07-08","text":"","title":"v0.81.0 (2020-07-08)"},{"location":"changelog.html#feat_32","text":"allow setting window icon color os dark mode detection","title":"Feat"},{"location":"changelog.html#v0801-2020-07-08","text":"","title":"v0.80.1 (2020-07-08)"},{"location":"changelog.html#fix_17","text":"Settings.value() returned wrong type","title":"Fix"},{"location":"changelog.html#v0800-2020-07-08","text":"","title":"v0.80.0 (2020-07-08)"},{"location":"changelog.html#feat_33","text":"add Widget.set_attribute add margin keyword argument to Widget.set_layout","title":"Feat"},{"location":"changelog.html#v0791-2020-07-08","text":"","title":"v0.79.1 (2020-07-08)"},{"location":"changelog.html#fix_18","text":"remove Qt logger on Application exit","title":"Fix"},{"location":"changelog.html#v0790-2020-07-08","text":"","title":"v0.79.0 (2020-07-08)"},{"location":"changelog.html#feat_34","text":"add widgets.Application.get_widget","title":"Feat"},{"location":"changelog.html#v0780-2020-07-08","text":"","title":"v0.78.0 (2020-07-08)"},{"location":"changelog.html#feat_35","text":"allow to save/load window state recursively. Saving needs to be done explicitely now.","title":"Feat"},{"location":"changelog.html#fix_19","text":"some fixes for core.Settings dict interface properly preserve types in core.Settings","title":"Fix"},{"location":"changelog.html#v0771-2020-07-07","text":"","title":"v0.77.1 (2020-07-07)"},{"location":"changelog.html#refactor_22","text":"also allow qt flag for Splitter ctor","title":"Refactor"},{"location":"changelog.html#fix_20","text":"return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview","title":"Fix"},{"location":"changelog.html#0770-2020-07-06","text":"","title":"0.77.0 (2020-07-06)"},{"location":"changelog.html#feat_36","text":"allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages","title":"Feat"},{"location":"changelog.html#fix_21","text":"fix Messagebox.message call","title":"Fix"},{"location":"changelog.html#refactor_23","text":"dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars","title":"Refactor"},{"location":"contributing.html","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs ~~~~~~~~~~~ Report bugs at https://github.com/phil65/prettyqt/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs ~~~~~~~~ Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features ~~~~~~~~~~~~~~~~~~ Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ~~~~~~~~~~~~~~~~~~~ PrettyQt could always use more documentation, whether as part of the official PrettyQt docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback ~~~~~~~~~~~~~~~ The best way to send feedback is to file an issue at https://github.com/phil65/prettyqt/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! Ready to contribute? Here's how to set up prettyqt for local development. Fork the prettyqt repo on GitHub. Clone your fork locally:: $ git clone git@github.com:your_name_here/prettyqt.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:: $ mkvirtualenv prettyqt $ cd prettyqt/ $ python setup.py develop Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests: $ flake8 prettyqt tests $ py.test To install required development libraries, run \"pip install -r requirements_dev.txt\". Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6 - 3.8. Check https://travis-ci.org/phil65/prettyqt/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Contributing"},{"location":"contributing.html#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing.html#types-of-contributions","text":"Report Bugs ~~~~~~~~~~~ Report bugs at https://github.com/phil65/prettyqt/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs ~~~~~~~~ Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features ~~~~~~~~~~~~~~~~~~ Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ~~~~~~~~~~~~~~~~~~~ PrettyQt could always use more documentation, whether as part of the official PrettyQt docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback ~~~~~~~~~~~~~~~ The best way to send feedback is to file an issue at https://github.com/phil65/prettyqt/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Types of Contributions"},{"location":"contributing.html#get-started","text":"Ready to contribute? Here's how to set up prettyqt for local development. Fork the prettyqt repo on GitHub. Clone your fork locally:: $ git clone git@github.com:your_name_here/prettyqt.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:: $ mkvirtualenv prettyqt $ cd prettyqt/ $ python setup.py develop Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests: $ flake8 prettyqt tests $ py.test To install required development libraries, run \"pip install -r requirements_dev.txt\". Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing.html#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6 - 3.8. Check https://travis-ci.org/phil65/prettyqt/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"api/charts.html","text":"charts module Charts module. abstractseries AbstractSeries QAbstractSeries with some custom properties. chart Chart apply_nice_numbers ( self ) Adjust both axis to display nice round numbers. Source code in prettyqt/charts/chart.py 62 63 64 65 def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers () update_boundaries ( self ) Set new min/max values based on axis. Source code in prettyqt/charts/chart.py 38 39 40 41 42 43 def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min () zoom_by_factor ( self , factor ) Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y )) chartview ChartView keyPressEvent ( self , event ) Handle keypress events to allow navigation via keyboard. Source code in prettyqt/charts/chartview.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_0 : self . chart () . apply_nice_numbers () else : return super () . keyPressEvent ( event ) event . accept () mouseMoveEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . RightButton : if not self . last_mouse_pos : return None pos_diff = event . pos () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . pos () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event ) mousePressEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py 66 67 68 69 70 71 72 73 74 def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : cursor = gui . Cursor ( QtCore . Qt . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . pos () event . accept () super () . mousePressEvent ( event ) mouseReleaseEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py 58 59 60 61 62 63 64 def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return None super () . mouseReleaseEvent ( event ) save_as_image ( self ) Let user choose folder and save chart as an image file. Source code in prettyqt/charts/chartview.py 96 97 98 99 100 101 102 103 104 105 106 107 108 @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return None self . chart () . show_legend () image = self . get_image () image . save ( filename [ 0 ]) self . chart () . hide_legend () wheelEvent ( self , event ) Handle wheel event for zooming. Source code in prettyqt/charts/chartview.py 53 54 55 56 def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct ) lineseries LineSeries QLineSeries with some custom properties. xyseries XYSeries QXYSeries with some custom properties.","title":"charts"},{"location":"api/charts.html#charts-module","text":"","title":"charts module"},{"location":"api/charts.html#prettyqt.charts","text":"Charts module.","title":"prettyqt.charts"},{"location":"api/charts.html#prettyqt.charts.abstractseries","text":"","title":"abstractseries"},{"location":"api/charts.html#prettyqt.charts.abstractseries.AbstractSeries","text":"QAbstractSeries with some custom properties.","title":"AbstractSeries"},{"location":"api/charts.html#prettyqt.charts.chart","text":"","title":"chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart","text":"","title":"Chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.apply_nice_numbers","text":"Adjust both axis to display nice round numbers. Source code in prettyqt/charts/chart.py 62 63 64 65 def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers ()","title":"apply_nice_numbers()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.update_boundaries","text":"Set new min/max values based on axis. Source code in prettyqt/charts/chart.py 38 39 40 41 42 43 def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min ()","title":"update_boundaries()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.zoom_by_factor","text":"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y ))","title":"zoom_by_factor()"},{"location":"api/charts.html#prettyqt.charts.chartview","text":"","title":"chartview"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView","text":"","title":"ChartView"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.keyPressEvent","text":"Handle keypress events to allow navigation via keyboard. Source code in prettyqt/charts/chartview.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_0 : self . chart () . apply_nice_numbers () else : return super () . keyPressEvent ( event ) event . accept ()","title":"keyPressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseMoveEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . RightButton : if not self . last_mouse_pos : return None pos_diff = event . pos () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . pos () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event )","title":"mouseMoveEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mousePressEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py 66 67 68 69 70 71 72 73 74 def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : cursor = gui . Cursor ( QtCore . Qt . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . pos () event . accept () super () . mousePressEvent ( event )","title":"mousePressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseReleaseEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py 58 59 60 61 62 63 64 def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return None super () . mouseReleaseEvent ( event )","title":"mouseReleaseEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.save_as_image","text":"Let user choose folder and save chart as an image file. Source code in prettyqt/charts/chartview.py 96 97 98 99 100 101 102 103 104 105 106 107 108 @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return None self . chart () . show_legend () image = self . get_image () image . save ( filename [ 0 ]) self . chart () . hide_legend ()","title":"save_as_image()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.wheelEvent","text":"Handle wheel event for zooming. Source code in prettyqt/charts/chartview.py 53 54 55 56 def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct )","title":"wheelEvent()"},{"location":"api/charts.html#prettyqt.charts.lineseries","text":"","title":"lineseries"},{"location":"api/charts.html#prettyqt.charts.lineseries.LineSeries","text":"QLineSeries with some custom properties.","title":"LineSeries"},{"location":"api/charts.html#prettyqt.charts.xyseries","text":"","title":"xyseries"},{"location":"api/charts.html#prettyqt.charts.xyseries.XYSeries","text":"QXYSeries with some custom properties.","title":"XYSeries"},{"location":"api/core.html","text":"core module Core module. Contains QtCore-based classes abstractitemmodel AbstractItemModel __len__ ( self ) special Return amount of rows. Source code in prettyqt/core/abstractitemmodel.py 18 19 20 def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount () change_layout ( self ) Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py 31 32 33 34 35 36 37 38 39 40 41 42 @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit () reset_model ( self ) Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py 44 45 46 47 48 49 50 51 52 53 54 55 @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel () datastream DataStream get_byte_order ( self ) Return byte order. possible values are \"big_endian\", \"little_endian\" Returns: Type Description bool byte order Source code in prettyqt/core/datastream.py 35 36 37 38 39 40 41 42 43 def get_byte_order ( self ) -> bool : \"\"\"Return byte order. possible values are \"big_endian\", \"little_endian\" Returns: byte order \"\"\" return BYTE_ORDER . inv [ self . byteOrder ()] get_float_precision ( self ) Return floating point precision. possible values are \"single\", \"double\" Returns: Type Description bool floating point precision Source code in prettyqt/core/datastream.py 60 61 62 63 64 65 66 67 68 def get_float_precision ( self ) -> bool : \"\"\"Return floating point precision. possible values are \"single\", \"double\" Returns: floating point precision \"\"\" return FLOAT_PRECISION . inv [ self . floatingPointPrecision ()] set_byte_order ( self , order ) Set byte order. valid values are: \"big_endian\", \"little endian\" Parameters: Name Type Description Default order str byte order to use required Exceptions: Type Description InvalidParamError invalid order Source code in prettyqt/core/datastream.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def set_byte_order ( self , order : str ): \"\"\"Set byte order. valid values are: \"big_endian\", \"little endian\" Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ]) set_float_precision ( self , precision ) Set floating point precision. valid values are: \"single\", \"double\" Parameters: Name Type Description Default precision str floating point precision required Exceptions: Type Description InvalidParamError invalid precision Source code in prettyqt/core/datastream.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def set_float_precision ( self , precision : str ): \"\"\"Set floating point precision. valid values are: \"single\", \"double\" Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOAT_PRECISION : raise InvalidParamError ( precision , FLOAT_PRECISION ) self . setFloatingPointPrecision ( FLOAT_PRECISION [ precision ]) date Date __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/date.py 7 8 def __reduce__ ( self ): return ( self . __class__ , ( self . year (), self . month (), self . day ())) datetime DateTime __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/datetime.py 12 13 def __reduce__ ( self ): return ( self . __class__ , ( self . date (), self . time ())) regularexpression RegularExpression globalMatch ( self , * args , ** kwargs ) globalMatch(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py 54 55 56 def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it ) match ( self , text , offset = 0 , match_type = 'normal' , anchored = False ) match(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def match ( self , text : str , offset : int = 0 , match_type : str = \"normal\" , anchored : bool = False , ): if isinstance ( match_type , str ): match_type = MATCH_TYPES [ match_type ] if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , match_type , options ) return core . RegularExpressionMatch ( match ) settings Settings get_default_format () classmethod Return default settings format. possible values are \"native\", \"ini\" Returns: Type Description str default settings format Source code in prettyqt/core/settings.py 105 106 107 108 109 110 111 112 113 114 @classmethod def get_default_format ( cls ) -> str : \"\"\"Return default settings format. possible values are \"native\", \"ini\" Returns: default settings format \"\"\" return FORMATS . inv [ cls . defaultFormat ()] get_scope ( self ) Return scope. possible values are \"user\", \"system\" Returns: Type Description str scope Source code in prettyqt/core/settings.py 116 117 118 119 120 121 122 123 124 def get_scope ( self ) -> str : \"\"\"Return scope. possible values are \"user\", \"system\" Returns: scope \"\"\" return SCOPES . inv [ self . scope ()] group ( self , prefix ) Context manager for setting groups. Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py 143 144 145 146 147 148 149 150 151 152 @contextlib . contextmanager def group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup () read_array ( self , prefix ) Context manager for reading arrays. Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py 166 167 168 169 170 171 172 173 174 175 @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray () set_default_format ( fmt ) classmethod Set the default format. possible values are \"native\", \"ini\" Parameters: Name Type Description Default fmt str the default format to use required Exceptions: Type Description InvalidParamError invalid format Source code in prettyqt/core/settings.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @classmethod def set_default_format ( cls , fmt : str ): \"\"\"Set the default format. possible values are \"native\", \"ini\" Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMATS : raise InvalidParamError ( fmt , FORMATS ) cls . setDefaultFormat ( FORMATS [ fmt ]) set_path ( fmt , scope , path ) classmethod Set the path to the settings file. Parameters: Name Type Description Default fmt str the default format to use required scope str the scope to use required Exceptions: Type Description InvalidParamError invalid format or scope Source code in prettyqt/core/settings.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @classmethod def set_path ( cls , fmt : str , scope : str , path : Union [ str , pathlib . Path ]): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMATS : raise InvalidParamError ( fmt , FORMATS ) if scope not in SCOPES : raise InvalidParamError ( scope , SCOPES ) cls . setPath ( FORMATS [ fmt ], SCOPES [ scope ], str ( path )) write_array ( self , prefix , size =- 1 ) Context manager for writing arrays. Parameters: Name Type Description Default prefix str prefix for settings array required size int size of settings array -1 Source code in prettyqt/core/settings.py 154 155 156 157 158 159 160 161 162 163 164 @contextlib . contextmanager def write_array ( self , prefix : str , size : int = - 1 ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" self . beginWriteArray ( prefix , size ) yield None self . endArray () size Size __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/size.py 13 14 def __reduce__ ( self ): return ( self . __class__ , ( self . width (), self . height ())) url Url to_path ( self ) Get pathlib object from the URL. Returns: Type Description Path Path Source code in prettyqt/core/url.py 26 27 28 29 30 31 32 def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self )) versionnumber VersionNumber major ( self ) An integer representing the major version. Source code in prettyqt/core/versionnumber.py 54 55 56 def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion () micro ( self ) An integer representing the micro version. Source code in prettyqt/core/versionnumber.py 62 63 64 def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion () minor ( self ) An integer representing the minor version. Source code in prettyqt/core/versionnumber.py 58 59 60 def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion ()","title":"core"},{"location":"api/core.html#core-module","text":"","title":"core module"},{"location":"api/core.html#prettyqt.core","text":"Core module. Contains QtCore-based classes","title":"prettyqt.core"},{"location":"api/core.html#prettyqt.core.abstractitemmodel","text":"","title":"abstractitemmodel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel","text":"","title":"AbstractItemModel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.__len__","text":"Return amount of rows. Source code in prettyqt/core/abstractitemmodel.py 18 19 20 def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.change_layout","text":"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py 31 32 33 34 35 36 37 38 39 40 41 42 @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit ()","title":"change_layout()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.reset_model","text":"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py 44 45 46 47 48 49 50 51 52 53 54 55 @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel ()","title":"reset_model()"},{"location":"api/core.html#prettyqt.core.datastream","text":"","title":"datastream"},{"location":"api/core.html#prettyqt.core.datastream.DataStream","text":"","title":"DataStream"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_byte_order","text":"Return byte order. possible values are \"big_endian\", \"little_endian\" Returns: Type Description bool byte order Source code in prettyqt/core/datastream.py 35 36 37 38 39 40 41 42 43 def get_byte_order ( self ) -> bool : \"\"\"Return byte order. possible values are \"big_endian\", \"little_endian\" Returns: byte order \"\"\" return BYTE_ORDER . inv [ self . byteOrder ()]","title":"get_byte_order()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_float_precision","text":"Return floating point precision. possible values are \"single\", \"double\" Returns: Type Description bool floating point precision Source code in prettyqt/core/datastream.py 60 61 62 63 64 65 66 67 68 def get_float_precision ( self ) -> bool : \"\"\"Return floating point precision. possible values are \"single\", \"double\" Returns: floating point precision \"\"\" return FLOAT_PRECISION . inv [ self . floatingPointPrecision ()]","title":"get_float_precision()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_byte_order","text":"Set byte order. valid values are: \"big_endian\", \"little endian\" Parameters: Name Type Description Default order str byte order to use required Exceptions: Type Description InvalidParamError invalid order Source code in prettyqt/core/datastream.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def set_byte_order ( self , order : str ): \"\"\"Set byte order. valid values are: \"big_endian\", \"little endian\" Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ])","title":"set_byte_order()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_float_precision","text":"Set floating point precision. valid values are: \"single\", \"double\" Parameters: Name Type Description Default precision str floating point precision required Exceptions: Type Description InvalidParamError invalid precision Source code in prettyqt/core/datastream.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def set_float_precision ( self , precision : str ): \"\"\"Set floating point precision. valid values are: \"single\", \"double\" Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOAT_PRECISION : raise InvalidParamError ( precision , FLOAT_PRECISION ) self . setFloatingPointPrecision ( FLOAT_PRECISION [ precision ])","title":"set_float_precision()"},{"location":"api/core.html#prettyqt.core.date","text":"","title":"date"},{"location":"api/core.html#prettyqt.core.date.Date","text":"","title":"Date"},{"location":"api/core.html#prettyqt.core.date.Date.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/date.py 7 8 def __reduce__ ( self ): return ( self . __class__ , ( self . year (), self . month (), self . day ()))","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.datetime","text":"","title":"datetime"},{"location":"api/core.html#prettyqt.core.datetime.DateTime","text":"","title":"DateTime"},{"location":"api/core.html#prettyqt.core.datetime.DateTime.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/datetime.py 12 13 def __reduce__ ( self ): return ( self . __class__ , ( self . date (), self . time ()))","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.regularexpression","text":"","title":"regularexpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression","text":"","title":"RegularExpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.globalMatch","text":"globalMatch(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py 54 55 56 def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it )","title":"globalMatch()"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.match","text":"match(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def match ( self , text : str , offset : int = 0 , match_type : str = \"normal\" , anchored : bool = False , ): if isinstance ( match_type , str ): match_type = MATCH_TYPES [ match_type ] if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , match_type , options ) return core . RegularExpressionMatch ( match )","title":"match()"},{"location":"api/core.html#prettyqt.core.settings","text":"","title":"settings"},{"location":"api/core.html#prettyqt.core.settings.Settings","text":"","title":"Settings"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_default_format","text":"Return default settings format. possible values are \"native\", \"ini\" Returns: Type Description str default settings format Source code in prettyqt/core/settings.py 105 106 107 108 109 110 111 112 113 114 @classmethod def get_default_format ( cls ) -> str : \"\"\"Return default settings format. possible values are \"native\", \"ini\" Returns: default settings format \"\"\" return FORMATS . inv [ cls . defaultFormat ()]","title":"get_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_scope","text":"Return scope. possible values are \"user\", \"system\" Returns: Type Description str scope Source code in prettyqt/core/settings.py 116 117 118 119 120 121 122 123 124 def get_scope ( self ) -> str : \"\"\"Return scope. possible values are \"user\", \"system\" Returns: scope \"\"\" return SCOPES . inv [ self . scope ()]","title":"get_scope()"},{"location":"api/core.html#prettyqt.core.settings.Settings.group","text":"Context manager for setting groups. Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py 143 144 145 146 147 148 149 150 151 152 @contextlib . contextmanager def group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup ()","title":"group()"},{"location":"api/core.html#prettyqt.core.settings.Settings.read_array","text":"Context manager for reading arrays. Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py 166 167 168 169 170 171 172 173 174 175 @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray ()","title":"read_array()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_default_format","text":"Set the default format. possible values are \"native\", \"ini\" Parameters: Name Type Description Default fmt str the default format to use required Exceptions: Type Description InvalidParamError invalid format Source code in prettyqt/core/settings.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @classmethod def set_default_format ( cls , fmt : str ): \"\"\"Set the default format. possible values are \"native\", \"ini\" Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMATS : raise InvalidParamError ( fmt , FORMATS ) cls . setDefaultFormat ( FORMATS [ fmt ])","title":"set_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_path","text":"Set the path to the settings file. Parameters: Name Type Description Default fmt str the default format to use required scope str the scope to use required Exceptions: Type Description InvalidParamError invalid format or scope Source code in prettyqt/core/settings.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @classmethod def set_path ( cls , fmt : str , scope : str , path : Union [ str , pathlib . Path ]): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMATS : raise InvalidParamError ( fmt , FORMATS ) if scope not in SCOPES : raise InvalidParamError ( scope , SCOPES ) cls . setPath ( FORMATS [ fmt ], SCOPES [ scope ], str ( path ))","title":"set_path()"},{"location":"api/core.html#prettyqt.core.settings.Settings.write_array","text":"Context manager for writing arrays. Parameters: Name Type Description Default prefix str prefix for settings array required size int size of settings array -1 Source code in prettyqt/core/settings.py 154 155 156 157 158 159 160 161 162 163 164 @contextlib . contextmanager def write_array ( self , prefix : str , size : int = - 1 ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" self . beginWriteArray ( prefix , size ) yield None self . endArray ()","title":"write_array()"},{"location":"api/core.html#prettyqt.core.size","text":"","title":"size"},{"location":"api/core.html#prettyqt.core.size.Size","text":"","title":"Size"},{"location":"api/core.html#prettyqt.core.size.Size.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/size.py 13 14 def __reduce__ ( self ): return ( self . __class__ , ( self . width (), self . height ()))","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.url","text":"","title":"url"},{"location":"api/core.html#prettyqt.core.url.Url","text":"","title":"Url"},{"location":"api/core.html#prettyqt.core.url.Url.to_path","text":"Get pathlib object from the URL. Returns: Type Description Path Path Source code in prettyqt/core/url.py 26 27 28 29 30 31 32 def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self ))","title":"to_path()"},{"location":"api/core.html#prettyqt.core.versionnumber","text":"","title":"versionnumber"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber","text":"","title":"VersionNumber"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.major","text":"An integer representing the major version. Source code in prettyqt/core/versionnumber.py 54 55 56 def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion ()","title":"major()"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.micro","text":"An integer representing the micro version. Source code in prettyqt/core/versionnumber.py 62 63 64 def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion ()","title":"micro()"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.minor","text":"An integer representing the minor version. Source code in prettyqt/core/versionnumber.py 58 59 60 def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion ()","title":"minor()"},{"location":"api/custom_delegates.html","text":"custom_delegates module Module containing custom delegate classes. buttondelegate ButtonDelegate createEditor ( self , parent , option , index ) createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/buttondelegate.py 15 16 17 18 19 20 21 22 23 def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn setEditorData ( self , editor , index ) setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py 25 26 def setEditorData ( self , editor , index ): pass setModelData ( self , editor , model , index ) setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py 28 29 def setModelData ( self , editor , model , index ): pass checkboxdelegate CheckBoxDelegate Delegate that places a CheckBox in every cell. createEditor ( self , parent , option , index ) Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. Source code in prettyqt/custom_delegates/checkboxdelegate.py 19 20 21 22 23 24 25 26 27 def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb setEditorData ( self , cb , index ) Override. set correct initial value for editor widget Source code in prettyqt/custom_delegates/checkboxdelegate.py 29 30 31 32 33 34 35 36 def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection ) setModelData ( self , combo , model , index ) Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. Source code in prettyqt/custom_delegates/checkboxdelegate.py 38 39 40 41 42 43 44 45 46 47 48 def setModelData ( self , combo , model , index ): \"\"\"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. \"\"\" dtype = self . dtypes [ combo . currentText ()] # s = model.data(index, model.DATA_ROLE) try : model . setData ( index , dtype , model . DTYPE_ROLE ) except ValueError as e : logger . error ( e ) icondelegate IconDelegate paint ( self , painter , option , index ) Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Parameters: Name Type Description Default painter QPainter painter to paint the icon required option QStyleOptionViewItem state of the item to be displayed required index QModelIndex index which gets decorated required Source code in prettyqt/custom_delegates/icondelegate.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if value : margin = 10 mode = gui . Icon . Normal if not ( option . state & widgets . Style . State_Enabled ): mode = gui . Icon . Disabled elif option . state & widgets . Style . State_Selected : mode = gui . Icon . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QIcon ): state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) actualSize = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = core . Size ( min ( option . decorationSize . width (), actualSize . width ()), min ( option . decorationSize . height (), actualSize . height ()), ) r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) icon . paint ( painter , r , constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER , mode , state ) nofocusdelegate NoFocusDelegate paint ( self , painter , option , index ) paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/nofocusdelegate.py 10 11 12 13 14 15 16 17 18 def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . State_HasFocus : option . state = option . state ^ widgets . Style . State_HasFocus super () . paint ( painter , option , index ) radiodelegate RadioDelegate createEditor ( self , parent , option , index ) createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/radiodelegate.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def createEditor ( self , parent , option , index ): editor = widgets . Widget ( parent ) editor . setContentsMargins ( 0 , 0 , 0 , 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . buttonGroup = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . setFocusPolicy ( QtCore . Qt . NoFocus ) rb . installEventFilter ( self ) editor . buttonGroup . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) editor . installEventFilter ( self ) return editor eventFilter ( self , source , event ) eventFilter(self, QObject, QEvent) -> bool Source code in prettyqt/custom_delegates/radiodelegate.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def eventFilter ( self , source , event ): if event . type () == core . Event . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event ) setEditorData ( self , editor , index ) setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py 76 77 78 79 def setEditorData ( self , editor , index ): value = index . data ( QtCore . Qt . DisplayRole ) if value in self . items : editor . buttonGroup . button ( self . items . index ( value )) . setChecked ( True ) setModelData ( self , editor , model , index ) setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py 81 82 83 84 85 def setModelData ( self , editor , model , index ): button = editor . buttonGroup . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], QtCore . Qt . DisplayRole ) self . choices [ button ] = index . row () updateEditorGeometry ( self , editor , option , index ) updateEditorGeometry(self, QWidget, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py 65 66 67 68 69 70 71 72 73 74 def updateEditorGeometry ( self , editor , option , index ): rect = core . Rect ( option . rect ) minWidth = editor . minimumSizeHint () . width () if rect . width () < minWidth : rect . setWidth ( minWidth ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) editor . setMask ( mask )","title":"custom_delegates"},{"location":"api/custom_delegates.html#custom_delegates-module","text":"","title":"custom_delegates module"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates","text":"Module containing custom delegate classes.","title":"prettyqt.custom_delegates"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate","text":"","title":"buttondelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate","text":"","title":"ButtonDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.createEditor","text":"createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/buttondelegate.py 15 16 17 18 19 20 21 22 23 def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setEditorData","text":"setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py 25 26 def setEditorData ( self , editor , index ): pass","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setModelData","text":"setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py 28 29 def setModelData ( self , editor , model , index ): pass","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate","text":"","title":"checkboxdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate","text":"Delegate that places a CheckBox in every cell.","title":"CheckBoxDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.createEditor","text":"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. Source code in prettyqt/custom_delegates/checkboxdelegate.py 19 20 21 22 23 24 25 26 27 def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.setEditorData","text":"Override. set correct initial value for editor widget Source code in prettyqt/custom_delegates/checkboxdelegate.py 29 30 31 32 33 34 35 36 def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection )","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.setModelData","text":"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. Source code in prettyqt/custom_delegates/checkboxdelegate.py 38 39 40 41 42 43 44 45 46 47 48 def setModelData ( self , combo , model , index ): \"\"\"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. \"\"\" dtype = self . dtypes [ combo . currentText ()] # s = model.data(index, model.DATA_ROLE) try : model . setData ( index , dtype , model . DTYPE_ROLE ) except ValueError as e : logger . error ( e )","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate","text":"","title":"icondelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate","text":"","title":"IconDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate.paint","text":"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Parameters: Name Type Description Default painter QPainter painter to paint the icon required option QStyleOptionViewItem state of the item to be displayed required index QModelIndex index which gets decorated required Source code in prettyqt/custom_delegates/icondelegate.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if value : margin = 10 mode = gui . Icon . Normal if not ( option . state & widgets . Style . State_Enabled ): mode = gui . Icon . Disabled elif option . state & widgets . Style . State_Selected : mode = gui . Icon . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QIcon ): state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) actualSize = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = core . Size ( min ( option . decorationSize . width (), actualSize . width ()), min ( option . decorationSize . height (), actualSize . height ()), ) r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = ( gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off ) icon . paint ( painter , r , constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER , mode , state )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate","text":"","title":"nofocusdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate","text":"","title":"NoFocusDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate.paint","text":"paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/nofocusdelegate.py 10 11 12 13 14 15 16 17 18 def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . State_HasFocus : option . state = option . state ^ widgets . Style . State_HasFocus super () . paint ( painter , option , index )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate","text":"","title":"radiodelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate","text":"","title":"RadioDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.createEditor","text":"createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/radiodelegate.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def createEditor ( self , parent , option , index ): editor = widgets . Widget ( parent ) editor . setContentsMargins ( 0 , 0 , 0 , 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . buttonGroup = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . setFocusPolicy ( QtCore . Qt . NoFocus ) rb . installEventFilter ( self ) editor . buttonGroup . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) editor . installEventFilter ( self ) return editor","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.eventFilter","text":"eventFilter(self, QObject, QEvent) -> bool Source code in prettyqt/custom_delegates/radiodelegate.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def eventFilter ( self , source , event ): if event . type () == core . Event . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event )","title":"eventFilter()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setEditorData","text":"setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py 76 77 78 79 def setEditorData ( self , editor , index ): value = index . data ( QtCore . Qt . DisplayRole ) if value in self . items : editor . buttonGroup . button ( self . items . index ( value )) . setChecked ( True )","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setModelData","text":"setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py 81 82 83 84 85 def setModelData ( self , editor , model , index ): button = editor . buttonGroup . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], QtCore . Qt . DisplayRole ) self . choices [ button ] = index . row ()","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.updateEditorGeometry","text":"updateEditorGeometry(self, QWidget, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py 65 66 67 68 69 70 71 72 73 74 def updateEditorGeometry ( self , editor , option , index ): rect = core . Rect ( option . rect ) minWidth = editor . minimumSizeHint () . width () if rect . width () < minWidth : rect . setWidth ( minWidth ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) editor . setMask ( mask )","title":"updateEditorGeometry()"},{"location":"api/custom_models.html","text":"custom_models module Custom_models module. Contains custom models columnitemmodel ColumnItemModel Model that provides an interface to an objectree that is build of TreeItems. columnCount ( self , _parent = None ) Return the number of columns in the tree. Source code in prettyqt/custom_models/columnitemmodel.py 23 24 25 def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols ) data ( self , index , role ) Return the tree item at the given index and role. Source code in prettyqt/custom_models/columnitemmodel.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: func = self . _attr_cols [ col ] . label if func is None : return \"\" attr = func ( tree_item ) return attr . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None flags ( self , index ) flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/custom_models/columnitemmodel.py 56 57 58 59 def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE headerData ( self , section , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/columnitemmodel.py 61 62 63 64 65 def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None regexmatchesmodel RegexMatchesModel columnCount ( self , parent = None ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py 20 21 def columnCount ( self , parent = None ): return len ( self . HEADER ) data ( self , index , role ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span () headerData ( self , offset , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py 23 24 25 26 def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] rowCount ( self , parent = None ) Required override for AbstractitemModels. Source code in prettyqt/custom_models/regexmatchesmodel.py 44 45 46 def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches ) transposeproxymodel TransposeProxyModel columnCount ( self , parent =< PyQt5 . QtCore . QModelIndex object at 0x7f9ec84fc050 > ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py 33 34 def columnCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . rowCount ( parent ) data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py 36 37 38 39 def data ( self , index : QtCore . QModelIndex , role = QtCore . Qt . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role ) headerData ( self , section , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py 41 42 def headerData ( self , section : int , orientation , role ): return self . _source_model . headerData ( section , orientation , role ) index ( self , row , column , parent = None ) index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 24 25 def index ( self , row : int , column : int , parent = None ) -> QtCore . QModelIndex : return self . createIndex ( row , column ) mapFromSource ( self , source_index ) mapFromSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 18 19 def mapFromSource ( self , source_index : QtCore . QModelIndex ) -> QtCore . QModelIndex : return self . index ( source_index . column (), source_index . row ()) mapToSource ( self , proxy_index ) mapToSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 21 22 def mapToSource ( self , proxy_index : QtCore . QModelIndex ) -> QtCore . QModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ()) parent ( self , index ) parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/custom_models/transposeproxymodel.py 27 28 def parent ( self , index : QtCore . QModelIndex ): return None rowCount ( self , parent =< PyQt5 . QtCore . QModelIndex object at 0x7f9ec856ef50 > ) rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py 30 31 def rowCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . columnCount ( parent ) setSourceModel ( self , source_model ) setSourceModel(self, QAbstractItemModel) Source code in prettyqt/custom_models/transposeproxymodel.py 14 15 16 def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"custom_models"},{"location":"api/custom_models.html#custom_models-module","text":"","title":"custom_models module"},{"location":"api/custom_models.html#prettyqt.custom_models","text":"Custom_models module. Contains custom models","title":"prettyqt.custom_models"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel","text":"","title":"columnitemmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel","text":"Model that provides an interface to an objectree that is build of TreeItems.","title":"ColumnItemModel"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.columnCount","text":"Return the number of columns in the tree. Source code in prettyqt/custom_models/columnitemmodel.py 23 24 25 def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.data","text":"Return the tree item at the given index and role. Source code in prettyqt/custom_models/columnitemmodel.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: func = self . _attr_cols [ col ] . label if func is None : return \"\" attr = func ( tree_item ) return attr . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.flags","text":"flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/custom_models/columnitemmodel.py 56 57 58 59 def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE","title":"flags()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/columnitemmodel.py 61 62 63 64 65 def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel","text":"","title":"regexmatchesmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel","text":"","title":"RegexMatchesModel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py 20 21 def columnCount ( self , parent = None ): return len ( self . HEADER )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span ()","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py 23 24 25 26 def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ]","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.rowCount","text":"Required override for AbstractitemModels. Source code in prettyqt/custom_models/regexmatchesmodel.py 44 45 46 def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel","text":"","title":"transposeproxymodel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel","text":"","title":"TransposeProxyModel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py 33 34 def columnCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . rowCount ( parent )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.data","text":"data(self, QModelIndex, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py 36 37 38 39 def data ( self , index : QtCore . QModelIndex , role = QtCore . Qt . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role )","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py 41 42 def headerData ( self , section : int , orientation , role ): return self . _source_model . headerData ( section , orientation , role )","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.index","text":"index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 24 25 def index ( self , row : int , column : int , parent = None ) -> QtCore . QModelIndex : return self . createIndex ( row , column )","title":"index()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapFromSource","text":"mapFromSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 18 19 def mapFromSource ( self , source_index : QtCore . QModelIndex ) -> QtCore . QModelIndex : return self . index ( source_index . column (), source_index . row ())","title":"mapFromSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapToSource","text":"mapToSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 21 22 def mapToSource ( self , proxy_index : QtCore . QModelIndex ) -> QtCore . QModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ())","title":"mapToSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.parent","text":"parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/custom_models/transposeproxymodel.py 27 28 def parent ( self , index : QtCore . QModelIndex ): return None","title":"parent()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.rowCount","text":"rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py 30 31 def rowCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . columnCount ( parent )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.setSourceModel","text":"setSourceModel(self, QAbstractItemModel) Source code in prettyqt/custom_models/transposeproxymodel.py 14 15 16 def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"setSourceModel()"},{"location":"api/custom_validators.html","text":"custom_validators module Custom_validators module. Contains custom validators compositevalidator CompositeValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/compositevalidator.py 28 29 30 def validate ( self , text : str , pos : int = 0 ) -> tuple : vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] return ( min ( vals ), text , pos ) notemptyvalidator NotEmptyValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notemptyvalidator.py 7 8 9 10 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos ) notzerovalidator NotZeroValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notzerovalidator.py 7 8 9 10 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"0\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos ) pathvalidator PathValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/pathvalidator.py 9 10 11 12 def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return ( self . Acceptable , text , pos ) return ( self . Intermediate , text , pos ) regexpatternvalidator RegexPatternValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexpatternvalidator.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def validate ( self , text : str , pos : int = 0 ) -> tuple : # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : self . compiled = re . compile ( text ) except sre_constants . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) except re . _regex_core . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) else : self . error_message = \"\" return ( self . Acceptable , text , pos ) regexvalidators BaseRegexValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexvalidators.py 34 35 36 37 38 39 40 41 42 43 44 45 def validate ( self , text : str , pos : int = 0 ) -> tuple : if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , partial = True ) if match is None : return ( self . Invalid , text , pos ) if match . partial : return ( self . Intermediate , text , pos ) else : return ( self . Acceptable , text , pos )","title":"custom_validators"},{"location":"api/custom_validators.html#custom_validators-module","text":"","title":"custom_validators module"},{"location":"api/custom_validators.html#prettyqt.custom_validators","text":"Custom_validators module. Contains custom validators","title":"prettyqt.custom_validators"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator","text":"","title":"compositevalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator","text":"","title":"CompositeValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/compositevalidator.py 28 29 30 def validate ( self , text : str , pos : int = 0 ) -> tuple : vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] return ( min ( vals ), text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator","text":"","title":"notemptyvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator","text":"","title":"NotEmptyValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notemptyvalidator.py 7 8 9 10 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator","text":"","title":"notzerovalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator","text":"","title":"NotZeroValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notzerovalidator.py 7 8 9 10 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"0\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator","text":"","title":"pathvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator","text":"","title":"PathValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/pathvalidator.py 9 10 11 12 def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return ( self . Acceptable , text , pos ) return ( self . Intermediate , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator","text":"","title":"regexpatternvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator","text":"","title":"RegexPatternValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexpatternvalidator.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def validate ( self , text : str , pos : int = 0 ) -> tuple : # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : self . compiled = re . compile ( text ) except sre_constants . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) except re . _regex_core . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) else : self . error_message = \"\" return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators","text":"","title":"regexvalidators"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator","text":"","title":"BaseRegexValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexvalidators.py 34 35 36 37 38 39 40 41 42 43 44 45 def validate ( self , text : str , pos : int = 0 ) -> tuple : if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , partial = True ) if match is None : return ( self . Invalid , text , pos ) if match . partial : return ( self . Intermediate , text , pos ) else : return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_widgets.html","text":"custom_widgets module Module containing custom widget classes. codeeditor CodeEditor resizeEvent ( self , event ) resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/codeeditor.py 36 37 38 39 40 41 def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect ) LineNumberArea paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/codeeditor.py 18 19 def paintEvent ( self , event ): self . editor . line_area_paintevent ( event ) sizeHint ( self ) sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/codeeditor.py 15 16 def sizeHint ( self ): return core . Size ( self . editor . line_area_width (), 0 ) dataset DataItem set_pos ( self , col = 0 , colspan = None ) Set data item's position on a GUI layout. Source code in prettyqt/custom_widgets/dataset.py 34 35 36 37 38 def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self DataSetMeta __new__ ( mcs , name , bases , dct ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py 422 423 424 425 426 427 428 429 430 431 def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct ) filechooserbutton FileChooserButton __init__ ( self , extensions = None , mode = 'save' , file_mode = 'existing_files' , root = None , parent = None ) special Initialize FileChooserButton. Parameters: Name Type Description Default extensions Optional[Dict[str, List[str]]] dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode str Accept mode (\"save\" or \"load\") 'save' file_mode str File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' root Union[NoneType, str, pathlib.Path] Root path None parent Optional[PyQt5.QtWidgets.QWidget] parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , extensions : Optional [ Dict [ str , List [ str ]]] = None , mode : str = \"save\" , file_mode : str = \"existing_files\" , root : Union [ None , str , pathlib . Path ] = None , parent : Optional [ QtWidgets . QWidget ] = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : Optional [ pathlib . Path ] = None self . extensions = extensions self . mode = mode self . file_mode = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout += self . lineedit action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout += self . button flowlayout FlowLayout addItem ( self , item ) addItem(self, QLayoutItem) Source code in prettyqt/custom_widgets/flowlayout.py 41 42 def addItem ( self , item ): self . items . append ( item ) count ( self ) count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py 44 45 def count ( self ) -> int : return len ( self . items ) expandingDirections ( self ) expandingDirections(self) -> Qt.Orientations Source code in prettyqt/custom_widgets/flowlayout.py 59 60 def expandingDirections ( self ): return QtCore . Qt . Orientations ( QtCore . Qt . Orientation ( 0 )) hasHeightForWidth ( self ) hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py 62 63 def hasHeightForWidth ( self ) -> bool : return True heightForWidth ( self , width ) heightForWidth(self, int) -> int Source code in prettyqt/custom_widgets/flowlayout.py 65 66 def heightForWidth ( self , width : int ): return self . do_layout ( core . Rect ( 0 , 0 , width , 0 ), True ) itemAt ( self , index ) itemAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py 47 48 49 50 51 def itemAt ( self , index : int ): if 0 <= index < len ( self . items ): return self . items [ index ] return None minimumSize ( self ) minimumSize(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py 75 76 77 78 79 80 81 82 83 def minimumSize ( self ): size = core . Size () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += core . Size ( margin_width , margin_width ) return size setGeometry ( self , rect ) setGeometry(self, QRect) Source code in prettyqt/custom_widgets/flowlayout.py 68 69 70 def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False ) sizeHint ( self ) sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py 72 73 def sizeHint ( self ) -> core . Size : return self . minimumSize () takeAt ( self , index ) takeAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py 53 54 55 56 57 def takeAt ( self , index : int ): if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None labeledslider LabeledSlider paintEvent ( self , e ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/labeledslider.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () painter = gui . Painter ( self ) st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PM_SliderSpaceAvailable , st_slider , self . sl ) for v , v_str in self . levels : # get the size of the label rect = painter . drawText ( core . Rect (), QtCore . Qt . TextDontPrint , v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc if self . bottom_margin <= rect . height (): self . bottom_margin = rect . height () self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) painter . drawText ( left , bottom , v_str ) return popupinfo PopupInfo Dialog overlay to show some info to user. show ( self , * args , ** kwargs ) show(self) Source code in prettyqt/custom_widgets/popupinfo.py 33 34 35 36 37 38 39 40 41 def show ( self , * args , ** kwargs ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) / 2 y = ( screen_geo . height () - size . height ()) / 2 self . move ( x , y - 200 ) super () . show ( * args , ** kwargs ) self . timer . start ( 2500 ) promptlineedit Credits to PyQode Authors. PromptLineEdit Extends QLineEdit to show a prompt text and a clear icon. prompt_text: str property writable Gets/Sets the prompt text. paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/promptlineedit.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def paintEvent ( self , event ): super () . paintEvent ( event ) if self . _prompt_text and not self . text () and self . isEnabled (): option = widgets . StyleOptionFrame () self . initStyleOption ( option ) left , top , right , bottom = self . getTextMargins () va = self . style () . visualAlignment ( self . layoutDirection (), self . alignment ()) rect = ( self . style () . subElementRect ( widgets . Style . SE_LineEditContents , option , self ) . adjusted ( 2 , 0 , 0 , 0 ) . adjusted ( left , top , - right , - bottom ) ) fm = gui . FontMetrics ( self . font ()) text = fm . elided_text ( self . _prompt_text , mode = \"right\" , width = rect . width ()) painter = gui . Painter ( self ) painter . setPen ( self . palette () . color ( gui . Palette . Disabled , gui . Palette . Text )) painter . drawText ( rect , va , text ) resizeEvent ( self , event ) resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/promptlineedit.py 70 71 72 73 74 def resizeEvent ( self , event ): # Adjusts Clear button position super () . resizeEvent ( event ) self . button . resize ( core . Size ( self . _margin , self . height () - 2 )) self . button . move ( self . width () - self . _margin - 3 , 1 ) set_button_visible ( self , visible ) Sets the clear button as visible . Parameters: Name Type Description Default visible bool Visibility of button required Source code in prettyqt/custom_widgets/promptlineedit.py 76 77 78 79 80 81 82 83 84 85 86 87 88 def set_button_visible ( self , visible : bool ): \"\"\"Sets the clear button as ``visible``. Args: visible (bool): Visibility of button \"\"\" self . button . setVisible ( visible ) left , top , right , bottom = self . getTextMargins () if visible : right = self . _margin + self . _spacing else : right = 0 self . setTextMargins ( left , top , right , bottom ) regexeditor special Module containing classes related to the RegEx editor. editor This module contains the editor widget implementation. quick_ref Contains the quick reference widget. spanslider SpanSlider mouseMoveEvent ( self , event ) mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PM_MaximumDragDistance , opt , self ) new_pos = self . pixel_pos_to_value ( self . pick ( event . pos ()) - self . offset ) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . pos ()): new_pos = self . position # pick the preferred handle on the first movement if self . first_movement : if self . lower == self . upper : if new_pos < self . lower_value : self . swap_controls () self . first_movement = False else : self . first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper - 1 ) if self . movement == \"free\" and new_pos > self . upper : self . swap_controls () self . set_upper_pos ( new_pos ) else : self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower : self . swap_controls () self . set_lower_pos ( new_pos ) else : self . set_upper_pos ( new_pos ) event . accept () mousePressEvent ( self , event ) mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . handle_mouse_press ( event . pos (), self . upper_pressed , self . upper , self . UPPER_HANDLE ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . handle_mouse_press ( event . pos (), self . lower_pressed , self . lower , self . LOWER_HANDLE ) self . first_movement = True event . accept () mouseReleaseEvent ( self , event ) mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 433 434 435 436 437 def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SC_None self . update () paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/spanslider.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SC_SliderTickmarks painter . drawComplexControl ( SLIDER_STYLE , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . drawComplexControl ( SLIDER_STYLE , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () spanRect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) if self . is_horizontal (): spanRect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) self . draw_span ( painter , spanRect ) # handles if self . last_pressed == self . LOWER_HANDLE : self . draw_handle ( painter , self . UPPER_HANDLE ) self . draw_handle ( painter , self . LOWER_HANDLE ) else : self . draw_handle ( painter , self . LOWER_HANDLE ) self . draw_handle ( painter , self . UPPER_HANDLE ) waitingspinner The MIT License (MIT). Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. BaseWaitingSpinner paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( \"none\" ) for i in range ( 0 , self . _line_num ): painter . save () painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length , ) rotate_angle = float ( 360 * i ) / float ( self . _line_num ) painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) rect = core . Rect ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . RelativeSize ) painter . restore () WaitingSpinner paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py 238 239 240 def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event )","title":"custom_widgets"},{"location":"api/custom_widgets.html#custom_widgets-module","text":"","title":"custom_widgets module"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets","text":"Module containing custom widget classes.","title":"prettyqt.custom_widgets"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor","text":"","title":"codeeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor","text":"","title":"CodeEditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor.resizeEvent","text":"resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/codeeditor.py 36 37 38 39 40 41 def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea","text":"","title":"LineNumberArea"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/codeeditor.py 18 19 def paintEvent ( self , event ): self . editor . line_area_paintevent ( event )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.sizeHint","text":"sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/codeeditor.py 15 16 def sizeHint ( self ): return core . Size ( self . editor . line_area_width (), 0 )","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset","text":"","title":"dataset"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem","text":"","title":"DataItem"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem.set_pos","text":"Set data item's position on a GUI layout. Source code in prettyqt/custom_widgets/dataset.py 34 35 36 37 38 def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self","title":"set_pos()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta","text":"","title":"DataSetMeta"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py 422 423 424 425 426 427 428 429 430 431 def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct )","title":"__new__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton","text":"","title":"filechooserbutton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton","text":"","title":"FileChooserButton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton.__init__","text":"Initialize FileChooserButton. Parameters: Name Type Description Default extensions Optional[Dict[str, List[str]]] dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode str Accept mode (\"save\" or \"load\") 'save' file_mode str File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' root Union[NoneType, str, pathlib.Path] Root path None parent Optional[PyQt5.QtWidgets.QWidget] parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , extensions : Optional [ Dict [ str , List [ str ]]] = None , mode : str = \"save\" , file_mode : str = \"existing_files\" , root : Union [ None , str , pathlib . Path ] = None , parent : Optional [ QtWidgets . QWidget ] = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : Optional [ pathlib . Path ] = None self . extensions = extensions self . mode = mode self . file_mode = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout += self . lineedit action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout += self . button","title":"__init__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout","text":"","title":"flowlayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout","text":"","title":"FlowLayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.addItem","text":"addItem(self, QLayoutItem) Source code in prettyqt/custom_widgets/flowlayout.py 41 42 def addItem ( self , item ): self . items . append ( item )","title":"addItem()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.count","text":"count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py 44 45 def count ( self ) -> int : return len ( self . items )","title":"count()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.expandingDirections","text":"expandingDirections(self) -> Qt.Orientations Source code in prettyqt/custom_widgets/flowlayout.py 59 60 def expandingDirections ( self ): return QtCore . Qt . Orientations ( QtCore . Qt . Orientation ( 0 ))","title":"expandingDirections()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.hasHeightForWidth","text":"hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py 62 63 def hasHeightForWidth ( self ) -> bool : return True","title":"hasHeightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.heightForWidth","text":"heightForWidth(self, int) -> int Source code in prettyqt/custom_widgets/flowlayout.py 65 66 def heightForWidth ( self , width : int ): return self . do_layout ( core . Rect ( 0 , 0 , width , 0 ), True )","title":"heightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.itemAt","text":"itemAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py 47 48 49 50 51 def itemAt ( self , index : int ): if 0 <= index < len ( self . items ): return self . items [ index ] return None","title":"itemAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.minimumSize","text":"minimumSize(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py 75 76 77 78 79 80 81 82 83 def minimumSize ( self ): size = core . Size () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += core . Size ( margin_width , margin_width ) return size","title":"minimumSize()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.setGeometry","text":"setGeometry(self, QRect) Source code in prettyqt/custom_widgets/flowlayout.py 68 69 70 def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False )","title":"setGeometry()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.sizeHint","text":"sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py 72 73 def sizeHint ( self ) -> core . Size : return self . minimumSize ()","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.takeAt","text":"takeAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py 53 54 55 56 57 def takeAt ( self , index : int ): if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None","title":"takeAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider","text":"","title":"labeledslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider","text":"","title":"LabeledSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/labeledslider.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () painter = gui . Painter ( self ) st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PM_SliderSpaceAvailable , st_slider , self . sl ) for v , v_str in self . levels : # get the size of the label rect = painter . drawText ( core . Rect (), QtCore . Qt . TextDontPrint , v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc if self . bottom_margin <= rect . height (): self . bottom_margin = rect . height () self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) painter . drawText ( left , bottom , v_str ) return","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo","text":"","title":"popupinfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo","text":"Dialog overlay to show some info to user.","title":"PopupInfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo.show","text":"show(self) Source code in prettyqt/custom_widgets/popupinfo.py 33 34 35 36 37 38 39 40 41 def show ( self , * args , ** kwargs ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) / 2 y = ( screen_geo . height () - size . height ()) / 2 self . move ( x , y - 200 ) super () . show ( * args , ** kwargs ) self . timer . start ( 2500 )","title":"show()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit","text":"Credits to PyQode Authors.","title":"promptlineedit"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit","text":"Extends QLineEdit to show a prompt text and a clear icon.","title":"PromptLineEdit"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.prompt_text","text":"Gets/Sets the prompt text.","title":"prompt_text"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/promptlineedit.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def paintEvent ( self , event ): super () . paintEvent ( event ) if self . _prompt_text and not self . text () and self . isEnabled (): option = widgets . StyleOptionFrame () self . initStyleOption ( option ) left , top , right , bottom = self . getTextMargins () va = self . style () . visualAlignment ( self . layoutDirection (), self . alignment ()) rect = ( self . style () . subElementRect ( widgets . Style . SE_LineEditContents , option , self ) . adjusted ( 2 , 0 , 0 , 0 ) . adjusted ( left , top , - right , - bottom ) ) fm = gui . FontMetrics ( self . font ()) text = fm . elided_text ( self . _prompt_text , mode = \"right\" , width = rect . width ()) painter = gui . Painter ( self ) painter . setPen ( self . palette () . color ( gui . Palette . Disabled , gui . Palette . Text )) painter . drawText ( rect , va , text )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.resizeEvent","text":"resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/promptlineedit.py 70 71 72 73 74 def resizeEvent ( self , event ): # Adjusts Clear button position super () . resizeEvent ( event ) self . button . resize ( core . Size ( self . _margin , self . height () - 2 )) self . button . move ( self . width () - self . _margin - 3 , 1 )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.set_button_visible","text":"Sets the clear button as visible . Parameters: Name Type Description Default visible bool Visibility of button required Source code in prettyqt/custom_widgets/promptlineedit.py 76 77 78 79 80 81 82 83 84 85 86 87 88 def set_button_visible ( self , visible : bool ): \"\"\"Sets the clear button as ``visible``. Args: visible (bool): Visibility of button \"\"\" self . button . setVisible ( visible ) left , top , right , bottom = self . getTextMargins () if visible : right = self . _margin + self . _spacing else : right = 0 self . setTextMargins ( left , top , right , bottom )","title":"set_button_visible()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor","text":"Module containing classes related to the RegEx editor.","title":"regexeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.editor","text":"This module contains the editor widget implementation.","title":"editor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.quick_ref","text":"Contains the quick reference widget.","title":"quick_ref"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider","text":"","title":"spanslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider","text":"","title":"SpanSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseMoveEvent","text":"mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PM_MaximumDragDistance , opt , self ) new_pos = self . pixel_pos_to_value ( self . pick ( event . pos ()) - self . offset ) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . pos ()): new_pos = self . position # pick the preferred handle on the first movement if self . first_movement : if self . lower == self . upper : if new_pos < self . lower_value : self . swap_controls () self . first_movement = False else : self . first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper - 1 ) if self . movement == \"free\" and new_pos > self . upper : self . swap_controls () self . set_upper_pos ( new_pos ) else : self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower : self . swap_controls () self . set_lower_pos ( new_pos ) else : self . set_upper_pos ( new_pos ) event . accept ()","title":"mouseMoveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mousePressEvent","text":"mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . handle_mouse_press ( event . pos (), self . upper_pressed , self . upper , self . UPPER_HANDLE ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . handle_mouse_press ( event . pos (), self . lower_pressed , self . lower , self . LOWER_HANDLE ) self . first_movement = True event . accept ()","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseReleaseEvent","text":"mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 433 434 435 436 437 def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SC_None self . update ()","title":"mouseReleaseEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/spanslider.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SC_SliderTickmarks painter . drawComplexControl ( SLIDER_STYLE , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . drawComplexControl ( SLIDER_STYLE , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () spanRect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) if self . is_horizontal (): spanRect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) self . draw_span ( painter , spanRect ) # handles if self . last_pressed == self . LOWER_HANDLE : self . draw_handle ( painter , self . UPPER_HANDLE ) self . draw_handle ( painter , self . LOWER_HANDLE ) else : self . draw_handle ( painter , self . LOWER_HANDLE ) self . draw_handle ( painter , self . UPPER_HANDLE )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner","text":"The MIT License (MIT). Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"waitingspinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner","text":"","title":"BaseWaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( \"none\" ) for i in range ( 0 , self . _line_num ): painter . save () painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length , ) rotate_angle = float ( 360 * i ) / float ( self . _line_num ) painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) rect = core . Rect ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . RelativeSize ) painter . restore ()","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner","text":"","title":"WaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py 238 239 240 def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event )","title":"paintEvent()"},{"location":"api/gui.html","text":"gui module Gui module. Contains QtGui-based classes color Color __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/color.py 13 14 def __reduce__ ( self ): return ( self . __class__ , ( self . red (), self . green (), self . blue (), self . alpha ())) from_text ( text ) classmethod Create a QColor from specified string. Source code in prettyqt/gui/color.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @classmethod def from_text ( cls , text ): \"\"\"Create a QColor from specified string.\"\"\" color = cls () text = str ( text ) if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color cursor Cursor get_shape ( self ) Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: Type Description str cursor shape Source code in prettyqt/gui/cursor.py 38 39 40 41 42 43 44 45 46 def get_shape ( self ) -> str : \"\"\"Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: cursor shape \"\"\" return SHAPES . inv [ self . shape ()] set_shape ( self , shape ) Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Parameters: Name Type Description Default shape str shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/gui/cursor.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def set_shape ( self , shape : str ): \"\"\"Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in SHAPES : raise InvalidParamError ( shape , SHAPES ) self . setShape ( SHAPES [ shape ]) font Font set_style_hint ( self , hint ) Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str style hint required Exceptions: Type Description InvalidParamError invalid style hint Source code in prettyqt/gui/font.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def set_style_hint ( self , hint : str ): \"\"\"Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ]) set_weight ( self , weight ) Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/font.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def set_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) self . setWeight ( WEIGHTS [ weight ]) gradient Gradient get_coordinate_mode ( self ) Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: Type Description str coordinate mode Source code in prettyqt/gui/gradient.py 49 50 51 52 53 54 55 56 57 def get_coordinate_mode ( self ) -> str : \"\"\"Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: coordinate mode \"\"\" return COORDINATE_MODES . inv [ self . coordinateMode ()] get_spread ( self ) Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: Type Description str spread method Source code in prettyqt/gui/gradient.py 74 75 76 77 78 79 80 81 82 def get_spread ( self ) -> str : \"\"\"Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: spread method \"\"\" return SPREADS . inv [ self . spread ()] get_type ( self ) Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: Type Description str gradient type Source code in prettyqt/gui/gradient.py 84 85 86 87 88 89 90 91 92 def get_type ( self ) -> str : \"\"\"Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: gradient type \"\"\" return TYPES . inv [ self . type ()] set_coordinate_mode ( self , mode ) Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Parameters: Name Type Description Default mode str coordinate mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/gradient.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def set_coordinate_mode ( self , mode : str ): \"\"\"Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODES : raise InvalidParamError ( mode , COORDINATE_MODES ) self . setCoordinateMode ( COORDINATE_MODES [ mode ]) set_spread ( self , method ) Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Parameters: Name Type Description Default method str spread method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/gui/gradient.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def set_spread ( self , method : str ): \"\"\"Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREADS : raise InvalidParamError ( method , SPREADS ) self . setSpread ( SPREADS [ method ]) icon get_icon ( icon , color = None , as_qicon = False ) Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. Source code in prettyqt/gui/icon.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def get_icon ( icon : IconType , color : Optional [ str ] = None , as_qicon : bool = False ): \"\"\"Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. \"\"\" if isinstance ( icon , QtGui . QIcon ): return icon if as_qicon else Icon ( icon ) if isinstance ( icon , pathlib . Path ): icon = str ( icon ) if ( icon , color , as_qicon ) in icon_cache : return icon_cache [( icon , color , as_qicon )] if isinstance ( icon , str ) and icon . startswith ( \"mdi.\" ): if color is not None : new = qta . icon ( icon , color = color ) else : new = qta . icon ( icon ) else : new = QtGui . QIcon ( icon ) icon = new if as_qicon else Icon ( new ) icon_cache [( icon , color , as_qicon )] = icon return icon keysequence KeySequence __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/keysequence.py 32 33 def __reduce__ ( self ): return ( self . __class__ , ( self . toString ())) painter Painter get_composition_mode ( self ) Get the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: Type Description str composition mode Source code in prettyqt/gui/painter.py 104 105 106 107 108 109 110 111 112 113 114 def get_composition_mode ( self ) -> str : \"\"\"Get the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: composition mode \"\"\" return COMP_MODES . inv [ self . compositionMode ()] get_pen ( self ) Return current pen type. Possible values: \"none\", Returns: Type Description str pen type Source code in prettyqt/gui/painter.py 76 77 78 79 80 81 82 83 84 def get_pen ( self ) -> str : \"\"\"Return current pen type. Possible values: \"none\", Returns: pen type \"\"\" return PEN_TYPES . inv [ self . pen ()] set_composition_mode ( self , mode ) Set the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Exceptions: Type Description InvalidParamError composition mode does not exist Source code in prettyqt/gui/painter.py 90 91 92 93 94 95 96 97 98 99 100 101 102 def set_composition_mode ( self , mode : str ): \"\"\"Set the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMP_MODES : raise InvalidParamError ( mode , COMP_MODES ) self . setCompositionMode ( COMP_MODES [ mode ]) set_pen ( self , pen_type ) Set pen type to use. Allowed values are \"none\", Parameters: Name Type Description Default pen_type str pen type to use required Exceptions: Type Description InvalidParamError pen type does not exist Source code in prettyqt/gui/painter.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def set_pen ( self , pen_type : str ): \"\"\"Set pen type to use. Allowed values are \"none\", Args: pen_type: pen type to use Raises: InvalidParamError: pen type does not exist \"\"\" if pen_type not in PEN_TYPES : raise InvalidParamError ( pen_type , PEN_TYPES ) self . setPen ( PEN_TYPES [ pen_type ]) polygon Polygon __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/polygon.py 9 10 def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () regularexpressionvalidator_pyside RegularExpressionValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/gui/regularexpressionvalidator_pyside.py 36 37 38 39 40 41 42 43 44 45 46 def validate ( self , text : str , pos : int = 0 ) -> tuple : if self . regex is None : raise TypeError () if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , match_type = \"prefer_first\" ) if match . hasPartialMatch (): return ( self . Intermediate , text , pos ) if match . hasMatch (): return ( self . Acceptable , text , pos ) return ( self . Invalid , text , pos ) standarditem StandardItem clone ( self ) clone(self) -> QStandardItem Source code in prettyqt/gui/standarditem.py 28 29 30 31 32 def clone ( self ): item = self . __class__ () core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/gui/standarditem.py 34 35 36 37 38 39 40 41 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) syntaxhighlighter SyntaxHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py 27 28 29 30 31 32 33 def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt ) textblockuserdata TextBlockUserData Storage for the user data associated with each line. textcharformat TextCharFormat get_font_weight ( self ) Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: Type Description str current font weight Source code in prettyqt/gui/textcharformat.py 68 69 70 71 72 73 74 75 76 def get_font_weight ( self ) -> str : \"\"\"Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: current font weight \"\"\" return WEIGHTS . inv [ self . fontWeight ()] get_underline_style ( self ) Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: Type Description str current underline style Source code in prettyqt/gui/textcharformat.py 94 95 96 97 98 99 100 101 102 103 def get_underline_style ( self ) -> str : \"\"\"Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: current underline style \"\"\" return UNDERLINE_STYLES . inv [ self . underlineStyle ()] set_font_style_hint ( self , hint ) Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str font style hint required Exceptions: Type Description InvalidParamError invalid font style hint Source code in prettyqt/gui/textcharformat.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def set_font_style_hint ( self , hint : str ): \"\"\"Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setFontStyleHint ( STYLE_HINTS [ hint ]) set_font_weight ( self , weight ) Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/textcharformat.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def set_font_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) self . setFontWeight ( WEIGHTS [ weight ]) set_underline_style ( self , style ) Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Parameters: Name Type Description Default style str underline style required Exceptions: Type Description InvalidParamError invalid underline style Source code in prettyqt/gui/textcharformat.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def set_underline_style ( self , style : str ): \"\"\"Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLES : raise InvalidParamError ( style , UNDERLINE_STYLES ) self . setUnderlineStyle ( UNDERLINE_STYLES [ style ]) textcursor TextCursor edit_block ( self ) Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py 103 104 105 106 107 108 @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock () select ( self , selection ) select(self, QTextCursor.SelectionType) Source code in prettyqt/gui/textcursor.py 64 65 66 67 def select ( self , selection ): if selection in SELECTION_TYPES : selection = SELECTION_TYPES [ selection ] super () . select ( selection ) select_text ( self , start_pos , end_pos ) Select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos Union[int, str] Start position required end_pos Union[int, str] End position required Source code in prettyqt/gui/textcursor.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def select_text ( self , start_pos : Union [ int , str ], end_pos : Union [ int , str ]) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText () set_position ( self , pos , mode = 'move' ) Set cursor to given position. Parameters: Name Type Description Default pos int Cursor position required mode str Move mode 'move' Source code in prettyqt/gui/textcursor.py 55 56 57 58 59 60 61 62 def set_position ( self , pos : int , mode : str = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODES [ mode ]) validator Validator __radd__ ( self , other ) special Needed for sum(). Source code in prettyqt/gui/validator.py 21 22 23 def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other )","title":"gui"},{"location":"api/gui.html#gui-module","text":"","title":"gui module"},{"location":"api/gui.html#prettyqt.gui","text":"Gui module. Contains QtGui-based classes","title":"prettyqt.gui"},{"location":"api/gui.html#prettyqt.gui.color","text":"","title":"color"},{"location":"api/gui.html#prettyqt.gui.color.Color","text":"","title":"Color"},{"location":"api/gui.html#prettyqt.gui.color.Color.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/color.py 13 14 def __reduce__ ( self ): return ( self . __class__ , ( self . red (), self . green (), self . blue (), self . alpha ()))","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.color.Color.from_text","text":"Create a QColor from specified string. Source code in prettyqt/gui/color.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @classmethod def from_text ( cls , text ): \"\"\"Create a QColor from specified string.\"\"\" color = cls () text = str ( text ) if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color","title":"from_text()"},{"location":"api/gui.html#prettyqt.gui.cursor","text":"","title":"cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor","text":"","title":"Cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.get_shape","text":"Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: Type Description str cursor shape Source code in prettyqt/gui/cursor.py 38 39 40 41 42 43 44 45 46 def get_shape ( self ) -> str : \"\"\"Return current cursor shape. Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: cursor shape \"\"\" return SHAPES . inv [ self . shape ()]","title":"get_shape()"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.set_shape","text":"Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Parameters: Name Type Description Default shape str shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/gui/cursor.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def set_shape ( self , shape : str ): \"\"\"Set cursor shape. Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in SHAPES : raise InvalidParamError ( shape , SHAPES ) self . setShape ( SHAPES [ shape ])","title":"set_shape()"},{"location":"api/gui.html#prettyqt.gui.font","text":"","title":"font"},{"location":"api/gui.html#prettyqt.gui.font.Font","text":"","title":"Font"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style_hint","text":"Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str style hint required Exceptions: Type Description InvalidParamError invalid style hint Source code in prettyqt/gui/font.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def set_style_hint ( self , hint : str ): \"\"\"Set the style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ])","title":"set_style_hint()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_weight","text":"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/font.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def set_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) self . setWeight ( WEIGHTS [ weight ])","title":"set_weight()"},{"location":"api/gui.html#prettyqt.gui.gradient","text":"","title":"gradient"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient","text":"","title":"Gradient"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_coordinate_mode","text":"Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: Type Description str coordinate mode Source code in prettyqt/gui/gradient.py 49 50 51 52 53 54 55 56 57 def get_coordinate_mode ( self ) -> str : \"\"\"Return current coordinate mode. Possible values: \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Returns: coordinate mode \"\"\" return COORDINATE_MODES . inv [ self . coordinateMode ()]","title":"get_coordinate_mode()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_spread","text":"Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: Type Description str spread method Source code in prettyqt/gui/gradient.py 74 75 76 77 78 79 80 81 82 def get_spread ( self ) -> str : \"\"\"Return current spread method. Possible values: \"pad\", \"repeat\", \"reflect\" Returns: spread method \"\"\" return SPREADS . inv [ self . spread ()]","title":"get_spread()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_type","text":"Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: Type Description str gradient type Source code in prettyqt/gui/gradient.py 84 85 86 87 88 89 90 91 92 def get_type ( self ) -> str : \"\"\"Return current gradient type. Possible values: \"linear\", \"radial\", \"conical\", \"none\" Returns: gradient type \"\"\" return TYPES . inv [ self . type ()]","title":"get_type()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.set_coordinate_mode","text":"Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Parameters: Name Type Description Default mode str coordinate mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/gradient.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def set_coordinate_mode ( self , mode : str ): \"\"\"Set the coordinate mode. Allowed values are \"logical\", \"object\", \"stretch_to_device\", \"object_bounding\" Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODES : raise InvalidParamError ( mode , COORDINATE_MODES ) self . setCoordinateMode ( COORDINATE_MODES [ mode ])","title":"set_coordinate_mode()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.set_spread","text":"Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Parameters: Name Type Description Default method str spread method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/gui/gradient.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def set_spread ( self , method : str ): \"\"\"Set the spread method. Allowed values are \"pad\", \"repeat\", \"reflect\" Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREADS : raise InvalidParamError ( method , SPREADS ) self . setSpread ( SPREADS [ method ])","title":"set_spread()"},{"location":"api/gui.html#prettyqt.gui.icon","text":"","title":"icon"},{"location":"api/gui.html#prettyqt.gui.icon.get_icon","text":"Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. Source code in prettyqt/gui/icon.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def get_icon ( icon : IconType , color : Optional [ str ] = None , as_qicon : bool = False ): \"\"\"Get icon with given color. Qtawesome already caches icons, but since we construct our own subclassed icon, we cache, too. \"\"\" if isinstance ( icon , QtGui . QIcon ): return icon if as_qicon else Icon ( icon ) if isinstance ( icon , pathlib . Path ): icon = str ( icon ) if ( icon , color , as_qicon ) in icon_cache : return icon_cache [( icon , color , as_qicon )] if isinstance ( icon , str ) and icon . startswith ( \"mdi.\" ): if color is not None : new = qta . icon ( icon , color = color ) else : new = qta . icon ( icon ) else : new = QtGui . QIcon ( icon ) icon = new if as_qicon else Icon ( new ) icon_cache [( icon , color , as_qicon )] = icon return icon","title":"get_icon()"},{"location":"api/gui.html#prettyqt.gui.keysequence","text":"","title":"keysequence"},{"location":"api/gui.html#prettyqt.gui.keysequence.KeySequence","text":"","title":"KeySequence"},{"location":"api/gui.html#prettyqt.gui.keysequence.KeySequence.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/keysequence.py 32 33 def __reduce__ ( self ): return ( self . __class__ , ( self . toString ()))","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.painter","text":"","title":"painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter","text":"","title":"Painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_composition_mode","text":"Get the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: Type Description str composition mode Source code in prettyqt/gui/painter.py 104 105 106 107 108 109 110 111 112 113 114 def get_composition_mode ( self ) -> str : \"\"\"Get the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: composition mode \"\"\" return COMP_MODES . inv [ self . compositionMode ()]","title":"get_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_pen","text":"Return current pen type. Possible values: \"none\", Returns: Type Description str pen type Source code in prettyqt/gui/painter.py 76 77 78 79 80 81 82 83 84 def get_pen ( self ) -> str : \"\"\"Return current pen type. Possible values: \"none\", Returns: pen type \"\"\" return PEN_TYPES . inv [ self . pen ()]","title":"get_pen()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_composition_mode","text":"Set the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Exceptions: Type Description InvalidParamError composition mode does not exist Source code in prettyqt/gui/painter.py 90 91 92 93 94 95 96 97 98 99 100 101 102 def set_composition_mode ( self , mode : str ): \"\"\"Set the current composition mode. Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMP_MODES : raise InvalidParamError ( mode , COMP_MODES ) self . setCompositionMode ( COMP_MODES [ mode ])","title":"set_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_pen","text":"Set pen type to use. Allowed values are \"none\", Parameters: Name Type Description Default pen_type str pen type to use required Exceptions: Type Description InvalidParamError pen type does not exist Source code in prettyqt/gui/painter.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def set_pen ( self , pen_type : str ): \"\"\"Set pen type to use. Allowed values are \"none\", Args: pen_type: pen type to use Raises: InvalidParamError: pen type does not exist \"\"\" if pen_type not in PEN_TYPES : raise InvalidParamError ( pen_type , PEN_TYPES ) self . setPen ( PEN_TYPES [ pen_type ])","title":"set_pen()"},{"location":"api/gui.html#prettyqt.gui.polygon","text":"","title":"polygon"},{"location":"api/gui.html#prettyqt.gui.polygon.Polygon","text":"","title":"Polygon"},{"location":"api/gui.html#prettyqt.gui.polygon.Polygon.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/polygon.py 9 10 def __reduce__ ( self ): return type ( self ), (), self . __getstate__ ()","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.regularexpressionvalidator_pyside","text":"","title":"regularexpressionvalidator_pyside"},{"location":"api/gui.html#prettyqt.gui.regularexpressionvalidator_pyside.RegularExpressionValidator","text":"","title":"RegularExpressionValidator"},{"location":"api/gui.html#prettyqt.gui.regularexpressionvalidator_pyside.RegularExpressionValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/gui/regularexpressionvalidator_pyside.py 36 37 38 39 40 41 42 43 44 45 46 def validate ( self , text : str , pos : int = 0 ) -> tuple : if self . regex is None : raise TypeError () if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , match_type = \"prefer_first\" ) if match . hasPartialMatch (): return ( self . Intermediate , text , pos ) if match . hasMatch (): return ( self . Acceptable , text , pos ) return ( self . Invalid , text , pos )","title":"validate()"},{"location":"api/gui.html#prettyqt.gui.standarditem","text":"","title":"standarditem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem","text":"","title":"StandardItem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.clone","text":"clone(self) -> QStandardItem Source code in prettyqt/gui/standarditem.py 28 29 30 31 32 def clone ( self ): item = self . __class__ () core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item","title":"clone()"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/gui/standarditem.py 34 35 36 37 38 39 40 41 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter","text":"","title":"syntaxhighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter","text":"","title":"SyntaxHighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py 27 28 29 30 31 32 33 def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt )","title":"highlightBlock()"},{"location":"api/gui.html#prettyqt.gui.textblockuserdata","text":"","title":"textblockuserdata"},{"location":"api/gui.html#prettyqt.gui.textblockuserdata.TextBlockUserData","text":"Storage for the user data associated with each line.","title":"TextBlockUserData"},{"location":"api/gui.html#prettyqt.gui.textcharformat","text":"","title":"textcharformat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat","text":"","title":"TextCharFormat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_font_weight","text":"Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: Type Description str current font weight Source code in prettyqt/gui/textcharformat.py 68 69 70 71 72 73 74 75 76 def get_font_weight ( self ) -> str : \"\"\"Get current font weight. Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: current font weight \"\"\" return WEIGHTS . inv [ self . fontWeight ()]","title":"get_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_underline_style","text":"Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: Type Description str current underline style Source code in prettyqt/gui/textcharformat.py 94 95 96 97 98 99 100 101 102 103 def get_underline_style ( self ) -> str : \"\"\"Get current underline style. Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: current underline style \"\"\" return UNDERLINE_STYLES . inv [ self . underlineStyle ()]","title":"get_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_style_hint","text":"Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str font style hint required Exceptions: Type Description InvalidParamError invalid font style hint Source code in prettyqt/gui/textcharformat.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def set_font_style_hint ( self , hint : str ): \"\"\"Set the font style hint. Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setFontStyleHint ( STYLE_HINTS [ hint ])","title":"set_font_style_hint()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_weight","text":"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/textcharformat.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def set_font_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) self . setFontWeight ( WEIGHTS [ weight ])","title":"set_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_underline_style","text":"Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Parameters: Name Type Description Default style str underline style required Exceptions: Type Description InvalidParamError invalid underline style Source code in prettyqt/gui/textcharformat.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def set_underline_style ( self , style : str ): \"\"\"Set the underline style. Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLES : raise InvalidParamError ( style , UNDERLINE_STYLES ) self . setUnderlineStyle ( UNDERLINE_STYLES [ style ])","title":"set_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcursor","text":"","title":"textcursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor","text":"","title":"TextCursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.edit_block","text":"Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py 103 104 105 106 107 108 @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock ()","title":"edit_block()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select","text":"select(self, QTextCursor.SelectionType) Source code in prettyqt/gui/textcursor.py 64 65 66 67 def select ( self , selection ): if selection in SELECTION_TYPES : selection = SELECTION_TYPES [ selection ] super () . select ( selection )","title":"select()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select_text","text":"Select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos Union[int, str] Start position required end_pos Union[int, str] End position required Source code in prettyqt/gui/textcursor.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def select_text ( self , start_pos : Union [ int , str ], end_pos : Union [ int , str ]) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText ()","title":"select_text()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.set_position","text":"Set cursor to given position. Parameters: Name Type Description Default pos int Cursor position required mode str Move mode 'move' Source code in prettyqt/gui/textcursor.py 55 56 57 58 59 60 61 62 def set_position ( self , pos : int , mode : str = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODES [ mode ])","title":"set_position()"},{"location":"api/gui.html#prettyqt.gui.validator","text":"","title":"validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator","text":"","title":"Validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator.__radd__","text":"Needed for sum(). Source code in prettyqt/gui/validator.py 21 22 23 def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other )","title":"__radd__()"},{"location":"api/multimedia.html","text":"multimedia module Multimedia module. audioencodersettings Settings dataclass Settings(bitrate: int, channel_count: int, codec: str, encoding_mode: str, encoding_options: Dict[str, Any], quality: str, sample_rate: int) mediaplayer MediaPlayer get_media_status ( self ) Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: Type Description str media status Source code in prettyqt/multimedia/mediaplayer.py 50 51 52 53 54 55 56 57 58 59 def get_media_status ( self ) -> str : \"\"\"Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: media status \"\"\" return MEDIA_STATUS . inv [ self . mediaStatus ()] get_state ( self ) Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: Type Description str state Source code in prettyqt/multimedia/mediaplayer.py 40 41 42 43 44 45 46 47 48 def get_state ( self ) -> str : \"\"\"Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: state \"\"\" return STATES . inv [ self . state ()] mediaplaylist MediaPlaylist get_playback_mode ( self ) Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: Type Description str playback mode Source code in prettyqt/multimedia/mediaplaylist.py 68 69 70 71 72 73 74 75 76 def get_playback_mode ( self ) -> str : \"\"\"Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: playback mode \"\"\" return PLAYBACK_MODES . inv [ self . playbackMode ()] set_playback_mode ( self , mode ) Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Parameters: Name Type Description Default mode str playback mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/multimedia/mediaplaylist.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def set_playback_mode ( self , mode : str ): \"\"\"Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Args: mode: playback mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in PLAYBACK_MODES : raise InvalidParamError ( mode , PLAYBACK_MODES ) self . setPlaybackMode ( PLAYBACK_MODES [ mode ]) videoencodersettings Settings dataclass Settings(bitrate: int, codec: str, encoding_mode: str, encoding_options: Dict[str, Any], quality: str, frame_rate: float, resolution: Tuple[int, int])","title":"multimedia"},{"location":"api/multimedia.html#multimedia-module","text":"","title":"multimedia module"},{"location":"api/multimedia.html#prettyqt.multimedia","text":"Multimedia module.","title":"prettyqt.multimedia"},{"location":"api/multimedia.html#prettyqt.multimedia.audioencodersettings","text":"","title":"audioencodersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.audioencodersettings.Settings","text":"Settings(bitrate: int, channel_count: int, codec: str, encoding_mode: str, encoding_options: Dict[str, Any], quality: str, sample_rate: int)","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer","text":"","title":"mediaplayer"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer","text":"","title":"MediaPlayer"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_media_status","text":"Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: Type Description str media status Source code in prettyqt/multimedia/mediaplayer.py 50 51 52 53 54 55 56 57 58 59 def get_media_status ( self ) -> str : \"\"\"Return current media status. Possible values: \"unknown\", \"no_media\", \"loading\", \"loaded\", \"stalled\", \"buffering\", \"buffered\", \"end\", \"invalid\" Returns: media status \"\"\" return MEDIA_STATUS . inv [ self . mediaStatus ()]","title":"get_media_status()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_state","text":"Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: Type Description str state Source code in prettyqt/multimedia/mediaplayer.py 40 41 42 43 44 45 46 47 48 def get_state ( self ) -> str : \"\"\"Return current state. Possible values: \"stopped\", \"playing\", \"paused\" Returns: state \"\"\" return STATES . inv [ self . state ()]","title":"get_state()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist","text":"","title":"mediaplaylist"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist","text":"","title":"MediaPlaylist"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist.get_playback_mode","text":"Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: Type Description str playback mode Source code in prettyqt/multimedia/mediaplaylist.py 68 69 70 71 72 73 74 75 76 def get_playback_mode ( self ) -> str : \"\"\"Return current playback mode. Possible values: \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Returns: playback mode \"\"\" return PLAYBACK_MODES . inv [ self . playbackMode ()]","title":"get_playback_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist.set_playback_mode","text":"Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Parameters: Name Type Description Default mode str playback mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/multimedia/mediaplaylist.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def set_playback_mode ( self , mode : str ): \"\"\"Set playback mode for given item view. Allowed values are \"item_once\", \"item_in_loop\", \"sequential\", \"loop\", \"random\" Args: mode: playback mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in PLAYBACK_MODES : raise InvalidParamError ( mode , PLAYBACK_MODES ) self . setPlaybackMode ( PLAYBACK_MODES [ mode ])","title":"set_playback_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.videoencodersettings","text":"","title":"videoencodersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.videoencodersettings.Settings","text":"Settings(bitrate: int, codec: str, encoding_mode: str, encoding_options: Dict[str, Any], quality: str, frame_rate: float, resolution: Tuple[int, int])","title":"Settings"},{"location":"api/multimediawidgets.html","text":"multimediawidgets module Multimediawidgets module.","title":"multimediawidgets"},{"location":"api/multimediawidgets.html#multimediawidgets-module","text":"","title":"multimediawidgets module"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets","text":"Multimediawidgets module.","title":"prettyqt.multimediawidgets"},{"location":"api/syntaxhighlighters.html","text":"syntaxhighlighters module syntaxhighlighters module. contains some custom syntax highlighers highlightrule HighlightRule dataclass HighlightRule(regex: Union[str, List[str]] = '', color: str = 'black', italic: bool = False, bold: bool = False, minimal: bool = False, font_size: Union[float, NoneType] = None, nth: int = 0) __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py 25 26 27 28 29 30 31 32 def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format () jsonhighlighter JsonHighlighter highlightBlock ( self , text ) Highlight a block of code using the rules outlined in the Constructor. Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py 24 25 26 27 28 29 30 31 32 33 def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT ) markdownhighlighter Syntax highlighter for Markdown markup language. MarkdownHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py 90 91 92 93 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE ) pygmentshighlighter PygmentsHighlighter Syntax highlighter that uses Pygments for parsing. highlightBlock ( self , string ) Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack set_style ( self , style ) Sets the style to the specified Pygments style. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 139 140 141 142 143 144 def set_style ( self , style ): \"\"\"Sets the style to the specified Pygments style.\"\"\" if isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches () set_style_sheet ( self , stylesheet ) Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 146 147 148 149 150 151 152 153 154 155 156 157 158 def set_style_sheet ( self , stylesheet ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches () get_tokens_unprocessed ( self , text , stack = ( 'root' ,)) Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def get_tokens_unprocessed ( self , text , stack = ( \"root\" ,)): \"\"\"Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while 1 : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if type ( action ) is _TokenType : yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , \"wrong state def: %r \" % new_state statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" pos += 1 statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos , Text , \" \\n \" continue yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack ) qstring_length ( text ) Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 16 17 18 19 20 21 22 23 24 def qstring_length ( text ): \"\"\"Tries to compute what the length of an utf16-encoded QString would be.\"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length pythonhighlighter Syntax highlighter for the programming language Python. PythonHighlighter Syntax highlighter for the Python language. highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py 143 144 145 146 147 148 149 150 def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE ) match_multiline ( self , text , delimiter , in_state , style ) Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def match_multiline ( self , text , delimiter , in_state , style ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : start = delimiter . indexIn ( text ) # Move past this match add = delimiter . matchedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter end = delimiter . indexIn ( text , start + add ) # Ending delimiter on this line? if end >= add : length = end - start + add + delimiter . matchedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . indexIn ( text , start + length ) # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state regexmatchhighlighter RegexMatchHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i ) xmlhighlighter Based on http://www.yasinuludag.com/blog/?p=49 . XmlHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . indexIn ( text ) while start_index >= 0 : end_index = VALUE_END_EXPRESSION . indexIn ( text , start_index ) if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : matched_len = VALUE_END_EXPRESSION . matchedLength () comment_len = end_index - start_index + matched_len self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . indexIn ( text , start_index + comment_len ) yamlhighlighter YamlHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py 82 83 84 85 86 87 88 89 90 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . indexIn ( text ) if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"syntaxhighlighters"},{"location":"api/syntaxhighlighters.html#syntaxhighlighters-module","text":"","title":"syntaxhighlighters module"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters","text":"syntaxhighlighters module. contains some custom syntax highlighers","title":"prettyqt.syntaxhighlighters"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule","text":"","title":"highlightrule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule","text":"HighlightRule(regex: Union[str, List[str]] = '', color: str = 'black', italic: bool = False, bold: bool = False, minimal: bool = False, font_size: Union[float, NoneType] = None, nth: int = 0)","title":"HighlightRule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py 25 26 27 28 29 30 31 32 def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format ()","title":"__init_subclass__()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter","text":"","title":"jsonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter","text":"","title":"JsonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter.highlightBlock","text":"Highlight a block of code using the rules outlined in the Constructor. Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py 24 25 26 27 28 29 30 31 32 33 def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter","text":"Syntax highlighter for Markdown markup language.","title":"markdownhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter","text":"","title":"MarkdownHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py 90 91 92 93 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter","text":"","title":"pygmentshighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter","text":"Syntax highlighter that uses Pygments for parsing.","title":"PygmentsHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.highlightBlock","text":"Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style","text":"Sets the style to the specified Pygments style. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 139 140 141 142 143 144 def set_style ( self , style ): \"\"\"Sets the style to the specified Pygments style.\"\"\" if isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches ()","title":"set_style()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style_sheet","text":"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 146 147 148 149 150 151 152 153 154 155 156 157 158 def set_style_sheet ( self , stylesheet ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches ()","title":"set_style_sheet()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.get_tokens_unprocessed","text":"Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def get_tokens_unprocessed ( self , text , stack = ( \"root\" ,)): \"\"\"Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while 1 : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if type ( action ) is _TokenType : yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , \"wrong state def: %r \" % new_state statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" pos += 1 statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos , Text , \" \\n \" continue yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack )","title":"get_tokens_unprocessed()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.qstring_length","text":"Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 16 17 18 19 20 21 22 23 24 def qstring_length ( text ): \"\"\"Tries to compute what the length of an utf16-encoded QString would be.\"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length","title":"qstring_length()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter","text":"Syntax highlighter for the programming language Python.","title":"pythonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter","text":"Syntax highlighter for the Python language.","title":"PythonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py 143 144 145 146 147 148 149 150 def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.match_multiline","text":"Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def match_multiline ( self , text , delimiter , in_state , style ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : start = delimiter . indexIn ( text ) # Move past this match add = delimiter . matchedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter end = delimiter . indexIn ( text , start + add ) # Ending delimiter on this line? if end >= add : length = end - start + add + delimiter . matchedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . indexIn ( text , start + length ) # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state","title":"match_multiline()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter","text":"","title":"regexmatchhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter","text":"","title":"RegexMatchHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter","text":"Based on http://www.yasinuludag.com/blog/?p=49 .","title":"xmlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter","text":"","title":"XmlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . indexIn ( text ) while start_index >= 0 : end_index = VALUE_END_EXPRESSION . indexIn ( text , start_index ) if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : matched_len = VALUE_END_EXPRESSION . matchedLength () comment_len = end_index - start_index + matched_len self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . indexIn ( text , start_index + comment_len )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter","text":"","title":"yamlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter","text":"","title":"YamlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py 82 83 84 85 86 87 88 89 90 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . indexIn ( text ) if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"highlightBlock()"},{"location":"api/webenginewidgets.html","text":"webenginewidgets module Webenginewidgets module. contains QWebEngineView-based classes webenginepage WebEnginePage A web engine page holds the HTML document contents, link history + actions. find_text ( self , string , backward = False , case_sensitive = False , callback = None ) Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webenginepage.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = self . FindFlag () if case_sensitive : flag |= self . FindCaseSensitively if backward : flag |= self . FindBackward self . findText ( string , flag , callback ) load_url ( self , url ) Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webenginepage.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) set_url ( self , url ) Set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webenginepage.py 17 18 19 20 21 22 23 24 25 26 27 28 29 def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom ) Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webenginepage.py 48 49 50 51 52 53 54 55 56 def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom ) webengineview WebEngineView find_text ( self , string , backward = False , case_sensitive = False , callback = None ) Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webengineview.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlag () if case_sensitive : flag |= QtWebEngineWidgets . QWebEnginePage . FindCaseSensitively if backward : flag |= QtWebEngineWidgets . QWebEnginePage . FindBackward self . findText ( string , flag , callback ) load_url ( self , url ) Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webengineview.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) set_url ( self , url ) Set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webengineview.py 15 16 17 18 19 20 21 22 23 24 25 26 27 def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom ) Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py 46 47 48 49 50 51 52 53 54 def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"webenginewidgets"},{"location":"api/webenginewidgets.html#webenginewidgets-module","text":"","title":"webenginewidgets module"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets","text":"Webenginewidgets module. contains QWebEngineView-based classes","title":"prettyqt.webenginewidgets"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage","text":"","title":"webenginepage"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage","text":"A web engine page holds the HTML document contents, link history + actions.","title":"WebEnginePage"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.find_text","text":"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webenginepage.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = self . FindFlag () if case_sensitive : flag |= self . FindCaseSensitively if backward : flag |= self . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.load_url","text":"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webenginepage.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_url","text":"Set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webenginepage.py 17 18 19 20 21 22 23 24 25 26 27 28 29 def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_zoom","text":"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webenginepage.py 48 49 50 51 52 53 54 55 56 def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview","text":"","title":"webengineview"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView","text":"","title":"WebEngineView"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.find_text","text":"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webengineview.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlag () if case_sensitive : flag |= QtWebEngineWidgets . QWebEnginePage . FindCaseSensitively if backward : flag |= QtWebEngineWidgets . QWebEnginePage . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.load_url","text":"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webengineview.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_url","text":"Set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webengineview.py 15 16 17 18 19 20 21 22 23 24 25 26 27 def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_zoom","text":"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py 46 47 48 49 50 51 52 53 54 def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/widgets.html","text":"widgets module widgets module. contains QtWidgets-based classes abstractbutton AbstractButton set_icon ( self , icon ) Set the icon for the button. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/abstractbutton.py 33 34 35 36 37 38 39 40 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) abstractitemview AbstractItemView get_selection_behaviour ( self ) Return current selection behaviour. Possible values: \"rows\", \"columns\", \"items\" Returns: Type Description str selection behaviour Source code in prettyqt/widgets/abstractitemview.py 181 182 183 184 185 186 187 188 189 def get_selection_behaviour ( self ) -> str : \"\"\"Return current selection behaviour. Possible values: \"rows\", \"columns\", \"items\" Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOURS . inv [ self . selectionBehavior ()] get_selection_mode ( self ) Return current selection mode. Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/abstractitemview.py 208 209 210 211 212 213 214 215 216 def get_selection_mode ( self ) -> str : \"\"\"Return current selection mode. Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()] highlight_when_inactive ( self ) Highlight items when widget does not have focus. Source code in prettyqt/widgets/abstractitemview.py 304 305 306 307 308 def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p ) jump_to_column ( self , col_num ) Make sure column at given index is visible. scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py 274 275 276 277 278 279 280 281 282 283 284 285 def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return None idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx ) num_selected ( self ) Return amount of selected rows. Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py 264 265 266 267 268 269 270 271 272 def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ()) scroll_to_bottom ( self ) Override to use abstractitemview-way of scrolling to bottom. Source code in prettyqt/widgets/abstractitemview.py 291 292 293 def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom () scroll_to_top ( self ) Override to use abstractitemview-way of scrolling to top. Source code in prettyqt/widgets/abstractitemview.py 287 288 289 def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop () selectAll ( self ) Override, we dont want to selectAll for too many items bc of performance. Source code in prettyqt/widgets/abstractitemview.py 53 54 55 56 57 58 59 60 def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return None if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return None super () . selectAll () selected_data ( self ) Returns generator yielding selected userData. Source code in prettyqt/widgets/abstractitemview.py 144 145 146 def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes ()) selected_indexes ( self ) Returns list of selected indexes in first row. Source code in prettyqt/widgets/abstractitemview.py 131 132 133 134 def selected_indexes ( self ) -> List [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) return sorted ( indexes , key = lambda x : x . row ()) selected_names ( self ) Returns generator yielding item names. Source code in prettyqt/widgets/abstractitemview.py 136 137 138 def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ()) selected_rows ( self ) Returns generator yielding row nums. Source code in prettyqt/widgets/abstractitemview.py 140 141 142 def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ()) set_horizontal_scroll_mode ( self , mode ) Set the horizontal scroll mode. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def set_horizontal_scroll_mode ( self , mode : str ): \"\"\"Set the horizontal scroll mode. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ]) set_model ( self , model ) Delete old selection model explicitely, seems to help with memory usage. Source code in prettyqt/widgets/abstractitemview.py 62 63 64 65 66 67 68 69 70 71 72 73 def set_model ( self , model : Optional [ QtCore . QAbstractItemModel ]): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model set_scroll_mode ( self , mode ) Set the scroll mode for both directions. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def set_scroll_mode ( self , mode : str ): \"\"\"Set the scroll mode for both directions. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ]) self . setVerticalScrollMode ( SCROLL_MODES [ mode ]) set_selection_behaviour ( self , behaviour ) Set selection behaviour for given item view. Allowed values are \"rows\", \"columns\", \"items\" Parameters: Name Type Description Default behaviour str selection behaviour to use required Exceptions: Type Description InvalidParamError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def set_selection_behaviour ( self , behaviour : str ): \"\"\"Set selection behaviour for given item view. Allowed values are \"rows\", \"columns\", \"items\" Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOURS : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOURS ) self . setSelectionBehavior ( SELECTION_BEHAVIOURS [ behaviour ]) set_selection_mode ( self , mode ) Set selection mode for given item view. Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"Set selection mode for given item view. Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise InvalidParamError ( mode , SELECTION_MODES ) self . setSelectionMode ( SELECTION_MODES [ mode ]) set_vertical_scroll_mode ( self , mode ) Set the vertical scroll mode. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def set_vertical_scroll_mode ( self , mode : str ): \"\"\"Set the vertical scroll mode. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setVerticalScrollMode ( SCROLL_MODES [ mode ]) toggle_select_all ( self ) Select all items from list (deselect when all selected). Source code in prettyqt/widgets/abstractitemview.py 97 98 99 100 101 102 103 104 def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return None if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll () abstractscrollarea AbstractScrollArea get_size_adjust_policy ( self ) Return size adjust policy. possible values are \"content\", \"first_show\", \"ignored\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py 68 69 70 71 72 73 74 75 76 def get_size_adjust_policy ( self ) -> str : \"\"\"Return size adjust policy. possible values are \"content\", \"first_show\", \"ignored\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()] scroll_to_bottom ( self ) Scroll to the bottom of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py 155 156 157 def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max () scroll_to_top ( self ) Scroll to the top of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py 151 152 153 def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min () set_horizontal_scrollbar_policy ( self , mode ) Set the horizontal scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def set_horizontal_scrollbar_policy ( self , mode : str ): \"\"\"Set the horizontal scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_horizontal_scrollbar_width ( self , width ) Set the horizontal scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 133 134 135 136 137 138 139 140 def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) set_scrollbar_policy ( self , mode ) Set the policy for both scrollbars. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def set_scrollbar_policy ( self , mode : str ): \"\"\"Set the policy for both scrollbars. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_scrollbar_width ( self , width ) Set the width for both scrollbars. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 124 125 126 127 128 129 130 131 def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width ) set_size_adjust_policy ( self , policy ) Set size adjust policy. Valid values are \"content\", \"first_show\", \"ignored\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def set_size_adjust_policy ( self , policy : str ): \"\"\"Set size adjust policy. Valid values are \"content\", \"first_show\", \"ignored\" Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise InvalidParamError ( policy , SIZE_POLICIES ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy ) set_vertical_scrollbar_policy ( self , mode ) Set the vertical scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def set_vertical_scrollbar_policy ( self , mode : str ): \"\"\"Set the vertical scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_vertical_scrollbar_width ( self , width ) Set the vertical scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 142 143 144 145 146 147 148 149 def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) abstractslider AbstractSlider is_horizontal ( self ) Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py 39 40 41 42 43 44 45 def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == QtCore . Qt . Horizontal is_vertical ( self ) Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py 47 48 49 50 51 52 53 def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == QtCore . Qt . Vertical scroll_to_max ( self ) Scroll to the maximum value of the slider. Source code in prettyqt/widgets/abstractslider.py 67 68 69 def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ()) scroll_to_min ( self ) Scroll to the minimum value of the slider. Source code in prettyqt/widgets/abstractslider.py 63 64 65 def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ()) set_horizontal ( self ) Set slider orientation to horizontal. Source code in prettyqt/widgets/abstractslider.py 55 56 57 def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( QtCore . Qt . Horizontal ) set_vertical ( self ) Set slider orientation to vertical. Source code in prettyqt/widgets/abstractslider.py 59 60 61 def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( QtCore . Qt . Vertical ) abstractspinbox AbstractSpinBox get_button_symbols ( self ) Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: Type Description str button symbol type Source code in prettyqt/widgets/abstractspinbox.py 47 48 49 50 51 52 53 54 55 def get_button_symbols ( self ) -> str : \"\"\"Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: button symbol type \"\"\" return SYMBOLS . inv [ self . buttonSymbols ()] get_correction_mode ( self ) Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: Type Description str correction mode Source code in prettyqt/widgets/abstractspinbox.py 87 88 89 90 91 92 93 94 95 def get_correction_mode ( self ) -> str : \"\"\"Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: correction mode \"\"\" return CORRECTION_MODES . inv [ self . correctionMode ()] get_step_type ( self ) Return step type. possible values are \"default\", \"adaptive\" Returns: Type Description str step type Source code in prettyqt/widgets/abstractspinbox.py 112 113 114 115 116 117 118 119 120 def get_step_type ( self ) -> str : \"\"\"Return step type. possible values are \"default\", \"adaptive\" Returns: step type \"\"\" return STEP_TYPES . inv [ self . stepType ()] set_button_symbols ( self , mode ) Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Parameters: Name Type Description Default mode str button symbol type to use required Exceptions: Type Description InvalidParamError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def set_button_symbols ( self , mode : str ): \"\"\"Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ]) set_correction_mode ( self , mode ) Set correction mode. possible values are \"to_previous\", \"to_nearest\" Parameters: Name Type Description Default mode str correction mode to use required Exceptions: Type Description InvalidParamError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def set_correction_mode ( self , mode : str ): \"\"\"Set correction mode. possible values are \"to_previous\", \"to_nearest\" Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ]) set_step_type ( self , mode ) Set step type. possible values are \"default\", \"adaptive\" Parameters: Name Type Description Default mode str step type to use required Exceptions: Type Description InvalidParamError invalid step type Source code in prettyqt/widgets/abstractspinbox.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def set_step_type ( self , mode : str ): \"\"\"Set step type. possible values are \"default\", \"adaptive\" Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ]) action Action get_menu_role ( self ) Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: Type Description str menu role Source code in prettyqt/widgets/action.py 207 208 209 210 211 212 213 214 215 216 def get_menu_role ( self ) -> str : \"\"\"Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: menu role \"\"\" return ROLES . inv [ self . menuRole ()] get_priority ( self ) Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: Type Description str priority Source code in prettyqt/widgets/action.py 156 157 158 159 160 161 162 163 164 def get_priority ( self ) -> str : \"\"\"Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: priority \"\"\" return PRIORITIES . inv [ self . priority ()] get_shortcut_context ( self ) Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: Type Description str shortcut context Source code in prettyqt/widgets/action.py 181 182 183 184 185 186 187 188 189 def get_shortcut_context ( self ) -> str : \"\"\"Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: shortcut context \"\"\" return CONTEXTS . inv [ self . shortcutContext ()] set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/action.py 119 120 121 122 123 124 125 126 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) set_menu_role ( self , role ) Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Parameters: Name Type Description Default role str menu role required Exceptions: Type Description InvalidParamError menu role does not exist Source code in prettyqt/widgets/action.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def set_menu_role ( self , role : str ): \"\"\"Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ]) set_priority ( self , priority ) Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Parameters: Name Type Description Default priority str priority for the action required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/widgets/action.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def set_priority ( self , priority : str ): \"\"\"Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ]) set_shortcut_context ( self , context ) Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Parameters: Name Type Description Default context str shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/action.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def set_shortcut_context ( self , context : str ): \"\"\"Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in CONTEXTS : raise InvalidParamError ( context , CONTEXTS ) self . setShortcutContext ( CONTEXTS [ context ]) actiongroup ActionGroup get_exclusion_policy ( self ) Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: Type Description str exclusion policy Source code in prettyqt/widgets/actiongroup.py 51 52 53 54 55 56 57 58 59 def get_exclusion_policy ( self ) -> str : \"\"\"Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: exclusion policy \"\"\" return POLICIES . inv [ self . exclusionPolicy ()] set_exclusion_policy ( self , policy ) Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Parameters: Name Type Description Default policy Optional[str] exclusion policy to use required Exceptions: Type Description InvalidParamError exclusion policy does not exist Source code in prettyqt/widgets/actiongroup.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def set_exclusion_policy ( self , policy : Optional [ str ]): \"\"\"Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ]) application Application copy_to_clipboard ( text ) classmethod Sets clipboard to supplied text. Source code in prettyqt/widgets/application.py 74 75 76 77 78 79 @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Clipboard ) cb . setText ( text , mode = cb . Clipboard ) set_icon ( self , icon ) Set the default window icon. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/application.py 20 21 22 23 24 25 26 27 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) calendarwidget CalendarWidget get_selection_mode ( self ) Return current selection mode. Possible values: \"single\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/calendarwidget.py 63 64 65 66 67 68 69 70 71 def get_selection_mode ( self ) -> str : \"\"\"Return current selection mode. Possible values: \"single\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()] set_selection_mode ( self , mode ) Set selection mode for given calendar widget. Allowed values are \"single\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/calendarwidget.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"Set selection mode for given calendar widget. Allowed values are \"single\" or \"none\" Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise InvalidParamError ( mode , SELECTION_MODES ) self . setSelectionMode ( SELECTION_MODES [ mode ]) checkbox CheckBox get_checkstate ( self ) Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description bool checkstate Source code in prettyqt/widgets/checkbox.py 80 81 82 83 84 85 86 87 88 def get_checkstate ( self ) -> bool : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()] set_checkstate ( self , state ) Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/checkbox.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( STATES [ state ]) combobox ComboBox get_insert_policy ( self ) Return insert policy. possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: Type Description str insert policy Source code in prettyqt/widgets/combobox.py 130 131 132 133 134 135 136 137 138 139 def get_insert_policy ( self ) -> str : \"\"\"Return insert policy. possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: insert policy \"\"\" return INSERT_POLICIES . inv [ self . insertPolicy ()] get_size_adjust_policy ( self ) Return size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/combobox.py 157 158 159 160 161 162 163 164 165 def get_size_adjust_policy ( self ) -> str : \"\"\"Return size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()] set_insert_policy ( self , policy ) Set insert policy. valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Parameters: Name Type Description Default policy str insert policy to use required Exceptions: Type Description InvalidParamError invalid insert policy Source code in prettyqt/widgets/combobox.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def set_insert_policy ( self , policy : str ): \"\"\"Set insert policy. valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICIES : raise InvalidParamError ( policy , INSERT_POLICIES ) policy = INSERT_POLICIES . get ( policy ) self . setInsertPolicy ( policy ) set_size_adjust_policy ( self , policy ) Set size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/combobox.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def set_size_adjust_policy ( self , policy : str ): \"\"\"Set size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise InvalidParamError ( policy , SIZE_POLICIES ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy ) completer Completer get_completion_mode ( self ) Return current completion mode. Possible values: \"popup\", \"inline\", \"unfiltered_popup\" Returns: Type Description str completion mode Source code in prettyqt/widgets/completer.py 79 80 81 82 83 84 85 86 87 def get_completion_mode ( self ) -> str : \"\"\"Return current completion mode. Possible values: \"popup\", \"inline\", \"unfiltered_popup\" Returns: completion mode \"\"\" return COMPLETION_MODES . inv [ self . completionMode ()] get_filter_mode ( self ) Return current filter mode. Possible values: \"starts_with\", \"contains\", \"ends_with\" Returns: Type Description str filter mode Source code in prettyqt/widgets/completer.py 104 105 106 107 108 109 110 111 112 def get_filter_mode ( self ) -> str : \"\"\"Return current filter mode. Possible values: \"starts_with\", \"contains\", \"ends_with\" Returns: filter mode \"\"\" return FILTER_MODES . inv [ self . filterMode ()] get_sort_mode ( self ) Return current sort mode. Possible values: \"unsorted\", \"case_sensitive\", \"case_insensitive\" Returns: Type Description str sort mode Source code in prettyqt/widgets/completer.py 54 55 56 57 58 59 60 61 62 def get_sort_mode ( self ) -> str : \"\"\"Return current sort mode. Possible values: \"unsorted\", \"case_sensitive\", \"case_insensitive\" Returns: sort mode \"\"\" return SORT_MODES . inv [ self . modelSorting ()] set_completion_mode ( self , mode ) Set completion mode to use. Allowed values are \"popup\", \"inline\", \"unfiltered_popup\" Parameters: Name Type Description Default mode str completion mode to use required Exceptions: Type Description InvalidParamError completion mode does not exist Source code in prettyqt/widgets/completer.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def set_completion_mode ( self , mode : str ): \"\"\"Set completion mode to use. Allowed values are \"popup\", \"inline\", \"unfiltered_popup\" Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODES : raise InvalidParamError ( mode , COMPLETION_MODES ) self . setCompletionMode ( COMPLETION_MODES [ mode ]) set_filter_mode ( self , mode ) Set filter mode to use. Allowed values are \"starts_with\", \"contains\", \"ends_with\" Parameters: Name Type Description Default mode str filter mode to use required Exceptions: Type Description InvalidParamError filter mode does not exist Source code in prettyqt/widgets/completer.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def set_filter_mode ( self , mode : str ): \"\"\"Set filter mode to use. Allowed values are \"starts_with\", \"contains\", \"ends_with\" Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in FILTER_MODES : raise InvalidParamError ( mode , FILTER_MODES ) self . setFilterMode ( FILTER_MODES [ mode ]) set_sort_mode ( self , mode ) Set sort mode to use. Allowed values are \"unsorted\", \"case_sensitive\", \"case_insensitive\" Parameters: Name Type Description Default mode Optional[str] sort mode to use required Exceptions: Type Description InvalidParamError sort mode does not exist Source code in prettyqt/widgets/completer.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def set_sort_mode ( self , mode : Optional [ str ]): \"\"\"Set sort mode to use. Allowed values are \"unsorted\", \"case_sensitive\", \"case_insensitive\" Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODES : raise InvalidParamError ( mode , SORT_MODES ) self . setModelSorting ( SORT_MODES [ mode ]) dialog BaseDialog keyPressEvent ( self , e ) keyPressEvent(self, QKeyEvent) Source code in prettyqt/widgets/dialog.py 38 39 40 41 42 43 44 def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e ) dialogbuttonbox DialogButtonBox add_button ( self , button , role = 'accept' , callback = None ) Add a button. Parameters: Name Type Description Default button Union[PyQt5.QtWidgets.QPushButton, str] button to add required role str role of the button 'accept' callback Optional[Callable] function to call when button gets clicked None Returns: Type Description PushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def add_button ( self , button : Union [ QtWidgets . QPushButton , str ], role : str = \"accept\" , callback : Optional [ Callable ] = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button add_default_button ( self , button , callback = None ) Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required callback Optional[Callable] function to call when button gets clicked None Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def add_default_button ( self , button : str , callback : Optional [ Callable ] = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn create ( ** kwargs ) classmethod create(self, window: sip.voidptr = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) Source code in prettyqt/widgets/dialogbuttonbox.py 71 72 73 74 75 76 @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) return box get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/dialogbuttonbox.py 102 103 104 105 106 107 108 109 110 def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()] set_orientation ( self , orientation ) Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the button box required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) dockwidget DockWidget Customized DockWidget class. Contains a custom TitleBar with maximise button filedialog FileDialog Simple dialog used to display some widget. directory ( self ) Return current directory. returns current directory level as a Pathlib object Returns: Type Description Path Pathlib object Source code in prettyqt/widgets/filedialog.py 226 227 228 229 230 231 232 233 234 def directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( super () . directory ()) get_accept_mode ( self ) Return accept mode. possible values are \"save\", \"open\" Returns: Type Description str accept mode Source code in prettyqt/widgets/filedialog.py 102 103 104 105 106 107 108 109 110 def get_accept_mode ( self ) -> str : \"\"\"Return accept mode. possible values are \"save\", \"open\" Returns: accept mode \"\"\" return ACCEPT_MODES . inv [ self . acceptMode ()] get_file_mode ( self ) Return file mode. possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: Type Description str file mode Source code in prettyqt/widgets/filedialog.py 161 162 163 164 165 166 167 168 169 def get_file_mode ( self ) -> str : \"\"\"Return file mode. possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: file mode \"\"\" return MODES . inv [ self . fileMode ()] get_label_text ( self , label ) Return label text. possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py 151 152 153 154 155 156 157 158 159 def get_label_text ( self , label ) -> str : \"\"\"Return label text. possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: label text \"\"\" return self . labelText ( LABELS . inv [ label ]) get_view_mode ( self ) Return view mode. possible values are \"detail\", \"list\" Returns: Type Description str view mode Source code in prettyqt/widgets/filedialog.py 127 128 129 130 131 132 133 134 135 def get_view_mode ( self ) -> str : \"\"\"Return view mode. possible values are \"detail\", \"list\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()] set_accept_mode ( self , mode ) Set accept mode. possible values are \"save\", \"open\" Parameters: Name Type Description Default mode str accept mode to use required Exceptions: Type Description InvalidParamError invalid accept mode Source code in prettyqt/widgets/filedialog.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def set_accept_mode ( self , mode : str ): \"\"\"Set accept mode. possible values are \"save\", \"open\" Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODES : raise InvalidParamError ( mode , ACCEPT_MODES ) self . setAcceptMode ( ACCEPT_MODES [ mode ]) set_directory ( self , path ) Set start directory. Source code in prettyqt/widgets/filedialog.py 236 237 238 239 240 def set_directory ( self , path : Union [ None , str , pathlib . Path ]): \"\"\"Set start directory.\"\"\" if isinstance ( path , pathlib . Path ): path = str ( path ) self . setDirectory ( path ) set_extension_filter ( self , extension_dict ) Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict Dict[str, List[str]] filter dictionary required Source code in prettyqt/widgets/filedialog.py 212 213 214 215 216 217 218 219 220 221 222 223 224 def set_extension_filter ( self , extension_dict : Dict [ str , List [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str ) set_file_mode ( self , mode ) Set the file mode of the dialog. allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Parameters: Name Type Description Default mode str mode to use required Source code in prettyqt/widgets/filedialog.py 171 172 173 174 175 176 177 178 179 def set_file_mode ( self , mode : str ): \"\"\"Set the file mode of the dialog. allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Args: mode: mode to use \"\"\" self . setFileMode ( MODES [ mode ]) set_label_text ( self , label , text ) Set the label text for button label. possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Parameters: Name Type Description Default label str button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py 137 138 139 140 141 142 143 144 145 146 147 148 149 def set_label_text ( self , label : str , text : str ): \"\"\"Set the label text for button label. possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Args: label: button to set text for text: text to use \"\"\" if label not in LABELS : raise InvalidParamError ( label , LABELS ) self . setLabelText ( LABELS [ label ], text ) set_view_mode ( self , mode ) Set view mode. possible values are \"detail\", \"list\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/filedialog.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def set_view_mode ( self , mode : str ): \"\"\"Set view mode. possible values are \"detail\", \"list\" Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ]) filesystemmodel FileSystemModel Class to populate a filesystem treeview. data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/widgets/filesystemmodel.py 51 52 53 54 55 def data ( self , index , role = QtCore . Qt . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role ) fontcombobox FontComboBox get_font_filters ( self ) Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: Type Description List[str] font filter list Source code in prettyqt/widgets/fontcombobox.py 61 62 63 64 65 66 67 68 69 70 def get_font_filters ( self ) -> List [ str ]: \"\"\"Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()] set_font_filters ( self , * filters ) Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Parameters: Name Type Description Default filters str font filters to use () Exceptions: Type Description InvalidParamError invalid font filters Source code in prettyqt/widgets/fontcombobox.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def set_font_filters ( self , * filters : str ): \"\"\"Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags ) formlayout FormLayout __len__ ( self ) special Needed for PySide2. Source code in prettyqt/widgets/formlayout.py 39 40 41 def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount () frame Frame get_frame_style ( self ) Return current frame style. Possible values: \"plain\", \"raised\", \"sunken\" Returns: Type Description str frame style Source code in prettyqt/widgets/frame.py 44 45 46 47 48 49 50 51 52 def get_frame_style ( self ) -> str : \"\"\"Return current frame style. Possible values: \"plain\", \"raised\", \"sunken\" Returns: frame style \"\"\" return SHADOWS . inv [ self . frameStyle ()] set_frame_style ( self , style ) Set frame style. Allowed values are \"plain\", \"raised\", \"sunken\" Parameters: Name Type Description Default style str frame style to use required Exceptions: Type Description InvalidParamError style does not exist Source code in prettyqt/widgets/frame.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def set_frame_style ( self , style : str ): \"\"\"Set frame style. Allowed values are \"plain\", \"raised\", \"sunken\" Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style not in SHADOWS : raise InvalidParamError ( style , SHADOWS ) self . setFrameStyle ( SHADOWS [ style ]) groupbox GroupBox GroupBox widget. A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets. headerview HeaderView contextMenuEvent ( self , event ) Context menu for our files tree. Source code in prettyqt/widgets/headerview.py 71 72 73 74 75 76 77 78 79 80 81 def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) for i , header_label in enumerate ( self . section_labels ()[ 1 :], start = 1 ): act = menu . addAction ( header_label ) act . setCheckable ( True ) val = not self . isSectionHidden ( i ) act . setChecked ( val ) fn = functools . partial ( self . set_section_hidden , i = i , hide = val ) act . triggered . connect ( fn ) menu . exec_ ( self . mapToGlobal ( event . pos ())) label Label get_text_format ( self ) Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/label.py 123 124 125 126 127 128 129 130 131 def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()] get_text_interaction ( self ) Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: Type Description List[str] list of text interaction modes Source code in prettyqt/widgets/label.py 151 152 153 154 155 156 157 158 159 def get_text_interaction ( self ) -> List [ str ]: \"\"\"Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()] set_text_format ( self , text_format ) Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/label.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise InvalidParamError ( text_format , TEXT_FORMATS ) self . setTextFormat ( TEXT_FORMATS [ text_format ]) return self set_text_interaction ( self , * types ) Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Parameters: Name Type Description Default types str text interaction mode to use () Exceptions: Type Description InvalidParamError text interaction mode does not exist Source code in prettyqt/widgets/label.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def set_text_interaction ( self , * types : str ): \"\"\"Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self set_weight ( self , weight ) Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/widgets/label.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def set_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) font = self . font () font . setWeight ( WEIGHTS [ weight ]) self . setFont ( font ) return self layout Layout get_size_mode ( self ) Return current size mode. Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: Type Description str size mode Source code in prettyqt/widgets/layout.py 87 88 89 90 91 92 93 94 95 def get_size_mode ( self ) -> str : \"\"\"Return current size mode. Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: size mode \"\"\" return MODES . inv [ self . sizeConstraint ()] set_alignment ( self , alignment , item = None ) Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required item set alignment for specific child only None Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layout.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def set_alignment ( self , alignment : str , item = None ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) if item is not None : return self . setAlignment ( item , ALIGNMENTS [ alignment ]) else : return self . setAlignment ( ALIGNMENTS [ alignment ]) set_size_mode ( self , mode ) Set the size mode of the layout. Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Parameters: Name Type Description Default mode str size mode for the layout required Exceptions: Type Description InvalidParamError size mode does not exist Source code in prettyqt/widgets/layout.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def set_size_mode ( self , mode : str ): \"\"\"Set the size mode of the layout. Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setSizeConstraint ( MODES [ mode ]) lineedit LineEdit font ( self ) font(self) -> QFont Source code in prettyqt/widgets/lineedit.py 71 72 def font ( self ) -> gui . Font : return gui . Font ( super () . font ()) get_echo_mode ( self ) Return echo mode. possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: Type Description str echo mode Source code in prettyqt/widgets/lineedit.py 125 126 127 128 129 130 131 132 133 def get_echo_mode ( self ) -> str : \"\"\"Return echo mode. possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: echo mode \"\"\" return ECHO_MODES . inv [ self . echoMode ()] set_echo_mode ( self , mode ) Set echo mode. Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Parameters: Name Type Description Default mode str echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/lineedit.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def set_echo_mode ( self , mode : str ): \"\"\"Set echo mode. Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODES : raise InvalidParamError ( mode , ECHO_MODES ) self . setEchoMode ( ECHO_MODES [ mode ]) set_read_only ( self , value = True ) Set text to read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py 80 81 82 83 84 85 86 def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) listview ListView get_view_mode ( self ) Return view mode. possible values are \"list\", \"icon\" Returns: Type Description str view mode Source code in prettyqt/widgets/listview.py 31 32 33 34 35 36 37 38 39 def get_view_mode ( self ) -> str : \"\"\"Return view mode. possible values are \"list\", \"icon\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()] set_view_mode ( self , mode ) Set view mode. possible values are \"list\", \"icon\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/listview.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def set_view_mode ( self , mode : str ): \"\"\"Set view mode. possible values are \"list\", \"icon\" Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ]) listwidgetitem ListWidgetItem get_checkstate ( self ) Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/listwidgetitem.py 61 62 63 64 65 66 67 68 69 def get_checkstate ( self ) -> str : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()] set_checkstate ( self , state ) Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( STATES [ state ]) set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/listwidgetitem.py 37 38 39 40 41 42 43 44 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) mainwindow MainWindow Class for our mainWindow. Includes all docks, a centralwidget and a toolbar add_toolbar ( self , toolbar , position = 'top' ) Adds a toolbar to the mainmenu at specified area. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default toolbar QToolBar toolbar to use required position str position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : str = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBar ( TOOLBAR_AREAS [ position ], toolbar ) add_toolbar_break ( self , position = 'top' ) Adds a toolbar break to the given area behind the last item. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default position str position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def add_toolbar_break ( self , position : str = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBarBreak ( TOOLBAR_AREAS [ position ]) createPopupMenu ( self ) createPopupMenu(self) -> QMenu Source code in prettyqt/widgets/mainwindow.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add_action ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add_action ( action ) return menu save_window_state ( self , recursive = False ) Save current window state as QSetting. Parameters: Name Type Description Default recursive bool Description False Source code in prettyqt/widgets/mainwindow.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def save_window_state ( self , recursive = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { name } ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state () toggle_fullscreen ( self ) Toggle between fullscreen and regular size. Source code in prettyqt/widgets/mainwindow.py 191 192 193 194 195 196 def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen () mdiarea MdiArea get_tab_position ( self ) Return current tab position. Possible values: \"north\", \"south\", \"west\", \"east\" Returns: Type Description str tab position Source code in prettyqt/widgets/mdiarea.py 108 109 110 111 112 113 114 115 116 def get_tab_position ( self ) -> str : \"\"\"Return current tab position. Possible values: \"north\", \"south\", \"west\", \"east\" Returns: tab position \"\"\" return TAB_POSITIONS . inv [ self . tabPosition ()] get_view_mode ( self ) Return current view mode. Possible values: \"default\", \"tabbed\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py 58 59 60 61 62 63 64 65 66 def get_view_mode ( self ) -> str : \"\"\"Return current view mode. Possible values: \"default\", \"tabbed\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()] get_window_order ( self ) Return current window order. Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py 83 84 85 86 87 88 89 90 91 def get_window_order ( self ) -> str : \"\"\"Return current window order. Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: view mode \"\"\" return WINDOW_ORDERS . inv [ self . activationOrder ()] set_tab_position ( self , position ) Set tab position for the MDI area. Valid values are \"north\", \"south\", \"west\", \"east\" Parameters: Name Type Description Default position str tabs position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/mdiarea.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def set_tab_position ( self , position : str ): \"\"\"Set tab position for the MDI area. Valid values are \"north\", \"south\", \"west\", \"east\" Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITIONS : raise InvalidParamError ( position , TAB_POSITIONS ) self . setTabPosition ( TAB_POSITIONS [ position ]) set_view_mode ( self , mode ) Set view mode for the MDI area. Valid values are \"default\", \"tabbed\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError view mode does not exist Source code in prettyqt/widgets/mdiarea.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def set_view_mode ( self , mode : str ): \"\"\"Set view mode for the MDI area. Valid values are \"default\", \"tabbed\" Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ]) set_window_order ( self , mode ) Set the window order behaviour for the MDI area. Valid values are \"creation\", \"stacking\", \"activation_history\" Parameters: Name Type Description Default mode str window order behaviour to use required Exceptions: Type Description InvalidParamError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def set_window_order ( self , mode : str ): \"\"\"Set the window order behaviour for the MDI area. Valid values are \"creation\", \"stacking\", \"activation_history\" Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDERS : raise InvalidParamError ( mode , WINDOW_ORDERS ) self . setActivationOrder ( WINDOW_ORDERS [ mode ]) menu Menu add_action ( self , label , callback = None , icon = None , checkable = False , checked = False , shortcut = None , status_tip = None ) Add an action to the menu. Parameters: Name Type Description Default label Union[str, prettyqt.widgets.action.Action] Label for button required callback Callable gets called when action is triggered None icon Optional[Any] icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut Optional[str] Shortcut for action None status_tip Optional[str] Status tip to be shown in status bar None Returns: Type Description Action Action added to menu Source code in prettyqt/widgets/menu.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def add_action ( self , label : Union [ str , widgets . Action ], callback : Callable = None , icon : Optional [ Any ] = None , checkable : bool = False , checked : bool = False , shortcut : Optional [ str ] = None , status_tip : Optional [ str ] = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action add_separator ( self , text = None ) Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None Returns: Type Description WidgetAction Separator action Source code in prettyqt/widgets/menu.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def add_separator ( self , text : Optional [ str ] = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator set_icon ( self , icon ) Set the icon for the menu. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/menu.py 46 47 48 49 50 51 52 53 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) messagebox MessageBox add_button ( self , button ) Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/messagebox.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def add_button ( self , button : str ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ]) get_text_format ( self ) Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/messagebox.py 152 153 154 155 156 157 158 159 160 def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()] set_icon ( self , icon ) Set the window icon. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/messagebox.py 97 98 99 100 101 102 def set_icon ( self , icon : gui . icon . IconType ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) return None icon = gui . icon . get_icon ( icon ) self . setIconPixmap ( icon . get_pixmap ( size = 64 )) set_text_format ( self , text_format ) Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/messagebox.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise InvalidParamError ( text_format , TEXT_FORMATS ) self . setTextFormat ( TEXT_FORMATS [ text_format ]) plaintextedit PlainTextEdit set_line_wrap_mode ( self , mode ) Set line wrap mode. Allowed values are \"none\" and \"widget width\" Parameters: Name Type Description Default mode str line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def set_line_wrap_mode ( self , mode : str ): \"\"\"Set line wrap mode. Allowed values are \"none\" and \"widget width\" Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODES : raise InvalidParamError ( mode , LINE_WRAP_MODES ) self . setLineWrapMode ( LINE_WRAP_MODES [ mode ]) set_read_only ( self , value = True ) Make the PlainTextEdit read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py 117 118 119 120 121 122 123 def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) set_wrap_mode ( self , mode ) Set word wrap mode. Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Parameters: Name Type Description Default mode str word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def set_wrap_mode ( self , mode : str ): \"\"\"Set word wrap mode. Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in WRAP_MODES : raise InvalidParamError ( mode , WRAP_MODES ) self . setWordWrapMode ( WRAP_MODES [ mode ]) wheelEvent ( self , event ) Handle wheel event for zooming. Source code in prettyqt/widgets/plaintextedit.py 65 66 67 68 69 70 71 72 def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event ) progressbar ProgressBar Progress dialog. wrapper for QtWidgets.QProgressBar get_alignment ( self ) Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description str alignment Source code in prettyqt/widgets/progressbar.py 53 54 55 56 57 58 59 60 61 def get_alignment ( self ) -> str : \"\"\"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" return ALIGNMENTS . inv [ self . alignment ()] get_text_direction ( self ) Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Type Description str Text direction Source code in prettyqt/widgets/progressbar.py 78 79 80 81 82 83 84 85 86 def get_text_direction ( self ) -> str : \"\"\"Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inv [ self . textDirection ()] set_alignment ( self , alignment ) Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/progressbar.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def set_alignment ( self , alignment : str ): \"\"\"Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) self . setAlignment ( ALIGNMENTS [ alignment ]) set_text_direction ( self , text_direction ) Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Parameters: Name Type Description Default text_direction str text direction for the layout required Exceptions: Type Description InvalidParamError text direction does not exist Source code in prettyqt/widgets/progressbar.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def set_text_direction ( self , text_direction : str ): \"\"\"Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ]) progressdialog ProgressDialog Progress dialog. Wrapper for QtWidgets.QProgressDialog sizepolicy SizePolicy __pretty__ ( self , fmt , ** kwargs ) special Provide a human readable representations of objects. Used by devtools (https://python-devtools.helpmanual.io/). Source code in prettyqt/widgets/sizepolicy.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def __pretty__ ( self , fmt : Callable [[ Any ], Any ], ** kwargs : Any ) -> Generator [ Any , None , None ]: \"\"\"Provide a human readable representations of objects. Used by devtools (https://python-devtools.helpmanual.io/). \"\"\" yield self . __class__ . __name__ + \"(\" yield 1 for k , v in self . __getstate__ () . items (): yield f \" { k } = { v !r} \" yield 0 yield - 1 yield \")\" get_control_type ( self ) Return control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: Type Description str control type Source code in prettyqt/widgets/sizepolicy.py 124 125 126 127 128 129 130 131 132 133 134 def get_control_type ( self ) -> str : \"\"\"Return control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: control type \"\"\" return CONTROL_TYPES . inv [ self . controlType ()] get_horizontal_policy ( self ) Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str horizontal size policy Source code in prettyqt/widgets/sizepolicy.py 80 81 82 83 84 85 86 87 88 89 def get_horizontal_policy ( self ) -> str : \"\"\"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: horizontal size policy \"\"\" return SIZE_POLICIES . inv [ self . horizontalPolicy ()] get_vertical_policy ( self ) Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str vertical size policy Source code in prettyqt/widgets/sizepolicy.py 102 103 104 105 106 107 108 109 110 111 def get_vertical_policy ( self ) -> str : \"\"\"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: vertical size policy \"\"\" return SIZE_POLICIES . inv [ self . verticalPolicy ()] set_control_type ( self , mode ) Set the control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Parameters: Name Type Description Default mode str control type to set required Source code in prettyqt/widgets/sizepolicy.py 136 137 138 139 140 141 142 143 144 145 146 def set_control_type ( self , mode : str ) -> None : \"\"\"Set the control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Args: mode: control type to set \"\"\" self . setControlType ( CONTROL_TYPES [ mode ]) set_horizontal_policy ( self , mode ) Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py 91 92 93 94 95 96 97 98 99 100 def set_horizontal_policy ( self , mode : str ) -> None : \"\"\"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setHorizontalPolicy ( SIZE_POLICIES [ mode ]) set_vertical_policy ( self , mode ) Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py 113 114 115 116 117 118 119 120 121 122 def set_vertical_policy ( self , mode : str ) -> None : \"\"\"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setVerticalPolicy ( SIZE_POLICIES [ mode ]) slider Slider get_tick_position ( self ) Return tick position. possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: Type Description str tick position Source code in prettyqt/widgets/slider.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def get_tick_position ( self ) -> str : \"\"\"Return tick position. possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: tick position \"\"\" val = TICK_POSITIONS . inv [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\" return val set_tick_position ( self , position ) Set the tick position for the slider. allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Parameters: Name Type Description Default position str position for the ticks required Source code in prettyqt/widgets/slider.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def set_tick_position ( self , position : str ): \"\"\"Set the tick position for the slider. allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITIONS : raise InvalidParamError ( position , TICK_POSITIONS ) self . setTickPosition ( TICK_POSITIONS [ position ]) splitter Splitter get_orientation ( self ) Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/splitter.py 108 109 110 111 112 113 114 115 116 def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()] set_orientation ( self , orientation ) Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitter.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) styleoptionslider StyleOptionSlider is_horizontal ( self ) Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py 29 30 31 32 33 34 35 def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == QtCore . Qt . Horizontal is_vertical ( self ) Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py 37 38 39 40 41 42 43 def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == QtCore . Qt . Vertical set_horizontal ( self ) Set slider orientation to horizontal. Source code in prettyqt/widgets/styleoptionslider.py 45 46 47 def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = QtCore . Qt . Horizontal set_vertical ( self ) Set slider orientation to vertical. Source code in prettyqt/widgets/styleoptionslider.py 49 50 51 def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = QtCore . Qt . Vertical systemtrayicon SystemTrayIcon set_icon ( self , icon ) Set the system tray icon. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/systemtrayicon.py 25 26 27 28 29 30 31 32 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon ) tabbar TabBar get_elide_mode ( self ) Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: Type Description str elide mode Source code in prettyqt/widgets/tabbar.py 135 136 137 138 139 140 141 142 143 def get_elide_mode ( self ) -> str : \"\"\"Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: elide mode \"\"\" return ELIDE_MODES . inv [ self . elideMode ()] get_remove_behaviour ( self ) Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: Type Description str remove behaviour Source code in prettyqt/widgets/tabbar.py 110 111 112 113 114 115 116 117 118 def get_remove_behaviour ( self ) -> str : \"\"\"Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOURS . inv [ self . selectionBehaviorOnRemove ()] mouseDoubleClickEvent ( self , event ) mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/widgets/tabbar.py 80 81 82 def mouseDoubleClickEvent ( self , event ): event . accept () self . on_detach . emit ( self . tabAt ( event . pos ()), self . mouse_cursor . pos ()) set_elide_mode ( self , mode ) Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Parameters: Name Type Description Default mode str elide mode to use required Exceptions: Type Description InvalidParamError invalid elide mode Source code in prettyqt/widgets/tabbar.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def set_elide_mode ( self , mode : str ) -> None : \"\"\"Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in ELIDE_MODES : raise InvalidParamError ( mode , ELIDE_MODES ) self . setElideMode ( ELIDE_MODES [ mode ]) set_icon_size ( self , size ) Set the icon size for the tabs. Parameters: Name Type Description Default size int height/width of the icons required Source code in prettyqt/widgets/tabbar.py 84 85 86 87 88 89 90 def set_icon_size ( self , size : int ) -> None : \"\"\"Set the icon size for the tabs. Args: size: height/width of the icons \"\"\" self . setIconSize ( QtCore . QSize ( size , size )) set_remove_behaviour ( self , mode ) Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Parameters: Name Type Description Default mode str new remove behaviour required Source code in prettyqt/widgets/tabbar.py 97 98 99 100 101 102 103 104 105 106 107 108 def set_remove_behaviour ( self , mode : str ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOURS : raise InvalidParamError ( mode , REMOVE_BEHAVIOURS ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOURS [ mode ]) tabwidget DetachedTab Window containing a detached tab. When a tab is detached, the contents are placed into this QMainWindow. The tab can be re-attached by closing the dialog Attributes: Name Type Description on_close signal, emitted when window is closed (widget, title, icon) closeEvent ( self , event ) closeEvent(self, QCloseEvent) Source code in prettyqt/widgets/tabwidget.py 264 265 def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . id , self . windowIcon ()) TabWidget Widget for managing the tabs section. attach_tab ( self , widget , name , icon = None , insert_at = None ) Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Parameters: Name Type Description Default widget Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] the content widget from the DetachedTab window required name str the name of the detached tab required icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] the window icon for the detached tab None insert_at Optional[int] insert the re-attached tab at the given index None Source code in prettyqt/widgets/tabwidget.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def attach_tab ( self , widget : Union [ QtWidgets . QWidget , QtWidgets . QLayout ], name : str , icon : gui . icon . IconType = None , insert_at : Optional [ int ] = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (gui.icon.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True ) close_detached_tabs ( self ) Close all tabs that are currently detached. Source code in prettyqt/widgets/tabwidget.py 216 217 218 219 220 def close_detached_tabs ( self ) -> None : \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close () detach_tab ( self , index , point ) Detach tab by removing its contents and placing them in a DetachedTab window. Parameters: Name Type Description Default index int index location of the tab to be detached required point QPoint screen pos for creating the new DetachedTab window required Returns: Type Description None None: Description Source code in prettyqt/widgets/tabwidget.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 @core . Slot ( int , QtCore . QPoint ) def detach_tab ( self , index : int , point : QtCore . QPoint ) -> None : \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content name = self . tabText ( index ) icon = self . tabIcon ( index ) if icon . isNull (): icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab get_tab_shape ( self ) Return tab shape. possible values are \"roundes\", \"triangular\" Returns: Type Description str tab shape Source code in prettyqt/widgets/tabwidget.py 95 96 97 98 99 100 101 102 103 def get_tab_shape ( self ) -> str : \"\"\"Return tab shape. possible values are \"roundes\", \"triangular\" Returns: tab shape \"\"\" return TAB_SHAPES . inv [ self . tabShape ()] open_widget ( self , widget , title = 'Unnamed' ) Create a tab containing delivered widget. Source code in prettyqt/widgets/tabwidget.py 229 230 231 232 @core . Slot ( object , str ) def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True ) set_tab_shape ( self , shape ) Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Parameters: Name Type Description Default shape str tab shape to use required Exceptions: Type Description InvalidParamError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def set_tab_shape ( self , shape : str ) -> None : \"\"\"Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ]) toolbar ToolBar add_separator ( self , text = None , before = None ) Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None before QAction insert separator before specific action None Returns: Type Description QAction Separator action Source code in prettyqt/widgets/toolbar.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def add_separator ( self , text : Optional [ str ] = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label ) get_style ( self ) Return current style. Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: Type Description str style Source code in prettyqt/widgets/toolbar.py 90 91 92 93 94 95 96 97 98 def get_style ( self ) -> str : \"\"\"Return current style. Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: style \"\"\" return STYLES . inv [ self . toolButtonStyle ()] is_area_allowed ( self , area ) Check if toolbar is allowed at specified area. Valid values for area: \"left\", \"right\", \"top\", \"bottom\", \"all\" Parameters: Name Type Description Default area str area of the toolbar required Exceptions: Type Description InvalidParamError area does not exist Source code in prettyqt/widgets/toolbar.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def is_area_allowed ( self , area : str ): \"\"\"Check if toolbar is allowed at specified area. Valid values for area: \"left\", \"right\", \"top\", \"bottom\", \"all\" Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in TOOLBAR_AREAS : raise InvalidParamError ( area , TOOLBAR_AREAS ) return self . isAreaAllowed ( TOOLBAR_AREAS [ area ]) toolbutton ToolButton get_arrow_type ( self ) Return arrow type. possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: Type Description str arrow type Source code in prettyqt/widgets/toolbutton.py 89 90 91 92 93 94 95 96 97 def get_arrow_type ( self ) -> str : \"\"\"Return arrow type. possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: arrow type \"\"\" return ARROW_TYPES . inv [ self . arrowType ()] get_popup_mode ( self ) Return popup mode. possible values are \"delayed\", \"menu_button\", \"instant\" Returns: Type Description str popup mode Source code in prettyqt/widgets/toolbutton.py 64 65 66 67 68 69 70 71 72 def get_popup_mode ( self ) -> str : \"\"\"Return popup mode. possible values are \"delayed\", \"menu_button\", \"instant\" Returns: popup mode \"\"\" return POPUP_MODES . inv [ self . popupMode ()] set_arrow_type ( self , mode ) Set the arrow type of the toolbutton. valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Parameters: Name Type Description Default mode str arrow type to use required Exceptions: Type Description InvalidParamError invalid arrow type Source code in prettyqt/widgets/toolbutton.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def set_arrow_type ( self , mode : str ): \"\"\"Set the arrow type of the toolbutton. valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in ARROW_TYPES : raise InvalidParamError ( mode , ARROW_TYPES ) self . setArrowType ( ARROW_TYPES [ mode ]) set_popup_mode ( self , mode ) Set the popup mode of the toolbutton. valid values are: \"delayed\", \"menu_button\", \"instant\" Parameters: Name Type Description Default mode str popup mode to use required Exceptions: Type Description InvalidParamError invalid popup mode Source code in prettyqt/widgets/toolbutton.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def set_popup_mode ( self , mode : str ): \"\"\"Set the popup mode of the toolbutton. valid values are: \"delayed\", \"menu_button\", \"instant\" Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODES : raise InvalidParamError ( mode , POPUP_MODES ) self . setPopupMode ( POPUP_MODES [ mode ]) treewidgetitem TreeWidgetItem get_checkstate ( self ) Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/treewidgetitem.py 62 63 64 65 66 67 68 69 70 def get_checkstate ( self ) -> str : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ( 0 )] set_checkstate ( self , state ) Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( 0 , STATES [ state ]) set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/treewidgetitem.py 38 39 40 41 42 43 44 45 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( 0 , icon ) undoview UndoView set_clean_icon ( self , icon ) Set the icon for the clean button. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/undoview.py 17 18 19 20 21 22 23 24 def set_clean_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setCleanIcon ( icon ) widget Widget __pretty__ ( self , fmt , ** kwargs ) special Provide a human readable representations of objects. Used by devtools (https://python-devtools.helpmanual.io/). Source code in prettyqt/widgets/widget.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def __pretty__ ( self , fmt : Callable [[ Any ], Any ], ** kwargs : Any ) -> Generator [ Any , None , None ]: \"\"\"Provide a human readable representations of objects. Used by devtools (https://python-devtools.helpmanual.io/). \"\"\" yield self . __class__ . __name__ + \"(\" yield 1 for k , v in self . serialize () . items (): yield f \" { k } =\" if hasattr ( v , \"__pretty__\" ): yield from v . __pretty__ ( fmt , ** kwargs ) else : yield f \" { v !r} \" yield 0 yield - 1 yield \")\" get_contextmenu_policy ( self ) Return current contextmenu policy. Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Returns: Type Description str contextmenu policy Source code in prettyqt/widgets/widget.py 348 349 350 351 352 353 354 355 356 def get_contextmenu_policy ( self ) -> str : \"\"\"Return current contextmenu policy. Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Returns: contextmenu policy \"\"\" return CONTEXT_POLICIES . inv [ self . contextMenuPolicy ()] get_modality ( self ) Get the current modality modes as a string. Possible values: \"none\", \"window\", \"application\" Returns: Type Description str modality mode str Source code in prettyqt/widgets/widget.py 267 268 269 270 271 272 273 274 275 276 def get_modality ( self ) -> str : \"\"\"Get the current modality modes as a string. Possible values: \"none\", \"window\", \"application\" Returns: modality mode str \"\"\" return MODALITIES . inv [ self . windowModality ()] resize ( self , * size ) resize(self, QSize) resize(self, int, int) Source code in prettyqt/widgets/widget.py 134 135 136 137 138 def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size ) set_contextmenu_policy ( self , policy ) Set contextmenu policy for given item view. Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Parameters: Name Type Description Default policy str contextmenu policy to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def set_contextmenu_policy ( self , policy : str ) -> None : \"\"\"Set contextmenu policy for given item view. Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CONTEXT_POLICIES : raise InvalidParamError ( policy , CONTEXT_POLICIES ) self . setContextMenuPolicy ( CONTEXT_POLICIES [ policy ]) set_icon ( self , icon ) Set the window icon. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/widget.py 140 141 142 143 144 145 146 147 def set_icon ( self , icon : gui . icon . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) set_modality ( self , modality = 'window' ) Set modality for the dialog. Valid values for modality: \"none\", \"window\", \"application\" Parameters: Name Type Description Default modality str modality for the main window 'window' Exceptions: Type Description InvalidParamError modality type does not exist Source code in prettyqt/widgets/widget.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def set_modality ( self , modality : str = \"window\" ) -> None : \"\"\"Set modality for the dialog. Valid values for modality: \"none\", \"window\", \"application\" Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in MODALITIES : raise InvalidParamError ( modality , MODALITIES ) self . setWindowModality ( MODALITIES [ modality ]) set_size_policy ( self , horizontal = None , vertical = None ) Set the sizes policy. possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default horizontal Optional[str] horizontal size policy None vertical Optional[str] vertical size policy None Source code in prettyqt/widgets/widget.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def set_size_policy ( self , horizontal : Optional [ str ] = None , vertical : Optional [ str ] = None ) -> None : \"\"\"Set the sizes policy. possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp )","title":"widgets"},{"location":"api/widgets.html#widgets-module","text":"","title":"widgets module"},{"location":"api/widgets.html#prettyqt.widgets","text":"widgets module. contains QtWidgets-based classes","title":"prettyqt.widgets"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton","text":"","title":"abstractbutton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton","text":"","title":"AbstractButton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton.set_icon","text":"Set the icon for the button. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/abstractbutton.py 33 34 35 36 37 38 39 40 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview","text":"","title":"abstractitemview"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView","text":"","title":"AbstractItemView"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_behaviour","text":"Return current selection behaviour. Possible values: \"rows\", \"columns\", \"items\" Returns: Type Description str selection behaviour Source code in prettyqt/widgets/abstractitemview.py 181 182 183 184 185 186 187 188 189 def get_selection_behaviour ( self ) -> str : \"\"\"Return current selection behaviour. Possible values: \"rows\", \"columns\", \"items\" Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOURS . inv [ self . selectionBehavior ()]","title":"get_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_mode","text":"Return current selection mode. Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/abstractitemview.py 208 209 210 211 212 213 214 215 216 def get_selection_mode ( self ) -> str : \"\"\"Return current selection mode. Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.highlight_when_inactive","text":"Highlight items when widget does not have focus. Source code in prettyqt/widgets/abstractitemview.py 304 305 306 307 308 def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p )","title":"highlight_when_inactive()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.jump_to_column","text":"Make sure column at given index is visible. scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py 274 275 276 277 278 279 280 281 282 283 284 285 def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return None idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx )","title":"jump_to_column()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.num_selected","text":"Return amount of selected rows. Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py 264 265 266 267 268 269 270 271 272 def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ())","title":"num_selected()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_bottom","text":"Override to use abstractitemview-way of scrolling to bottom. Source code in prettyqt/widgets/abstractitemview.py 291 292 293 def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_top","text":"Override to use abstractitemview-way of scrolling to top. Source code in prettyqt/widgets/abstractitemview.py 287 288 289 def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selectAll","text":"Override, we dont want to selectAll for too many items bc of performance. Source code in prettyqt/widgets/abstractitemview.py 53 54 55 56 57 58 59 60 def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return None if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return None super () . selectAll ()","title":"selectAll()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_data","text":"Returns generator yielding selected userData. Source code in prettyqt/widgets/abstractitemview.py 144 145 146 def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes ())","title":"selected_data()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_indexes","text":"Returns list of selected indexes in first row. Source code in prettyqt/widgets/abstractitemview.py 131 132 133 134 def selected_indexes ( self ) -> List [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) return sorted ( indexes , key = lambda x : x . row ())","title":"selected_indexes()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_names","text":"Returns generator yielding item names. Source code in prettyqt/widgets/abstractitemview.py 136 137 138 def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ())","title":"selected_names()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_rows","text":"Returns generator yielding row nums. Source code in prettyqt/widgets/abstractitemview.py 140 141 142 def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ())","title":"selected_rows()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_horizontal_scroll_mode","text":"Set the horizontal scroll mode. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def set_horizontal_scroll_mode ( self , mode : str ): \"\"\"Set the horizontal scroll mode. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ])","title":"set_horizontal_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_model","text":"Delete old selection model explicitely, seems to help with memory usage. Source code in prettyqt/widgets/abstractitemview.py 62 63 64 65 66 67 68 69 70 71 72 73 def set_model ( self , model : Optional [ QtCore . QAbstractItemModel ]): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model","title":"set_model()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_scroll_mode","text":"Set the scroll mode for both directions. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def set_scroll_mode ( self , mode : str ): \"\"\"Set the scroll mode for both directions. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ]) self . setVerticalScrollMode ( SCROLL_MODES [ mode ])","title":"set_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_behaviour","text":"Set selection behaviour for given item view. Allowed values are \"rows\", \"columns\", \"items\" Parameters: Name Type Description Default behaviour str selection behaviour to use required Exceptions: Type Description InvalidParamError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def set_selection_behaviour ( self , behaviour : str ): \"\"\"Set selection behaviour for given item view. Allowed values are \"rows\", \"columns\", \"items\" Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOURS : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOURS ) self . setSelectionBehavior ( SELECTION_BEHAVIOURS [ behaviour ])","title":"set_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_mode","text":"Set selection mode for given item view. Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"Set selection mode for given item view. Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise InvalidParamError ( mode , SELECTION_MODES ) self . setSelectionMode ( SELECTION_MODES [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_vertical_scroll_mode","text":"Set the vertical scroll mode. possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 def set_vertical_scroll_mode ( self , mode : str ): \"\"\"Set the vertical scroll mode. possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise InvalidParamError ( mode , SCROLL_MODES ) self . setVerticalScrollMode ( SCROLL_MODES [ mode ])","title":"set_vertical_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.toggle_select_all","text":"Select all items from list (deselect when all selected). Source code in prettyqt/widgets/abstractitemview.py 97 98 99 100 101 102 103 104 def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return None if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll ()","title":"toggle_select_all()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea","text":"","title":"abstractscrollarea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea","text":"","title":"AbstractScrollArea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.get_size_adjust_policy","text":"Return size adjust policy. possible values are \"content\", \"first_show\", \"ignored\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py 68 69 70 71 72 73 74 75 76 def get_size_adjust_policy ( self ) -> str : \"\"\"Return size adjust policy. possible values are \"content\", \"first_show\", \"ignored\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_bottom","text":"Scroll to the bottom of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py 155 156 157 def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_top","text":"Scroll to the top of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py 151 152 153 def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_policy","text":"Set the horizontal scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def set_horizontal_scrollbar_policy ( self , mode : str ): \"\"\"Set the horizontal scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_horizontal_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_width","text":"Set the horizontal scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 133 134 135 136 137 138 139 140 def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" )","title":"set_horizontal_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_policy","text":"Set the policy for both scrollbars. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def set_scrollbar_policy ( self , mode : str ): \"\"\"Set the policy for both scrollbars. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_width","text":"Set the width for both scrollbars. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 124 125 126 127 128 129 130 131 def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width )","title":"set_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_size_adjust_policy","text":"Set size adjust policy. Valid values are \"content\", \"first_show\", \"ignored\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def set_size_adjust_policy ( self , policy : str ): \"\"\"Set size adjust policy. Valid values are \"content\", \"first_show\", \"ignored\" Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise InvalidParamError ( policy , SIZE_POLICIES ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy )","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_policy","text":"Set the vertical scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def set_vertical_scrollbar_policy ( self , mode : str ): \"\"\"Set the vertical scrollbar visibility. possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise InvalidParamError ( mode , SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_vertical_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_width","text":"Set the vertical scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 142 143 144 145 146 147 148 149 def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" )","title":"set_vertical_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider","text":"","title":"abstractslider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider","text":"","title":"AbstractSlider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_horizontal","text":"Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py 39 40 41 42 43 44 45 def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == QtCore . Qt . Horizontal","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_vertical","text":"Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py 47 48 49 50 51 52 53 def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == QtCore . Qt . Vertical","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_max","text":"Scroll to the maximum value of the slider. Source code in prettyqt/widgets/abstractslider.py 67 68 69 def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ())","title":"scroll_to_max()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_min","text":"Scroll to the minimum value of the slider. Source code in prettyqt/widgets/abstractslider.py 63 64 65 def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ())","title":"scroll_to_min()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_horizontal","text":"Set slider orientation to horizontal. Source code in prettyqt/widgets/abstractslider.py 55 56 57 def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( QtCore . Qt . Horizontal )","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_vertical","text":"Set slider orientation to vertical. Source code in prettyqt/widgets/abstractslider.py 59 60 61 def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( QtCore . Qt . Vertical )","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox","text":"","title":"abstractspinbox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox","text":"","title":"AbstractSpinBox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_button_symbols","text":"Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: Type Description str button symbol type Source code in prettyqt/widgets/abstractspinbox.py 47 48 49 50 51 52 53 54 55 def get_button_symbols ( self ) -> str : \"\"\"Return button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Returns: button symbol type \"\"\" return SYMBOLS . inv [ self . buttonSymbols ()]","title":"get_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_correction_mode","text":"Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: Type Description str correction mode Source code in prettyqt/widgets/abstractspinbox.py 87 88 89 90 91 92 93 94 95 def get_correction_mode ( self ) -> str : \"\"\"Return correction mode. possible values are \"to_previous\", \"to_nearest\" Returns: correction mode \"\"\" return CORRECTION_MODES . inv [ self . correctionMode ()]","title":"get_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_step_type","text":"Return step type. possible values are \"default\", \"adaptive\" Returns: Type Description str step type Source code in prettyqt/widgets/abstractspinbox.py 112 113 114 115 116 117 118 119 120 def get_step_type ( self ) -> str : \"\"\"Return step type. possible values are \"default\", \"adaptive\" Returns: step type \"\"\" return STEP_TYPES . inv [ self . stepType ()]","title":"get_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_button_symbols","text":"Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Parameters: Name Type Description Default mode str button symbol type to use required Exceptions: Type Description InvalidParamError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def set_button_symbols ( self , mode : str ): \"\"\"Set button symbol type. possible values are \"none\", \"up_down\", \"plus_minus\" Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ])","title":"set_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_correction_mode","text":"Set correction mode. possible values are \"to_previous\", \"to_nearest\" Parameters: Name Type Description Default mode str correction mode to use required Exceptions: Type Description InvalidParamError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def set_correction_mode ( self , mode : str ): \"\"\"Set correction mode. possible values are \"to_previous\", \"to_nearest\" Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ])","title":"set_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_step_type","text":"Set step type. possible values are \"default\", \"adaptive\" Parameters: Name Type Description Default mode str step type to use required Exceptions: Type Description InvalidParamError invalid step type Source code in prettyqt/widgets/abstractspinbox.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def set_step_type ( self , mode : str ): \"\"\"Set step type. possible values are \"default\", \"adaptive\" Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ])","title":"set_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.action","text":"","title":"action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action","text":"","title":"Action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_menu_role","text":"Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: Type Description str menu role Source code in prettyqt/widgets/action.py 207 208 209 210 211 212 213 214 215 216 def get_menu_role ( self ) -> str : \"\"\"Return menu role. Possible values: \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Returns: menu role \"\"\" return ROLES . inv [ self . menuRole ()]","title":"get_menu_role()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_priority","text":"Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: Type Description str priority Source code in prettyqt/widgets/action.py 156 157 158 159 160 161 162 163 164 def get_priority ( self ) -> str : \"\"\"Return current priority. Possible values: \"low\", \"normal\", \"high\" Returns: priority \"\"\" return PRIORITIES . inv [ self . priority ()]","title":"get_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_shortcut_context","text":"Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: Type Description str shortcut context Source code in prettyqt/widgets/action.py 181 182 183 184 185 186 187 188 189 def get_shortcut_context ( self ) -> str : \"\"\"Return shortcut context. Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: shortcut context \"\"\" return CONTEXTS . inv [ self . shortcutContext ()]","title":"get_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/action.py 119 120 121 122 123 124 125 126 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_menu_role","text":"Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Parameters: Name Type Description Default role str menu role required Exceptions: Type Description InvalidParamError menu role does not exist Source code in prettyqt/widgets/action.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def set_menu_role ( self , role : str ): \"\"\"Set menu role. Allowed values are \"none\", \"text_heuristic\", \"application_specific\", \"about_qt\", \"about\", \"preferences\", \"quit\" Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ])","title":"set_menu_role()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_priority","text":"Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Parameters: Name Type Description Default priority str priority for the action required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/widgets/action.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def set_priority ( self , priority : str ): \"\"\"Set priority of the action. Allowed values are \"low\", \"normal\", \"high\" Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ])","title":"set_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_shortcut_context","text":"Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Parameters: Name Type Description Default context str shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/action.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def set_shortcut_context ( self , context : str ): \"\"\"Set shortcut context. Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in CONTEXTS : raise InvalidParamError ( context , CONTEXTS ) self . setShortcutContext ( CONTEXTS [ context ])","title":"set_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup","text":"","title":"actiongroup"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup","text":"","title":"ActionGroup"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.get_exclusion_policy","text":"Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: Type Description str exclusion policy Source code in prettyqt/widgets/actiongroup.py 51 52 53 54 55 56 57 58 59 def get_exclusion_policy ( self ) -> str : \"\"\"Return current exclusion policy. Possible values: \"none\", \"exclusive\", \"exclusive_optional\" Returns: exclusion policy \"\"\" return POLICIES . inv [ self . exclusionPolicy ()]","title":"get_exclusion_policy()"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.set_exclusion_policy","text":"Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Parameters: Name Type Description Default policy Optional[str] exclusion policy to use required Exceptions: Type Description InvalidParamError exclusion policy does not exist Source code in prettyqt/widgets/actiongroup.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def set_exclusion_policy ( self , policy : Optional [ str ]): \"\"\"Set exclusion policy to use. Allowed values are \"none\", \"exclusive\", \"exclusive_optional\" Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ])","title":"set_exclusion_policy()"},{"location":"api/widgets.html#prettyqt.widgets.application","text":"","title":"application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application","text":"","title":"Application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.copy_to_clipboard","text":"Sets clipboard to supplied text. Source code in prettyqt/widgets/application.py 74 75 76 77 78 79 @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Clipboard ) cb . setText ( text , mode = cb . Clipboard )","title":"copy_to_clipboard()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.set_icon","text":"Set the default window icon. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/application.py 20 21 22 23 24 25 26 27 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget","text":"","title":"calendarwidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget","text":"","title":"CalendarWidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.get_selection_mode","text":"Return current selection mode. Possible values: \"single\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/calendarwidget.py 63 64 65 66 67 68 69 70 71 def get_selection_mode ( self ) -> str : \"\"\"Return current selection mode. Possible values: \"single\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.set_selection_mode","text":"Set selection mode for given calendar widget. Allowed values are \"single\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/calendarwidget.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"Set selection mode for given calendar widget. Allowed values are \"single\" or \"none\" Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise InvalidParamError ( mode , SELECTION_MODES ) self . setSelectionMode ( SELECTION_MODES [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox","text":"","title":"checkbox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox","text":"","title":"CheckBox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.get_checkstate","text":"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description bool checkstate Source code in prettyqt/widgets/checkbox.py 80 81 82 83 84 85 86 87 88 def get_checkstate ( self ) -> bool : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.set_checkstate","text":"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/checkbox.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( STATES [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.combobox","text":"","title":"combobox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox","text":"","title":"ComboBox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_insert_policy","text":"Return insert policy. possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: Type Description str insert policy Source code in prettyqt/widgets/combobox.py 130 131 132 133 134 135 136 137 138 139 def get_insert_policy ( self ) -> str : \"\"\"Return insert policy. possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: insert policy \"\"\" return INSERT_POLICIES . inv [ self . insertPolicy ()]","title":"get_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_size_adjust_policy","text":"Return size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/combobox.py 157 158 159 160 161 162 163 164 165 def get_size_adjust_policy ( self ) -> str : \"\"\"Return size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_insert_policy","text":"Set insert policy. valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Parameters: Name Type Description Default policy str insert policy to use required Exceptions: Type Description InvalidParamError invalid insert policy Source code in prettyqt/widgets/combobox.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def set_insert_policy ( self , policy : str ): \"\"\"Set insert policy. valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICIES : raise InvalidParamError ( policy , INSERT_POLICIES ) policy = INSERT_POLICIES . get ( policy ) self . setInsertPolicy ( policy )","title":"set_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_size_adjust_policy","text":"Set size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/combobox.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def set_size_adjust_policy ( self , policy : str ): \"\"\"Set size adjust policy. possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise InvalidParamError ( policy , SIZE_POLICIES ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy )","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.completer","text":"","title":"completer"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer","text":"","title":"Completer"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_completion_mode","text":"Return current completion mode. Possible values: \"popup\", \"inline\", \"unfiltered_popup\" Returns: Type Description str completion mode Source code in prettyqt/widgets/completer.py 79 80 81 82 83 84 85 86 87 def get_completion_mode ( self ) -> str : \"\"\"Return current completion mode. Possible values: \"popup\", \"inline\", \"unfiltered_popup\" Returns: completion mode \"\"\" return COMPLETION_MODES . inv [ self . completionMode ()]","title":"get_completion_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_filter_mode","text":"Return current filter mode. Possible values: \"starts_with\", \"contains\", \"ends_with\" Returns: Type Description str filter mode Source code in prettyqt/widgets/completer.py 104 105 106 107 108 109 110 111 112 def get_filter_mode ( self ) -> str : \"\"\"Return current filter mode. Possible values: \"starts_with\", \"contains\", \"ends_with\" Returns: filter mode \"\"\" return FILTER_MODES . inv [ self . filterMode ()]","title":"get_filter_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_sort_mode","text":"Return current sort mode. Possible values: \"unsorted\", \"case_sensitive\", \"case_insensitive\" Returns: Type Description str sort mode Source code in prettyqt/widgets/completer.py 54 55 56 57 58 59 60 61 62 def get_sort_mode ( self ) -> str : \"\"\"Return current sort mode. Possible values: \"unsorted\", \"case_sensitive\", \"case_insensitive\" Returns: sort mode \"\"\" return SORT_MODES . inv [ self . modelSorting ()]","title":"get_sort_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_completion_mode","text":"Set completion mode to use. Allowed values are \"popup\", \"inline\", \"unfiltered_popup\" Parameters: Name Type Description Default mode str completion mode to use required Exceptions: Type Description InvalidParamError completion mode does not exist Source code in prettyqt/widgets/completer.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def set_completion_mode ( self , mode : str ): \"\"\"Set completion mode to use. Allowed values are \"popup\", \"inline\", \"unfiltered_popup\" Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODES : raise InvalidParamError ( mode , COMPLETION_MODES ) self . setCompletionMode ( COMPLETION_MODES [ mode ])","title":"set_completion_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_filter_mode","text":"Set filter mode to use. Allowed values are \"starts_with\", \"contains\", \"ends_with\" Parameters: Name Type Description Default mode str filter mode to use required Exceptions: Type Description InvalidParamError filter mode does not exist Source code in prettyqt/widgets/completer.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def set_filter_mode ( self , mode : str ): \"\"\"Set filter mode to use. Allowed values are \"starts_with\", \"contains\", \"ends_with\" Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in FILTER_MODES : raise InvalidParamError ( mode , FILTER_MODES ) self . setFilterMode ( FILTER_MODES [ mode ])","title":"set_filter_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_sort_mode","text":"Set sort mode to use. Allowed values are \"unsorted\", \"case_sensitive\", \"case_insensitive\" Parameters: Name Type Description Default mode Optional[str] sort mode to use required Exceptions: Type Description InvalidParamError sort mode does not exist Source code in prettyqt/widgets/completer.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def set_sort_mode ( self , mode : Optional [ str ]): \"\"\"Set sort mode to use. Allowed values are \"unsorted\", \"case_sensitive\", \"case_insensitive\" Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODES : raise InvalidParamError ( mode , SORT_MODES ) self . setModelSorting ( SORT_MODES [ mode ])","title":"set_sort_mode()"},{"location":"api/widgets.html#prettyqt.widgets.dialog","text":"","title":"dialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.BaseDialog","text":"","title":"BaseDialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.BaseDialog.keyPressEvent","text":"keyPressEvent(self, QKeyEvent) Source code in prettyqt/widgets/dialog.py 38 39 40 41 42 43 44 def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e )","title":"keyPressEvent()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox","text":"","title":"dialogbuttonbox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox","text":"","title":"DialogButtonBox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_button","text":"Add a button. Parameters: Name Type Description Default button Union[PyQt5.QtWidgets.QPushButton, str] button to add required role str role of the button 'accept' callback Optional[Callable] function to call when button gets clicked None Returns: Type Description PushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def add_button ( self , button : Union [ QtWidgets . QPushButton , str ], role : str = \"accept\" , callback : Optional [ Callable ] = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_default_button","text":"Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required callback Optional[Callable] function to call when button gets clicked None Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def add_default_button ( self , button : str , callback : Optional [ Callable ] = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn","title":"add_default_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.create","text":"create(self, window: sip.voidptr = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) Source code in prettyqt/widgets/dialogbuttonbox.py 71 72 73 74 75 76 @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) return box","title":"create()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/dialogbuttonbox.py 102 103 104 105 106 107 108 109 110 def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.set_orientation","text":"Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the button box required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the button box. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.dockwidget","text":"","title":"dockwidget"},{"location":"api/widgets.html#prettyqt.widgets.dockwidget.DockWidget","text":"Customized DockWidget class. Contains a custom TitleBar with maximise button","title":"DockWidget"},{"location":"api/widgets.html#prettyqt.widgets.filedialog","text":"","title":"filedialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog","text":"Simple dialog used to display some widget.","title":"FileDialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.directory","text":"Return current directory. returns current directory level as a Pathlib object Returns: Type Description Path Pathlib object Source code in prettyqt/widgets/filedialog.py 226 227 228 229 230 231 232 233 234 def directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( super () . directory ())","title":"directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_accept_mode","text":"Return accept mode. possible values are \"save\", \"open\" Returns: Type Description str accept mode Source code in prettyqt/widgets/filedialog.py 102 103 104 105 106 107 108 109 110 def get_accept_mode ( self ) -> str : \"\"\"Return accept mode. possible values are \"save\", \"open\" Returns: accept mode \"\"\" return ACCEPT_MODES . inv [ self . acceptMode ()]","title":"get_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_file_mode","text":"Return file mode. possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: Type Description str file mode Source code in prettyqt/widgets/filedialog.py 161 162 163 164 165 166 167 168 169 def get_file_mode ( self ) -> str : \"\"\"Return file mode. possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: file mode \"\"\" return MODES . inv [ self . fileMode ()]","title":"get_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_label_text","text":"Return label text. possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py 151 152 153 154 155 156 157 158 159 def get_label_text ( self , label ) -> str : \"\"\"Return label text. possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: label text \"\"\" return self . labelText ( LABELS . inv [ label ])","title":"get_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_view_mode","text":"Return view mode. possible values are \"detail\", \"list\" Returns: Type Description str view mode Source code in prettyqt/widgets/filedialog.py 127 128 129 130 131 132 133 134 135 def get_view_mode ( self ) -> str : \"\"\"Return view mode. possible values are \"detail\", \"list\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_accept_mode","text":"Set accept mode. possible values are \"save\", \"open\" Parameters: Name Type Description Default mode str accept mode to use required Exceptions: Type Description InvalidParamError invalid accept mode Source code in prettyqt/widgets/filedialog.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def set_accept_mode ( self , mode : str ): \"\"\"Set accept mode. possible values are \"save\", \"open\" Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODES : raise InvalidParamError ( mode , ACCEPT_MODES ) self . setAcceptMode ( ACCEPT_MODES [ mode ])","title":"set_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_directory","text":"Set start directory. Source code in prettyqt/widgets/filedialog.py 236 237 238 239 240 def set_directory ( self , path : Union [ None , str , pathlib . Path ]): \"\"\"Set start directory.\"\"\" if isinstance ( path , pathlib . Path ): path = str ( path ) self . setDirectory ( path )","title":"set_directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_extension_filter","text":"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict Dict[str, List[str]] filter dictionary required Source code in prettyqt/widgets/filedialog.py 212 213 214 215 216 217 218 219 220 221 222 223 224 def set_extension_filter ( self , extension_dict : Dict [ str , List [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str )","title":"set_extension_filter()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_file_mode","text":"Set the file mode of the dialog. allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Parameters: Name Type Description Default mode str mode to use required Source code in prettyqt/widgets/filedialog.py 171 172 173 174 175 176 177 178 179 def set_file_mode ( self , mode : str ): \"\"\"Set the file mode of the dialog. allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Args: mode: mode to use \"\"\" self . setFileMode ( MODES [ mode ])","title":"set_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_label_text","text":"Set the label text for button label. possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Parameters: Name Type Description Default label str button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py 137 138 139 140 141 142 143 144 145 146 147 148 149 def set_label_text ( self , label : str , text : str ): \"\"\"Set the label text for button label. possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Args: label: button to set text for text: text to use \"\"\" if label not in LABELS : raise InvalidParamError ( label , LABELS ) self . setLabelText ( LABELS [ label ], text )","title":"set_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_view_mode","text":"Set view mode. possible values are \"detail\", \"list\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/filedialog.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def set_view_mode ( self , mode : str ): \"\"\"Set view mode. possible values are \"detail\", \"list\" Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel","text":"","title":"filesystemmodel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel","text":"Class to populate a filesystem treeview.","title":"FileSystemModel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/widgets/filesystemmodel.py 51 52 53 54 55 def data ( self , index , role = QtCore . Qt . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role )","title":"data()"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox","text":"","title":"fontcombobox"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox","text":"","title":"FontComboBox"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.get_font_filters","text":"Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: Type Description List[str] font filter list Source code in prettyqt/widgets/fontcombobox.py 61 62 63 64 65 66 67 68 69 70 def get_font_filters ( self ) -> List [ str ]: \"\"\"Return list of font filters. possible included values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()]","title":"get_font_filters()"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.set_font_filters","text":"Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Parameters: Name Type Description Default filters str font filters to use () Exceptions: Type Description InvalidParamError invalid font filters Source code in prettyqt/widgets/fontcombobox.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def set_font_filters ( self , * filters : str ): \"\"\"Set font filters. valid values are \"all\", \"scalable\", \"non_scalable\", \"monospaced\", \"proportional\" Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags )","title":"set_font_filters()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout","text":"","title":"formlayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout","text":"","title":"FormLayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.__len__","text":"Needed for PySide2. Source code in prettyqt/widgets/formlayout.py 39 40 41 def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/widgets.html#prettyqt.widgets.frame","text":"","title":"frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame","text":"","title":"Frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.get_frame_style","text":"Return current frame style. Possible values: \"plain\", \"raised\", \"sunken\" Returns: Type Description str frame style Source code in prettyqt/widgets/frame.py 44 45 46 47 48 49 50 51 52 def get_frame_style ( self ) -> str : \"\"\"Return current frame style. Possible values: \"plain\", \"raised\", \"sunken\" Returns: frame style \"\"\" return SHADOWS . inv [ self . frameStyle ()]","title":"get_frame_style()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.set_frame_style","text":"Set frame style. Allowed values are \"plain\", \"raised\", \"sunken\" Parameters: Name Type Description Default style str frame style to use required Exceptions: Type Description InvalidParamError style does not exist Source code in prettyqt/widgets/frame.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def set_frame_style ( self , style : str ): \"\"\"Set frame style. Allowed values are \"plain\", \"raised\", \"sunken\" Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style not in SHADOWS : raise InvalidParamError ( style , SHADOWS ) self . setFrameStyle ( SHADOWS [ style ])","title":"set_frame_style()"},{"location":"api/widgets.html#prettyqt.widgets.groupbox","text":"","title":"groupbox"},{"location":"api/widgets.html#prettyqt.widgets.groupbox.GroupBox","text":"GroupBox widget. A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets.","title":"GroupBox"},{"location":"api/widgets.html#prettyqt.widgets.headerview","text":"","title":"headerview"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView","text":"","title":"HeaderView"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView.contextMenuEvent","text":"Context menu for our files tree. Source code in prettyqt/widgets/headerview.py 71 72 73 74 75 76 77 78 79 80 81 def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) for i , header_label in enumerate ( self . section_labels ()[ 1 :], start = 1 ): act = menu . addAction ( header_label ) act . setCheckable ( True ) val = not self . isSectionHidden ( i ) act . setChecked ( val ) fn = functools . partial ( self . set_section_hidden , i = i , hide = val ) act . triggered . connect ( fn ) menu . exec_ ( self . mapToGlobal ( event . pos ()))","title":"contextMenuEvent()"},{"location":"api/widgets.html#prettyqt.widgets.label","text":"","title":"label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label","text":"","title":"Label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_format","text":"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/label.py 123 124 125 126 127 128 129 130 131 def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_interaction","text":"Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: Type Description List[str] list of text interaction modes Source code in prettyqt/widgets/label.py 151 152 153 154 155 156 157 158 159 def get_text_interaction ( self ) -> List [ str ]: \"\"\"Return current text interaction mode. Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()]","title":"get_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_format","text":"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/label.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise InvalidParamError ( text_format , TEXT_FORMATS ) self . setTextFormat ( TEXT_FORMATS [ text_format ]) return self","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_interaction","text":"Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Parameters: Name Type Description Default types str text interaction mode to use () Exceptions: Type Description InvalidParamError text interaction mode does not exist Source code in prettyqt/widgets/label.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def set_text_interaction ( self , * types : str ): \"\"\"Set the text interaction mode. Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self","title":"set_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_weight","text":"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/widgets/label.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def set_weight ( self , weight : str ): \"\"\"Set the font weight. Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHTS : raise InvalidParamError ( weight , WEIGHTS ) font = self . font () font . setWeight ( WEIGHTS [ weight ]) self . setFont ( font ) return self","title":"set_weight()"},{"location":"api/widgets.html#prettyqt.widgets.layout","text":"","title":"layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout","text":"","title":"Layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.get_size_mode","text":"Return current size mode. Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: Type Description str size mode Source code in prettyqt/widgets/layout.py 87 88 89 90 91 92 93 94 95 def get_size_mode ( self ) -> str : \"\"\"Return current size mode. Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: size mode \"\"\" return MODES . inv [ self . sizeConstraint ()]","title":"get_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_alignment","text":"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required item set alignment for specific child only None Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layout.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def set_alignment ( self , alignment : str , item = None ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) if item is not None : return self . setAlignment ( item , ALIGNMENTS [ alignment ]) else : return self . setAlignment ( ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_size_mode","text":"Set the size mode of the layout. Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Parameters: Name Type Description Default mode str size mode for the layout required Exceptions: Type Description InvalidParamError size mode does not exist Source code in prettyqt/widgets/layout.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def set_size_mode ( self , mode : str ): \"\"\"Set the size mode of the layout. Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setSizeConstraint ( MODES [ mode ])","title":"set_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit","text":"","title":"lineedit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit","text":"","title":"LineEdit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.font","text":"font(self) -> QFont Source code in prettyqt/widgets/lineedit.py 71 72 def font ( self ) -> gui . Font : return gui . Font ( super () . font ())","title":"font()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_echo_mode","text":"Return echo mode. possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: Type Description str echo mode Source code in prettyqt/widgets/lineedit.py 125 126 127 128 129 130 131 132 133 def get_echo_mode ( self ) -> str : \"\"\"Return echo mode. possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: echo mode \"\"\" return ECHO_MODES . inv [ self . echoMode ()]","title":"get_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_echo_mode","text":"Set echo mode. Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Parameters: Name Type Description Default mode str echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/lineedit.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def set_echo_mode ( self , mode : str ): \"\"\"Set echo mode. Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODES : raise InvalidParamError ( mode , ECHO_MODES ) self . setEchoMode ( ECHO_MODES [ mode ])","title":"set_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_read_only","text":"Set text to read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py 80 81 82 83 84 85 86 def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.listview","text":"","title":"listview"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView","text":"","title":"ListView"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_view_mode","text":"Return view mode. possible values are \"list\", \"icon\" Returns: Type Description str view mode Source code in prettyqt/widgets/listview.py 31 32 33 34 35 36 37 38 39 def get_view_mode ( self ) -> str : \"\"\"Return view mode. possible values are \"list\", \"icon\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_view_mode","text":"Set view mode. possible values are \"list\", \"icon\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/listview.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def set_view_mode ( self , mode : str ): \"\"\"Set view mode. possible values are \"list\", \"icon\" Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem","text":"","title":"listwidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem","text":"","title":"ListWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.get_checkstate","text":"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/listwidgetitem.py 61 62 63 64 65 66 67 68 69 def get_checkstate ( self ) -> str : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( STATES [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/listwidgetitem.py 37 38 39 40 41 42 43 44 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow","text":"","title":"mainwindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow","text":"Class for our mainWindow. Includes all docks, a centralwidget and a toolbar","title":"MainWindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar","text":"Adds a toolbar to the mainmenu at specified area. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default toolbar QToolBar toolbar to use required position str position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : str = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBar ( TOOLBAR_AREAS [ position ], toolbar )","title":"add_toolbar()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar_break","text":"Adds a toolbar break to the given area behind the last item. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default position str position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def add_toolbar_break ( self , position : str = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise InvalidParamError ( position , TOOLBAR_AREAS ) self . addToolBarBreak ( TOOLBAR_AREAS [ position ])","title":"add_toolbar_break()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.createPopupMenu","text":"createPopupMenu(self) -> QMenu Source code in prettyqt/widgets/mainwindow.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add_action ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add_action ( action ) return menu","title":"createPopupMenu()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.save_window_state","text":"Save current window state as QSetting. Parameters: Name Type Description Default recursive bool Description False Source code in prettyqt/widgets/mainwindow.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def save_window_state ( self , recursive = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { name } ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state ()","title":"save_window_state()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.toggle_fullscreen","text":"Toggle between fullscreen and regular size. Source code in prettyqt/widgets/mainwindow.py 191 192 193 194 195 196 def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen ()","title":"toggle_fullscreen()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea","text":"","title":"mdiarea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea","text":"","title":"MdiArea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_tab_position","text":"Return current tab position. Possible values: \"north\", \"south\", \"west\", \"east\" Returns: Type Description str tab position Source code in prettyqt/widgets/mdiarea.py 108 109 110 111 112 113 114 115 116 def get_tab_position ( self ) -> str : \"\"\"Return current tab position. Possible values: \"north\", \"south\", \"west\", \"east\" Returns: tab position \"\"\" return TAB_POSITIONS . inv [ self . tabPosition ()]","title":"get_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_view_mode","text":"Return current view mode. Possible values: \"default\", \"tabbed\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py 58 59 60 61 62 63 64 65 66 def get_view_mode ( self ) -> str : \"\"\"Return current view mode. Possible values: \"default\", \"tabbed\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_window_order","text":"Return current window order. Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py 83 84 85 86 87 88 89 90 91 def get_window_order ( self ) -> str : \"\"\"Return current window order. Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: view mode \"\"\" return WINDOW_ORDERS . inv [ self . activationOrder ()]","title":"get_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_tab_position","text":"Set tab position for the MDI area. Valid values are \"north\", \"south\", \"west\", \"east\" Parameters: Name Type Description Default position str tabs position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/mdiarea.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def set_tab_position ( self , position : str ): \"\"\"Set tab position for the MDI area. Valid values are \"north\", \"south\", \"west\", \"east\" Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITIONS : raise InvalidParamError ( position , TAB_POSITIONS ) self . setTabPosition ( TAB_POSITIONS [ position ])","title":"set_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_view_mode","text":"Set view mode for the MDI area. Valid values are \"default\", \"tabbed\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description InvalidParamError view mode does not exist Source code in prettyqt/widgets/mdiarea.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def set_view_mode ( self , mode : str ): \"\"\"Set view mode for the MDI area. Valid values are \"default\", \"tabbed\" Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODES : raise InvalidParamError ( mode , VIEW_MODES ) self . setViewMode ( VIEW_MODES [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_window_order","text":"Set the window order behaviour for the MDI area. Valid values are \"creation\", \"stacking\", \"activation_history\" Parameters: Name Type Description Default mode str window order behaviour to use required Exceptions: Type Description InvalidParamError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def set_window_order ( self , mode : str ): \"\"\"Set the window order behaviour for the MDI area. Valid values are \"creation\", \"stacking\", \"activation_history\" Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDERS : raise InvalidParamError ( mode , WINDOW_ORDERS ) self . setActivationOrder ( WINDOW_ORDERS [ mode ])","title":"set_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.menu","text":"","title":"menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu","text":"","title":"Menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_action","text":"Add an action to the menu. Parameters: Name Type Description Default label Union[str, prettyqt.widgets.action.Action] Label for button required callback Callable gets called when action is triggered None icon Optional[Any] icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut Optional[str] Shortcut for action None status_tip Optional[str] Status tip to be shown in status bar None Returns: Type Description Action Action added to menu Source code in prettyqt/widgets/menu.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def add_action ( self , label : Union [ str , widgets . Action ], callback : Callable = None , icon : Optional [ Any ] = None , checkable : bool = False , checked : bool = False , shortcut : Optional [ str ] = None , status_tip : Optional [ str ] = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action","title":"add_action()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_separator","text":"Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None Returns: Type Description WidgetAction Separator action Source code in prettyqt/widgets/menu.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def add_separator ( self , text : Optional [ str ] = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.set_icon","text":"Set the icon for the menu. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/menu.py 46 47 48 49 50 51 52 53 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox","text":"","title":"messagebox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox","text":"","title":"MessageBox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.add_button","text":"Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/messagebox.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def add_button ( self , button : str ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ])","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.get_text_format","text":"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/messagebox.py 152 153 154 155 156 157 158 159 160 def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_icon","text":"Set the window icon. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/messagebox.py 97 98 99 100 101 102 def set_icon ( self , icon : gui . icon . IconType ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) return None icon = gui . icon . get_icon ( icon ) self . setIconPixmap ( icon . get_pixmap ( size = 64 ))","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_text_format","text":"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/messagebox.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise InvalidParamError ( text_format , TEXT_FORMATS ) self . setTextFormat ( TEXT_FORMATS [ text_format ])","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit","text":"","title":"plaintextedit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit","text":"","title":"PlainTextEdit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_line_wrap_mode","text":"Set line wrap mode. Allowed values are \"none\" and \"widget width\" Parameters: Name Type Description Default mode str line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def set_line_wrap_mode ( self , mode : str ): \"\"\"Set line wrap mode. Allowed values are \"none\" and \"widget width\" Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODES : raise InvalidParamError ( mode , LINE_WRAP_MODES ) self . setLineWrapMode ( LINE_WRAP_MODES [ mode ])","title":"set_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_read_only","text":"Make the PlainTextEdit read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py 117 118 119 120 121 122 123 def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_wrap_mode","text":"Set word wrap mode. Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Parameters: Name Type Description Default mode str word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def set_wrap_mode ( self , mode : str ): \"\"\"Set word wrap mode. Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in WRAP_MODES : raise InvalidParamError ( mode , WRAP_MODES ) self . setWordWrapMode ( WRAP_MODES [ mode ])","title":"set_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.wheelEvent","text":"Handle wheel event for zooming. Source code in prettyqt/widgets/plaintextedit.py 65 66 67 68 69 70 71 72 def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event )","title":"wheelEvent()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar","text":"","title":"progressbar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar","text":"Progress dialog. wrapper for QtWidgets.QProgressBar","title":"ProgressBar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_alignment","text":"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description str alignment Source code in prettyqt/widgets/progressbar.py 53 54 55 56 57 58 59 60 61 def get_alignment ( self ) -> str : \"\"\"Return current alignment. Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" return ALIGNMENTS . inv [ self . alignment ()]","title":"get_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_text_direction","text":"Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Type Description str Text direction Source code in prettyqt/widgets/progressbar.py 78 79 80 81 82 83 84 85 86 def get_text_direction ( self ) -> str : \"\"\"Return current text direction. Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inv [ self . textDirection ()]","title":"get_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_alignment","text":"Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/progressbar.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def set_alignment ( self , alignment : str ): \"\"\"Set the alignment of the layout. Allowed values are \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise InvalidParamError ( alignment , ALIGNMENTS ) self . setAlignment ( ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_text_direction","text":"Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Parameters: Name Type Description Default text_direction str text direction for the layout required Exceptions: Type Description InvalidParamError text direction does not exist Source code in prettyqt/widgets/progressbar.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def set_text_direction ( self , text_direction : str ): \"\"\"Set the text direction of the layout. Allowed values are \"top_to_bottom\", \"bottom_to_top\" Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ])","title":"set_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.progressdialog","text":"","title":"progressdialog"},{"location":"api/widgets.html#prettyqt.widgets.progressdialog.ProgressDialog","text":"Progress dialog. Wrapper for QtWidgets.QProgressDialog","title":"ProgressDialog"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy","text":"","title":"sizepolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy","text":"","title":"SizePolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.__pretty__","text":"Provide a human readable representations of objects. Used by devtools (https://python-devtools.helpmanual.io/). Source code in prettyqt/widgets/sizepolicy.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def __pretty__ ( self , fmt : Callable [[ Any ], Any ], ** kwargs : Any ) -> Generator [ Any , None , None ]: \"\"\"Provide a human readable representations of objects. Used by devtools (https://python-devtools.helpmanual.io/). \"\"\" yield self . __class__ . __name__ + \"(\" yield 1 for k , v in self . __getstate__ () . items (): yield f \" { k } = { v !r} \" yield 0 yield - 1 yield \")\"","title":"__pretty__()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_control_type","text":"Return control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: Type Description str control type Source code in prettyqt/widgets/sizepolicy.py 124 125 126 127 128 129 130 131 132 133 134 def get_control_type ( self ) -> str : \"\"\"Return control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: control type \"\"\" return CONTROL_TYPES . inv [ self . controlType ()]","title":"get_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_horizontal_policy","text":"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str horizontal size policy Source code in prettyqt/widgets/sizepolicy.py 80 81 82 83 84 85 86 87 88 89 def get_horizontal_policy ( self ) -> str : \"\"\"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: horizontal size policy \"\"\" return SIZE_POLICIES . inv [ self . horizontalPolicy ()]","title":"get_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_vertical_policy","text":"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str vertical size policy Source code in prettyqt/widgets/sizepolicy.py 102 103 104 105 106 107 108 109 110 111 def get_vertical_policy ( self ) -> str : \"\"\"Return size policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: vertical size policy \"\"\" return SIZE_POLICIES . inv [ self . verticalPolicy ()]","title":"get_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_control_type","text":"Set the control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Parameters: Name Type Description Default mode str control type to set required Source code in prettyqt/widgets/sizepolicy.py 136 137 138 139 140 141 142 143 144 145 146 def set_control_type ( self , mode : str ) -> None : \"\"\"Set the control type. possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Args: mode: control type to set \"\"\" self . setControlType ( CONTROL_TYPES [ mode ])","title":"set_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_horizontal_policy","text":"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py 91 92 93 94 95 96 97 98 99 100 def set_horizontal_policy ( self , mode : str ) -> None : \"\"\"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setHorizontalPolicy ( SIZE_POLICIES [ mode ])","title":"set_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_vertical_policy","text":"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py 113 114 115 116 117 118 119 120 121 122 def set_vertical_policy ( self , mode : str ) -> None : \"\"\"Set the horizontal policy. possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setVerticalPolicy ( SIZE_POLICIES [ mode ])","title":"set_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.slider","text":"","title":"slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider","text":"","title":"Slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.get_tick_position","text":"Return tick position. possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: Type Description str tick position Source code in prettyqt/widgets/slider.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def get_tick_position ( self ) -> str : \"\"\"Return tick position. possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: tick position \"\"\" val = TICK_POSITIONS . inv [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\" return val","title":"get_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.set_tick_position","text":"Set the tick position for the slider. allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Parameters: Name Type Description Default position str position for the ticks required Source code in prettyqt/widgets/slider.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def set_tick_position ( self , position : str ): \"\"\"Set the tick position for the slider. allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITIONS : raise InvalidParamError ( position , TICK_POSITIONS ) self . setTickPosition ( TICK_POSITIONS [ position ])","title":"set_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.splitter","text":"","title":"splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter","text":"","title":"Splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.get_orientation","text":"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/splitter.py 108 109 110 111 112 113 114 115 116 def get_orientation ( self ) -> str : \"\"\"Return current orientation. Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.set_orientation","text":"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitter.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def set_orientation ( self , orientation : str ): \"\"\"Set the orientation of the splitter. Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider","text":"","title":"styleoptionslider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider","text":"","title":"StyleOptionSlider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_horizontal","text":"Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py 29 30 31 32 33 34 35 def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == QtCore . Qt . Horizontal","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_vertical","text":"Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py 37 38 39 40 41 42 43 def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == QtCore . Qt . Vertical","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_horizontal","text":"Set slider orientation to horizontal. Source code in prettyqt/widgets/styleoptionslider.py 45 46 47 def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = QtCore . Qt . Horizontal","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_vertical","text":"Set slider orientation to vertical. Source code in prettyqt/widgets/styleoptionslider.py 49 50 51 def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = QtCore . Qt . Vertical","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon","text":"","title":"systemtrayicon"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon","text":"","title":"SystemTrayIcon"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon.set_icon","text":"Set the system tray icon. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/systemtrayicon.py 25 26 27 28 29 30 31 32 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar","text":"","title":"tabbar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar","text":"","title":"TabBar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_elide_mode","text":"Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: Type Description str elide mode Source code in prettyqt/widgets/tabbar.py 135 136 137 138 139 140 141 142 143 def get_elide_mode ( self ) -> str : \"\"\"Return elide mode. possible values are \"left\", \"right\", \"middle\", \"none\" Returns: elide mode \"\"\" return ELIDE_MODES . inv [ self . elideMode ()]","title":"get_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_remove_behaviour","text":"Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: Type Description str remove behaviour Source code in prettyqt/widgets/tabbar.py 110 111 112 113 114 115 116 117 118 def get_remove_behaviour ( self ) -> str : \"\"\"Return remove behaviour. possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOURS . inv [ self . selectionBehaviorOnRemove ()]","title":"get_remove_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.mouseDoubleClickEvent","text":"mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/widgets/tabbar.py 80 81 82 def mouseDoubleClickEvent ( self , event ): event . accept () self . on_detach . emit ( self . tabAt ( event . pos ()), self . mouse_cursor . pos ())","title":"mouseDoubleClickEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_elide_mode","text":"Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Parameters: Name Type Description Default mode str elide mode to use required Exceptions: Type Description InvalidParamError invalid elide mode Source code in prettyqt/widgets/tabbar.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def set_elide_mode ( self , mode : str ) -> None : \"\"\"Set elide mode. Valid values are \"left\", \"right\", \"middle\", \"none\" Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in ELIDE_MODES : raise InvalidParamError ( mode , ELIDE_MODES ) self . setElideMode ( ELIDE_MODES [ mode ])","title":"set_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_icon_size","text":"Set the icon size for the tabs. Parameters: Name Type Description Default size int height/width of the icons required Source code in prettyqt/widgets/tabbar.py 84 85 86 87 88 89 90 def set_icon_size ( self , size : int ) -> None : \"\"\"Set the icon size for the tabs. Args: size: height/width of the icons \"\"\" self . setIconSize ( QtCore . QSize ( size , size ))","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_remove_behaviour","text":"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Parameters: Name Type Description Default mode str new remove behaviour required Source code in prettyqt/widgets/tabbar.py 97 98 99 100 101 102 103 104 105 106 107 108 def set_remove_behaviour ( self , mode : str ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOURS : raise InvalidParamError ( mode , REMOVE_BEHAVIOURS ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOURS [ mode ])","title":"set_remove_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget","text":"","title":"tabwidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab","text":"Window containing a detached tab. When a tab is detached, the contents are placed into this QMainWindow. The tab can be re-attached by closing the dialog Attributes: Name Type Description on_close signal, emitted when window is closed (widget, title, icon)","title":"DetachedTab"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab.closeEvent","text":"closeEvent(self, QCloseEvent) Source code in prettyqt/widgets/tabwidget.py 264 265 def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . id , self . windowIcon ())","title":"closeEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget","text":"Widget for managing the tabs section.","title":"TabWidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.attach_tab","text":"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Parameters: Name Type Description Default widget Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] the content widget from the DetachedTab window required name str the name of the detached tab required icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] the window icon for the detached tab None insert_at Optional[int] insert the re-attached tab at the given index None Source code in prettyqt/widgets/tabwidget.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def attach_tab ( self , widget : Union [ QtWidgets . QWidget , QtWidgets . QLayout ], name : str , icon : gui . icon . IconType = None , insert_at : Optional [ int ] = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (gui.icon.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True )","title":"attach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.close_detached_tabs","text":"Close all tabs that are currently detached. Source code in prettyqt/widgets/tabwidget.py 216 217 218 219 220 def close_detached_tabs ( self ) -> None : \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close ()","title":"close_detached_tabs()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.detach_tab","text":"Detach tab by removing its contents and placing them in a DetachedTab window. Parameters: Name Type Description Default index int index location of the tab to be detached required point QPoint screen pos for creating the new DetachedTab window required Returns: Type Description None None: Description Source code in prettyqt/widgets/tabwidget.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 @core . Slot ( int , QtCore . QPoint ) def detach_tab ( self , index : int , point : QtCore . QPoint ) -> None : \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content name = self . tabText ( index ) icon = self . tabIcon ( index ) if icon . isNull (): icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab","title":"detach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_shape","text":"Return tab shape. possible values are \"roundes\", \"triangular\" Returns: Type Description str tab shape Source code in prettyqt/widgets/tabwidget.py 95 96 97 98 99 100 101 102 103 def get_tab_shape ( self ) -> str : \"\"\"Return tab shape. possible values are \"roundes\", \"triangular\" Returns: tab shape \"\"\" return TAB_SHAPES . inv [ self . tabShape ()]","title":"get_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.open_widget","text":"Create a tab containing delivered widget. Source code in prettyqt/widgets/tabwidget.py 229 230 231 232 @core . Slot ( object , str ) def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True )","title":"open_widget()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_shape","text":"Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Parameters: Name Type Description Default shape str tab shape to use required Exceptions: Type Description InvalidParamError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def set_tab_shape ( self , shape : str ) -> None : \"\"\"Set tab shape for the tabwidget. Valid values are \"rounded\" and \"triangular\" Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ])","title":"set_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar","text":"","title":"toolbar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar","text":"","title":"ToolBar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.add_separator","text":"Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None before QAction insert separator before specific action None Returns: Type Description QAction Separator action Source code in prettyqt/widgets/toolbar.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def add_separator ( self , text : Optional [ str ] = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label )","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.get_style","text":"Return current style. Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: Type Description str style Source code in prettyqt/widgets/toolbar.py 90 91 92 93 94 95 96 97 98 def get_style ( self ) -> str : \"\"\"Return current style. Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: style \"\"\" return STYLES . inv [ self . toolButtonStyle ()]","title":"get_style()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.is_area_allowed","text":"Check if toolbar is allowed at specified area. Valid values for area: \"left\", \"right\", \"top\", \"bottom\", \"all\" Parameters: Name Type Description Default area str area of the toolbar required Exceptions: Type Description InvalidParamError area does not exist Source code in prettyqt/widgets/toolbar.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def is_area_allowed ( self , area : str ): \"\"\"Check if toolbar is allowed at specified area. Valid values for area: \"left\", \"right\", \"top\", \"bottom\", \"all\" Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in TOOLBAR_AREAS : raise InvalidParamError ( area , TOOLBAR_AREAS ) return self . isAreaAllowed ( TOOLBAR_AREAS [ area ])","title":"is_area_allowed()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton","text":"","title":"toolbutton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton","text":"","title":"ToolButton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_arrow_type","text":"Return arrow type. possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: Type Description str arrow type Source code in prettyqt/widgets/toolbutton.py 89 90 91 92 93 94 95 96 97 def get_arrow_type ( self ) -> str : \"\"\"Return arrow type. possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: arrow type \"\"\" return ARROW_TYPES . inv [ self . arrowType ()]","title":"get_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_popup_mode","text":"Return popup mode. possible values are \"delayed\", \"menu_button\", \"instant\" Returns: Type Description str popup mode Source code in prettyqt/widgets/toolbutton.py 64 65 66 67 68 69 70 71 72 def get_popup_mode ( self ) -> str : \"\"\"Return popup mode. possible values are \"delayed\", \"menu_button\", \"instant\" Returns: popup mode \"\"\" return POPUP_MODES . inv [ self . popupMode ()]","title":"get_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_arrow_type","text":"Set the arrow type of the toolbutton. valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Parameters: Name Type Description Default mode str arrow type to use required Exceptions: Type Description InvalidParamError invalid arrow type Source code in prettyqt/widgets/toolbutton.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def set_arrow_type ( self , mode : str ): \"\"\"Set the arrow type of the toolbutton. valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in ARROW_TYPES : raise InvalidParamError ( mode , ARROW_TYPES ) self . setArrowType ( ARROW_TYPES [ mode ])","title":"set_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_popup_mode","text":"Set the popup mode of the toolbutton. valid values are: \"delayed\", \"menu_button\", \"instant\" Parameters: Name Type Description Default mode str popup mode to use required Exceptions: Type Description InvalidParamError invalid popup mode Source code in prettyqt/widgets/toolbutton.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def set_popup_mode ( self , mode : str ): \"\"\"Set the popup mode of the toolbutton. valid values are: \"delayed\", \"menu_button\", \"instant\" Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODES : raise InvalidParamError ( mode , POPUP_MODES ) self . setPopupMode ( POPUP_MODES [ mode ])","title":"set_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem","text":"","title":"treewidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem","text":"","title":"TreeWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_checkstate","text":"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/treewidgetitem.py 62 63 64 65 66 67 68 69 70 def get_checkstate ( self ) -> str : \"\"\"Return checkstate. possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ( 0 )]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def set_checkstate ( self , state : str ): \"\"\"Set checkstate of the checkbox. valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in STATES : raise InvalidParamError ( state , STATES ) self . setCheckState ( 0 , STATES [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/treewidgetitem.py 38 39 40 41 42 43 44 45 def set_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setIcon ( 0 , icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.undoview","text":"","title":"undoview"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView","text":"","title":"UndoView"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView.set_clean_icon","text":"Set the icon for the clean button. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/undoview.py 17 18 19 20 21 22 23 24 def set_clean_icon ( self , icon : gui . icon . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon ) self . setCleanIcon ( icon )","title":"set_clean_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget","text":"","title":"widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget","text":"","title":"Widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.__pretty__","text":"Provide a human readable representations of objects. Used by devtools (https://python-devtools.helpmanual.io/). Source code in prettyqt/widgets/widget.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def __pretty__ ( self , fmt : Callable [[ Any ], Any ], ** kwargs : Any ) -> Generator [ Any , None , None ]: \"\"\"Provide a human readable representations of objects. Used by devtools (https://python-devtools.helpmanual.io/). \"\"\" yield self . __class__ . __name__ + \"(\" yield 1 for k , v in self . serialize () . items (): yield f \" { k } =\" if hasattr ( v , \"__pretty__\" ): yield from v . __pretty__ ( fmt , ** kwargs ) else : yield f \" { v !r} \" yield 0 yield - 1 yield \")\"","title":"__pretty__()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_contextmenu_policy","text":"Return current contextmenu policy. Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Returns: Type Description str contextmenu policy Source code in prettyqt/widgets/widget.py 348 349 350 351 352 353 354 355 356 def get_contextmenu_policy ( self ) -> str : \"\"\"Return current contextmenu policy. Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Returns: contextmenu policy \"\"\" return CONTEXT_POLICIES . inv [ self . contextMenuPolicy ()]","title":"get_contextmenu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_modality","text":"Get the current modality modes as a string. Possible values: \"none\", \"window\", \"application\" Returns: Type Description str modality mode str Source code in prettyqt/widgets/widget.py 267 268 269 270 271 272 273 274 275 276 def get_modality ( self ) -> str : \"\"\"Get the current modality modes as a string. Possible values: \"none\", \"window\", \"application\" Returns: modality mode str \"\"\" return MODALITIES . inv [ self . windowModality ()]","title":"get_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.resize","text":"resize(self, QSize) resize(self, int, int) Source code in prettyqt/widgets/widget.py 134 135 136 137 138 def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size )","title":"resize()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_contextmenu_policy","text":"Set contextmenu policy for given item view. Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Parameters: Name Type Description Default policy str contextmenu policy to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def set_contextmenu_policy ( self , policy : str ) -> None : \"\"\"Set contextmenu policy for given item view. Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\" Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CONTEXT_POLICIES : raise InvalidParamError ( policy , CONTEXT_POLICIES ) self . setContextMenuPolicy ( CONTEXT_POLICIES [ policy ])","title":"set_contextmenu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_icon","text":"Set the window icon. Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/widget.py 140 141 142 143 144 145 146 147 def set_icon ( self , icon : gui . icon . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = gui . icon . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_modality","text":"Set modality for the dialog. Valid values for modality: \"none\", \"window\", \"application\" Parameters: Name Type Description Default modality str modality for the main window 'window' Exceptions: Type Description InvalidParamError modality type does not exist Source code in prettyqt/widgets/widget.py 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def set_modality ( self , modality : str = \"window\" ) -> None : \"\"\"Set modality for the dialog. Valid values for modality: \"none\", \"window\", \"application\" Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in MODALITIES : raise InvalidParamError ( modality , MODALITIES ) self . setWindowModality ( MODALITIES [ modality ])","title":"set_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_size_policy","text":"Set the sizes policy. possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default horizontal Optional[str] horizontal size policy None vertical Optional[str] vertical size policy None Source code in prettyqt/widgets/widget.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def set_size_policy ( self , horizontal : Optional [ str ] = None , vertical : Optional [ str ] = None ) -> None : \"\"\"Set the sizes policy. possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp )","title":"set_size_policy()"}]}