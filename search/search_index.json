{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"prettyqt: Pythonic layer on top of PyQt6 / PySide6","text":""},{"location":"index.html#what-is-it","title":"What is it?","text":"<p>PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt6 / PySide6.</p>"},{"location":"index.html#main-features","title":"Main Features","text":"<ul> <li>Large parts of the Qt API are available in a PEP-8-compliant way.</li> <li>Pre-defined widgets for common use cases</li> <li>Large set of validators, syntax highlighters, models and much more.</li> </ul> <p>PrettyQt basically is a wrapper for the whole Qt API (either on top of PySide6 or PyQt6).</p> <p>The library contains a tree of mixins, with one mixin for each Qt class. These mixins also inherit from each other and are applied to the Qt classes. That way each class gets all helper methods from all sub-mixins.</p> <p>Example: The class \"TreeView\" inherits from original Qt Class \"QTreeView\" and gets helper methods from \"TreeViewMxin\", \"AbstractItemViewMixin\", \"AbstractScrollAreaMixin\", \"FrameMixin\", \"WidgetMixin\" and \"ObjectMixin\".</p> <p>To illustrate this, we will use some of our included models:</p> <pre><code>from prettyqt import custom_models, widgets\n\napp = widgets.app()\nwidget_1 = widgets.TreeView()\nwidget_2 = widgets.TreeView()\nmodel_1 = custom_models.SubClassTreeModel(core.ObjectMixin)  # our base mixin.\nmodel_2 = custom_models.SubClassTreeModel(core.QObject)  # this is QtCore.QObject\nwidget.set_model(model)\nwidget.show()\n</code></pre> <p>You can see a comparison here between Our mixin tree and the original Qt Tree. As you can notice, every Qt class with Subclasses has a corresponding Mixin.</p> <p>To show what this leads to, we will look at another example:</p> <pre><code>from prettyqt import custom_models, widgets\n\napp = widgets.app()\nwidget = widgets.TreeView()\nmodel = custom_models.ParentClassTreeModel(widgets.TreeWidget)\nwidget.set_model(model)\nwidget.show()\n</code></pre> <p>Main objective is to make Qt feel \"pythonic\". Qt is originally a C++ Framework, and using it can be quite cumbersome for Python developers. (it\u00b4s statically typed, very OOP-centric, lot of enum use, snakeCase naming etc.) PrettyQt aims to improve this by:</p> <ul> <li>adding more powerful methods to the classes, which accept more types and have more options (in form of keyword arguments)</li> <li>doing conversions for method parameters to lessen the strictness for types. (Example: points, sizes and rectangles can also be passed to most important methods as tuples.)</li> <li>raising Exceptions or returning None instead of returning -1 or invalid objects.</li> <li>all enum getters/setters also work with strings. Everything typed with Literals for an excellent IDE experience. (Example: )</li> <li>adding a lot of dunder methods to the classes to make them behave like good python citizens.</li> </ul> <p>The minimum supported python version is 3.10. Since larger parts of the library are dealing with type conversions, the match-case statement is essential, therefore makin it impossible to use older Python versions. The minimum supported Qt version is 6.5, since it is the first Qt Version which is up-to-par featurewise with Qt5.</p> <p>Apart from the 3D related modules (Qt3D, QtDataVizualization), QtXml and QtSql, almost every class from Qt is covered.</p>"},{"location":"index.html#the-covered-modules-right-now-are","title":"The covered modules right now are:","text":"<ul> <li>QtBluetooth (-&gt; prettyqt.bluetooth)</li> <li>QtCharts (-&gt; prettyqt.charts)</li> <li>QtCore (-&gt; prettyqt.core)</li> <li>QtDesigner (-&gt; prettyqt.designer)</li> <li>QtGui (-&gt; prettyqt.gui)</li> <li>QtLocation (-&gt; prettyqt.location)</li> <li>QtMultimedia (-&gt; prettyqt.multimedia)</li> <li>QtMultimediaWidgets (-&gt; prettyqt.multimediawidgets)</li> <li>QtNetwork (-&gt; prettyqt.network)</li> <li>QtOpenGLWidgets (-&gt; prettyqt.openglwidgets)</li> <li>QtPdf (-&gt; prettyqt.pdf)</li> <li>QtPdfWidgets (-&gt; prettyqt.pdfwidgets)</li> <li>QtPositioning (-&gt; prettyqt.positioning)</li> <li>QtPrintSupport (-&gt; prettyqt.printsupport)</li> <li>QtQml (-&gt; prettyqt.qml)</li> <li>QtHelp (-&gt; prettyqt.qthelp) (prepended \"qt\" to avoid name clashing)</li> <li>QtQuick (-&gt; prettyqt.quick)</li> <li>QtQuickWidgets (-&gt; prettyqt.quickwidgets)</li> <li>QScintilla (-&gt; prettyqt.scintilla)</li> <li>QtScXml (-&gt; prettyqt.scxml)</li> <li>QtStateMachine (-&gt; prettyqt.statemachine)</li> <li>QtSvg (-&gt; prettyqt.svg)</li> <li>QtSvgWidgets (-&gt; prettyqt.svgwidgets)</li> <li>QtTextToSpeech (-&gt; prettyqt.texttospeech)</li> <li>QtWebChannel (-&gt; prettyqt.webchannel)</li> <li>QtWebEngineCore (-&gt; prettyqt.webenginecore)</li> <li>QtWebEngineWidgets (-&gt; prettyqt.webenginewidgets)</li> <li>QtWidgets (-&gt; prettyqt.widgets)</li> </ul> <p>All subclassed Qt classes in mentioned modules are called exactly like the Qt-Counterpart, except that the leading Q is missing.</p>"},{"location":"index.html#examples","title":"Examples:","text":"<ul> <li>QtWidgets.QWidget -&gt; widgets.Widget</li> <li>QtCore.QObject -&gt; core.Object</li> </ul> <p>Apart from the mentioned mixin tree and the corresponding classes, this library also contains a lot of custom widgets, delegates, eventfilters, validators, syntaxhighlighters, layouts, models, proxy models and much more.</p> <p>Converting to PrettyQt should be very straightforward since the original behaviour of the Qt classes didnt change for the largest parts and all methods from base Qt modules are still available. (There might be a few constructors with slightly different behaviour though.)</p> <p>Interested? Take a look at the documentation! (even though it totally sucks in its current state.)</p>"},{"location":"index.html#where-to-get-it","title":"Where to get it","text":"<p>The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt</p> <p>The latest released version are available at the Python package index.</p> <pre><code># or PyPI\npip install prettyqt\n</code></pre>"},{"location":"index.html#required-dependencies","title":"Required dependencies","text":"<ul> <li>bidict</li> <li>pygments</li> <li>qstylizer</li> <li>typing_extensions</li> </ul>"},{"location":"index.html#and-one-of","title":"And one of...","text":"<ul> <li>pyside6</li> <li>pyqt6</li> </ul> <p>Note: Only Qt 6.5+ is supported.</p>"},{"location":"index.html#optional-dependencies","title":"Optional dependencies","text":"<ul> <li>orjson</li> <li>numpy</li> <li>ipython</li> <li>qtconsole</li> <li>pillow</li> <li>fsspec</li> <li>docutils</li> </ul>"},{"location":"index.html#installation-from-sources","title":"Installation from sources","text":"<p>This project uses poetry for dependency management and packaging. Install this first. In the <code>prettyqt</code> directory (same one where you found this file after cloning the git repo), execute:</p> <pre><code>poetry install\n</code></pre>"},{"location":"index.html#license","title":"License","text":"<p>MIT</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/</p>"},{"location":"index.html#contributing-to-prettyqt","title":"Contributing to prettyqt","text":"<p>All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome.</p> <p>Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!</p>"},{"location":"SUMMARY.html","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference<ul> <li>bluetooth</li> <li>charts</li> <li>constants</li> <li>core</li> <li>custom_delegates</li> <li>custom_models</li> <li>custom_validators</li> <li>custom_widgets</li> <li>gui</li> <li>location</li> <li>multimedia</li> <li>multimediawidgets</li> <li>network</li> <li>objbrowser</li> <li>pdf</li> <li>pdfwidgets</li> <li>positioning</li> <li>qml</li> <li>qthelp</li> <li>quick</li> <li>quickwidgets</li> <li>svg</li> <li>syntaxhighlighters</li> <li>texttospeech</li> <li>webenginecore</li> <li>webenginewidgets</li> <li>widgets</li> </ul> </li> <li>Highlights<ul> <li>models</li> <li>layouts</li> <li>models</li> <li>proxies</li> <li>animating</li> <li>widgets</li> <li>validators</li> </ul> </li> <li>Changelog</li> </ul>"},{"location":"api_guidelines.html","title":"Api guidelines","text":"<p>To allow for an easy switch, the API layer provided by PrettyQt should be consistent and predictable. When knowing the following guidelines, it should be easy to guess how PrettyQt can be used:</p> <ol> <li> <p>Every Qt namespace has an equivalent module, named lowerase and with the Qt-prefix removed. Example: QtCore basically equals to prettyqt.core</p> </li> <li> <p>Every Qt class has an equivalent class with the Q-prefix removed, placed in the namespace mentioned above. The \"original\" Qt classes are still available in the same module.</p> </li> <li> <p>Example: widgets.Widget is the QWidget subclass also containing the mixins, widgets.QWidget is the original Qt Class.</p> </li> <li> <p>The Qt-inherited API should still work as-is. If any method is overriden by this framework, it should still be allowed to call it with the original Qt signature.</p> </li> <li> <p>Naming of the equivalent PrettyQt methods should follow a consistent scheme. Setters are lower-cased and snake-cased, getters are lower-cased, snake-cased and have a get_ prepended to avoid name clashes. If any lower-cased, snake-cased method name is not provided by PrettyQt, it will call the original method via getattr. (The last point only applies to classes which inherit from QObject.)</p> </li> </ol> <p>Types</p> <p>PrettyQt loosens type restrictions for all API calls.</p> <p>Here is a short list how support for types is extended:</p> <p>QtGui.QColor: - Sequence[int, int, int] - Sequence[int, int, int, int] - str (Color name or #color hex value) - str (Color role from palette. Example: \"window_role\", \"highlight_role\")</p> <p>Example:     effect = widgets.GraphicsColorizeEffect()     effect.set_color(\"window_role\")     effect.set_color((30, 30, 50))     effect.set_color(\"green\")</p> <p>QtGui.QIcon: - pathlib.Path (path to an icon) - str (icon name, like \"mdi.information\")</p> <p>Example:     button = widgets.PushButton()     button.set_icon(\"mdi.information\")     button.set_icon(pathlib.Path(\"path/to/icon.png\"))</p> <p>QtCore.QTime: - datetime.time (https://docs.python.org/3/library/datetime.html#datetime.time) - str (which can be parsed from dat)</p> <p>Example:     widget = widgets.TimeEdit()     widget.set_time(\"02:04:00\")</p> <p>QtCore.QRegularExpression: - str (containing the regex pattern) - re.Pattern</p> <p>Example:     proxy = core.SortFilterProxyModel()     pattern = re.complile(\"[a-z]\")     proxy.set_filter_regular_expression(pattern)</p> <p>QtCore.QUrl: - str - os.PathLike (when appropriate) - urllib.parse.ParseResult</p> <p>Example:     page = webenginecore.WebEnginePage()     page.set_url(\"http://www.github.com/phil65/prettyqt\")</p> <p>QtCore.QByteArray - str - bytes</p> <p>QtCore.QMargins - tuple[int, int, int, int] (left, top, right, bottom) - tuple[int, int] (left/right, top/bottom) - int - None (same as 0) - QtCore.QMarginsF</p> <p>QtCore.QPoint: - tuple[int, int] - QtCore.QPointF</p> <p>QtCore.QPointF: - tuple[float, float] - tuple[int, int] - QtCore.QPoint</p> <p>QtCore.QSize: - tuple[int, int] - QtCore.QSizeF</p> <p>QtCore.QSizeF: - tuple[float, float] - QtCore.QSize</p>"},{"location":"changelog.html","title":"Changelog","text":""},{"location":"changelog.html#v1500-2023-06-27","title":"v1.50.0 (2023-06-27)","text":""},{"location":"changelog.html#feat","title":"Feat","text":"<ul> <li>TreeView: add expand_all method</li> <li>FilterHeader: use NumFilterWidget for numerical columns</li> <li>MultiColumnFilterProxyModel: add support for callables</li> <li>add NumFilterWidget</li> <li>add ColumnOrderProxyModel</li> <li>Proxifier: add melt method</li> <li>add ProxyMapper</li> <li>add MeltProxyModel</li> <li>PandasIndexFilterProxyModel: add endswith filter mode</li> <li>DateTimeAxis: add some datetime-related methods</li> <li>Object: add bind_property classmethod</li> <li>add FunctionValidator</li> <li>VariantDelegate: add validator kwarg</li> <li>add StringListLineEdit</li> <li>LineEdit: add append kwarg</li> <li>ProgressBarDelegate: support choosing a custom role</li> <li>add RangeEdit and SliceEdit</li> <li>Proxifier: add change_icon_size</li> <li>StandardItemModel: set ItemPrototype to our own subclass</li> <li>StandardItemModel: add from_dict method</li> <li>XmlModel: also support lxml.etree</li> <li>slicing support for Grid/GraphicsGridlayout</li> <li>Object: types.UnionType support for Object.find_child</li> <li>PathValidator: add mode setting (any, file, folder)</li> <li>LineEdit: allow explicitely overriding empty handling for validators</li> <li>Proxifier: change set_read_only to a more general change_flags method</li> </ul>"},{"location":"changelog.html#fix","title":"Fix","text":"<ul> <li>Widget: fix map_to/from(\"window\", ...)</li> <li>EnumFlagWidget: fix behaviour for non-power-of-2 flags</li> <li>EventLoop: typo in execute()</li> <li>TableToListProxyModel: emit headerDataChanged signal on header change</li> <li>EnumFlagWidget: filter None to workaround Qt flag bug</li> <li>DoubleValidator: correct default for set_range decimals kwarg</li> </ul>"},{"location":"changelog.html#v1490-2023-06-21","title":"v1.49.0 (2023-06-21)","text":""},{"location":"changelog.html#feat_1","title":"Feat","text":"<ul> <li>ParentClassTreeModel: add mro mode</li> <li>add SliceCheckableTreeProxyModel</li> <li>ScrollAreaTocWidget: show windowIcon</li> <li>ScrollAreaTocWidget: make header property user-settable</li> <li>Proxifier: add to_list method</li> <li>PandasTableWithHeaderModel: make multiindex_separator a property</li> <li>new fast PandasProxyModels</li> <li>BaseIPythonWidget: make completion_mode a property</li> <li>add some multimedia classes</li> <li>add SliceChangeIconSizeProxyModel</li> <li>SortFilterProxyModel: allow re.Pattern for setFilterRegularExpression</li> <li>search box for settings</li> <li>MultiColumnFilterProxyModel: support fuzzy and normal (startswith) mode.</li> <li>MultilineLayout: support different layout types</li> <li>add MultiColumnFilterProxyModel</li> <li>add FilterHeader (replaces FilterContainer)</li> <li>TableToListProxyModel: map headerData and allow setting custom header</li> <li>debugging: add proxy_comparer helper</li> <li>allow negative indexes for Layout.getitem</li> <li>ScrollAreaTocWidget: make highlight_font a property</li> <li>qml: add a helper to quickly expose all widgets to qml</li> <li>PropertyAnimation: add get_property_value method</li> <li>Widget: add map_to/from(\"window\")</li> <li>AbstractAnimation: add toggle_direction method</li> <li>ColorValuesProxyModel: allow setting low/high color</li> <li>helpers: get_color_percentage works with arbitrary number of tuple elements now</li> <li>Layout: allow LayoutItems for add()</li> <li>add SliceFilterProxyModel</li> <li>add HighlightMouseProxyModel</li> <li>TabWidget: allow slicing</li> <li>HeaderView: allow indexing by section name</li> <li>slicing support for TabBar</li> <li>Layout: add get_items method</li> <li>Proxifier: add add_column method</li> <li>Slicing support for StackedWidget</li> <li>HeaderView: add HeaderWrapper</li> <li>PushButton: add set_action method</li> <li>add AutoresizingTextEdit</li> <li>add ConfigWidget</li> <li>Slice proxying</li> <li>add include_column kwarg to get_index_key</li> <li>add ColorValuesProxyModel</li> <li>add ModelIndexModel</li> <li>add DisplayMode setting to FlattenedTreeProxyModel</li> <li>Proxifier: add flatten method</li> <li>Object: add properties_set_to context manager</li> <li>AbstractItemModel: add get_breadcrumbs_path</li> <li>ImportlibTreeModel: show markers</li> <li>TreeModel: support TreeItem subclasses</li> <li>AbstractItemModel: depth kwarg for prefetch_tree</li> <li>Treeview: add set_expanded method (which also takes Iterables)</li> <li>AbstractItemModel: depth kwarg for search/iter_tree</li> <li>Object: add signal_blocked method</li> <li>AbstractItemModel: add get_child_indexes method</li> <li>VariantDelegate: make setting EditRole optional</li> <li>ToolBox: add slicing support</li> <li>GraphicsLayout: add slicing support</li> <li>AnimationGroup: add targetObject method</li> <li>ListWidget: add slice support</li> <li>ToolBar: add getitem including slicing</li> <li>BaseListDelegator: support slicing</li> <li>support slicing for layouts</li> <li>Splitter: allow slicing</li> <li>add listdelegators module</li> <li>TextCursor: add join_previous kwarg for edit_block</li> <li>TextCursor: add contains method</li> <li>add FrameInfoModel class</li> <li>add show method</li> <li>add TextAnimation class</li> <li>PygmentsHighlighter: make style a property</li> <li>add EmojiIconEngine class</li> <li>Locale: add get_flag_unicode method</li> <li>Locale: add get_country method</li> <li>Fx: infer type for transition methods</li> <li>Font: add as_qt kwarg for mono()</li> <li>ListMixin: support slices for getitem</li> <li>add SubClassTreeModel / ParentClassTreeModel</li> <li>add PydanticFieldsModel</li> <li>add PydanticModel</li> <li>Settings: allow nesting settings objects</li> <li>add AstViewer</li> <li>add two models for attrs</li> <li>fx: add transition_to/from methods</li> <li>add OptionsValidator</li> <li>RegularExpression: add to_py_pattern method</li> <li>VariantAnimation: add append_reversed method</li> <li>add MultiComboBox</li> <li>AbstractItemModel: add get_index_key / key_from_index methods</li> <li>Layout: groupbox for ContextLayouts</li> <li>MetaObject: also accept snake case for get_property etc</li> <li>MetaProperty: add get_python_type method</li> <li>SequentialAnimationGroup: add reverse / reversed / append_reversed methods</li> <li>Stalker: work with non-prettyqt widgets</li> <li>QObjectDialog: widget click sets focus on HierarchyView</li> <li>add ZoomAnimation</li> <li>VariantAnimation: add reverse/reversed methods</li> <li>fx delegate for widgets</li> <li>Widget: add data kwarg to add_action</li> <li>add delay kwarg to play_animation</li> <li>ScrollBar: add can_scroll method</li> <li>add some ScXml classes</li> <li>HighlightCurrentProxyModel: make highlight color configurable</li> <li>HighlightCurrentProxyModel: add \"row\" as mode option</li> <li>add XmlModel</li> <li>ScrollArea: make get_visible_widgets work with base QWidgets</li> <li>add AstModel class</li> <li>TextCursor: allow tuples for select_text</li> <li>TextCursor: allow tuples for set_position</li> <li>TabWidget: add create_tab_preview method</li> <li>add two models for displaying dataclasses</li> <li>WidgetPropertiesModel: add Stored column</li> <li>Locale: add get_c_locale method</li> <li>Object: only_nonempty kwarg for get_properties</li> <li>MetaObject: extended get_properties filter functionality</li> <li>MetaObject: added get_all_super_classes method</li> <li>Object: allow predicates for find_children property selector</li> <li>RegularExpression: allow re.Pattern in ctor</li> </ul>"},{"location":"changelog.html#fix_1","title":"Fix","text":"<ul> <li>ColumnItemModel: prevent namespace issues</li> <li>TextDocument: method somehow landed in wrong class</li> <li>MultiColumnFilterProxyModel: fix non-fuzzy str search</li> <li>AstModel: correct has_children check</li> <li>Object: fix check in get_properties</li> <li>ScrollbarTocWidget: highlight rows when shown</li> <li>RenderLinkDelegate: correctly clip text</li> <li>ClassTreeModel: catch another exception</li> <li>KeySequenceEdit: return correct type</li> <li>AnimationGroup: fix slicing support</li> <li>DebugMode: hide frame when menu closed</li> <li>CycleWidget: fixed scroll issue</li> <li>FilterContainer: editor width fix</li> <li>FilterContainer: pass object_name to parent in init</li> <li>AbstractItemView: fix incorrect type in size_hint_for_column</li> <li>Spanslider: qt6 related stuff</li> </ul>"},{"location":"changelog.html#v1480-2023-06-08","title":"v1.48.0 (2023-06-08)","text":""},{"location":"changelog.html#feat_2","title":"Feat","text":"<ul> <li>make ProcessEnvironment a MutableMapping</li> <li>TableView: add margin kwarg to get_visible_section_span / resize_visible_columns_to_contents</li> <li>AbstractItemView: add get_visible_section_span</li> <li>AbstractTableModel: add to_dataframe method</li> <li>AbstractItemModel: add prefetch_tree method</li> <li>checks module</li> <li>Windows contextmenu stuff</li> </ul>"},{"location":"changelog.html#fix_2","title":"Fix","text":"<ul> <li>show_root: properly reset before hiding</li> </ul>"},{"location":"changelog.html#v1470-2023-06-07","title":"v1.47.0 (2023-06-07)","text":""},{"location":"changelog.html#feat_3","title":"Feat","text":"<ul> <li>AbstractScrollArea: add add_scrollbar_widget method</li> <li>add AnnotatedScrollBar</li> <li>TextEditSelecter: add getitem</li> <li>PlainTextEdit: add get_visible_line_span</li> <li>add MonotonicListValidator</li> <li>add some pandas widgets</li> <li>add PrintSupport classes</li> <li>PlainTextEdit: add get_pixel_height method</li> <li>quick shot for a PreviewScrollBar</li> <li>Add ScrollAreaTableOfContentsWidget</li> <li>AbstractItemModel: add max_results kwarg for search_tree</li> <li>Object: property selector kwarg for find_children</li> <li>Widget: add map_to and child_at methods</li> <li>ScrollArea: always use Widget for viewport, add get_visible_widgets</li> <li>return handles for AbstractItemView.sync_with</li> <li>AbstractItemView: always use our subclassed ItemSelectionModel</li> <li>make settings a proper MutableMapping</li> <li>Layout: add item_at method</li> <li>add SectionAutoSpanEventFilter</li> <li>AbstractItemView: add sync_with method</li> <li>add OrientedTableView</li> <li>add AutoSizeColumnsEventFilter</li> <li>allow setting eventfilters by name</li> <li>TextDocument: add get_pixel_height method</li> <li>TableView: add resize_visible_columns_to_contents method</li> <li>getattr for core, gui, widgets modules</li> <li>AbstractProxyModel: add get_source_model method</li> <li>TableView: add get_visible_section_span</li> <li>Pixmap: add save_to_file method</li> <li>VariantDelegate: support numpy integers</li> <li>add DataFrameEvalFilterProxyModel</li> <li>TableView: add auto_span method</li> <li>max colcount by default for resizeColumnsToContents</li> <li>DataFrameViewer: use numpy for span detection</li> <li>MetaObject: add forward_signals kwarg to copy</li> <li>MetaObject: also allow copy for widgets which need orientation</li> <li>bit NumPy support for VariantDelegate</li> <li>add HighlightCurrentProxyModel</li> <li>GuiApplication: add find_window method</li> <li>add UrlLineEdit</li> <li>allow str for RegularExpressionValidator ctor</li> <li>TreeView: add show_root method</li> <li>start with pandas stuff</li> <li>AbstractItemView: add get_size_hint_for_column</li> <li>AbstractProxyModel: add remove method</li> <li>add ReadOnlyProxyModel</li> <li>MessageBox: add get_button method</li> <li>LineEdit: allow QRegularExpressions for set_validator</li> <li>Validator: add strict mode</li> <li>AbstractItemModel: add iter_tree / search_tree methods</li> <li>AbstractItemView: add iter_tree method</li> <li>Stalker: add some event signals</li> <li>add TextLength/AlphaNumericValidator</li> <li>add Hex/QssValidator</li> <li>allow showing different content for show_tooltips</li> <li>add Int/Float LineEdits</li> <li>allow setting validator by str</li> <li>TextEditSelecter: add highlight_matches method</li> <li>MenuBar for QObjectDetailsDialog</li> <li>SidebarWidget: allow Actions for add_action</li> <li>prep some Actions for Mainwindow</li> <li>FilterContainer: add set_filter_mode method</li> <li>Stalker: make log_level a prop</li> <li>add ColumnJoinerProxyModel</li> <li>fuzzy filter support in \"regular\" SortFilterProxyModel</li> <li>add AppearanceProxyModel class</li> <li>add SpanTableView</li> <li>add BackingStore</li> <li>add RectFEdit</li> <li>AbstractItemView: add get_proxies method</li> <li>TableView: add is_cell_visible method</li> <li>HeaderView: add is_in_visual_range method</li> <li>show widget borders in debug mode</li> <li>KeyCombination: add add method</li> <li>AbstractItemModel: add is_checkstate_column method</li> <li>add some proxy models</li> <li>ensure_visible kwarg for (Plain)TextEdit</li> <li>colors: quick access to setting color roles</li> <li>TextEditSelecter: end_pos kwarg for goto_line</li> <li>add qobjectsdetailsdialog</li> <li>AbstractItemView: extend set_model</li> <li>MetaObject: add connect_signals method</li> <li>MetaObject: add only_notifiers kwarg for get_signals</li> <li>TextBrowser: add get_source_type method</li> <li>CommandPalette: add for_path method</li> <li>automatic registration for delegates</li> <li>Widget: add \"border\" as set_layout option</li> <li>move all proxy stuff to Proxifier delegate</li> <li>Widget: allow setting margin in ctor</li> <li>AbstractItemView: make role a kwarg for current_data/selected_data</li> <li>add FlattenedTreeProxyModel</li> <li>add StretchButtonToolBar</li> <li>add CrossFadeWidget</li> <li>add AdjustingBoxLayoutDockWidget</li> </ul>"},{"location":"changelog.html#fix_3","title":"Fix","text":"<ul> <li>Settings: raise KeyError for non-existing keys</li> <li>fix create_char</li> <li>add missing import</li> <li>typo</li> <li>DataFrameEvalFilterProxyModel: always get the root sourcemodel</li> <li>ColorDialog: fix replacing QColorShower stuff</li> <li>SidebarWidget: correct signature for add_action</li> <li>WidgetHierarchyModel: only return direct children</li> <li>HeaderView: fix toggle-vis context menu</li> <li>add workaround for missing parent() methods when using PyQt</li> <li>QAbstractProxyModel is part of QtCore</li> <li>dont mask QObject.parent()</li> <li>StackedWidget: fix fade animation</li> <li>WidgetHierarchyModel: missed to adjust columnCount for extra column</li> </ul>"},{"location":"changelog.html#v1460-2023-05-24","title":"v1.46.0 (2023-05-24)","text":""},{"location":"changelog.html#feat_4","title":"Feat","text":"<ul> <li>add ActionGrid</li> <li>StandardItem: add get/set_text_alignment</li> <li>HeaderView: add get_section_for_label method</li> <li>add DefaultDropdownAction</li> <li>add PredicateFilterProxyModel</li> <li>MetaObject: only_writable kwarg for get_properties</li> <li>add ValueTransformationProxyModel</li> <li>add SubsetFilterProxyModel</li> <li>AbstractItemView: add get/set_state</li> <li>add LineEditFilterContainer</li> <li>add TableToListProxyModel</li> <li>AbstractItemModel: add get_model method</li> <li>add WidgetHierarchyModel</li> <li>add MultiLineLayout</li> <li>AbstractItemView: add get_drop_indicator_position</li> <li>Layout: add clear method</li> <li>Font: add scaled method</li> <li>SignalMapper: add delitem method</li> <li>add ListViewGridResizeEventFilter</li> </ul>"},{"location":"changelog.html#fix_4","title":"Fix","text":"<ul> <li>GraphicsScene: fix _get_viewer_zoom without viewer</li> <li>WaitingSpinner: correctly position on parent</li> </ul>"},{"location":"changelog.html#v1450-2023-05-23","title":"v1.45.0 (2023-05-23)","text":""},{"location":"changelog.html#feat_5","title":"Feat","text":"<ul> <li>ShortcutsModel: parent widget column</li> </ul>"},{"location":"changelog.html#fix_5","title":"Fix","text":"<ul> <li>AbstractItemModel: fix transpose for PySide6</li> <li>MetaType: correctly cast in get_name</li> </ul>"},{"location":"changelog.html#v1440-2023-05-23","title":"v1.44.0 (2023-05-23)","text":""},{"location":"changelog.html#feat_6","title":"Feat","text":"<ul> <li>Widget: add highlight_widget method</li> <li>add FocusWidget</li> <li>add MappingModel</li> <li>DateTime: add from_seconds method</li> <li>add LogRecordModel</li> <li>MetaMethod: add get_parameter_types method</li> <li>MetaObject: add filter_shit kwarg for get_methods</li> <li>animation option for Cursor.set_pos</li> <li>add CursorMoveAnimation</li> <li>Cursor: add click method</li> <li>add SliderMoveToMouseClickEventFilter</li> <li>add test module</li> <li>PopupInfo: add icon support</li> <li>EventCatcher: allow str for eventtselection</li> <li>Object: add copy method</li> <li>for_palette method for Gradient</li> <li>RubberBand: add track widget method</li> <li>add WidgetDelegate</li> <li>Object: add copy method</li> <li>proper LocaleEdit</li> <li>Locale: add get_all_locales method</li> <li>add PainterPath.add</li> <li>Widget: support tuples for position_on</li> <li>Cursor: add set_pos method</li> <li>Object: add start_callback_timer</li> <li>add OrientedScrollArea</li> <li>add OverlayBorder</li> <li>add ScientificValidators</li> <li>rich_text param for set_tooltip</li> <li>DateTimeEdit: add set_to_today method</li> <li>add FuzzyCompleter</li> <li>List interface for ListMixin</li> <li>AbstractItemModel: two more context managers</li> <li>ShortcutsModel</li> <li>set ObjectNames in debugmode</li> <li>add OpenGLwidget</li> <li>WidgetsDetailsModel: automatically populate table based on most common ancestor.</li> <li>add WidgetsDetailsModel</li> <li>AbstractItemModel: make proxies easily available</li> <li>ToolBar: add show_tooltips method</li> <li>first shot for a WidgetPropertiesModel</li> <li>Date: add from_string method</li> <li>add EnumFlagWidget</li> <li>Application: add process_events method</li> <li>MetaProperty: add get_enumerator_type</li> <li>add debugmode eventFilter (WIP)</li> <li>EventCatcher: allow callable for do_filter</li> <li>Object: add connect_events method</li> <li>EventCatcher eventfilter</li> <li>Elision functionality for Label</li> <li>add JsonValidator / PythonCodeValidator / ColorValidator classes</li> </ul>"},{"location":"changelog.html#fix_6","title":"Fix","text":"<ul> <li>Cursor: correct subclass check in set_pos</li> <li>EnumComboBox/EnumFlagWidget: only declare one user prop</li> <li>correctly init Url when arg is PathLike</li> </ul>"},{"location":"changelog.html#v1430-2023-05-18","title":"v1.43.0 (2023-05-18)","text":""},{"location":"changelog.html#feat_7","title":"Feat","text":"<ul> <li>Widget: x/y_offset kwargs for position_on</li> <li>add FlashEffect</li> <li>auto kwarg suppport for Slot decorator</li> <li>MetaMethod: add get_normalized_signature method</li> <li>Widget: add show_tooltip method</li> <li>Widget: tool_tip kwarg for add_action</li> <li>ToolBar: add get_widgets method</li> <li>allow str in PropertyAnimation ctor</li> </ul>"},{"location":"changelog.html#fix_7","title":"Fix","text":"<ul> <li>missed some testing shit</li> <li>correctly map in map_to_global</li> </ul>"},{"location":"changelog.html#v1420-2023-05-17","title":"v1.42.0 (2023-05-17)","text":""},{"location":"changelog.html#feat_8","title":"Feat","text":"<ul> <li>coreApplication: add in_main_thread method</li> <li>MetaObject: add get_user_property method</li> <li>MetaType: add get_meta_object / get_meta_object_for_type</li> <li>add SignalList</li> <li>MetaProperty: add get_notify_signal / get_enumerator</li> <li>Object: keep track of eventfilters</li> <li>GuiApplication: add get_keyboard_modifiers / query_keyboard_modifiers</li> <li>Application: add widgets_at method</li> <li>first quick shot for a WidgetEditor</li> <li>allow initializing SizePolicy with strings</li> <li>NativeEventFilter for windows global hotkeys</li> <li>KeySequence: add get_key_bindings</li> <li>KeySequence: cast in getitem</li> <li>KeySequenceEdit: add get_key_combinations / get_finishing_key_combinations</li> <li>add some more prop-edit widgets</li> <li>Drag: return DropActionStr for main_loop</li> <li>animation feature for StackedWidget</li> <li>Frame: add set_frame_rect</li> <li>MetaType: get_type -&gt; get_type_name and new get_type</li> <li>JsonDocument: add format method</li> <li>embed quickref in RegexEditorWidget</li> <li>IconBrowser: use FuzzyFilter proxy</li> <li>GroupBox: add get_alignment method</li> <li>FormLayout: add get/set_label_alignment, get/set_form_alignment</li> <li>Widget: scale_ratio param for center_on</li> <li>context manager stuff for layouts</li> <li>widgets: add HBoxLayout / VBoxLayout classes</li> <li>ActionsModel: Usage count column</li> <li>add AsyncRunner</li> <li>add IPython stuff</li> <li>some helper stuff for ThreadPool</li> <li>Dir: add get_temp_path method</li> <li>merge widget center methods + rect support for mapToGlobal (map_to_global)</li> <li>FileIconProvider: custom_directory_icons methods</li> <li>prep some QtDesigner stuff</li> <li>Widget: add center_on_parent method</li> <li>some methods for StyleOptionViewItem</li> <li>Action: add usage counter and get_type</li> <li>SortFilterProxyModel: add invalidated signal</li> </ul>"},{"location":"changelog.html#fix_8","title":"Fix","text":"<ul> <li>proper mono font for all platforms</li> <li>ElidedLabel: qt6 fix</li> <li>set_data for StandardItem / ListWidgetItem with wrong arg order</li> <li>CommandPalette: widgets from other sources can have parent as an attribute</li> <li>QtWidgets: fix binding of old methods</li> <li>ButtonDelegate: pass parent via kwarg</li> <li>HtmlItemDelegate: properly draw with icon</li> <li>AbstractItemView: fix some setfocus stuff</li> <li>FuzzyFilterModel: do not check html string for filtering</li> </ul>"},{"location":"changelog.html#v1410-2023-05-10","title":"v1.41.0 (2023-05-10)","text":""},{"location":"changelog.html#feat_9","title":"Feat","text":"<ul> <li>ColumnItemModel: add set_columns method</li> <li>add FuzzyFilterModel</li> <li>add commandpalette</li> <li>SortFilterProxyModel: add setFixedFilterList method</li> <li>SortFilterProxyModel: override lessThan to allow sorting for more types</li> <li>AbstractItemView: add some methods to deal with ItemSelectionModel</li> <li>Widget: add set_focus method</li> <li>add ActionsModel class</li> <li>StandardItem: add set_data method</li> <li>IconDelegate: make item role configurable</li> <li>Completer: added path_updated signal</li> <li>Completer: add set_completion_role method</li> <li>SortFilterProxyModel: add set_filter_role method</li> </ul>"},{"location":"changelog.html#fix_9","title":"Fix","text":"<ul> <li>ColumnItemModel: fix get_sort_value</li> <li>ListWidgetItem: fix set_data method</li> <li>IconDelegate: qt6 porting issue</li> <li>HtmlItemDelegate: qt6 porting bug</li> <li>RenderLinkDelegate: Qt6 fixes</li> </ul>"},{"location":"changelog.html#v1400-2023-05-09","title":"v1.40.0 (2023-05-09)","text":""},{"location":"changelog.html#feat_10","title":"Feat","text":"<ul> <li>Painter: add draw_star, draw_diamond methods</li> <li>PolygonF: scale kwarg for create_star_diamond</li> <li>Constraints column for ImportLib model</li> <li>format for different classes</li> <li>Widget: add set_graphics_effect method</li> <li>core: add LoggingCategory class</li> <li>network: add NetworkReply class</li> <li>add MaterialIconStyle class</li> <li>InputMethod: add query_focus_object method</li> <li>add GoogleCompleter</li> <li>add HTMLItemDelegate</li> </ul>"},{"location":"changelog.html#fix_10","title":"Fix","text":"<ul> <li>NestedItem: set parent in append_child</li> </ul>"},{"location":"changelog.html#v1391-2023-05-08","title":"v1.39.1 (2023-05-08)","text":""},{"location":"changelog.html#fix_11","title":"Fix","text":"<ul> <li>model cleanup</li> </ul>"},{"location":"changelog.html#v1390-2023-05-08","title":"v1.39.0 (2023-05-08)","text":""},{"location":"changelog.html#feat_11","title":"Feat","text":"<ul> <li>re-work JsonModel</li> <li>add update_check</li> <li>some MessageBox work</li> <li>SlideAnimation: add start/end_value kwargs for ctor</li> <li>Widget: add play_animation method</li> <li>PlainTextEdit: extend set_syntaxhighlighter</li> <li>add CycleWidget</li> <li>add SelectedWordHighlighter class</li> <li>PlainTextEdit: better way to color focused line</li> <li>bluetooth: cover some more classes</li> <li>ItemSelectionModel: add set_current_index method</li> <li>scroll_to_item for Table/TreeWidget</li> <li>AbstractScrollArea: add set_viewport_margins method</li> <li>set_size for SvgGenerator and QuickItem</li> </ul>"},{"location":"changelog.html#fix_12","title":"Fix","text":"<ul> <li>Scintilla: fix highlight_current_line</li> <li>Color: also inherit transparency when QColor for ctor</li> <li>typed signals seem to cast to Qt types</li> </ul>"},{"location":"changelog.html#v1381-2023-05-07","title":"v1.38.1 (2023-05-07)","text":""},{"location":"changelog.html#fix_13","title":"Fix","text":"<ul> <li>Chart: used wrong call for setting style</li> </ul>"},{"location":"changelog.html#v1380-2023-05-07","title":"v1.38.0 (2023-05-07)","text":""},{"location":"changelog.html#feat_12","title":"Feat","text":"<ul> <li>TreeWidget: add find_items method</li> <li>recursive and case_sensitive kwarg for ListWidget/StandardItemModel.find_items</li> <li>HeaderView: add set_sort_indicator method</li> <li>VersionNumber: add from_string method</li> <li>auto adjust Chart and PygmentsHighlighter colors to Palette</li> <li>Palette: allow disabling highlight_inactive</li> </ul>"},{"location":"changelog.html#fix_14","title":"Fix","text":"<ul> <li>HierarchicalHeaderView: oops</li> </ul>"},{"location":"changelog.html#v1371-2023-05-06","title":"v1.37.1 (2023-05-06)","text":""},{"location":"changelog.html#fix_15","title":"Fix","text":"<ul> <li>check for None-model in set_sorting_enabled</li> </ul>"},{"location":"changelog.html#v1370-2023-05-06","title":"v1.37.0 (2023-05-06)","text":""},{"location":"changelog.html#feat_13","title":"Feat","text":"<ul> <li>HeaderView: some kwargs for set_resize_mode, add set_sections_movable method</li> <li>TreeView/TableView: add set_sorting_enabled method</li> <li>add HierarchicalHeaderView class</li> <li>SortFilterProxyModel: add get_sort_order method</li> <li>Wizard: add set_custom_button method</li> <li>make some basic types pattern matching compatible</li> <li>SortFilterProxyModel: more pythonic sort() kwargs</li> </ul>"},{"location":"changelog.html#v1360-2023-05-05","title":"v1.36.0 (2023-05-05)","text":""},{"location":"changelog.html#feat_14","title":"Feat","text":"<ul> <li>MimeDatabase: add some new methods</li> <li>SizePolicy: add get_transposed method</li> <li>enable dark mode detection on linux</li> <li>DataWidgetMapper: add setitem, getitem, delitem</li> <li>GuiApplication: add set_progress_value method</li> <li>quick: add SGNode class</li> <li>Window: add some more methods</li> <li>qml: add QmlError / QmlExpression classes</li> <li>qml: add QmlProperty class</li> <li>TreeWidgetItem: add recursive option for get_children</li> <li>TreeWidget: add get_items method</li> </ul>"},{"location":"changelog.html#fix_16","title":"Fix","text":"<ul> <li>Completer: fixed is_case_sensitive method</li> <li>correctly inherit for QuickView</li> </ul>"},{"location":"changelog.html#v1350-2023-05-05","title":"v1.35.0 (2023-05-05)","text":""},{"location":"changelog.html#feat_15","title":"Feat","text":"<ul> <li>Shortcut: allow str for ctor</li> <li>Shortcut: add set_key(s) methods</li> <li>add add_shortcut methods for Window and Widget classes</li> <li>gui: add SurfaceFormat class</li> <li>Locale: add some methods</li> <li>Locale: add get_formatted_data_size</li> </ul>"},{"location":"changelog.html#v1340-2023-05-04","title":"v1.34.0 (2023-05-04)","text":""},{"location":"changelog.html#feat_16","title":"Feat","text":"<ul> <li>qml: add QmlPropertyMap class</li> <li>FsSpecModel: filter columns depending on protocol</li> <li>GraphicsView: add zooming option</li> <li>add AccordionWidget</li> </ul>"},{"location":"changelog.html#v1331-2023-05-04","title":"v1.33.1 (2023-05-04)","text":""},{"location":"changelog.html#fix_17","title":"Fix","text":"<ul> <li>test fixes</li> </ul>"},{"location":"changelog.html#v1330-2023-05-04","title":"v1.33.0 (2023-05-04)","text":""},{"location":"changelog.html#feat_17","title":"Feat","text":"<ul> <li>GraphicsScene: add grid functionality</li> <li>add DebouncedSignal class</li> <li>TabWidget: allow QWidget for remove_tab</li> <li>AbstractNativeEventFilter: add install method</li> <li>add taskbaritem module</li> <li>HoverIconEventFilter: add pressed state</li> <li>VariantDelegate: deal with enums</li> <li>add EnumComboBox</li> <li>Completer: add set_strings method</li> <li>add FsSpecCompleter</li> <li>Widget: add get_win_id() method</li> <li>TtextTableCell: add get_first/last_cursor_position methods</li> <li>LineEdit: add set_completer method</li> <li>Completer: add get_completions() method</li> <li>FsSpecModel: add get_file_content method</li> <li>KeySequence: overload for to_shortcut_str</li> <li>LineEdit: add tab_pressed signal</li> <li>qthelp: add HelpFilterSettingsWidget class</li> <li>Shortcut: add get_keys method</li> <li>TreeWidgetItem: add collapse / expand / get_text_alignment methods</li> <li>TableWidget: allow QModelIndex for closePersistentEditor / isPersistentEditorOpen</li> <li>TableWidgetItem: add set_editable method</li> <li>TreeWidget: add some more methods</li> <li>gui: add TextBlockFormat class</li> <li>TreeWidgetItem: add some methods</li> <li>GraphicsView: add get_view_rect / get_pixel_size</li> <li>GraphicsView: add add_item / remove_item methods</li> <li>GraphicsView: set our own scene subclass by default</li> <li>MimeData: add to_dict and clone methods</li> <li>add VariantDelegate class</li> </ul>"},{"location":"changelog.html#fix_18","title":"Fix","text":"<ul> <li>TabBar: qt6 regression (PointF instead of Point)</li> <li>ColumnItemModel: reset model in set_root_item</li> <li>AwesomeFileIconProvider: missed a case for icon()</li> <li>AudioDevice: fix get_channel_config</li> <li>Charts: dont use axisX / axisY (missing in qt6)</li> <li>ButtonDelegate: only apply to correct column</li> <li>RegexInput: catch exception when regex invalid</li> </ul>"},{"location":"changelog.html#v1320-2023-04-30","title":"v1.32.0 (2023-04-30)","text":""},{"location":"changelog.html#feat_18","title":"Feat","text":"<ul> <li>custom_widgets: add RegexLineEdit class</li> <li>PlainTextEdit: emit text with value_changed signal</li> <li>gui: add TextTable, TextTableCell and TextTableFormat classes</li> <li>ItemEditorFactor: add create_extended method</li> <li>QuickItem: add getitem and contains methods</li> <li>custom_widgets: add ColorComboBox</li> <li>ColorDialog: add get/set_custom_colors methods</li> <li>printsupport: add Printer class</li> <li>GuiApplication: add palette_changed signal</li> <li>add QtPrintSupport to qt module</li> <li>Splitter: override createHandle so that our own subclass is used.</li> <li>SplitterHandle: add clicked signal</li> <li>Palette: add is_dark method</li> <li>add quickwidgets module</li> </ul>"},{"location":"changelog.html#fix_19","title":"Fix","text":"<ul> <li>FontChooserButton: add missing button icon</li> </ul>"},{"location":"changelog.html#v1310-2023-04-29","title":"v1.31.0 (2023-04-29)","text":""},{"location":"changelog.html#feat_19","title":"Feat","text":"<ul> <li>FsSpecModel: allow None for setRootPath</li> <li>core: add SharedMemory class</li> <li>multimedia: add AudioDevice class</li> <li>add delitem for UrlQuery, Timeline and StackedWidget</li> <li>QuickRenderControl: add edit_frame context manager</li> <li>PdfWriter: add get/set_version methods</li> <li>PagedPaintDevice: add get_page_ranges and get_page_layout methods</li> <li>Date: add replace method</li> <li>FileDevice: add get_permissions method</li> <li>gui: add PageRanges class</li> <li>PainterPath: add get_simplified and to_reversed methods</li> <li>Layout: allow None for set_margin</li> <li>GridLayout: add alignment kwarg to add method</li> <li>add KeyCombinationEdit class</li> <li>KeySequenceEdit: allow QKeySequence for set_value</li> <li>ToolBox: add some kwargs to add_widget</li> <li>Splitter: some kwargs for add_widget method</li> <li>Slider: better mouseclick behaviour</li> <li>Date: add add_days, add_months, add_years and get_current_date methods</li> <li>Time: add add_msecs, add_secs and get_current_time methods</li> <li>Label: add clicked signal</li> </ul>"},{"location":"changelog.html#fix_20","title":"Fix","text":"<ul> <li>FsSpecModel: fix root glob call</li> <li>StarDelegate: qt6 fix</li> <li>Timeline: Qt6 fixes</li> <li>PlainTextEdit: wheelEvent fix</li> </ul>"},{"location":"changelog.html#v1300-2023-04-28","title":"v1.30.0 (2023-04-28)","text":""},{"location":"changelog.html#feat_20","title":"Feat","text":"<ul> <li>AbstractScrollArea: add set_scrollbar_smooth method</li> <li>add SmoothScrollBar class</li> <li>AbstractScrollArea: add scroll_by_pixels method</li> <li>Cursor: add fake_mouse_move classmethod</li> <li>Widget: add set_style method</li> </ul>"},{"location":"changelog.html#fix_21","title":"Fix","text":"<ul> <li>PlainTextEdit: correctly propagate wheelEvent</li> </ul>"},{"location":"changelog.html#v1290-2023-04-27","title":"v1.29.0 (2023-04-27)","text":""},{"location":"changelog.html#feat_21","title":"Feat","text":"<ul> <li>CameraDevice: add get_video_formats method</li> <li>re-introduce multimedia module</li> <li>FsSpecModel: add get_protocol_path method</li> <li>Widget: allow int index for insertAction</li> <li>HeaderView: add get_default_alignment and get_orientation methods</li> <li>HeaderView: add get_resize_mode method</li> <li>ColorDialog: some new methods</li> <li>pdf: add PdfSearchModel class</li> </ul>"},{"location":"changelog.html#fix_22","title":"Fix","text":"<ul> <li>Widget: support several QOpenGlWidgets for get_image</li> </ul>"},{"location":"changelog.html#v1281-2023-04-26","title":"v1.28.1 (2023-04-26)","text":""},{"location":"changelog.html#fix_23","title":"Fix","text":"<ul> <li>weird PySide6 issue with Enum val as default kwarg (PyQt works fine..)</li> </ul>"},{"location":"changelog.html#v1280-2023-04-26","title":"v1.28.0 (2023-04-26)","text":""},{"location":"changelog.html#feat_22","title":"Feat","text":"<ul> <li>Drag: add set_drag_cursor and main_loop methods</li> </ul>"},{"location":"changelog.html#v1270-2023-04-26","title":"v1.27.0 (2023-04-26)","text":""},{"location":"changelog.html#feat_23","title":"Feat","text":"<ul> <li>filesystemmodel mixin for FsSpecModel</li> </ul>"},{"location":"changelog.html#fix_24","title":"Fix","text":"<ul> <li>FsSpecModel: always return correct type for permissions()</li> </ul>"},{"location":"changelog.html#v1260-2023-04-26","title":"v1.26.0 (2023-04-26)","text":""},{"location":"changelog.html#feat_24","title":"Feat","text":"<ul> <li>MimeData: add get_urls method</li> <li>MimeData: add set_urls method</li> <li>pdf: add PdfBookmarkModel class</li> <li>AbstractItemModel: add get_role_names method</li> </ul>"},{"location":"changelog.html#fix_25","title":"Fix","text":"<ul> <li>change SORT_ROLE and NAME_ROLE values to not conflict with FileSystemModel enums</li> <li>MimeData: getitem and setitem seem to cause issues?</li> </ul>"},{"location":"changelog.html#v1250-2023-04-26","title":"v1.25.0 (2023-04-26)","text":""},{"location":"changelog.html#feat_25","title":"Feat","text":"<ul> <li>custom_models: add fsspec model</li> <li>FileSystemModel: add get_permissions method</li> </ul>"},{"location":"changelog.html#v1240-2023-04-26","title":"v1.24.0 (2023-04-26)","text":""},{"location":"changelog.html#feat_26","title":"Feat","text":"<ul> <li>Layout: add add_widget method</li> <li>Widget: allow None values for set_min/max_size</li> <li>TextStream: add get/set_number_flags methods</li> </ul>"},{"location":"changelog.html#v1230-2023-04-25","title":"v1.23.0 (2023-04-25)","text":""},{"location":"changelog.html#feat_27","title":"Feat","text":"<ul> <li>core: Add ModelRoleData class</li> <li>add ImportlibTreeModel</li> </ul>"},{"location":"changelog.html#fix_26","title":"Fix","text":"<ul> <li>correctly behaving listmixin</li> </ul>"},{"location":"changelog.html#v1222-2023-04-25","title":"v1.22.2 (2023-04-25)","text":""},{"location":"changelog.html#fix_27","title":"Fix","text":"<ul> <li>NestedModel: add default value for index kwargs</li> <li>correctly behaving RegexMatchesModel</li> </ul>"},{"location":"changelog.html#v1221-2023-04-25","title":"v1.22.1 (2023-04-25)","text":""},{"location":"changelog.html#fix_28","title":"Fix","text":"<ul> <li>NestedModel: rowCount fix</li> </ul>"},{"location":"changelog.html#v1220-2023-04-25","title":"v1.22.0 (2023-04-25)","text":""},{"location":"changelog.html#feat_28","title":"Feat","text":"<ul> <li>LayoutItem: add get_expanding_directions method</li> <li>LayoutItem: add get_control_types method</li> <li>GraphicsLayoutItem: add get/set_size_policy and bool methods</li> </ul>"},{"location":"changelog.html#fix_29","title":"Fix","text":"<ul> <li>Pixmap: fix create_char method</li> </ul>"},{"location":"changelog.html#v1210-2023-04-23","title":"v1.21.0 (2023-04-23)","text":""},{"location":"changelog.html#feat_29","title":"Feat","text":"<ul> <li>NetworkRequest: support some attributes from newer qt versions</li> <li>NetworkRequest: add set_attribute(s) method</li> <li>Object: add set_properties method</li> <li>MimeData: add for_file method</li> <li>TextDocument: add get_bytes method</li> <li>MetaMethod: add get_parameters/get_return_types methods</li> <li>MetaObject: add get_class_info method</li> <li>MetaObject: add get_super_class method</li> <li>UrlQuery: add getitem and setitem methods</li> <li>TextDocumentWriter: add serialize_document method</li> <li>Widget: add toggle_maximized method</li> </ul>"},{"location":"changelog.html#fix_30","title":"Fix","text":"<ul> <li>correct isinstance check for to_json</li> <li>TextDocumentWriter: fix serialization</li> <li>SingleApplication: TextStream.setCodec gone in qt6</li> </ul>"},{"location":"changelog.html#v1200-2023-04-22","title":"v1.20.0 (2023-04-22)","text":""},{"location":"changelog.html#feat_30","title":"Feat","text":"<ul> <li>add some methods for Thread/ThreadPool 81795</li> <li>Pixmap: get rid of flags param for from_image 8fbbf</li> <li>bluetooth: add BluetoothDeviceInfo class 80482</li> </ul>"},{"location":"changelog.html#fix_31","title":"Fix","text":"<ul> <li>BluetoothDeviceDiscoveryAgent: correctly set flags for start_discovery 4f53b</li> </ul>"},{"location":"changelog.html#v1190-2023-04-22","title":"v1.19.0 (2023-04-22)","text":""},{"location":"changelog.html#feat_31","title":"Feat","text":"<ul> <li>MenuBar: add get/set_corner_widget methods a9fc0</li> <li>PdfView: add set_file method c5b79</li> </ul>"},{"location":"changelog.html#v1180-2023-04-21","title":"v1.18.0 (2023-04-21)","text":""},{"location":"changelog.html#feat_32","title":"Feat","text":"<ul> <li>ScrollerMetrics: add get_scroll_metrics method + bit dict interface 838d6</li> <li>WebEngineSettings: more dict interface 903d7</li> <li>GuiApplication: add set_badge_number method 57e9b</li> </ul>"},{"location":"changelog.html#fix_32","title":"Fix","text":"<ul> <li>make sure to correctly set parent for actions added to menus 8ea43</li> <li>HeaderView: context menu fix c71c2</li> </ul>"},{"location":"changelog.html#v1170-2023-04-21","title":"v1.17.0 (2023-04-21)","text":""},{"location":"changelog.html#feat_33","title":"Feat","text":"<ul> <li>Image: add to_ndarray method ea556</li> <li>Widget: add get_cursor method 4dc77</li> <li>Image: add convert_to_format method f36f1</li> </ul>"},{"location":"changelog.html#fix_33","title":"Fix","text":"<ul> <li>ImportlibDistributionModel: avoid duplicates in requirements d27d2</li> </ul>"},{"location":"changelog.html#v1160-2023-04-21","title":"v1.16.0 (2023-04-21)","text":""},{"location":"changelog.html#feat_34","title":"Feat","text":"<ul> <li>AbstractItemView: add get_horizontal/vertical/scroll_mode methods bf664</li> <li>AbstractItemView: added model_changed signal 79b24</li> <li>Scroller: add grabbed_gesture method c3041</li> <li>add pdf and pdfwidgets modules de15b</li> <li>MetaProperty: add get_meta_type method 9242c</li> <li>GeoPolygon: add get_hole_path / get_perimeter methods 8910a</li> </ul>"},{"location":"changelog.html#v1151-2023-04-20","title":"v1.15.1 (2023-04-20)","text":""},{"location":"changelog.html#fix_34","title":"Fix","text":"<ul> <li>IconBrowser: correctly build charmap dict 49e18</li> <li>GraphicsEllipseItem: fix get_rect type issue (got broken with qt6) 69653</li> </ul>"},{"location":"changelog.html#v1150-2023-04-20","title":"v1.15.0 (2023-04-20)","text":""},{"location":"changelog.html#feat_35","title":"Feat","text":"<ul> <li>Object: add get_properties method 2fafb</li> <li>Image: add from/to_pil methods eb342</li> <li>Object: add get_dynamic_properties method 7c82b</li> <li>PropertyAnimation: allow passing the qt property method directly for apply_to 1ca12</li> </ul>"},{"location":"changelog.html#fix_35","title":"Fix","text":"<ul> <li>MetaObject: offsets were off by 1 cecd7</li> </ul>"},{"location":"changelog.html#v1143-2023-04-20","title":"v1.14.3 (2023-04-20)","text":""},{"location":"changelog.html#fix_36","title":"Fix","text":"<ul> <li>another release fix :) af959</li> </ul>"},{"location":"changelog.html#v1142-2023-04-20","title":"v1.14.2 (2023-04-20)","text":""},{"location":"changelog.html#fix_37","title":"Fix","text":"<ul> <li>another release fix bdc10</li> </ul>"},{"location":"changelog.html#v1141-2023-04-20","title":"v1.14.1 (2023-04-20)","text":""},{"location":"changelog.html#fix_38","title":"Fix","text":"<ul> <li>release pipeline fix bcfd8</li> </ul>"},{"location":"changelog.html#v1140-2023-04-20","title":"v1.14.0 (2023-04-20)","text":""},{"location":"changelog.html#feat_36","title":"Feat","text":"<ul> <li>WaitingSpinner: register some attributes as Qt Properties d3b25</li> <li>TableWidget: also support indexes for openPersistentEditor d450d</li> </ul>"},{"location":"changelog.html#fix_39","title":"Fix","text":"<ul> <li>RadioDelegate: property doesnt accept bytes (anymore) 25a96</li> <li>Painter: fix draw_rounded_rect method bb883</li> </ul>"},{"location":"changelog.html#v1131-2023-04-20","title":"v1.13.1 (2023-04-20)","text":""},{"location":"changelog.html#fix_40","title":"Fix","text":"<ul> <li>fix tests... 58c78</li> </ul>"},{"location":"changelog.html#v1130-2023-04-20","title":"v1.13.0 (2023-04-20)","text":""},{"location":"changelog.html#feat_37","title":"Feat","text":"<ul> <li>ButtonDelegate: no need anymore to open persistent editors 78984</li> <li>AbstractTableModel: add getitem method to return indexes 0b9be</li> </ul>"},{"location":"changelog.html#v1121-2023-04-19","title":"v1.12.1 (2023-04-19)","text":""},{"location":"changelog.html#fix_41","title":"Fix","text":"<ul> <li>Widget: missing string cast for set_stylesheet e536b</li> </ul>"},{"location":"changelog.html#v1120-2023-04-19","title":"v1.12.0 (2023-04-19)","text":""},{"location":"changelog.html#feat_38","title":"Feat","text":"<ul> <li>ColumnItemModel: inherit some stuff from ListMixin</li> </ul>"},{"location":"changelog.html#v1110-2023-04-18","title":"v1.11.0 (2023-04-18)","text":""},{"location":"changelog.html#feat_39","title":"Feat","text":"<ul> <li>LineEdit: allow some special values for set_input_mask</li> <li>Locale: add get_measurement_system</li> </ul>"},{"location":"changelog.html#fix_42","title":"Fix","text":"<ul> <li>ColumntItemModel: always return correct rowCount</li> </ul>"},{"location":"changelog.html#v1100-2023-04-18","title":"v1.10.0 (2023-04-18)","text":""},{"location":"changelog.html#feat_40","title":"Feat","text":"<ul> <li>ColumnItemModel: methods for setting data</li> <li>TreeItem: add iter method</li> </ul>"},{"location":"changelog.html#fix_43","title":"Fix","text":"<ul> <li>AttributeModel: checkstate instead of text for is_attribute</li> <li>UndoStack: raise KeyError instead of returning it</li> </ul>"},{"location":"changelog.html#v192-2023-04-17","title":"v1.9.2 (2023-04-17)","text":""},{"location":"changelog.html#fix_44","title":"Fix","text":"<ul> <li>StorageInfoModel: move some stuff to baseclass</li> </ul>"},{"location":"changelog.html#v191-2023-04-17","title":"v1.9.1 (2023-04-17)","text":""},{"location":"changelog.html#fix_45","title":"Fix","text":"<ul> <li>ColumnItemModel: fix wrong value for non-listed roles in data()</li> <li>ObjectBrowser: re-add DEFAULT_ATTR_DETAILS and inspected_node_is_visible</li> </ul>"},{"location":"changelog.html#v190-2023-04-17","title":"v1.9.0 (2023-04-17)","text":""},{"location":"changelog.html#feat_41","title":"Feat","text":"<ul> <li>custom_widgets: add FileTree class</li> <li>AbstractItemModel: add update_all method</li> </ul>"},{"location":"changelog.html#fix_46","title":"Fix","text":"<ul> <li>IconDelegate: fix exception when QIcon is passed</li> </ul>"},{"location":"changelog.html#v181-2023-04-17","title":"v1.8.1 (2023-04-17)","text":""},{"location":"changelog.html#fix_47","title":"Fix","text":"<ul> <li>user_data fix</li> </ul>"},{"location":"changelog.html#v180-2023-04-17","title":"v1.8.0 (2023-04-17)","text":""},{"location":"changelog.html#feat_42","title":"Feat","text":"<ul> <li>ColumnItemModel: add user_data to ColumnItems</li> </ul>"},{"location":"changelog.html#v171-2023-04-17","title":"v1.7.1 (2023-04-17)","text":""},{"location":"changelog.html#fix_48","title":"Fix","text":"<ul> <li>fix docs generation</li> </ul>"},{"location":"changelog.html#v170-2023-04-17","title":"v1.7.0 (2023-04-17)","text":""},{"location":"changelog.html#feat_43","title":"Feat","text":"<ul> <li>ColumnItemModel: add support for sort value and tooltips</li> <li>Widget: add grab_mouse_events / grab_keyboard_events context managers</li> <li>Painter: add some convenience methods</li> </ul>"},{"location":"changelog.html#v160-2023-04-16","title":"v1.6.0 (2023-04-16)","text":""},{"location":"changelog.html#feat_44","title":"Feat","text":"<ul> <li>Widget: add delete_children method</li> <li>Url: add is_special_url and _has_explicit_scheme methods</li> <li>Application: add set_style method</li> <li>Scrollbar: add scroll_to_next/previous_row methods</li> <li>Uuid: add to_string method</li> </ul>"},{"location":"changelog.html#fix_49","title":"Fix","text":"<ul> <li>Application: correct icon colors for new Qt built in dark mode (when using Fusion theme)</li> <li>ChartView: correct cursor shape for dragging movements</li> </ul>"},{"location":"changelog.html#v150-2023-04-13","title":"v1.5.0 (2023-04-13)","text":""},{"location":"changelog.html#feat_45","title":"Feat","text":"<ul> <li>TimeZone: add get_time_spec method</li> <li>TextDocument: add get/set_meta_information methods</li> <li>ListWidgetItem: add set_text_alignment method</li> <li>DirIterator: add get_file_path / get_file_info methods</li> </ul>"},{"location":"changelog.html#fix_50","title":"Fix","text":"<ul> <li>FileSystemModel: fix yield_child_indexes method</li> </ul>"},{"location":"changelog.html#v142-2023-04-12","title":"v1.4.2 (2023-04-12)","text":""},{"location":"changelog.html#fix_51","title":"Fix","text":"<ul> <li>only run tests on linux for now</li> </ul>"},{"location":"changelog.html#v141-2023-04-12","title":"v1.4.1 (2023-04-12)","text":""},{"location":"changelog.html#fix_52","title":"Fix","text":"<ul> <li>remove codecov from deps</li> </ul>"},{"location":"changelog.html#v140-2023-04-12","title":"v1.4.0 (2023-04-12)","text":""},{"location":"changelog.html#feat_46","title":"Feat","text":"<ul> <li>Color: add convert_to method</li> <li>Color: add get_spec method</li> <li>core: add KeyCombination class</li> <li>re-add qthelp module</li> </ul>"},{"location":"changelog.html#fix_53","title":"Fix","text":"<ul> <li>fixed Color.as_qt error with Qt6.5</li> </ul>"},{"location":"changelog.html#v130-2023-04-11","title":"v1.3.0 (2023-04-11)","text":""},{"location":"changelog.html#feat_47","title":"Feat","text":"<ul> <li>add some set_origin methods</li> <li>add some set_transform methods</li> <li>Brush: add set_style method</li> </ul>"},{"location":"changelog.html#v120-2023-04-11","title":"v1.2.0 (2023-04-11)","text":""},{"location":"changelog.html#feat_48","title":"Feat","text":"<ul> <li>re-enable texttospeech module</li> <li>gui: add AbstractFileIconProvider class</li> <li>core: add MetaType class</li> <li>gui: add StyleHints class</li> </ul>"},{"location":"changelog.html#fix_54","title":"Fix","text":"<ul> <li>correct filtering for Dir.get_entry_info_list</li> <li>Dir: explicitely use kwargs for entryList/entryInfoList calls</li> <li>prevent namespace collisions with builtin locale package</li> </ul>"},{"location":"changelog.html#v112-2023-04-10","title":"v1.1.2 (2023-04-10)","text":""},{"location":"changelog.html#fix_55","title":"Fix","text":"<ul> <li>always pass sys.argv to QCoreApplication etc</li> </ul>"},{"location":"changelog.html#v111-2023-04-10","title":"v1.1.1 (2023-04-10)","text":""},{"location":"changelog.html#fix_56","title":"Fix","text":"<ul> <li>Qt6 fixes for Dialog classes</li> </ul>"},{"location":"changelog.html#v110-2023-04-10","title":"v1.1.0 (2023-04-10)","text":""},{"location":"changelog.html#feat_49","title":"Feat","text":"<ul> <li>Image: add as_bytes method</li> </ul>"},{"location":"changelog.html#v100-2023-04-07","title":"v1.0.0 (2023-04-07)","text":""},{"location":"changelog.html#feat_50","title":"Feat","text":"<ul> <li>MultimediaWidgets for Qt6</li> <li>get rid of mro fuckery</li> <li>re-add location module</li> </ul>"},{"location":"changelog.html#fix_57","title":"Fix","text":"<ul> <li>remove title property for widgets</li> </ul>"},{"location":"api/bluetooth.html","title":"bluetooth module","text":"<p>bluetooth module.</p> <p>contains QtBluetooth-based classes</p>"},{"location":"api/bluetooth.html#prettyqt.bluetooth.BluetoothDeviceDiscoveryAgent","title":"<code>BluetoothDeviceDiscoveryAgent</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtBluetooth.QBluetoothDeviceDiscoveryAgent</code></p> Source code in <code>prettyqt\\bluetooth\\bluetoothdevicediscoveryagent.py</code> <pre><code>class BluetoothDeviceDiscoveryAgent(\ncore.ObjectMixin, QtBluetooth.QBluetoothDeviceDiscoveryAgent\n):\ndevice_discovered = core.Signal(object)  # bluetooth.BluetoothDeviceInfo casts signal.\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.deviceDiscovered.connect(self._on_device_discovered)\ndef _on_device_discovered(self, info):\ninfo = bluetooth.BluetoothDeviceInfo(info)\nself.device_discovered.emit(info)\n# def set_inquiry_type(self, typ: InquiryTypeStr):\n#     \"\"\"Set inquiry type.\n#     Args:\n#         typ: inquiry type\n#     \"\"\"\n#     self.setInquiryType(INQUIRY_TYPES.get_enum_value(typ))\n# def get_inquiry_type(self) -&gt; InquiryTypeStr:\n#     \"\"\"Get the current inquiry type.\n#     Returns:\n#         inquiry type\n#     \"\"\"\n#     return INQUIRY_TYPES.inverse[self.inquiryType()]\ndef start_discovery(self, classic: bool = True, low_energy: bool = True):\n\"\"\"Start discovery of bluetooth devices.\"\"\"\nflag = QtBluetooth.QBluetoothDeviceDiscoveryAgent.NoMethod\nif classic:\nflag |= QtBluetooth.QBluetoothDeviceDiscoveryAgent.ClassicMethod\nif low_energy:\nflag |= QtBluetooth.QBluetoothDeviceDiscoveryAgent.LowEnergyMethod\nself.start(flag)\ndef get_error(self) -&gt; ErrorStr:\n\"\"\"Get error type if available.\"\"\"\nreturn ERROR.inverse[self.error()]\ndef get_supported_discovery_methods(self) -&gt; list[DiscoveryMethodStr]:\n\"\"\"Return a list of supported discovery methods.\"\"\"\nreturn DISCOVERY_METHODS.get_list(self.supportedDiscoveryMethods())\n</code></pre>"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothdevicediscoveryagent.BluetoothDeviceDiscoveryAgent.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Get error type if available.</p> Source code in <code>prettyqt\\bluetooth\\bluetoothdevicediscoveryagent.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Get error type if available.\"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothdevicediscoveryagent.BluetoothDeviceDiscoveryAgent.get_supported_discovery_methods","title":"<code>get_supported_discovery_methods() -&gt; list[DiscoveryMethodStr]</code>","text":"<p>Return a list of supported discovery methods.</p> Source code in <code>prettyqt\\bluetooth\\bluetoothdevicediscoveryagent.py</code> <pre><code>def get_supported_discovery_methods(self) -&gt; list[DiscoveryMethodStr]:\n\"\"\"Return a list of supported discovery methods.\"\"\"\nreturn DISCOVERY_METHODS.get_list(self.supportedDiscoveryMethods())\n</code></pre>"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothdevicediscoveryagent.BluetoothDeviceDiscoveryAgent.start_discovery","title":"<code>start_discovery(classic: bool = True, low_energy: bool = True)</code>","text":"<p>Start discovery of bluetooth devices.</p> Source code in <code>prettyqt\\bluetooth\\bluetoothdevicediscoveryagent.py</code> <pre><code>def start_discovery(self, classic: bool = True, low_energy: bool = True):\n\"\"\"Start discovery of bluetooth devices.\"\"\"\nflag = QtBluetooth.QBluetoothDeviceDiscoveryAgent.NoMethod\nif classic:\nflag |= QtBluetooth.QBluetoothDeviceDiscoveryAgent.ClassicMethod\nif low_energy:\nflag |= QtBluetooth.QBluetoothDeviceDiscoveryAgent.LowEnergyMethod\nself.start(flag)\n</code></pre>"},{"location":"api/bluetooth.html#prettyqt.bluetooth.BluetoothLocalDevice","title":"<code>BluetoothLocalDevice</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtBluetooth.QBluetoothLocalDevice</code></p> Source code in <code>prettyqt\\bluetooth\\bluetoothlocaldevice.py</code> <pre><code>class BluetoothLocalDevice(core.ObjectMixin, QtBluetooth.QBluetoothLocalDevice):\ndef __bool__(self):\nreturn self.isValid()\ndef __repr__(self):\nreturn get_repr(self, self.address())\ndef get_error(self) -&gt; ErrorStr:\nreturn ERROR.inverse[self.error()]\ndef set_host_mode(self, mode: HostModeStr | HostMode):\n\"\"\"Set host mode.\n        Args:\n            mode: host mode to use\n        \"\"\"\nself.setGridStyle(HOST_MODE.get_enum_value(mode))\ndef get_host_mode(self) -&gt; HostModeStr:\n\"\"\"Return host mode.\n        Returns:\n            host mode\n        \"\"\"\nreturn HOST_MODE.inverse[self.gridStyle()]\ndef get_pairing_status(\nself, address: QtBluetooth.QBluetoothAddress | int | str\n) -&gt; PairingStr:\n\"\"\"Return pairing status.\n        Arguments:\n            address: bluetooth address\n        Returns:\n            pairing status\n        \"\"\"\nif isinstance(address, int | str):\naddress = QtBluetooth.QBluetoothAddress(address)\nreturn PAIRING.inverse[self.pairingStatus(address)]\ndef request_pairing(\nself, address: QtBluetooth.QBluetoothAddress | int | str, pairing: PairingStr\n):\nif isinstance(address, int | str):\naddress = QtBluetooth.QBluetoothAddress(address)\nself.requestPairing(address, PAIRING[pairing])\ndef get_connected_devices(self) -&gt; list[bluetooth.BluetoothAddress]:\nreturn [bluetooth.BluetoothAddress(i) for i in self.connectedDevices()]\n@classmethod\ndef get_all_devices(cls) -&gt; list[bluetooth.BluetoothHostInfo]:\nreturn [bluetooth.BluetoothHostInfo(i) for i in cls.allDevices()]\n</code></pre>"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothlocaldevice.BluetoothLocalDevice.get_host_mode","title":"<code>get_host_mode() -&gt; HostModeStr</code>","text":"<p>Return host mode.</p> <p>Returns:</p> Type Description <code>HostModeStr</code> <p>host mode</p> Source code in <code>prettyqt\\bluetooth\\bluetoothlocaldevice.py</code> <pre><code>def get_host_mode(self) -&gt; HostModeStr:\n\"\"\"Return host mode.\n    Returns:\n        host mode\n    \"\"\"\nreturn HOST_MODE.inverse[self.gridStyle()]\n</code></pre>"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothlocaldevice.BluetoothLocalDevice.get_pairing_status","title":"<code>get_pairing_status(address: QtBluetooth.QBluetoothAddress | int | str) -&gt; PairingStr</code>","text":"<p>Return pairing status.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>QtBluetooth.QBluetoothAddress | int | str</code> <p>bluetooth address</p> required <p>Returns:</p> Type Description <code>PairingStr</code> <p>pairing status</p> Source code in <code>prettyqt\\bluetooth\\bluetoothlocaldevice.py</code> <pre><code>def get_pairing_status(\nself, address: QtBluetooth.QBluetoothAddress | int | str\n) -&gt; PairingStr:\n\"\"\"Return pairing status.\n    Arguments:\n        address: bluetooth address\n    Returns:\n        pairing status\n    \"\"\"\nif isinstance(address, int | str):\naddress = QtBluetooth.QBluetoothAddress(address)\nreturn PAIRING.inverse[self.pairingStatus(address)]\n</code></pre>"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothlocaldevice.BluetoothLocalDevice.set_host_mode","title":"<code>set_host_mode(mode: HostModeStr | HostMode)</code>","text":"<p>Set host mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>HostModeStr | HostMode</code> <p>host mode to use</p> required Source code in <code>prettyqt\\bluetooth\\bluetoothlocaldevice.py</code> <pre><code>def set_host_mode(self, mode: HostModeStr | HostMode):\n\"\"\"Set host mode.\n    Args:\n        mode: host mode to use\n    \"\"\"\nself.setGridStyle(HOST_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/charts.html","title":"charts module","text":"<p>Charts module.</p>"},{"location":"api/charts.html#prettyqt.charts.AbstractAxisMixin","title":"<code>AbstractAxisMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\charts\\abstractaxis.py</code> <pre><code>class AbstractAxisMixin(core.ObjectMixin):\ndef get_alignment(self) -&gt; constants.SideStr | None:\n\"\"\"Return current alignment.\n        Returns:\n            alignment\n        \"\"\"\nalignment = self.alignment()\nif alignment == constants.ALIGN_NONE:\nreturn None\nreturn constants.SIDES.inverse[alignment]\ndef get_orientation(self) -&gt; constants.OrientationStr | None:\n\"\"\"Return current orientation.\n        Returns:\n            orientation\n        \"\"\"\norientation = self.orientation()\nif orientation == constants.ORIENTATION_NONE:\nreturn None\nreturn constants.ORIENTATION.inverse[orientation]\ndef get_grid_line_color(self) -&gt; gui.Color:\nreturn gui.Color(self.gridLineColor())\ndef get_grid_line_pen(self) -&gt; gui.Pen:\nreturn gui.Pen(self.gridLinePen())\ndef get_line_pen(self) -&gt; gui.Pen:\nreturn gui.Pen(self.linePen())\ndef get_line_pen_color(self) -&gt; gui.Color:\nreturn gui.Color(self.linePenColor())\ndef get_labels_color(self) -&gt; gui.Color:\nreturn gui.Color(self.labelsColor())\ndef get_labels_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.labelsBrush())\ndef get_labels_font(self) -&gt; gui.Font:\nreturn gui.Font(self.labelsFont())\ndef get_title_font(self) -&gt; gui.Font:\nreturn gui.Font(self.titleFont())\ndef get_title_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.titleBrush())\ndef get_shades_color(self) -&gt; gui.Color:\nreturn gui.Color(self.shadesColor())\ndef get_shades_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.shadesBrush())\ndef get_shades_pen(self) -&gt; gui.Pen:\nreturn gui.Pen(self.shadesPen())\ndef get_shades_border_color(self) -&gt; gui.Color:\nreturn gui.Color(self.shadesBorderColor())\ndef get_minor_grid_line_pen(self) -&gt; gui.Pen:\nreturn gui.Pen(self.minorGridLinePen())\ndef get_minor_grid_line_color(self) -&gt; gui.Color:\nreturn gui.Color(self.minorGridLineColor())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxisMixin.get_alignment","title":"<code>get_alignment() -&gt; constants.SideStr | None</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.SideStr | None</code> <p>alignment</p> Source code in <code>prettyqt\\charts\\abstractaxis.py</code> <pre><code>def get_alignment(self) -&gt; constants.SideStr | None:\n\"\"\"Return current alignment.\n    Returns:\n        alignment\n    \"\"\"\nalignment = self.alignment()\nif alignment == constants.ALIGN_NONE:\nreturn None\nreturn constants.SIDES.inverse[alignment]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxisMixin.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr | None</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr | None</code> <p>orientation</p> Source code in <code>prettyqt\\charts\\abstractaxis.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr | None:\n\"\"\"Return current orientation.\n    Returns:\n        orientation\n    \"\"\"\norientation = self.orientation()\nif orientation == constants.ORIENTATION_NONE:\nreturn None\nreturn constants.ORIENTATION.inverse[orientation]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.AbstractBarSeriesMixin","title":"<code>AbstractBarSeriesMixin</code>","text":"<p>         Bases: <code>charts.AbstractSeriesMixin</code></p> Source code in <code>prettyqt\\charts\\abstractbarseries.py</code> <pre><code>class AbstractBarSeriesMixin(charts.AbstractSeriesMixin):\ndef __delitem__(self, item: int | QtCharts.QBarSet):\nif isinstance(item, int):\nbarsets = self.barSets()\nitem = barsets[item]\nself.remove(item)\ndef __getitem__(self, index: int) -&gt; QtCharts.QBarSet:\nbarsets = self.barSets()\nreturn barsets[index]\ndef set_labels_position(\nself, position: LabelsPositionStr | QtCharts.QAbstractBarSeries.LabelsPosition\n):\n\"\"\"Set the labels position.\n        Args:\n            position: labels position\n        \"\"\"\nself.setLabelsPosition(LABELS_POSITIONS[position])\ndef get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n        Returns:\n            labels position\n        \"\"\"\nreturn LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeriesMixin.get_labels_position","title":"<code>get_labels_position() -&gt; LabelsPositionStr</code>","text":"<p>Return current labels position.</p> <p>Returns:</p> Type Description <code>LabelsPositionStr</code> <p>labels position</p> Source code in <code>prettyqt\\charts\\abstractbarseries.py</code> <pre><code>def get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n    Returns:\n        labels position\n    \"\"\"\nreturn LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeriesMixin.set_labels_position","title":"<code>set_labels_position(position: LabelsPositionStr | QtCharts.QAbstractBarSeries.LabelsPosition)</code>","text":"<p>Set the labels position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>LabelsPositionStr | QtCharts.QAbstractBarSeries.LabelsPosition</code> <p>labels position</p> required Source code in <code>prettyqt\\charts\\abstractbarseries.py</code> <pre><code>def set_labels_position(\nself, position: LabelsPositionStr | QtCharts.QAbstractBarSeries.LabelsPosition\n):\n\"\"\"Set the labels position.\n    Args:\n        position: labels position\n    \"\"\"\nself.setLabelsPosition(LABELS_POSITIONS[position])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.AbstractSeriesMixin","title":"<code>AbstractSeriesMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> <p>QAbstractSeries with some custom properties.</p> Source code in <code>prettyqt\\charts\\abstractseries.py</code> <pre><code>class AbstractSeriesMixin(core.ObjectMixin):\n\"\"\"QAbstractSeries with some custom properties.\"\"\"\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself._group = \"\"\ndef get_group(self):\nreturn self._group\ndef set_group(self, value):\nself._group = value\ngroup = core.Property(str, get_group, set_group)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.CategoryAxis","title":"<code>CategoryAxis</code>","text":"<p>         Bases: <code>charts.ValueAxisMixin</code>, <code>QtCharts.QCategoryAxis</code></p> Source code in <code>prettyqt\\charts\\categoryaxis.py</code> <pre><code>class CategoryAxis(charts.ValueAxisMixin, QtCharts.QCategoryAxis):\ndef __delitem__(self, index: str):\nself.remove(index)\ndef __getitem__(self, label: int | slice) -&gt; str | list[str]:\nreturn self.categoriesLabels()[label]\ndef __setitem__(self, index: str, value: str):\nself.replaceLabel(index, value)\ndef __iter__(self) -&gt; Iterator[str]:\nreturn iter(self.categoriesLabels())\ndef __add__(self, other: tuple[str, int]) -&gt; CategoryAxis:\nself.append(*other)\nreturn self\ndef __len__(self):\n# needed for PySide6\nreturn self.count()\ndef set_labels_position(\nself, position: LabelsPositionStr | QtCharts.QCategoryAxis.AxisLabelsPosition\n):\n\"\"\"Set the labels position.\n        Args:\n            position: labels position\n        \"\"\"\nself.setLabelsPosition(LABELS_POSITIONS.get_enum_value(position))\ndef get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n        Returns:\n            labels position\n        \"\"\"\nreturn LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.get_labels_position","title":"<code>get_labels_position() -&gt; LabelsPositionStr</code>","text":"<p>Return current labels position.</p> <p>Returns:</p> Type Description <code>LabelsPositionStr</code> <p>labels position</p> Source code in <code>prettyqt\\charts\\categoryaxis.py</code> <pre><code>def get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n    Returns:\n        labels position\n    \"\"\"\nreturn LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.set_labels_position","title":"<code>set_labels_position(position: LabelsPositionStr | QtCharts.QCategoryAxis.AxisLabelsPosition)</code>","text":"<p>Set the labels position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>LabelsPositionStr | QtCharts.QCategoryAxis.AxisLabelsPosition</code> <p>labels position</p> required Source code in <code>prettyqt\\charts\\categoryaxis.py</code> <pre><code>def set_labels_position(\nself, position: LabelsPositionStr | QtCharts.QCategoryAxis.AxisLabelsPosition\n):\n\"\"\"Set the labels position.\n    Args:\n        position: labels position\n    \"\"\"\nself.setLabelsPosition(LABELS_POSITIONS.get_enum_value(position))\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.ChartMixin","title":"<code>ChartMixin</code>","text":"<p>         Bases: <code>widgets.GraphicsWidgetMixin</code></p> Source code in <code>prettyqt\\charts\\chart.py</code> <pre><code>class ChartMixin(widgets.GraphicsWidgetMixin):\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.max_x = 0\nself.max_y = 0\nself.min_x = 0\nself.min_y = 0\nself.adjust_style_to_palette()\ngui.GuiApplication.styleHints().colorSchemeChanged.connect(\nself.adjust_style_to_palette\n)\ndef adjust_style_to_palette(self):\npal = gui.GuiApplication.get_palette()\nstyle = \"Dark\" if pal.is_dark() else \"Light\"\nself.set_theme(style)\ndef get_axes(\nself,\norientation: constants.OrientationStr | None = None,\nseries: QtCharts.QAbstractBarSeries | None = None,\n) -&gt; list[QtCharts.QAbstractAxis]:\nif orientation is None:\norientation = constants.HORIZONTAL | constants.VERTICAL\nreturn self.axes(constants.ORIENTATION[orientation], series)\ndef update_boundaries(self):\n\"\"\"Set new min/max values based on axis.\"\"\"\nif axis_x := self.get_axes(\"horizontal\"):\nself.max_x = axis_x[0].max()\nself.min_x = axis_x[0].min()\nif axis_y := self.get_axes(\"vertical\"):\nself.max_y = axis_y[0].max()\nself.min_y = axis_y[0].min()\ndef hide_legend(self):\nself.legend().hide()\ndef show_legend(self):\nself.legend().show()\ndef get_legend(self) -&gt; charts.Legend:\nreturn charts.Legend(self.legend())\ndef set_legend_alignment(\nself, alignment: constants.SideStr | constants.AlignmentFlag\n):\nself.legend().setAlignment(constants.SIDES[alignment])\ndef set_theme(self, theme_name: ThemeStr):\nself.setTheme(THEMES[theme_name])\ndef set_margins(self, margins: datatypes.MarginsType):\nmargins = datatypes.to_margins(margins)\nself.setMargins(margins)\ndef set_animation_options(self, option: AnimationOptionStr):\nself.setAnimationOptions(ANIMATION_OPTIONS[option])\ndef apply_nice_numbers(self):\n\"\"\"Adjust both axis to display nice round numbers.\"\"\"\nfor axis in self.get_axes():\naxis.applyNiceNumbers()\ndef zoom_by_factor(self, factor: float):\n\"\"\"Zoom in/out by factor (1.0 = no change).\n        Make sure that we dont zoom out too far\n        \"\"\"\nself.zoom(factor)\nif axis_x := self.get_axes(\"horizontal\"):\nif axis_x[0].min() &lt; self.min_x:\naxis_x[0].setMin(self.min_x)\nif axis_x[0].max() &gt; self.max_x:\naxis_x[0].setMax(self.max_x)\nif axis_y := self.get_axes(\"vertical\"):\nif axis_y[0].max() &gt; self.max_y:\naxis_y[0].setMax(self.max_y)\n# always bottom-align when zooming for now. should perhaps become optional.\n# if axis_y[0].min() &lt; self.min_y:\naxis_y[0].setMin(max(0, self.min_y))\ndef get_chart_type(self) -&gt; ChartTypeStr:\nreturn CHART_TYPES.inverse[self.chartType()]\ndef get_margins(self) -&gt; core.Margins:\nreturn core.Margins(self.margins())\ndef get_plot_area(self) -&gt; core.RectF:\nreturn core.RectF(self.plotArea())\ndef get_locale(self) -&gt; core.Locale:\nreturn core.Locale(self.locale())\ndef get_theme(self) -&gt; ThemeStr:\nreturn THEMES.inverse[self.theme()]\ndef get_animation_options(self) -&gt; list[AnimationOptionStr]:\nreturn ANIMATION_OPTIONS.get_list(self.animationOptions())\ndef get_animation_easing_curve(self) -&gt; core.EasingCurve:\nreturn core.EasingCurve(self.animationEasingCurve())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chart.ChartMixin.apply_nice_numbers","title":"<code>apply_nice_numbers()</code>","text":"<p>Adjust both axis to display nice round numbers.</p> Source code in <code>prettyqt\\charts\\chart.py</code> <pre><code>def apply_nice_numbers(self):\n\"\"\"Adjust both axis to display nice round numbers.\"\"\"\nfor axis in self.get_axes():\naxis.applyNiceNumbers()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chart.ChartMixin.update_boundaries","title":"<code>update_boundaries()</code>","text":"<p>Set new min/max values based on axis.</p> Source code in <code>prettyqt\\charts\\chart.py</code> <pre><code>def update_boundaries(self):\n\"\"\"Set new min/max values based on axis.\"\"\"\nif axis_x := self.get_axes(\"horizontal\"):\nself.max_x = axis_x[0].max()\nself.min_x = axis_x[0].min()\nif axis_y := self.get_axes(\"vertical\"):\nself.max_y = axis_y[0].max()\nself.min_y = axis_y[0].min()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chart.ChartMixin.zoom_by_factor","title":"<code>zoom_by_factor(factor: float)</code>","text":"<p>Zoom in/out by factor (1.0 = no change).</p> <p>Make sure that we dont zoom out too far</p> Source code in <code>prettyqt\\charts\\chart.py</code> <pre><code>def zoom_by_factor(self, factor: float):\n\"\"\"Zoom in/out by factor (1.0 = no change).\n    Make sure that we dont zoom out too far\n    \"\"\"\nself.zoom(factor)\nif axis_x := self.get_axes(\"horizontal\"):\nif axis_x[0].min() &lt; self.min_x:\naxis_x[0].setMin(self.min_x)\nif axis_x[0].max() &gt; self.max_x:\naxis_x[0].setMax(self.max_x)\nif axis_y := self.get_axes(\"vertical\"):\nif axis_y[0].max() &gt; self.max_y:\naxis_y[0].setMax(self.max_y)\n# always bottom-align when zooming for now. should perhaps become optional.\n# if axis_y[0].min() &lt; self.min_y:\naxis_y[0].setMin(max(0, self.min_y))\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.ChartView","title":"<code>ChartView</code>","text":"<p>         Bases: <code>widgets.GraphicsViewMixin</code>, <code>QtCharts.QChartView</code></p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>class ChartView(widgets.GraphicsViewMixin, QtCharts.QChartView):\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nif not args or not isinstance(args[0], QtCharts.QChart):\nself.setChart(charts.Chart())\nself.setRenderHint(gui.Painter.RenderHint.Antialiasing)\nself.set_rubber_band(\"rectangle\")\n# self.setDragMode(self.RubberBandDrag)\ndef keyPressEvent(self, event: QtGui.QKeyEvent):\n\"\"\"Handle keypress events to allow navigation via keyboard.\"\"\"\nmatch event.key():\ncase constants.Key.Key_Escape:\nself.chart().zoomReset()\ncase constants.Key.Key_Plus:\nself.chart().zoom_by_factor(ZOOM_IN_FACTOR)\ncase constants.Key.Key_Minus:\nself.chart().zoom_by_factor(ZOOM_OUT_FACTOR)\ncase constants.Key.Key_Left:\nself.chart().scroll(-SCROLL_STEP_SIZE, 0)\ncase constants.Key.Key_Right:\nself.chart().scroll(SCROLL_STEP_SIZE, 0)\ncase constants.Key.Key_Up:\nself.chart().scroll(0, SCROLL_STEP_SIZE)\ncase constants.Key.Key_Down:\nself.chart().scroll(0, -SCROLL_STEP_SIZE)\ncase constants.Key.Key_0:\nself.chart().apply_nice_numbers()\ncase _:\nsuper().keyPressEvent(event)\nreturn\nevent.accept()\ndef wheelEvent(self, event: QtGui.QWheelEvent):\n\"\"\"Handle wheel event for zooming.\"\"\"\nfct = ZOOM_IN_FACTOR if event.angleDelta().y() &gt; 0 else ZOOM_OUT_FACTOR\nself.chart().zoom_by_factor(fct)\nevent.accept()\ndef mouseReleaseEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\nif event.button() == constants.MouseButton.RightButton:\nwidgets.Application.restoreOverrideCursor()\nevent.accept()\nreturn\nsuper().mouseReleaseEvent(event)\ndef mousePressEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\nif event.button() == constants.MouseButton.RightButton:\nwidgets.Application.set_override_cursor(\"size_all\")\nself.last_mouse_pos = event.position()\nevent.accept()\nsuper().mousePressEvent(event)\ndef mouseMoveEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n# pan the chart with a middle mouse drag\nif event.buttons() &amp; constants.MouseButton.RightButton:  # type: ignore\nif not self.last_mouse_pos:\nreturn\npos_diff = event.position() - self.last_mouse_pos\nself.chart().scroll(-pos_diff.x(), pos_diff.y())\nself.last_mouse_pos = event.position()\nevent.accept()\nsuper().mouseMoveEvent(event)\n@core.Slot()\ndef save_as_image(self):\n\"\"\"Let user choose folder and save chart as an image file.\"\"\"\ndlg = widgets.FileDialog(mode=\"save\", caption=\"Save image\")\nfilters = {\"Bmp files\": [\".bmp\"], \"Jpeg files\": [\".jpg\"], \"Png files\": [\".png\"]}\ndlg.set_extension_filter(filters)\nfilename = dlg.open_file()\nif not filename:\nreturn\nself.chart().show_legend()\nimage = self.get_image()\nimage.save(str(filename[0]))\nself.chart().hide_legend()\ndef set_rubber_band(self, typ: RubberBandStr | QtCharts.QChartView.RubberBand):\n\"\"\"Set the rubber band type.\n        Args:\n            typ: rubber band type\n        \"\"\"\nself.setRubberBand(RUBBER_BAND.get_enum_value(typ))\ndef get_rubber_band(self) -&gt; RubberBandStr:\n\"\"\"Return current rubber band type.\n        Returns:\n            Rubber band type\n        \"\"\"\nreturn RUBBER_BAND.inverse[self.rubberBand()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.get_rubber_band","title":"<code>get_rubber_band() -&gt; RubberBandStr</code>","text":"<p>Return current rubber band type.</p> <p>Returns:</p> Type Description <code>RubberBandStr</code> <p>Rubber band type</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def get_rubber_band(self) -&gt; RubberBandStr:\n\"\"\"Return current rubber band type.\n    Returns:\n        Rubber band type\n    \"\"\"\nreturn RUBBER_BAND.inverse[self.rubberBand()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.keyPressEvent","title":"<code>keyPressEvent(event: QtGui.QKeyEvent)</code>","text":"<p>Handle keypress events to allow navigation via keyboard.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def keyPressEvent(self, event: QtGui.QKeyEvent):\n\"\"\"Handle keypress events to allow navigation via keyboard.\"\"\"\nmatch event.key():\ncase constants.Key.Key_Escape:\nself.chart().zoomReset()\ncase constants.Key.Key_Plus:\nself.chart().zoom_by_factor(ZOOM_IN_FACTOR)\ncase constants.Key.Key_Minus:\nself.chart().zoom_by_factor(ZOOM_OUT_FACTOR)\ncase constants.Key.Key_Left:\nself.chart().scroll(-SCROLL_STEP_SIZE, 0)\ncase constants.Key.Key_Right:\nself.chart().scroll(SCROLL_STEP_SIZE, 0)\ncase constants.Key.Key_Up:\nself.chart().scroll(0, SCROLL_STEP_SIZE)\ncase constants.Key.Key_Down:\nself.chart().scroll(0, -SCROLL_STEP_SIZE)\ncase constants.Key.Key_0:\nself.chart().apply_nice_numbers()\ncase _:\nsuper().keyPressEvent(event)\nreturn\nevent.accept()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseMoveEvent","title":"<code>mouseMoveEvent(event: QtGui.QMouseEvent)</code>","text":"<p>Override to allow dragging the chart.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def mouseMoveEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n# pan the chart with a middle mouse drag\nif event.buttons() &amp; constants.MouseButton.RightButton:  # type: ignore\nif not self.last_mouse_pos:\nreturn\npos_diff = event.position() - self.last_mouse_pos\nself.chart().scroll(-pos_diff.x(), pos_diff.y())\nself.last_mouse_pos = event.position()\nevent.accept()\nsuper().mouseMoveEvent(event)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mousePressEvent","title":"<code>mousePressEvent(event: QtGui.QMouseEvent)</code>","text":"<p>Override to allow dragging the chart.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def mousePressEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\nif event.button() == constants.MouseButton.RightButton:\nwidgets.Application.set_override_cursor(\"size_all\")\nself.last_mouse_pos = event.position()\nevent.accept()\nsuper().mousePressEvent(event)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseReleaseEvent","title":"<code>mouseReleaseEvent(event: QtGui.QMouseEvent)</code>","text":"<p>Override to allow dragging the chart.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def mouseReleaseEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\nif event.button() == constants.MouseButton.RightButton:\nwidgets.Application.restoreOverrideCursor()\nevent.accept()\nreturn\nsuper().mouseReleaseEvent(event)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.save_as_image","title":"<code>save_as_image()</code>","text":"<p>Let user choose folder and save chart as an image file.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>@core.Slot()\ndef save_as_image(self):\n\"\"\"Let user choose folder and save chart as an image file.\"\"\"\ndlg = widgets.FileDialog(mode=\"save\", caption=\"Save image\")\nfilters = {\"Bmp files\": [\".bmp\"], \"Jpeg files\": [\".jpg\"], \"Png files\": [\".png\"]}\ndlg.set_extension_filter(filters)\nfilename = dlg.open_file()\nif not filename:\nreturn\nself.chart().show_legend()\nimage = self.get_image()\nimage.save(str(filename[0]))\nself.chart().hide_legend()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.set_rubber_band","title":"<code>set_rubber_band(typ: RubberBandStr | QtCharts.QChartView.RubberBand)</code>","text":"<p>Set the rubber band type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>RubberBandStr | QtCharts.QChartView.RubberBand</code> <p>rubber band type</p> required Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def set_rubber_band(self, typ: RubberBandStr | QtCharts.QChartView.RubberBand):\n\"\"\"Set the rubber band type.\n    Args:\n        typ: rubber band type\n    \"\"\"\nself.setRubberBand(RUBBER_BAND.get_enum_value(typ))\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.wheelEvent","title":"<code>wheelEvent(event: QtGui.QWheelEvent)</code>","text":"<p>Handle wheel event for zooming.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def wheelEvent(self, event: QtGui.QWheelEvent):\n\"\"\"Handle wheel event for zooming.\"\"\"\nfct = ZOOM_IN_FACTOR if event.angleDelta().y() &gt; 0 else ZOOM_OUT_FACTOR\nself.chart().zoom_by_factor(fct)\nevent.accept()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.Legend","title":"<code>Legend</code>","text":"<p>         Bases: <code>widgets.GraphicsWidgetMixin</code></p> Source code in <code>prettyqt\\charts\\legend.py</code> <pre><code>class Legend(widgets.GraphicsWidgetMixin):\ndef __init__(self, item: QtCharts.QLegend):\nself.item = item\ndef __getattr__(self, val):\nreturn getattr(self.item, val)\ndef serialize_fields(self):\nreturn dict(\nalignment=self.get_alignment(),\nbackground_visible=self.isBackgroundVisible(),\nborder_color=self.get_border_color(),\ncolor=self.get_color(),\nfont=self.get_font(),\nlabel_color=self.get_label_color(),\nmarker_shape=self.get_marker_shape(),\nreverse_markers=self.reverseMarkers(),\nshow_tooltips=self.showToolTips(),\n)\ndef set_alignment(self, alignment: constants.SideStr | QtCharts.QLegend.MarkerShape):\n\"\"\"Set the alignment of the legend.\n        Args:\n            alignment: alignment for the legend\n        \"\"\"\nself.setAlignment(constants.SIDES.get_enum_value(alignment))\ndef get_alignment(self) -&gt; constants.SideStr:\n\"\"\"Return current alignment.\n        Returns:\n            alignment\n        \"\"\"\nreturn constants.SIDES.inverse[self.alignment()]\ndef set_marker_shape(self, shape: MarkerShapeStr):\n\"\"\"Set the marker shape.\n        Args:\n            shape: marker shape\n        \"\"\"\nself.setMarkerShape(MARKER_SHAPES.get_enum_value(shape))\ndef get_marker_shape(self) -&gt; MarkerShapeStr:\n\"\"\"Return current marker shape.\n        Returns:\n            Marker shape\n        \"\"\"\nreturn MARKER_SHAPES.inverse[self.markerShape()]\ndef get_border_color(self) -&gt; gui.Color:\nreturn gui.Color(self.borderColor())\ndef get_color(self) -&gt; gui.Color:\nreturn gui.Color(self.color())\ndef get_label_color(self) -&gt; gui.Color:\nreturn gui.Color(self.labelColor())\ndef get_font(self) -&gt; gui.Font:\nreturn gui.Font(self.font())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_alignment","title":"<code>get_alignment() -&gt; constants.SideStr</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.SideStr</code> <p>alignment</p> Source code in <code>prettyqt\\charts\\legend.py</code> <pre><code>def get_alignment(self) -&gt; constants.SideStr:\n\"\"\"Return current alignment.\n    Returns:\n        alignment\n    \"\"\"\nreturn constants.SIDES.inverse[self.alignment()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_marker_shape","title":"<code>get_marker_shape() -&gt; MarkerShapeStr</code>","text":"<p>Return current marker shape.</p> <p>Returns:</p> Type Description <code>MarkerShapeStr</code> <p>Marker shape</p> Source code in <code>prettyqt\\charts\\legend.py</code> <pre><code>def get_marker_shape(self) -&gt; MarkerShapeStr:\n\"\"\"Return current marker shape.\n    Returns:\n        Marker shape\n    \"\"\"\nreturn MARKER_SHAPES.inverse[self.markerShape()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_alignment","title":"<code>set_alignment(alignment: constants.SideStr | QtCharts.QLegend.MarkerShape)</code>","text":"<p>Set the alignment of the legend.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.SideStr | QtCharts.QLegend.MarkerShape</code> <p>alignment for the legend</p> required Source code in <code>prettyqt\\charts\\legend.py</code> <pre><code>def set_alignment(self, alignment: constants.SideStr | QtCharts.QLegend.MarkerShape):\n\"\"\"Set the alignment of the legend.\n    Args:\n        alignment: alignment for the legend\n    \"\"\"\nself.setAlignment(constants.SIDES.get_enum_value(alignment))\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_marker_shape","title":"<code>set_marker_shape(shape: MarkerShapeStr)</code>","text":"<p>Set the marker shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>MarkerShapeStr</code> <p>marker shape</p> required Source code in <code>prettyqt\\charts\\legend.py</code> <pre><code>def set_marker_shape(self, shape: MarkerShapeStr):\n\"\"\"Set the marker shape.\n    Args:\n        shape: marker shape\n    \"\"\"\nself.setMarkerShape(MARKER_SHAPES.get_enum_value(shape))\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.LineSeries","title":"<code>LineSeries</code>","text":"<p>         Bases: <code>charts.XYSeriesMixin</code>, <code>QtCharts.QLineSeries</code></p> <p>QLineSeries with some custom properties.</p> Source code in <code>prettyqt\\charts\\lineseries.py</code> <pre><code>class LineSeries(charts.XYSeriesMixin, QtCharts.QLineSeries):\n\"\"\"QLineSeries with some custom properties.\"\"\"\npass\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.PieSlice","title":"<code>PieSlice</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtCharts.QPieSlice</code></p> Source code in <code>prettyqt\\charts\\pieslice.py</code> <pre><code>class PieSlice(core.ObjectMixin, QtCharts.QPieSlice):\ndef __repr__(self):\nreturn get_repr(self, self.label(), self.value())\ndef set_label_position(self, position: LabelPositionStr):\n\"\"\"Set the label position.\n        Args:\n            position: label position\n        \"\"\"\nself.setLabelPosition(LABEL_POSITION.get_enum_value(position))\ndef get_label_position(self) -&gt; LabelPositionStr:\n\"\"\"Return current label position.\n        Returns:\n            label position\n        \"\"\"\nreturn LABEL_POSITION.inverse[self.labelPosition()]\ndef get_label_font(self) -&gt; gui.Font:\nreturn gui.Font(self.labelFont())\ndef get_label_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.labelBrush())\ndef get_label_color(self) -&gt; gui.Color:\nreturn gui.Color(self.labelColor())\ndef get_pen(self) -&gt; gui.Pen:\nreturn gui.Pen(self.pen())\ndef get_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.brush())\ndef get_color(self) -&gt; gui.Color:\nreturn gui.Color(self.color())\ndef get_border_color(self) -&gt; gui.Color:\nreturn gui.Color(self.borderColor())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.get_label_position","title":"<code>get_label_position() -&gt; LabelPositionStr</code>","text":"<p>Return current label position.</p> <p>Returns:</p> Type Description <code>LabelPositionStr</code> <p>label position</p> Source code in <code>prettyqt\\charts\\pieslice.py</code> <pre><code>def get_label_position(self) -&gt; LabelPositionStr:\n\"\"\"Return current label position.\n    Returns:\n        label position\n    \"\"\"\nreturn LABEL_POSITION.inverse[self.labelPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.set_label_position","title":"<code>set_label_position(position: LabelPositionStr)</code>","text":"<p>Set the label position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>LabelPositionStr</code> <p>label position</p> required Source code in <code>prettyqt\\charts\\pieslice.py</code> <pre><code>def set_label_position(self, position: LabelPositionStr):\n\"\"\"Set the label position.\n    Args:\n        position: label position\n    \"\"\"\nself.setLabelPosition(LABEL_POSITION.get_enum_value(position))\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.ValueAxisMixin","title":"<code>ValueAxisMixin</code>","text":"<p>         Bases: <code>charts.AbstractAxisMixin</code></p> Source code in <code>prettyqt\\charts\\valueaxis.py</code> <pre><code>class ValueAxisMixin(charts.AbstractAxisMixin):\ndef set_tick_type(self, tick_type: TickTypeStr | QtCharts.QValueAxis.TickType):\n\"\"\"Set the tick type of the legend.\n        Args:\n            tick_type: tick type for the legend\n        \"\"\"\nself.setTickType(TICK_TYPES.get_enum_value(tick_type))\ndef get_tick_type(self) -&gt; TickTypeStr:\n\"\"\"Return current tick type.\n        Returns:\n            tick_type\n        \"\"\"\nreturn TICK_TYPES.inverse[self.tickType()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxisMixin.get_tick_type","title":"<code>get_tick_type() -&gt; TickTypeStr</code>","text":"<p>Return current tick type.</p> <p>Returns:</p> Type Description <code>TickTypeStr</code> <p>tick_type</p> Source code in <code>prettyqt\\charts\\valueaxis.py</code> <pre><code>def get_tick_type(self) -&gt; TickTypeStr:\n\"\"\"Return current tick type.\n    Returns:\n        tick_type\n    \"\"\"\nreturn TICK_TYPES.inverse[self.tickType()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxisMixin.set_tick_type","title":"<code>set_tick_type(tick_type: TickTypeStr | QtCharts.QValueAxis.TickType)</code>","text":"<p>Set the tick type of the legend.</p> <p>Parameters:</p> Name Type Description Default <code>tick_type</code> <code>TickTypeStr | QtCharts.QValueAxis.TickType</code> <p>tick type for the legend</p> required Source code in <code>prettyqt\\charts\\valueaxis.py</code> <pre><code>def set_tick_type(self, tick_type: TickTypeStr | QtCharts.QValueAxis.TickType):\n\"\"\"Set the tick type of the legend.\n    Args:\n        tick_type: tick type for the legend\n    \"\"\"\nself.setTickType(TICK_TYPES.get_enum_value(tick_type))\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.XYSeriesMixin","title":"<code>XYSeriesMixin</code>","text":"<p>         Bases: <code>charts.AbstractSeriesMixin</code></p> <p>QXYSeries with some custom properties.</p> Source code in <code>prettyqt\\charts\\xyseries.py</code> <pre><code>class XYSeriesMixin(charts.AbstractSeriesMixin):\n\"\"\"QXYSeries with some custom properties.\"\"\"\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\n# self._process_name = \"\"\nself.setUseOpenGL()\ndef __setitem__(self, index: int, val: QtCore.QPointF):\nself.replace(index, val)\ndef __delitem__(self, index: int):\nself.remove(index)\n# def __setstate__(self, state):\n#     self.append(state[\"points\"])\n# def __reduce__(self):\n#     return type(self), (), self.__getstate__()\ndef __add__(self, other: QtCore.QPointF) -&gt; XYSeries:\nself.append(other)\nreturn self\ndef serialize_fields(self):\nif prettyqt.qt.API == \"pyqt6\":\npoints = [self.at(i) for i in range(self.count())]\nelse:\npoints = self.points()\nreturn dict(points=points)\ndef get_pen(self) -&gt; gui.Pen:\nreturn gui.Pen(self.pen())\ndef get_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.brush())\n</code></pre>"},{"location":"api/constants.html","title":"constants module","text":"<p>Constants module.</p>"},{"location":"api/core.html","title":"core module","text":"<p>Core module.</p> <p>Contains QtCore-based classes</p>"},{"location":"api/core.html#prettyqt.core.AbstractAnimationMixin","title":"<code>AbstractAnimationMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>class AbstractAnimationMixin(core.ObjectMixin):\ndef __len__(self):\nreturn self.duration()\ndef __and__(self, other: QtCore.QAbstractAnimation) -&gt; core.SequentialAnimationGroup:\ngroup = core.SequentialAnimationGroup()\ngroup.addAnimation(self)\ngroup.addAnimation(other)\nreturn group\ndef __or__(self, other: QtCore.QAbstractAnimation) -&gt; core.ParallelAnimationGroup:\ngroup = core.ParallelAnimationGroup()\ngroup.addAnimation(self)\ngroup.addAnimation(other)\nreturn group\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"direction\": DIRECTION, \"state\": STATE}\nreturn maps\ndef toggle_direction(self):\nDirection = AbstractAnimation.Direction\nis_forward = self.direction() == Direction.Forward\ndirection = Direction.Backward if is_forward else Direction.Forward\nself.setDirection(direction)\ndef set_direction(\nself, direction: DirectionStr | QtCore.QAbstractAnimation.Direction\n):\n\"\"\"Set animation direction.\n        Args:\n            direction: animation direction\n        \"\"\"\nself.setDirection(DIRECTION.get_enum_value(direction))\ndef get_direction(self) -&gt; DirectionStr:\n\"\"\"Get the current animation direction.\n        Returns:\n            animation direction\n        \"\"\"\nreturn DIRECTION.inverse[self.direction()]\ndef get_state(self) -&gt; StateStr:\n\"\"\"Get the current animation state.\n        Returns:\n            animation state\n        \"\"\"\nreturn STATE.inverse[self.state()]\ndef start_animation(\nself,\npolicy: DeletionPolicyStr | core.QAbstractAnimation.DeletionPolicy = \"keep\",\ninterval: int = 0,\nsingle_shot: bool = True,\n):\n\"\"\"Start the animation.\n        Args:\n            policy: animation policy\n            interval: time interval / delay for timer\n            single_shot: whether animation gets triggered once or in intervals\n        \"\"\"\nif policy in DELETION_POLICY.keys():\npolicy = DELETION_POLICY[policy]\nif interval:\nfn = functools.partial(self.start, policy)\nself.start_callback_timer(fn, interval, single_shot=single_shot)\nelse:\nself.start(policy)\ndef restart_animation(\nself,\npolicy: DeletionPolicyStr | QtCore.QAbstractAnimation.DeletionPolicy = \"keep\",\n):\n\"\"\"Restart the animation.\n        Args:\n            policy: animation policy\n        \"\"\"\nself.stop()\nself.start_animation(policy)\ndef run(self, delay: int = 0, single_shot: bool = True):\nself.start_callback_timer(self.start, delay, single_shot=single_shot)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.get_direction","title":"<code>get_direction() -&gt; DirectionStr</code>","text":"<p>Get the current animation direction.</p> <p>Returns:</p> Type Description <code>DirectionStr</code> <p>animation direction</p> Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>def get_direction(self) -&gt; DirectionStr:\n\"\"\"Get the current animation direction.\n    Returns:\n        animation direction\n    \"\"\"\nreturn DIRECTION.inverse[self.direction()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.get_state","title":"<code>get_state() -&gt; StateStr</code>","text":"<p>Get the current animation state.</p> <p>Returns:</p> Type Description <code>StateStr</code> <p>animation state</p> Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>def get_state(self) -&gt; StateStr:\n\"\"\"Get the current animation state.\n    Returns:\n        animation state\n    \"\"\"\nreturn STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.restart_animation","title":"<code>restart_animation(policy: DeletionPolicyStr | QtCore.QAbstractAnimation.DeletionPolicy = 'keep')</code>","text":"<p>Restart the animation.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>DeletionPolicyStr | QtCore.QAbstractAnimation.DeletionPolicy</code> <p>animation policy</p> <code>'keep'</code> Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>def restart_animation(\nself,\npolicy: DeletionPolicyStr | QtCore.QAbstractAnimation.DeletionPolicy = \"keep\",\n):\n\"\"\"Restart the animation.\n    Args:\n        policy: animation policy\n    \"\"\"\nself.stop()\nself.start_animation(policy)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.set_direction","title":"<code>set_direction(direction: DirectionStr | QtCore.QAbstractAnimation.Direction)</code>","text":"<p>Set animation direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>DirectionStr | QtCore.QAbstractAnimation.Direction</code> <p>animation direction</p> required Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>def set_direction(\nself, direction: DirectionStr | QtCore.QAbstractAnimation.Direction\n):\n\"\"\"Set animation direction.\n    Args:\n        direction: animation direction\n    \"\"\"\nself.setDirection(DIRECTION.get_enum_value(direction))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.start_animation","title":"<code>start_animation(policy: DeletionPolicyStr | core.QAbstractAnimation.DeletionPolicy = 'keep', interval: int = 0, single_shot: bool = True)</code>","text":"<p>Start the animation.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>DeletionPolicyStr | core.QAbstractAnimation.DeletionPolicy</code> <p>animation policy</p> <code>'keep'</code> <code>interval</code> <code>int</code> <p>time interval / delay for timer</p> <code>0</code> <code>single_shot</code> <code>bool</code> <p>whether animation gets triggered once or in intervals</p> <code>True</code> Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>def start_animation(\nself,\npolicy: DeletionPolicyStr | core.QAbstractAnimation.DeletionPolicy = \"keep\",\ninterval: int = 0,\nsingle_shot: bool = True,\n):\n\"\"\"Start the animation.\n    Args:\n        policy: animation policy\n        interval: time interval / delay for timer\n        single_shot: whether animation gets triggered once or in intervals\n    \"\"\"\nif policy in DELETION_POLICY.keys():\npolicy = DELETION_POLICY[policy]\nif interval:\nfn = functools.partial(self.start, policy)\nself.start_callback_timer(fn, interval, single_shot=single_shot)\nelse:\nself.start(policy)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.AbstractItemModelMixin","title":"<code>AbstractItemModelMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>class AbstractItemModelMixin(core.ObjectMixin):\nDEFAULT_FLAGS = (\nconstants.DRAG_ENABLED | constants.IS_ENABLED | constants.IS_SELECTABLE\n)\ndef __repr__(self):\nreturn f\"{type(self).__name__}: ({self.rowCount()}, {self.columnCount()})\"\ndef __len__(self) -&gt; int:\nreturn self.rowCount()\ndef __add__(\nself, other: QtCore.QAbstractItemModel\n) -&gt; core.ConcatenateTablesProxyModel:\nproxy = core.ConcatenateTablesProxyModel()\nproxy.addSourceModel(self)\nproxy.addSourceModel(other)\nreturn proxy\n@overload\ndef __getitem__(self, index: tuple[int, int] | int) -&gt; QtCore.QModelIndex:\n...\n@overload\ndef __getitem__(\nself, index: tuple[slice, int] | tuple[int, slice] | tuple[slice, slice]\n) -&gt; listdelegators.BaseListDelegator[QtCore.QModelIndex]:\n...\ndef __getitem__(\nself, index: tuple[int | slice, int | slice]\n) -&gt; QtCore.QModelIndex | listdelegators.BaseListDelegator[QtCore.QModelIndex]:\n# TODO: do proxies need mapToSource here?\nrowcount = self.rowCount()\ncolcount = self.columnCount()\nmatch index:\ncase int() as row, int() as col:\nif row &gt;= rowcount or col &gt;= rowcount:\nraise IndexError(index)\nreturn self.index(row, col)\ncase (row, col):\nindexes = [\nself.index(i, j)\nfor i, j in helpers.yield_positions(row, col, rowcount, colcount)\n]\nreturn listdelegators.BaseListDelegator(indexes)\ncase int() as row:\nif row &gt;= rowcount:\nraise IndexError(index)\n# this here breaks PySide6 IPython test...\nreturn self.index(row, 0)\ncase _:\nraise TypeError(index)\ndef set_data(\nself,\nindex: tuple[int | slice, int | slice] | core.ModelIndex,\nvalue: Any,\nrole=constants.EDIT_ROLE,\n):\nmatch index:\ncase core.ModelIndex():\nself.setData(index, value, role)\ncase (row, col):\nrowcount = self.rowCount()\ncolcount = self.columnCount()\nfor i, j in helpers.yield_positions(row, col, rowcount, colcount):\nself.setData(self.index(i, j), value, role)\ncase _:\nraise TypeError(index)\ndef check_index(\nself,\nindex: QtCore.QModelIndex,\nindex_is_valid: bool = False,\ndo_not_use_parent: bool = False,\nparent_is_invalid: bool = False,\n) -&gt; bool:\nflag = QtCore.QAbstractItemModel.CheckIndexOption.NoOption\nif index_is_valid:\nflag |= QtCore.QAbstractItemModel.CheckIndexOption.IndexIsValid\nif do_not_use_parent:\nflag |= QtCore.QAbstractItemModel.CheckIndexOption.DoNotUseParent\nif parent_is_invalid:\nflag |= QtCore.QAbstractItemModel.CheckIndexOption.ParentIsInvalid\ncheck_flag = QtCore.QAbstractItemModel.CheckIndexOption(0) | flag\nreturn self.checkIndex(index, check_flag)\n@contextlib.contextmanager\ndef change_layout(self):\n\"\"\"Context manager to change the layout.\n        wraps calls with correct signals\n        emitted at beginning: layoutAboutToBeChanged\n        emitted at end: layoutChanged\n        \"\"\"\nself.layoutAboutToBeChanged.emit()\nyield None\nself.layoutChanged.emit()\n@contextlib.contextmanager\ndef reset_model(self):\n\"\"\"Context manager to reset the model.\n        wraps calls with correct signals\n        emitted at beginning: beginResetModel\n        emitted at end: endResetModel\n        \"\"\"\nself.beginResetModel()\nyield None\nself.endResetModel()\ndef get_column_type(\nself,\ncolumn: int,\nrows_to_check: int = 5,\nrole=constants.DISPLAY_ROLE,\n) -&gt; type | None:\n\"\"\"Guess column data type by checking values of first rows with given role.\"\"\"\nto_check = min(rows_to_check, self.rowCount())\nif to_check == 0:\nreturn None\n# cant combine these or make them a generator, so we do two list comps.\nindexes = [self.index(row, column) for row in range(to_check)]\nvalues = [self.data(i, role=role) for i in indexes]\nif all(isinstance(i, bool) for i in values):\nreturn bool\nif all(isinstance(i, str) for i in values):\nreturn str\nif all(isinstance(i, int) for i in values):\nreturn int\nif all(isinstance(i, float) for i in values):\nreturn float\ncheck_values = [self.data(i, role=constants.CHECKSTATE_ROLE) for i in indexes]\nreturn bool if None not in check_values else None\ndef update_row(self, row: int):\nstart_index = self.index(row, 0)\nend_index = self.index(row, self.columnCount() - 1)\nself.dataChanged.emit(start_index, end_index)\ndef update_all(self):\ntop_left = self.index(0, 0)\nbottom_right = self.index(self.rowCount() - 1, self.columnCount() - 1)\nself.dataChanged.emit(top_left, bottom_right)\n@contextlib.contextmanager\ndef remove_row(self, row: int, parent: QtCore.QModelIndex | None = None):\nparent = QtCore.QModelIndex() if parent is None else parent\nself.beginRemoveRows(parent, row, row)\nyield None\nself.endRemoveRows()\n@contextlib.contextmanager\ndef remove_rows(\nself,\nfirst: int | None = None,\nlast: int | None = None,\nparent: QtCore.QModelIndex | None = None,\n):\nparent = QtCore.QModelIndex() if parent is None else parent\nfirst = first or 0\nlast = last if last is not None else self.rowCount()\nself.beginRemoveRows(parent, first, last)\nyield None\nself.endRemoveRows()\n@contextlib.contextmanager\ndef remove_columns(\nself,\nfirst: int | None = None,\nlast: int | None = None,\nparent: QtCore.QModelIndex | None = None,\n):\nparent = QtCore.QModelIndex() if parent is None else parent\nfirst = first or 0\nlast = last if last is not None else self.rowCount()\nself.beginRemoveColumns(parent, first, last)\nyield None\nself.endRemoveColumns()\n@contextlib.contextmanager\ndef insert_row(self, row: int, parent: QtCore.QModelIndex | None = None):\nparent = QtCore.QModelIndex() if parent is None else parent\nself.beginInsertRows(parent, row, row)\nyield None\nself.endInsertRows()\n@contextlib.contextmanager\ndef insert_rows(\nself,\nfirst: int | None = None,\nlast: int | None = None,\nparent: QtCore.QModelIndex | None = None,\n):\nparent = QtCore.QModelIndex() if parent is None else parent\nfirst = first or 0\nlast = last if last is not None else self.rowCount()\nself.beginInsertRows(parent, first, last)\nyield None\nself.endInsertRows()\n@contextlib.contextmanager\ndef append_rows(self, num_rows: int, parent: QtCore.QModelIndex | None = None):\nparent = QtCore.QModelIndex() if parent is None else parent\nrow_count = self.rowCount()\nself.beginInsertRows(parent, row_count, row_count + num_rows - 1)\nyield None\nself.endInsertRows()\n@contextlib.contextmanager\ndef insert_columns(\nself,\nfirst: int | None = None,\nlast: int | None = None,\nparent: QtCore.QModelIndex | None = None,\n):\nparent = QtCore.QModelIndex() if parent is None else parent\nfirst = first or 0\nlast = last if last is not None else self.rowCount()\nself.beginInsertColumns(parent, first, last)\nyield None\nself.endInsertColumns()\ndef force_reset(self):\nself.beginResetModel()\nself.endResetModel()\ndef force_layoutchange(self):\nself.layoutAboutToBeChanged.emit()\nself.layoutChanged.emit()\ndef get_role_names(self) -&gt; bidict[int, str]:\nreturn bidict({i: v.data().decode() for i, v in self.roleNames().items()})\ndef get_breadcrumbs_path(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n) -&gt; list[str]:\n\"\"\"Get the path for the given index.\n        Returns a list containing data of all indexes up to the root for given role.\n        \"\"\"\npieces = [index.data(role)]\nwhile (index := index.parent()).isValid():\npieces.insert(0, index.data(role))\nreturn pieces\ndef prefetch_tree(\nself, root_index: core.ModelIndex | None = None, depth: int | None = None\n):\nfor idx in self.iter_tree(root_index, depth):\nif self.canFetchMore(idx):\nself.fetchMore(idx)\ndef iter_tree(\nself,\nroot_index: core.ModelIndex | None = None,\ndepth: int | None = None,\n) -&gt; Iterator[core.ModelIndex]:\n\"\"\"Iter through all indexes of the model tree.\"\"\"\nif root_index is None:\n# TODO: does this always equal AbstractItemView.rootIndex()?\n# root_index = self.index(0, 0)\nroot_index = core.ModelIndex()\nif root_index.isValid():\nyield root_index\nif depth is not None and (depth := depth - 1) &lt; 0:\nreturn\nfor i in range(self.rowCount(root_index)):\nidx = self.index(i, 0, root_index)\nyield from self.iter_tree(idx, depth)\ndef search_tree(\nself,\nvalue: Any,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\nroot_index: core.ModelIndex | None = None,\nmax_results: int | None = None,\ndepth: int | None = None,\n) -&gt; listdelegators.BaseListDelegator[core.ModelIndex]:\n\"\"\"Search the tree for indexes with a given value in given role.\n        Compared to QAbstractItemModel.match, this method allows to set a maximum\n        search depth and passing several values to search for as a list.\n        Arguments:\n            value: Item or list of items to search for.\n            role: Index role to search in.\n            root_index: start index for searching. If None, whole tree is searched.\n            max_results: stop searching after x amount of hits. 'None' means no limit.\n            depth: search depth. Search depth. 'None' means no limit.\n        \"\"\"\nresults = []\n# This makes it impossible to search for lists. I think thats fine.\nif not isinstance(value, list):\nvalue = [value]\nfor idx in self.iter_tree(root_index, depth=depth):\nif self.data(idx, role) in value:\nresults.append(idx)\nif len(results) == max_results:\nbreak\nreturn listdelegators.BaseListDelegator(results)\ndef get_child_indexes(\nself, index: core.ModelIndex\n) -&gt; listdelegators.BaseListDelegator[core.ModelIndex]:\n\"\"\"Get all child indexes for given index (first column only).\n        To get indexes recursively, use iter_tree.\n        \"\"\"\nindexes = [self.index(i, 0, index) for i in range(self.rowCount(index))]\nreturn listdelegators.BaseListDelegator(indexes)\ndef get_index_key(\nself, index: core.ModelIndex, include_column: bool = False\n) -&gt; tuple[tuple[int, int] | int, ...]:\n\"\"\"Return a key for `index` from the source model into the _source_offset map.\n        The key is a tuple of row indices on\n        the path from the top if the model to the `index`.\n        \"\"\"\nkey_path = []\nparent = index\nwhile parent.isValid():\nkey = (parent.row(), parent.column()) if include_column else parent.row()\nkey_path.append(key)\nparent = parent.parent()\nreturn tuple(reversed(key_path))\ndef index_from_key(\nself, key_path: tuple[int | tuple[int, int], ...]\n) -&gt; core.ModelIndex:\n\"\"\"Return a source QModelIndex for the given key.\"\"\"\nmodel = self.sourceModel()\nif model is None:\nreturn core.ModelIndex()\nindex = model.index(key_path[0], 0)\nfor row in key_path[1:]:\nindex = model.index(row, 0, index)\nreturn index\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.change_layout","title":"<code>change_layout()</code>","text":"<p>Context manager to change the layout.</p> <p>wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged</p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>@contextlib.contextmanager\ndef change_layout(self):\n\"\"\"Context manager to change the layout.\n    wraps calls with correct signals\n    emitted at beginning: layoutAboutToBeChanged\n    emitted at end: layoutChanged\n    \"\"\"\nself.layoutAboutToBeChanged.emit()\nyield None\nself.layoutChanged.emit()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.get_breadcrumbs_path","title":"<code>get_breadcrumbs_path(index: core.ModelIndex, role: constants.ItemDataRole = constants.DISPLAY_ROLE) -&gt; list[str]</code>","text":"<p>Get the path for the given index.</p> <p>Returns a list containing data of all indexes up to the root for given role.</p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>def get_breadcrumbs_path(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n) -&gt; list[str]:\n\"\"\"Get the path for the given index.\n    Returns a list containing data of all indexes up to the root for given role.\n    \"\"\"\npieces = [index.data(role)]\nwhile (index := index.parent()).isValid():\npieces.insert(0, index.data(role))\nreturn pieces\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.get_child_indexes","title":"<code>get_child_indexes(index: core.ModelIndex) -&gt; listdelegators.BaseListDelegator[core.ModelIndex]</code>","text":"<p>Get all child indexes for given index (first column only).</p> <p>To get indexes recursively, use iter_tree.</p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>def get_child_indexes(\nself, index: core.ModelIndex\n) -&gt; listdelegators.BaseListDelegator[core.ModelIndex]:\n\"\"\"Get all child indexes for given index (first column only).\n    To get indexes recursively, use iter_tree.\n    \"\"\"\nindexes = [self.index(i, 0, index) for i in range(self.rowCount(index))]\nreturn listdelegators.BaseListDelegator(indexes)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.get_column_type","title":"<code>get_column_type(column: int, rows_to_check: int = 5, role: int = constants.DISPLAY_ROLE) -&gt; type | None</code>","text":"<p>Guess column data type by checking values of first rows with given role.</p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>def get_column_type(\nself,\ncolumn: int,\nrows_to_check: int = 5,\nrole=constants.DISPLAY_ROLE,\n) -&gt; type | None:\n\"\"\"Guess column data type by checking values of first rows with given role.\"\"\"\nto_check = min(rows_to_check, self.rowCount())\nif to_check == 0:\nreturn None\n# cant combine these or make them a generator, so we do two list comps.\nindexes = [self.index(row, column) for row in range(to_check)]\nvalues = [self.data(i, role=role) for i in indexes]\nif all(isinstance(i, bool) for i in values):\nreturn bool\nif all(isinstance(i, str) for i in values):\nreturn str\nif all(isinstance(i, int) for i in values):\nreturn int\nif all(isinstance(i, float) for i in values):\nreturn float\ncheck_values = [self.data(i, role=constants.CHECKSTATE_ROLE) for i in indexes]\nreturn bool if None not in check_values else None\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.get_index_key","title":"<code>get_index_key(index: core.ModelIndex, include_column: bool = False) -&gt; tuple[tuple[int, int] | int, ...]</code>","text":"<p>Return a key for <code>index</code> from the source model into the _source_offset map.</p> <p>The key is a tuple of row indices on the path from the top if the model to the <code>index</code>.</p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>def get_index_key(\nself, index: core.ModelIndex, include_column: bool = False\n) -&gt; tuple[tuple[int, int] | int, ...]:\n\"\"\"Return a key for `index` from the source model into the _source_offset map.\n    The key is a tuple of row indices on\n    the path from the top if the model to the `index`.\n    \"\"\"\nkey_path = []\nparent = index\nwhile parent.isValid():\nkey = (parent.row(), parent.column()) if include_column else parent.row()\nkey_path.append(key)\nparent = parent.parent()\nreturn tuple(reversed(key_path))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.index_from_key","title":"<code>index_from_key(key_path: tuple[int | tuple[int, int], ...]) -&gt; core.ModelIndex</code>","text":"<p>Return a source QModelIndex for the given key.</p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>def index_from_key(\nself, key_path: tuple[int | tuple[int, int], ...]\n) -&gt; core.ModelIndex:\n\"\"\"Return a source QModelIndex for the given key.\"\"\"\nmodel = self.sourceModel()\nif model is None:\nreturn core.ModelIndex()\nindex = model.index(key_path[0], 0)\nfor row in key_path[1:]:\nindex = model.index(row, 0, index)\nreturn index\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.iter_tree","title":"<code>iter_tree(root_index: core.ModelIndex | None = None, depth: int | None = None) -&gt; Iterator[core.ModelIndex]</code>","text":"<p>Iter through all indexes of the model tree.</p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>def iter_tree(\nself,\nroot_index: core.ModelIndex | None = None,\ndepth: int | None = None,\n) -&gt; Iterator[core.ModelIndex]:\n\"\"\"Iter through all indexes of the model tree.\"\"\"\nif root_index is None:\n# TODO: does this always equal AbstractItemView.rootIndex()?\n# root_index = self.index(0, 0)\nroot_index = core.ModelIndex()\nif root_index.isValid():\nyield root_index\nif depth is not None and (depth := depth - 1) &lt; 0:\nreturn\nfor i in range(self.rowCount(root_index)):\nidx = self.index(i, 0, root_index)\nyield from self.iter_tree(idx, depth)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.reset_model","title":"<code>reset_model()</code>","text":"<p>Context manager to reset the model.</p> <p>wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel</p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>@contextlib.contextmanager\ndef reset_model(self):\n\"\"\"Context manager to reset the model.\n    wraps calls with correct signals\n    emitted at beginning: beginResetModel\n    emitted at end: endResetModel\n    \"\"\"\nself.beginResetModel()\nyield None\nself.endResetModel()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.search_tree","title":"<code>search_tree(value: Any, role: constants.ItemDataRole = constants.DISPLAY_ROLE, root_index: core.ModelIndex | None = None, max_results: int | None = None, depth: int | None = None) -&gt; listdelegators.BaseListDelegator[core.ModelIndex]</code>","text":"<p>Search the tree for indexes with a given value in given role.</p> <p>Compared to QAbstractItemModel.match, this method allows to set a maximum search depth and passing several values to search for as a list.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Item or list of items to search for.</p> required <code>role</code> <code>constants.ItemDataRole</code> <p>Index role to search in.</p> <code>constants.DISPLAY_ROLE</code> <code>root_index</code> <code>core.ModelIndex | None</code> <p>start index for searching. If None, whole tree is searched.</p> <code>None</code> <code>max_results</code> <code>int | None</code> <p>stop searching after x amount of hits. 'None' means no limit.</p> <code>None</code> <code>depth</code> <code>int | None</code> <p>search depth. Search depth. 'None' means no limit.</p> <code>None</code> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>def search_tree(\nself,\nvalue: Any,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\nroot_index: core.ModelIndex | None = None,\nmax_results: int | None = None,\ndepth: int | None = None,\n) -&gt; listdelegators.BaseListDelegator[core.ModelIndex]:\n\"\"\"Search the tree for indexes with a given value in given role.\n    Compared to QAbstractItemModel.match, this method allows to set a maximum\n    search depth and passing several values to search for as a list.\n    Arguments:\n        value: Item or list of items to search for.\n        role: Index role to search in.\n        root_index: start index for searching. If None, whole tree is searched.\n        max_results: stop searching after x amount of hits. 'None' means no limit.\n        depth: search depth. Search depth. 'None' means no limit.\n    \"\"\"\nresults = []\n# This makes it impossible to search for lists. I think thats fine.\nif not isinstance(value, list):\nvalue = [value]\nfor idx in self.iter_tree(root_index, depth=depth):\nif self.data(idx, role) in value:\nresults.append(idx)\nif len(results) == max_results:\nbreak\nreturn listdelegators.BaseListDelegator(results)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.AbstractProxyModelMixin","title":"<code>AbstractProxyModelMixin</code>","text":"<p>         Bases: <code>core.AbstractItemModelMixin</code></p> Source code in <code>prettyqt\\core\\abstractproxymodel.py</code> <pre><code>class AbstractProxyModelMixin(core.AbstractItemModelMixin):\nID = \"\"\ndef __pretty__(\nself, fmt: Callable[[Any], Any], **kwargs: Any\n) -&gt; Generator[Any, None, None]:\nyield f\"{type(self).__name__}(\"\nyield 1\n# yield 1\nyield f\"objectName={self.objectName()}\"\nyield 0\nfor k, v in self.get_properties(include_super=False).items():\nyield f\"{k}={v!r}\"\nyield 0\nmodel = self.sourceModel()\nif hasattr(model, \"__pretty__\"):\nyield from model.__pretty__(fmt, **kwargs)\nyield 0\nyield -1\n# yield -1\nyield \")\"\ndef parent(self, *args):\n# workaround: PyQt6 QIdentityproxymodel.parent() missing\nif not args and qt.API == \"pyqt6\":\nreturn QtCore.QAbstractProxyModel.parent(self)\nreturn super().parent(*args)\ndef first_item_index(self) -&gt; core.ModelIndex:\n\"\"\"Return the first child of the root item.\"\"\"\n# We cannot just call the same function of the source model because the first node\n# there may be hidden.\nproxy_root_index = self.mapFromSource(core.ModelIndex())\nreturn self.index(0, 0, proxy_root_index)\ndef get_source_model(self, skip_proxies: bool = True):\nmodel = self.sourceModel()\nif skip_proxies:\nwhile isinstance(model, QtCore.QAbstractProxyModel):\nmodel = model.sourceModel()\nreturn model\ndef remove(self):\nparent = self.parent()\nmodels = parent.get_models()\nidx = models.index(self)\nif idx == len(models) - 1:\nparent.set_model(models[idx - 1])\nself.setSourceModel(None)\nelif idx == 0 and len(models) &gt; 0:\nparent.set_model(models[1])\nelif idx &gt; 0 and len(models) &gt; 2:\nmodels[idx - 1].setSourceModel(models[idx + 1])\nself.setSourceModel(None)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractproxymodel.AbstractProxyModelMixin.first_item_index","title":"<code>first_item_index() -&gt; core.ModelIndex</code>","text":"<p>Return the first child of the root item.</p> Source code in <code>prettyqt\\core\\abstractproxymodel.py</code> <pre><code>def first_item_index(self) -&gt; core.ModelIndex:\n\"\"\"Return the first child of the root item.\"\"\"\n# We cannot just call the same function of the source model because the first node\n# there may be hidden.\nproxy_root_index = self.mapFromSource(core.ModelIndex())\nreturn self.index(0, 0, proxy_root_index)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.AnimationGroupMixin","title":"<code>AnimationGroupMixin</code>","text":"<p>         Bases: <code>core.AbstractAnimationMixin</code></p> Source code in <code>prettyqt\\core\\animationgroup.py</code> <pre><code>class AnimationGroupMixin(core.AbstractAnimationMixin):\n@overload\ndef __getitem__(self, index: int) -&gt; QtCore.QAbstractAnimation:\n...\n@overload\ndef __getitem__(\nself, index: slice\n) -&gt; listdelegators.BaseListDelegator[QtCore.QAbstractAnimation]:\n...\ndef __getitem__(self, index: int | slice):\ncount = self.animationCount()\nmatch index:\ncase int():\nif index &lt; 0:\nindex = count + index\nif index &gt;= count:\nraise IndexError(index)\nanim = self.animationAt(index)\nif anim is None:\nraise KeyError(index)\nreturn anim\ncase slice():\nstop = index.stop or count\nrng = range(index.start or 0, stop, index.step or 1)\nanims = [self.animationAt(i) for i in rng]\nreturn listdelegators.BaseListDelegator(anims)\ncase _:\nraise TypeError(index)\ndef __setitem__(self, index: int, value: QtCore.QAbstractAnimation):\nif not (0 &lt;= index &lt; self.animationCount()):\nraise KeyError(index)\nself.takeAnimation(index)\nself.insertAnimation(index, value)\ndef __len__(self):\nreturn self.animationCount()\ndef __delitem__(self, index: int):\nif not (0 &lt;= index &lt; self.animationCount()):\nraise KeyError(index)\nself.takeAnimation(index)\ndef __add__(self, other: QtCore.QAbstractAnimation):\nself.addAnimation(other)\nreturn self\ndef targetObject(self) -&gt; widgets.QWidget:\n\"\"\"Return shared targetObject if existing.\"\"\"\ntargets = [\nanim.targetObject()\nfor i in range(self.animationCount())\nif isinstance((anim := self.animationAt(i)), core.QPropertyAnimation)\n]\nif len(targets) != self.animationCount() or len(set(targets)) != 1:\nraise RuntimeError(\"Could not find shared targetObject for all animations.\")\nreturn targets[0]\ndef add_property_animation(self, obj: Callable) -&gt; core.PropertyAnimation:\nanim = core.PropertyAnimation()\nanim.apply_to(obj)\nself.addAnimation(anim)\nreturn anim\n</code></pre>"},{"location":"api/core.html#prettyqt.core.animationgroup.AnimationGroupMixin.targetObject","title":"<code>targetObject() -&gt; widgets.QWidget</code>","text":"<p>Return shared targetObject if existing.</p> Source code in <code>prettyqt\\core\\animationgroup.py</code> <pre><code>def targetObject(self) -&gt; widgets.QWidget:\n\"\"\"Return shared targetObject if existing.\"\"\"\ntargets = [\nanim.targetObject()\nfor i in range(self.animationCount())\nif isinstance((anim := self.animationAt(i)), core.QPropertyAnimation)\n]\nif len(targets) != self.animationCount() or len(set(targets)) != 1:\nraise RuntimeError(\"Could not find shared targetObject for all animations.\")\nreturn targets[0]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.Collator","title":"<code>Collator</code>","text":"<p>         Bases: <code>QtCore.QCollator</code></p> Source code in <code>prettyqt\\core\\collator.py</code> <pre><code>class Collator(QtCore.QCollator):\ndef __repr__(self):\nreturn get_repr(self, self.get_locale())\ndef get_locale(self) -&gt; core.Locale:\nreturn core.Locale(self.locale())\ndef set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n        Args:\n            state: case sensitive\n        \"\"\"\nsensitivity = (\nconstants.CaseSensitivity.CaseSensitive\nif state\nelse constants.CaseSensitivity.CaseInsensitive\n)\nself.setCaseSensitivity(sensitivity)\ndef is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n        Returns:\n            case sensitivity\n        \"\"\"\nreturn bool(self.caseSensitivity())\ndef get_sort_key(self, string: str) -&gt; core.CollatorSortKey:\nreturn core.CollatorSortKey(self.sortKey(string))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.collator.Collator.is_case_sensitive","title":"<code>is_case_sensitive() -&gt; bool</code>","text":"<p>Return case sensitivity.</p> <p>Returns:</p> Type Description <code>bool</code> <p>case sensitivity</p> Source code in <code>prettyqt\\core\\collator.py</code> <pre><code>def is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n    Returns:\n        case sensitivity\n    \"\"\"\nreturn bool(self.caseSensitivity())\n</code></pre>"},{"location":"api/core.html#prettyqt.core.collator.Collator.set_case_sensitive","title":"<code>set_case_sensitive(state: bool)</code>","text":"<p>Set case sensitivity.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>case sensitive</p> required Source code in <code>prettyqt\\core\\collator.py</code> <pre><code>def set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n    Args:\n        state: case sensitive\n    \"\"\"\nsensitivity = (\nconstants.CaseSensitivity.CaseSensitive\nif state\nelse constants.CaseSensitivity.CaseInsensitive\n)\nself.setCaseSensitivity(sensitivity)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.CommandLineParser","title":"<code>CommandLineParser</code>","text":"<p>         Bases: <code>QtCore.QCommandLineParser</code></p> Source code in <code>prettyqt\\core\\commandlineparser.py</code> <pre><code>class CommandLineParser(QtCore.QCommandLineParser):\ndef set_single_dash_word_option_mode(self, mode: SingleDashWordStr):\n\"\"\"Set the single dash word option mode.\n        Args:\n            mode: single dash word option mode\n        \"\"\"\nself.setSingleDashWordOptionMode(SINGLE_DASH_WORD.get_enum_value(mode))\ndef set_options_after_positional_arguments_mode(\nself, mode: SingleDashWordStr | mod.SingleDashWordOptionMode\n):\n\"\"\"Set the options after positional arguments mode.\n        Args:\n            mode: options after positional arguments mode\n        \"\"\"\nval = OPTIONS_AFTER_POS_ARG.get_enum_value(mode)\nself.setOptionsAfterPositionalArgumentsMode(val)\ndef add_option(\nself,\nname: str,\ndescription: str | None = None,\nvalue_name: str | None = None,\ndefault_value: str | None = None,\n) -&gt; core.CommandLineOption:\nif description is None:\ndescription = \"\"\nif value_name is None:\nvalue_name = \"\"\nif default_value is None:\ndefault_value = \"\"\noption = core.CommandLineOption(name, description, value_name, default_value)\nself.addOption(option)\nreturn option\n</code></pre>"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_options_after_positional_arguments_mode","title":"<code>set_options_after_positional_arguments_mode(mode: SingleDashWordStr | mod.SingleDashWordOptionMode)</code>","text":"<p>Set the options after positional arguments mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SingleDashWordStr | mod.SingleDashWordOptionMode</code> <p>options after positional arguments mode</p> required Source code in <code>prettyqt\\core\\commandlineparser.py</code> <pre><code>def set_options_after_positional_arguments_mode(\nself, mode: SingleDashWordStr | mod.SingleDashWordOptionMode\n):\n\"\"\"Set the options after positional arguments mode.\n    Args:\n        mode: options after positional arguments mode\n    \"\"\"\nval = OPTIONS_AFTER_POS_ARG.get_enum_value(mode)\nself.setOptionsAfterPositionalArgumentsMode(val)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_single_dash_word_option_mode","title":"<code>set_single_dash_word_option_mode(mode: SingleDashWordStr)</code>","text":"<p>Set the single dash word option mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SingleDashWordStr</code> <p>single dash word option mode</p> required Source code in <code>prettyqt\\core\\commandlineparser.py</code> <pre><code>def set_single_dash_word_option_mode(self, mode: SingleDashWordStr):\n\"\"\"Set the single dash word option mode.\n    Args:\n        mode: single dash word option mode\n    \"\"\"\nself.setSingleDashWordOptionMode(SINGLE_DASH_WORD.get_enum_value(mode))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.CoreApplicationMixin","title":"<code>CoreApplicationMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\core\\coreapplication.py</code> <pre><code>class CoreApplicationMixin(core.ObjectMixin):\ntranslators: dict[str, core.Translator] = {}\n@classmethod\ndef call_on_exit(cls, func: Callable):\ninstance = cls.instance()\nif instance is None:\nraise RuntimeError(\"No QApplication running\")\ninstance.aboutToQuit.connect(func)\n@classmethod\ndef get_application_file_path(cls) -&gt; pathlib.Path:\nreturn pathlib.Path(cls.applicationFilePath())\n@classmethod\ndef get_application_dir_path(cls) -&gt; pathlib.Path:\nreturn pathlib.Path(cls.applicationDirPath())\n@classmethod\ndef add_library_path(cls, path: datatypes.PathType):\ncls.addLibraryPath(os.fspath(path))\n@classmethod\ndef get_library_paths(cls) -&gt; list[pathlib.Path]:\nreturn [pathlib.Path(i) for i in cls.libraryPaths()]\ndef set_application_name(self, name: str):\nif os.name == \"nt\" and name and not getattr(sys, \"frozen\", False):\nimport ctypes\nctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(name)\nself.setApplicationName(name)\ndef set_metadata(\nself,\napp_name: str | None = None,\napp_version: None | datatypes.SemanticVersionType = None,\norg_name: str | None = None,\norg_domain: str | None = None,\n):\nif app_name is not None:\nself.setApplicationName(app_name)\nmatch app_version:\ncase None:\npass\ncase QtCore.QVersionNumber():\napp_version = app_version.toString()\nself.setApplicationVersion(app_version)\ncase tuple():\napp_version = \".\".join(str(i) for i in app_version)\nself.setApplicationVersion(app_version)\ncase str():\nself.setApplicationVersion(app_version)\ncase _:\nraise TypeError(app_version)\nif org_name is not None:\nself.setOrganizationName(org_name)\nif org_domain is not None:\nself.setOrganizationDomain(org_domain)\n@classmethod\ndef load_language_file(cls, file: datatypes.PathType) -&gt; core.Translator:\ntranslator = core.Translator()\ntranslator.load_file(file)\ncls.installTranslator(translator)\ncls.translators[str(file)] = translator\nreturn translator\n@classmethod\ndef load_language(cls, language: str) -&gt; core.Translator:\ntranslator = core.Translator.for_language(language)\ncls.installTranslator(translator)\ncls.translators[language] = translator\nreturn translator\ndef post_event(\nself,\nobj: QtCore.QObject,\nevent: QtCore.QEvent,\npriority: int | constants.EventPriorityStr = \"normal\",\n):\nmatch priority:\ncase int():\nprio = priority\ncase str():\nprio = constants.EVENT_PRIORITY[priority]\ncase _:\nraise TypeError(priority)\nreturn self.postEvent(obj, event, prio)\ndef in_main_thread(self) -&gt; bool:\n\"\"\"Check if we are in the thread in which QApplication object was created.\n        Returns:\n            True if we are in the main thread, False otherwise.\n        \"\"\"\nreturn self.thread() == core.Thread.currentThread()\ndef main_loop(self) -&gt; int:\nreturn self.exec()\n@staticmethod\ndef restart():\nos.execl(sys.executable, sys.executable, *sys.argv)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.coreapplication.CoreApplicationMixin.in_main_thread","title":"<code>in_main_thread() -&gt; bool</code>","text":"<p>Check if we are in the thread in which QApplication object was created.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if we are in the main thread, False otherwise.</p> Source code in <code>prettyqt\\core\\coreapplication.py</code> <pre><code>def in_main_thread(self) -&gt; bool:\n\"\"\"Check if we are in the thread in which QApplication object was created.\n    Returns:\n        True if we are in the main thread, False otherwise.\n    \"\"\"\nreturn self.thread() == core.Thread.currentThread()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.DataStream","title":"<code>DataStream</code>","text":"<p>         Bases: <code>QtCore.QDataStream</code></p> Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>class DataStream(QtCore.QDataStream):\ndef set_byte_order(self, order: ByteOrderStr | QtCore.QDataStream.ByteOrder):\n\"\"\"Set byte order.\n        Args:\n            order: byte order to use\n        \"\"\"\nself.setByteOrder(BYTE_ORDER.get_enum_value(order))\ndef get_byte_order(self) -&gt; ByteOrderStr:\n\"\"\"Return byte order.\n        Returns:\n            byte order\n        \"\"\"\nreturn BYTE_ORDER.inverse[self.byteOrder()]\ndef set_status(self, status: StatusStr):\n\"\"\"Set status.\n        Args:\n            status: status to use\n        \"\"\"\nself.setStatus(STATUS.get_enum_value(status))\ndef get_status(self) -&gt; StatusStr:\n\"\"\"Return status.\n        Returns:\n            status\n        \"\"\"\nreturn STATUS.inverse[self.status()]\ndef set_floating_point_precision(\nself,\nprecision: FloatingPointPrecisionStr | QtCore.QDataStream.FloatingPointPrecision,\n):\n\"\"\"Set floating point precision.\n        Args:\n            precision: floating point precision\n        \"\"\"\nself.setFloatingPointPrecision(FLOATING_POINT_PRECISION.get_enum_value(precision))\ndef get_floating_point_precision(self) -&gt; FloatingPointPrecisionStr:\n\"\"\"Return floating point precision.\n        Returns:\n            floating point precision\n        \"\"\"\nreturn FLOATING_POINT_PRECISION.inverse[self.floatingPointPrecision()]\n@classmethod\ndef create_bytearray(cls, data: datatypes.QtSerializableType) -&gt; QtCore.QByteArray:\nba = QtCore.QByteArray()\nstream = cls(ba, QtCore.QIODeviceBase.OpenModeFlag.WriteOnly)\nstream &lt;&lt; data\nreturn ba\n@classmethod\ndef write_bytearray(\ncls, ba: datatypes.ByteArrayType, write_to: datatypes.QtSerializableType\n):\nba = datatypes.to_bytearray(ba)\nstream = cls(ba, QtCore.QIODeviceBase.OpenModeFlag.ReadOnly)\nstream &gt;&gt; write_to\n@classmethod\ndef copy_data(\ncls, source: datatypes.QtSerializableType, dest: datatypes.QtSerializableType\n):\nba = cls.create_bytearray(source)\ncls.write_bytearray(ba, dest)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_byte_order","title":"<code>get_byte_order() -&gt; ByteOrderStr</code>","text":"<p>Return byte order.</p> <p>Returns:</p> Type Description <code>ByteOrderStr</code> <p>byte order</p> Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def get_byte_order(self) -&gt; ByteOrderStr:\n\"\"\"Return byte order.\n    Returns:\n        byte order\n    \"\"\"\nreturn BYTE_ORDER.inverse[self.byteOrder()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_floating_point_precision","title":"<code>get_floating_point_precision() -&gt; FloatingPointPrecisionStr</code>","text":"<p>Return floating point precision.</p> <p>Returns:</p> Type Description <code>FloatingPointPrecisionStr</code> <p>floating point precision</p> Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def get_floating_point_precision(self) -&gt; FloatingPointPrecisionStr:\n\"\"\"Return floating point precision.\n    Returns:\n        floating point precision\n    \"\"\"\nreturn FLOATING_POINT_PRECISION.inverse[self.floatingPointPrecision()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_status","title":"<code>get_status() -&gt; StatusStr</code>","text":"<p>Return status.</p> <p>Returns:</p> Type Description <code>StatusStr</code> <p>status</p> Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def get_status(self) -&gt; StatusStr:\n\"\"\"Return status.\n    Returns:\n        status\n    \"\"\"\nreturn STATUS.inverse[self.status()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_byte_order","title":"<code>set_byte_order(order: ByteOrderStr | QtCore.QDataStream.ByteOrder)</code>","text":"<p>Set byte order.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>ByteOrderStr | QtCore.QDataStream.ByteOrder</code> <p>byte order to use</p> required Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def set_byte_order(self, order: ByteOrderStr | QtCore.QDataStream.ByteOrder):\n\"\"\"Set byte order.\n    Args:\n        order: byte order to use\n    \"\"\"\nself.setByteOrder(BYTE_ORDER.get_enum_value(order))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_floating_point_precision","title":"<code>set_floating_point_precision(precision: FloatingPointPrecisionStr | QtCore.QDataStream.FloatingPointPrecision)</code>","text":"<p>Set floating point precision.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>FloatingPointPrecisionStr | QtCore.QDataStream.FloatingPointPrecision</code> <p>floating point precision</p> required Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def set_floating_point_precision(\nself,\nprecision: FloatingPointPrecisionStr | QtCore.QDataStream.FloatingPointPrecision,\n):\n\"\"\"Set floating point precision.\n    Args:\n        precision: floating point precision\n    \"\"\"\nself.setFloatingPointPrecision(FLOATING_POINT_PRECISION.get_enum_value(precision))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_status","title":"<code>set_status(status: StatusStr)</code>","text":"<p>Set status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>StatusStr</code> <p>status to use</p> required Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def set_status(self, status: StatusStr):\n\"\"\"Set status.\n    Args:\n        status: status to use\n    \"\"\"\nself.setStatus(STATUS.get_enum_value(status))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.DateTime","title":"<code>DateTime</code>","text":"<p>         Bases: <code>QtCore.QDateTime</code></p> Source code in <code>prettyqt\\core\\_datetime.py</code> <pre><code>class DateTime(QtCore.QDateTime):\ndef __repr__(self):\ntemplate = super().__repr__().split(\"(\")[1]\nreturn f\"{type(self).__name__}({template}\"\ndef __str__(self):\nreturn self.toString(\"yyyy-MM-dd hh:mm:ss.zzzzzz\")\ndef __reduce__(self):\nreturn type(self), (self.date(), self.time(), self.get_timezone())\ndef __format__(self, format_spec: constants.DateFormatStr):\nif format_spec in constants.DATE_FORMAT:\nreturn self.to_format(format_spec)\nreturn self.toString(format_spec)\n@classmethod\ndef from_seconds(cls, seconds: float) -&gt; Self:\nnew = cls()\nnew.setMSecsSinceEpoch(int(seconds * 1000))\nreturn new\ndef get_value(self) -&gt; datetime.datetime:\nreturn self.toPython()\ndef get_date(self) -&gt; core.Date:\nreturn core.Date(self.date())\ndef get_time(self) -&gt; core.Time:\nreturn core.Time(self.time())\ndef get_timezone(self) -&gt; core.TimeZone:\nreturn core.TimeZone(self.timeZone())\ndef set_timezone(self, zone: str | QtCore.QTimeZone):\nif isinstance(zone, str):\nself.setTimeZone(core.TimeZone(zone))\nelse:\nself.setTimeZone(zone)\ndef set_time_spec(self, spec: constants.TimeSpecStr | constants.TimeSpec):\n\"\"\"Set the time specification.\n        Args:\n            spec: time specification to use\n        \"\"\"\nself.setTimeSpec(constants.TIME_SPEC[spec])\ndef get_time_spec(self) -&gt; constants.TimeSpecStr:\n\"\"\"Return current time specification.\n        Returns:\n            time specification\n        \"\"\"\nreturn constants.TIME_SPEC.inverse[self.timeSpec()]\ndef to_format(self, fmt: constants.DateFormatStr):\nreturn self.toString(constants.DATE_FORMAT[fmt])\n</code></pre>"},{"location":"api/core.html#prettyqt.core._datetime.DateTime.get_time_spec","title":"<code>get_time_spec() -&gt; constants.TimeSpecStr</code>","text":"<p>Return current time specification.</p> <p>Returns:</p> Type Description <code>constants.TimeSpecStr</code> <p>time specification</p> Source code in <code>prettyqt\\core\\_datetime.py</code> <pre><code>def get_time_spec(self) -&gt; constants.TimeSpecStr:\n\"\"\"Return current time specification.\n    Returns:\n        time specification\n    \"\"\"\nreturn constants.TIME_SPEC.inverse[self.timeSpec()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core._datetime.DateTime.set_time_spec","title":"<code>set_time_spec(spec: constants.TimeSpecStr | constants.TimeSpec)</code>","text":"<p>Set the time specification.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>constants.TimeSpecStr | constants.TimeSpec</code> <p>time specification to use</p> required Source code in <code>prettyqt\\core\\_datetime.py</code> <pre><code>def set_time_spec(self, spec: constants.TimeSpecStr | constants.TimeSpec):\n\"\"\"Set the time specification.\n    Args:\n        spec: time specification to use\n    \"\"\"\nself.setTimeSpec(constants.TIME_SPEC[spec])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.DeadlineTimer","title":"<code>DeadlineTimer</code>","text":"<p>         Bases: <code>QtCore.QDeadlineTimer</code></p> Source code in <code>prettyqt\\core\\deadlinetimer.py</code> <pre><code>class DeadlineTimer(QtCore.QDeadlineTimer):\ndef set_type(self, typ: constants.TimerTypeStr | constants.TimerType):\n\"\"\"Set the timer type.\n        Args:\n            typ: timer type\n        \"\"\"\nself.setTimerType(constants.TIMER_TYPE.get_enum_value(typ))\ndef get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n        Returns:\n            timer type\n        \"\"\"\nreturn constants.TIMER_TYPE.inverse[self.timerType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.get_type","title":"<code>get_type() -&gt; constants.TimerTypeStr</code>","text":"<p>Return current timer type.</p> <p>Returns:</p> Type Description <code>constants.TimerTypeStr</code> <p>timer type</p> Source code in <code>prettyqt\\core\\deadlinetimer.py</code> <pre><code>def get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n    Returns:\n        timer type\n    \"\"\"\nreturn constants.TIMER_TYPE.inverse[self.timerType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.set_type","title":"<code>set_type(typ: constants.TimerTypeStr | constants.TimerType)</code>","text":"<p>Set the timer type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>constants.TimerTypeStr | constants.TimerType</code> <p>timer type</p> required Source code in <code>prettyqt\\core\\deadlinetimer.py</code> <pre><code>def set_type(self, typ: constants.TimerTypeStr | constants.TimerType):\n\"\"\"Set the timer type.\n    Args:\n        typ: timer type\n    \"\"\"\nself.setTimerType(constants.TIMER_TYPE.get_enum_value(typ))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.EasingCurve","title":"<code>EasingCurve</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtCore.QEasingCurve</code></p> Source code in <code>prettyqt\\core\\easingcurve.py</code> <pre><code>class EasingCurve(serializemixin.SerializeMixin, QtCore.QEasingCurve):\ndef __init__(self, other_or_type: TypeStr | int | QtCore.QEasingCurve = \"linear\"):\nif isinstance(other_or_type, str) and other_or_type in TYPE:\ntyp = TYPE[other_or_type]\nelse:\ntyp = other_or_type\nsuper().__init__(typ)\ndef __getitem__(self, value: float) -&gt; float:\nreturn self.valueForProgress(value)\ndef __repr__(self):\nreturn get_repr(self, self.get_type())\ndef set_custom_type(self, method: CurveMethod):\nself.setCustomType(method)\ndef get_custom_type(self) -&gt; CurveMethod:\nreturn self.customType()  # type: ignore\ndef set_type(self, typ: TypeStr | QtCore.QEasingCurve.Type):\n\"\"\"Set easing curve type.\n        Args:\n            typ: easing curve type\n        \"\"\"\nself.setType(TYPE.get_enum_value(typ))\ndef get_type(self) -&gt; TypeStr:\n\"\"\"Get the current easing curve type.\n        Returns:\n            easing curve type\n        \"\"\"\nreturn TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.get_type","title":"<code>get_type() -&gt; TypeStr</code>","text":"<p>Get the current easing curve type.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>easing curve type</p> Source code in <code>prettyqt\\core\\easingcurve.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Get the current easing curve type.\n    Returns:\n        easing curve type\n    \"\"\"\nreturn TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.set_type","title":"<code>set_type(typ: TypeStr | QtCore.QEasingCurve.Type)</code>","text":"<p>Set easing curve type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TypeStr | QtCore.QEasingCurve.Type</code> <p>easing curve type</p> required Source code in <code>prettyqt\\core\\easingcurve.py</code> <pre><code>def set_type(self, typ: TypeStr | QtCore.QEasingCurve.Type):\n\"\"\"Set easing curve type.\n    Args:\n        typ: easing curve type\n    \"\"\"\nself.setType(TYPE.get_enum_value(typ))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.ElapsedTimer","title":"<code>ElapsedTimer</code>","text":"<p>         Bases: <code>QtCore.QElapsedTimer</code></p> Source code in <code>prettyqt\\core\\elapsedtimer.py</code> <pre><code>class ElapsedTimer(QtCore.QElapsedTimer):\ndef __bool__(self):\nreturn self.isValid()\ndef get_clock_type(self) -&gt; ClockTypeStr:\n\"\"\"Return current clock type.\n        Returns:\n            clock type\n        \"\"\"\nreturn CLOCK_TYPE.inverse[self.clockType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.elapsedtimer.ElapsedTimer.get_clock_type","title":"<code>get_clock_type() -&gt; ClockTypeStr</code>","text":"<p>Return current clock type.</p> <p>Returns:</p> Type Description <code>ClockTypeStr</code> <p>clock type</p> Source code in <code>prettyqt\\core\\elapsedtimer.py</code> <pre><code>def get_clock_type(self) -&gt; ClockTypeStr:\n\"\"\"Return current clock type.\n    Returns:\n        clock type\n    \"\"\"\nreturn CLOCK_TYPE.inverse[self.clockType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.FileDeviceMixin","title":"<code>FileDeviceMixin</code>","text":"<p>         Bases: <code>core.IODeviceMixin</code></p> Source code in <code>prettyqt\\core\\filedevice.py</code> <pre><code>class FileDeviceMixin(core.IODeviceMixin):\ndef __repr__(self):\nreturn get_repr(self, self.fileName())\ndef __str__(self):\nreturn self.fileName()\ndef get_permissions(self) -&gt; list[PermissionStr]:\nreturn PERMISSIONS.get_list(self.permissions())\ndef set_file_time(\nself,\nfile_time: datatypes.DateTimeType,\ntyp: FileTimeStr | QtCore.QFileDevice.FileTime,\n) -&gt; bool:\n\"\"\"Set file time.\n        Args:\n            file_time: file time to set\n            typ: file time type\n        \"\"\"\nfile_time = datatypes.to_datetime(file_time)\nreturn self.setFileTime(file_time, FILE_TIME.get_enum_value(typ))  # type: ignore\ndef get_file_time(\nself, typ: FileTimeStr | QtCore.QFileDevice.FileTime\n) -&gt; datetime.datetime | None:\n\"\"\"Return current file time.\n        Returns:\n            file time\n        \"\"\"\nif date := self.fileTime(FILE_TIME.get_enum_value(typ)):\nreturn date.toPython()  # type: ignore\nreturn None\ndef get_error(self) -&gt; FileErrorStr:\n\"\"\"Return file error status.\n        Returns:\n            file error status\n        \"\"\"\nreturn FILE_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.filedevice.FileDeviceMixin.get_error","title":"<code>get_error() -&gt; FileErrorStr</code>","text":"<p>Return file error status.</p> <p>Returns:</p> Type Description <code>FileErrorStr</code> <p>file error status</p> Source code in <code>prettyqt\\core\\filedevice.py</code> <pre><code>def get_error(self) -&gt; FileErrorStr:\n\"\"\"Return file error status.\n    Returns:\n        file error status\n    \"\"\"\nreturn FILE_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.filedevice.FileDeviceMixin.get_file_time","title":"<code>get_file_time(typ: FileTimeStr | QtCore.QFileDevice.FileTime) -&gt; datetime.datetime | None</code>","text":"<p>Return current file time.</p> <p>Returns:</p> Type Description <code>datetime.datetime | None</code> <p>file time</p> Source code in <code>prettyqt\\core\\filedevice.py</code> <pre><code>def get_file_time(\nself, typ: FileTimeStr | QtCore.QFileDevice.FileTime\n) -&gt; datetime.datetime | None:\n\"\"\"Return current file time.\n    Returns:\n        file time\n    \"\"\"\nif date := self.fileTime(FILE_TIME.get_enum_value(typ)):\nreturn date.toPython()  # type: ignore\nreturn None\n</code></pre>"},{"location":"api/core.html#prettyqt.core.filedevice.FileDeviceMixin.set_file_time","title":"<code>set_file_time(file_time: datatypes.DateTimeType, typ: FileTimeStr | QtCore.QFileDevice.FileTime) -&gt; bool</code>","text":"<p>Set file time.</p> <p>Parameters:</p> Name Type Description Default <code>file_time</code> <code>datatypes.DateTimeType</code> <p>file time to set</p> required <code>typ</code> <code>FileTimeStr | QtCore.QFileDevice.FileTime</code> <p>file time type</p> required Source code in <code>prettyqt\\core\\filedevice.py</code> <pre><code>def set_file_time(\nself,\nfile_time: datatypes.DateTimeType,\ntyp: FileTimeStr | QtCore.QFileDevice.FileTime,\n) -&gt; bool:\n\"\"\"Set file time.\n    Args:\n        file_time: file time to set\n        typ: file time type\n    \"\"\"\nfile_time = datatypes.to_datetime(file_time)\nreturn self.setFileTime(file_time, FILE_TIME.get_enum_value(typ))  # type: ignore\n</code></pre>"},{"location":"api/core.html#prettyqt.core.KeyCombination","title":"<code>KeyCombination</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtCore.QKeyCombination</code></p> Source code in <code>prettyqt\\core\\keycombination.py</code> <pre><code>class KeyCombination(serializemixin.SerializeMixin, QtCore.QKeyCombination):\ndef __init__(self, *args, **kwargs):\nmatch args:\ncase (str(),) if args[0] in MODIFIERS.inverse.values():\nmods = args[0].split(\"+\")\nqtmod = functools.reduce(or_, [MODIFIERS[m] for m in mods])\nsuper().__init__(qtmod, Keys.No)\nreturn\ncase (str(),):\n*mods, btn = args[0].split(\"+\")\n# get modifiler\nqtmod = (\nfunctools.reduce(or_, [MODIFIERS[m] for m in mods])\nif mods\nelse Mod.NoModifier\n)\n# get button\nif btn in _SYMBOLS:\nbtn = _SYMBOLS[btn]\nif btn.isalnum():\nbtn = btn.upper()\nqtkey = getattr(Key, f\"Key_{btn}\") if btn != \"{}\" else Keys.Any\nsuper().__init__(qtmod, qtkey)\ncase (QtCore.QEvent(),):\nmodifier = args[0].modifiers()\nmodifier ^= Mod.KeypadModifier\nkey = args[0].key()\nif key in MODIFIER_KEYS:  # modifier only\nkey = Keys.No\nsuper().__init__(key, modifier)\ncase _:\nsuper().__init__(*args, **kwargs)\ndef __eq__(self, other):\nif isinstance(other, str | Key):\nother = KeyCombination(other)\nreturn super().__eq__(other)\ndef __add__(self, other):\nfrom prettyqt import gui\nreturn gui.KeySequence(self, other)\ndef __repr__(self):\nreturn get_repr(self, self.key(), self.keyboardModifiers())\ndef is_typing(self) -&gt; bool:\n\"\"\"True if key is a letter or number.\"\"\"\nmod_ok = self.keyboardModifiers() in (Mod.NoModifier, Mod.ShiftModifier)\nkey = self.key()\nkey_ok = (\nKey.Key_Exclam &lt;= key &lt;= Key.Key_ydiaeresis\nor Keys.ALPHA &lt;= key &lt;= Keys.OMEGA\nor Keys.CYR_A &lt;= key &lt;= Keys.CYR_YA\n)\nreturn mod_ok and key_ok\ndef is_moving(self) -&gt; bool:\n\"\"\"True if arrows are pushed.\"\"\"\nreturn self.key() in ARROW_KEYS\ndef is_moving_func(self) -&gt; bool:\n\"\"\"True if function arrows are pushed.\"\"\"\nreturn self.key() in FUNC_ARROW_KEYS\ndef has_modifier(self, modifier: constants.KeyboardModifierStr) -&gt; bool:\n\"\"\"True if keycombo contains modifier.\"\"\"\nreturn bool(self.keyboardModifiers() &amp; constants.KEYBOARD_MODIFIERS[modifier])\ndef has_key(self) -&gt; bool:\n\"\"\"True if non-modifier key is pressed.\"\"\"\nreturn self.key() != Keys.No\ndef get_key(self) -&gt; constants.KeyStr:\nreturn constants.KEY.inverse[self.key()]\ndef get_modifiers(self) -&gt; list[constants.KeyboardModifierStr]:\nreturn constants.KEYBOARD_MODIFIERS.get_list(self.keyboardModifiers())\n</code></pre>"},{"location":"api/core.html#prettyqt.core.keycombination.KeyCombination.has_key","title":"<code>has_key() -&gt; bool</code>","text":"<p>True if non-modifier key is pressed.</p> Source code in <code>prettyqt\\core\\keycombination.py</code> <pre><code>def has_key(self) -&gt; bool:\n\"\"\"True if non-modifier key is pressed.\"\"\"\nreturn self.key() != Keys.No\n</code></pre>"},{"location":"api/core.html#prettyqt.core.keycombination.KeyCombination.has_modifier","title":"<code>has_modifier(modifier: constants.KeyboardModifierStr) -&gt; bool</code>","text":"<p>True if keycombo contains modifier.</p> Source code in <code>prettyqt\\core\\keycombination.py</code> <pre><code>def has_modifier(self, modifier: constants.KeyboardModifierStr) -&gt; bool:\n\"\"\"True if keycombo contains modifier.\"\"\"\nreturn bool(self.keyboardModifiers() &amp; constants.KEYBOARD_MODIFIERS[modifier])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.keycombination.KeyCombination.is_moving","title":"<code>is_moving() -&gt; bool</code>","text":"<p>True if arrows are pushed.</p> Source code in <code>prettyqt\\core\\keycombination.py</code> <pre><code>def is_moving(self) -&gt; bool:\n\"\"\"True if arrows are pushed.\"\"\"\nreturn self.key() in ARROW_KEYS\n</code></pre>"},{"location":"api/core.html#prettyqt.core.keycombination.KeyCombination.is_moving_func","title":"<code>is_moving_func() -&gt; bool</code>","text":"<p>True if function arrows are pushed.</p> Source code in <code>prettyqt\\core\\keycombination.py</code> <pre><code>def is_moving_func(self) -&gt; bool:\n\"\"\"True if function arrows are pushed.\"\"\"\nreturn self.key() in FUNC_ARROW_KEYS\n</code></pre>"},{"location":"api/core.html#prettyqt.core.keycombination.KeyCombination.is_typing","title":"<code>is_typing() -&gt; bool</code>","text":"<p>True if key is a letter or number.</p> Source code in <code>prettyqt\\core\\keycombination.py</code> <pre><code>def is_typing(self) -&gt; bool:\n\"\"\"True if key is a letter or number.\"\"\"\nmod_ok = self.keyboardModifiers() in (Mod.NoModifier, Mod.ShiftModifier)\nkey = self.key()\nkey_ok = (\nKey.Key_Exclam &lt;= key &lt;= Key.Key_ydiaeresis\nor Keys.ALPHA &lt;= key &lt;= Keys.OMEGA\nor Keys.CYR_A &lt;= key &lt;= Keys.CYR_YA\n)\nreturn mod_ok and key_ok\n</code></pre>"},{"location":"api/core.html#prettyqt.core.MetaMethod","title":"<code>MetaMethod</code>","text":"Source code in <code>prettyqt\\core\\metamethod.py</code> <pre><code>class MetaMethod:\ndef __init__(self, metamethod: QtCore.QMetaMethod):\nself.item = metamethod\ndef __getattr__(self, val):\nreturn getattr(self.item, val)\ndef __bool__(self):\nreturn self.item.isValid()\ndef __repr__(self):\nreturn get_repr(self, self.get_name())\ndef get_access(self) -&gt; AccessStr:\nreturn ACCESS.inverse[self.item.access()]\ndef get_method_type(self) -&gt; MethodTypeStr:\nreturn METHOD_TYPE.inverse[self.item.methodType()]\ndef get_method_signature(self) -&gt; str:\nreturn self.item.methodSignature().data().decode()\ndef get_normalized_method_signature(self) -&gt; str:\n\"\"\"Returns something like 'objectNameChanged(QString)'.\"\"\"\nsig = self.item.methodSignature()\nnormalized = QtCore.QMetaObject.normalizedSignature(sig.data().decode())\nreturn normalized.data().decode()\ndef get_name(self) -&gt; str:\nreturn self.item.name().data().decode()\ndef get_parameters(self) -&gt; list[core.MetaType]:\ncount = self.parameterCount()\nreturn [core.MetaType(self.parameterMetaType(i).id()) for i in range(count)]\ndef get_return_type(self) -&gt; core.MetaType:\nreturn core.MetaType(self.returnMetaType().id())\ndef get_parameter_types(self) -&gt; list[str]:\n\"\"\"Returns sth. like ['QString'].\"\"\"\nreturn [i.data().decode() for i in self.parameterTypes()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metamethod.MetaMethod.get_normalized_method_signature","title":"<code>get_normalized_method_signature() -&gt; str</code>","text":"<p>Returns something like 'objectNameChanged(QString)'.</p> Source code in <code>prettyqt\\core\\metamethod.py</code> <pre><code>def get_normalized_method_signature(self) -&gt; str:\n\"\"\"Returns something like 'objectNameChanged(QString)'.\"\"\"\nsig = self.item.methodSignature()\nnormalized = QtCore.QMetaObject.normalizedSignature(sig.data().decode())\nreturn normalized.data().decode()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metamethod.MetaMethod.get_parameter_types","title":"<code>get_parameter_types() -&gt; list[str]</code>","text":"<p>Returns sth. like ['QString'].</p> Source code in <code>prettyqt\\core\\metamethod.py</code> <pre><code>def get_parameter_types(self) -&gt; list[str]:\n\"\"\"Returns sth. like ['QString'].\"\"\"\nreturn [i.data().decode() for i in self.parameterTypes()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.MetaObject","title":"<code>MetaObject</code>","text":"Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>class MetaObject:\ndef __init__(self, metaobject: core.QMetaObject):\nself.item = metaobject\ndef __getattr__(self, val):\nreturn getattr(self.item, val)\ndef get_super_class(self) -&gt; MetaObject | None:\n\"\"\"Get SuperClass MetaObject.\"\"\"\nreturn MetaObject(klass) if (klass := self.superClass()) is not None else None\ndef get_all_super_classes(self) -&gt; list[MetaObject]:\n\"\"\"Get SuperClass MetaObject.\"\"\"\nklasses = []\nwhile klass := self.superClass():\nklasses.append(MetaObject(klass))\nreturn klasses\ndef get_name(self) -&gt; str:\n\"\"\"Get MetaObject class name.\"\"\"\nreturn self.className()\ndef get_class_info(self, include_super: bool = True) -&gt; dict[str, str]:\n\"\"\"Get MetaObject class info.\"\"\"\nstart = 0 if include_super else self.item.classInfoOffset() - 1\ncount = self.item.classInfoCount()\nclassinfos = [self.item.classInfo(i) for i in range(start, count)]\nreturn {i.name(): i.value() for i in classinfos}\ndef get_method(self, index: int | str) -&gt; core.MetaMethod:\n\"\"\"Get MetaMethod based on index or name.\"\"\"\nif isinstance(index, int):\nmethod = core.MetaMethod(self.item.method(index))\nif not method.isValid():\nraise KeyError(index)\nreturn method\nfor method in self.get_methods():\nif method.get_name() in [index, helpers.to_lower_camel(index)]:\nreturn method\nraise KeyError(index)\ndef get_enum(self, index: int | str) -&gt; core.MetaEnum:\n\"\"\"Get MetaEnum based on index or name.\"\"\"\nif isinstance(index, int):\nenum = core.MetaEnum(self.item.enumerator(index))\nif not enum.isValid():\nraise KeyError(index)\nreturn enum\nfor enumerator in self.get_enums():\nif enumerator.get_name() in [index, helpers.to_lower_camel(index)]:\nreturn enumerator\nraise KeyError(index)\ndef get_property(self, index: int | str) -&gt; core.MetaProperty:\n\"\"\"Get MetaProperty based on index or name.\"\"\"\nif isinstance(index, int):\nprop = core.MetaProperty(self.item.property(index))\nif not prop.isValid():\nraise KeyError(index)\nreturn prop\nfor prop in self.get_properties():\nif prop.get_name() in [index, helpers.to_lower_camel(index)]:\nreturn prop\nraise KeyError(index)\ndef get_constructor(self, index: int | str) -&gt; core.MetaMethod:\n\"\"\"Get ctor MetaMethod based on index or name.\"\"\"\nif isinstance(index, int):\nmethod = core.MetaMethod(self.item.constructor(index))\nif not method.isValid():\nraise KeyError(index)\nreturn method\nfor method in self.get_constructors():\nif method.get_name() in [index, helpers.to_lower_camel(index)]:\nreturn method\nraise KeyError(index)\ndef get_methods(\nself,\ninclude_super: bool = True,\ntype_filter: core.metamethod.MethodTypeStr | None = None,\nfilter_shit: bool = True,\n) -&gt; list[core.MetaMethod]:\n\"\"\"Get all MetaMethods based on given criteria.\"\"\"\nstart = 0 if include_super else self.item.methodOffset() - 1\nmethods = [\nmethod\nfor i in range(start, self.item.methodCount())\nif not (method := self.get_method(i)).get_name().startswith(\"_q_\")\nor not filter_shit\n]\nif type_filter is None:\nreturn methods\nelse:\nreturn [i for i in methods if i.get_method_type() == type_filter]\ndef get_enums(self, include_super: bool = True) -&gt; list[core.MetaEnum]:\n\"\"\"Get all MetaEnums based on given criteria.\"\"\"\nstart = 0 if include_super else self.item.enumeratorOffset() - 1\nreturn [self.get_enum(i) for i in range(start, self.item.enumeratorCount())]\ndef get_constructors(self) -&gt; list[core.MetaMethod]:\n\"\"\"Get all ctor MetaMethods.\"\"\"\ncount = self.item.constructorCount()\nreturn [core.MetaMethod(self.item.constructor(i)) for i in range(count)]\ndef get_properties(\nself,\ninclude_super: bool = True,\nonly_writable: bool = False,\nonly_stored: bool = False,\nonly_bindable: bool = False,\nonly_designable: bool = False,\nonly_final: bool = False,\nonly_required: bool = False,\nonly_enum_type: bool = False,\nonly_flag_type: bool = False,\nonly_with_notifiers: bool = False,\nonly_with_type_name: str = \"\",\n) -&gt; list[core.MetaProperty]:\n\"\"\"Get all MetaProperties based on given criteria.\"\"\"\nstart = 0 if include_super else self.item.propertyOffset() - 1\ncount = self.item.propertyCount()\nprop_list = []\nfor i in range(start, count):\nprop = self.item.property(i)\nif (\n(only_writable and not prop.isWritable())\nor (only_stored and not prop.isStored())\nor (only_bindable and not prop.isBindable())\nor (only_designable and not prop.isDesignable())\nor (only_final and not prop.isFinal())\nor (only_required and not prop.isRequired())\nor (only_enum_type and not prop.isEnumType())\nor (only_flag_type and not prop.isFlagType())\nor (only_with_notifiers and not prop.hasNotifier())\nor (only_with_type_name and prop.typeName() != only_with_type_name)\n):\ncontinue\nprop_list.append(core.MetaProperty(prop))\nreturn prop_list\ndef get_property_values(\nself, qobject: core.QObject, cast_types: bool = False\n) -&gt; dict[str, Any]:\n\"\"\"Get a dictionary containing all MetaProperties values from given qobject.\"\"\"\nvals = {prop.get_name(): prop.read(qobject) for prop in self.get_properties()}\nif cast_types:\nreturn {k: datatypes.make_serializable(v) for k, v in vals.items()}\nelse:\nreturn vals\ndef get_signals(\nself, include_super: bool = True, only_notifiers: bool = False\n) -&gt; list[core.MetaMethod]:\n\"\"\"Get all signal MetaMethods based on given criteria.\"\"\"\nif only_notifiers:\nreturn [  # type: ignore\nprop.get_notify_signal()\nfor prop in self.get_properties(include_super)\nif prop.hasNotifySignal()\n]\nelse:\nreturn self.get_methods(include_super=include_super, type_filter=\"signal\")\ndef get_slots(self, include_super: bool = True) -&gt; list[core.MetaMethod]:\n\"\"\"Get all slot MetaMethods based on given criteria.\"\"\"\nreturn self.get_methods(include_super=include_super, type_filter=\"slot\")\ndef get_plain_methods(self, include_super: bool = True) -&gt; list[core.MetaMethod]:\n\"\"\"Get all plain MetaMethods based on given criteria.\"\"\"\nreturn self.get_methods(include_super=include_super, type_filter=\"method\")\ndef get_meta_type(self) -&gt; core.MetaType:\n\"\"\"Get Meta type of this MetaObject.\"\"\"\nreturn core.MetaType(self.metaType().id())\ndef get_user_property(self) -&gt; core.MetaProperty | None:\n\"\"\"Get MetaProperty marked as userprop.\"\"\"\nreturn core.MetaProperty(p) if (p := self.userProperty()).isValid() else None\n# just experimenting\n@classmethod\ndef invoke_method(\ncls,\nobj: core.QObject,\nmethod: str,\n*args,\nconnection_type: constants.ConnectionTypeStr = \"auto\",\n):\nconn = constants.CONNECTION_TYPE[connection_type]\nargs = tuple(core.Q_ARG(type(arg), arg) for arg in args)\nreturn cls.invokeMethod(obj, method, conn, *args)\ndef get_new_instance(self, *args, **kwargs):\nargs = tuple(core.Q_ARG(type(i), i) for i in args)\nkwargs = {k: core.Q_ARG(type(v), v) for k, v in kwargs.items()}\n# requires core.QGenericArgumentHolder for PySide6\nself.newInstance(*args, **kwargs)\ndef connect_signals(\nself,\nsource_qobject: core.QObject,\nfn_or_qobject: Callable | QtCore.QObject,\nonly_notifiers: bool = False,\n) -&gt; list[core.QMetaObject.Connection]:\n\"\"\"Connect all signals of a given qobject.\n        Either connect all signals to a function or connect each signal\n        to the corresponding signal of the receiver.\n        \"\"\"\nhandles = []\nfor signal in self.get_signals(only_notifiers=only_notifiers):\nsignal_name = signal.get_name()\nsignal_instance = source_qobject.__getattribute__(signal_name)\nslot = (\nfn_or_qobject.__getattribute__(signal_name)\nif isinstance(fn_or_qobject, QtCore.QObject)\nelse fn_or_qobject\n)\nhandle = signal_instance.connect(slot)\nhandles.append(handle)\nlogger.debug(f\"connected {len(handles)} signals to {fn_or_qobject}.\")\nreturn handles\ndef copy(self, qobject: core.QObject, forward_signals: bool = True):\n\"\"\"Create a copy of given QObject.\"\"\"\ntry:\nnew = type(qobject)()\nexcept TypeError:\n# this should should cover most cases.\nnew = type(qobject)(qobject.orientation())\nfor prop in self.get_properties(only_writable=True):\nval = prop.read(qobject)\nprop.write(new, val)\nif forward_signals:\nself.connect_signals(new, qobject)\nlogger.debug(f\"copied {qobject!r}\")\nreturn new\ndef get_property_class_affiliations(self) -&gt; dict[str, list[core.MetaProperty]]:\n\"\"\"Get a mapping of class -&gt; property affiliations.\"\"\"\nmapper = {}\nmetaclass = self\nwhile metaclass is not None:\nmapper[metaclass.get_name()] = [\nmetaclass.get_property(i)\nfor i in range(metaclass.propertyOffset(), metaclass.propertyCount())\n]\nmetaclass = metaclass.get_super_class()\nreturn mapper\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.connect_signals","title":"<code>connect_signals(source_qobject: core.QObject, fn_or_qobject: Callable | QtCore.QObject, only_notifiers: bool = False) -&gt; list[core.QMetaObject.Connection]</code>","text":"<p>Connect all signals of a given qobject.</p> <p>Either connect all signals to a function or connect each signal to the corresponding signal of the receiver.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def connect_signals(\nself,\nsource_qobject: core.QObject,\nfn_or_qobject: Callable | QtCore.QObject,\nonly_notifiers: bool = False,\n) -&gt; list[core.QMetaObject.Connection]:\n\"\"\"Connect all signals of a given qobject.\n    Either connect all signals to a function or connect each signal\n    to the corresponding signal of the receiver.\n    \"\"\"\nhandles = []\nfor signal in self.get_signals(only_notifiers=only_notifiers):\nsignal_name = signal.get_name()\nsignal_instance = source_qobject.__getattribute__(signal_name)\nslot = (\nfn_or_qobject.__getattribute__(signal_name)\nif isinstance(fn_or_qobject, QtCore.QObject)\nelse fn_or_qobject\n)\nhandle = signal_instance.connect(slot)\nhandles.append(handle)\nlogger.debug(f\"connected {len(handles)} signals to {fn_or_qobject}.\")\nreturn handles\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.copy","title":"<code>copy(qobject: core.QObject, forward_signals: bool = True)</code>","text":"<p>Create a copy of given QObject.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def copy(self, qobject: core.QObject, forward_signals: bool = True):\n\"\"\"Create a copy of given QObject.\"\"\"\ntry:\nnew = type(qobject)()\nexcept TypeError:\n# this should should cover most cases.\nnew = type(qobject)(qobject.orientation())\nfor prop in self.get_properties(only_writable=True):\nval = prop.read(qobject)\nprop.write(new, val)\nif forward_signals:\nself.connect_signals(new, qobject)\nlogger.debug(f\"copied {qobject!r}\")\nreturn new\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_all_super_classes","title":"<code>get_all_super_classes() -&gt; list[MetaObject]</code>","text":"<p>Get SuperClass MetaObject.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_all_super_classes(self) -&gt; list[MetaObject]:\n\"\"\"Get SuperClass MetaObject.\"\"\"\nklasses = []\nwhile klass := self.superClass():\nklasses.append(MetaObject(klass))\nreturn klasses\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_class_info","title":"<code>get_class_info(include_super: bool = True) -&gt; dict[str, str]</code>","text":"<p>Get MetaObject class info.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_class_info(self, include_super: bool = True) -&gt; dict[str, str]:\n\"\"\"Get MetaObject class info.\"\"\"\nstart = 0 if include_super else self.item.classInfoOffset() - 1\ncount = self.item.classInfoCount()\nclassinfos = [self.item.classInfo(i) for i in range(start, count)]\nreturn {i.name(): i.value() for i in classinfos}\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_constructor","title":"<code>get_constructor(index: int | str) -&gt; core.MetaMethod</code>","text":"<p>Get ctor MetaMethod based on index or name.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_constructor(self, index: int | str) -&gt; core.MetaMethod:\n\"\"\"Get ctor MetaMethod based on index or name.\"\"\"\nif isinstance(index, int):\nmethod = core.MetaMethod(self.item.constructor(index))\nif not method.isValid():\nraise KeyError(index)\nreturn method\nfor method in self.get_constructors():\nif method.get_name() in [index, helpers.to_lower_camel(index)]:\nreturn method\nraise KeyError(index)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_constructors","title":"<code>get_constructors() -&gt; list[core.MetaMethod]</code>","text":"<p>Get all ctor MetaMethods.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_constructors(self) -&gt; list[core.MetaMethod]:\n\"\"\"Get all ctor MetaMethods.\"\"\"\ncount = self.item.constructorCount()\nreturn [core.MetaMethod(self.item.constructor(i)) for i in range(count)]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_enum","title":"<code>get_enum(index: int | str) -&gt; core.MetaEnum</code>","text":"<p>Get MetaEnum based on index or name.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_enum(self, index: int | str) -&gt; core.MetaEnum:\n\"\"\"Get MetaEnum based on index or name.\"\"\"\nif isinstance(index, int):\nenum = core.MetaEnum(self.item.enumerator(index))\nif not enum.isValid():\nraise KeyError(index)\nreturn enum\nfor enumerator in self.get_enums():\nif enumerator.get_name() in [index, helpers.to_lower_camel(index)]:\nreturn enumerator\nraise KeyError(index)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_enums","title":"<code>get_enums(include_super: bool = True) -&gt; list[core.MetaEnum]</code>","text":"<p>Get all MetaEnums based on given criteria.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_enums(self, include_super: bool = True) -&gt; list[core.MetaEnum]:\n\"\"\"Get all MetaEnums based on given criteria.\"\"\"\nstart = 0 if include_super else self.item.enumeratorOffset() - 1\nreturn [self.get_enum(i) for i in range(start, self.item.enumeratorCount())]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_meta_type","title":"<code>get_meta_type() -&gt; core.MetaType</code>","text":"<p>Get Meta type of this MetaObject.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_meta_type(self) -&gt; core.MetaType:\n\"\"\"Get Meta type of this MetaObject.\"\"\"\nreturn core.MetaType(self.metaType().id())\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_method","title":"<code>get_method(index: int | str) -&gt; core.MetaMethod</code>","text":"<p>Get MetaMethod based on index or name.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_method(self, index: int | str) -&gt; core.MetaMethod:\n\"\"\"Get MetaMethod based on index or name.\"\"\"\nif isinstance(index, int):\nmethod = core.MetaMethod(self.item.method(index))\nif not method.isValid():\nraise KeyError(index)\nreturn method\nfor method in self.get_methods():\nif method.get_name() in [index, helpers.to_lower_camel(index)]:\nreturn method\nraise KeyError(index)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_methods","title":"<code>get_methods(include_super: bool = True, type_filter: core.metamethod.MethodTypeStr | None = None, filter_shit: bool = True) -&gt; list[core.MetaMethod]</code>","text":"<p>Get all MetaMethods based on given criteria.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_methods(\nself,\ninclude_super: bool = True,\ntype_filter: core.metamethod.MethodTypeStr | None = None,\nfilter_shit: bool = True,\n) -&gt; list[core.MetaMethod]:\n\"\"\"Get all MetaMethods based on given criteria.\"\"\"\nstart = 0 if include_super else self.item.methodOffset() - 1\nmethods = [\nmethod\nfor i in range(start, self.item.methodCount())\nif not (method := self.get_method(i)).get_name().startswith(\"_q_\")\nor not filter_shit\n]\nif type_filter is None:\nreturn methods\nelse:\nreturn [i for i in methods if i.get_method_type() == type_filter]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_name","title":"<code>get_name() -&gt; str</code>","text":"<p>Get MetaObject class name.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_name(self) -&gt; str:\n\"\"\"Get MetaObject class name.\"\"\"\nreturn self.className()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_plain_methods","title":"<code>get_plain_methods(include_super: bool = True) -&gt; list[core.MetaMethod]</code>","text":"<p>Get all plain MetaMethods based on given criteria.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_plain_methods(self, include_super: bool = True) -&gt; list[core.MetaMethod]:\n\"\"\"Get all plain MetaMethods based on given criteria.\"\"\"\nreturn self.get_methods(include_super=include_super, type_filter=\"method\")\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_properties","title":"<code>get_properties(include_super: bool = True, only_writable: bool = False, only_stored: bool = False, only_bindable: bool = False, only_designable: bool = False, only_final: bool = False, only_required: bool = False, only_enum_type: bool = False, only_flag_type: bool = False, only_with_notifiers: bool = False, only_with_type_name: str = '') -&gt; list[core.MetaProperty]</code>","text":"<p>Get all MetaProperties based on given criteria.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_properties(\nself,\ninclude_super: bool = True,\nonly_writable: bool = False,\nonly_stored: bool = False,\nonly_bindable: bool = False,\nonly_designable: bool = False,\nonly_final: bool = False,\nonly_required: bool = False,\nonly_enum_type: bool = False,\nonly_flag_type: bool = False,\nonly_with_notifiers: bool = False,\nonly_with_type_name: str = \"\",\n) -&gt; list[core.MetaProperty]:\n\"\"\"Get all MetaProperties based on given criteria.\"\"\"\nstart = 0 if include_super else self.item.propertyOffset() - 1\ncount = self.item.propertyCount()\nprop_list = []\nfor i in range(start, count):\nprop = self.item.property(i)\nif (\n(only_writable and not prop.isWritable())\nor (only_stored and not prop.isStored())\nor (only_bindable and not prop.isBindable())\nor (only_designable and not prop.isDesignable())\nor (only_final and not prop.isFinal())\nor (only_required and not prop.isRequired())\nor (only_enum_type and not prop.isEnumType())\nor (only_flag_type and not prop.isFlagType())\nor (only_with_notifiers and not prop.hasNotifier())\nor (only_with_type_name and prop.typeName() != only_with_type_name)\n):\ncontinue\nprop_list.append(core.MetaProperty(prop))\nreturn prop_list\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_property","title":"<code>get_property(index: int | str) -&gt; core.MetaProperty</code>","text":"<p>Get MetaProperty based on index or name.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_property(self, index: int | str) -&gt; core.MetaProperty:\n\"\"\"Get MetaProperty based on index or name.\"\"\"\nif isinstance(index, int):\nprop = core.MetaProperty(self.item.property(index))\nif not prop.isValid():\nraise KeyError(index)\nreturn prop\nfor prop in self.get_properties():\nif prop.get_name() in [index, helpers.to_lower_camel(index)]:\nreturn prop\nraise KeyError(index)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_property_class_affiliations","title":"<code>get_property_class_affiliations() -&gt; dict[str, list[core.MetaProperty]]</code>","text":"<p>Get a mapping of class -&gt; property affiliations.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_property_class_affiliations(self) -&gt; dict[str, list[core.MetaProperty]]:\n\"\"\"Get a mapping of class -&gt; property affiliations.\"\"\"\nmapper = {}\nmetaclass = self\nwhile metaclass is not None:\nmapper[metaclass.get_name()] = [\nmetaclass.get_property(i)\nfor i in range(metaclass.propertyOffset(), metaclass.propertyCount())\n]\nmetaclass = metaclass.get_super_class()\nreturn mapper\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_property_values","title":"<code>get_property_values(qobject: core.QObject, cast_types: bool = False) -&gt; dict[str, Any]</code>","text":"<p>Get a dictionary containing all MetaProperties values from given qobject.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_property_values(\nself, qobject: core.QObject, cast_types: bool = False\n) -&gt; dict[str, Any]:\n\"\"\"Get a dictionary containing all MetaProperties values from given qobject.\"\"\"\nvals = {prop.get_name(): prop.read(qobject) for prop in self.get_properties()}\nif cast_types:\nreturn {k: datatypes.make_serializable(v) for k, v in vals.items()}\nelse:\nreturn vals\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_signals","title":"<code>get_signals(include_super: bool = True, only_notifiers: bool = False) -&gt; list[core.MetaMethod]</code>","text":"<p>Get all signal MetaMethods based on given criteria.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_signals(\nself, include_super: bool = True, only_notifiers: bool = False\n) -&gt; list[core.MetaMethod]:\n\"\"\"Get all signal MetaMethods based on given criteria.\"\"\"\nif only_notifiers:\nreturn [  # type: ignore\nprop.get_notify_signal()\nfor prop in self.get_properties(include_super)\nif prop.hasNotifySignal()\n]\nelse:\nreturn self.get_methods(include_super=include_super, type_filter=\"signal\")\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_slots","title":"<code>get_slots(include_super: bool = True) -&gt; list[core.MetaMethod]</code>","text":"<p>Get all slot MetaMethods based on given criteria.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_slots(self, include_super: bool = True) -&gt; list[core.MetaMethod]:\n\"\"\"Get all slot MetaMethods based on given criteria.\"\"\"\nreturn self.get_methods(include_super=include_super, type_filter=\"slot\")\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_super_class","title":"<code>get_super_class() -&gt; MetaObject | None</code>","text":"<p>Get SuperClass MetaObject.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_super_class(self) -&gt; MetaObject | None:\n\"\"\"Get SuperClass MetaObject.\"\"\"\nreturn MetaObject(klass) if (klass := self.superClass()) is not None else None\n</code></pre>"},{"location":"api/core.html#prettyqt.core.metaobject.MetaObject.get_user_property","title":"<code>get_user_property() -&gt; core.MetaProperty | None</code>","text":"<p>Get MetaProperty marked as userprop.</p> Source code in <code>prettyqt\\core\\metaobject.py</code> <pre><code>def get_user_property(self) -&gt; core.MetaProperty | None:\n\"\"\"Get MetaProperty marked as userprop.\"\"\"\nreturn core.MetaProperty(p) if (p := self.userProperty()).isValid() else None\n</code></pre>"},{"location":"api/core.html#prettyqt.core.ObjectMixin","title":"<code>ObjectMixin</code>","text":"Source code in <code>prettyqt\\core\\object.py</code> <pre><code>class ObjectMixin:\ndef __init__(self, *args, **kwargs):\nself._eventfilters = set()\n# klass = type(self)\n# if issubclass(klass, QtCore.QObject) and klass not in _properties:\n#     metaobj = core.MetaObject(klass.staticMetaObject)\n#     _properties[klass] = [i.get_name() for i in metaobj.get_properties()]\n#     _signals[klass] = [i.get_name() for i in metaobj.get_signals()]\nnew = {}\nif kwargs:\nmapper = self._get_map()\nprops = get_properties(type(self))\nsignals = get_signals(type(self))\nfor k, v in kwargs.items():\n# this allows snake_case naming.\ncamel_k = helpers.to_lower_camel(k)\nif camel_k != k and camel_k in kwargs:\nlogger.warning(f\"{k} defined twice: {v} / {kwargs[camel_k]}\")\n# allow str values instead of enum\nif camel_k in mapper and isinstance(v, str):\nnew[camel_k] = mapper[camel_k][v]\n# allow str values for common icon kwargs\nelif camel_k in {\"windowIcon\", \"icon\"} and isinstance(v, str):\nfrom prettyqt import iconprovider\nnew[camel_k] = iconprovider.get_icon(v)\n# kwargs which need camel-casing\nelif camel_k in props or camel_k in signals:\nnew[camel_k] = v\nelse:\nnew[k] = v\nsuper().__init__(*args, **new)\ndef _get_map(self):\n\"\"\"Can be implemented by subclasses to support str -&gt; Enum conversion.\n        To get data from all subclasses, we always fetch _get_map from super(),\n        append our own shit and return it.\n        \"\"\"\nreturn {}\ndef __pretty__(\nself, fmt: Callable[[Any], Any], **kwargs: Any\n) -&gt; Generator[Any, None, None]:\nyield f\"{type(self).__name__}(\"\nyield 1\nfor k, v in self.get_properties(only_writable=True).items():\nyield f\"{k}={v!r}\"\nyield 0\nfor ef in self._eventfilters:\nyield f\"Eventfilter={ef.__class__.__name__}\"\nyield 0\nyield -1\nyield \")\"\n# def __repr__(self):  # we already monkeypatch QObject\n#     return get_repr(self, self.objectName())\ndef __setstate__(self, state):\nself.set_properties(state)\ndef __getstate__(self):\nreturn self.get_properties()\ndef __reduce__(self):\nreturn type(self), (), self.__getstate__()\ndef __getattr__(self, val):\ncameled = helpers.to_lower_camel(val)\nif cameled in dir(self):\nreturn getattr(self, cameled)\nraise AttributeError(val)\ndef installEventFilter(self, filter_: QtCore.QObject | str, **kwargs):\n\"\"\"Override to also allow setting eventfilters by name.\"\"\"\nif filter_ in self._eventfilters:\nlogger.warning(f\"Installing same EventFilter multiple times to {self}.\")\nreturn\nmatch filter_:\ncase QtCore.QObject():\npass\ncase str():\nfrom prettyqt import eventfilters\nKlass = helpers.get_class_for_id(eventfilters.BaseEventFilter, filter_)\nfilter_ = Klass(parent=self, **kwargs)\ncase _:\nraise ValueError(filter_)\nself._eventfilters.add(filter_)\nsuper().installEventFilter(filter_)\ndef removeEventFilter(self, eventfilter: QtCore.QObject):\nif eventfilter not in self._eventfilters:\nlogger.warning(\"Trying to remove non-installed EventFilter.\")\nreturn\nself._eventfilters.remove(eventfilter)\nsuper().removeEventFilter(eventfilter)\ndef add_callback_for_event(\nself,\ncallback: Callable[[QtCore.QEvent], bool],\ninclude: QtCore.QEvent.Type | Sequence[QtCore.QEvent.Type] | None = None,\nexclude: QtCore.QEvent.Type | Sequence[QtCore.QEvent.Type] | None = None,\n) -&gt; eventfilters.EventCatcher:\n\"\"\"Connect widget events to a callback.\n        if include is set, it behaves like a whitelist.\n        if exclude is set, it behaves like a blacklist.\n        The QEvent is passed to the callback as an argument, and the callback\n        needs to return True or False to indicate whether the Event should be filtered.\n        Arguments:\n            callback: Callback to execute when event is triggered\n            include: Events to include\n            exclude: Events to exclude\n        \"\"\"\nfrom prettyqt import eventfilters\neventfilter = eventfilters.EventCatcher(include, exclude, callback, parent=self)\nself.installEventFilter(eventfilter)\nreturn eventfilter\ndef serialize(self) -&gt; dict[str, Any]:\nreturn self.get_properties()\n# dct = {}\n# for klass in reversed(inspect.getmro(type(self))):\n#     if \"serialize_fields\" in klass.__dict__:\n#         data = klass.serialize_fields(self)  # type: ignore\n#         dct |= data\n# return dct\n@contextlib.contextmanager\ndef signals_blocked(self):\n\"\"\"Context manager to temporarily block emitting signals.\"\"\"\nblocked = self.blockSignals(True)\nyield self\nself.blockSignals(blocked)\n@contextlib.contextmanager\ndef signal_blocked(\nself, signal: core.SignalInstance, receiver: Callable | core.SignalInstance\n):\n\"\"\"Context manager to temporarily disconnect specific signal.\"\"\"\nsignal.disconnect(receiver)\nyield self\nsignal.connect(receiver)\n@contextlib.contextmanager\ndef properties_set_to(self, **kwargs):\nprops = {k: self.property(k) for k in kwargs}\nfor k, v in kwargs.items():\nself.setProperty(k, v)\nyield self\nfor k, v in props.items():\nself.setProperty(k, v)\ndef to_json(self):\ndct = self.__getstate__()\nfor k, v in dct.items():\nif isinstance(v, ObjectMixin):\ndct[k] = v.to_json()\nreturn dct\ndef set_unique_id(self):\n\"\"\"Set unique objectName.\"\"\"\nclass_name = type(self).__name__\ncount = next(counter_dict[class_name])\nself.set_id(f\"{class_name}_{count}\")\ndef set_id(self, name: str):\nself.setObjectName(name)\ndef get_id(self) -&gt; str:\nreturn self.objectName()\ndef has_id(self) -&gt; bool:\nreturn self.objectName() != \"\"\n@classmethod\ndef get_static_metaobject(cls) -&gt; core.MetaObject:\nreturn core.MetaObject(cls.staticMetaObject)\ndef get_metaobject(self) -&gt; core.MetaObject:\nreturn core.MetaObject(self.metaObject())\n# @property\n# def id(self) -&gt; str:\n#     return self.objectName()\n# @id.setter\n# def id(self, name: str):\n#     self.setObjectName(name)\ndef find_children(\nself,\ntyp: type[T] = QtCore.QObject,\nname: str | datatypes.PatternType | None = None,\nrecursive: bool = True,\nproperty_selector: dict[str, datatypes.VariantType | Callable] | None = None,\nonly_prettyqt_classes: bool = False,\n) -&gt; listdelegators.BaseListDelegator[T]:\n\"\"\"Find children with given type and name.\n        Children can be filtered by passing a property selector dictionary.\n        It must contain the property name for keys and either a value which must be set\n        or a predicate function which gets the property value as an argument\n        and must return True if the child should be included.\n        Arguments:\n            typ: Subclass of QObject (can also be a UnionType)\n            name: ObjectName filter. None includes all.\n            recursive: whether to search for children recursively.\n            property_selector: dict containing PropertyName -&gt; Value/Predicate pairs.\n            only_prettyqt_classes: only include objects with prettyqt superpowers.\n        Returns:\n            list of QObjects\n        \"\"\"\nif isinstance(name, re.Pattern):\nname = core.RegularExpression(name)\nif recursive:\nflag = constants.FindChildOption.FindChildrenRecursively\nelse:\nflag = constants.FindChildOption.FindDirectChildrenOnly\nmatch typ:\ncase types.UnionType():\nobjects = [\ni\nfor t in get_args(typ)\nfor i in self.findChildren(t, name=name, options=flag)\n]\ncase type():\nobjects = self.findChildren(typ, name=name, options=flag)\ncase _:\nraise TypeError(typ)\nif property_selector:\nobjects = [\no\nfor o in objects\nfor k, v in property_selector.items()\nif (callable(v) and v(o.property(k)))\nor (not callable(v) and o.property(k) == v)\n]\nif only_prettyqt_classes:\nobjects = [i for i in objects if i.__module__.startswith(\"prettyqt\")]\nreturn listdelegators.BaseListDelegator(objects)\ndef find_child(\nself,\ntyp: type[T] = QtCore.QObject,\nname: str | QtCore.QRegularExpression | None = None,\nrecursive: bool = True,\n) -&gt; T | None:\n\"\"\"Find a child with given type and name.\"\"\"\nif recursive:\nflag = constants.FindChildOption.FindChildrenRecursively\nelse:\nflag = constants.FindChildOption.FindDirectChildrenOnly\nmatch typ:\ncase types.UnionType():\nreturn next(\n(item for item in self.find_children(typ, name, recursive=recursive)),\nNone,\n)\ncase _:\nreturn self.findChild(typ, name, flag)  # type: ignore\ndef find_parent(\nself, typ: type[T] = QtCore.QObject, name: str | None = None\n) -&gt; T | None:\n\"\"\"Find parent with given type or name.\"\"\"\nnode = self\nwhile node:\nnode = node.parent()\nif isinstance(node, typ) and (name is None or node.objectName() == name):\nreturn node\nreturn None\ndef start_timer(\nself,\ninterval: int | str,\ntimer_type: constants.TimerTypeStr = \"coarse\",\n) -&gt; int | None:\n\"\"\"Start a timer and return the timer id, to be used in timerEvent.\"\"\"\nif isinstance(interval, str):\ninterval = helpers.parse_time(interval)\nresult = self.startTimer(interval, constants.TIMER_TYPE[timer_type])\nreturn None if result == 0 else result\ndef start_callback_timer(\nself,\ncallback: Callable,\ninterval: int | str,\nsingle_shot: bool = False,\ntimer_type: constants.TimerTypeStr = \"coarse\",\n) -&gt; core.Timer:\n\"\"\"Start timer and execute callback when timeout reached.\"\"\"\ninterval = helpers.parse_time(interval) if isinstance(interval, str) else interval\ntimer = core.Timer(\nself,\nsingle_shot=single_shot,\ninterval=interval,\ntimer_type=timer_type,\ntimeout=callback,\n)\ntimer.start()\nreturn timer\ndef get_properties(\nself,\ninclude_super: bool = True,\ncast: bool = True,\nonly_writable: bool = False,\nonly_nonempty: bool = False,\n) -&gt; dict[str, Any]:\n\"\"\"Get a dictionary containing all properties and their values.\"\"\"\nmetaobj = self.get_metaobject()\nprops = metaobj.get_properties(\ninclude_super=include_super, only_writable=only_writable\n)\ndct = {}\nfor i in props:\nif i.get_name() in [\"children\", \"frameShadow\", \"state\"]:\ncontinue\nval = i.read(self)\nif only_nonempty:\nmatch val:\ncase _ if hasattr(val, \"isNull\"):\ninclude = not val.isNull()\ncase _ if hasattr(val, \"isEmpty\"):\ninclude = not val.isEmpty()\ncase _ if hasattr(val, \"isValid\"):\ninclude = val.isValid()\ncase _:\ninclude = bool(val)\nelse:\ninclude = True\nif not include:\ncontinue\ndct[i.name()] = datatypes.make_serializable(val) if cast else val\nreturn dct\ndef set_properties(self, props: dict[str, Any], include_super: bool = True):\n\"\"\"Set properties from a dictionary.\"\"\"\nmetaobj = self.get_metaobject()\nmetaprops = metaobj.get_properties(include_super=include_super)\nfor metaprop in metaprops:\nif (name := metaprop.name()) in props:\nvalue = props[name]\nmetaprop.write(self, value)\ndef get_dynamic_properties(self) -&gt; dict[str, Any]:\n\"\"\"Get a dictionary with all dynamic properties.\"\"\"\nreturn {\n(k := i.data().decode()): self.property(k)\nfor i in self.dynamicPropertyNames()\n}\ndef bind_property(cls, object_name: str, prop_name: str) -&gt; property:\ndef getter(self):\nreturn self.findChild(cls, object_name).property(prop_name)\ndef setter(self, value):\nself.findChild(cls, object_name).setProperty(prop_name, value)\nreturn property(getter, setter)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def __init__(self, *args, **kwargs):\nself._eventfilters = set()\n# klass = type(self)\n# if issubclass(klass, QtCore.QObject) and klass not in _properties:\n#     metaobj = core.MetaObject(klass.staticMetaObject)\n#     _properties[klass] = [i.get_name() for i in metaobj.get_properties()]\n#     _signals[klass] = [i.get_name() for i in metaobj.get_signals()]\nnew = {}\nif kwargs:\nmapper = self._get_map()\nprops = get_properties(type(self))\nsignals = get_signals(type(self))\nfor k, v in kwargs.items():\n# this allows snake_case naming.\ncamel_k = helpers.to_lower_camel(k)\nif camel_k != k and camel_k in kwargs:\nlogger.warning(f\"{k} defined twice: {v} / {kwargs[camel_k]}\")\n# allow str values instead of enum\nif camel_k in mapper and isinstance(v, str):\nnew[camel_k] = mapper[camel_k][v]\n# allow str values for common icon kwargs\nelif camel_k in {\"windowIcon\", \"icon\"} and isinstance(v, str):\nfrom prettyqt import iconprovider\nnew[camel_k] = iconprovider.get_icon(v)\n# kwargs which need camel-casing\nelif camel_k in props or camel_k in signals:\nnew[camel_k] = v\nelse:\nnew[k] = v\nsuper().__init__(*args, **new)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.add_callback_for_event","title":"<code>add_callback_for_event(callback: Callable[[QtCore.QEvent], bool], include: QtCore.QEvent.Type | Sequence[QtCore.QEvent.Type] | None = None, exclude: QtCore.QEvent.Type | Sequence[QtCore.QEvent.Type] | None = None) -&gt; eventfilters.EventCatcher</code>","text":"<p>Connect widget events to a callback.</p> <p>if include is set, it behaves like a whitelist. if exclude is set, it behaves like a blacklist. The QEvent is passed to the callback as an argument, and the callback needs to return True or False to indicate whether the Event should be filtered.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[QtCore.QEvent], bool]</code> <p>Callback to execute when event is triggered</p> required <code>include</code> <code>QtCore.QEvent.Type | Sequence[QtCore.QEvent.Type] | None</code> <p>Events to include</p> <code>None</code> <code>exclude</code> <code>QtCore.QEvent.Type | Sequence[QtCore.QEvent.Type] | None</code> <p>Events to exclude</p> <code>None</code> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def add_callback_for_event(\nself,\ncallback: Callable[[QtCore.QEvent], bool],\ninclude: QtCore.QEvent.Type | Sequence[QtCore.QEvent.Type] | None = None,\nexclude: QtCore.QEvent.Type | Sequence[QtCore.QEvent.Type] | None = None,\n) -&gt; eventfilters.EventCatcher:\n\"\"\"Connect widget events to a callback.\n    if include is set, it behaves like a whitelist.\n    if exclude is set, it behaves like a blacklist.\n    The QEvent is passed to the callback as an argument, and the callback\n    needs to return True or False to indicate whether the Event should be filtered.\n    Arguments:\n        callback: Callback to execute when event is triggered\n        include: Events to include\n        exclude: Events to exclude\n    \"\"\"\nfrom prettyqt import eventfilters\neventfilter = eventfilters.EventCatcher(include, exclude, callback, parent=self)\nself.installEventFilter(eventfilter)\nreturn eventfilter\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.find_child","title":"<code>find_child(typ: type[T] = QtCore.QObject, name: str | QtCore.QRegularExpression | None = None, recursive: bool = True) -&gt; T | None</code>","text":"<p>Find a child with given type and name.</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def find_child(\nself,\ntyp: type[T] = QtCore.QObject,\nname: str | QtCore.QRegularExpression | None = None,\nrecursive: bool = True,\n) -&gt; T | None:\n\"\"\"Find a child with given type and name.\"\"\"\nif recursive:\nflag = constants.FindChildOption.FindChildrenRecursively\nelse:\nflag = constants.FindChildOption.FindDirectChildrenOnly\nmatch typ:\ncase types.UnionType():\nreturn next(\n(item for item in self.find_children(typ, name, recursive=recursive)),\nNone,\n)\ncase _:\nreturn self.findChild(typ, name, flag)  # type: ignore\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.find_children","title":"<code>find_children(typ: type[T] = QtCore.QObject, name: str | datatypes.PatternType | None = None, recursive: bool = True, property_selector: dict[str, datatypes.VariantType | Callable] | None = None, only_prettyqt_classes: bool = False) -&gt; listdelegators.BaseListDelegator[T]</code>","text":"<p>Find children with given type and name.</p> <p>Children can be filtered by passing a property selector dictionary. It must contain the property name for keys and either a value which must be set or a predicate function which gets the property value as an argument and must return True if the child should be included.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[T]</code> <p>Subclass of QObject (can also be a UnionType)</p> <code>QtCore.QObject</code> <code>name</code> <code>str | datatypes.PatternType | None</code> <p>ObjectName filter. None includes all.</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>whether to search for children recursively.</p> <code>True</code> <code>property_selector</code> <code>dict[str, datatypes.VariantType | Callable] | None</code> <p>dict containing PropertyName -&gt; Value/Predicate pairs.</p> <code>None</code> <code>only_prettyqt_classes</code> <code>bool</code> <p>only include objects with prettyqt superpowers.</p> <code>False</code> <p>Returns:</p> Type Description <code>listdelegators.BaseListDelegator[T]</code> <p>list of QObjects</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def find_children(\nself,\ntyp: type[T] = QtCore.QObject,\nname: str | datatypes.PatternType | None = None,\nrecursive: bool = True,\nproperty_selector: dict[str, datatypes.VariantType | Callable] | None = None,\nonly_prettyqt_classes: bool = False,\n) -&gt; listdelegators.BaseListDelegator[T]:\n\"\"\"Find children with given type and name.\n    Children can be filtered by passing a property selector dictionary.\n    It must contain the property name for keys and either a value which must be set\n    or a predicate function which gets the property value as an argument\n    and must return True if the child should be included.\n    Arguments:\n        typ: Subclass of QObject (can also be a UnionType)\n        name: ObjectName filter. None includes all.\n        recursive: whether to search for children recursively.\n        property_selector: dict containing PropertyName -&gt; Value/Predicate pairs.\n        only_prettyqt_classes: only include objects with prettyqt superpowers.\n    Returns:\n        list of QObjects\n    \"\"\"\nif isinstance(name, re.Pattern):\nname = core.RegularExpression(name)\nif recursive:\nflag = constants.FindChildOption.FindChildrenRecursively\nelse:\nflag = constants.FindChildOption.FindDirectChildrenOnly\nmatch typ:\ncase types.UnionType():\nobjects = [\ni\nfor t in get_args(typ)\nfor i in self.findChildren(t, name=name, options=flag)\n]\ncase type():\nobjects = self.findChildren(typ, name=name, options=flag)\ncase _:\nraise TypeError(typ)\nif property_selector:\nobjects = [\no\nfor o in objects\nfor k, v in property_selector.items()\nif (callable(v) and v(o.property(k)))\nor (not callable(v) and o.property(k) == v)\n]\nif only_prettyqt_classes:\nobjects = [i for i in objects if i.__module__.startswith(\"prettyqt\")]\nreturn listdelegators.BaseListDelegator(objects)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.find_parent","title":"<code>find_parent(typ: type[T] = QtCore.QObject, name: str | None = None) -&gt; T | None</code>","text":"<p>Find parent with given type or name.</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def find_parent(\nself, typ: type[T] = QtCore.QObject, name: str | None = None\n) -&gt; T | None:\n\"\"\"Find parent with given type or name.\"\"\"\nnode = self\nwhile node:\nnode = node.parent()\nif isinstance(node, typ) and (name is None or node.objectName() == name):\nreturn node\nreturn None\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.get_dynamic_properties","title":"<code>get_dynamic_properties() -&gt; dict[str, Any]</code>","text":"<p>Get a dictionary with all dynamic properties.</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def get_dynamic_properties(self) -&gt; dict[str, Any]:\n\"\"\"Get a dictionary with all dynamic properties.\"\"\"\nreturn {\n(k := i.data().decode()): self.property(k)\nfor i in self.dynamicPropertyNames()\n}\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.get_properties","title":"<code>get_properties(include_super: bool = True, cast: bool = True, only_writable: bool = False, only_nonempty: bool = False) -&gt; dict[str, Any]</code>","text":"<p>Get a dictionary containing all properties and their values.</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def get_properties(\nself,\ninclude_super: bool = True,\ncast: bool = True,\nonly_writable: bool = False,\nonly_nonempty: bool = False,\n) -&gt; dict[str, Any]:\n\"\"\"Get a dictionary containing all properties and their values.\"\"\"\nmetaobj = self.get_metaobject()\nprops = metaobj.get_properties(\ninclude_super=include_super, only_writable=only_writable\n)\ndct = {}\nfor i in props:\nif i.get_name() in [\"children\", \"frameShadow\", \"state\"]:\ncontinue\nval = i.read(self)\nif only_nonempty:\nmatch val:\ncase _ if hasattr(val, \"isNull\"):\ninclude = not val.isNull()\ncase _ if hasattr(val, \"isEmpty\"):\ninclude = not val.isEmpty()\ncase _ if hasattr(val, \"isValid\"):\ninclude = val.isValid()\ncase _:\ninclude = bool(val)\nelse:\ninclude = True\nif not include:\ncontinue\ndct[i.name()] = datatypes.make_serializable(val) if cast else val\nreturn dct\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.installEventFilter","title":"<code>installEventFilter(filter_: QtCore.QObject | str, **kwargs: QtCore.QObject | str)</code>","text":"<p>Override to also allow setting eventfilters by name.</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def installEventFilter(self, filter_: QtCore.QObject | str, **kwargs):\n\"\"\"Override to also allow setting eventfilters by name.\"\"\"\nif filter_ in self._eventfilters:\nlogger.warning(f\"Installing same EventFilter multiple times to {self}.\")\nreturn\nmatch filter_:\ncase QtCore.QObject():\npass\ncase str():\nfrom prettyqt import eventfilters\nKlass = helpers.get_class_for_id(eventfilters.BaseEventFilter, filter_)\nfilter_ = Klass(parent=self, **kwargs)\ncase _:\nraise ValueError(filter_)\nself._eventfilters.add(filter_)\nsuper().installEventFilter(filter_)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.set_properties","title":"<code>set_properties(props: dict[str, Any], include_super: bool = True)</code>","text":"<p>Set properties from a dictionary.</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def set_properties(self, props: dict[str, Any], include_super: bool = True):\n\"\"\"Set properties from a dictionary.\"\"\"\nmetaobj = self.get_metaobject()\nmetaprops = metaobj.get_properties(include_super=include_super)\nfor metaprop in metaprops:\nif (name := metaprop.name()) in props:\nvalue = props[name]\nmetaprop.write(self, value)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.set_unique_id","title":"<code>set_unique_id()</code>","text":"<p>Set unique objectName.</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def set_unique_id(self):\n\"\"\"Set unique objectName.\"\"\"\nclass_name = type(self).__name__\ncount = next(counter_dict[class_name])\nself.set_id(f\"{class_name}_{count}\")\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.signal_blocked","title":"<code>signal_blocked(signal: core.SignalInstance, receiver: Callable | core.SignalInstance)</code>","text":"<p>Context manager to temporarily disconnect specific signal.</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>@contextlib.contextmanager\ndef signal_blocked(\nself, signal: core.SignalInstance, receiver: Callable | core.SignalInstance\n):\n\"\"\"Context manager to temporarily disconnect specific signal.\"\"\"\nsignal.disconnect(receiver)\nyield self\nsignal.connect(receiver)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.signals_blocked","title":"<code>signals_blocked()</code>","text":"<p>Context manager to temporarily block emitting signals.</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>@contextlib.contextmanager\ndef signals_blocked(self):\n\"\"\"Context manager to temporarily block emitting signals.\"\"\"\nblocked = self.blockSignals(True)\nyield self\nself.blockSignals(blocked)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.start_callback_timer","title":"<code>start_callback_timer(callback: Callable, interval: int | str, single_shot: bool = False, timer_type: constants.TimerTypeStr = 'coarse') -&gt; core.Timer</code>","text":"<p>Start timer and execute callback when timeout reached.</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def start_callback_timer(\nself,\ncallback: Callable,\ninterval: int | str,\nsingle_shot: bool = False,\ntimer_type: constants.TimerTypeStr = \"coarse\",\n) -&gt; core.Timer:\n\"\"\"Start timer and execute callback when timeout reached.\"\"\"\ninterval = helpers.parse_time(interval) if isinstance(interval, str) else interval\ntimer = core.Timer(\nself,\nsingle_shot=single_shot,\ninterval=interval,\ntimer_type=timer_type,\ntimeout=callback,\n)\ntimer.start()\nreturn timer\n</code></pre>"},{"location":"api/core.html#prettyqt.core.object.ObjectMixin.start_timer","title":"<code>start_timer(interval: int | str, timer_type: constants.TimerTypeStr = 'coarse') -&gt; int | None</code>","text":"<p>Start a timer and return the timer id, to be used in timerEvent.</p> Source code in <code>prettyqt\\core\\object.py</code> <pre><code>def start_timer(\nself,\ninterval: int | str,\ntimer_type: constants.TimerTypeStr = \"coarse\",\n) -&gt; int | None:\n\"\"\"Start a timer and return the timer id, to be used in timerEvent.\"\"\"\nif isinstance(interval, str):\ninterval = helpers.parse_time(interval)\nresult = self.startTimer(interval, constants.TIMER_TYPE[timer_type])\nreturn None if result == 0 else result\n</code></pre>"},{"location":"api/core.html#prettyqt.core.OperatingSystemVersion","title":"<code>OperatingSystemVersion</code>","text":"<p>         Bases: <code>QtCore.QOperatingSystemVersion</code></p> Source code in <code>prettyqt\\core\\operatingsystemversion.py</code> <pre><code>class OperatingSystemVersion(QtCore.QOperatingSystemVersion):\ndef __init__(\nself,\ntyp: QtCore.QOperatingSystemVersion.OSType | str,\nmajor: int,\nminor: int | None = None,\nmicro: int | None = None,\n):\nos_type = OS_TYPE[typ] if isinstance(typ, str) else typ\nif minor is None:\nminor = -1\nif micro is None:\nmicro = -1\nsuper().__init__(os_type, major, minor, micro)\ndef __repr__(self):\nreturn get_repr(\nself,\nself.get_type(),\nself.majorVersion(),\nself.minorVersion(),\nself.microVersion(),\n)\n@property\ndef _type(self) -&gt; OsTypeStr:\nreturn self.get_type()\n@property\ndef _majorVersion(self) -&gt; int:\nreturn self.majorVersion()\n@property\ndef _minorVersion(self) -&gt; int:\nreturn self.minorVersion()\n@property\ndef _macroVersion(self) -&gt; int:\nreturn self.macroVersion()\n__match_args__ = (\"_type\", \"_majorVersion\", \"_minorVersion\", \"_macroVersion\")\ndef __reduce__(self):\nreturn (\ntype(self),\n(\nself.get_type(),\nself.majorVersion(),\nself.minorVersion(),\nself.microVersion(),\n),\n)\ndef __eq__(self, other):\nreturn (\n(\nself.type() == other.type()\nand self.majorVersion() == other.majorVersion()\nand self.minorVersion() == other.minorVersion()\nand self.microVersion() == other.microVersion()\n)\nif isinstance(other, QtCore.QOperatingSystemVersion)\nelse False\n)\ndef __hash__(self):\nreturn hash(\n(\nself.get_type(),\nself.majorVersion(),\nself.minorVersion(),\nself.microVersion(),\n)\n)\ndef get_type(self) -&gt; OsTypeStr:\n\"\"\"Get current os type.\n        Returns:\n            current os type\n        \"\"\"\nreturn OS_TYPE.inverse[self.type()]\ndef get_versionnumber(self) -&gt; core.VersionNumber:\nreturn core.VersionNumber(\nself.majorVersion(), self.minorVersion(), self.microVersion()\n)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion.get_type","title":"<code>get_type() -&gt; OsTypeStr</code>","text":"<p>Get current os type.</p> <p>Returns:</p> Type Description <code>OsTypeStr</code> <p>current os type</p> Source code in <code>prettyqt\\core\\operatingsystemversion.py</code> <pre><code>def get_type(self) -&gt; OsTypeStr:\n\"\"\"Get current os type.\n    Returns:\n        current os type\n    \"\"\"\nreturn OS_TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.Process","title":"<code>Process</code>","text":"<p>         Bases: <code>core.IODeviceMixin</code>, <code>QtCore.QProcess</code></p> Source code in <code>prettyqt\\core\\process.py</code> <pre><code>class Process(core.IODeviceMixin, QtCore.QProcess):\ndef set_read_channel(\nself, channel: ProcessChannelStr | QtCore.QProcess.ProcessChannelMode\n):\n\"\"\"Set the input channel channel.\n        Args:\n            channel: channel to set\n        \"\"\"\nself.setReadChannel(PROCESS_CHANNELS.get_enum_value(channel))\ndef get_read_channel(self) -&gt; ProcessChannelStr:\nreturn PROCESS_CHANNELS.inverse[self.readChannel()]\ndef close_read_channel(self, channel: ProcessChannelStr):\nself.closeReadChannel(PROCESS_CHANNELS[channel])\ndef set_input_channel_mode(\nself, mode: InputChannelModeStr | QtCore.QProcess.InputChannelMode\n):\n\"\"\"Set the input channel mode.\n        Args:\n            mode: mode to set\n        \"\"\"\nself.setInputChannelMode(INPUT_CHANNEL_MODES.get_enum_value(mode))\ndef get_input_channel_mode(self) -&gt; InputChannelModeStr:\nreturn INPUT_CHANNEL_MODES.inverse[self.inputChannelMode()]\ndef set_process_channel_mode(\nself, mode: ProcessChannelModeStr | QtCore.QProcess.ProcessChannelMode\n):\n\"\"\"Set the process channel mode.\n        Args:\n            mode: mode to set\n        \"\"\"\nself.setProcessChannelMode(PROCESS_CHANNEL_MODES.get_enum_value(mode))\ndef get_process_channel_mode(self) -&gt; ProcessChannelModeStr:\nreturn PROCESS_CHANNEL_MODES.inverse[self.processChannelMode()]\ndef set_state(self, state: ProcessStateStr | QtCore.QProcess.ProcessState):\n\"\"\"Set the process state.\n        Args:\n            state: state to set\n        \"\"\"\nself.setProcessState(PROCESS_STATES.get_enum_value(state))\ndef get_state(self) -&gt; ProcessStateStr:\nreturn PROCESS_STATES.inverse[self.state()]\ndef get_error(self) -&gt; ProcessErrorStr:\nreturn PROCESS_ERRORS.inverse[self.error()]\ndef get_exit_status(self) -&gt; ExitStatusStr:\nreturn EXIT_STATUS.inverse[self.exitStatus()]\ndef get_process_environment(self) -&gt; core.ProcessEnvironment:\nreturn core.ProcessEnvironment(self.processEnvironment())\n@contextlib.contextmanager\ndef edit_process_environment(self):\nenv = self.get_process_environment()\nyield env\nself.setProcessEnvironment(env)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_input_channel_mode","title":"<code>set_input_channel_mode(mode: InputChannelModeStr | QtCore.QProcess.InputChannelMode)</code>","text":"<p>Set the input channel mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>InputChannelModeStr | QtCore.QProcess.InputChannelMode</code> <p>mode to set</p> required Source code in <code>prettyqt\\core\\process.py</code> <pre><code>def set_input_channel_mode(\nself, mode: InputChannelModeStr | QtCore.QProcess.InputChannelMode\n):\n\"\"\"Set the input channel mode.\n    Args:\n        mode: mode to set\n    \"\"\"\nself.setInputChannelMode(INPUT_CHANNEL_MODES.get_enum_value(mode))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_process_channel_mode","title":"<code>set_process_channel_mode(mode: ProcessChannelModeStr | QtCore.QProcess.ProcessChannelMode)</code>","text":"<p>Set the process channel mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ProcessChannelModeStr | QtCore.QProcess.ProcessChannelMode</code> <p>mode to set</p> required Source code in <code>prettyqt\\core\\process.py</code> <pre><code>def set_process_channel_mode(\nself, mode: ProcessChannelModeStr | QtCore.QProcess.ProcessChannelMode\n):\n\"\"\"Set the process channel mode.\n    Args:\n        mode: mode to set\n    \"\"\"\nself.setProcessChannelMode(PROCESS_CHANNEL_MODES.get_enum_value(mode))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_read_channel","title":"<code>set_read_channel(channel: ProcessChannelStr | QtCore.QProcess.ProcessChannelMode)</code>","text":"<p>Set the input channel channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>ProcessChannelStr | QtCore.QProcess.ProcessChannelMode</code> <p>channel to set</p> required Source code in <code>prettyqt\\core\\process.py</code> <pre><code>def set_read_channel(\nself, channel: ProcessChannelStr | QtCore.QProcess.ProcessChannelMode\n):\n\"\"\"Set the input channel channel.\n    Args:\n        channel: channel to set\n    \"\"\"\nself.setReadChannel(PROCESS_CHANNELS.get_enum_value(channel))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_state","title":"<code>set_state(state: ProcessStateStr | QtCore.QProcess.ProcessState)</code>","text":"<p>Set the process state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>ProcessStateStr | QtCore.QProcess.ProcessState</code> <p>state to set</p> required Source code in <code>prettyqt\\core\\process.py</code> <pre><code>def set_state(self, state: ProcessStateStr | QtCore.QProcess.ProcessState):\n\"\"\"Set the process state.\n    Args:\n        state: state to set\n    \"\"\"\nself.setProcessState(PROCESS_STATES.get_enum_value(state))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.PropertyAnimation","title":"<code>PropertyAnimation</code>","text":"<p>         Bases: <code>core.VariantAnimationMixin</code>, <code>QtCore.QPropertyAnimation</code></p> Source code in <code>prettyqt\\core\\propertyanimation.py</code> <pre><code>class PropertyAnimation(core.VariantAnimationMixin, QtCore.QPropertyAnimation):\nID = \"property\"\ndef __init__(self, *args, **kwargs):\nmatch args:\ncase (QtCore.QObject(), str(), *rest):\nsuper().__init__(args[0], bytes(args[1]), *rest, **kwargs)\ncase _:\nsuper().__init__(*args, **kwargs)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"easingCurve\": core.easingcurve.TYPE}\nreturn maps\ndef apply_to(self, method: Callable):\nself.setTargetObject(method.__self__)\nself.set_property_name(method.__name__)\ndef set_property_name(self, name: datatypes.ByteArrayType):\nname = datatypes.to_bytearray(name)\nself.setPropertyName(name)\ndef get_property_name(self) -&gt; str:\nreturn self.propertyName().data().decode()\ndef get_property_value(self) -&gt; Any:\n\"\"\"Return the value of the property which should get animated.\"\"\"\nprop_name = self.get_property_name()\nobj = self.targetObject()\nreturn obj.property(prop_name)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.propertyanimation.PropertyAnimation.get_property_value","title":"<code>get_property_value() -&gt; Any</code>","text":"<p>Return the value of the property which should get animated.</p> Source code in <code>prettyqt\\core\\propertyanimation.py</code> <pre><code>def get_property_value(self) -&gt; Any:\n\"\"\"Return the value of the property which should get animated.\"\"\"\nprop_name = self.get_property_name()\nobj = self.targetObject()\nreturn obj.property(prop_name)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.Settings","title":"<code>Settings</code>","text":"<p>         Bases: <code>Settings_</code></p> <p>Settings class which wraps everything into a dict to preserve data types.</p> Source code in <code>prettyqt\\core\\settings.py</code> <pre><code>class Settings(Settings_):\n\"\"\"Settings class which wraps everything into a dict to preserve data types.\"\"\"\ndef set_value(self, key: str, value):\nmatch value:\ncase Settings_():\nsetting = dict(value=dict(value), typ=\"subsetting\")\ncase _:\nsetting = dict(value=value, typ=\"regular\")\nsuper().set_value(key, setting)\ndef get_value(self, key: str, default=None):\nif not self.contains(key):\nreturn default\nval = self.value(key)\n# TODO: convert settings dicts back?\nmatch val:\ncase {\"value\": setting}:\nreturn setting\ncase _:\n# this is for migration\nself.set_value(key, val)\nreturn val\n</code></pre>"},{"location":"api/core.html#prettyqt.core.SocketNotifier","title":"<code>SocketNotifier</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtCore.QSocketNotifier</code></p> Source code in <code>prettyqt\\core\\socketnotifier.py</code> <pre><code>class SocketNotifier(core.ObjectMixin, QtCore.QSocketNotifier):\n# def __repr__(self):\n#     return f\"{type(self).__name__}({self.socket()}, {self.type()})\"\ndef get_type(self) -&gt; TypeStr:\n\"\"\"Return socket event type.\n        Returns:\n            socket event type\n        \"\"\"\nreturn TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.socketnotifier.SocketNotifier.get_type","title":"<code>get_type() -&gt; TypeStr</code>","text":"<p>Return socket event type.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>socket event type</p> Source code in <code>prettyqt\\core\\socketnotifier.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return socket event type.\n    Returns:\n        socket event type\n    \"\"\"\nreturn TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.SortFilterProxyModel","title":"<code>SortFilterProxyModel</code>","text":"<p>         Bases: <code>core.AbstractProxyModelMixin</code>, <code>QtCore.QSortFilterProxyModel</code></p> Source code in <code>prettyqt\\core\\sortfilterproxymodel.py</code> <pre><code>class SortFilterProxyModel(core.AbstractProxyModelMixin, QtCore.QSortFilterProxyModel):\nFilterMode = core.Enum(FilterMode)\ninvalidated = core.Signal()\nfilter_mode_changed = core.Signal(str)\nID = \"sort_filter\"\ndef __init__(self, *args, **kwargs):\nself._filter_mode: FilterModeStr = \"wildcard\"\nsuper().__init__(*args, **kwargs)\n#     self._filter_column = 0\n# def setFilterKeyColumn(self, column: int | list[int] | None):\n#     if column is None:\n#         column = -1\n#     self._filter_column = column\n# def filterKeyColumn(self) -&gt; int | list[int] | None:\n#     return self._filter_column\n# def filterAcceptsRow(self, source_row: int, source_index: core.ModelIndex):\n#     column = self.filterKeyColumn()\n#     col_count = self.sourceModel().columnCount()\n#     indexes = [\n#         self.sourceModel().index(source_row, i, source_index) for i in col_count\n#     ]\n#     labels = [self.sourceModel().data(idx) for idx in indexes]\n#     if isinstance(column, int) and source_index.column() == column:\n#         return super().filterAcceptsRow(source_row, source_index)\ndef filterAcceptsRow(self, source_row: int, source_index: core.ModelIndex) -&gt; bool:\nif self._filter_mode != \"fuzzy\":\nreturn super().filterAcceptsRow(source_row, source_index)\ncolumn = self.filterKeyColumn()\nsource_model = self.sourceModel()\nidx = source_model.index(source_row, column, source_index)\ntext = source_model.data(idx)\nreturn fuzzy.fuzzy_match_simple(\nself.filterRegularExpression().pattern(),\ntext,\ncase_sensitive=self.is_filter_case_sensitive(),\n)\ndef invalidate(self):\nsuper().invalidate()\nself.invalidated.emit()\ndef lessThan(self, left, right) -&gt; bool:\nrole = super().sortRole()\nleft_data = left.data(role)\nright_data = right.data(role)\nif left_data is not None and right_data is not None:\nreturn left_data &lt; right_data\nreturn True\ndef sort(\nself,\ncolumn: int | None,\nascending: bool | constants.SortOrder = constants.ASCENDING,\n):\nif isinstance(ascending, bool):\nascending = constants.ASCENDING if ascending else constants.DESCENDING\nif column is None:\ncolumn = -1\nsuper().sort(column, ascending)\ndef setFilterRegularExpression(self, pattern: datatypes.PatternType):\nif isinstance(pattern, re.Pattern):\npattern = core.RegularExpression(pattern)\nsuper().setFilterRegularExpression(pattern)\ndef setFilterString(self, search_str: str):\npat = \".*?\".join(map(re.escape, search_str))\npat = f\"(?=({pat}))\"\nsuper().setFilterRegularExpression(pat)\ndef setFixedFilterList(self, filter_list: Iterable[str]):\npat = \"|\".join(filter_list)\nsuper().setFilterRegularExpression(pat)\ndef set_filter_case_sensitivity(\nself, sensitivity: constants.CaseSensitivityStr | constants.CaseSensitivity\n):\n\"\"\"Set the filter case sensitivity.\n        Args:\n            sensitivity: filter case sensitivity\n        \"\"\"\nvalue = constants.CASE_SENSITIVITY.get_enum_value(sensitivity)\nsuper().setFilterCaseSensitivity(value)\ndef get_filter_case_sensitivity(self) -&gt; constants.CaseSensitivityStr:\n\"\"\"Return current filter case sensitivity.\n        Returns:\n            filter case sensitivity\n        \"\"\"\nreturn constants.CASE_SENSITIVITY.inverse[super().filterCaseSensitivity()]\ndef set_filter_case_sensitive(self, state: bool):\nif state:\nsensitivity = constants.CaseSensitivity.CaseSensitive\nelse:\nsensitivity = constants.CaseSensitivity.CaseInsensitive\nsuper().setFilterCaseSensitivity(sensitivity)\ndef is_filter_case_sensitive(self) -&gt; bool:\nreturn super().filterCaseSensitivity() == constants.CaseSensitivity.CaseSensitive\ndef set_sort_case_sensitive(self, state: bool):\nif state:\nsensitivity = constants.CaseSensitivity.CaseSensitive\nelse:\nsensitivity = constants.CaseSensitivity.CaseInsensitive\nsuper().setSortCaseSensitivity(sensitivity)\ndef is_sort_case_sensitive(self) -&gt; bool:\nreturn super().sortCaseSensitivity() == constants.CaseSensitivity.CaseSensitive\ndef get_filter_regular_expression(self) -&gt; core.RegularExpression:\nreturn core.RegularExpression(self.filterRegularExpression())\ndef set_sort_role(self, role: constants.ItemDataRoleStr | int):\nrole = constants.ITEM_DATA_ROLE[role] if isinstance(role, str) else role\nsuper().setSortRole(role)\ndef set_filter_role(self, role: constants.ItemDataRoleStr | int):\nrole = constants.ITEM_DATA_ROLE[role] if isinstance(role, str) else role\nsuper().setFilterRole(role)\ndef get_sort_order(self) -&gt; Literal[\"ascending\", \"descending\"]:\nreturn \"ascending\" if super().sortOrder() == constants.ASCENDING else \"descending\"\ndef set_filter_key_column(self, column: int | None):\nif column is None:\ncolumn = -1\nsuper().setFilterKeyColumn(column)\ndef set_search_term(self, search_term: str | Iterable[str]):\nmatch self._filter_mode:\ncase \"fixed_string\" if isinstance(search_term, list):\nself.setFixedFilterList(search_term)\ncase \"fixed_string\":\nself.setFilterFixedString(search_term)\ncase \"substring\":\nself.setFilterString(search_term)\ncase \"fuzzy\":\nself.setFilterFixedString(search_term)\ncase \"wildcard\":\nself.setFilterWildcard(search_term)\ncase \"regex\":\nself.setFilterRegularExpression(search_term)\ndef get_filter_mode(self) -&gt; FilterModeStr:\nreturn self._filter_mode\ndef set_filter_mode(self, mode: FilterModeStr):\nself._filter_mode = mode\nself.filter_mode_changed.emit(mode)\nfilterMode = core.Property(\nstr, get_filter_mode, set_filter_mode, notify=filter_mode_changed\n)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.sortfilterproxymodel.SortFilterProxyModel.get_filter_case_sensitivity","title":"<code>get_filter_case_sensitivity() -&gt; constants.CaseSensitivityStr</code>","text":"<p>Return current filter case sensitivity.</p> <p>Returns:</p> Type Description <code>constants.CaseSensitivityStr</code> <p>filter case sensitivity</p> Source code in <code>prettyqt\\core\\sortfilterproxymodel.py</code> <pre><code>def get_filter_case_sensitivity(self) -&gt; constants.CaseSensitivityStr:\n\"\"\"Return current filter case sensitivity.\n    Returns:\n        filter case sensitivity\n    \"\"\"\nreturn constants.CASE_SENSITIVITY.inverse[super().filterCaseSensitivity()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.sortfilterproxymodel.SortFilterProxyModel.set_filter_case_sensitivity","title":"<code>set_filter_case_sensitivity(sensitivity: constants.CaseSensitivityStr | constants.CaseSensitivity)</code>","text":"<p>Set the filter case sensitivity.</p> <p>Parameters:</p> Name Type Description Default <code>sensitivity</code> <code>constants.CaseSensitivityStr | constants.CaseSensitivity</code> <p>filter case sensitivity</p> required Source code in <code>prettyqt\\core\\sortfilterproxymodel.py</code> <pre><code>def set_filter_case_sensitivity(\nself, sensitivity: constants.CaseSensitivityStr | constants.CaseSensitivity\n):\n\"\"\"Set the filter case sensitivity.\n    Args:\n        sensitivity: filter case sensitivity\n    \"\"\"\nvalue = constants.CASE_SENSITIVITY.get_enum_value(sensitivity)\nsuper().setFilterCaseSensitivity(value)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.TextStream","title":"<code>TextStream</code>","text":"<p>         Bases: <code>QtCore.QTextStream</code></p> Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>class TextStream(QtCore.QTextStream):\ndef set_field_alignment(\nself, alignment: FieldAlignmentStr | QtCore.QTextStream.FieldAlignment\n):\n\"\"\"Set the field alignment.\n        Args:\n            alignment: field alignment\n        \"\"\"\nself.setFieldAlignment(FIELD_ALIGNMENT.get_enum_value(alignment))\ndef get_field_alignment(self) -&gt; FieldAlignmentStr:\n\"\"\"Get current field alignment.\n        Returns:\n            current field alignment\n        \"\"\"\nreturn FIELD_ALIGNMENT.inverse[self.fieldAlignment()]\ndef set_status(self, status: StatusStr | QtCore.QTextStream.Status):\n\"\"\"Set the status.\n        Args:\n            status: status\n        \"\"\"\nself.setStatus(STATUS.get_enum_value(status))\ndef get_status(self) -&gt; StatusStr:\n\"\"\"Get current status.\n        Returns:\n            current status\n        \"\"\"\nreturn STATUS.inverse[self.status()]\ndef set_real_number_notation(\nself, notation: RealNumberNotationStr | QtCore.QTextStream.RealNumberNotation\n):\n\"\"\"Set the real number notation.\n        Args:\n            notation: real number notation\n        \"\"\"\nself.setRealNumberNotation(REAL_NUMBER_NOTATION.get_enum_value(notation))\ndef get_real_number_notation(self) -&gt; RealNumberNotationStr:\n\"\"\"Get current real number notation.\n        Returns:\n            current real number notation\n        \"\"\"\nreturn REAL_NUMBER_NOTATION.inverse[self.realNumberNotation()]\ndef read_lines(self) -&gt; Iterator[str]:\nwhile True:\nif msg := self.readLine():\nyield msg\nelse:\nreturn\ndef get_number_flags(self) -&gt; list[NumberFlagStr]:\nreturn NUMBER_FLAGS.get_list(self.numberFlags())\ndef set_number_flags(self, *flags: NumberFlagStr):\nflag = NUMBER_FLAGS.merge_flags(flags)\nself.setNumberFlags(flag)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_field_alignment","title":"<code>get_field_alignment() -&gt; FieldAlignmentStr</code>","text":"<p>Get current field alignment.</p> <p>Returns:</p> Type Description <code>FieldAlignmentStr</code> <p>current field alignment</p> Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def get_field_alignment(self) -&gt; FieldAlignmentStr:\n\"\"\"Get current field alignment.\n    Returns:\n        current field alignment\n    \"\"\"\nreturn FIELD_ALIGNMENT.inverse[self.fieldAlignment()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_real_number_notation","title":"<code>get_real_number_notation() -&gt; RealNumberNotationStr</code>","text":"<p>Get current real number notation.</p> <p>Returns:</p> Type Description <code>RealNumberNotationStr</code> <p>current real number notation</p> Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def get_real_number_notation(self) -&gt; RealNumberNotationStr:\n\"\"\"Get current real number notation.\n    Returns:\n        current real number notation\n    \"\"\"\nreturn REAL_NUMBER_NOTATION.inverse[self.realNumberNotation()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_status","title":"<code>get_status() -&gt; StatusStr</code>","text":"<p>Get current status.</p> <p>Returns:</p> Type Description <code>StatusStr</code> <p>current status</p> Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def get_status(self) -&gt; StatusStr:\n\"\"\"Get current status.\n    Returns:\n        current status\n    \"\"\"\nreturn STATUS.inverse[self.status()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_field_alignment","title":"<code>set_field_alignment(alignment: FieldAlignmentStr | QtCore.QTextStream.FieldAlignment)</code>","text":"<p>Set the field alignment.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>FieldAlignmentStr | QtCore.QTextStream.FieldAlignment</code> <p>field alignment</p> required Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def set_field_alignment(\nself, alignment: FieldAlignmentStr | QtCore.QTextStream.FieldAlignment\n):\n\"\"\"Set the field alignment.\n    Args:\n        alignment: field alignment\n    \"\"\"\nself.setFieldAlignment(FIELD_ALIGNMENT.get_enum_value(alignment))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_real_number_notation","title":"<code>set_real_number_notation(notation: RealNumberNotationStr | QtCore.QTextStream.RealNumberNotation)</code>","text":"<p>Set the real number notation.</p> <p>Parameters:</p> Name Type Description Default <code>notation</code> <code>RealNumberNotationStr | QtCore.QTextStream.RealNumberNotation</code> <p>real number notation</p> required Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def set_real_number_notation(\nself, notation: RealNumberNotationStr | QtCore.QTextStream.RealNumberNotation\n):\n\"\"\"Set the real number notation.\n    Args:\n        notation: real number notation\n    \"\"\"\nself.setRealNumberNotation(REAL_NUMBER_NOTATION.get_enum_value(notation))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_status","title":"<code>set_status(status: StatusStr | QtCore.QTextStream.Status)</code>","text":"<p>Set the status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>StatusStr | QtCore.QTextStream.Status</code> <p>status</p> required Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def set_status(self, status: StatusStr | QtCore.QTextStream.Status):\n\"\"\"Set the status.\n    Args:\n        status: status\n    \"\"\"\nself.setStatus(STATUS.get_enum_value(status))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.ThreadPool","title":"<code>ThreadPool</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtCore.QThreadPool</code></p> <p>Note: signals only work correctly when exclusively using start_worker method.</p> Source code in <code>prettyqt\\core\\threadpool.py</code> <pre><code>class ThreadPool(core.ObjectMixin, QtCore.QThreadPool):\n\"\"\"Note: signals only work correctly when exclusively using start_worker method.\"\"\"\n__instance: Self | None = None  # a global instance\njob_num_updated = core.Signal(int)\nerror_occured = core.Signal(Exception)\nbusy_state_changed = core.Signal(bool)\ndef __contains__(self, other: QtCore.QThread):\nreturn self.contains(other)\ndef get_thread_priority(self) -&gt; core.thread.PriorityStr:\nreturn core.thread.PRIORITY.inverse[self.threadPriority()]\ndef set_thread_priority(self, priority: core.thread.PriorityStr):\nprio = core.thread.PRIORITY[priority]\nself.setThreadPriority(prio)\n@classmethod\ndef instance(cls) -&gt; Self:\n\"\"\"Return global ThreadPool singleton. (globalInstance always returns Qt type).\"\"\"\nif cls.__instance is None:\ncls.__instance = cls()\nreturn cls.__instance\ndef start_worker(\nself,\nfn_or_worker: Callable | Worker,\nargs: tuple | None = None,\nkwargs: dict | None = None,\npriority: int = 0,\nresult_fn: Callable | None = None,\nfinished_fn: Callable | None = None,\nprogress_fn: Callable | None = None,\nerror_fn: Callable | None = None,\n):\nif isinstance(fn_or_worker, Callable):\nif args is None:\nargs = ()\nif kwargs is None:\nkwargs = {}\nrunnable = Worker(fn_or_worker, *args, **kwargs)\nelse:\nrunnable = fn_or_worker\nrunnable.signals.finished.connect(self._on_job_ended)\nrunnable.signals.error.connect(self._on_job_ended)\nrunnable.signals.error.connect(self._on_exception)\nif result_fn:\nrunnable.signals.result.connect(result_fn)\nif finished_fn:\nrunnable.signals.finished.connect(finished_fn)\nif progress_fn:\nrunnable.signals.progress.connect(progress_fn)\nif error_fn:\nrunnable.signals.error.connect(error_fn)\nthread_count = self.activeThreadCount()\nif thread_count == 0:\nself.busy_state_changed.emit(True)\nself.job_num_updated.emit(thread_count + 1)  # + 1 because we didnt start yet.\nsuper().start(runnable, priority)\ndef _on_job_ended(self):\nthread_count = self.activeThreadCount()\nif thread_count == 1:  # this is the last job\nself.busy_state_changed.emit(False)\nself.job_num_updated.emit(thread_count - 1)  # -1 because we didnt really end yet.\ndef _on_exception(self, exception):\nself.error_occured.emit(exception)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.threadpool.ThreadPool.instance","title":"<code>instance() -&gt; Self</code>  <code>classmethod</code>","text":"<p>Return global ThreadPool singleton. (globalInstance always returns Qt type).</p> Source code in <code>prettyqt\\core\\threadpool.py</code> <pre><code>@classmethod\ndef instance(cls) -&gt; Self:\n\"\"\"Return global ThreadPool singleton. (globalInstance always returns Qt type).\"\"\"\nif cls.__instance is None:\ncls.__instance = cls()\nreturn cls.__instance\n</code></pre>"},{"location":"api/core.html#prettyqt.core.TimeLine","title":"<code>TimeLine</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtCore.QTimeLine</code></p> Source code in <code>prettyqt\\core\\timeline.py</code> <pre><code>class TimeLine(core.ObjectMixin, QtCore.QTimeLine):\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"direction\": DIRECTION}\nreturn maps\ndef set_direction(self, direction: DirectionStr | QtCore.QTimeLine.Direction):\n\"\"\"Set the direction.\n        Args:\n            direction: direction\n        \"\"\"\nself.setDirection(DIRECTION.get_enum_value(direction))\ndef get_direction(self) -&gt; DirectionStr:\n\"\"\"Return current direction.\n        Returns:\n            direction\n        \"\"\"\nreturn DIRECTION.inverse[self.direction()]\ndef get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n        Returns:\n            state\n        \"\"\"\nreturn STATE.inverse[self.state()]\ndef set_easing(\nself,\neasing_type: core.easingcurve.TypeStr\n| core.QEasingCurve.Type\n| Callable[[float], float],\n) -&gt; core.EasingCurve:\ncurve = core.EasingCurve()\nif callable(easing_type):\ncurve.set_custom_type(easing_type)\nelse:\ncurve.set_type(easing_type)\nself.setEasingCurve(curve)\nreturn curve\ndef get_easing(self) -&gt; core.easingcurve.TypeStr | Callable[[float], float]:\ncurve = core.EasingCurve(self.easingCurve())\ntyp = curve.get_type()\nreturn curve.get_custom_type() if typ == \"custom\" else typ\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_direction","title":"<code>get_direction() -&gt; DirectionStr</code>","text":"<p>Return current direction.</p> <p>Returns:</p> Type Description <code>DirectionStr</code> <p>direction</p> Source code in <code>prettyqt\\core\\timeline.py</code> <pre><code>def get_direction(self) -&gt; DirectionStr:\n\"\"\"Return current direction.\n    Returns:\n        direction\n    \"\"\"\nreturn DIRECTION.inverse[self.direction()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_state","title":"<code>get_state() -&gt; StateStr</code>","text":"<p>Return current state.</p> <p>Returns:</p> Type Description <code>StateStr</code> <p>state</p> Source code in <code>prettyqt\\core\\timeline.py</code> <pre><code>def get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n    Returns:\n        state\n    \"\"\"\nreturn STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.set_direction","title":"<code>set_direction(direction: DirectionStr | QtCore.QTimeLine.Direction)</code>","text":"<p>Set the direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>DirectionStr | QtCore.QTimeLine.Direction</code> <p>direction</p> required Source code in <code>prettyqt\\core\\timeline.py</code> <pre><code>def set_direction(self, direction: DirectionStr | QtCore.QTimeLine.Direction):\n\"\"\"Set the direction.\n    Args:\n        direction: direction\n    \"\"\"\nself.setDirection(DIRECTION.get_enum_value(direction))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.Timer","title":"<code>Timer</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtCore.QTimer</code></p> Source code in <code>prettyqt\\core\\timer.py</code> <pre><code>class Timer(core.ObjectMixin, QtCore.QTimer):\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"timerType\": constants.TIMER_TYPE}\nreturn maps\ndef set_type(self, typ: constants.TimerTypeStr | constants.TimerType):\n\"\"\"Set the timer type.\n        Args:\n            typ: timer type\n        \"\"\"\nself.setTimerType(constants.TIMER_TYPE.get_enum_value(typ))\ndef get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n        Returns:\n            timer type\n        \"\"\"\nreturn constants.TIMER_TYPE.inverse[self.timerType()]\ndef set_interval(self, interval: int | str):\nif isinstance(interval, str):\ninterval = helpers.parse_time(interval)\nself.setInterval(interval)\ndef start_timer(self, interval: None | int | str = None):\nif isinstance(interval, str):\ninterval = helpers.parse_time(interval)\nif interval is None:\nself.start()\nelse:\nself.start(interval)\ndef restart(self):\nself.stop()\nself.start()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timer.Timer.get_type","title":"<code>get_type() -&gt; constants.TimerTypeStr</code>","text":"<p>Return current timer type.</p> <p>Returns:</p> Type Description <code>constants.TimerTypeStr</code> <p>timer type</p> Source code in <code>prettyqt\\core\\timer.py</code> <pre><code>def get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n    Returns:\n        timer type\n    \"\"\"\nreturn constants.TIMER_TYPE.inverse[self.timerType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timer.Timer.set_type","title":"<code>set_type(typ: constants.TimerTypeStr | constants.TimerType)</code>","text":"<p>Set the timer type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>constants.TimerTypeStr | constants.TimerType</code> <p>timer type</p> required Source code in <code>prettyqt\\core\\timer.py</code> <pre><code>def set_type(self, typ: constants.TimerTypeStr | constants.TimerType):\n\"\"\"Set the timer type.\n    Args:\n        typ: timer type\n    \"\"\"\nself.setTimerType(constants.TIMER_TYPE.get_enum_value(typ))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.Url","title":"<code>Url</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtCore.QUrl</code></p> Source code in <code>prettyqt\\core\\url.py</code> <pre><code>class Url(serializemixin.SerializeMixin, QtCore.QUrl):\ndef __init__(self, *args, **kwargs):\nmatch args:\ncase (os.PathLike(), *rest):\npath = os.fspath(args[0])\nif pathlib.Path(path).exists():\npath = self.fromLocalFile(path)\nsuper().__init__(path, *rest, **kwargs)\ncase _:\nsuper().__init__(*args, **kwargs)\n@property\ndef _toString(self) -&gt; str:\nreturn self.toString()\n__match_args__ = (\"_toString\",)\n# def __str__(self):\n#     return self.absolutePath()\ndef __repr__(self):\nreturn get_repr(self, self.toString())\ndef __str__(self):\nreturn self.toString()\ndef serialize_fields(self):\nreturn dict(path=self.toString())\ndef serialize(self) -&gt; dict[str, Any]:\nreturn self.serialize_fields()\ndef to_string(self) -&gt; str:\nreturn self.toString()\ndef to_path(self) -&gt; pathlib.Path:\n\"\"\"Get pathlib object from the URL.\n        Returns:\n            Path\n        \"\"\"\nreturn pathlib.Path(str(self))\ndef is_local_file(self) -&gt; bool:\nreturn self.isLocalFile()\n@classmethod\ndef from_user_input(cls, url: str, working_dir: str | None = None) -&gt; Self:\nif working_dir is None:\nworking_dir = \"\"\nreturn cls(cls.fromUserInput(url, working_dir))\n@classmethod\ndef from_local_file(cls, path: datatypes.PathType) -&gt; Self:\nurl = cls.fromLocalFile(os.fspath(path))\nreturn cls(url)\ndef _has_explicit_scheme(self) -&gt; bool:\n\"\"\"Check if a url has an explicit scheme given.\"\"\"\nreturn bool(\nself.isValid()\nand self.scheme()\nand (self.host() or self.path())\nand not self.path().startswith(\":\")\n)\ndef is_special_url(self) -&gt; bool:\n\"\"\"Return True if url is an about:... or other special URL.\"\"\"\nreturn self.scheme() in (\"about\", \"file\") if self.isValid() else False\n</code></pre>"},{"location":"api/core.html#prettyqt.core.url.Url.is_special_url","title":"<code>is_special_url() -&gt; bool</code>","text":"<p>Return True if url is an about:... or other special URL.</p> Source code in <code>prettyqt\\core\\url.py</code> <pre><code>def is_special_url(self) -&gt; bool:\n\"\"\"Return True if url is an about:... or other special URL.\"\"\"\nreturn self.scheme() in (\"about\", \"file\") if self.isValid() else False\n</code></pre>"},{"location":"api/core.html#prettyqt.core.url.Url.to_path","title":"<code>to_path() -&gt; pathlib.Path</code>","text":"<p>Get pathlib object from the URL.</p> <p>Returns:</p> Type Description <code>pathlib.Path</code> <p>Path</p> Source code in <code>prettyqt\\core\\url.py</code> <pre><code>def to_path(self) -&gt; pathlib.Path:\n\"\"\"Get pathlib object from the URL.\n    Returns:\n        Path\n    \"\"\"\nreturn pathlib.Path(str(self))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.UuidMixin","title":"<code>UuidMixin</code>","text":"Source code in <code>prettyqt\\core\\uuid.py</code> <pre><code>class UuidMixin:\ndef __repr__(self):\nreturn get_repr(self, self.toString())\ndef __str__(self):\nreturn self.toString()\ndef __bool__(self):\nreturn not self.isNull()\ndef __reduce__(self):\nreturn type(self), (self.toString(),)\ndef __format__(self, format_spec: StringFormatStr):\nreturn self.to_string(format_spec)\ndef get_variant(self) -&gt; VariantStr:\nreturn VARIANTS.inverse[self.variant()]\ndef get_version(self) -&gt; VersionStr:\nreturn VERSION.inverse[self.version()]\n@classmethod\ndef create_uuid(cls) -&gt; Self:\n# workaround for PySide2, not able to clone in ctor\nreturn cls(cls.createUuid().toString())\ndef to_string(\nself, fmt: StringFormatStr | QtCore.QUuid.StringFormat = \"with_braces\"\n) -&gt; str:\n\"\"\"Return string representation of the Uuid.\n        Allowed values are \"with_braces\", \"without_braces\", \"id_128\"\n        Args:\n            fmt: Uuid format to use\n        \"\"\"\nreturn self.toString(STRING_FORMATS.get_enum_value(fmt))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.uuid.UuidMixin.to_string","title":"<code>to_string(fmt: StringFormatStr | QtCore.QUuid.StringFormat = 'with_braces') -&gt; str</code>","text":"<p>Return string representation of the Uuid.</p> <p>Allowed values are \"with_braces\", \"without_braces\", \"id_128\"</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>StringFormatStr | QtCore.QUuid.StringFormat</code> <p>Uuid format to use</p> <code>'with_braces'</code> Source code in <code>prettyqt\\core\\uuid.py</code> <pre><code>def to_string(\nself, fmt: StringFormatStr | QtCore.QUuid.StringFormat = \"with_braces\"\n) -&gt; str:\n\"\"\"Return string representation of the Uuid.\n    Allowed values are \"with_braces\", \"without_braces\", \"id_128\"\n    Args:\n        fmt: Uuid format to use\n    \"\"\"\nreturn self.toString(STRING_FORMATS.get_enum_value(fmt))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.VariantAnimationMixin","title":"<code>VariantAnimationMixin</code>","text":"<p>         Bases: <code>core.AbstractAnimationMixin</code></p> Source code in <code>prettyqt\\core\\variantanimation.py</code> <pre><code>class VariantAnimationMixin(core.AbstractAnimationMixin):\ndef __getitem__(self, value: float) -&gt; datatypes.Variant:\nreturn self.keyValueAt(value)\ndef __setitem__(self, key: float, value: datatypes.Variant):\nself.setKeyValueAt(key, value)\ndef __iter__(self) -&gt; Iterator[tuple[float, datatypes.Variant]]:\nreturn iter(self.keyValues())\ndef set_easing(\nself,\neasing_type: core.easingcurve.TypeStr\n| core.QEasingCurve.Type\n| Callable[[float], float],\n):\ncurve = core.EasingCurve()\nif callable(easing_type):\ncurve.set_custom_type(easing_type)\nelse:\ncurve.set_type(easing_type)\nself.setEasingCurve(curve)\ndef get_easing(self) -&gt; core.easingcurve.TypeStr | Callable[[float], float]:\ncurve = core.EasingCurve(self.easingCurve())\ntyp = curve.get_type()\nreturn curve.get_custom_type() if typ == \"custom\" else typ\ndef set_range(self, start, end):\nself.setStartValue(start)\nself.setEndValue(end)\ndef reverse(self):\n\"\"\"True reverse instead of just setting direction.\"\"\"\nself.setKeyValues(list(reversed(self.keyValues())))\ndef reversed(self) -&gt; VariantAnimation:\n\"\"\"Return a reversed copy of the animation.\"\"\"\nnew = self.get_metaobject().copy(self)\nnew.reverse()\nreturn new\ndef append_reversed(self) -&gt; Self:\n\"\"\"Append the reversed animation, effectively doubling the duration.\"\"\"\nself.setDuration(self.duration() * 2)\nfirst_part = [(k / 2, v) for k, v in self.keyValues()]\nsecond_part = [(1 - (k / 2), v) for k, v in self.keyValues()]\nkeys = first_part + list(reversed(second_part))[1:]\nself.setKeyValues(keys)\nreturn self\n</code></pre>"},{"location":"api/core.html#prettyqt.core.variantanimation.VariantAnimationMixin.append_reversed","title":"<code>append_reversed() -&gt; Self</code>","text":"<p>Append the reversed animation, effectively doubling the duration.</p> Source code in <code>prettyqt\\core\\variantanimation.py</code> <pre><code>def append_reversed(self) -&gt; Self:\n\"\"\"Append the reversed animation, effectively doubling the duration.\"\"\"\nself.setDuration(self.duration() * 2)\nfirst_part = [(k / 2, v) for k, v in self.keyValues()]\nsecond_part = [(1 - (k / 2), v) for k, v in self.keyValues()]\nkeys = first_part + list(reversed(second_part))[1:]\nself.setKeyValues(keys)\nreturn self\n</code></pre>"},{"location":"api/core.html#prettyqt.core.variantanimation.VariantAnimationMixin.reverse","title":"<code>reverse()</code>","text":"<p>True reverse instead of just setting direction.</p> Source code in <code>prettyqt\\core\\variantanimation.py</code> <pre><code>def reverse(self):\n\"\"\"True reverse instead of just setting direction.\"\"\"\nself.setKeyValues(list(reversed(self.keyValues())))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.variantanimation.VariantAnimationMixin.reversed","title":"<code>reversed() -&gt; VariantAnimation</code>","text":"<p>Return a reversed copy of the animation.</p> Source code in <code>prettyqt\\core\\variantanimation.py</code> <pre><code>def reversed(self) -&gt; VariantAnimation:\n\"\"\"Return a reversed copy of the animation.\"\"\"\nnew = self.get_metaobject().copy(self)\nnew.reverse()\nreturn new\n</code></pre>"},{"location":"api/core.html#prettyqt.core.VersionNumber","title":"<code>VersionNumber</code>","text":"<p>         Bases: <code>QtCore.QVersionNumber</code></p> Source code in <code>prettyqt\\core\\versionnumber.py</code> <pre><code>class VersionNumber(QtCore.QVersionNumber):\ndef __init__(self, *args, **kwargs):\nmatch args:\ncase (str(),):\nargs = [int(i) for i in args[0].split(\".\")][:3]\ncase (tuple(),):\nargs = args[0]\n# PySide6 Workaround:\ncase (QtCore.QVersionNumber(),):\nargs = (\nargs[0].majorVersion(),\nargs[0].minorVersion(),\nargs[0].microVersion(),\n)\nsuper().__init__(*args, **kwargs)\ndef __repr__(self):\nreturn get_repr(self, self.major(), self.minor(), self.micro())\n@property\ndef _majorVersion(self) -&gt; int:\nreturn self.majorVersion()\n@property\ndef _minorVersion(self) -&gt; int:\nreturn self.minorVersion()\n@property\ndef _microVersion(self) -&gt; int:\nreturn self.microVersion()\n__match_args__ = (\"_majorVersion\", \"_minorVersion\", \"_microVersion\")\ndef __reduce__(self):\nreturn type(self), (self.major(), self.minor(), self.micro())\ndef __str__(self):\nreturn self.toString()\ndef __eq__(self, other):\nif isinstance(other, str | tuple):\nother = VersionNumber(other)\nreturn super().__eq__(other)\ndef __hash__(self):\nreturn hash((self.major(), self.minor(), self.micro()))\ndef __gt__(self, other: datatypes.SemanticVersionType):\nif isinstance(other, str | tuple):\nother = VersionNumber(other)\nreturn super().__gt__(other)\ndef __ge__(self, other: datatypes.SemanticVersionType):\nif isinstance(other, str | tuple):\nother = VersionNumber(other)\nreturn super().__ge__(other)\ndef __lt__(self, other: datatypes.SemanticVersionType):\nif isinstance(other, str | tuple):\nother = VersionNumber(other)\nreturn super().__lt__(other)\ndef __le__(self, other: datatypes.SemanticVersionType):\nif isinstance(other, str | tuple):\nother = VersionNumber(other)\nreturn super().__le__(other)\n@classmethod\ndef from_string(cls, version_string: str) -&gt; Self:\nreturn cls(cls.fromString(version_string))\n@classmethod\ndef get_qt_version(cls) -&gt; Self:\nreturn cls(*[int(i) for i in QtCore.__version__.split(\".\")])\n@classmethod\ndef get_python_version(cls) -&gt; Self:\nreturn cls(*sys.version_info[:3])\ndef major(self) -&gt; int:\n\"\"\"An integer representing the major version.\"\"\"\nreturn self.majorVersion()\ndef minor(self) -&gt; int:\n\"\"\"An integer representing the minor version.\"\"\"\nreturn self.minorVersion()\ndef micro(self) -&gt; int:\n\"\"\"An integer representing the micro version.\"\"\"\nreturn self.microVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.major","title":"<code>major() -&gt; int</code>","text":"<p>An integer representing the major version.</p> Source code in <code>prettyqt\\core\\versionnumber.py</code> <pre><code>def major(self) -&gt; int:\n\"\"\"An integer representing the major version.\"\"\"\nreturn self.majorVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.micro","title":"<code>micro() -&gt; int</code>","text":"<p>An integer representing the micro version.</p> Source code in <code>prettyqt\\core\\versionnumber.py</code> <pre><code>def micro(self) -&gt; int:\n\"\"\"An integer representing the micro version.\"\"\"\nreturn self.microVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.minor","title":"<code>minor() -&gt; int</code>","text":"<p>An integer representing the minor version.</p> Source code in <code>prettyqt\\core\\versionnumber.py</code> <pre><code>def minor(self) -&gt; int:\n\"\"\"An integer representing the minor version.\"\"\"\nreturn self.minorVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.XmlStreamReader","title":"<code>XmlStreamReader</code>","text":"<p>         Bases: <code>QtCore.QXmlStreamReader</code></p> Source code in <code>prettyqt\\core\\xmlstreamreader.py</code> <pre><code>class XmlStreamReader(QtCore.QXmlStreamReader):\ndef __iter__(self):\nreturn self\ndef __next__(self):\nwhile not self.atEnd():\nself.readNext()\nif self.hasError():\nraise RuntimeError(self.get_error())\nreturn self\nraise StopIteration\ndef get_error(self) -&gt; ErrorStr:\n\"\"\"Return file error status.\n        Returns:\n            file error status\n        \"\"\"\nreturn ERROR.inverse[self.error()]\ndef get_token_type(self) -&gt; TokenTypeStr:\n\"\"\"Get the current token type.\n        Returns:\n            token type\n        \"\"\"\nreturn TOKEN_TYPE.inverse[self.tokenType()]\ndef read_next(self) -&gt; TokenTypeStr:\n\"\"\"Read the next token and returns its type.\n        Returns:\n            token type\n        \"\"\"\nreturn TOKEN_TYPE.inverse[self.readNext()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return file error status.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>file error status</p> Source code in <code>prettyqt\\core\\xmlstreamreader.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return file error status.\n    Returns:\n        file error status\n    \"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.get_token_type","title":"<code>get_token_type() -&gt; TokenTypeStr</code>","text":"<p>Get the current token type.</p> <p>Returns:</p> Type Description <code>TokenTypeStr</code> <p>token type</p> Source code in <code>prettyqt\\core\\xmlstreamreader.py</code> <pre><code>def get_token_type(self) -&gt; TokenTypeStr:\n\"\"\"Get the current token type.\n    Returns:\n        token type\n    \"\"\"\nreturn TOKEN_TYPE.inverse[self.tokenType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.read_next","title":"<code>read_next() -&gt; TokenTypeStr</code>","text":"<p>Read the next token and returns its type.</p> <p>Returns:</p> Type Description <code>TokenTypeStr</code> <p>token type</p> Source code in <code>prettyqt\\core\\xmlstreamreader.py</code> <pre><code>def read_next(self) -&gt; TokenTypeStr:\n\"\"\"Read the next token and returns its type.\n    Returns:\n        token type\n    \"\"\"\nreturn TOKEN_TYPE.inverse[self.readNext()]\n</code></pre>"},{"location":"api/custom_delegates.html","title":"custom_delegates module","text":"<p>Module containing custom delegate classes.</p>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.HtmlItemDelegate","title":"<code>HtmlItemDelegate</code>","text":"<p>         Bases: <code>widgets.StyledItemDelegate</code></p> Source code in <code>prettyqt\\custom_delegates\\htmlitemdelegate.py</code> <pre><code>class HtmlItemDelegate(widgets.StyledItemDelegate):\nID = \"html\"\n\"\"\"Delegate do display HTML text.\n    An alternative approach would be go grab a pixmal from a QLabel for painting.\n    (see ButtonDelegate)\n    \"\"\"\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.doc = gui.TextDocument()\nself.text_option = gui.TextOption()\nself.text_option.setWrapMode(gui.TextOption.WrapMode.NoWrap)\nself.doc.setDefaultTextOption(self.text_option)\nself.doc.setDocumentMargin(0)\ndef paint(self, painter, option, index):\npainter.save()\noption = widgets.StyleOptionViewItem(option)\nself.initStyleOption(option, index)\nself.prepare_doc(option)\n# draw everything without text\noption.text = \"\"\noption.widget.style().drawControl(\nQtWidgets.QStyle.ControlElement.CE_ItemViewItem, option, painter\n)\n# now we find position of our label and display our TextDocument there.\nicon_size = option.icon.actualSize(option.decorationSize)\nmargin = icon_size.width()\npainter.translate(option.rect.left() + margin, option.rect.top())\nclip = QtCore.QRectF(0, 0, option.rect.width() + margin, option.rect.height())\nself.doc.drawContents(painter, clip)\npainter.restore()\ndef sizeHint(self, option, index):\noption = widgets.StyleOptionViewItem(option)\nself.initStyleOption(option, index)\nself.prepare_doc(option)\nreturn QtCore.QSize(int(self.doc.idealWidth()), int(self.doc.size().height()))\ndef prepare_doc(self, option: QtWidgets.QStyleOptionViewItem):\nself.text_option.setAlignment(option.displayAlignment)\nself.doc.setDefaultFont(option.font)\nself.doc.setHtml(option.text)\n# self.doc.setTextWidth(option.rect.width())\nself.doc.setPageSize(QtCore.QSizeF(option.rect.width(), option.rect.height()))\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.htmlitemdelegate.HtmlItemDelegate.ID","title":"<code>ID = 'html'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Delegate do display HTML text.</p> <p>An alternative approach would be go grab a pixmal from a QLabel for painting. (see ButtonDelegate)</p>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.IconDelegate","title":"<code>IconDelegate</code>","text":"<p>         Bases: <code>widgets.StyledItemDelegate</code></p> Source code in <code>prettyqt\\custom_delegates\\icondelegate.py</code> <pre><code>class IconDelegate(widgets.StyledItemDelegate):\nID = \"icon\"\ndef __init__(self, role: constants.ItemDataRole = constants.USER_ROLE, **kwargs):\nself._role = role\nself.margin = 10\nsuper().__init__(**kwargs)\ndef paint(\nself,\npainter: QtGui.QPainter,\noption: QtWidgets.QStyleOptionViewItem,\nindex: QtCore.QModelIndex,\n):\n\"\"\"Override to paint an icon based on given Pixmap / Color / Icon.\n        Pixmap / Color / Icon must be set to '_role'\n        Args:\n            painter (QtGui.QPainter): painter to paint the icon\n            option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed\n            index (QtCore.QModelIndex): index which gets decorated\n        \"\"\"\nsuper().paint(painter, option, index)\nvalue = index.data(self._role)\nif not value:\nreturn\nmode = gui.Icon.Mode.Normal\nif not option.state &amp; widgets.Style.StateFlag.State_Enabled:\nmode = gui.Icon.Mode.Disabled\nelif option.state &amp; widgets.Style.StateFlag.State_Selected:\nmode = gui.Icon.Mode.Selected\nmatch value:\ncase QtGui.QPixmap():\nicon = QtGui.QIcon(value)\noption.decorationSize = int(value.size() / value.devicePixelRatio())\ncase QtGui.QColor():\npixmap = QtGui.QPixmap(option.decorationSize)\npixmap.fill(value)\nicon = QtGui.QIcon(pixmap)\ncase QtGui.QImage():\nicon = QtGui.QIcon(QtGui.QPixmap.fromImage(value))\noption.decorationSize = int(value.size() / value.devicePixelRatio())\ncase QtGui.QIcon():\nicon = value\nis_on = option.state &amp; widgets.Style.StateFlag.State_Open\nstate = gui.Icon.State.On if is_on else gui.Icon.State.Off\nactual_size = option.icon.actualSize(option.decorationSize, mode, state)\noption.decorationSize.boundedTo(actual_size)\ncase _:\nraise ValueError(value)\nr = core.Rect(core.Point(), option.decorationSize)\nr.moveCenter(option.rect.center())\nr.setRight(option.rect.right() - self.margin)\nstate = (\ngui.Icon.State.On\nif option.state &amp; widgets.Style.StateFlag.State_Open\nelse gui.Icon.State.Off\n)\nalignment = constants.ALIGN_RIGHT | constants.ALIGN_V_CENTER\nicon.paint(painter, r, alignment, mode, state)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate.paint","title":"<code>paint(painter: QtGui.QPainter, option: QtWidgets.QStyleOptionViewItem, index: QtCore.QModelIndex)</code>","text":"<p>Override to paint an icon based on given Pixmap / Color / Icon.</p> <p>Pixmap / Color / Icon must be set to '_role'</p> <p>Parameters:</p> Name Type Description Default <code>painter</code> <code>QtGui.QPainter</code> <p>painter to paint the icon</p> required <code>option</code> <code>QtWidgets.QStyleOptionViewItem</code> <p>state of the item to be displayed</p> required <code>index</code> <code>QtCore.QModelIndex</code> <p>index which gets decorated</p> required Source code in <code>prettyqt\\custom_delegates\\icondelegate.py</code> <pre><code>def paint(\nself,\npainter: QtGui.QPainter,\noption: QtWidgets.QStyleOptionViewItem,\nindex: QtCore.QModelIndex,\n):\n\"\"\"Override to paint an icon based on given Pixmap / Color / Icon.\n    Pixmap / Color / Icon must be set to '_role'\n    Args:\n        painter (QtGui.QPainter): painter to paint the icon\n        option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed\n        index (QtCore.QModelIndex): index which gets decorated\n    \"\"\"\nsuper().paint(painter, option, index)\nvalue = index.data(self._role)\nif not value:\nreturn\nmode = gui.Icon.Mode.Normal\nif not option.state &amp; widgets.Style.StateFlag.State_Enabled:\nmode = gui.Icon.Mode.Disabled\nelif option.state &amp; widgets.Style.StateFlag.State_Selected:\nmode = gui.Icon.Mode.Selected\nmatch value:\ncase QtGui.QPixmap():\nicon = QtGui.QIcon(value)\noption.decorationSize = int(value.size() / value.devicePixelRatio())\ncase QtGui.QColor():\npixmap = QtGui.QPixmap(option.decorationSize)\npixmap.fill(value)\nicon = QtGui.QIcon(pixmap)\ncase QtGui.QImage():\nicon = QtGui.QIcon(QtGui.QPixmap.fromImage(value))\noption.decorationSize = int(value.size() / value.devicePixelRatio())\ncase QtGui.QIcon():\nicon = value\nis_on = option.state &amp; widgets.Style.StateFlag.State_Open\nstate = gui.Icon.State.On if is_on else gui.Icon.State.Off\nactual_size = option.icon.actualSize(option.decorationSize, mode, state)\noption.decorationSize.boundedTo(actual_size)\ncase _:\nraise ValueError(value)\nr = core.Rect(core.Point(), option.decorationSize)\nr.moveCenter(option.rect.center())\nr.setRight(option.rect.right() - self.margin)\nstate = (\ngui.Icon.State.On\nif option.state &amp; widgets.Style.StateFlag.State_Open\nelse gui.Icon.State.Off\n)\nalignment = constants.ALIGN_RIGHT | constants.ALIGN_V_CENTER\nicon.paint(painter, r, alignment, mode, state)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.StarDelegate","title":"<code>StarDelegate</code>","text":"<p>         Bases: <code>widgets.StyledItemDelegate</code></p> <p>A delegate class that allows us to render our star ratings.</p> Source code in <code>prettyqt\\custom_delegates\\stardelegate.py</code> <pre><code>class StarDelegate(widgets.StyledItemDelegate):\n\"\"\"A delegate class that allows us to render our star ratings.\"\"\"\nID = \"star\"\ndef paint(self, painter, option, index):\nstar_rating = StarRating(index.data())\n# If the row is currently selected, we need to make sure we\n# paint the background accordingly.\nif option.state &amp; widgets.Style.StateFlag.State_Selected:\n# The original C++ example used option.palette.foreground() to\n# get the brush for painting, but there are a couple of\n# problems with that:\n#   - foreground() is obsolete now, use windowText() instead\n#   - more importantly, windowText() just returns a brush\n#     containing a flat color, where sometimes the style\n#     would have a nice subtle gradient or something.\n# Here we just use the brush of the painter object that's\n# passed in to us, which keeps the row highlighting nice\n# and consistent.\npainter.fillRect(option.rect, painter.brush())\n# Now that we've painted the background, call star_rating.paint()\n# to paint the stars.\nstar_rating.paint(painter, option.rect, option.palette)\ndef sizeHint(self, option, index):\n\"\"\"Return the size needed to display the item in a QSize object.\"\"\"\nstar_rating = StarRating(index.data())\nreturn star_rating.sizeHint()\n# The next 4 methods handle the custom editing that we need to do.\n# If this were just a display delegate, paint() and sizeHint() would\n# be all we needed.\ndef createEditor(self, parent, option, index):\n\"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\"\neditor = StarEditor(parent)\neditor.editing_finished.connect(self.commitAndCloseEditor)\nreturn editor\ndef setEditorData(self, editor: StarEditor, index):\n\"\"\"Set the data to be displayed and edited by our custom editor.\"\"\"\neditor.set_star_rating(index.data())\ndef setModelData(self, editor, model, index):\n\"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\"\nmodel.setData(index, editor.star_rating.star_count)\ndef commitAndCloseEditor(self):\neditor = self.sender()\n# The commitData signal must be emitted when we've finished editing\n# and need to write our changed back to the model.\nself.commitData.emit(editor)\nself.closeEditor.emit(editor, self.EndEditHint.NoHint)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.createEditor","title":"<code>createEditor(parent, option, index)</code>","text":"<p>Create and return the StarEditor object we'll use to edit the StarRating.</p> Source code in <code>prettyqt\\custom_delegates\\stardelegate.py</code> <pre><code>def createEditor(self, parent, option, index):\n\"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\"\neditor = StarEditor(parent)\neditor.editing_finished.connect(self.commitAndCloseEditor)\nreturn editor\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setEditorData","title":"<code>setEditorData(editor: StarEditor, index: StarEditor)</code>","text":"<p>Set the data to be displayed and edited by our custom editor.</p> Source code in <code>prettyqt\\custom_delegates\\stardelegate.py</code> <pre><code>def setEditorData(self, editor: StarEditor, index):\n\"\"\"Set the data to be displayed and edited by our custom editor.\"\"\"\neditor.set_star_rating(index.data())\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setModelData","title":"<code>setModelData(editor, model, index)</code>","text":"<p>Get the data from our custom editor and stuffs it into the model.</p> Source code in <code>prettyqt\\custom_delegates\\stardelegate.py</code> <pre><code>def setModelData(self, editor, model, index):\n\"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\"\nmodel.setData(index, editor.star_rating.star_count)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.sizeHint","title":"<code>sizeHint(option, index)</code>","text":"<p>Return the size needed to display the item in a QSize object.</p> Source code in <code>prettyqt\\custom_delegates\\stardelegate.py</code> <pre><code>def sizeHint(self, option, index):\n\"\"\"Return the size needed to display the item in a QSize object.\"\"\"\nstar_rating = StarRating(index.data())\nreturn star_rating.sizeHint()\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.VariantDelegate","title":"<code>VariantDelegate</code>","text":"<p>         Bases: <code>widgets.StyledItemDelegate</code></p> <p>Delegate which supports editing many data types.</p> Source code in <code>prettyqt\\custom_delegates\\variantdelegate.py</code> <pre><code>class VariantDelegate(widgets.StyledItemDelegate):\n\"\"\"Delegate which supports editing many data types.\"\"\"\nID = \"variant\"\ndef __init__(\nself,\n*args,\ndata_role: constants.ItemDataRole = constants.USER_ROLE,\nset_edit_role: bool = True,\nvalidator: gui.QValidator\n| widgets.lineedit.ValidatorStr\n| datatypes.PatternType\n| None = None,\n**kwargs,\n):\nsuper().__init__(*args, **kwargs)\nself.data_role = data_role\nself._set_edit_role = set_edit_role\nself._validator = validator\ndef paint(self, painter, option, index):\n# if not self.is_supported_type(value):\n#     option = widgets.StyleOptionViewItem(option)\n#     option.state &amp;= ~widgets.QStyle.StateFlag.State_Enabled\nfrom prettyqt import custom_delegates\nmatch value := self._data_for_index(index, self.data_role):\ncase gui.QIcon():\nicon_delegate = custom_delegates.IconDelegate()\nicon_delegate.paint(painter, option, index)\nreturn\ncase enum.Enum():  # PySide6 needs this when using Views\noption.text = value.name\noption.widget.style().drawControl(\nwidgets.QStyle.ControlElement.CE_ItemViewItem, option, painter\n)\ncase _:\nsuper().paint(painter, option, index)\ndef createEditor(self, parent, option, index):\nval = self._data_for_index(index, self.data_role)\nlogger.info(f\"creating editor for {val!r}...\")\nwidget = datatypes.get_widget_for_value(val, parent)\nif widget is None:\nlogger.warning(f\"Could not find editor for {val!r} ({type(val)})\")\nreturn None\nif self._validator and isinstance(\nwidget, widgets.LineEdit | widgets.AbstractSpinBoxMixin\n):\nwidget.set_validator(self._validator, append=True)\nwidget.setAutoFillBackground(True)\nwidget.set_focus_policy(\"strong\")\nreturn widget\ndef setEditorData(self, editor, index):\nvalue = self._data_for_index(index, self.data_role)\nlogger.info(f\"setting data for {editor!r} to {value!r}\")\neditor.set_value(value)\ndef setModelData(self, editor, model, index):\nif (value := editor.get_value()) is not None:\nlogger.info(f\"setting data for {model!r} to {value!r}\")\nmodel.setData(index, value, self.data_role)\nif self._set_edit_role:\nmodel.setData(index, datatypes.to_string(value), constants.DISPLAY_ROLE)\n# self.closeEditor.emit(editor, self.EndEditHint.NoHint)\nself.commitData.emit(editor)\ndef displayText(self, value, locale: core.QLocale) -&gt; str:\nreturn datatypes.to_string(value, locale)\n</code></pre>"},{"location":"api/custom_models.html","title":"custom_models module","text":"<p>Custom_models module.</p> <p>Contains custom models</p>"},{"location":"api/custom_models.html#prettyqt.custom_models.AstModel","title":"<code>AstModel</code>","text":"<p>         Bases: <code>custom_models.TreeModel</code></p> <p>Model to display the tree of an AST node.</p> Source code in <code>prettyqt\\custom_models\\astmodel.py</code> <pre><code>class AstModel(custom_models.TreeModel):\n\"\"\"Model to display the tree of an AST node.\"\"\"\nHEADER = [\n\"Node type\",\n\"Name\",\n\"Line range\",\n\"Column range\",\n\"Code segement\",\n\"Docstring\",\n]\ndef __init__(self, ast_tree, **kwargs):\nsuper().__init__(None, **kwargs)\nself.ast_tree = None\nself.code = \"\"\nself.set_ast(ast_tree)\n@classmethod\ndef supports(cls, instance) -&gt; bool:\nreturn isinstance(instance, ast.AST)\ndef columnCount(self, parent=None):\nreturn len(self.HEADER) if self.ast_tree is not None else 0\ndef set_ast(self, ast_tree: ast.AST | str = \"\"):\nmatch ast_tree:\ncase str():\ncode = ast_tree\ntry:\nnode = ast.parse(ast_tree)\nexcept SyntaxError as e:\nlogger.debug(f\"caught {e!r} when building AST\")\nreturn\ncase ast.AST():\ncode = ast.unparse(ast_tree)\nnode = ast.parse(code)  # makin a circle to make sure line numbers match.\ncase _:\nraise TypeError(ast_tree)\nnode = ast.fix_missing_locations(node)\nwith self.reset_model():\nself.ast_tree = node\nself.set_root_item(node)\nself.code = code\n# def find_lineno(self, index):\n#     # not needed, thx to ast.fix_missing_locations\n#     while not hasattr(node := index.data(constants.USER_ROLE), \"lineno\"):\n#         index = index.parent()\n#     return node.lineno\ndef headerData(\nself,\nsection: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n) -&gt; str | None:\nmatch orientation, role, section:\ncase constants.HORIZONTAL, constants.DISPLAY_ROLE, _:\nreturn self.HEADER[section]\nreturn None\ndef data(self, index: core.ModelIndex, role=constants.DISPLAY_ROLE):\nif not index.isValid():\nreturn None\nnode = self.data_by_index(index).obj\nmatch role, index.column():\ncase constants.DISPLAY_ROLE, 0:\nreturn type(node).__name__\ncase constants.DISPLAY_ROLE, 1:\nmatch node:\ncase _ if type(node) in NODE_MAP:\nreturn NODE_MAP[type(node)]\ncase (\nast.Name(id=name)\n| ast.arg(arg=name)\n| ast.Constant(value=name)\n| ast.alias(name=name)\n| ast.ClassDef(name=name)\n| ast.FunctionDef(name=name)\n):\nreturn name\ncase str():\nreturn node\ncase constants.DISPLAY_ROLE, 2:\nif hasattr(node, \"lineno\"):\nreturn f\"{node.lineno} - {node.end_lineno}\"\ncase constants.DISPLAY_ROLE, 3:\nif hasattr(node, \"col_offset\"):\nreturn f\"{node.col_offset} - {node.end_col_offset}\"\ncase constants.DISPLAY_ROLE, 4:\nreturn ast.get_source_segment(self.code, node)\ncase constants.FONT_ROLE, 4 | 5:\nreturn gui.Font.mono(as_qt=True)\ncase constants.DISPLAY_ROLE, 5:\ntry:\nreturn ast.get_docstring(node)\nexcept TypeError:\nreturn None\ncase constants.USER_ROLE, _:\nreturn node\ndef _fetch_object_children(self, item: treeitem.TreeItem) -&gt; list[treeitem.TreeItem]:\nreturn [treeitem.TreeItem(obj=i) for i in ast.iter_child_nodes(item.obj)]\ndef _has_children(self, item: treeitem.TreeItem) -&gt; bool:\nif item.obj is None:\nreturn False\nreturn any(True for _ in ast.iter_child_nodes(item.obj))\ndef rename_variable(\nself,\nold: str,\nnew: str,\nroot_tree: ast.AST | None = None,\nignore: list[str] | None = None,\nscope: list[str] | None = None,\n):\nif scope is None:\nscope = [\"main\"]\nif ignore is None:\nignore = []\nif root_tree is None:\nroot_tree = self.ast_tree\nfor i in ast.iter_fields(root_tree):\nif not isinstance(a := getattr(root_tree, i), list):\nif a == old and not {*scope} &amp; {*ignore}:\nsetattr(root_tree, i, new)\nn = a if isinstance(a, list) else [a]\ns = [root_tree.name] if type(root_tree).__name__.endswith(\"Def\") else scope\nfor j in n:\nif isinstance(j, ast.AST):\nself.rename_variable(j, old, new, ignore, s)\ndef get_variable_names(self):\ncurrent_names = set()\nfor node in ast.walk(self.ast_tree):\nmatch node:\ncase ast.Name(id=name) | ast.arg(arg=name):\ncurrent_names.add(name)\nreturn current_names\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.BaseDataclassModel","title":"<code>BaseDataclassModel</code>","text":"<p>         Bases: <code>core.AbstractTableModel</code></p> Source code in <code>prettyqt\\custom_models\\basedataclassmodel.py</code> <pre><code>class BaseDataclassModel(core.AbstractTableModel):\ndef __init__(self, items: Sequence, **kwargs):\nsuper().__init__(**kwargs)\nself.items = items\nklasses = [type(i) for i in items]\nself.Class = lca_type(klasses)\nlogger.debug(f\"{type(self).__name__}: found common ancestor {self.Class}\")\nself.fields = self.get_fields()\nself.fields.sort(key=lambda x: x.name)\ndef get_fields(self):\nreturn NotImplemented\ndef columnCount(self, parent=None):\nreturn len(self.fields)\ndef headerData(\nself,\nsection: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n) -&gt; str | None:\nmatch orientation, role, section:\ncase constants.VERTICAL, constants.DISPLAY_ROLE, _:\ninstance = self.items[section]\nreturn type(instance).__name__\ncase constants.HORIZONTAL, constants.DISPLAY_ROLE, _:\nreturn self.fields[section].name\ndef data(self, index: core.ModelIndex, role=constants.DISPLAY_ROLE):\nif not index.isValid():\nreturn None\nfield = self.fields[index.column()]\ninstance = self.items[index.row()]\nmatch role:\ncase constants.DISPLAY_ROLE | constants.EDIT_ROLE:\nreturn repr(getattr(instance, field.name))\ncase constants.USER_ROLE:\nreturn getattr(instance, field.name)\ndef setData(\nself,\nindex: core.ModelIndex,\nvalue: Any,\nrole: constants.ItemDataRole = constants.EDIT_ROLE,\n) -&gt; bool:\nfield = self.fields[index.column()]\ninstance = self.items[index.row()]\nmatch role:\ncase constants.USER_ROLE:\nwith self.reset_model():\nsetattr(instance, field.name, value)\nreturn True\nreturn False\ndef rowCount(self, parent=None):\n\"\"\"Override for AbstractitemModel base method.\"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nreturn 0 if parent.isValid() else len(self.items)\ndef flags(self, parent=None):\n\"\"\"Override.\n        BaseClass implementation just tries to set attribute with same value to test\n        if field is writable. If possible, subclasses should find a more efficient way.\n        \"\"\"\nif not parent.isValid():\nreturn super().flags(parent)\nparent = parent or core.ModelIndex()\nfield = self.fields[parent.column()]\ninstance = self.items[parent.row()]\n# need to cover not parent.isValid()?\nval = getattr(instance, field.name)\nwith contextlib.suppress(Exception):\nsetattr(instance, field.name, val)\nreturn super().flags(parent) | constants.IS_EDITABLE\nreturn super().flags(parent)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.basedataclassmodel.BaseDataclassModel.flags","title":"<code>flags(parent = None)</code>","text":"<p>Override.</p> <p>BaseClass implementation just tries to set attribute with same value to test if field is writable. If possible, subclasses should find a more efficient way.</p> Source code in <code>prettyqt\\custom_models\\basedataclassmodel.py</code> <pre><code>def flags(self, parent=None):\n\"\"\"Override.\n    BaseClass implementation just tries to set attribute with same value to test\n    if field is writable. If possible, subclasses should find a more efficient way.\n    \"\"\"\nif not parent.isValid():\nreturn super().flags(parent)\nparent = parent or core.ModelIndex()\nfield = self.fields[parent.column()]\ninstance = self.items[parent.row()]\n# need to cover not parent.isValid()?\nval = getattr(instance, field.name)\nwith contextlib.suppress(Exception):\nsetattr(instance, field.name, val)\nreturn super().flags(parent) | constants.IS_EDITABLE\nreturn super().flags(parent)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.basedataclassmodel.BaseDataclassModel.rowCount","title":"<code>rowCount(parent = None)</code>","text":"<p>Override for AbstractitemModel base method.</p> Source code in <code>prettyqt\\custom_models\\basedataclassmodel.py</code> <pre><code>def rowCount(self, parent=None):\n\"\"\"Override for AbstractitemModel base method.\"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nreturn 0 if parent.isValid() else len(self.items)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.BaseFieldsModel","title":"<code>BaseFieldsModel</code>","text":"<p>         Bases: <code>core.AbstractTableModel</code></p> Source code in <code>prettyqt\\custom_models\\basefieldsmodel.py</code> <pre><code>class BaseFieldsModel(core.AbstractTableModel):\nHEADER: list[str] = []\ndef __init__(self, instance, **kwargs):\nself._instance = instance\nself._fields = self.get_fields(instance)\nsuper().__init__(**kwargs)\nself.set_instance(instance)\ndef get_fields(self, instance):\nreturn NotImplemented\ndef set_instance(self, instance):\nself._instance = instance\nself._fields = self.get_fields(instance)\nself.update_all()\ndef columnCount(self, parent=None) -&gt; int:\nreturn len(self.HEADER)\ndef headerData(\nself,\nsection: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n) -&gt; str | None:\nmatch orientation, role:\ncase constants.HORIZONTAL, constants.DISPLAY_ROLE:\nreturn self.HEADER[section]\ncase constants.VERTICAL, constants.DISPLAY_ROLE:\nfield = self._fields[section]\nreturn field.name\ndef setData(\nself,\nindex: core.ModelIndex,\nvalue: Any,\nrole: constants.ItemDataRole = constants.EDIT_ROLE,\n) -&gt; bool:\nif not index.isValid():\nreturn None\nfield = self._fields[index.row()]\nmatch role, index.column():\ncase constants.USER_ROLE, _:\nsetattr(self._instance, field.name, value)\nself.update_row(index.row())\nreturn True\nreturn False\ndef rowCount(self, parent: QtCore.QModelIndex | None = None) -&gt; int:\n\"\"\"Override for AbstractitemModel base method.\"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nreturn 0 if parent.isValid() else len(self._fields)\ndef flags(self, index: QtCore.QModelIndex) -&gt; constants.ItemFlag:\nfield = self._fields[index.row()]\nif index.column() == 0:\nval = getattr(self._instance, field.name)\nwith contextlib.suppress(Exception):\nsetattr(self._instance, field.name, val)\nreturn super().flags(index) | constants.IS_EDITABLE\nreturn super().flags(index)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.basefieldsmodel.BaseFieldsModel.rowCount","title":"<code>rowCount(parent: QtCore.QModelIndex | None = None) -&gt; int</code>","text":"<p>Override for AbstractitemModel base method.</p> Source code in <code>prettyqt\\custom_models\\basefieldsmodel.py</code> <pre><code>def rowCount(self, parent: QtCore.QModelIndex | None = None) -&gt; int:\n\"\"\"Override for AbstractitemModel base method.\"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nreturn 0 if parent.isValid() else len(self._fields)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ColumnItem","title":"<code>ColumnItem</code>","text":"<p>Determines how an object attribute is shown.</p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>class ColumnItem:\n\"\"\"Determines how an object attribute is shown.\"\"\"\nmodel: core.QAbstractItemModel\nname: str = \"\"\ndoc: str = \"&lt;no help available&gt;\"\ncol_visible: bool = True\nwidth: int | str = SMALL_COL_WIDTH\nline_wrap: gui.textoption.WordWrapModeStr = \"none\"\nselectable: bool = True\nenabled: bool = True\neditable: bool = False\ncheckable: bool = False\ntristate: bool = False\ndef __init__(self, model: core.QAbstractItemModel):\nself.model = model\ndef get_name(self) -&gt; str:\nreturn self.name\ndef get_flags(self, tree_item):\nflag = constants.NO_FLAGS\nif self.selectable:\nflag |= constants.IS_SELECTABLE\nif self.enabled:\nflag |= constants.IS_ENABLED\nif self.editable:\nflag |= constants.IS_EDITABLE\nif self.checkable:\nflag |= constants.IS_CHECKABLE\nif self.tristate:\nflag |= constants.IS_USER_TRISTATE\nreturn flag\ndef get_data(self, item, role):\nreturn NotImplemented\ndef set_data(self, item, value, role):\nreturn NotImplemented\ndef get_width(self) -&gt; int:\nmatch self.width:\ncase \"small\":\nreturn SMALL_COL_WIDTH\ncase \"medium\":\nreturn MEDIUM_COL_WIDTH\ncase int():\nreturn self.width\ncase _:\nraise ValueError(self.width)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ColumnJoinerProxyModel","title":"<code>ColumnJoinerProxyModel</code>","text":"<p>         Bases: <code>core.AbstractProxyModel</code></p> Source code in <code>prettyqt\\custom_models\\columnjoinerproxymodel.py</code> <pre><code>class ColumnJoinerProxyModel(core.AbstractProxyModel):\nID = \"column_join\"\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.mapping = []\ndef columnCount(self, parent: core.ModelIndex | None = None) -&gt; int:\nparent = parent or core.ModelIndex()\nreturn (\n0\nif self.sourceModel() is None\nelse self.sourceModel().columnCount(parent) + len(self.mapping)\n)\ndef rowCount(self, parent: core.ModelIndex | None = None):\nreturn self.sourceModel().rowCount()\ndef flags(self, index: core.ModelIndex):\ncolumn = index.column()\nif self.is_additional_column(column):\nreturn self.mapping[column - self.columnCount()].flags\nreturn self.sourceModel().flags(index)\ndef is_additional_column(self, column: int):\ncol_count = self.sourceModel().columnCount()\nreturn column &gt;= col_count\ndef index(self, row, column, parent):\nif self.is_additional_column(column):\nreturn self.createIndex(row, column, core.ModelIndex())\nreturn self.sourceModel().index(row, column, parent)\ndef parent(self, index=None):\nif self.is_additional_column(index.column()):\nreturn core.ModelIndex()\nreturn self.sourceModel().parent(index)\ndef data(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\ncol_count = self.sourceModel().columnCount()\ncolumn = index.column()\nif self.is_additional_column(column):\nif role == constants.DISPLAY_ROLE:\nmapper = self.mapping[column - col_count]\nfield_names = [v[1] for v in string.Formatter().parse(mapper.formatter)]\nformatter = mapper.formatter\nmatch formatter:\ncase str():\nfor name in field_names:\ndata = self.data(\nself.index(index.row(), int(name), index.parent())\n)\nformatter = formatter.replace(f\"{{{name}}}\", data)\nreturn formatter\ncase Callable():\nreturn formatter(index)\nreturn None\nreturn super().data(index, role)\ndef headerData(\nself,\nsection: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nif orientation == constants.HORIZONTAL:\nif self.is_additional_column(section):\nif role == constants.DISPLAY_ROLE:\nmapper = self.mapping[section - self.columnCount()]\nreturn mapper.header\nreturn None\nreturn super().headerData(section, orientation, role)\ndef mapToSource(self, proxy_index):\nif not proxy_index.isValid():\nreturn core.ModelIndex()\ncolumn = proxy_index.column()\nif self.is_additional_column(column):\nreturn core.ModelIndex()\nreturn self.sourceModel().index(\nproxy_index.row(), proxy_index.column(), proxy_index.parent()\n)\ndef mapFromSource(self, index):\nif self.is_additional_column(index.column()):\nreturn core.ModelIndex()\nreturn self.sourceModel().index(index.row(), index.column(), index.parent())\ndef add_mapping(self, column_name: str, formatter: str):\n\"\"\"Form: for example \"{0} ({1}), with numbers referencing the columns.\"\"\"\nself.mapping.append(ColumnMapping(formatter, column_name))\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnjoinerproxymodel.ColumnJoinerProxyModel.add_mapping","title":"<code>add_mapping(column_name: str, formatter: str)</code>","text":"<p>Form: for example \"{0} ({1}), with numbers referencing the columns.</p> Source code in <code>prettyqt\\custom_models\\columnjoinerproxymodel.py</code> <pre><code>def add_mapping(self, column_name: str, formatter: str):\n\"\"\"Form: for example \"{0} ({1}), with numbers referencing the columns.\"\"\"\nself.mapping.append(ColumnMapping(formatter, column_name))\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ColumnTableModel","title":"<code>ColumnTableModel</code>","text":"<p>         Bases: <code>ColumnItemModelMixin</code>, <code>core.AbstractTableModel</code></p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>class ColumnTableModel(ColumnItemModelMixin, core.AbstractTableModel):\ndef __init__(\nself,\nitems: Sequence,\ncolumns: Sequence[ColumnItem],\nmime_type: str | None = None,\n**kwargs,\n):\nsuper().__init__(**kwargs)\nself.items = items\nself.mime_type = mime_type\nself._attr_cols = []\nself.set_columns(columns)\ndef rowCount(self, parent=None):\nparent = parent or core.ModelIndex()\nreturn 0 if parent.isValid() else len(self.items)\ndef columnCount(self, parent=None):\nparent = parent or core.ModelIndex()\nreturn 0 if parent.isValid() else len(self._attr_cols)\ndef data_by_index(self, index: core.ModelIndex):\nreturn self.items[index.row()]\ndef setData(\nself,\nindex: core.ModelIndex,\nvalue: Any,\nrole: constants.ItemDataRole = constants.EDIT_ROLE,\n):\nif role == constants.USER_ROLE:\nself.items[index.row()] = value\nself.update_row(index.row())\nreturn True\nreturn super().setData(index, value, role)\ndef removeRows(self, row: int, count: int, parent):\nend_row = row + count - 1\nwith self.remove_rows(row, end_row, parent):\nfor i in range(end_row, row - 1, -1):\nself.items.pop(i)\nreturn True\ndef dropMimeData(self, mime_data, action, row, column, parent_index):\nif not mime_data.hasFormat(self.mime_type):\nreturn False\n# Since we only drop in between items, parent_index must be invalid,\n# and we use the row arg to know where the drop took place.\nif parent_index.isValid():\nreturn False\nindexes = mime_data.get_json_data(self.mime_type)\npos = row if row &lt; len(self.items) and row != -1 else len(self.items)\nrem_offset = sum(i &lt;= pos for i in indexes)\nnew = [self.items[i] for i in indexes]\nwith self.change_layout():\nfor i in sorted(indexes, reverse=True):\nself.items.pop(i)\nfor item in reversed(new):\nself.items.insert(pos - rem_offset, item)\nreturn False\ndef sort(self, ncol: int, order):\n\"\"\"Sort table by given column number.\"\"\"\nis_asc = order == constants.ASCENDING\nif sorter := self._attr_cols[ncol].label:\nwith self.change_layout():\nself.items.sort(key=sorter, reverse=is_asc)\ndef add(self, item: Any, position: int | None = None):\n\"\"\"Append provided item to the list.\"\"\"\nself.add_items(items=[item], position=position)\nreturn item\ndef add_items(self, items: Iterable[Any], position: int | None = None):\n\"\"\"Append a list of items to the list.\"\"\"\nif position is None:\nposition = len(self.items)\nitems = list(items)\nwith self.insert_rows(position, position + len(items) - 1):\nfor i, _ in enumerate(items):\nself.items.insert(i + position, items[i])\n# self.items.extend(items)\nreturn items\ndef remove_items(self, offsets: Iterable[int]):\nfor offset in sorted(offsets, reverse=True):\nself.removeRow(offset)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnTableModel.add","title":"<code>add(item: Any, position: int | None = None)</code>","text":"<p>Append provided item to the list.</p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>def add(self, item: Any, position: int | None = None):\n\"\"\"Append provided item to the list.\"\"\"\nself.add_items(items=[item], position=position)\nreturn item\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnTableModel.add_items","title":"<code>add_items(items: Iterable[Any], position: int | None = None)</code>","text":"<p>Append a list of items to the list.</p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>def add_items(self, items: Iterable[Any], position: int | None = None):\n\"\"\"Append a list of items to the list.\"\"\"\nif position is None:\nposition = len(self.items)\nitems = list(items)\nwith self.insert_rows(position, position + len(items) - 1):\nfor i, _ in enumerate(items):\nself.items.insert(i + position, items[i])\n# self.items.extend(items)\nreturn items\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnTableModel.sort","title":"<code>sort(ncol: int, order: int)</code>","text":"<p>Sort table by given column number.</p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>def sort(self, ncol: int, order):\n\"\"\"Sort table by given column number.\"\"\"\nis_asc = order == constants.ASCENDING\nif sorter := self._attr_cols[ncol].label:\nwith self.change_layout():\nself.items.sort(key=sorter, reverse=is_asc)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.FuzzyFilterProxyModel","title":"<code>FuzzyFilterProxyModel</code>","text":"<p>         Bases: <code>core.SortFilterProxyModel</code></p> <p>Proxy model with fuzzyfilter functionality.</p> <p>this proxymodel replaces the text from the display role in the given filter column with HTML code in order to color the letter matches. A backup from the original text is made available in the BackupRole. Based on the original text, the proxy calculates a score for the match and makes it available via the SortRole. To display the html code properly, a HtmlItemDelegate is needed.</p> Source code in <code>prettyqt\\custom_models\\fuzzyfiltermodel.py</code> <pre><code>class FuzzyFilterProxyModel(core.SortFilterProxyModel):\n\"\"\"Proxy model with fuzzyfilter functionality.\n    this proxymodel replaces the text from the display role in the given filter column\n    with HTML code in order to color the letter matches. A backup from the original text\n    is made available in the BackupRole. Based on the original text, the proxy calculates\n    a score for the match and makes it available via the SortRole.\n    To display the html code properly, a HtmlItemDelegate is needed.\n    \"\"\"\nID = \"fuzzy\"\nclass Roles(enum.IntEnum):\n\"\"\"Addional roles.\"\"\"\nBackupRole = constants.USER_ROLE + 65\nSortRole = constants.SORT_ROLE\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, filter_mode=\"fuzzy\", **kwargs)\nself._search_term = \"\"\nself._match_color: QtGui.QColor = gui.Color(\"blue\")\nself.sort(0, constants.DESCENDING)\ndef set_match_color(self, color: datatypes.ColorType | None):\nself._match_color = colors.get_color(color) if color else QtGui.QColor()\ndef get_match_color(self) -&gt; QtGui.QColor:\nreturn self._match_color\ndef lessThan(self, left: core.ModelIndex, right: core.ModelIndex):\nif not self._search_term:\nreturn super().lessThan(left, right)\nif left.data() is None or right.data() is None:\nreturn True\n# since fuzzy scores are cached, it should be fine to do this here.\nleft_data = fuzzy.fuzzy_match(self._search_term, str(left.data()))\nright_data = fuzzy.fuzzy_match(self._search_term, str(right.data()))\nreturn left_data &lt; right_data\ndef set_search_term(self, search_term: str):\nself._search_term = search_term\nsuper().set_search_term(search_term)\nself.invalidate()\ndef get_search_term(self):\nreturn self._search_term\ndef data(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nif not index.isValid():\nreturn None\nfilter_column = self.filterKeyColumn()\nmatch role, index.column():\ncase constants.DISPLAY_ROLE, _ if index.column() == filter_column:\nlabel = super().data(index, constants.DISPLAY_ROLE)\nreturn (\nfuzzy.color_text(\nself._search_term,\nstr(label),\nself._match_color.name(),\nself.is_filter_case_sensitive(),\n)\nif self._search_term and self._match_color.isValid() and label\nelse label\n)\n# case constants.DISPLAY_ROLE, 1:\n#     idx = self.index(index.row(), filter_column)\n#     label = super().data(idx, constants.DISPLAY_ROLE)\n#     if label is None:\n#         return None\n#     result = fuzzy.fuzzy_match(self._search_term, str(label))\n#     return str(result[1])\ncase self.Roles.BackupRole, _:\nreturn super().data(index, constants.DISPLAY_ROLE)\ncase self.Roles.SortRole, _:\nidx = self.index(index.row(), filter_column)\nlabel = super().data(idx, constants.DISPLAY_ROLE)\nresult = fuzzy.fuzzy_match(self._search_term, label)\nreturn result[1]\ncase _, _:\nreturn super().data(index, role)\nsearch_term = core.Property(str, get_search_term, set_search_term)\nmatch_color = core.Property(QtGui.QColor, get_match_color, set_match_color)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.fuzzyfiltermodel.FuzzyFilterProxyModel.Roles","title":"<code>Roles</code>","text":"<p>         Bases: <code>enum.IntEnum</code></p> <p>Addional roles.</p> Source code in <code>prettyqt\\custom_models\\fuzzyfiltermodel.py</code> <pre><code>class Roles(enum.IntEnum):\n\"\"\"Addional roles.\"\"\"\nBackupRole = constants.USER_ROLE + 65\nSortRole = constants.SORT_ROLE\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.HighlightCurrentProxyModel","title":"<code>HighlightCurrentProxyModel</code>","text":"<p>         Bases: <code>core.IdentityProxyModel</code></p> <p>Highlights all cells which have same data as current index in given role.</p> Source code in <code>prettyqt\\custom_models\\highlightcurrentproxymodel.py</code> <pre><code>class HighlightCurrentProxyModel(core.IdentityProxyModel):\n\"\"\"Highlights all cells which have same data as current index in given role.\"\"\"\nID = \"highlight_current\"\ndef __init__(\nself,\n*args,\nrole=constants.DISPLAY_ROLE,\nmode: HighlightModeStr = \"column\",\nhighlight_color: datatypes.ColorType = \"red\",\n**kwargs,\n):\nself._mode = mode\nself._current_value = ...  # Sentinel value\nself._data_role = role\nself._current_column = None\nself._current_row = None\nself._highlight_color = colors.get_color(highlight_color).as_qt()\nsuper().__init__(*args, **kwargs)\nparent: widgets.AbstractItemView = self.parent()  # type: ignore\nparent.model_changed.connect(self._on_model_change)\nif sel_model := parent.selectionModel():\nsel_model.currentChanged.connect(self._on_current_change)\ndef _on_model_change(self, model):\nself.parent().selectionModel().currentChanged.connect(self._on_current_change)\ndef _on_current_change(self, new, old):\nwith self.change_layout():\nself._current_value = new.data(constants.DISPLAY_ROLE)\nself._current_column = new.column()\nself._current_row = new.row()\ndef set_highlight_color(self, color: datatypes.ColorType):\n\"\"\"Set color used for highlighting cells.\"\"\"\nself._highlight_color = colors.get_color(color).as_qt()\ndef get_highlight_color(self) -&gt; QtGui.QColor:\n\"\"\"Get color used for higlighting cells.\"\"\"\nreturn self._highlight_color\ndef set_highlight_mode(self, mode: HighlightModeStr):\n\"\"\"Set highlight mode.\"\"\"\nself._highlight_mode = mode\ndef get_highlight_mode(self) -&gt; HighlightModeStr:\n\"\"\"Get highlight mode.\"\"\"\nreturn self._highlight_mode\ndef data(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nif (\nrole == constants.BACKGROUND_ROLE\nand index.data(self._data_role) == self._current_value\nand (\n(self._mode == \"column\" and index.column() == self._current_column)\nor (\nself._mode == \"row\"\nand (index.row() == self._current_row)\nor self._mode == \"all\"\n)\n)\n):\nreturn self._highlight_color\nreturn super().data(index, role)\nhighlightMode = core.Property(str, get_highlight_mode, set_highlight_mode)\nhighlightColor = core.Property(QtGui.QColor, get_highlight_color, set_highlight_color)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.highlightcurrentproxymodel.HighlightCurrentProxyModel.get_highlight_color","title":"<code>get_highlight_color() -&gt; QtGui.QColor</code>","text":"<p>Get color used for higlighting cells.</p> Source code in <code>prettyqt\\custom_models\\highlightcurrentproxymodel.py</code> <pre><code>def get_highlight_color(self) -&gt; QtGui.QColor:\n\"\"\"Get color used for higlighting cells.\"\"\"\nreturn self._highlight_color\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.highlightcurrentproxymodel.HighlightCurrentProxyModel.get_highlight_mode","title":"<code>get_highlight_mode() -&gt; HighlightModeStr</code>","text":"<p>Get highlight mode.</p> Source code in <code>prettyqt\\custom_models\\highlightcurrentproxymodel.py</code> <pre><code>def get_highlight_mode(self) -&gt; HighlightModeStr:\n\"\"\"Get highlight mode.\"\"\"\nreturn self._highlight_mode\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.highlightcurrentproxymodel.HighlightCurrentProxyModel.set_highlight_color","title":"<code>set_highlight_color(color: datatypes.ColorType)</code>","text":"<p>Set color used for highlighting cells.</p> Source code in <code>prettyqt\\custom_models\\highlightcurrentproxymodel.py</code> <pre><code>def set_highlight_color(self, color: datatypes.ColorType):\n\"\"\"Set color used for highlighting cells.\"\"\"\nself._highlight_color = colors.get_color(color).as_qt()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.highlightcurrentproxymodel.HighlightCurrentProxyModel.set_highlight_mode","title":"<code>set_highlight_mode(mode: HighlightModeStr)</code>","text":"<p>Set highlight mode.</p> Source code in <code>prettyqt\\custom_models\\highlightcurrentproxymodel.py</code> <pre><code>def set_highlight_mode(self, mode: HighlightModeStr):\n\"\"\"Set highlight mode.\"\"\"\nself._highlight_mode = mode\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.HighlightMouseProxyModel","title":"<code>HighlightMouseProxyModel</code>","text":"<p>         Bases: <code>core.IdentityProxyModel</code></p> <p>Highlights all cells with same row / column as mouse position.</p> Source code in <code>prettyqt\\custom_models\\highlightmouseproxymodel.py</code> <pre><code>class HighlightMouseProxyModel(core.IdentityProxyModel):\n\"\"\"Highlights all cells with same row / column as mouse position.\"\"\"\nID = \"highlight_mouse\"\ndef __init__(\nself,\nparent: widgets.QAbstractItemView,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\nmode: HighlightModeStr = \"both\",\nhighlight_color: datatypes.ColorType = \"red\",\n**kwargs,\n):\nself._mode = mode\nself._current_value = ...  # Sentinel value\nself._data_role = role\nself._current_column = None\nself._current_row = None\nself._highlight_color = colors.get_color(highlight_color).as_qt()\nsuper().__init__(parent, **kwargs)\nparent.setMouseTracking(True)\nparent.entered.connect(self.cell_entered)\nparent.installEventFilter(self)\ndef eventFilter(self, source, event):\nmatch event.type():\ncase core.Event.Type.Leave:\nself._current_row = None\nself._current_column = None\nself.force_layoutchange()\nreturn False\ndef cell_entered(self, index):\nself._current_row = index.row()\nself._current_column = index.column()\nself.force_layoutchange()\ndef set_highlight_color(self, color: datatypes.ColorType):\n\"\"\"Set color used for highlighting cells.\"\"\"\nself._highlight_color = colors.get_color(color).as_qt()\ndef get_highlight_color(self) -&gt; QtGui.QColor:\n\"\"\"Get color used for higlighting cells.\"\"\"\nreturn self._highlight_color\ndef set_highlight_mode(self, mode: HighlightModeStr):\n\"\"\"Set highlight mode.\"\"\"\nself._highlight_mode = mode\ndef get_highlight_mode(self) -&gt; HighlightModeStr:\n\"\"\"Get highlight mode.\"\"\"\nreturn self._highlight_mode\ndef data(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nif role != constants.BACKGROUND_ROLE:\nreturn super().data(index, role)\nis_in_row = index.row() == self._current_row\nis_in_column = index.column() == self._current_column\nmatch self._mode:\ncase \"column\" if is_in_column:\nreturn self._highlight_color\ncase \"row\" if is_in_row:\nreturn self._highlight_color\ncase \"both\" if is_in_row or is_in_column:\nreturn self._highlight_color\ncase \"single\" if is_in_row and is_in_column:\nreturn self._highlight_color\ncase _:\nreturn super().data(index, role)\nhighlightMode = core.Property(str, get_highlight_mode, set_highlight_mode)\nhighlightColor = core.Property(QtGui.QColor, get_highlight_color, set_highlight_color)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.highlightmouseproxymodel.HighlightMouseProxyModel.get_highlight_color","title":"<code>get_highlight_color() -&gt; QtGui.QColor</code>","text":"<p>Get color used for higlighting cells.</p> Source code in <code>prettyqt\\custom_models\\highlightmouseproxymodel.py</code> <pre><code>def get_highlight_color(self) -&gt; QtGui.QColor:\n\"\"\"Get color used for higlighting cells.\"\"\"\nreturn self._highlight_color\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.highlightmouseproxymodel.HighlightMouseProxyModel.get_highlight_mode","title":"<code>get_highlight_mode() -&gt; HighlightModeStr</code>","text":"<p>Get highlight mode.</p> Source code in <code>prettyqt\\custom_models\\highlightmouseproxymodel.py</code> <pre><code>def get_highlight_mode(self) -&gt; HighlightModeStr:\n\"\"\"Get highlight mode.\"\"\"\nreturn self._highlight_mode\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.highlightmouseproxymodel.HighlightMouseProxyModel.set_highlight_color","title":"<code>set_highlight_color(color: datatypes.ColorType)</code>","text":"<p>Set color used for highlighting cells.</p> Source code in <code>prettyqt\\custom_models\\highlightmouseproxymodel.py</code> <pre><code>def set_highlight_color(self, color: datatypes.ColorType):\n\"\"\"Set color used for highlighting cells.\"\"\"\nself._highlight_color = colors.get_color(color).as_qt()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.highlightmouseproxymodel.HighlightMouseProxyModel.set_highlight_mode","title":"<code>set_highlight_mode(mode: HighlightModeStr)</code>","text":"<p>Set highlight mode.</p> Source code in <code>prettyqt\\custom_models\\highlightmouseproxymodel.py</code> <pre><code>def set_highlight_mode(self, mode: HighlightModeStr):\n\"\"\"Set highlight mode.\"\"\"\nself._highlight_mode = mode\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.JsonModel","title":"<code>JsonModel</code>","text":"<p>         Bases: <code>custom_models.ColumnItemModel</code></p> Source code in <code>prettyqt\\custom_models\\jsonmodel.py</code> <pre><code>class JsonModel(custom_models.ColumnItemModel):\nCOLUMNS = [NameColumn, ValueColumn, TypeColumn]\ndef __init__(\nself,\nobj: Any,\nshow_root: bool = True,\n**kwargs,\n):\nsuper().__init__(\nobj=JsonItem(key=\"\", value=obj, typ=type(obj)),\ncolumns=self.COLUMNS,\nshow_root=show_root,\n**kwargs,\n)\n@classmethod\ndef supports(cls, instance) -&gt; bool:\nreturn isinstance(instance, Mapping)\ndef _has_children(self, item: treeitem.TreeItem) -&gt; bool:\nreturn isinstance(item.obj.value, dict | list | set) and bool(item.obj.value)\ndef _fetch_object_children(self, item: treeitem.TreeItem) -&gt; list[treeitem.TreeItem]:\n\"\"\"Fetch the children of a Python object.\n        Returns: list of treeitem.TreeItems\n        \"\"\"\n# items = []\nmatch item.obj.value:\ncase Mapping():\nreturn [\ntreeitem.TreeItem(obj=JsonItem(key=k, value=v, typ=type(v)))\nfor k, v in item.obj.value.items()\n]\ncase Iterable() if not isinstance(item.obj.value, str):\nreturn [\ntreeitem.TreeItem(obj=JsonItem(key=k, value=v, typ=type(v)))\nfor k, v in enumerate(item.obj.value)\n]\ncase _:\nreturn [\ntreeitem.TreeItem(\nobj=JsonItem(\nkey=\"key\",\nvalue=repr(item.obj.value),\ntyp=type(item.obj.value),\n)\n)\n]\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ListMixin","title":"<code>ListMixin</code>","text":"Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>class ListMixin:\nSORT_METHODS: dict[int, Callable]\nMIME_TYPE: str = \"\"\ndef __init__(self, *args, items=None, **kwargs):\nsuper().__init__(*args, **kwargs)  # type: ignore\nself.items = items or []\ndef setData(\nself,\nindex: core.ModelIndex,\nvalue: Any,\nrole: constants.ItemDataRole = constants.EDIT_ROLE,\n) -&gt; bool:\nif role == constants.USER_ROLE:\nself.items[index.row()] = value\nself.update_row(index.row())\nreturn True\nreturn super().setData(index, value, role)  # type: ignore\ndef removeRows(self, row: int, count: int, parent):\n# called by default implementation of QAbstractItemModel::startDrag\nend_row = row + count - 1\nwith self.remove_rows(row, end_row, parent):\nfor i in range(end_row, row - 1, -1):\nself.items.pop(i)\nreturn True\n# def insertRows(self, row: int, count: int, parent):\n#     # called by default implementation of QAbstractItemModel::dropMimeData\n#     end_row = row + count - 1\n#     with self.insert_rows(row, end_row, parent):\n#         for i in range(end_row, row - 1, -1):\n#             self.items.insert(i,)\n#     return True\ndef rowCount(self, parent=None):\n\"\"\"Required override for AbstractitemModels.\"\"\"\nparent = parent or core.ModelIndex()\nreturn 0 if parent.column() &gt; 0 or parent.isValid() else len(self.items)\ndef data_by_index(self, index):\nreturn self.items[index.row()]\ndef dropMimeData(self, mime_data, action, row, column, parent_index):\nif not mime_data.hasFormat(self.MIME_TYPE):\nreturn False\n# Since we only drop in between items, parent_index must be invalid,\n# and we use the row arg to know where the drop took place.\nif parent_index.isValid():\nreturn False\nindexes = mime_data.get_json_data(self.MIME_TYPE)\npos = row if row &lt; len(self.items) and row != -1 else len(self.items)\nrem_offset = sum(i &lt;= pos for i in indexes)\nnew = [self.items[i] for i in indexes]\nwith self.change_layout():\nfor i in sorted(indexes, reverse=True):\nself.items.pop(i)\nfor item in reversed(new):\nself.items.insert(pos - rem_offset, item)\nreturn False\ndef sort(self, ncol: int, order):\n\"\"\"Sort table by given column number.\"\"\"\nis_asc = order == constants.ASCENDING\nif sorter := self.SORT_METHODS.get(ncol):\nwith self.change_layout():\nself.items.sort(key=sorter, reverse=is_asc)\ndef add(self, item: Any, position: int | None = None):\n\"\"\"Append provided item to the list.\"\"\"\nself.add_items(items=[item], position=position)\nreturn item\ndef add_items(self, items: Iterable[Any], position: int | None = None):\n\"\"\"Append a list of items to the list.\"\"\"\nif position is None:\nposition = len(self.items)\nitems = list(items)\nwith self.insert_rows(position, position + len(items) - 1):\nfor i in range(len(items)):\nself.items.insert(i + position, items[i])\n# self.items.extend(items)\nreturn items\ndef remove_items(self, offsets: Iterable[int]):\nfor offset in sorted(offsets, reverse=True):\nself.removeRow(offset)\ndef supportedDropActions(self):\nreturn constants.MOVE_ACTION\ndef mimeTypes(self):\nreturn [self.MIME_TYPE]\ndef mimeData(self, indexes):\n\"\"\"AbstractItemModel override, defines the data used for drag and drop.\n        atm this just returns the positions (not sure if this is perfect)\n        \"\"\"\nmime_data = core.MimeData()\ndata = [i.row() for i in indexes if i.column() == 0]\nmime_data.set_json_data(self.MIME_TYPE, data)\nreturn mime_data\n# list interface\ndef pop(self, row=None):\nif row is None:\nrow = len(self.items) - 1\nresult = self.items[row]\nself.removeRow(row)\nreturn result\ndef __getitem__(self, row):\nreturn self.items[row]\ndef __setitem__(self, row: int | slice, value):\nmatch row:\ncase slice():\nrng = range(row.start or 0, row.stop or len(self.items), row.step or 1)\nfor count, i in enumerate(rng):\nif i &lt; self.rowCount():\nindex = self.index(i)\nself.setData(i, value[count], role=constants.USER_ROLE)\nelse:\nself.items.append(value[count])\ncase int():\nindex = self.index(row)\nself.setData(index, value, role=constants.USER_ROLE)\ncase _:\nraise ValueError(row)\ndef __len__(self):\nreturn len(self.items)\ndef insert(self, row: int, value):\nwith self.insert_row(row):\nself.items.insert(row, value)\ndef append(self, value):\nrow = len(self.items)\nself.insert(row, value)\ndef extend(self, values):\npos = len(self.items)\nwith self.insert_rows(pos, pos + len(values)):\nself.items.extend(values)\ndef set_list(self, values):\n\"\"\"Set the model to a new list.\"\"\"\nwith self.reset_model():\nself.items = values\ndef remove(self, item):\nif item in self.items:\npos = self.items.index(item)\nwith self.remove_row(pos):\nself.items.remove(item)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.add","title":"<code>add(item: Any, position: int | None = None)</code>","text":"<p>Append provided item to the list.</p> Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>def add(self, item: Any, position: int | None = None):\n\"\"\"Append provided item to the list.\"\"\"\nself.add_items(items=[item], position=position)\nreturn item\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.add_items","title":"<code>add_items(items: Iterable[Any], position: int | None = None)</code>","text":"<p>Append a list of items to the list.</p> Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>def add_items(self, items: Iterable[Any], position: int | None = None):\n\"\"\"Append a list of items to the list.\"\"\"\nif position is None:\nposition = len(self.items)\nitems = list(items)\nwith self.insert_rows(position, position + len(items) - 1):\nfor i in range(len(items)):\nself.items.insert(i + position, items[i])\n# self.items.extend(items)\nreturn items\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.mimeData","title":"<code>mimeData(indexes)</code>","text":"<p>AbstractItemModel override, defines the data used for drag and drop.</p> <p>atm this just returns the positions (not sure if this is perfect)</p> Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>def mimeData(self, indexes):\n\"\"\"AbstractItemModel override, defines the data used for drag and drop.\n    atm this just returns the positions (not sure if this is perfect)\n    \"\"\"\nmime_data = core.MimeData()\ndata = [i.row() for i in indexes if i.column() == 0]\nmime_data.set_json_data(self.MIME_TYPE, data)\nreturn mime_data\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.rowCount","title":"<code>rowCount(parent = None)</code>","text":"<p>Required override for AbstractitemModels.</p> Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>def rowCount(self, parent=None):\n\"\"\"Required override for AbstractitemModels.\"\"\"\nparent = parent or core.ModelIndex()\nreturn 0 if parent.column() &gt; 0 or parent.isValid() else len(self.items)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.set_list","title":"<code>set_list(values)</code>","text":"<p>Set the model to a new list.</p> Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>def set_list(self, values):\n\"\"\"Set the model to a new list.\"\"\"\nwith self.reset_model():\nself.items = values\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.sort","title":"<code>sort(ncol: int, order: int)</code>","text":"<p>Sort table by given column number.</p> Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>def sort(self, ncol: int, order):\n\"\"\"Sort table by given column number.\"\"\"\nis_asc = order == constants.ASCENDING\nif sorter := self.SORT_METHODS.get(ncol):\nwith self.change_layout():\nself.items.sort(key=sorter, reverse=is_asc)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ModelMixin","title":"<code>ModelMixin</code>","text":"Source code in <code>prettyqt\\custom_models\\modelmixin.py</code> <pre><code>class ModelMixin:\nDTYPE_ROLE = constants.USER_ROLE + 1  # type: ignore\nHEADER = [\"Name\"]\nLABELS: dict = {}\nCHECKSTATE: dict = {}\nTOOLTIPS: dict = {}\nDECORATIONS: dict = {}\nSET_DATA: dict = {}\ncontent_type = \"\"\ndef headerData(\nself,\noffset: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nmatch orientation, role:\ncase constants.HORIZONTAL, constants.DISPLAY_ROLE:\nreturn self.HEADER[offset]\ndef columnCount(self, parent=None):\nreturn len(self.HEADER)\ndef flags(self, index: core.ModelIndex) -&gt; constants.ItemFlag:\n\"\"\"Override for AbstractitemModel base method.\n        returns corresponding flags for cell of supplied index\n        \"\"\"\nif not index.isValid():\nreturn constants.DROP_ENABLED\nif index.column() in self.SET_DATA:\nreturn self.DEFAULT_FLAGS | constants.IS_EDITABLE\nreturn self.DEFAULT_FLAGS\ndef data(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nif not index.isValid():\nreturn None\nitem = self.data_by_index(index)\nmatch role:\ncase constants.DECORATION_ROLE:\nif fn := self.DECORATIONS.get(index.column()):\nreturn fn(item)\ncase constants.DISPLAY_ROLE | constants.EDIT_ROLE:\nif fn := self.LABELS.get(index.column()):\nreturn fn(item)\ncase constants.TOOLTIP_ROLE:\nif fn := self.TOOLTIPS.get(index.column()):\nreturn fn(item)\ncase constants.CHECKSTATE_ROLE:\nif fn := self.CHECKSTATE.get(index.column()):\nreturn fn(item)\ncase constants.USER_ROLE:\nreturn item\ncase _:\nreturn None\ndef setData(\nself,\nindex: core.ModelIndex,\nvalue: Any,\nrole: constants.ItemDataRole = constants.EDIT_ROLE,\n) -&gt; bool:\nif role == constants.EDIT_ROLE:\nif not value:\nreturn False\nitem = self.data_by_index(index)\nif fn := self.SET_DATA.get(index.column()):\nfn(item, value)\nself.update_row(index.row())\nreturn True\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.modelmixin.ModelMixin.flags","title":"<code>flags(index: core.ModelIndex) -&gt; constants.ItemFlag</code>","text":"<p>Override for AbstractitemModel base method.</p> <p>returns corresponding flags for cell of supplied index</p> Source code in <code>prettyqt\\custom_models\\modelmixin.py</code> <pre><code>def flags(self, index: core.ModelIndex) -&gt; constants.ItemFlag:\n\"\"\"Override for AbstractitemModel base method.\n    returns corresponding flags for cell of supplied index\n    \"\"\"\nif not index.isValid():\nreturn constants.DROP_ENABLED\nif index.column() in self.SET_DATA:\nreturn self.DEFAULT_FLAGS | constants.IS_EDITABLE\nreturn self.DEFAULT_FLAGS\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.MultiColumnFilterProxyModel","title":"<code>MultiColumnFilterProxyModel</code>","text":"<p>         Bases: <code>core.SortFilterProxyModel</code></p> <p>A SortFilterProxyModel which filters based on multiple columns in one go.</p> <p>Especially useful for our FilterHeader widget, which otherwise would nest a lot of SortFilterProxyModels, where each one would have to loop the whole table.</p> Source code in <code>prettyqt\\custom_models\\multicolumnfilterproxymodel.py</code> <pre><code>class MultiColumnFilterProxyModel(core.SortFilterProxyModel):\n\"\"\"A SortFilterProxyModel which filters based on multiple columns in one go.\n    Especially useful for our FilterHeader widget, which otherwise would nest\n    a lot of SortFilterProxyModels, where each one would have to loop the whole table.\n    \"\"\"\nID = \"multi_column_filter\"\ndef __init__(self, parent=None, **kwargs):\nsuper().__init__(parent, **kwargs)\nself._filters: dict[int, Filter] = {}\nself.setRecursiveFilteringEnabled(True)\ndef clear_filters(self):\nself._filters = {}\nself.invalidateRowsFilter()\ndef set_filter_value(\nself,\ncolumn: int,\nvalue: str,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nif value == \"\" or value is None:  # False is a valid value.\ndel self._filters[column]\nelse:\nself._filters[column] = Filter(column=column, value=value, role=role)\nself.invalidateRowsFilter()\ndef setFilterKeyColumn(self, column: int):\nraise NotImplementedError(\"Not supported.\")\ndef setFilterRole(self, column: int):\nraise NotImplementedError(\"Not supported.\")\ndef filterAcceptsRow(self, row, parent):\nsource = self.sourceModel()\nfor k, v in self._filters.items():\nindex = source.index(row, k, parent)\ndata = source.data(index, v.role)\nsearch_val = v.value\nmatch search_val:\ncase str():\nif (\nself.filterMode == \"fuzzy\"\nand not fuzzy.fuzzy_match_simple(\nsearch_val,\ndata,\ncase_sensitive=self.is_filter_case_sensitive(),\n)\n):\nreturn False\nif not self.is_filter_case_sensitive():\nsearch_val = search_val.lower()\ndata = data.lower()\nif not data.startswith(search_val):\nreturn False\ncase Callable():\nreturn search_val(data)\ncase _:\nif data != search_val:\nreturn False\nreturn True\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.NestedItem","title":"<code>NestedItem</code>","text":"Source code in <code>prettyqt\\custom_models\\nesteditem.py</code> <pre><code>class NestedItem:\nitem_name = \"not_defined\"\ndef __init__(\nself,\nparent: Self | None = None,\ndynamic_name: str | None = None,\ncount: int | None = None,\nchildren: Sequence[Self] | None = None,\n):\nself.parent = parent\nself.dynamic_name = dynamic_name or self.item_name\nself.count = count\n# self.timestamp = kwargs.pop(\"timestamp\", time.time())\nself.children: Sequence[Self] = []\nif children:\nself.add_children(children)\ndef __iter__(self) -&gt; Iterator[Self]:\nreturn iter(self.children)\ndef add_children(self, children: Sequence[Self]):\nfor child in children:\nchild.parent = self\nself.children.extend(children)\ndef append_child(self, item: Self):\nitem.parent_item = self\nself.children.append(item)\ndef insert_children(self, idx: int, items: Sequence[Self]):\nself.children[idx:idx] = items\nfor item in items:\nitem.parent_item = self\ndef child(self, row: int) -&gt; Self:\nreturn self.children[row]\ndef row(self) -&gt; int:\n\"\"\"Return row number.\n        returns row position of item inside parent`s children\n        returns 0 if no parent available\n        Returns:\n            row number\n        \"\"\"\nreturn self.parent.children.index(self) if self.parent else 0\ndef iter_tree(\nself,\nname: str | None = None,\nyield_self: bool = True,\nrecursive: bool = True,\nlevel: int = 0,\ncount: int = 0,\nassign_names: bool = True,\n):\n\"\"\"Yield children from bottom to top, yield self at end.\n        assigns dynamic vars count, level and dynamic name\n        \"\"\"\nif name is None:\nname = self.item_name\nfor i, c in enumerate(self.children, start=1):\ncount += 1\nlevel += 1\nwith_suffix = f\"{name}_{i}\" if len(self.children) &gt; 1 else name\nif recursive:\nyield from c.iter_tree(\nwith_suffix, yield_self=False, level=level, count=count\n)\nif assign_names:\nc.dynamic_name, c.count = with_suffix, count\nyield c\nlevel -= 1\nif yield_self:\nif assign_names:\nself.dynamic_name, self.count = name, 0\nyield self\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem.NestedItem.iter_tree","title":"<code>iter_tree(name: str | None = None, yield_self: bool = True, recursive: bool = True, level: int = 0, count: int = 0, assign_names: bool = True)</code>","text":"<p>Yield children from bottom to top, yield self at end.</p> <p>assigns dynamic vars count, level and dynamic name</p> Source code in <code>prettyqt\\custom_models\\nesteditem.py</code> <pre><code>def iter_tree(\nself,\nname: str | None = None,\nyield_self: bool = True,\nrecursive: bool = True,\nlevel: int = 0,\ncount: int = 0,\nassign_names: bool = True,\n):\n\"\"\"Yield children from bottom to top, yield self at end.\n    assigns dynamic vars count, level and dynamic name\n    \"\"\"\nif name is None:\nname = self.item_name\nfor i, c in enumerate(self.children, start=1):\ncount += 1\nlevel += 1\nwith_suffix = f\"{name}_{i}\" if len(self.children) &gt; 1 else name\nif recursive:\nyield from c.iter_tree(\nwith_suffix, yield_self=False, level=level, count=count\n)\nif assign_names:\nc.dynamic_name, c.count = with_suffix, count\nyield c\nlevel -= 1\nif yield_self:\nif assign_names:\nself.dynamic_name, self.count = name, 0\nyield self\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem.NestedItem.row","title":"<code>row() -&gt; int</code>","text":"<p>Return row number.</p> <p>returns row position of item inside parent`s children returns 0 if no parent available</p> <p>Returns:</p> Type Description <code>int</code> <p>row number</p> Source code in <code>prettyqt\\custom_models\\nesteditem.py</code> <pre><code>def row(self) -&gt; int:\n\"\"\"Return row number.\n    returns row position of item inside parent`s children\n    returns 0 if no parent available\n    Returns:\n        row number\n    \"\"\"\nreturn self.parent.children.index(self) if self.parent else 0\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.NestedModel","title":"<code>NestedModel</code>","text":"<p>         Bases: <code>custom_models.ListMixin</code>, <code>custom_models.ModelMixin</code>, <code>core.AbstractItemModel</code></p> Source code in <code>prettyqt\\custom_models\\nestedmodel.py</code> <pre><code>class NestedModel(  # type: ignore\ncustom_models.ListMixin, custom_models.ModelMixin, core.AbstractItemModel\n):\nDEFAULT_FLAGS = (\nconstants.DRAG_ENABLED  # type: ignore\n| constants.IS_ENABLED\n| constants.IS_SELECTABLE\n)\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.root = Root()\nself.items = self.root.children\ndef flags(self, index=None):\nindex = index or core.ModelIndex()\nif not index.isValid():\nreturn constants.NO_FLAGS\nif index.column() in self.SET_DATA:\nreturn self.DEFAULT_FLAGS | constants.IS_EDITABLE\nreturn self.DEFAULT_FLAGS\ndef rowCount(self, parent=None) -&gt; int:\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nreturn (\nlen(parent.internalPointer().children)\nif parent.isValid()\nelse len(self.items)\n)\ndef index(self, row, column, parent=None):\nparent = parent or core.ModelIndex()\nif not self.hasIndex(row, column, parent):\nreturn core.ModelIndex()\nparent_item = parent.internalPointer()\nif not parent_item:\nparent_item = self.root\nreturn self.createIndex(row, column, parent_item.children[row])\ndef parent(self, index: core.ModelIndex | None = None) -&gt; core.ModelIndex:\n# hacky way to let the case without any arguments get through.\n# not really nice, a proper dispatch library would be better.\n# functools.singledispatchmethod doesnt work here.\nif index is None:\nreturn super().parent()\nif not index.isValid():\nreturn core.ModelIndex()\nif item := index.internalPointer():\nreturn (\ncore.ModelIndex()\nif item.parent in [self.root, None]\nelse self.createIndex(item.parent.row(), 0, item.parent)\n)\nelse:\nreturn core.ModelIndex()\ndef data_by_index(self, index):\nreturn index.internalPointer()\ndef json(self, root=None) -&gt; dict:\n\"\"\"Serialise model as JSON-compliant dictionary.\n        Arguments:\n            root (JsonTreeItem, optional): Serialise from here\n                defaults to the the top-level item\n        Returns:\n            model as dict\n        \"\"\"\nroot = root or self.root\nreturn root.as_json()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.json","title":"<code>json(root = None) -&gt; dict</code>","text":"<p>Serialise model as JSON-compliant dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>JsonTreeItem</code> <p>Serialise from here defaults to the the top-level item</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>model as dict</p> Source code in <code>prettyqt\\custom_models\\nestedmodel.py</code> <pre><code>def json(self, root=None) -&gt; dict:\n\"\"\"Serialise model as JSON-compliant dictionary.\n    Arguments:\n        root (JsonTreeItem, optional): Serialise from here\n            defaults to the the top-level item\n    Returns:\n        model as dict\n    \"\"\"\nroot = root or self.root\nreturn root.as_json()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ParentClassTreeModel","title":"<code>ParentClassTreeModel</code>","text":"<p>         Bases: <code>BaseClassTreeModel</code></p> <p>Model to display the parentclass tree of a python class.</p> Source code in <code>prettyqt\\custom_models\\classtreemodel.py</code> <pre><code>class ParentClassTreeModel(BaseClassTreeModel):\n\"\"\"Model to display the parentclass tree of a python class.\"\"\"\ndef __init__(self, *args, **kwargs):\nself._show_mro = False\nsuper().__init__(*args, **kwargs)\n@classmethod\ndef supports(cls, instance) -&gt; bool:\nreturn isinstance(instance, type)\ndef _fetch_object_children(self, item: treeitem.TreeItem) -&gt; list[treeitem.TreeItem]:\nif self._show_mro:\nreturn [treeitem.TreeItem(obj=i) for i in item.obj.mro()[1:]]\nelse:\nreturn [treeitem.TreeItem(obj=i) for i in item.obj.__bases__]\ndef _has_children(self, item: treeitem.TreeItem) -&gt; bool:\nif item.obj is None:\nreturn False\nreturn len(item.obj.__bases__) &gt; 0\ndef set_show_mro(self, show: bool):\nself._show_mro = show\ndef get_show_mro(self) -&gt; bool:\nreturn self._show_mro\nshow_mro = core.Property(bool, get_show_mro, set_show_mro)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ProxyMapper","title":"<code>ProxyMapper</code>","text":"<p>         Bases: <code>core.Object</code></p> <p>Class to map indexes / ItemSelections from one proxy to another.</p> Also handles cases like <p>Root model     |</p> <pre><code>       shared proxy\n       /                      Proxy_1_1     Proxy_2_1\n      |            |\n    Proxy_1_2     Proxy_2_2\n</code></pre> <p>When mapping from 1_2 to 2_2, it will find the closest parent (\"shared proxy\" here), use mapToSource / mapSelectionFromSource until it gets there, and then mapFromSource / mapSelectionFromSource to get down to 2_2.</p> Source code in <code>prettyqt\\custom_models\\proxymapper.py</code> <pre><code>class ProxyMapper(core.Object):\n\"\"\"Class to map indexes / ItemSelections from one proxy to another.\n    Also handles cases like:\n                Root model\n                    |\n               shared proxy\n               /          \\\n            Proxy_1_1     Proxy_2_1\n              |            |\n            Proxy_1_2     Proxy_2_2\n    When mapping from 1_2 to 2_2, it will find the closest parent (\"shared proxy\" here),\n    use mapToSource / mapSelectionFromSource until it gets there,\n    and then mapFromSource / mapSelectionFromSource to get down to 2_2.\n    \"\"\"\ndef __init__(\nself,\nproxy_1: core.QAbstractItemModel,\nproxy_2: core.QAbstractItemModel,\n**kwargs,\n):\nsuper().__init__(**kwargs)\nproxychain_1 = self.get_proxy_chain(proxy_1)\nproxychain_2 = self.get_proxy_chain(proxy_2)\ncommon_list = [c for c in proxychain_1 if c in proxychain_2]\nif not common_list:\nraise RuntimeError(\"No common source model\")\ncommon_source = common_list[0]\nlogger.debug(f\"Common source: {common_source}\")\nself._proxychain_1 = proxychain_1[: proxychain_1.index(common_source)]\nself._proxychain_2 = proxychain_2[: proxychain_2.index(common_source)]\nlogger.debug(f\"Chain 1:{self._proxychain_1}\")\nlogger.debug(f\"Chain 2:{self._proxychain_2}\")\n@staticmethod\ndef get_proxy_chain(model) -&gt; list[core.QAbstractItemModel]:\nmodels = [model]\nwhile isinstance(model, core.QAbstractProxyModel):\nmodel = model.sourceModel()\nmodels.append(model)\nreturn models\ndef map_index_from_one_to_two(self, index: core.ModelIndex) -&gt; core.ModelIndex:\nfor model in self._proxychain_1:\nlogger.debug(f\"mapping from {model!r} to {model.sourceModel()!r}\")\nindex = model.mapToSource(index)\nfor model in reversed(self._proxychain_2):\nlogger.debug(f\"mapping from {model.sourceModel()!r} to {model!r}\")\nindex = model.mapFromSource(index)\nreturn index\ndef map_index_from_two_to_one(self, index: core.ModelIndex) -&gt; core.ModelIndex:\nfor model in self._proxychain_2:\nlogger.debug(f\"mapping from {model!r} to {model.sourceModel()!r}\")\nindex = model.mapToSource(index)\nfor model in reversed(self._proxychain_1):\nlogger.debug(f\"mapping from {model.sourceModel()!r} to {model!r}\")\nindex = model.mapFromSource(index)\nreturn index\ndef map_selection_from_one_to_two(\nself, selection: core.QItemSelection\n) -&gt; core.QItemSelection:\nfor model in self._proxychain_1:\nlogger.debug(f\"mapping from {model!r} to {model.sourceModel()!r}\")\nselection = model.mapSelectionToSource(selection)\nfor model in reversed(self._proxychain_2):\nlogger.debug(f\"mapping from {model.sourceModel()!r} to {model!r}\")\nselection = model.mapSelectionFromSource(selection)\nreturn selection\ndef map_selection_from_two_to_one(\nself, selection: core.QItemSelection\n) -&gt; core.QItemSelection:\nfor model in self._proxychain_2:\nlogger.debug(f\"mapping from {model!r} to {model.sourceModel()!r}\")\nselection = model.mapSelectionToSource(selection)\nfor model in reversed(self._proxychain_1):\nlogger.debug(f\"mapping from {model.sourceModel()!r} to {model!r}\")\nselection = model.mapSelectionFromSource(selection)\nreturn selection\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.PythonObjectTreeModel","title":"<code>PythonObjectTreeModel</code>","text":"<p>         Bases: <code>custom_models.ColumnItemModel</code></p> Source code in <code>prettyqt\\custom_models\\pythonobjecttreemodel.py</code> <pre><code>class PythonObjectTreeModel(custom_models.ColumnItemModel):\nTreeItem = PythonObjectTreeItem\nCOLUMNS = [\nNameColumn,\nDescriptionColumn,\nPathColumn,\nStrColumn,\nReprColumn,\nLengthColumn,\nTypeColumn,\nClassColumn,\nIdColumn,\nAttributeColumn,\nIsCallableColumn,\nIsRoutineColumn,\nIsBuiltinColumn,\nPredicateColumn,\nModuleColumn,\n# FileColumn,\n# SourceFileColumn,\n]\ndef __init__(self, obj, parent=None):\nsuper().__init__(obj, self.COLUMNS, show_root=False, parent=parent)\n@classmethod\ndef supports(cls, instance) -&gt; bool:\nreturn True\ndef get_path_for_index(self, index: core.ModelIndex) -&gt; str:\n\"\"\"Get the path for the object referenced by index.\n        Example: An.example = {\"a\": [b, c, {\"d\": e}]}\n                 -&gt; path of e: An.example[\"a\"][2][\"d\"]\n        \"\"\"\n# TODO: not used yet, better rework ColumnItemModel first\ntreeitem = index.data(constants.USER_ROLE)\nif treeitem is None:\nreturn\nprev_data = treeitem.obj\npieces = []\nwhile (index := index.parent()).isValid():\ntreeitem = index.data(constants.USER_ROLE)\ndata = treeitem.obj\nmatch data:\ncase Mapping():\nfor k, v in data.items():\nif v is prev_data:\npieces.append(f\"[{k!r}]\")\nbreak\ncase Iterable():\npieces.append(f\"[{data.index(prev_data)}]\")\ncase _:\n# or should this be treeitem.obj_name?\npieces.append(f\".{prev_data.__name__}\")\nprev_data = data\npieces.append(treeitem.obj_name)\nlogger.info(pieces)\nreturn \"\".join(reversed(pieces))\ndef _fetch_object_children(\nself, treeitem: treeitem.TreeItem\n) -&gt; list[PythonObjectTreeItem]:\n\"\"\"Fetch the children of a Python object.\n        Returns: list of PythonObjectTreeItems\n        \"\"\"\nobj_children = []\npath_strings = []\nobj = treeitem.obj\nobj_path = treeitem.obj_path\nif isinstance(obj, list | tuple | set | frozenset):\nobj_children = [(str(i), j) for i, j in sorted(enumerate(obj))]\npath_strings = [\nf\"{obj_path}[{i[0]}]\" if obj_path else i[0] for i in obj_children\n]\nelif isinstance(obj, Mapping):\nobj_children = list(obj.items())\npath_strings = [\nf\"{obj_path}[{item[0]!r}]\" if obj_path else item[0]\nfor item in obj_children\n]\nis_attr_list = [False] * len(obj_children)\n# Object attributes\nfor attr_name, attr_value in sorted(inspect.getmembers(obj)):\nobj_children.append((attr_name, attr_value))\npath_strings.append(f\"{obj_path}.{attr_name}\" if obj_path else attr_name)\nis_attr_list.append(True)\nreturn [\nPythonObjectTreeItem(obj=val, name=name, obj_path=p, is_attribute=is_attr)\nfor (name, val), p, is_attr in zip(obj_children, path_strings, is_attr_list)\n]\ndef _aux_refresh_tree(self, tree_index: core.ModelIndex):\n\"\"\"Refresh the tree nodes recursively, auxiliary.\n        If the underlying Python object has been changed, we don't want to delete the old\n        tree model and create a new one from scratch because this loses all information\n        about which nodes are fetched and expanded. Instead the old tree model is updated.\n        Using the difflib from the standard library it is determined for a parent node\n        which child nodes should be added or removed. This is done based on the node names\n        only, not on the node contents (the underlying Python objects). Testing the\n        underlying nodes for equality is potentially slow. It is faster to let the\n        refreshNode function emit the dataChanged signal for all cells.\n        \"\"\"\ntree_item = self.data_by_index(tree_index)\nif not tree_item.children_fetched:\nreturn None\nold_items = tree_item.child_items\nnew_items = self._fetch_object_children(tree_item)\nold_item_names = [(item.obj_name, item.is_attribute) for item in old_items]\nnew_item_names = [(item.obj_name, item.is_attribute) for item in new_items]\nseq_matcher = SequenceMatcher(\nisjunk=None, a=old_item_names, b=new_item_names, autojunk=False\n)\nopcodes = seq_matcher.get_opcodes()\nlogger.debug(\"(reversed) opcodes: %s\", list(reversed(opcodes)))\nfor tag, i1, i2, j1, j2 in reversed(opcodes):\nmatch tag:\ncase \"equal\":\n# when node names are equal is aux_refresh_tree called recursively.\nfor old_row, new_row in zip(range(i1, i2), range(j1, j2)):\nold_items[old_row].obj = new_items[new_row].obj\nchild_index = self.index(old_row, 0, parent=tree_index)\nself._aux_refresh_tree(child_index)\ncase \"replace\":\n# Remove the old item and insert the new. The old item may have child\n# nodes which indices must be removed by Qt, otherwise it crashes.\nfirst = i1  # row number of first that will be removed\nlast = i1 + i2 - 1  # row number of last element after insertion\nwith self.remove_rows(first, last, tree_index):\ndel tree_item.child_items[i1:i2]\nfirst = i1  # row number of first element after insertion\nlast = i1 + j2 - j1 - 1  # row number of last element after insertion\nwith self.insert_rows(first, last, tree_index):\ntree_item.insert_children(i1, new_items[j1:j2])\ncase \"delete\":\nfirst = i1  # row number of first that will be removed\nlast = i1 + i2 - 1  # row number of last element after insertion\nwith self.remove_rows(first, last, tree_index):\ndel tree_item.child_items[i1:i2]\ncase \"insert\":\nfirst = i1\nlast = i1 + j2 - j1 - 1\nwith self.insert_rows(first, last, tree_index):\ntree_item.insert_children(i1, new_items[j1:j2])\ncase _:\nraise ValueError(f\"Invalid tag: {tag}\")\ndef refresh_tree(self):\nif self._show_root:\nindex = self.createIndex(0, 0, self.inspected_item)\nelse:\nindex = self.root_index()\n\"\"\"Refresh the tree model from the underlying root object.\"\"\"\nself._aux_refresh_tree(index)\n# Emit the dataChanged signal for all cells. This is faster than checking which\n# nodes have changed, which may be slow for some underlying Python objects.\nself.update_all()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.pythonobjecttreemodel.PythonObjectTreeModel.get_path_for_index","title":"<code>get_path_for_index(index: core.ModelIndex) -&gt; str</code>","text":"<p>Get the path for the object referenced by index.</p> An.example = {\"a\": [b, c, {\"d\": e}]} <p>-&gt; path of e: An.example\"a\"[\"d\"]</p> Source code in <code>prettyqt\\custom_models\\pythonobjecttreemodel.py</code> <pre><code>def get_path_for_index(self, index: core.ModelIndex) -&gt; str:\n\"\"\"Get the path for the object referenced by index.\n    Example: An.example = {\"a\": [b, c, {\"d\": e}]}\n             -&gt; path of e: An.example[\"a\"][2][\"d\"]\n    \"\"\"\n# TODO: not used yet, better rework ColumnItemModel first\ntreeitem = index.data(constants.USER_ROLE)\nif treeitem is None:\nreturn\nprev_data = treeitem.obj\npieces = []\nwhile (index := index.parent()).isValid():\ntreeitem = index.data(constants.USER_ROLE)\ndata = treeitem.obj\nmatch data:\ncase Mapping():\nfor k, v in data.items():\nif v is prev_data:\npieces.append(f\"[{k!r}]\")\nbreak\ncase Iterable():\npieces.append(f\"[{data.index(prev_data)}]\")\ncase _:\n# or should this be treeitem.obj_name?\npieces.append(f\".{prev_data.__name__}\")\nprev_data = data\npieces.append(treeitem.obj_name)\nlogger.info(pieces)\nreturn \"\".join(reversed(pieces))\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.RegexMatchesModel","title":"<code>RegexMatchesModel</code>","text":"<p>         Bases: <code>core.AbstractTableModel</code></p> Source code in <code>prettyqt\\custom_models\\regexmatchesmodel.py</code> <pre><code>class RegexMatchesModel(core.AbstractTableModel):\nHEADER = [\"Start\", \"End\", \"Value\", \"Groups\"]\ndef __init__(self, matches: list | None = None, **kwargs):\nsuper().__init__(**kwargs)\nself.matches = matches or []\n@classmethod\ndef supports(cls, instance) -&gt; bool:\nmatch instance:\ncase (re.Match(), *_):\nreturn True\ncase _:\nreturn False\ndef columnCount(self, parent=None):\nreturn len(self.HEADER)\ndef headerData(  # type: ignore\nself,\nsection: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n) -&gt; str | None:\nmatch orientation, role:\ncase constants.HORIZONTAL, constants.DISPLAY_ROLE:\nreturn self.HEADER[section]\ndef data(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nif not index.isValid():\nreturn None\nitem = self.matches[index.row()]\nmatch role, index.column():\ncase constants.DISPLAY_ROLE, 0:\nreturn str(item.span()[0])\ncase constants.DISPLAY_ROLE, 1:\nreturn str(item.span()[1])\ncase constants.DISPLAY_ROLE, 2:\nreturn repr(item.group())\ncase constants.DISPLAY_ROLE, 3:\nreturn str(len(item.groups()))\ncase constants.USER_ROLE, _:\nreturn item.span()\ndef rowCount(self, parent=None):\n\"\"\"Override for AbstractitemModel base method.\"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nreturn 0 if parent.isValid() else len(self.matches)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.rowCount","title":"<code>rowCount(parent = None)</code>","text":"<p>Override for AbstractitemModel base method.</p> Source code in <code>prettyqt\\custom_models\\regexmatchesmodel.py</code> <pre><code>def rowCount(self, parent=None):\n\"\"\"Override for AbstractitemModel base method.\"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nreturn 0 if parent.isValid() else len(self.matches)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.SliceFilterProxyModel","title":"<code>SliceFilterProxyModel</code>","text":"<p>         Bases: <code>custom_models.SliceIdentityProxyModel</code></p> <p>Proxy to filter a model based on slices.</p> <p>Since slicing operations are bijective, we can do this without looping all rows / columns. Thus, this should perform much better than a SortFilterProxyModel with a column filter. (O(1) instead of O(n))</p> Source code in <code>prettyqt\\custom_models\\slicefilterproxymodel.py</code> <pre><code>class SliceFilterProxyModel(custom_models.SliceIdentityProxyModel):\n\"\"\"Proxy to filter a model based on slices.\n    Since slicing operations are bijective, we can do this without\n    looping all rows / columns. Thus, this should perform much better than a\n    SortFilterProxyModel with a column filter. (O(1) instead of O(n))\n    \"\"\"\nID = \"slice_filter\"\ndef rowCount(self, index: core.ModelIndex | None = None):\nrowcount = super().rowCount()\n# TODO: not sure if slice.stop = 0 is covered correctly?\nreturn min(rowcount, self.get_row_slice().stop or rowcount)\ndef columnCount(self, index: core.ModelIndex | None = None):\ncolcount = super().columnCount()\nreturn min(colcount, self.get_column_slice().stop or colcount)\ndef headerData(\nself,\nsection: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\n\"\"\"Map header data to proxy by calculating position from slice values.\n        source pos = slice start + proxy pos * slice step)\n        \"\"\"\nis_horizontal = orientation == constants.HORIZONTAL\nrng = self.get_column_range() if is_horizontal else self.get_row_range()\npos = rng.start + section * rng.step\nreturn super().headerData(pos, orientation, role)\ndef index(\nself, row: int, column: int, parent: core.ModelIndex | None = None\n) -&gt; core.ModelIndex:\nparent = parent or core.ModelIndex()\nsource = self.sourceModel()\nif row &lt; 0 or column &lt; 0 or source is None:\nreturn core.ModelIndex()\nsource_parent = self.mapToSource(parent)\ncol_range = self.get_column_range()\nrow_range = self.get_row_range()\ncol_pos = col_range.start + (col_range.step * column)\nrow_pos = row_range.start + (row_range.step * row)\nsource_index = source.index(row_pos, col_pos, source_parent)\nreturn self.mapFromSource(source_index)\ndef mapToSource(self, proxy_idx: core.ModelIndex) -&gt; core.ModelIndex:\n\"\"\"Map index to source by calculating position from slice values.\n        source pos = slice start + proxy pos * slice step)\n        \"\"\"\nsource = self.sourceModel()\nif source is None or not proxy_idx.isValid():\nreturn core.ModelIndex()\ncol_range = self.get_column_range()\nrow_range = self.get_row_range()\ncol_pos = col_range.start + (col_range.step * proxy_idx.column())\nrow_pos = row_range.start + (row_range.step * proxy_idx.row())\nreturn source.index(row_pos, col_pos)\ndef mapFromSource(self, source_index: core.ModelIndex) -&gt; core.ModelIndex:\n\"\"\"Map index from source by calculating position based on slice values.\n        proxy pos = source pos - slice start / slice step\n        \"\"\"\nif self.sourceModel() is None or not source_index.isValid():\nreturn core.ModelIndex()\nrow_pos = self.position_in_row_slice(source_index.row())\ncol_pos = self.position_in_column_slice(source_index.column())\nreturn self.createIndex(row_pos, col_pos, source_index.internalPointer())\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.slicefilterproxymodel.SliceFilterProxyModel.headerData","title":"<code>headerData(section: int, orientation: constants.Orientation, role: constants.ItemDataRole = constants.DISPLAY_ROLE)</code>","text":"<p>Map header data to proxy by calculating position from slice values.</p> <p>source pos = slice start + proxy pos * slice step)</p> Source code in <code>prettyqt\\custom_models\\slicefilterproxymodel.py</code> <pre><code>def headerData(\nself,\nsection: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\n\"\"\"Map header data to proxy by calculating position from slice values.\n    source pos = slice start + proxy pos * slice step)\n    \"\"\"\nis_horizontal = orientation == constants.HORIZONTAL\nrng = self.get_column_range() if is_horizontal else self.get_row_range()\npos = rng.start + section * rng.step\nreturn super().headerData(pos, orientation, role)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.slicefilterproxymodel.SliceFilterProxyModel.mapFromSource","title":"<code>mapFromSource(source_index: core.ModelIndex) -&gt; core.ModelIndex</code>","text":"<p>Map index from source by calculating position based on slice values.</p> <p>proxy pos = source pos - slice start / slice step</p> Source code in <code>prettyqt\\custom_models\\slicefilterproxymodel.py</code> <pre><code>def mapFromSource(self, source_index: core.ModelIndex) -&gt; core.ModelIndex:\n\"\"\"Map index from source by calculating position based on slice values.\n    proxy pos = source pos - slice start / slice step\n    \"\"\"\nif self.sourceModel() is None or not source_index.isValid():\nreturn core.ModelIndex()\nrow_pos = self.position_in_row_slice(source_index.row())\ncol_pos = self.position_in_column_slice(source_index.column())\nreturn self.createIndex(row_pos, col_pos, source_index.internalPointer())\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.slicefilterproxymodel.SliceFilterProxyModel.mapToSource","title":"<code>mapToSource(proxy_idx: core.ModelIndex) -&gt; core.ModelIndex</code>","text":"<p>Map index to source by calculating position from slice values.</p> <p>source pos = slice start + proxy pos * slice step)</p> Source code in <code>prettyqt\\custom_models\\slicefilterproxymodel.py</code> <pre><code>def mapToSource(self, proxy_idx: core.ModelIndex) -&gt; core.ModelIndex:\n\"\"\"Map index to source by calculating position from slice values.\n    source pos = slice start + proxy pos * slice step)\n    \"\"\"\nsource = self.sourceModel()\nif source is None or not proxy_idx.isValid():\nreturn core.ModelIndex()\ncol_range = self.get_column_range()\nrow_range = self.get_row_range()\ncol_pos = col_range.start + (col_range.step * proxy_idx.column())\nrow_pos = row_range.start + (row_range.step * proxy_idx.row())\nreturn source.index(row_pos, col_pos)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.SliceIdentityProxyModel","title":"<code>SliceIdentityProxyModel</code>","text":"<p>         Bases: <code>core.IdentityProxyModel</code></p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>class SliceIdentityProxyModel(core.IdentityProxyModel):\ndef __init__(self, indexer=None, **kwargs):\nsuper().__init__(**kwargs)\nself._indexer = (slice(None), slice(None))\nself.set_indexer(indexer)\ndef indexer_contains(self, index: core.ModelIndex) -&gt; bool:\n\"\"\"Check whether given ModelIndex is included in our Indexer.\"\"\"\ncol_slice = self.update_slice_boundaries(self.get_column_slice(), typ=\"column\")\nrow_slice = self.update_slice_boundaries(self.get_row_slice(), typ=\"row\")\n# logger.info(f\"{col_slice=} {row_slice=}\")\nto_check = (col_slice, row_slice)  # instead of _indexer, for negative indexes.\nreturn helpers.is_position_in_index(index.column(), index.row(), to_check)\ndef update_slice_boundaries(self, sl: slice, typ=\"row\") -&gt; slice:\n\"\"\"Update slice boundaries by resolving negative indexes.\"\"\"\n# Not sure yet whats the best approach here and which cases I should support...\nsource = self.sourceModel()\ncount = source.rowCount() if typ == \"row\" else source.columnCount()\n# if sl.end is larger than count, clip it (or perhaps throw exception?)\n# if sl.stop is not None and sl.stop &gt;= count:\n#     sl = slice(sl.start, count, sl.step)\n# resolve negative start value\nif sl.start is not None and sl.start &lt; 0:\nstart = count + sl.start\nend = count + sl.stop\n# end = start + (sl.stop - sl.start)\nif start &lt; 0:\nraise IndexError(sl.start)\nsl = slice(start, end, sl.step)\n# if sl.stop is not None and sl.stop &lt; 0:\n#     stop = source.columnCount() + sl.stop\n#     if stop &lt; 0:\n#         raise IndexError(sl.stop)\n#     sl = slice(sl.start, stop, sl.step)\nreturn sl\ndef set_indexer(self, indexer):\n\"\"\"Takes basically anything which is common to use for __getitem__.\"\"\"\nmatch indexer:\ncase None:\nself._indexer = (slice(None), slice(None))\ncase int() as column:\nself.set_column_slice(column)\ncase slice() as col_slice:\nself._indexer = (col_slice, slice(None))\ncase col_slice, row_slice:\nself.set_column_slice(col_slice)\nself.set_row_slice(row_slice)\ncase _:\nraise TypeError(indexer)\ndef get_column_slice(self) -&gt; slice:\nmatch self._indexer:\ncase None | (None, _):\nreturn slice(None)\ncase (slice() as col_slice, _):\nreturn col_slice\ncase _:\nraise TypeError(self._indexer)\ndef get_row_slice(self) -&gt; slice:\nmatch self._indexer:\ncase None | (_, None):\nreturn slice(None)\ncase (_, slice() as row_slice):\nreturn row_slice\ncase _:\nraise TypeError(self._indexer)\ndef set_column_slice(\nself, value: slice | int | None | tuple[int | None, int | None, int | None]\n):\n\"\"\"Throw anything at this method in order to set the column slice.\"\"\"\nmatch value:\ncase slice() as col_slice:\nsl = col_slice\ncase int() as col:\nsl = slice(col, col + 1)\ncase None:\nsl = slice(None)\ncase (\nint() | None as start,\nint() | None as stop,\nint() | None as step,\n):\nsl = slice(start, stop, step)\ncase _:\nraise TypeError(value)\nself._indexer = (sl, self.get_row_slice())\ndef set_row_slice(\nself, value: slice | int | None | tuple[int | None, int | None, int | None]\n):\n\"\"\"Throw anything at this method in order to set the row slice.\"\"\"\nmatch value:\ncase slice() as row_slice:\nsl = row_slice\ncase int() as row:\nsl = slice(row, row + 1)\ncase None:\nsl = slice(None)\ncase (\nint() | None as start,\nint() | None as stop,\nint() | None as step,\n):\nsl = slice(start, stop, step)\ncase _:\nraise TypeError(value)\nself._indexer = (self.get_row_slice(), sl)\ndef get_row_range(self) -&gt; range:\n\"\"\"Return a range for the row slice with valid start / stop / step values.\"\"\"\nsl = self.get_row_slice()\nrow_count = self.sourceModel().rowCount()\nreturn range(sl.start or 0, sl.stop or row_count, sl.step or 1)\ndef get_column_range(self) -&gt; range:\n\"\"\"Return a range for the column slice with valid start / stop / step values.\"\"\"\nsl = self.get_column_slice()\ncol_count = self.sourceModel().columnCount()\nreturn range(sl.start or 0, sl.stop or col_count, sl.step or 1)\ndef position_in_column_slice(self, col: int) -&gt; int:\n\"\"\"Can be interpreted as slice.index(col) if slice would be a list.\"\"\"\nsl = self.get_column_slice()\nreturn int((col - (sl.start or 0)) / (sl.step or 1))\ndef position_in_row_slice(self, row: int) -&gt; int:\n\"\"\"Can be interpreted as slice.index(row) if slice would be a list.\"\"\"\nsl = self.get_row_slice()\nreturn int((row - (sl.start or 0)) / (sl.step or 1))\n# The Qt typesystems dont like slices (or ranges / tuples)\n# seems what works is to throw tuples at a QtProperty declared as list.\n# otherwise change this to list getters/setters.\ndef get_column_tuple(self) -&gt; tuple[int | None, int | None, int | None]:\n\"\"\"Get tuple representation of the column slice.\"\"\"\nsl = self.get_column_slice()\nreturn (sl.start, sl.stop, sl.step)\ndef get_row_tuple(self) -&gt; tuple[int | None, int | None, int | None]:\n\"\"\"Get tuple representation of the row slice.\"\"\"\nsl = self.get_row_slice()\nreturn (sl.start, sl.stop, sl.step)\ncolumn_slice = core.Property(list, get_column_tuple, set_column_slice)\nrow_slice = core.Property(list, get_row_tuple, set_column_slice)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.sliceidentityproxymodel.SliceIdentityProxyModel.get_column_range","title":"<code>get_column_range() -&gt; range</code>","text":"<p>Return a range for the column slice with valid start / stop / step values.</p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>def get_column_range(self) -&gt; range:\n\"\"\"Return a range for the column slice with valid start / stop / step values.\"\"\"\nsl = self.get_column_slice()\ncol_count = self.sourceModel().columnCount()\nreturn range(sl.start or 0, sl.stop or col_count, sl.step or 1)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.sliceidentityproxymodel.SliceIdentityProxyModel.get_column_tuple","title":"<code>get_column_tuple() -&gt; tuple[int | None, int | None, int | None]</code>","text":"<p>Get tuple representation of the column slice.</p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>def get_column_tuple(self) -&gt; tuple[int | None, int | None, int | None]:\n\"\"\"Get tuple representation of the column slice.\"\"\"\nsl = self.get_column_slice()\nreturn (sl.start, sl.stop, sl.step)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.sliceidentityproxymodel.SliceIdentityProxyModel.get_row_range","title":"<code>get_row_range() -&gt; range</code>","text":"<p>Return a range for the row slice with valid start / stop / step values.</p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>def get_row_range(self) -&gt; range:\n\"\"\"Return a range for the row slice with valid start / stop / step values.\"\"\"\nsl = self.get_row_slice()\nrow_count = self.sourceModel().rowCount()\nreturn range(sl.start or 0, sl.stop or row_count, sl.step or 1)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.sliceidentityproxymodel.SliceIdentityProxyModel.get_row_tuple","title":"<code>get_row_tuple() -&gt; tuple[int | None, int | None, int | None]</code>","text":"<p>Get tuple representation of the row slice.</p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>def get_row_tuple(self) -&gt; tuple[int | None, int | None, int | None]:\n\"\"\"Get tuple representation of the row slice.\"\"\"\nsl = self.get_row_slice()\nreturn (sl.start, sl.stop, sl.step)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.sliceidentityproxymodel.SliceIdentityProxyModel.indexer_contains","title":"<code>indexer_contains(index: core.ModelIndex) -&gt; bool</code>","text":"<p>Check whether given ModelIndex is included in our Indexer.</p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>def indexer_contains(self, index: core.ModelIndex) -&gt; bool:\n\"\"\"Check whether given ModelIndex is included in our Indexer.\"\"\"\ncol_slice = self.update_slice_boundaries(self.get_column_slice(), typ=\"column\")\nrow_slice = self.update_slice_boundaries(self.get_row_slice(), typ=\"row\")\n# logger.info(f\"{col_slice=} {row_slice=}\")\nto_check = (col_slice, row_slice)  # instead of _indexer, for negative indexes.\nreturn helpers.is_position_in_index(index.column(), index.row(), to_check)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.sliceidentityproxymodel.SliceIdentityProxyModel.position_in_column_slice","title":"<code>position_in_column_slice(col: int) -&gt; int</code>","text":"<p>Can be interpreted as slice.index(col) if slice would be a list.</p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>def position_in_column_slice(self, col: int) -&gt; int:\n\"\"\"Can be interpreted as slice.index(col) if slice would be a list.\"\"\"\nsl = self.get_column_slice()\nreturn int((col - (sl.start or 0)) / (sl.step or 1))\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.sliceidentityproxymodel.SliceIdentityProxyModel.position_in_row_slice","title":"<code>position_in_row_slice(row: int) -&gt; int</code>","text":"<p>Can be interpreted as slice.index(row) if slice would be a list.</p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>def position_in_row_slice(self, row: int) -&gt; int:\n\"\"\"Can be interpreted as slice.index(row) if slice would be a list.\"\"\"\nsl = self.get_row_slice()\nreturn int((row - (sl.start or 0)) / (sl.step or 1))\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.sliceidentityproxymodel.SliceIdentityProxyModel.set_column_slice","title":"<code>set_column_slice(value: slice | int | None | tuple[int | None, int | None, int | None])</code>","text":"<p>Throw anything at this method in order to set the column slice.</p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>def set_column_slice(\nself, value: slice | int | None | tuple[int | None, int | None, int | None]\n):\n\"\"\"Throw anything at this method in order to set the column slice.\"\"\"\nmatch value:\ncase slice() as col_slice:\nsl = col_slice\ncase int() as col:\nsl = slice(col, col + 1)\ncase None:\nsl = slice(None)\ncase (\nint() | None as start,\nint() | None as stop,\nint() | None as step,\n):\nsl = slice(start, stop, step)\ncase _:\nraise TypeError(value)\nself._indexer = (sl, self.get_row_slice())\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.sliceidentityproxymodel.SliceIdentityProxyModel.set_indexer","title":"<code>set_indexer(indexer)</code>","text":"<p>Takes basically anything which is common to use for getitem.</p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>def set_indexer(self, indexer):\n\"\"\"Takes basically anything which is common to use for __getitem__.\"\"\"\nmatch indexer:\ncase None:\nself._indexer = (slice(None), slice(None))\ncase int() as column:\nself.set_column_slice(column)\ncase slice() as col_slice:\nself._indexer = (col_slice, slice(None))\ncase col_slice, row_slice:\nself.set_column_slice(col_slice)\nself.set_row_slice(row_slice)\ncase _:\nraise TypeError(indexer)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.sliceidentityproxymodel.SliceIdentityProxyModel.set_row_slice","title":"<code>set_row_slice(value: slice | int | None | tuple[int | None, int | None, int | None])</code>","text":"<p>Throw anything at this method in order to set the row slice.</p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>def set_row_slice(\nself, value: slice | int | None | tuple[int | None, int | None, int | None]\n):\n\"\"\"Throw anything at this method in order to set the row slice.\"\"\"\nmatch value:\ncase slice() as row_slice:\nsl = row_slice\ncase int() as row:\nsl = slice(row, row + 1)\ncase None:\nsl = slice(None)\ncase (\nint() | None as start,\nint() | None as stop,\nint() | None as step,\n):\nsl = slice(start, stop, step)\ncase _:\nraise TypeError(value)\nself._indexer = (self.get_row_slice(), sl)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.sliceidentityproxymodel.SliceIdentityProxyModel.update_slice_boundaries","title":"<code>update_slice_boundaries(sl: slice, typ: slice = 'row') -&gt; slice</code>","text":"<p>Update slice boundaries by resolving negative indexes.</p> Source code in <code>prettyqt\\custom_models\\sliceidentityproxymodel.py</code> <pre><code>def update_slice_boundaries(self, sl: slice, typ=\"row\") -&gt; slice:\n\"\"\"Update slice boundaries by resolving negative indexes.\"\"\"\n# Not sure yet whats the best approach here and which cases I should support...\nsource = self.sourceModel()\ncount = source.rowCount() if typ == \"row\" else source.columnCount()\n# if sl.end is larger than count, clip it (or perhaps throw exception?)\n# if sl.stop is not None and sl.stop &gt;= count:\n#     sl = slice(sl.start, count, sl.step)\n# resolve negative start value\nif sl.start is not None and sl.start &lt; 0:\nstart = count + sl.start\nend = count + sl.stop\n# end = start + (sl.stop - sl.start)\nif start &lt; 0:\nraise IndexError(sl.start)\nsl = slice(start, end, sl.step)\n# if sl.stop is not None and sl.stop &lt; 0:\n#     stop = source.columnCount() + sl.stop\n#     if stop &lt; 0:\n#         raise IndexError(sl.stop)\n#     sl = slice(sl.start, stop, sl.step)\nreturn sl\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.SliceValueTransformationProxyModel","title":"<code>SliceValueTransformationProxyModel</code>","text":"<p>         Bases: <code>custom_models.SliceIdentityProxyModel</code></p> <p>A simple transformation proxy model with settable transformers.</p> Example <p>proxy = SliceValueTransformationProxyModel() proxy.add_transformer(lambda value: value &lt; 1)</p> Source code in <code>prettyqt\\custom_models\\slicevaluetransformationproxymodel.py</code> <pre><code>class SliceValueTransformationProxyModel(custom_models.SliceIdentityProxyModel):\n\"\"\"A simple transformation proxy model with settable transformers.\n    Example:\n        &gt;&gt;&gt; proxy = SliceValueTransformationProxyModel()\n        &gt;&gt;&gt; proxy.add_transformer(lambda value: value &lt; 1)\n    \"\"\"\nID = \"value_transformation\"\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself._transformers: list[Transformer] = []\ndef clear(self):\nself._transformers = []\ndef add_transformer(\nself,\nfn: Callable[[Any], Any],\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\nselector: Callable[[Any], bool] | None = None,\nselector_role: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\ntr = Transformer(\nfn=fn,\nrole=role,\nselector=selector,\nselector_role=selector_role,\n)\nself._transformers.append(tr)\ndef data(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nval = super().data(index, role)\nfor t in self._transformers:\nif self.indexer_contains(index) and t.role == role:\nselector_val = super().data(index, t.selector_role)\nif t.selector is None or t.selector(selector_val):\nval = t.fn(selector_val)\nreturn val\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.SubClassTreeModel","title":"<code>SubClassTreeModel</code>","text":"<p>         Bases: <code>BaseClassTreeModel</code></p> <p>Model to display the subclass tree of a python class.</p> Source code in <code>prettyqt\\custom_models\\classtreemodel.py</code> <pre><code>class SubClassTreeModel(BaseClassTreeModel):\n\"\"\"Model to display the subclass tree of a python class.\"\"\"\n@classmethod\ndef supports(cls, instance) -&gt; bool:\nreturn isinstance(instance, type)\ndef _fetch_object_children(self, item: treeitem.TreeItem) -&gt; list[treeitem.TreeItem]:\nreturn [treeitem.TreeItem(obj=i) for i in item.obj.__subclasses__()]\ndef _has_children(self, item: treeitem.TreeItem) -&gt; bool:\nif item.obj is None:\nreturn False\nreturn len(item.obj.__subclasses__()) &gt; 0\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.TableToListProxyModel","title":"<code>TableToListProxyModel</code>","text":"<p>         Bases: <code>core.IdentityProxyModel</code></p> <p>Model to flatten a table to a list.</p> Source code in <code>prettyqt\\custom_models\\tabletolistproxymodel.py</code> <pre><code>class TableToListProxyModel(core.IdentityProxyModel):\n\"\"\"Model to flatten a table to a list.\"\"\"\nID = \"table_to_list\"\ndef __init__(self, *args, header_title: str = \"\", **kwargs):\nsuper().__init__(*args, **kwargs)\nself._header_title = header_title\ndef columnCount(self, parent: core.ModelIndex | None = None) -&gt; int:\nparent = parent or core.ModelIndex()\nreturn 0 if self.sourceModel() is None else 1\ndef headerData(\nself,\nsection: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n) -&gt; str | None:\nmatch orientation, role:\ncase constants.HORIZONTAL, constants.DISPLAY_ROLE:\nreturn self._header_title or None\ncase constants.VERTICAL, constants.DISPLAY_ROLE:\ncol_section = section % super().columnCount()\nrow_section = section // super().rowCount()\npre = super().headerData(col_section, constants.HORIZONTAL, role)\npost = super().headerData(row_section, constants.VERTICAL, role)\npre_str = col_section if pre is None else pre\npost_str = row_section if post is None else post\nreturn f\"{pre_str} - {post_str}\"\nreturn None\ndef rowCount(self, parent: core.ModelIndex | None = None) -&gt; int:\nparent = parent or core.ModelIndex()\nsource = self.sourceModel()\nreturn 0 if source is None else source.rowCount() * source.columnCount()\ndef index(\nself, row: int, column: int, parent: core.ModelIndex | None = None\n) -&gt; core.ModelIndex:\nparent = parent or core.ModelIndex()\nsource = self.sourceModel()\nif row &lt; 0 or column &lt; 0 or source is None:\nreturn core.ModelIndex()\nsource_parent = self.mapToSource(parent)\ncolcount = source.columnCount()\nsource_index = source.index(row // colcount, row % colcount, source_parent)\nreturn self.mapFromSource(source_index)\ndef mapToSource(self, proxy_idx: core.ModelIndex) -&gt; core.ModelIndex:\nsource = self.sourceModel()\nif source is None or not proxy_idx.isValid():\nreturn core.ModelIndex()\nrow = proxy_idx.row()\ncolcount = source.columnCount()\nreturn source.index(row // colcount, row % colcount)\ndef mapFromSource(self, source_index: core.ModelIndex) -&gt; core.ModelIndex:\nsource = self.sourceModel()\nif source is None or not source_index.isValid():\nreturn core.ModelIndex()\nr = source_index.row() * source.columnCount() + source_index.column()\nreturn self.createIndex(r, 0, source_index.internalPointer())\ndef set_header_title(self, title: str):\nself._header_title = title\nself.headerDataChanged.emit(constants.HORIZONTAL, 0, 0)\ndef get_header_title(self) -&gt; str:\nreturn self._header_title\nheader_title = core.Property(str, get_header_title, set_header_title)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.TreeModel","title":"<code>TreeModel</code>","text":"<p>         Bases: <code>core.AbstractItemModel</code></p> Source code in <code>prettyqt\\custom_models\\treemodel.py</code> <pre><code>class TreeModel(core.AbstractItemModel):\nTreeItem = treeitem.TreeItem\ndef __init__(self, obj=None, show_root: bool = True, **kwargs):\nsuper().__init__(**kwargs)\nself._root_item = treeitem.TreeItem(obj=obj)\nself._show_root = show_root\nself.set_root_item(obj)\n@property\ndef show_root(self) -&gt; bool:\n\"\"\"Return True if the inspected node is visible.\n        In that case an invisible root node has been added.\n        \"\"\"\nreturn self._show_root\ndef set_root_item(self, obj):\nif self._show_root:\nself._root_item = self.TreeItem(obj=None)\nself._root_item.children_fetched = True\nself.inspected_item = self.TreeItem(obj=obj)\nself._root_item.append_child(self.inspected_item)\n# root_index = self.index(0, 0)\n# self.fetchMore(self.index(0, 0, root_index))\nelse:\n# The root itself will be invisible\nself._root_item = self.TreeItem(obj=obj)\nself.inspected_item = self._root_item\nroot_index = self.index(0, 0)\nself.fetchMore(root_index)\n@property\ndef root_item(self) -&gt; treeitem.TreeItem:\nreturn self._root_item\ndef data_by_index(self, index: core.ModelIndex) -&gt; treeitem.TreeItem:\nreturn index.internalPointer() if index.isValid() else self.root_item\ndef index(\nself, row: int, column: int, parent: core.ModelIndex | None = None\n) -&gt; core.ModelIndex:\nparent = parent or core.ModelIndex()\nparent_item = self.data_by_index(parent)\nif not self.hasIndex(row, column, parent):\nreturn core.ModelIndex()\nif child_item := parent_item.child(row):  # isnt this always true?\nreturn self.createIndex(row, column, child_item)\nreturn core.ModelIndex()\ndef parent(self, index: core.ModelIndex | None = None) -&gt; core.ModelIndex:\n# hacky way to let the case without any arguments get through.\n# not really nice, a proper dispatch library would be better.\n# functools.singledispatchmethod doesnt work here.\nif index is None:\nreturn super().parent()\nif not index.isValid():\nreturn core.ModelIndex()\nchild_item = self.data_by_index(index)\nparent_item = child_item.parent()\nif parent_item is None or parent_item == self.root_item:\nreturn core.ModelIndex()\nreturn self.createIndex(parent_item.row(), 0, parent_item)\ndef rowCount(self, parent: core.ModelIndex | None = None):\nparent = parent or core.ModelIndex()\nreturn 0 if parent.column() &gt; 0 else self.data_by_index(parent).child_count()\ndef hasChildren(self, parent: core.ModelIndex | None = None):\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\ntreeitem = self.data_by_index(parent)\nif self._show_root and treeitem == self._root_item:\nreturn True\nreturn self._has_children(treeitem)\ndef canFetchMore(self, parent: core.ModelIndex | None = None):\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nelse:\nreturn not self.data_by_index(parent).children_fetched\ndef fetchMore(self, parent: core.ModelIndex | None = None):\n\"\"\"Fetch the children given the model index of a parent node.\n        Adds the children to the parent.\n        \"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn\nparent_item = self.data_by_index(parent)\nif parent_item.children_fetched:\nreturn\ntree_items = self._fetch_object_children(parent_item)\nwith self.insert_rows(0, len(tree_items) - 1, parent):\nfor tree_item in tree_items:\nparent_item.append_child(tree_item)\nparent_item.children_fetched = True\ndef _fetch_object_children(self, treeitem) -&gt; list[treeitem.TreeItem]:\nreturn treeitem.child_items\ndef _has_children(self, treeitem) -&gt; bool:\nreturn treeitem.has_children\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.treemodel.TreeModel.show_root","title":"<code>show_root: bool</code>  <code>property</code>","text":"<p>Return True if the inspected node is visible.</p> <p>In that case an invisible root node has been added.</p>"},{"location":"api/custom_models.html#prettyqt.custom_models.treemodel.TreeModel.fetchMore","title":"<code>fetchMore(parent: core.ModelIndex | None = None)</code>","text":"<p>Fetch the children given the model index of a parent node.</p> <p>Adds the children to the parent.</p> Source code in <code>prettyqt\\custom_models\\treemodel.py</code> <pre><code>def fetchMore(self, parent: core.ModelIndex | None = None):\n\"\"\"Fetch the children given the model index of a parent node.\n    Adds the children to the parent.\n    \"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn\nparent_item = self.data_by_index(parent)\nif parent_item.children_fetched:\nreturn\ntree_items = self._fetch_object_children(parent_item)\nwith self.insert_rows(0, len(tree_items) - 1, parent):\nfor tree_item in tree_items:\nparent_item.append_child(tree_item)\nparent_item.children_fetched = True\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ValueFilterProxyModel","title":"<code>ValueFilterProxyModel</code>","text":"<p>         Bases: <code>core.SortFilterProxyModel</code></p> <p>Compared to QSortFilterProxyModel, this one also works with non-str values.</p> Source code in <code>prettyqt\\custom_models\\valuefilterproxymodel.py</code> <pre><code>class ValueFilterProxyModel(core.SortFilterProxyModel):\n\"\"\"Compared to QSortFilterProxyModel, this one also works with non-str values.\"\"\"\nID = \"value_filter\"\ndef __init__(self, filter_value=None, **kwargs):\nself._filter_value = filter_value\nsuper().__init__(**kwargs)\ndef __repr__(self):\nreturn get_repr(self, self._filter_value)\ndef filterAcceptsRow(self, source_row: int, parent: core.ModelIndex) -&gt; bool:\nif self._filter_value is None:\nreturn True\ncolumn = self.filterKeyColumn()\nrole = self.filterRole()\nsource_model = self.sourceModel()\nidx = source_model.index(source_row, column, parent)\nvalue = source_model.data(idx, role)\nreturn value == self._filter_value\ndef set_filter_value(self, value):\nself._filter_value = value\nself.invalidateRowsFilter()\ndef get_filter_value(self):\nreturn self._filter_value\nfilter_value = core.Property(object, get_filter_value, set_filter_value, user=True)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.WidgetHierarchyModel","title":"<code>WidgetHierarchyModel</code>","text":"<p>         Bases: <code>custom_models.TreeModel</code></p> Source code in <code>prettyqt\\custom_models\\widgethierarchymodel.py</code> <pre><code>class WidgetHierarchyModel(custom_models.TreeModel):\nclass Roles(enum.IntEnum):\n\"\"\"Custom roles.\"\"\"\nWidgetRole = constants.USER_ROLE + 23324\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.BaseClass = QtWidgets.QWidget\nself.props = core.MetaObject(self.BaseClass.staticMetaObject).get_properties(\nonly_stored=True\n)\nself.props.insert(0, FakeClassNameProp())\nself.props.insert(1, FakeLayoutProp())\nself.props.insert(1, FakeUserPropertyNameProp())\nself.props.insert(1, FakeUserPropertyValueProp())\n# self.props.sort(key=lambda x: x.get_name())\n@classmethod\ndef supports(cls, instance) -&gt; bool:\nreturn isinstance(instance, QtWidgets.QWidget)\ndef columnCount(self, parent=None):\nreturn len(self.props)\ndef headerData(\nself,\nsection: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n) -&gt; str | None:\nmatch orientation, role, section:\ncase constants.HORIZONTAL, constants.DISPLAY_ROLE, _:\nreturn self.props[section].get_name()\ndef data(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nif not index.isValid():\nreturn None\nwidget = self.data_by_index(index).obj\nmatch role, index.column():\ncase constants.DISPLAY_ROLE | constants.EDIT_ROLE, _:\nprop = self.props[index.column()]\nreturn prop.read(widget)\ncase constants.USER_ROLE, _:\nprop = self.props[index.column()]\nreturn prop.read(widget)\ncase self.Roles.WidgetRole, _:\nreturn widget\ncase constants.SIZE_HINT_ROLE, _:\nreturn QtCore.QSize(250, 35)\ndef setData(\nself,\nindex: core.ModelIndex,\nvalue,\nrole: constants.ItemDataRole = constants.EDIT_ROLE,\n) -&gt; bool:\nprop = self.props[index.column()]\nwidget = self.data_by_index(index).obj\nmatch role:\ncase constants.USER_ROLE:\nwith self.change_layout():\nprop.write(widget, value)\n# self.update_row(index.row())\nreturn True\nreturn False\ndef flags(self, index: core.ModelIndex) -&gt; constants.ItemFlag:\nprop = self.props[index.column()]\nif prop.isWritable():\nreturn (\nsuper().flags(index)\n| constants.IS_EDITABLE\n| constants.IS_ENABLED\n| constants.IS_SELECTABLE\n)\nreturn super().flags(index)\ndef _fetch_object_children(self, item: treeitem.TreeItem) -&gt; list[treeitem.TreeItem]:\nreturn [\ntreeitem.TreeItem(obj=i)\nfor i in item.obj.findChildren(\nself.BaseClass, None, constants.FindChildOption.FindDirectChildrenOnly\n)\n]\ndef _has_children(self, item: treeitem.TreeItem) -&gt; bool:\nreturn bool(\nitem.obj.findChildren(\nself.BaseClass, None, constants.FindChildOption.FindDirectChildrenOnly\n)\n)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.widgethierarchymodel.WidgetHierarchyModel.Roles","title":"<code>Roles</code>","text":"<p>         Bases: <code>enum.IntEnum</code></p> <p>Custom roles.</p> Source code in <code>prettyqt\\custom_models\\widgethierarchymodel.py</code> <pre><code>class Roles(enum.IntEnum):\n\"\"\"Custom roles.\"\"\"\nWidgetRole = constants.USER_ROLE + 23324\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.WidgetPropertiesModel","title":"<code>WidgetPropertiesModel</code>","text":"<p>         Bases: <code>core.AbstractTableModel</code></p> Source code in <code>prettyqt\\custom_models\\widgetpropertiesmodel.py</code> <pre><code>class WidgetPropertiesModel(core.AbstractTableModel):\nHEADER = [\n\"Property name\",\n\"Value\",\n\"Type\",\n\"User property\",\n\"Readable\",\n\"Writable\",\n\"Resettable\",\n\"Bindable\",\n\"Designable\",\n\"Constant\",\n\"Final\",\n\"Required\",\n\"Valid\",\n\"Stored\",\n\"Notifier\",\n\"User Type\",\n# \"Enumerator\",\n]\ndef __init__(self, widget: QtWidgets.QWidget, **kwargs):\nself._widget = None\nself._metaobj = None\nself.event_catcher = None\nself._handles: list[core.QMetaObject.Connection] = []\nsuper().__init__(**kwargs)\nself.set_widget(widget)\n@classmethod\ndef supports(cls, instance) -&gt; bool:\nreturn isinstance(instance, QtWidgets.QWidget)\ndef set_widget(self, widget):\nif self._widget:\nself.unhook()\nself._widget = widget\nself._metaobj = core.MetaObject(self._widget.metaObject())\nself.event_catcher = eventfilters.EventCatcher(\ninclude=[\"resize\", \"move\"], parent=self._widget\n)\nlogger.debug(f\"Connected {self._widget!r} to {self!r}\")\nself.event_catcher.caught.connect(self.force_layoutchange)\nself._widget.installEventFilter(self.event_catcher)\nself._handles = self._metaobj.connect_signals(\nself._widget, self.force_layoutchange, only_notifiers=True\n)\nself.update_all()\ndef unhook(self):\nfor handle in self._handles:\nself._widget.disconnect(handle)\nself._widget.removeEventFilter(self.event_catcher)\nlogger.debug(f\"Disconnected {self._widget!r} from {self!r}\")\ndef columnCount(self, parent=None) -&gt; int:\nreturn len(self.HEADER)\ndef headerData(\nself,\nsection: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n) -&gt; str | None:\nmatch orientation, role:\ncase constants.HORIZONTAL, constants.DISPLAY_ROLE:\nreturn self.HEADER[section]\ncase constants.VERTICAL, constants.DISPLAY_ROLE:\nprop = self._metaobj.get_property(section)\nreturn prop.propertyIndex()\ndef data(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nif not index.isValid():\nreturn None\nprop = self._metaobj.get_property(index.row())\nmatch role, index.column():\ncase constants.BACKGROUND_ROLE, _:\nreturn QtGui.QColor(\"lightblue\") if prop.isUser() else None\ncase constants.DISPLAY_ROLE, 0:\nreturn prop.name()\ncase constants.FONT_ROLE, 0:\nfont = QtGui.QFont()\nfont.setBold(True)\nreturn font\ncase constants.DISPLAY_ROLE | constants.EDIT_ROLE, 1:\nreturn prop.read(self._widget)\ncase constants.DISPLAY_ROLE, 2:\nreturn prop.get_meta_type().get_name()\ncase constants.FONT_ROLE, 2:\nfont = QtGui.QFont()\nfont.setItalic(True)\nreturn font\ncase constants.CHECKSTATE_ROLE, 3:\nreturn prop.isUser()\ncase constants.CHECKSTATE_ROLE, 4:\nreturn prop.isReadable()\ncase constants.CHECKSTATE_ROLE, 5:\nreturn prop.isWritable()\ncase constants.CHECKSTATE_ROLE, 6:\nreturn prop.isResettable()\ncase constants.CHECKSTATE_ROLE, 7:\nreturn prop.isBindable()\ncase constants.CHECKSTATE_ROLE, 8:\nreturn prop.isDesignable()\ncase constants.CHECKSTATE_ROLE, 9:\nreturn prop.isConstant()\ncase constants.CHECKSTATE_ROLE, 10:\nreturn prop.isFinal()\ncase constants.CHECKSTATE_ROLE, 11:\nreturn prop.isRequired()\ncase constants.CHECKSTATE_ROLE, 12:\nreturn prop.isValid()\ncase constants.CHECKSTATE_ROLE, 13:\nreturn prop.isStored()\ncase constants.DISPLAY_ROLE, 14:\nnotifier = prop.get_notify_signal()\nreturn \"\" if notifier is None else notifier.get_name()\ncase constants.DISPLAY_ROLE, 15:\nreturn prop.userType()\n# case constants.DISPLAY_ROLE, 8:\n#     enumerator = prop.get_enumerator()\n#     return \"\" if enumerator is None else enumerator.get_name()\ncase constants.USER_ROLE, _:\nreturn prop.read(self._widget)\ndef setData(\nself,\nindex: core.ModelIndex,\nvalue,\nrole: constants.ItemDataRole = constants.EDIT_ROLE,\n) -&gt; bool:\nif not index.isValid():\nreturn None\nprop = self._metaobj.get_property(index.row())\nmatch role, index.column():\ncase constants.USER_ROLE, _:\nprop.write(self._widget, value)\nself.update_row(index.row())\nreturn True\nreturn False\ndef rowCount(self, parent: QtCore.QModelIndex | None = None) -&gt; int:\n\"\"\"Override for AbstractitemModel base method.\"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nreturn 0 if parent.isValid() else self._metaobj.propertyCount()\ndef flags(self, index: QtCore.QModelIndex) -&gt; constants.ItemFlag:\nprop = self._metaobj.get_property(index.row())\nif index.column() == 1 and prop.isWritable():\nreturn super().flags(index) | constants.IS_EDITABLE\nreturn super().flags(index)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.widgetpropertiesmodel.WidgetPropertiesModel.rowCount","title":"<code>rowCount(parent: QtCore.QModelIndex | None = None) -&gt; int</code>","text":"<p>Override for AbstractitemModel base method.</p> Source code in <code>prettyqt\\custom_models\\widgetpropertiesmodel.py</code> <pre><code>def rowCount(self, parent: QtCore.QModelIndex | None = None) -&gt; int:\n\"\"\"Override for AbstractitemModel base method.\"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nreturn 0 if parent.isValid() else self._metaobj.propertyCount()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.WidgetsDetailsModel","title":"<code>WidgetsDetailsModel</code>","text":"<p>         Bases: <code>core.AbstractTableModel</code></p> Source code in <code>prettyqt\\custom_models\\widgetsdetailsmodel.py</code> <pre><code>class WidgetsDetailsModel(core.AbstractTableModel):\ndef __init__(self, items: Sequence[QtWidgets.QWidget], **kwargs):\nsuper().__init__(**kwargs)\nself.items = items\ncommon_ancestor = helpers.find_common_ancestor([type(i) for i in self.items])\nlogger.debug(f\"{type(self).__name__}: found common ancestor {common_ancestor}\")\nself.props = core.MetaObject(common_ancestor.staticMetaObject).get_properties(\nonly_stored=True\n)\nself.props.sort(key=lambda x: x.get_name())\n@classmethod\ndef supports(cls, instance) -&gt; bool:\nmatch instance:\ncase (QtWidgets.QWidget(), *_):\nreturn True\ncase _:\nreturn False\ndef columnCount(self, parent=None):\nreturn len(self.props)\ndef headerData(\nself,\nsection: int,\norientation: constants.Orientation,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n) -&gt; str | None:\nmatch orientation, role, section:\ncase constants.VERTICAL, constants.DISPLAY_ROLE, _:\nwidget = self.items[section]\nreturn repr(widget)\ncase constants.HORIZONTAL, constants.DISPLAY_ROLE, _:\nreturn self.props[section].get_name()\ndef data(\nself,\nindex: core.ModelIndex,\nrole: constants.ItemDataRole = constants.DISPLAY_ROLE,\n):\nif not index.isValid():\nreturn None\nprop = self.props[index.column()]\nwidget = self.items[index.row()]\nmatch role:\ncase constants.DISPLAY_ROLE | constants.EDIT_ROLE:\nreturn prop.read(widget)\ncase constants.USER_ROLE:\nreturn prop.read(widget)\ndef setData(\nself,\nindex: core.ModelIndex,\nvalue,\nrole: constants.ItemDataRole = constants.EDIT_ROLE,\n) -&gt; bool:\nprop = self.props[index.column()]\nwidget = self.items[index.row()]\nmatch role:\ncase constants.USER_ROLE:\nwith self.reset_model():\nprop.write(widget, value)\n# self.update_row(index.row())\nreturn True\nreturn False\ndef rowCount(self, parent=None):\n\"\"\"Override for AbstractitemModel base method.\"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nreturn 0 if parent.isValid() else len(self.items)\ndef flags(self, index: core.ModelIndex) -&gt; constants.ItemFlag:\nprop = self.props[index.column()]\nif prop.isWritable():\nreturn super().flags(index) | constants.IS_EDITABLE\nreturn super().flags(index)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.widgetsdetailsmodel.WidgetsDetailsModel.rowCount","title":"<code>rowCount(parent = None)</code>","text":"<p>Override for AbstractitemModel base method.</p> Source code in <code>prettyqt\\custom_models\\widgetsdetailsmodel.py</code> <pre><code>def rowCount(self, parent=None):\n\"\"\"Override for AbstractitemModel base method.\"\"\"\nparent = parent or core.ModelIndex()\nif parent.column() &gt; 0:\nreturn 0\nreturn 0 if parent.isValid() else len(self.items)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.XmlModel","title":"<code>XmlModel</code>","text":"<p>         Bases: <code>custom_models.ColumnItemModel</code></p> <p>Semi-lazy xml model. Fetches all direct child items when accessing index.</p> Source code in <code>prettyqt\\custom_models\\xmlmodel.py</code> <pre><code>class XmlModel(custom_models.ColumnItemModel):\n\"\"\"Semi-lazy xml model. Fetches all direct child items when accessing index.\"\"\"\nCOLUMNS = [TagColumn, TextColumn, TailColumn, AttributeColumn]\ndef __init__(\nself,\nobj: str | datatypes.IsTreeIterator | ET.ElementTree,\nshow_root: bool = True,\n**kwargs,\n):\nmatch obj:\ncase str():\ncontext = ET.iterparse(io.StringIO(obj), events=(\"start\",))\n_, root = next(context)\ncase datatypes.IsTreeIterator():\n_, root = next(obj)\ncase ET.ElementTree():\nxml_str = ET.tostring(xml._root, encoding=\"unicode\")\ncontext = ET.iterparse(io.StringIO(xml_str), events=(\"start\",))\n_, root = next(context)\ncase _ if importlib.util.find_spec(\"lxml\"):\nfrom lxml import etree\nif isinstance(obj, etree._Element):\nroot = obj\nelse:\nraise TypeError(obj)\ncase _:\nraise TypeError(obj)\nsuper().__init__(\nobj=root,\ncolumns=self.COLUMNS,\nshow_root=show_root,\n**kwargs,\n)\n@classmethod\ndef supports(cls, instance) -&gt; bool:\nmatch instance:\ncase datatypes.IsTreeIterator() | ET.ElementTree():\nreturn True\ncase _ if importlib.util.find_spec(\"lxml\"):\nfrom lxml import etree\nreturn isinstance(instance, etree._Element)\ncase _:\nreturn False\ndef _has_children(self, item: treeitem.TreeItem) -&gt; bool:\nreturn bool(item.obj)\ndef _fetch_object_children(self, item: treeitem.TreeItem) -&gt; list[treeitem.TreeItem]:\nreturn [treeitem.TreeItem(obj=i) for i in item.obj]\n</code></pre>"},{"location":"api/custom_validators.html","title":"custom_validators module","text":"<p>Custom_validators module.</p> <p>Contains custom validators</p>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.ScientificFloatValidator","title":"<code>ScientificFloatValidator</code>","text":"<p>         Bases: <code>BaseScientificValidator</code></p> <p>This is a validator for float values represented as strings in scientific notation.</p> <p>(i.e. \"1.35e-9\", \".24E+8\", \"14e3\" etc.) Also supports SI unit prefix like 'M', 'n' etc.</p> Source code in <code>prettyqt\\custom_validators\\scientificvalidators.py</code> <pre><code>class ScientificFloatValidator(BaseScientificValidator):\n\"\"\"This is a validator for float values represented as strings in scientific notation.\n    (i.e. \"1.35e-9\", \".24E+8\", \"14e3\" etc.)\n    Also supports SI unit prefix like 'M', 'n' etc.\n    \"\"\"\nID = \"scientific_float\"\nre_pattern = re.compile(\nr\"(\\s*([+-]?)(\\d+\\.\\d+|\\.\\d+|\\d+\\.?)([eE][+-]?\\d+)?\\s?([YZEPTGMkm\u00b5unpfazy]?)\\s*)\",\nflags=re.UNICODE,\n)\ngroup_map = {\"match\": 0, \"sign\": 1, \"mantissa\": 2, \"exponent\": 3, \"si\": 4}\ndef validate(self, string, position):\nif (\nstring.strip() in \"+.-.\"\nor string.strip() in list(\"YZEPTGMkm\u00b5unpfazy\")\nor re.match(r\"[+-]?(in$|i$)\", string, re.IGNORECASE)\n):\nreturn self.State.Intermediate, string, position\n# Accept input of [+-]inf. Not case sensitive.\nif re.match(r\"[+-]?\\binf$\", string, re.IGNORECASE):\nreturn self.State.Acceptable, string.lower(), position\nif not (group_dict := self.get_group_dict(string)):\nreturn (\n(self.State.Intermediate, string, position)\nif string[position - 1] in \"eE-+.\" and \"i\" not in string.lower()\nelse (self.State.Invalid, \"\", position)\n)\nif group_dict[\"match\"] == string:\nreturn self.State.Acceptable, string, position\nif string.count(\".\") &gt; 1:\nreturn self.State.Invalid, group_dict[\"match\"], position\nposition = min(position, len(string))\nif string[position - 1] in \"eE-+\" and \"i\" not in string.lower():\nreturn self.State.Intermediate, string, position\nreturn self.State.Invalid, group_dict[\"match\"], position\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.ScientificIntegerValidator","title":"<code>ScientificIntegerValidator</code>","text":"<p>         Bases: <code>BaseScientificValidator</code></p> <p>This is a validator for int values represented as strings in scientific notation.</p> <p>Using engineering notation only positive exponents are allowed (i.e. \"1e9\", \"2E+8\", \"14e+3\" etc.) Also supports non-fractional SI unit prefix like 'M', 'k' etc.</p> Source code in <code>prettyqt\\custom_validators\\scientificvalidators.py</code> <pre><code>class ScientificIntegerValidator(BaseScientificValidator):\n\"\"\"This is a validator for int values represented as strings in scientific notation.\n    Using engineering notation only positive exponents are allowed\n    (i.e. \"1e9\", \"2E+8\", \"14e+3\" etc.)\n    Also supports non-fractional SI unit prefix like 'M', 'k' etc.\n    \"\"\"\nID = \"scientific_integer\"\nre_pattern = re.compile(\nr\"(([+-]?\\d+)([eE]\\+?\\d+)?\\s?([YZEPTGMk])?\\s*)\", flags=re.UNICODE\n)\ngroup_map = {\"match\": 0, \"mantissa\": 1, \"exponent\": 2, \"si\": 3}\ndef validate(self, string, position):\nif not string.strip() or string.strip() in list(\"YZEPTGMk\"):\nreturn self.State.Intermediate, string, position\nif not (group_dict := self.get_group_dict(string)):\nreturn self.State.Invalid, \"\", position\nif group_dict[\"match\"] == string:\nreturn self.State.Acceptable, string, position\nposition = min(position, len(string))\nif string[position - 1] in \"eE-+\":\nreturn self.State.Intermediate, string, position\nreturn self.State.Invalid, group_dict[\"match\"], position\n</code></pre>"},{"location":"api/custom_widgets.html","title":"custom_widgets module","text":"<p>Module containing custom widget classes.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.BorderLayout","title":"<code>BorderLayout</code>","text":"<p>         Bases: <code>widgets.Layout</code></p> Source code in <code>prettyqt\\custom_widgets\\borderlayout.py</code> <pre><code>class BorderLayout(widgets.Layout):\nID = \"border\"\nclass Position(enum.IntEnum):\n\"\"\"Item position.\"\"\"\nWest = 0\nNorth = 1\nSouth = 2\nEast = 3\nCenter = 4\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.items: list[ItemWrapper] = []\ndef addItem(self, item: QtWidgets.QWidgetItem):\nself.add_widgetitem(item, BorderLayout.Position.West)\ndef addWidget(\nself,\nwidget: QtWidgets.QWidget,\nposition: Position | None = None,\n):\nposition = BorderLayout.Position.West if position is None else position\nself.add_widgetitem(widgets.WidgetItem(widget), position)\ndef expandingDirections(self) -&gt; constants.Orientation:\nreturn constants.HORIZONTAL | constants.VERTICAL\ndef hasHeightForWidth(self) -&gt; bool:\nreturn False\ndef count(self) -&gt; int:\nreturn len(self.items)\ndef itemAt(self, index: int) -&gt; QtWidgets.QWidgetItem | None:\nreturn self.items[index].item if index &lt; len(self.items) else None\ndef minimumSize(self):\nreturn self.calculate_size(\"minimum\")\ndef setGeometry(self, rect: QtCore.QRect):\ncenter = None\neast_width = 0\nwest_width = 0\nnorth_height = 0\nsouth_height = 0\nsuper().setGeometry(rect)\nfor wrapper in self.items:\nitem = wrapper.item\nmatch wrapper.position:\ncase BorderLayout.Position.North:\nh = item.sizeHint().height()\ngeom = core.Rect(rect.x(), north_height, rect.width(), h)\nitem.setGeometry(geom)\nnorth_height += item.geometry().height() + self.spacing()\ncase BorderLayout.Position.South:\ngeo = item.geometry()\nh = item.sizeHint().height()\ngeom = core.Rect(geo.x(), geo.y(), rect.width(), h)\nitem.setGeometry(geom)\nsouth_height += item.geometry().height() + self.spacing()\ny = rect.y() + rect.height() - south_height + self.spacing()\ngeo = item.geometry()\ngeom = core.Rect(rect.x(), y, geo.width(), geo.height())\nitem.setGeometry(geom)\ncase BorderLayout.Position.Center:\ncenter = wrapper\ncenter_height = rect.height() - north_height - south_height\nfor wrapper in self.items:\nitem = wrapper.item\nmatch wrapper.position:\ncase BorderLayout.Position.West:\nx = rect.x() + west_width\nw = item.sizeHint().width()\ngeom = core.Rect(x, north_height, w, center_height)\nitem.setGeometry(geom)\nwest_width += item.geometry().width() + self.spacing()\ncase BorderLayout.Position.East:\ngeo = item.geometry()\nw = item.sizeHint().width()\ngeom = core.Rect(geo.x(), geo.y(), w, center_height)\nitem.setGeometry(geom)\neast_width += item.geometry().width() + self.spacing()\nx = rect.x() + rect.width() - east_width + self.spacing()\ngeom = core.Rect(x, north_height, geo.width(), geo.height())\nitem.setGeometry(geom)\nif center:\nw = rect.width() - east_width - west_width\nrect = core.Rect(west_width, north_height, w, center_height)\ncenter.item.setGeometry(rect)\ndef sizeHint(self) -&gt; core.Size:\nreturn self.calculate_size(\"size_hint\")\ndef takeAt(self, index: int) -&gt; QtWidgets.QWidgetItem | None:\nif 0 &lt;= index &lt; len(self.items):\nlayout_struct = self.items.pop(index)\nreturn layout_struct.item\nreturn None\ndef add_widgetitem(self, item: QtWidgets.QWidgetItem, position: Position):\nself.items.append(ItemWrapper(item, position))\ndef calculate_size(self, size_type: Literal[\"minimum\", \"size_hint\"]) -&gt; core.Size:\ntotal_size = core.Size()\nPos = BorderLayout.Position\nfor wrapper in self.items:\nitem_size = (\nwrapper.item.minimumSize()\nif size_type == \"minimum\"\nelse wrapper.item.sizeHint()\n)\nif wrapper.position in (Pos.North, Pos.South, Pos.Center):\ntotal_size.setHeight(total_size.height() + item_size.height())\nif wrapper.position in (Pos.West, Pos.East, Pos.Center):\ntotal_size.setWidth(total_size.width() + item_size.width())\nreturn total_size\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.Position","title":"<code>Position</code>","text":"<p>         Bases: <code>enum.IntEnum</code></p> <p>Item position.</p> Source code in <code>prettyqt\\custom_widgets\\borderlayout.py</code> <pre><code>class Position(enum.IntEnum):\n\"\"\"Item position.\"\"\"\nWest = 0\nNorth = 1\nSouth = 2\nEast = 3\nCenter = 4\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.ClickableLabel","title":"<code>ClickableLabel</code>","text":"<p>         Bases: <code>widgets.Label</code></p> <p>A label widget that behaves like a button.</p> Source code in <code>prettyqt\\custom_widgets\\clickablelabel.py</code> <pre><code>class ClickableLabel(widgets.Label):\n\"\"\"A label widget that behaves like a button.\"\"\"\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs, alignment=\"left\")\nself.setFont(QtGui.QFont(\"Arial\"))\nself.setFixedHeight(24)\nself.set_size_policy(\"minimum\", \"expanding\")\ndef setText(self, text: str):\nfm = gui.FontMetrics(self.font())\nwidth = fm.horizontalAdvance(text)\nself.setFixedWidth(width + 18)\nsuper().setText(text)\ndef enterEvent(self, event: QtCore.QEvent):\nwith self.edit_font() as font:\nfont.setUnderline(True)\nself.set_cursor(\"pointing_hand\")\nself.update()\nreturn super().enterEvent(event)\ndef leaveEvent(self, event: QtCore.QEvent):\nwith self.edit_font() as font:\nfont.setUnderline(False)\nself.unsetCursor()\nreturn super().leaveEvent(event)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.CommandPalette","title":"<code>CommandPalette</code>","text":"<p>         Bases: <code>widgets.Widget</code></p> <p>A Qt command palette widget.</p> Source code in <code>prettyqt\\custom_widgets\\commandpalette.py</code> <pre><code>class CommandPalette(widgets.Widget):\n\"\"\"A Qt command palette widget.\"\"\"\ndef __init__(self, parent: QtWidgets.QWidget | None = None):\nsuper().__init__(parent=parent)\nself.setWindowFlags(\nconstants.WindowType.WindowStaysOnTopHint\n| constants.WindowType.FramelessWindowHint\n# | constants.WindowType.ToolTip\n)\nself.set_focus_policy(\"strong\")\nself.setMinimumWidth(700)\nself._line = widgets.LineEdit()\nself.setFocusProxy(self._line)\nself._table = CommandTable()\n# self._line.value_changed.connect(self._table.select_first_row)\nself._line.value_changed.connect(self._table._proxy.set_search_term)\nlayout = self.set_layout(\"vertical\")\nlayout.addWidget(self._line)\nlayout.addWidget(self._table)\nself.add_shortcut(\"Ctrl+P\", self.close)\nself._line.installEventFilter(self)\n# self._line.textChanged.connect(self._on_text_changed)\n# self._table.action_clicked.connect(self._on_action_clicked)\n# self._line.editingFinished.connect(self.hide)\ndef eventFilter(self, source: QtCore.QObject, e: QtCore.QEvent) -&gt; bool:\nif source != self._line or e.type() != QtCore.QEvent.Type.KeyPress:\nreturn super().eventFilter(source, e)\nif e.modifiers() in (\nconstants.KeyboardModifier.NoModifier,\nconstants.KeyboardModifier.KeypadModifier,\n):\nmatch e.key():\ncase constants.Key.Key_Escape:\nself.hide()\nreturn True\ncase constants.Key.Key_Return:\nself.hide()\nself._table.execute_focused()\nreturn True\ncase constants.Key.Key_Up:\nself._table.move_row_selection(-1)\nreturn True\ncase constants.Key.Key_Down:\nself._table.move_row_selection(1)\nreturn True\nreturn super().eventFilter(source, e)\ndef populate_from_widget(self, widget: QtWidgets.QWidget):\nself.add_actions(widget.actions())\nif not callable(widget.parent):\nreturn\nwhile widget := widget.parent():\nself.add_actions(widget.actions())\ndef add_path_actions(self, path):\npath = pathlib.Path(path)\nactions = [gui.Action(str(p)) for p in path.rglob(\"*\") if p.is_file()]\nself.add_actions(actions)\ndef match_color(self) -&gt; str:\n\"\"\"The color used for the matched characters.\"\"\"\nreturn self._table.match_color\ndef set_match_color(self, color):\n\"\"\"Set the color used for the matched characters.\"\"\"\nself._table.match_color = colors.get_color(color).name()\ndef install_to(self, parent: widgets.Widget):\nself.setParent(parent, constants.WindowType.SubWindow)\nself.hide()\n# def focusOutEvent(self, a0: QtGui.QFocusEvent) -&gt; None:\n#     self.hide()\n#     return super().focusOutEvent(a0)\ndef add_actions(self, actions: Sequence[QtGui.QAction]):\nself._table._model.add_items(actions)\ndef show(self):\nself._line.setText(\"\")\nself.resize(1000, 300)\nself.position_on(\"screen\")\nsuper().show()\nself.raise_()\nself._line.setFocus()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.commandpalette.CommandPalette.match_color","title":"<code>match_color() -&gt; str</code>","text":"<p>The color used for the matched characters.</p> Source code in <code>prettyqt\\custom_widgets\\commandpalette.py</code> <pre><code>def match_color(self) -&gt; str:\n\"\"\"The color used for the matched characters.\"\"\"\nreturn self._table.match_color\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.commandpalette.CommandPalette.set_match_color","title":"<code>set_match_color(color)</code>","text":"<p>Set the color used for the matched characters.</p> Source code in <code>prettyqt\\custom_widgets\\commandpalette.py</code> <pre><code>def set_match_color(self, color):\n\"\"\"Set the color used for the matched characters.\"\"\"\nself._table.match_color = colors.get_color(color).name()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.CompletionWidget","title":"<code>CompletionWidget</code>","text":"<p>         Bases: <code>widgets.ListWidget</code></p> Source code in <code>prettyqt\\custom_widgets\\completionwidget.py</code> <pre><code>class CompletionWidget(widgets.ListWidget):\ndef __init__(self, textedit: QtWidgets.QTextEdit | QtWidgets.QPlainTextEdit):\nsuper().__init__(parent=textedit)\nself._text_edit = textedit\nself.set_edit_triggers(\"none\")\nself.set_selection_behavior(\"rows\")\nself.set_selection_mode(\"single\")\n# We need Popup style to ensure correct mouse interaction\n# (dialog would dissappear on mouse click with ToolTip style)\nself.setWindowFlags(constants.WindowType.Popup)\nself.setAttribute(constants.WidgetAttribute.WA_StaticContents)\noriginal_policy = self._text_edit.focusPolicy()\nself.set_focus_policy(\"none\")\nself._text_edit.setFocusPolicy(original_policy)\n# Ensure that the text edit keeps focus when widget is displayed.\nself.setFocusProxy(self._text_edit)\nself.set_frame_shadow(\"plain\")\nself.set_frame_shape(\"styled_panel\")\nself.itemActivated.connect(self._complete_current)\ndef eventFilter(self, obj, event):\n\"\"\"Handle mouse input and to auto-hide when losing focus.\"\"\"\nif obj is self and event.type() == QtCore.QEvent.Type.MouseButtonPress:\npos = self.mapToGlobal(event.pos())\ntarget = QtWidgets.QApplication.widgetAt(pos)\nif target and self.isAncestorOf(target) or target is self:\nreturn False\nelse:\nself.cancel_completion()\nreturn super().eventFilter(obj, event)\ndef keyPressEvent(self, event):\nmatch event.key():\ncase (\nconstants.Key.Key_Return | constants.Key.Key_Enter | constants.Key.Key_Tab\n):\nself._complete_current()\ncase constants.Key.Key_Escape:\nself.hide()\ncase (\nconstants.Key.Key_Up\n| constants.Key.Key_Down\n| constants.Key.Key_PageUp\n| constants.Key.Key_PageDown\n| constants.Key.Key_Home\n| constants.Key.Key_End\n):\nreturn super().keyPressEvent(event)\ncase _:\nQtWidgets.QApplication.sendEvent(self._text_edit, event)\n# 'QWidget' interface\ndef hideEvent(self, event):\n\"\"\"Disconnect signal handlers and event filter.\"\"\"\nsuper().hideEvent(event)\nwith contextlib.suppress(TypeError):\nself._text_edit.cursorPositionChanged.disconnect(self._update_current)\nself.removeEventFilter(self)\ndef showEvent(self, event):\n\"\"\"Connect signal handlers and event filter.\"\"\"\nsuper().showEvent(event)\nself._text_edit.cursorPositionChanged.connect(self._update_current)\nself.installEventFilter(self)\n# 'CompletionWidget' interface\ndef show_items(self, cursor, items: Iterable[str], prefix_length: int = 0):\n\"\"\"Show the widget with 'items' at the position specified by 'cursor'.\"\"\"\npoint = self._get_top_left_position(cursor)\nself.clear()\npath_items = []\nfor item in items:\n# Check if the item could refer to a file or dir. The replacing\n# of '\"' is needed for items on Windows\npath = os.path.abspath(item.replace('\"', \"\"))\nif os.path.isfile(path) or os.path.isdir(path):\npath_items.append(item.replace('\"', \"\"))\nelse:\nlist_item = widgets.ListWidgetItem()\nlist_item.setData(constants.ItemDataRole.UserRole, item)  # type: ignore\n# Need to split to only show last element of a dot completion\nlist_item.setText(item.split(\".\")[-1])\nself.addItem(list_item)\ncommon_prefix = os.path.dirname(os.path.commonprefix(path_items))\nfor path_item in path_items:\nlist_item = widgets.ListWidgetItem()\nlist_item.setData(constants.ItemDataRole.UserRole, path_item)  # type: ignore\ntext = path_item.split(common_prefix)[-1] if common_prefix else path_item\nlist_item.setText(text)\nself.addItem(list_item)\nheight = self.sizeHint().height()\nscreen = self.get_screen()\nif screen is None:\nreturn\nscreen_rect = self.availableGeometry()\nif screen_rect.size().height() + screen_rect.y() - point.y() - height &lt; 0:\npoint = self._text_edit.mapToGlobal(self._text_edit.cursorRect().topRight())\npoint.setY(int(point.y() - height))\nscrollbar_width = self.verticalScrollBar().sizeHint().width()\nw = self.sizeHintForColumn(0) + scrollbar_width + 2 * self.frameWidth()\nself.setGeometry(point.x(), point.y(), w, height)\n# Move cursor to start of the prefix to replace it\n# when a item is selected\ncursor.movePosition(QtGui.QTextCursor.MoveOperation.Left, n=prefix_length)\nself._start_position = cursor.position()\nself.setCurrentRow(0)\nself.raise_()\nself.show()\n# Protected interface\ndef _get_top_left_position(self, cursor: QtGui.QTextCursor) -&gt; QtCore.QPoint:\n\"\"\"Get top left position for this widget.\"\"\"\npoint = self._text_edit.cursorRect(cursor).center()\npoint_size = self._text_edit.font().pointSize()\nfactor = 1.05 if os.name == \"nt\" else 0.98\ndelta = int((point_size * 1.20) ** factor)\ny = delta - (point_size // 2)\npoint.setY(int(point.y() + y))\npoint = self._text_edit.mapToGlobal(point)\nreturn point\ndef _complete_current(self):\n\"\"\"Perform the completion with the currently selected item.\"\"\"\ntext = self.currentItem().data(constants.ItemDataRole.UserRole)  # type: ignore\nself._current_text_cursor().insertText(text)\nself.hide()\ndef _current_text_cursor(self) -&gt; QtGui.QTextCursor:\n\"\"\"Return a cursor with text between the start  and currentposition selected.\"\"\"\ncursor = self._text_edit.textCursor()\nif cursor.position() &gt;= self._start_position:\ncursor.setPosition(self._start_position, gui.TextCursor.MoveMode.KeepAnchor)\nreturn cursor\ndef _update_current(self):\n\"\"\"Update the current item based on the current text and the widget position.\"\"\"\n# Update widget position\ncursor = self._text_edit.textCursor()\npoint = self._get_top_left_position(cursor)\nself.move(point)\nif prefix := self._current_text_cursor().selection().toPlainText():\nflags = (\nconstants.MatchFlag.MatchStartsWith  # type: ignore\n| constants.MatchFlag.MatchCaseSensitive\n)\nif items := self.findItems(prefix, flags):\nself.setCurrentItem(items[0])\nelse:\nself.hide()\nelse:\nself.hide()\ndef cancel_completion(self):\nself.hide()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.eventFilter","title":"<code>eventFilter(obj, event)</code>","text":"<p>Handle mouse input and to auto-hide when losing focus.</p> Source code in <code>prettyqt\\custom_widgets\\completionwidget.py</code> <pre><code>def eventFilter(self, obj, event):\n\"\"\"Handle mouse input and to auto-hide when losing focus.\"\"\"\nif obj is self and event.type() == QtCore.QEvent.Type.MouseButtonPress:\npos = self.mapToGlobal(event.pos())\ntarget = QtWidgets.QApplication.widgetAt(pos)\nif target and self.isAncestorOf(target) or target is self:\nreturn False\nelse:\nself.cancel_completion()\nreturn super().eventFilter(obj, event)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.hideEvent","title":"<code>hideEvent(event)</code>","text":"<p>Disconnect signal handlers and event filter.</p> Source code in <code>prettyqt\\custom_widgets\\completionwidget.py</code> <pre><code>def hideEvent(self, event):\n\"\"\"Disconnect signal handlers and event filter.\"\"\"\nsuper().hideEvent(event)\nwith contextlib.suppress(TypeError):\nself._text_edit.cursorPositionChanged.disconnect(self._update_current)\nself.removeEventFilter(self)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.showEvent","title":"<code>showEvent(event)</code>","text":"<p>Connect signal handlers and event filter.</p> Source code in <code>prettyqt\\custom_widgets\\completionwidget.py</code> <pre><code>def showEvent(self, event):\n\"\"\"Connect signal handlers and event filter.\"\"\"\nsuper().showEvent(event)\nself._text_edit.cursorPositionChanged.connect(self._update_current)\nself.installEventFilter(self)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.show_items","title":"<code>show_items(cursor, items: Iterable[str], prefix_length: int = 0)</code>","text":"<p>Show the widget with 'items' at the position specified by 'cursor'.</p> Source code in <code>prettyqt\\custom_widgets\\completionwidget.py</code> <pre><code>def show_items(self, cursor, items: Iterable[str], prefix_length: int = 0):\n\"\"\"Show the widget with 'items' at the position specified by 'cursor'.\"\"\"\npoint = self._get_top_left_position(cursor)\nself.clear()\npath_items = []\nfor item in items:\n# Check if the item could refer to a file or dir. The replacing\n# of '\"' is needed for items on Windows\npath = os.path.abspath(item.replace('\"', \"\"))\nif os.path.isfile(path) or os.path.isdir(path):\npath_items.append(item.replace('\"', \"\"))\nelse:\nlist_item = widgets.ListWidgetItem()\nlist_item.setData(constants.ItemDataRole.UserRole, item)  # type: ignore\n# Need to split to only show last element of a dot completion\nlist_item.setText(item.split(\".\")[-1])\nself.addItem(list_item)\ncommon_prefix = os.path.dirname(os.path.commonprefix(path_items))\nfor path_item in path_items:\nlist_item = widgets.ListWidgetItem()\nlist_item.setData(constants.ItemDataRole.UserRole, path_item)  # type: ignore\ntext = path_item.split(common_prefix)[-1] if common_prefix else path_item\nlist_item.setText(text)\nself.addItem(list_item)\nheight = self.sizeHint().height()\nscreen = self.get_screen()\nif screen is None:\nreturn\nscreen_rect = self.availableGeometry()\nif screen_rect.size().height() + screen_rect.y() - point.y() - height &lt; 0:\npoint = self._text_edit.mapToGlobal(self._text_edit.cursorRect().topRight())\npoint.setY(int(point.y() - height))\nscrollbar_width = self.verticalScrollBar().sizeHint().width()\nw = self.sizeHintForColumn(0) + scrollbar_width + 2 * self.frameWidth()\nself.setGeometry(point.x(), point.y(), w, height)\n# Move cursor to start of the prefix to replace it\n# when a item is selected\ncursor.movePosition(QtGui.QTextCursor.MoveOperation.Left, n=prefix_length)\nself._start_position = cursor.position()\nself.setCurrentRow(0)\nself.raise_()\nself.show()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.EnumComboBox","title":"<code>EnumComboBox</code>","text":"<p>         Bases: <code>widgets.ComboBox</code></p> <p>ComboBox presenting options from a python Enum.</p> <p>If the Enum class does not implement <code>__str__</code> then a human readable name is created from the name of the enum member, replacing underscores with spaces.</p> Source code in <code>prettyqt\\custom_widgets\\editors\\enumcombobox.py</code> <pre><code>class EnumComboBox(widgets.ComboBox):\n\"\"\"ComboBox presenting options from a python Enum.\n    If the Enum class does not implement `__str__` then a human readable name\n    is created from the name of the enum member, replacing underscores with spaces.\n    \"\"\"\n# current_enum_changed = core.Signal(object)\nvalue_changed = core.Signal(enum.Enum)\ndef __init__(self, value=None, object_name: str = \"enum_combobox\", **kwargs):\nself._enum_class = None\nself._allow_none = False\nsuper().__init__(object_name=object_name, **kwargs)\nif value is not None:\nself.set_value(value)\n# self.currentIndexChanged.connect(self._emit_signal)\ndef __repr__(self):\nreturn get_repr(self, self.get_value())\ndef set_allow_none(self, value: bool):\nself._allow_none = value\ndef is_none_allowed(self) -&gt; bool:\nreturn self._allow_none\ndef _set_enum_class(self, enum: enum.EnumMeta | None):\n\"\"\"Set enum class from which members value should be selected.\"\"\"\nif enum == self._enum_class:\nreturn None\nself._enum_class = enum\nsuper().clear()\nif self._allow_none and enum is not None:\nsuper().addItem(NONE_STRING)\nitems = [i.name.replace(\"_\", \" \") for i in self._enum_class.__members__.values()]\nsuper().addItems(items)\ndef get_enum_class(self) -&gt; enum.EnumMeta | None:\n\"\"\"Return current Enum class.\"\"\"\nreturn self._enum_class\ndef is_optional(self) -&gt; bool:\n\"\"\"Return if current enum is with optional annotation.\"\"\"\nreturn self._allow_none\ndef clear(self):\nself._enum_class = None\nself._allow_none = False\nsuper().clear()\ndef get_value(self) -&gt; EnumType | None:\n\"\"\"Current value as Enum member.\"\"\"\nif self._enum_class is None:\nreturn None\nclass_members = list(self._enum_class.__members__.values())\nif not self._allow_none:\nreturn class_members[self.currentIndex()]\nis_none = self.currentText() == NONE_STRING\nreturn None if is_none else class_members[self.currentIndex() - 1]\ndef set_value(self, value: EnumType | None) -&gt; None:\n\"\"\"Set value with Enum.\"\"\"\nif value is None:\nif not self._allow_none:\nraise ValueError(value)\nself.setCurrentIndex(0)\nreturn\nif not isinstance(value, enum.Enum):\nvalue = self._enum_class(value)\nself._set_enum_class(value.__class__)\nself.setCurrentText(value.name.replace(\"_\", \" \"))\n# def _emit_signal(self):\n#     if self._enum_class is not None:\n#         self.current_enum_changed.emit(self.get_value())\nallowNone = core.Property(bool, is_none_allowed, set_allow_none)\nenumValue = core.Property(enum.Enum, get_value, set_value, user=True)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.editors.enumcombobox.EnumComboBox.get_enum_class","title":"<code>get_enum_class() -&gt; enum.EnumMeta | None</code>","text":"<p>Return current Enum class.</p> Source code in <code>prettyqt\\custom_widgets\\editors\\enumcombobox.py</code> <pre><code>def get_enum_class(self) -&gt; enum.EnumMeta | None:\n\"\"\"Return current Enum class.\"\"\"\nreturn self._enum_class\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.editors.enumcombobox.EnumComboBox.get_value","title":"<code>get_value() -&gt; EnumType | None</code>","text":"<p>Current value as Enum member.</p> Source code in <code>prettyqt\\custom_widgets\\editors\\enumcombobox.py</code> <pre><code>def get_value(self) -&gt; EnumType | None:\n\"\"\"Current value as Enum member.\"\"\"\nif self._enum_class is None:\nreturn None\nclass_members = list(self._enum_class.__members__.values())\nif not self._allow_none:\nreturn class_members[self.currentIndex()]\nis_none = self.currentText() == NONE_STRING\nreturn None if is_none else class_members[self.currentIndex() - 1]\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.editors.enumcombobox.EnumComboBox.is_optional","title":"<code>is_optional() -&gt; bool</code>","text":"<p>Return if current enum is with optional annotation.</p> Source code in <code>prettyqt\\custom_widgets\\editors\\enumcombobox.py</code> <pre><code>def is_optional(self) -&gt; bool:\n\"\"\"Return if current enum is with optional annotation.\"\"\"\nreturn self._allow_none\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.editors.enumcombobox.EnumComboBox.set_value","title":"<code>set_value(value: EnumType | None) -&gt; None</code>","text":"<p>Set value with Enum.</p> Source code in <code>prettyqt\\custom_widgets\\editors\\enumcombobox.py</code> <pre><code>def set_value(self, value: EnumType | None) -&gt; None:\n\"\"\"Set value with Enum.\"\"\"\nif value is None:\nif not self._allow_none:\nraise ValueError(value)\nself.setCurrentIndex(0)\nreturn\nif not isinstance(value, enum.Enum):\nvalue = self._enum_class(value)\nself._set_enum_class(value.__class__)\nself.setCurrentText(value.name.replace(\"_\", \" \"))\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.EnumFlagWidget","title":"<code>EnumFlagWidget</code>","text":"<p>         Bases: <code>widgets.ToolButton</code></p> Source code in <code>prettyqt\\custom_widgets\\editors\\enumflagwidget.py</code> <pre><code>class EnumFlagWidget(widgets.ToolButton):\nvalue_changed = core.Signal(enum.Flag)\ndef __init__(self, *args, object_name: str = \"enum_flag_widget\", **kwargs):\nself._enum_class = None\nself._action_map = {}\nself.button_menu = widgets.Menu(triggered=self._on_menu_click)\nsuper().__init__(*args, object_name=object_name, **kwargs)\nself.setMenu(self.button_menu)\nself.set_popup_mode(\"instant\")\ndef _on_menu_click(self):\nvalues = []\nvalue = self.get_value()\nfor i in self._enum_class.__members__.values():\nif i.value == 0:\ncontinue\n# self._action_map[i].setChecked(value &amp; i == i)\nif value &amp; i == i:\nvalues.append(i)\ntext = \" | \".join(i.name for i in values) if values else self._enum_class(0).name\nself.set_text(text)\nself.value_changed.emit(value)\ndef clear(self):\nself._action_map = {}\nself.button_menu.clear()\ndef _set_enum_class(self, enum: enum.EnumMeta | None):\n\"\"\"Set enum class from which members value should be selected.\"\"\"\nif enum == self._enum_class:\nreturn None\nself._enum_class = enum\nself.clear()\nfor i in self._enum_class.__members__.values():\nif i.value == 0:\ncontinue\naction = gui.Action(text=i.name.replace(\"_\", \" \"), checkable=True)\naction.setData(i)\nself._action_map[i] = action\nself.button_menu.add(action)\ndef get_enum_class(self) -&gt; enum.EnumMeta | None:\n\"\"\"Return current Enum class.\"\"\"\nreturn self._enum_class\ndef get_value(self) -&gt; enum.Flag:\n\"\"\"Current value as Enum member.\"\"\"\nif self._enum_class is None:\nreturn None\nflag = self._enum_class(0)\nfor k, v in self._action_map.items():\nif v.isChecked():\nflag |= k\nreturn flag\ndef set_value(self, value: enum.Flag) -&gt; None:\n\"\"\"Set value with Enum.\"\"\"\nif not isinstance(value, enum.Flag):\nvalue = self._enum_class(value)\nself._set_enum_class(value.__class__)\nif not isinstance(value, self._enum_class):\nraise TypeError(\n\"setValue(self, Enum): argument 1 has unexpected type \"\nf\"{type(value).__name__!r}\"\n)\n# this filter shouldnt be needed, see https://bugreports.qt.io/browse/PYSIDE-2369\nvalues = []\nfor i in self._enum_class.__members__.values():\nif i.value == 0:\ncontinue\nif value &amp; i == i:\nself._action_map[i].setChecked(True)\nvalues.append(i)\ntext = \" | \".join(i.name for i in values) if values else self._enum_class(0).name\nself.set_text(text)\nvalue = core.Property(enum.Flag, get_value, set_value, user=True)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.editors.enumflagwidget.EnumFlagWidget.get_enum_class","title":"<code>get_enum_class() -&gt; enum.EnumMeta | None</code>","text":"<p>Return current Enum class.</p> Source code in <code>prettyqt\\custom_widgets\\editors\\enumflagwidget.py</code> <pre><code>def get_enum_class(self) -&gt; enum.EnumMeta | None:\n\"\"\"Return current Enum class.\"\"\"\nreturn self._enum_class\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.editors.enumflagwidget.EnumFlagWidget.get_value","title":"<code>get_value() -&gt; enum.Flag</code>","text":"<p>Current value as Enum member.</p> Source code in <code>prettyqt\\custom_widgets\\editors\\enumflagwidget.py</code> <pre><code>def get_value(self) -&gt; enum.Flag:\n\"\"\"Current value as Enum member.\"\"\"\nif self._enum_class is None:\nreturn None\nflag = self._enum_class(0)\nfor k, v in self._action_map.items():\nif v.isChecked():\nflag |= k\nreturn flag\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.editors.enumflagwidget.EnumFlagWidget.set_value","title":"<code>set_value(value: enum.Flag) -&gt; None</code>","text":"<p>Set value with Enum.</p> Source code in <code>prettyqt\\custom_widgets\\editors\\enumflagwidget.py</code> <pre><code>def set_value(self, value: enum.Flag) -&gt; None:\n\"\"\"Set value with Enum.\"\"\"\nif not isinstance(value, enum.Flag):\nvalue = self._enum_class(value)\nself._set_enum_class(value.__class__)\nif not isinstance(value, self._enum_class):\nraise TypeError(\n\"setValue(self, Enum): argument 1 has unexpected type \"\nf\"{type(value).__name__!r}\"\n)\n# this filter shouldnt be needed, see https://bugreports.qt.io/browse/PYSIDE-2369\nvalues = []\nfor i in self._enum_class.__members__.values():\nif i.value == 0:\ncontinue\nif value &amp; i == i:\nself._action_map[i].setChecked(True)\nvalues.append(i)\ntext = \" | \".join(i.name for i in values) if values else self._enum_class(0).name\nself.set_text(text)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.FileChooserButton","title":"<code>FileChooserButton</code>","text":"<p>         Bases: <code>widgets.Widget</code></p> Source code in <code>prettyqt\\custom_widgets\\editors\\filechooserbutton.py</code> <pre><code>class FileChooserButton(widgets.Widget):\nvalue_changed = core.Signal(pathlib.Path)\ndef __init__(\nself,\nextensions: dict[str, list[str]] | None = None,\nmode: widgets.filedialog.AcceptModeStr = \"save\",\nfile_mode: widgets.filedialog.FileModeStr = \"existing_files\",\nroot: None | str | pathlib.Path = None,\nobject_name: str = \"file_chooser_button\",\n**kwargs: Any,\n):\n\"\"\"Initialize FileChooserButton.\n        Args:\n            extensions: dict allowed extensions\n                        form: \"'name': ['.ext1', '.ext2']\"\n            mode: Accept mode (\"save\" or \"load\")\n            file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\",\n                                  or \"directory\")\n            root: Root path\n            object_name: Object name\n            kwargs: kwargs passed to parent\n        \"\"\"\nsuper().__init__(object_name=object_name, **kwargs)\nself._path: pathlib.Path | None = None\nself._extensions = extensions or []\nself.mode = mode\nself.file_mode = file_mode\nself.root = root\nlayout = widgets.HBoxLayout(self)\nlayout.set_margin(0)\nself.lineedit = widgets.LineEdit()\nself.lineedit.set_read_only()\nlayout.add(self.lineedit)\naction = gui.Action(triggered=self.open_file)\nif self.file_mode == \"directory\":\naction.set_icon(\"mdi.folder-outline\")\nelse:\naction.set_icon(\"mdi.file-outline\")\nself.button = widgets.ToolButton()\nself.button.setDefaultAction(action)\nlayout.add(self.button)\n@core.Slot()\ndef open_file(self):\ndialog = widgets.FileDialog(\nparent=self,\npath_id=\"file_path\",\nmode=self.mode,\npath=self.root,\nfile_mode=self.file_mode,\n)\nif self._extensions:\ndialog.set_extension_filter(self._extensions)\nif not dialog.choose():\nreturn\nself.set_path(dialog.selected_file())\nself.value_changed.emit(self._path)\ndef set_path(self, path: datatypes.PathType | None):\nif path is None:\nself._path = None\nself.lineedit.set_text(\"\")\nelse:\nself._path = pathlib.Path(path)\nself.lineedit.set_text(os.fspath(path))\ndef get_value(self) -&gt; pathlib.Path | None:\nreturn self._path\ndef set_value(self, value: datatypes.PathType | None):\nself.set_path(value)\ndef get_extensions(self) -&gt; list[str]:\nreturn self._extensions\ndef set_extensions(self, extensions: list[str]):\nself._extensions = extensions\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.editors.filechooserbutton.FileChooserButton.__init__","title":"<code>__init__(extensions: dict[str, list[str]] | None = None, mode: widgets.filedialog.AcceptModeStr = 'save', file_mode: widgets.filedialog.FileModeStr = 'existing_files', root: None | str | pathlib.Path = None, object_name: str = 'file_chooser_button', **kwargs: Any)</code>","text":"<p>Initialize FileChooserButton.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>dict[str, list[str]] | None</code> <p>dict allowed extensions         form: \"'name': ['.ext1', '.ext2']\"</p> <code>None</code> <code>mode</code> <code>widgets.filedialog.AcceptModeStr</code> <p>Accept mode (\"save\" or \"load\")</p> <code>'save'</code> <code>file_mode</code> <code>widgets.filedialog.FileModeStr</code> <p>File mode (\"existing_files\", \"existing_file\", \"any_file\",                   or \"directory\")</p> <code>'existing_files'</code> <code>root</code> <code>None | str | pathlib.Path</code> <p>Root path</p> <code>None</code> <code>object_name</code> <code>str</code> <p>Object name</p> <code>'file_chooser_button'</code> <code>kwargs</code> <code>Any</code> <p>kwargs passed to parent</p> <code>{}</code> Source code in <code>prettyqt\\custom_widgets\\editors\\filechooserbutton.py</code> <pre><code>def __init__(\nself,\nextensions: dict[str, list[str]] | None = None,\nmode: widgets.filedialog.AcceptModeStr = \"save\",\nfile_mode: widgets.filedialog.FileModeStr = \"existing_files\",\nroot: None | str | pathlib.Path = None,\nobject_name: str = \"file_chooser_button\",\n**kwargs: Any,\n):\n\"\"\"Initialize FileChooserButton.\n    Args:\n        extensions: dict allowed extensions\n                    form: \"'name': ['.ext1', '.ext2']\"\n        mode: Accept mode (\"save\" or \"load\")\n        file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\",\n                              or \"directory\")\n        root: Root path\n        object_name: Object name\n        kwargs: kwargs passed to parent\n    \"\"\"\nsuper().__init__(object_name=object_name, **kwargs)\nself._path: pathlib.Path | None = None\nself._extensions = extensions or []\nself.mode = mode\nself.file_mode = file_mode\nself.root = root\nlayout = widgets.HBoxLayout(self)\nlayout.set_margin(0)\nself.lineedit = widgets.LineEdit()\nself.lineedit.set_read_only()\nlayout.add(self.lineedit)\naction = gui.Action(triggered=self.open_file)\nif self.file_mode == \"directory\":\naction.set_icon(\"mdi.folder-outline\")\nelse:\naction.set_icon(\"mdi.file-outline\")\nself.button = widgets.ToolButton()\nself.button.setDefaultAction(action)\nlayout.add(self.button)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.HierarchicalHeaderView","title":"<code>HierarchicalHeaderView</code>","text":"<p>         Bases: <code>widgets.HeaderView</code></p> <p>Hierarchical header view.</p> <p>This class is a Python port of http://qt-apps.org/content/show.php/HierarchicalHeaderView?content=103154</p> Source code in <code>prettyqt\\custom_widgets\\hierarchicalheaderview.py</code> <pre><code>class HierarchicalHeaderView(widgets.HeaderView):\n\"\"\"Hierarchical header view.\n    This class is a Python port of\n    http://qt-apps.org/content/show.php/HierarchicalHeaderView?content=103154\n    \"\"\"\nheader_model = None\ndef __init__(\nself,\norientation: constants.Orientation | constants.OrientationStr,\nparent: QtWidgets.QWidget,\n):\nsuper().__init__(orientation, parent, highlight_sections=True)\nself.setSectionsClickable(True)\nself.sectionResized.connect(self.on_section_resized)\nself.show()  # force to be visible\nif orientation in {constants.HORIZONTAL, \"horizontal\"}:\nparent.setHorizontalHeader(self)\nelse:\nparent.setVerticalHeader(self)\nself.sectionMoved.connect(self._on_section_moved)\ndef init_from_new_model(\nself, orientation: constants.Orientation, model: QtCore.QAbstractItemModel\n):\nis_hor = orientation == constants.HORIZONTAL\nrole = HORIZONTAL_HEADER_DATA_ROLE if is_hor else VERTICAL_HEADER_DATA_ROLE\nself.header_model = model.data(core.ModelIndex(), role)\ndef find_leaf(\nself, index: core.ModelIndex, section_index: int, current_leaf_index: int\n) -&gt; tuple[core.ModelIndex, int]:\nif not index.isValid():\nreturn core.ModelIndex(), current_leaf_index\nmodel = index.model()\nif child_count := model.columnCount(index):\nfor i in range(child_count):\nres, current_leaf_index = self.find_leaf(\nmodel.index(0, i, index), section_index, current_leaf_index\n)\nif res.isValid():\nreturn res, current_leaf_index\nelse:\ncurrent_leaf_index += 1\nif current_leaf_index == section_index:\nreturn index, current_leaf_index\nreturn core.ModelIndex(), current_leaf_index\ndef leaf_index(self, section_index: int) -&gt; core.ModelIndex:\nif self.header_model:\ncurrent_leaf_index = -1\nfor i in range(self.header_model.columnCount()):\nres, current_leaf_index = self.find_leaf(\nself.header_model.index(0, i), section_index, current_leaf_index\n)\nif res.isValid():\nreturn res\nreturn core.ModelIndex()\ndef search_leafs(self, index: core.ModelIndex) -&gt; list[core.ModelIndex]:\nres = []\nif index.isValid():\nmodel = index.model()\nif child_count := index.model().columnCount(index):\nfor i in range(child_count):\nleaf = model.index(0, i, index)\nres += self.search_leafs(leaf)\nelse:\nres.append(index)\nreturn res\ndef leafs(self, index: core.ModelIndex) -&gt; list[core.ModelIndex]:\nleafs = []\nif index.isValid():\nmodel = index.model()\nchild_count = index.model().columnCount(index)\nfor i in range(child_count):\nleaf = model.index(0, i, index)\nleafs += self.search_leafs(leaf)\nreturn leafs\ndef set_foreground_brush(\nself, opt: QtWidgets.QStyleOptionHeader, index: core.ModelIndex\n):\nif foreground_brush := index.data(constants.FOREGROUND_ROLE):\nbrush = QtGui.QBrush(foreground_brush)\nopt.palette.setBrush(QtGui.QPalette.ColorRole.ButtonText, brush)\ndef set_background_brush(\nself, opt: QtWidgets.QStyleOptionHeader, index: core.ModelIndex\n):\nif background_brush := index.data(constants.BACKGROUND_ROLE):\nbrush = QtGui.QBrush(background_brush)\nopt.palette.setBrush(QtGui.QPalette.ColorRole.Button, brush)\nopt.palette.setBrush(QtGui.QPalette.ColorRole.Window, brush)\ndef get_cell_size(\nself,\nleaf_index: core.ModelIndex,\nhv: QtWidgets.QHeaderView,\nstyle_options: QtWidgets.QStyleOptionHeader,\n) -&gt; QtCore.QSize:\nres = QtCore.QSize()\nif variant := leaf_index.data(constants.SIZE_HINT_ROLE):\nres = variant\nfnt = var if (var := leaf_index.data(constants.FONT_ROLE)) else hv.font()\nfnt.setBold(True)\nfm = QtGui.QFontMetrics(fnt)\ntext_size = fm.size(0, leaf_index.data(constants.DISPLAY_ROLE))\nsize = text_size + QtCore.QSize(4, 0)\nif leaf_index.data(constants.USER_ROLE):\nsize.transpose()\ndecoration_size = hv.style().sizeFromContents(\nQtWidgets.QStyle.ContentsType.CT_HeaderSection,\nstyle_options,\nQtCore.QSize(),\nhv,\n)\nempty_text_size = fm.size(0, \"\")\nreturn res.expandedTo(size + decoration_size - empty_text_size)\ndef get_current_cell_width(\nself,\nsearched_index: core.ModelIndex,\nleaf_index: core.ModelIndex,\nsection_index: int,\nhv: QtWidgets.QHeaderView,\n) -&gt; int:\nleafs_list = self.leafs(searched_index)\nif not leafs_list:\nreturn hv.sectionSize(section_index)\noffset = leafs_list.index(leaf_index) if leaf_index in leafs_list else -1\nfirst_leaf_section_index = section_index - offset\nreturn sum(\nhv.sectionSize(first_leaf_section_index + i) for i in range(len(leafs_list))\n)\ndef get_current_cell_left(\nself,\nsearched_index: core.ModelIndex,\nleaf_index: core.ModelIndex,\nsection_index: int,\nleft: int,\nhv: QtWidgets.QHeaderView,\n) -&gt; int:\nif leafs_list := self.leafs(searched_index):\nn = leafs_list.index(leaf_index) if leaf_index in leafs_list else -1\nfirst_leaf_section_index = section_index - n\nfor i in range(n - 1, -1, -1):\nleft -= hv.sectionSize(first_leaf_section_index + i)\nreturn left\ndef paint_horizontal_cell(\nself,\npainter: QtGui.QPainter,\nhv: QtWidgets.QHeaderView,\ncell_index: core.ModelIndex,\nleaf_index: core.ModelIndex,\nlogical_leaf_index: int,\nstyle_options: QtWidgets.QStyleOptionHeader,\nsection_rect: QtCore.QRect,\ntop: int,\n) -&gt; int:\nuniopt = QtWidgets.QStyleOptionHeader(style_options)\nself.set_foreground_brush(uniopt, cell_index)\nself.set_background_brush(uniopt, cell_index)\nheight = (\nsection_rect.height() - top\nif cell_index == leaf_index\nelse self.get_cell_size(cell_index, hv, uniopt).height()\n)\nleft = self.get_current_cell_left(\ncell_index, leaf_index, logical_leaf_index, section_rect.left(), hv\n)\nwidth = self.get_current_cell_width(\ncell_index, leaf_index, logical_leaf_index, hv\n)\nr = QtCore.QRect(left, top, width, height)\nuniopt.text = cell_index.data(constants.DISPLAY_ROLE)\npainter.save()\nuniopt.rect = r\nstyle = hv.style()\nif cell_index.data(constants.USER_ROLE):\nstyle.drawControl(CE.CE_HeaderSection, uniopt, painter, hv)\nm = QtGui.QTransform()\nm.rotate(-90)\npainter.setWorldTransform(m, True)\nnew_r = QtCore.QRect(0, 0, r.height(), r.width())\nnew_r.moveCenter(QtCore.QPoint(-r.center().y(), r.center().x()))\nuniopt.rect = new_r\nstyle.drawControl(CE.CE_HeaderLabel, uniopt, painter, hv)\nelse:\nstyle.drawControl(CE.CE_Header, uniopt, painter, hv)\npainter.restore()\nreturn top + height\ndef paint_horizontal_section(\nself,\npainter: QtGui.QPainter,\nsection_rect: QtCore.QRect,\nlogical_leaf_index: int,\nhv: QtWidgets.QHeaderView,\nstyle_options: QtWidgets.QStyleOptionHeader,\nleaf_index: core.ModelIndex,\n):\nold_bo = painter.brushOrigin()\ntop = section_rect.y()\nindexes = get_parent_indexes(leaf_index)\nfor i, idx in enumerate(indexes):\nreal_style_options = QtWidgets.QStyleOptionHeader(style_options)\nif i &lt; len(indexes) - 1 and (\nreal_style_options.state &amp; StateFlag.State_Sunken\nor real_style_options.state &amp; StateFlag.State_On\n):\nt = StateFlag.State_Sunken | StateFlag.State_On\nreal_style_options.state = real_style_options.state &amp; ~t\n# FIXME: parent items are not highlighted\nif i &lt; len(indexes) - 1:  # Use sortIndicator for inner level only\nreal_style_options.sortIndicator = SortIndicator.None_\n#                if i==0:\n#                    print(self.leafs(indexes[i]), leaf_index)\ntop = self.paint_horizontal_cell(\npainter,\nhv,\nidx,\nleaf_index,\nlogical_leaf_index,\nreal_style_options,\nsection_rect,\ntop,\n)\npainter.setBrushOrigin(old_bo)\ndef paint_vertical_cell(\nself,\npainter: QtGui.QPainter,\nhv: QtWidgets.QHeaderView,\ncell_index: core.ModelIndex,\nleaf_index: core.ModelIndex,\nlogical_leaf_index: int,\nstyle_options: QtWidgets.QStyleOptionHeader,\nsection_rect: QtCore.QRect,\nleft: int,\n) -&gt; int:\nuniopt = QtWidgets.QStyleOptionHeader(style_options)\nself.set_foreground_brush(uniopt, cell_index)\nself.set_background_brush(uniopt, cell_index)\nwidth = (\nsection_rect.width() - left\nif cell_index == leaf_index\nelse self.get_cell_size(cell_index, hv, uniopt).width()\n)\ntop = self.get_current_cell_left(\ncell_index, leaf_index, logical_leaf_index, section_rect.top(), hv\n)\nheight = self.get_current_cell_width(\ncell_index, leaf_index, logical_leaf_index, hv\n)\nr = QtCore.QRect(left, top, width, height)\nuniopt.text = cell_index.data(constants.DISPLAY_ROLE)\npainter.save()\nuniopt.rect = r\nstyle = hv.style()\nif cell_index.data(constants.USER_ROLE):\nstyle.drawControl(CE.CE_HeaderSection, uniopt, painter, hv)\nm = QtGui.QTransform()\nm.rotate(-90)\npainter.setWorldTransform(m, True)\nnew_r = QtCore.QRect(0, 0, r.height(), r.width())\nnew_r.moveCenter(QtCore.QPoint(-r.center().y(), r.center().x()))\nuniopt.rect = new_r\nstyle.drawControl(CE.CE_HeaderLabel, uniopt, painter, hv)\nelse:\nstyle.drawControl(CE.CE_Header, uniopt, painter, hv)\npainter.restore()\nreturn left + width\ndef paint_vertical_section(\nself,\npainter: QtGui.QPainter,\nsection_rect: QtCore.QRect,\nlogical_leaf_index: int,\nhv: QtWidgets.QHeaderView,\nstyle_options: QtWidgets.QStyleOptionHeader,\nleaf_index: core.ModelIndex,\n):\nold_bo = painter.brushOrigin()\nleft = section_rect.x()\nindexes = get_parent_indexes(leaf_index)\nfor i, idx in enumerate(indexes):\nreal_style_options = QtWidgets.QStyleOptionHeader(style_options)\nif i &lt; len(indexes) - 1 and (\nreal_style_options.state &amp; StateFlag.State_Sunken\nor real_style_options.state &amp; StateFlag.State_On\n):\nt = StateFlag.State_Sunken | StateFlag.State_On\nreal_style_options.state = real_style_options.state &amp; ~t\n# FIXME: parent items are not highlighted\nleft = self.paint_vertical_cell(\npainter,\nhv,\nidx,\nleaf_index,\nlogical_leaf_index,\nreal_style_options,\nsection_rect,\nleft,\n)\npainter.setBrushOrigin(old_bo)\ndef _on_section_moved(\nself, logical_index: int, old_visual_index: int, new_visual_index: int\n):\nview = self.parent()\nmodel = view.model()\nif not hasattr(model, \"reorder\"):\nreturn  # reorder underlying data of models with /reorder/ def only\nif getattr(self, \"manual_move\", False):\nself.manual_move = False\nreturn\nself.manual_move = True\nself.moveSection(new_visual_index, old_visual_index)  # cancel move\nif not model.reorder(old_visual_index, new_visual_index, self.orientation()):\nreturn\nrng = sorted((old_visual_index, new_visual_index))\nif self.orientation() == constants.HORIZONTAL:\noptions = [(view.columnWidth(i), i) for i in range(rng[0], rng[1] + 1)]\nfor i, col in enumerate(range(rng[0], rng[1] + 1)):\nview.setColumnWidth(col, options[i][0])\nview.selectColumn(new_visual_index)\nelse:\noptions = [(view.rowHeight(i), i) for i in range(rng[0], rng[1] + 1)]\nfor i, col in enumerate(range(rng[0], rng[1] + 1)):\nview.setRowHeight(col, options[i][0])\nview.selectRow(new_visual_index)\n# FIXME: don't select if sorting is enable?\nif self.isSortIndicatorShown():\nsort_ind_index = next(\n(i for i, o in enumerate(options) if o[1] == self.sortIndicatorSection()),\nNone,\n)\n# sort indicator is among sections being reordered\nif sort_ind_index is not None:\n# FIXME: does unnecessary sorting\nself.setSortIndicator(sort_ind_index + rng[0], self.sortIndicatorOrder())\nmodel.layoutChanged.emit()  # update view\ndef get_style_option_for_cell(\nself, logical_index: int\n) -&gt; QtWidgets.QStyleOptionHeader:\nopt = QtWidgets.QStyleOptionHeader()\nself.initStyleOption(opt)\nif self.isSortIndicatorShown() and self.sortIndicatorSection() == logical_index:\nasc = self.sortIndicatorOrder() == constants.ASCENDING\nopt.sortIndicator = SortIndicator.SortDown if asc else SortIndicator.SortUp\nif self.window().isActiveWindow():\nopt.state = opt.state | StateFlag.State_Active\nopt.textAlignment = constants.AlignmentFlag.AlignCenter\nopt.iconAlignment = constants.AlignmentFlag.AlignVCenter\nopt.section = logical_index\nvisual = self.visualIndex(logical_index)\nif self.count() == 1:\nopt.position = SectionPosition.OnlyOneSection\nelif visual == 0:\nopt.position = SectionPosition.Beginning\nelse:\nis_end = visual == self.count() - 1\nopt.position = SectionPosition.End if is_end else SectionPosition.Middle\nsel_model = self.selectionModel()\nif not sel_model:\nreturn opt\nroot_idx = self.rootIndex()\nif self.sectionsClickable() and self.highlightSections():\nif self.orientation() == constants.HORIZONTAL:\nif sel_model.columnIntersectsSelection(logical_index, root_idx):\nopt.state = opt.state | StateFlag.State_On\nif sel_model.isColumnSelected(logical_index, root_idx):\nopt.state = opt.state | StateFlag.State_Sunken\nelse:\nif sel_model.rowIntersectsSelection(logical_index, root_idx):\nopt.state = opt.state | StateFlag.State_On\nif sel_model.isRowSelected(logical_index, root_idx):\nopt.state = opt.state | StateFlag.State_Sunken\nprev_idx = self.logicalIndex(visual - 1)\nnext_idx = self.logicalIndex(visual + 1)\nif self.orientation() == constants.HORIZONTAL:\nprev_selected = sel_model.isColumnSelected(prev_idx, root_idx)\nnext_selected = sel_model.isColumnSelected(next_idx, root_idx)\nelse:\nprev_selected = sel_model.isRowSelected(prev_idx, root_idx)\nnext_selected = sel_model.isRowSelected(next_idx, root_idx)\nif prev_selected and next_selected:\nopt.selectedPosition = SelectedPosition.NextAndPreviousAreSelected\nelif prev_selected:\nopt.selectedPosition = SelectedPosition.PreviousIsSelected\nelif next_selected:\nopt.selectedPosition = SelectedPosition.NextIsSelected\nelse:\nopt.selectedPosition = SelectedPosition.NotAdjacent\nreturn opt\ndef sectionSizeFromContents(self, logical_index: int) -&gt; QtCore.QSize:\nif not self.header_model:\nreturn super().sectionSizeFromContents(logical_index)\ncur_leaf_index = self.leaf_index(logical_index)\nif not cur_leaf_index.isValid():\nreturn super().sectionSizeFromContents(logical_index)\nstyleOption = QtWidgets.QStyleOptionHeader(\nself.get_style_option_for_cell(logical_index)\n)\ns = self.get_cell_size(cur_leaf_index, self, styleOption)\ncur_leaf_index = cur_leaf_index.parent()\nwhile cur_leaf_index.isValid():\ncell_size = self.get_cell_size(cur_leaf_index, self, styleOption)\nif self.orientation() == constants.HORIZONTAL:\ns.setHeight(s.height() + cell_size.height())\nelse:\ns.setWidth(s.width() + cell_size.width())\ncur_leaf_index = cur_leaf_index.parent()\nreturn s\ndef paintSection(\nself, painter: QtGui.QPainter, rect: QtCore.QRect, logical_index: int\n):\nif not rect.isValid():\nsuper().paintSection(painter, rect, logical_index)\nreturn\nleaf_index = self.leaf_index(logical_index)\nif not leaf_index.isValid():\nsuper().paintSection(painter, rect, logical_index)\nreturn\nstyle_option = self.get_style_option_for_cell(logical_index)\nif self.orientation() == constants.HORIZONTAL:\nself.paint_horizontal_section(\npainter,\nrect,\nlogical_index,\nself,\nstyle_option,\nleaf_index,\n)\nelse:\nself.paint_vertical_section(\npainter,\nrect,\nlogical_index,\nself,\nstyle_option,\nleaf_index,\n)\ndef on_section_resized(self, logical_index: int):\nif self.isSectionHidden(logical_index):\nreturn\nleaf_index = self.leaf_index(logical_index)\nif leaf_index.isValid():\nleafs_list = self.leafs(find_root_index(leaf_index))\nstart = leafs_list.index(leaf_index) if leaf_index in leafs_list else -1\nis_horizontal = self.orientation() == constants.HORIZONTAL\nfor _ in range(start, 0, -1):\nlogical_index -= 1\nw = self.viewport().width()\nh = self.viewport().height()\npos = self.sectionViewportPosition(logical_index)\nr = QtCore.QRect(pos, 0, w - pos, h)\nif is_horizontal:\nif self.isRightToLeft():\nr.setRect(0, 0, pos + self.sectionSize(logical_index), h)\nelse:\nr.setRect(0, pos, w, h - pos)\nself.viewport().update(r.normalized())\ndef setModel(self, model: QtCore.QAbstractItemModel):\nsuper().setModel(model)\nmodel.layoutChanged.connect(self._on_layout_change)\nself._on_layout_change()\ndef _on_layout_change(self):\nif model := self.model():\nself.init_from_new_model(self.orientation(), model)\nis_horizontal = self.orientation() == constants.HORIZONTAL\ncount = model.columnCount() if is_horizontal else model.rowCount()\nself.initializeSections(0, count - 1)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.IconBrowser","title":"<code>IconBrowser</code>","text":"<p>         Bases: <code>widgets.MainWindow</code></p> <p>A small browser window that allows the user to search through all icons.</p> <p>You can also copy the name and python code for the currently selected icon.</p> Source code in <code>prettyqt\\custom_widgets\\iconbrowser.py</code> <pre><code>class IconBrowser(widgets.MainWindow):\n\"\"\"A small browser window that allows the user to search through all icons.\n    You can also copy the name and python code for the currently selected icon.\n    \"\"\"\ndef __init__(self):\nsuper().__init__()\nself.setMinimumSize(500, 500)\nself.set_title(\"Icon Browser\")\nfont_maps = {k: v.charmap for k, v in iconprovider._instance().fonts.items()}\nicon_names = [\nf\"{font_collection}.{icon_name}\"\nfor font_collection, font_data in font_maps.items()\nfor icon_name in font_data\n]\nmodel = IconModel(icon_color=\"text_role\")\nmodel.setStringList(sorted(icon_names))\nself._proxy_model = custom_models.FuzzyFilterProxyModel()\nself._proxy_model.setSourceModel(model)\nself._proxy_model.set_filter_case_sensitive(True)\nself._proxy_model.set_match_color(None)\nself._listview = widgets.ListView(\nself,\nuniform_item_sizes=True,\nview_mode=\"icon\",\ncontext_menu_policy=\"custom\",\ndouble_clicked=self._copy_icon_text,\nvertical_scroll_bar_policy=\"always_on\",\n)\neventfilter = listviewgridresizeeventfilter.ListViewGridResizeEventFilter(\nparent=self._listview\n)\nself._listview.installEventFilter(eventfilter)\nself._listview.set_model(self._proxy_model)\nself._lineedit = widgets.LineEdit(\nparent=self, text_changed=self._trigger_instant_update\n)\nself._combobox = widgets.ComboBox(\nparent=self,\nminimum_width=75,\ncurrent_index_changed=self._trigger_instant_update,\n)\nself._combobox.addItems([ALL_COLLECTIONS, *sorted(font_maps.keys())])\nsearch_bar_frame = widgets.Frame(self)\nlayout = search_bar_frame.set_layout(\"horizontal\", margin=0)\nlayout.add(self._combobox)\nlayout.add(self._lineedit)\nself._copy_button = widgets.PushButton(\"Copy Name\", clicked=self._copy_icon_text)\nframe = widgets.Frame(self)\nlayout = frame.set_layout(\"vertical\")\nlayout.add(search_bar_frame)\nlayout.add(self._listview)\nlayout.add(self._copy_button)\nself.setCentralWidget(frame)\nself.add_shortcut(\"return\", self._copy_icon_text)\nself._lineedit.setFocus()\nself.position_on(\"screen\")\ndef _trigger_instant_update(self):\n\"\"\"Stop timer used for committing search term and update proxy model instantly.\"\"\"\nself._proxy_model.set_search_term(self._lineedit.text())\ndef _copy_icon_text(self):\n\"\"\"Copy the name of the currently selected icon to the clipboard.\"\"\"\nif indexes := self._listview.selectedIndexes():\nwidgets.Application.copy_to_clipboard(indexes[0].data())\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.IconWidget","title":"<code>IconWidget</code>","text":"<p>         Bases: <code>widgets.Label</code></p> Source code in <code>prettyqt\\custom_widgets\\iconwidget.py</code> <pre><code>class IconWidget(widgets.Label):\ndef __init__(self, *names, parent: QtWidgets.QWidget | None = None, **kwargs):\nsuper().__init__(parent=parent)\nself._icon: QtGui.QIcon | None = None\nself._size = core.Size(16, 16)\nself.set_icon(iconprovider._icon(*names, **kwargs))\ndef set_icon(self, _icon: datatypes.IconType):\n\"\"\"Set a new icon().\n        Parameters\n        ----------\n        _icon: qtawesome.icon\n            icon to set\n        \"\"\"\nself._icon = iconprovider.get_icon(_icon)\nself.setPixmap(self._icon.pixmap(self._size))\ndef set_icon_size(self, size: datatypes.SizeType):\nself._size = datatypes.to_size(size)\nself.update()\ndef update(self, *args, **kwargs):\nif self._icon:\nself.setPixmap(self._icon.pixmap(self._size))\nreturn super().update(*args, **kwargs)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.set_icon","title":"<code>set_icon(_icon: datatypes.IconType)</code>","text":"<p>Set a new icon().</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.set_icon--parameters","title":"Parameters","text":"qtawesome.icon <p>icon to set</p> Source code in <code>prettyqt\\custom_widgets\\iconwidget.py</code> <pre><code>def set_icon(self, _icon: datatypes.IconType):\n\"\"\"Set a new icon().\n    Parameters\n    ----------\n    _icon: qtawesome.icon\n        icon to set\n    \"\"\"\nself._icon = iconprovider.get_icon(_icon)\nself.setPixmap(self._icon.pixmap(self._size))\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.ObjectBrowser","title":"<code>ObjectBrowser</code>","text":"<p>         Bases: <code>widgets.MainWindow</code></p> <p>Object browser main application window.</p> Source code in <code>prettyqt\\custom_widgets\\objectbrowser.py</code> <pre><code>class ObjectBrowser(widgets.MainWindow):\n\"\"\"Object browser main application window.\"\"\"\ndef __init__(self, obj, stack=None, name: str = \"\"):\nsuper().__init__()\nself.set_title(\"Object browser\")\nself.set_icon(\"mdi.language-python\")\nself._auto_refresh = False\nself._refresh_rate = 2\nself._tree_model = custom_models.PythonObjectTreeModel(obj)\nself._attr_details = [\nKlass(model=self._tree_model) for Klass in DEFAULT_ATTR_DETAILS\n]\n# Toggle auto-refresh on/off\nself.toggle_auto_refresh_action = gui.Action(\ntext=\"Auto-refresh\",\nparent=self,\ncheckable=True,\nstatus_tip=f\"Auto refresh every {self._refresh_rate} seconds\",\n)\nself.toggle_auto_refresh_action.toggled.connect(self.toggle_auto_refresh)\n# Add another refresh action with a different shortcut. An action must be added to\n# a visible widget for it to receive events. It is added to the main windows to\n# prevent it from being displayed again in the menu\nself.refresh_action_f5 = self.add_action(\ntext=\"&amp;Refresh2\", shortcut=\"F5\", triggered=self._tree_model.refresh_tree\n)\nself.central_splitter = widgets.Splitter(\nparent=self, orientation=constants.VERTICAL\n)\nself.setCentralWidget(self.central_splitter)\n# Tree widget\nself.obj_tree = widgets.TreeView(\nroot_is_decorated=True, selection_behavior=\"rows\"\n)\nself.obj_tree.set_model(self._tree_model)\nself.obj_tree.h_header = custom_widgets.FilterHeader(self.obj_tree)\n# Stretch last column?\n# It doesn't play nice when columns are hidden and then shown again.\nself.obj_tree.h_header.set_id(\"table_header\")\nself.obj_tree.h_header.setSectionsMovable(True)\nself.obj_tree.h_header.setStretchLastSection(False)\nself.central_splitter.addWidget(self.obj_tree)\n# Bottom pane\nbottom_pane_widget = widgets.Widget()\nbottom_pane_widget.set_layout(\"horizontal\", spacing=0, margin=5)\nself.central_splitter.addWidget(bottom_pane_widget)\ngroup_box = widgets.GroupBox(\"Details\")\nbottom_pane_widget.box.addWidget(group_box)\ngroup_box.set_layout(\"horizontal\", margin=2)\n# Radio buttons\nradio_widget = widgets.Widget()\nradio_widget.set_layout(\"vertical\", margin=0)\nself.button_group = widgets.ButtonGroup(\nself, button_clicked=self._change_details_field\n)\nfor button_id, attr_detail in enumerate(self._attr_details):\nradio_button = widgets.RadioButton(attr_detail.name)\nradio_widget.box.addWidget(radio_button)\nself.button_group.addButton(radio_button, button_id)\nself.button_group.button(0).setChecked(True)\nradio_widget.box.addStretch(1)\ngroup_box.box.addWidget(radio_widget)\nself.editor = widgets.PlainTextEdit(read_only=True, font=gui.Font.mono())\ngroup_box.box.addWidget(self.editor)\n# Splitter parameters\nself.central_splitter.setCollapsible(0, False)\nself.central_splitter.setCollapsible(1, True)\nself.central_splitter.setSizes([400, 200])\nself.central_splitter.setStretchFactor(0, 10)\nself.central_splitter.setStretchFactor(1, 0)\nselection_model = self.obj_tree.selectionModel()\nselection_model.currentRowChanged.connect(self._update_details)\nmenubar = self.menuBar()\nfile_menu = menubar.add_menu(\"&amp;File\")\nfile_menu.add_action(text=\"C&amp;lose\", triggered=self.close, shortcut=\"Ctrl+W\")\nfile_menu.add_action(\ntext=\"E&amp;xit\",\ntriggered=lambda: widgets.app().closeAllWindows(),\nshortcut=\"Ctrl+Q\",\n)\nview_menu = menubar.add_menu(\"&amp;View\")\nview_menu.add_action(\ntext=\"&amp;Refresh\", triggered=self._tree_model.refresh_tree, shortcut=\"Ctrl+R\"\n)\nview_menu.addAction(self.toggle_auto_refresh_action)\nview_menu.addSeparator()\nself.show_cols_submenu = self.obj_tree.h_header.createPopupMenu()\nself.show_cols_submenu.setTitle(\"Table columns\")\nview_menu.add_menu(self.show_cols_submenu)\nview_menu.addSeparator()\nassert self._refresh_rate &gt; 0\nself._refresh_timer = core.Timer(self)\nself._refresh_timer.setInterval(self._refresh_rate * 1000)\nself._refresh_timer.timeout.connect(self._tree_model.refresh_tree)\nself.toggle_auto_refresh_action.setChecked(self._auto_refresh)\n@core.Slot(core.ModelIndex, core.ModelIndex)\ndef _update_details(\nself, current_index: core.ModelIndex, _previous_index: core.ModelIndex\n):\n\"\"\"Show the object details in the editor given an index.\"\"\"\nif self.obj_tree.model() is None or not current_index.isValid():\nreturn\nrole = self.obj_tree.get_model(skip_proxies=True).ExtraRoles.TreeItemRole\ntree_item = current_index.data(role)\nself._update_details_for_item(tree_item)\ndef _change_details_field(self, _button_id=None):\n\"\"\"Change the field that is displayed in the details pane.\"\"\"\n# logger.debug(\"_change_details_field: {}\".format(_button_id))\nif self.obj_tree.model() is None:\nreturn\ncurrent_index = self.obj_tree.selectionModel().currentIndex()\nif not current_index.isValid():\nreturn\nrole = self.obj_tree.get_model(skip_proxies=True).ExtraRoles.TreeItemRole\ntree_item = current_index.data(role)\nself._update_details_for_item(tree_item)\ndef _update_details_for_item(self, tree_item):\n\"\"\"Show the object details in the editor given an tree_item.\"\"\"\nbutton_id = self.button_group.checkedId()\nattr_details = self._attr_details[button_id]\ndata = attr_details.get_data(tree_item)\nself.editor.set_text(data)\nself.editor.set_word_wrap_mode(attr_details.line_wrap)\ndef toggle_auto_refresh(self, checked):\n\"\"\"Toggle auto-refresh on/off.\"\"\"\nif checked:\nlogger.info(\"Auto-refresh on. Rate %g seconds\", self._refresh_rate)\nself._refresh_timer.start()\nelse:\nlogger.info(\"Auto-refresh off\")\nself._refresh_timer.stop()\nself._auto_refresh = checked\ndef closeEvent(self, event):\n\"\"\"Called when the window is closed.\"\"\"\nself._refresh_timer.stop()\nself._refresh_timer.timeout.disconnect(self._tree_model.refresh_tree)\nself.toggle_auto_refresh_action.toggled.disconnect(self.toggle_auto_refresh)\nself.refresh_action_f5.triggered.disconnect(self._tree_model.refresh_tree)\nself.button_group.buttonClicked.disconnect(self._change_details_field)\nselection_model = self.obj_tree.selectionModel()\nselection_model.currentRowChanged.disconnect(self._update_details)\nself.close()\nevent.accept()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.objectbrowser.ObjectBrowser.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Called when the window is closed.</p> Source code in <code>prettyqt\\custom_widgets\\objectbrowser.py</code> <pre><code>def closeEvent(self, event):\n\"\"\"Called when the window is closed.\"\"\"\nself._refresh_timer.stop()\nself._refresh_timer.timeout.disconnect(self._tree_model.refresh_tree)\nself.toggle_auto_refresh_action.toggled.disconnect(self.toggle_auto_refresh)\nself.refresh_action_f5.triggered.disconnect(self._tree_model.refresh_tree)\nself.button_group.buttonClicked.disconnect(self._change_details_field)\nselection_model = self.obj_tree.selectionModel()\nselection_model.currentRowChanged.disconnect(self._update_details)\nself.close()\nevent.accept()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.objectbrowser.ObjectBrowser.toggle_auto_refresh","title":"<code>toggle_auto_refresh(checked)</code>","text":"<p>Toggle auto-refresh on/off.</p> Source code in <code>prettyqt\\custom_widgets\\objectbrowser.py</code> <pre><code>def toggle_auto_refresh(self, checked):\n\"\"\"Toggle auto-refresh on/off.\"\"\"\nif checked:\nlogger.info(\"Auto-refresh on. Rate %g seconds\", self._refresh_rate)\nself._refresh_timer.start()\nelse:\nlogger.info(\"Auto-refresh off\")\nself._refresh_timer.stop()\nself._auto_refresh = checked\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.OrientedTableView","title":"<code>OrientedTableView</code>","text":"<p>         Bases: <code>widgets.TableView</code></p> <p>TableView class with some convenience methods for oriented tables.</p> Source code in <code>prettyqt\\custom_widgets\\orientedtableview.py</code> <pre><code>class OrientedTableView(widgets.TableView):\n\"\"\"TableView class with some convenience methods for oriented tables.\"\"\"\ndef __init__(self, orientation: constants.Orientation, **kwargs):\nsuper().__init__(**kwargs)\nself.orientation = orientation\ndef get_higher_levels(self, levels: int):\nmodel = self.model()\nif self.is_horizontal():\n# Get the header's selected columns\n# Removes the higher levels so that only the lowest level of the header\n# affects the data table selection\nreturn core.ItemSelection(\nmodel.index(0, 0), model.index(levels - 2, model.columnCount() - 1)\n)\nelse:\nreturn core.ItemSelection(\nmodel.index(0, 0), model.index(model.rowCount() - 1, levels - 2)\n)\ndef set_section_span(self, row, column, count):\nif self.is_horizontal():\nself.setSpan(row, column, 1, count)\nelse:\nself.setSpan(column, row, count, 1)\ndef sectionAt(self, val: int):\nreturn self.columnAt(val) if self.is_horizontal() else self.rowAt(val)\ndef over_header_edge(self, position: int, margin: int = 3):\n# Return the index of the column this x position is on the right edge of\nleft = self.sectionAt(position - margin)\nright = self.sectionAt(position + margin)\nif left != right != 0:\n# We're at the left edge of the first column\nreturn left\ndef is_horizontal(self) -&gt; bool:\nreturn self.orientation == constants.HORIZONTAL\ndef sectionWidth(self, val: int):\nreturn self.columnWidth(val) if self.is_horizontal() else self.rowHeight(val)\ndef setSectionWidth(self, val: int, val2):\nif self.is_horizontal():\nself.setColumnWidth(val, val2)\nelse:\nself.setRowHeight(val, val2)\ndef get_split_cursor(self):\nif self.is_horizontal():\nreturn gui.Cursor(constants.CursorShape.SplitHCursor)\nelse:\nreturn gui.Cursor(constants.CursorShape.SplitVCursor)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.PopupInfo","title":"<code>PopupInfo</code>","text":"<p>         Bases: <code>widgets.Dialog</code></p> <p>Dialog overlay to show some info to user.</p> Source code in <code>prettyqt\\custom_widgets\\popupinfo.py</code> <pre><code>class PopupInfo(widgets.Dialog):\n\"\"\"Dialog overlay to show some info to user.\"\"\"\n_singleton: PopupInfo | None = None\ndef __init__(self, parent: QtWidgets.QWidget | None = None, text: str | None = None):\nsuper().__init__(parent=parent)\nself.timer = core.Timer(single_shot=True, timeout=self.close)\nself.label = widgets.Label(alignment=\"center\")\nself.iconlabel = widgets.Label()\nself.set_icon(\"mdi.information\")\nself.set_flags(stay_on_top=True, frameless=True, tooltip=True)\nlayout = self.set_layout(\"horizontal\", margin=20, size_constraint=\"minimum\")\nself.set_background_color(\"black\")\nself.label.set_color(\"white\")\nlayout.add(self.iconlabel)\nlayout.add(self.label)\nself.hide()\ndef set_text_color(self, color: datatypes.ColorType):\nself.label.set_color(color)\ndef set_icon(self, icon: datatypes.IconType):\npixmap = iconprovider.get_icon(icon, color=\"white\").pixmap(32)\nself.iconlabel.setPixmap(pixmap)\ndef show_popup(\nself,\ntext: str,\nicon: datatypes.IconType = \"mdi.information\",\ntext_color: datatypes.ColorType = \"white\",\nbackground_color: datatypes.ColorType = \"black\",\nposition=\"screen\",\ntimeout: int = 2500,\n):\nself.set_background_color(background_color)\nself.label.set_color(text_color)\nself.label.setText(text)\nself.set_icon(icon)\nself.adjustSize()\nself.position_on(position, y_offset=-200)\nself.timer.start(timeout)\nself.show()\n@classmethod\ndef popup(\ncls,\ntext: str,\nicon: datatypes.IconType = \"mdi.information\",\ntext_color: datatypes.ColorType = \"white\",\nbackground_color: datatypes.ColorType = \"black\",\nposition=\"screen\",\ntimeout: int = 2500,\n):\nif cls._singleton is None:\ncls._singleton = cls()\npopup = cls._singleton\npopup.set_background_color(background_color)\npopup.label.set_color(text_color)\npopup.label.setText(text)\npopup.set_icon(icon)\npopup.adjustSize()\npopup.position_on(position, y_offset=-200)\npopup.timer.start(timeout)\npopup.show()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.RoundProgressBar","title":"<code>RoundProgressBar</code>","text":"<p>         Bases: <code>widgets.Widget</code></p> Source code in <code>prettyqt\\custom_widgets\\roundprogressbar.py</code> <pre><code>class RoundProgressBar(widgets.Widget):\nclass Position(float, enum.Enum):\n\"\"\"Start position of progress bar in degrees.\"\"\"\nLeft = 180.0\nTop = 90.0\nRight = 0.0\nBottom = -90.0\nclass BarStyle(enum.IntEnum):\n\"\"\"Progress bar style.\"\"\"\nDonut = 1\nPie = 2\nLine = 3\nExpand = 4\nclass ValueType(enum.IntEnum):\n\"\"\"Value type.\"\"\"\nvalue = 1\npercent = 2\nmaximum = 3\ndef __init__(self, parent: QtWidgets.QWidget | None = None):\nsuper().__init__(parent)\nself._min_value = 0.0\nself._max_value = 100.0\nself.current_value = 0.0\nself.null_pos = self.Position.Top\nself.bar_style: RoundProgressBar.BarStyle = self.BarStyle.Donut\nself.outline_pen_width = 1.0\nself.data_pen_width = 1.0\nself._rebuild_brush = False\nself.number_format = \"%p%\"\nself.decimals = 1\nself._update_flags: ValueTypeStr = \"percent\"\nself.gradient_data: Sequence[QtGui.QColor] = []\ndef minimum(self):\nreturn self._min_value\ndef maximum(self):\nreturn self._max_value\n# SETTERS -------------------------------------------------------\ndef set_null_position(self, position: RoundProgressBar.Position):\nif position != self.null_pos:\nself.null_pos = position\nself._rebuild_brush = True\nself.update()\ndef get_null_position(self):\nreturn self.null_pos\ndef set_bar_style(self, style: BarStyleStr | RoundProgressBar.BarStyle):\nif isinstance(style, str):\nBAR_STYLE = dict(\ndonut=RoundProgressBar.BarStyle.Donut,\npie=RoundProgressBar.BarStyle.Pie,\nline=RoundProgressBar.BarStyle.Line,\nexpand=RoundProgressBar.BarStyle.Expand,\n)\nstyle = BAR_STYLE[style]\nif style != self.bar_style:\nself.bar_style = style\nself._rebuild_brush = True\nself.update()\ndef set_outline_pen_width(self, width: float):\nif width != self.outline_pen_width:\nself.outline_pen_width = width\nself.update()\ndef set_data_pen_width(self, width: float):\nif width != self.data_pen_width:\nself.data_pen_width = width\nself.update()\ndef set_data_colors(self, stop_points: list[QtGui.QColor]):\nif stop_points != self.gradient_data:\nself.gradient_data = stop_points\nself._rebuild_brush = True\nself.update()\ndef set_format(self, val: str):\nif val != self.number_format:\nself.number_format = val\nself._value_format_changed()\ndef set_decimals(self, count: int):\nif count &gt;= 0 and count != self.decimals:\nself.decimals = count\nself._value_format_changed()\n# SLOTS ---------------------------------------------------------\n@core.Slot(float, float)\ndef set_range(self, minval: float, maxval: float):\nself._min_value = min(minval, maxval)\nself._max_value = max(minval, maxval)\nself.current_value = min(\nself._max_value, max(self._min_value, self.current_value)\n)\nself._rebuild_brush = True\nself.update()\n@core.Slot(float)\ndef setMinimum(self, val: float):\nself.set_range(val, self._max_value)\n@core.Slot(float)\ndef setMaximum(self, val: float):\nself.set_range(self._min_value, val)\n@core.Slot(float)\ndef set_value(self, val: float):\nif self.current_value != val:\nself.current_value = min(self._max_value, max(self._min_value, val))\nself.update()\ndef get_value(self) -&gt; float:\nreturn self.current_value\n# PAINTING ------------------------------------------------------\ndef paintEvent(self, event: gui.PaintEvent):\nouter_radius = min(self.width(), self.height())\nrect = core.RectF(1, 1, outer_radius - 2, outer_radius - 2)\nwith gui.Painter(self) as painter:\npainter.use_antialiasing()\nif self.bar_style != self.BarStyle.Line:\nself._rebuild_data_brush_if_needed()\npainter.fillRect(0, 0, outer_radius, outer_radius, self.palette().window())\nself._draw_base(painter, rect)\nself._draw_value(painter, rect, self.current_value)\ninner_rect, inner_radius = self._calculate_inner_rect(outer_radius)\nself._draw_inner_background(painter, inner_rect)\nself._draw_text(painter, inner_rect, inner_radius, self.current_value)\ndef _draw_base(self, painter: gui.Painter, rect: core.RectF):\nmatch self.bar_style:\ncase self.BarStyle.Donut:\ncolor = self.palette().shadow().color()\npainter.set_pen(color=color, width=self.outline_pen_width)\npainter.setBrush(self.palette().base())\npainter.drawEllipse(rect)\ncase self.BarStyle.Line:\nbase_color = self.palette().base().color()\npainter.set_pen(color=base_color, width=self.outline_pen_width)\npainter.setBrush(constants.BrushStyle.NoBrush)\nwidth = self.outline_pen_width / 2\nadjusted = rect.adjusted(width, width, -width, -width)\npainter.drawEllipse(adjusted)\ncase self.BarStyle.Pie | self.BarStyle.Expand:\nbase_color = self.palette().base().color()\npainter.set_pen(color=base_color, width=self.outline_pen_width)\npainter.setBrush(self.palette().base())\npainter.drawEllipse(rect)\ndef _draw_value(self, painter: gui.Painter, rect: core.RectF, value: float):\nif value == self._min_value:\nreturn\ndiff = self.current_value - self._min_value\nvalue_range = self._max_value - self._min_value\ndelta = max(value_range / diff, 0)\nmatch self.bar_style:\ncase self.BarStyle.Expand:\npainter.setBrush(self.palette().highlight())\ncolor = self.palette().shadow().color()\npainter.set_pen(color=color, width=self.data_pen_width)\nradius = (rect.height() / 2) / delta\npainter.drawEllipse(rect.center(), radius, radius)\ncase self.BarStyle.Line:\ncolor = self.palette().highlight().color()\npainter.set_pen(color=color, width=self.data_pen_width)\npainter.setBrush(constants.BrushStyle.NoBrush)\npen_width = self.outline_pen_width / 2\nadjusted = rect.adjusted(pen_width, pen_width, -pen_width, -pen_width)\nif value == self._max_value:\npainter.drawEllipse(adjusted)\nelse:\narc_length = 360 / delta\narc_length = int(-arc_length * 16)\npainter.drawArc(adjusted, int(self.null_pos * 16), arc_length)\ncase self.BarStyle.Donut | self.BarStyle.Pie:\ndata_path = gui.PainterPath()\ndata_path.set_fill_rule(\"winding\")\nif value == self._max_value:\ndata_path.addEllipse(rect)\nelse:\narc_length = 360 / delta\ncenter_point = rect.center()\ndata_path.moveTo(center_point)\ndata_path.arcTo(rect, self.null_pos, -arc_length)\ndata_path.lineTo(center_point)\npainter.setBrush(self.palette().highlight())\nshadow_color = self.palette().shadow().color()\npainter.set_pen(color=shadow_color, width=self.data_pen_width)\npainter.drawPath(data_path)\ndef _calculate_inner_rect(self, outer_radius: float) -&gt; tuple[core.RectF, float]:\nif self.bar_style in (self.BarStyle.Line, self.BarStyle.Expand):\ninner_radius = outer_radius - self.outline_pen_width\nelse:\ninner_radius = outer_radius * 0.75\ndelta = (outer_radius - inner_radius) / 2\ninner_rect = core.RectF(delta, delta, inner_radius, inner_radius)\nreturn inner_rect, inner_radius\ndef _draw_inner_background(self, painter: gui.Painter, inner_rect: core.RectF):\nif self.bar_style == self.BarStyle.Donut:\npainter.setBrush(self.palette().base())\npainter.drawEllipse(inner_rect)\ndef _draw_text(\nself,\npainter: gui.Painter,\ninner_rect: core.RectF,\ninner_radius: float,\nvalue: float,\n):\nif not self.number_format:\nreturn\nfont = self.get_font()\nfont.setPixelSize(10)\nmetrics = gui.FontMetricsF(font)\nmax_width = metrics.horizontalAdvance(self._value_to_text(self._max_value))\ndelta = inner_radius / max_width\nfont_size = int(font.pixelSize() * delta * 0.75)\nfont.setPixelSize(max(font_size, 1))\npainter.setFont(font)\npainter.setPen(self.palette().text().color())\ntext = self._value_to_text(value)\npainter.drawText(inner_rect, constants.ALIGN_CENTER, text)  # type: ignore\ndef _value_to_text(self, value: float) -&gt; str:\ntext_to_draw = self.number_format\nmatch self._update_flags:\ncase \"value\":\nval = round(value, self.decimals)\nreturn text_to_draw.replace(r\"%v\", str(val))\ncase \"percent\":\ndiff = self._max_value - self._min_value\npct = (value - self._min_value) / diff * 100\nval = round(pct, self.decimals)\nreturn text_to_draw.replace(r\"%p\", str(val))\ncase \"max\":\nval = round(self._max_value - self._min_value + 1, self.decimals)\nreturn text_to_draw.replace(r\"%m\", str(val))\ncase _:\nraise ValueError(self._update_flags)\ndef _value_format_changed(self):\nfor k, v in VALUE_MAP.items():\nif k in self.number_format:\nself._update_flags = v\nself.update()\ndef _rebuild_data_brush_if_needed(self):\nif not self._rebuild_brush or not self.gradient_data:\nreturn\nself._rebuild_brush = False\nif self.bar_style == \"expand\":\ndata_brush = gui.RadialGradient(0.5, 0.5, 0.5, 0.5, 0.5)\nfor i in self.gradient_data:\ndata_brush[i[0]] = i[1]\nelse:\ndata_brush = gui.ConicalGradient(0.5, 0.5, self.null_pos)\nfor i in self.gradient_data:\ndata_brush[1 - i[0]] = i[1]\ndata_brush.set_coordinate_mode(\"stretch_to_device\")\nwith self.edit_palette() as palette:\npalette.set_brush(\"highlight\", data_brush)\nnullPosition = core.Property(enum.Enum, get_null_position, set_null_position)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar.RoundProgressBar.BarStyle","title":"<code>BarStyle</code>","text":"<p>         Bases: <code>enum.IntEnum</code></p> <p>Progress bar style.</p> Source code in <code>prettyqt\\custom_widgets\\roundprogressbar.py</code> <pre><code>class BarStyle(enum.IntEnum):\n\"\"\"Progress bar style.\"\"\"\nDonut = 1\nPie = 2\nLine = 3\nExpand = 4\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar.RoundProgressBar.Position","title":"<code>Position</code>","text":"<p>         Bases: <code>float</code>, <code>enum.Enum</code></p> <p>Start position of progress bar in degrees.</p> Source code in <code>prettyqt\\custom_widgets\\roundprogressbar.py</code> <pre><code>class Position(float, enum.Enum):\n\"\"\"Start position of progress bar in degrees.\"\"\"\nLeft = 180.0\nTop = 90.0\nRight = 0.0\nBottom = -90.0\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar.RoundProgressBar.ValueType","title":"<code>ValueType</code>","text":"<p>         Bases: <code>enum.IntEnum</code></p> <p>Value type.</p> Source code in <code>prettyqt\\custom_widgets\\roundprogressbar.py</code> <pre><code>class ValueType(enum.IntEnum):\n\"\"\"Value type.\"\"\"\nvalue = 1\npercent = 2\nmaximum = 3\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.ScrollAreaTocWidget","title":"<code>ScrollAreaTocWidget</code>","text":"<p>         Bases: <code>widgets.TreeView</code></p> Source code in <code>prettyqt\\custom_widgets\\scrollareatocwidget.py</code> <pre><code>class ScrollAreaTocWidget(widgets.TreeView):\nsection_changed = core.Signal()\n@core.Enum\nclass ScrollMode(enum.Enum):\n\"\"\"Scroll modes.\"\"\"\nSingle = 1\nMulti = 2\nHeadersOnly = 4\n@core.Enum\nclass ExpandMode(enum.Enum):\n\"\"\"Expand modes.\"\"\"\nAlways = 1\nOnFocus = 2\ndef __init__(\nself,\nscrollarea: widgets.QScrollArea,\norientation: constants.Orientation = constants.VERTICAL,\nwidget_class: type = widgets.QWidget,\n**kwargs,\n) -&gt; None:\n# TODO: not sure if parent should always equal scrollarea...\"\"\"\nself._WidgetClass = widget_class\nself._scroll_mode = \"single\"\nself._expand_mode = \"always\"\nself._last_visible = None\nself.scrollarea = scrollarea\nsuper().__init__(scrollarea, **kwargs)\nself._orientation = orientation\nself.setFixedWidth(200)\nself.h_header.hide()\nself.h_header.setStretchLastSection(True)\nself.setAlternatingRowColors(False)\nself.setRootIsDecorated(False)\n# self.setStyleSheet(\n#     \"\"\"::item:hover {background: transparent; border-color:transparent}\n#     ::item:selected { border-color:transparent;\n#     border-style:outset; border-width:2px; color:black; }\"\"\"\n# )\nif orientation == constants.VERTICAL:\nscrollarea.v_scrollbar.valueChanged.connect(self._on_scroll)\nelse:\nscrollarea.h_scrollbar.valueChanged.connect(self._on_scroll)\nself.set_widget(scrollarea)\ndef showEvent(self, event):\nsuper().showEvent(event)\nself._on_scroll()\ndef set_widget(self, widget: widgets.QScrollArea):\n\"\"\"Set the ScrollArea widget to follow.\"\"\"\nif widget.widget() is None:\nraise RuntimeError(\"No widget set on ScrollArea.\")\nself.scrollarea = widget\nmodel = ScrollAreaTocModel(\nwidget.widget(),\nshow_root=True,\nparent=self.scrollarea,\nwidget_class=self._WidgetClass,\n)\nself.set_model(model)\nself.proxy = self.proxifier.get_proxy(\n\"sort_filter\", recursive_filtering_enabled=True\n)\nself.proxy.set_filter_case_sensitive(False)\nself.show_root(False)\nwidget.widget().installEventFilter(self)\nself.selectionModel().currentRowChanged.connect(self._on_current_change)\nself.selectionModel().selectionChanged.connect(self._on_selection_change)\n# if self._expand_mode == \"always\":\nself.expandAll()\ndef _on_current_change(self, new, old):\nif self.model() is None:\nreturn\nis_vertical = self._orientation == constants.VERTICAL\narea = self.scrollarea\nscrollbar = area.v_scrollbar if is_vertical else area.h_scrollbar\nwith self.signal_blocked(scrollbar.valueChanged, self._on_scroll):\nwidget = self.model().data(new, role=constants.USER_ROLE)\narea.scroll_to_bottom()\narea.ensureWidgetVisible(widget, 10, 10)\ndef _on_selection_change(self, new, old):\nif self.model() is None:\nreturn\nwidgets = [i.data(constants.USER_ROLE) for i in self.selected_indexes()]\nself.get_model(skip_proxies=True).set_highlighted_widgets(widgets)\ndef _on_scroll(self):\nmodel: ScrollAreaTocModel | None = self.model()\nif model is None:\nreturn\nvisible_widgets = self.scrollarea.get_visible_widgets(typ=self._WidgetClass)\nif not visible_widgets or visible_widgets == self._last_visible:\nreturn\nself._last_visible = visible_widgets\nsig = self.selectionModel().currentRowChanged\nwith self.signal_blocked(sig, self._on_current_change):\nself.select_index(None)\nif self._expand_mode != \"always\":\nself.collapseAll()\nmatch self._scroll_mode:\ncase \"multi\":\nindexes = model.search_tree(visible_widgets, constants.USER_ROLE)\nfor index in indexes:\nchildren = model.get_child_indexes(index)\n# only select if all children selected.\n# if all(c in indexes for c in children):\n# highlight when no children or when first child is visible.\nif not children or children[0] in indexes:\nself.select_index(index, clear=False)\nself.set_expanded(indexes)\nself.scroll_to(indexes[0])\nself.scroll_to(indexes[-1])\ncase \"headers_only\":\nif indexes := model.search_tree(\nvisible_widgets,\nrole=constants.USER_ROLE,\nmax_results=1,\n):\nself.set_current_index(indexes[0])\nself.scroll_to(indexes[0])\ncase \"single\":\nif indexes := model.search_tree(visible_widgets, constants.USER_ROLE):\nviewport = self.scrollarea.viewport()\n# sort indexes by closest distance to top\nindexes.sort(\nkey=lambda x: abs(\nx.data(constants.USER_ROLE)\n.map_to(viewport, x.data(constants.USER_ROLE).rect())\n.top()\n),\n)\nself.collapseAll()\nself.model().fetchMore(indexes[0])\nself.set_current_index(indexes[0])\nself.scroll_to(indexes[0])\ncase _:\nraise ValueError(self._scroll_mode)\n# model.set_highlighted_indexes(indexes)\ndef wheelEvent(self, e):\nself.scrollarea.wheelEvent(e)\ndef eventFilter(self, source: core.QObject, event: core.QEvent) -&gt; bool:\nmatch event.type():\ncase core.Event.Type.ChildAdded:\nself._on_scroll()\nreturn False\ndef get_scroll_mode(self) -&gt; str:\nreturn self._scroll_mode\ndef set_scroll_mode(self, mode: str):\nself._scroll_mode = mode\ndef get_expand_mode(self) -&gt; str:\nreturn self._expand_mode\ndef set_expand_mode(self, mode: str):\nself._expand_mode = mode\nscrollMode = core.Property(str, get_scroll_mode, set_scroll_mode)\nexpandMode = core.Property(str, get_expand_mode, set_expand_mode)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.scrollareatocwidget.ScrollAreaTocWidget.ExpandMode","title":"<code>ExpandMode</code>","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Expand modes.</p> Source code in <code>prettyqt\\custom_widgets\\scrollareatocwidget.py</code> <pre><code>@core.Enum\nclass ExpandMode(enum.Enum):\n\"\"\"Expand modes.\"\"\"\nAlways = 1\nOnFocus = 2\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.scrollareatocwidget.ScrollAreaTocWidget.ScrollMode","title":"<code>ScrollMode</code>","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Scroll modes.</p> Source code in <code>prettyqt\\custom_widgets\\scrollareatocwidget.py</code> <pre><code>@core.Enum\nclass ScrollMode(enum.Enum):\n\"\"\"Scroll modes.\"\"\"\nSingle = 1\nMulti = 2\nHeadersOnly = 4\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.scrollareatocwidget.ScrollAreaTocWidget.set_widget","title":"<code>set_widget(widget: widgets.QScrollArea)</code>","text":"<p>Set the ScrollArea widget to follow.</p> Source code in <code>prettyqt\\custom_widgets\\scrollareatocwidget.py</code> <pre><code>def set_widget(self, widget: widgets.QScrollArea):\n\"\"\"Set the ScrollArea widget to follow.\"\"\"\nif widget.widget() is None:\nraise RuntimeError(\"No widget set on ScrollArea.\")\nself.scrollarea = widget\nmodel = ScrollAreaTocModel(\nwidget.widget(),\nshow_root=True,\nparent=self.scrollarea,\nwidget_class=self._WidgetClass,\n)\nself.set_model(model)\nself.proxy = self.proxifier.get_proxy(\n\"sort_filter\", recursive_filtering_enabled=True\n)\nself.proxy.set_filter_case_sensitive(False)\nself.show_root(False)\nwidget.widget().installEventFilter(self)\nself.selectionModel().currentRowChanged.connect(self._on_current_change)\nself.selectionModel().selectionChanged.connect(self._on_selection_change)\n# if self._expand_mode == \"always\":\nself.expandAll()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.SidebarWidget","title":"<code>SidebarWidget</code>","text":"<p>         Bases: <code>widgets.MainWindow</code></p> Source code in <code>prettyqt\\custom_widgets\\sidebarwidget.py</code> <pre><code>class SidebarWidget(widgets.MainWindow):\nSETTINGS_BUTTON_HEIGHT = 28\ndef __init__(\nself,\n*args,\nshow_settings: bool = False,\nmain_layout: widgets.widget.LayoutStr | QtWidgets.QLayout = \"vertical\",\n**kwargs,\n):\nsuper().__init__(*args, **kwargs)\nself._button_width = 100\nself._style: constants.ToolButtonStyleStr = \"text_below_icon\"\nself.button_map: dict[QtWidgets.QWidget, QtWidgets.QToolButton] = {}\nself.icon_map: dict[QtWidgets.QWidget, gui.Icon] = {}\nself.sidebar = widgets.ToolBar(\ncontext_menu_policy=\"prevent\",\nfloatable=True,\nobject_name=\"SidebarWidget\",\nwindow_title=\"Sidebar\",\n)\nself.sidebar.set_style(self._style)\nself.sidebar.set_allowed_areas(\"all\")\nself.settings_menu = widgets.Menu()\nself.sidebar.set_icon_size(int(self._button_width * 0.7))\nif show_settings:\nself.settings_btn = self.sidebar.add_menu_button(\n\"\", icon=\"mdi.wrench\", menu=self.settings_menu\n)\nself.settings_btn.setFixedSize(\nself._button_width, self.SETTINGS_BUTTON_HEIGHT\n)\nself.settings_btn.set_style(\"icon\")\nself.sidebar.orientationChanged.connect(self._on_orientation_change)\nself.sidebar.add_separator()\nself.spacer_action = self.sidebar.add_spacer()\nself.add_toolbar(self.sidebar, \"left\")\nself.area = widgets.Widget()\nself.area.set_layout(\"stacked\")\nw = widgets.Widget()\nw.set_layout(main_layout)\nself.main_layout = w.box\nself.main_layout.set_margin(0)\nself.main_layout += self.area\nself.setCentralWidget(w)\ndef _on_orientation_change(self, orientation: constants.Orientation):\nif orientation == constants.HORIZONTAL:\nself.settings_btn.setFixedSize(34, 34)\nelse:\nself.settings_btn.setFixedSize(\nself._button_width, self.SETTINGS_BUTTON_HEIGHT\n)\ndef add_tab(\nself,\nitem: QtWidgets.QWidget,\ntitle: str,\nicon: datatypes.IconType | None = None,\nshow: bool = False,\nshortcut: str | None = None,\narea: AreaStr = \"top\",\n):\nself.area.box.add(item)\nact = gui.Action(\ntext=title,\nicon=icon,\nshortcut=shortcut or \"\",\nparent=self.sidebar,\ncheckable=True,\ntriggered=lambda: self.set_tab(item),\n)\nself.addAction(act)\nbutton = widgets.ToolButton(self.sidebar)\nbutton.setDefaultAction(act)\nbutton.setFixedWidth(self._button_width)\nbutton.set_style(self._style)\nif area == \"top\":\nself.sidebar.insertWidget(self.spacer_action, button)\nelse:\nself.sidebar.addWidget(button)\nif len(self.area.box) == 1:\nbutton.setChecked(True)\nself.button_map[item] = button\nself.icon_map[item] = iconprovider.get_icon(icon)\nif show:\nself.area.box.setCurrentWidget(item)\ndef set_marker(\nself, item: str | int | widgets.Widget, color: datatypes.ColorType = \"red\"\n):\nwidget = item if isinstance(item, widgets.QWidget) else self._get_widget(item)\nif widget == self._get_current_widget():\nreturn\ntemplate = self.icon_map[widget]\npx = template.pixmap(100, 100)\nwith gui.Painter(px) as painter:\ndot = gui.Pixmap.create_dot(color)\npainter.drawPixmap(0, 0, dot)\nicon = gui.Icon(px)\nself.button_map[widget].setIcon(icon)\ndef _get_widget(self, item: str | int | widgets.Widget):\n\"\"\"Returns widget page specified by name, offset or content.\"\"\"\nmatch item:\ncase int():\nreturn self.area.box[item]\ncase str():\nw = self.area.find_child(QtWidgets.QWidget, name=item, recursive=False)\nif w not in self.area.box:\nraise ValueError(\"Layout does not contain the chosen widget\")\nreturn w\ncase _:\nraise TypeError(item)\ndef _get_current_widget(self) -&gt; QtWidgets.QWidget:\n\"\"\"Returns the currently selected widget page.\"\"\"\nfor k, v in self.button_map.items():\nif v.isChecked():\nreturn k\nraise RuntimeError(\"no page activated.\")\ndef set_tab(self, item: str | int | widgets.QWidget):\nwidget = item if isinstance(item, widgets.QWidget) else self._get_widget(item)\ncurrent = self.area.box.currentWidget()\nself.button_map[current].setChecked(False)\nself.area.box.setCurrentWidget(widget)\nself.button_map[widget].setChecked(True)\ndef add_spacer(self) -&gt; gui.QAction:\nreturn self.sidebar.add_spacer()\ndef add_separator(self, text: str | None = None, area: AreaStr = \"top\"):\nif area == \"top\":\nself.sidebar.add_separator(text, before=self.spacer_action)\nelse:\nself.sidebar.add_separator(text)\ndef add_action(self, *args, area: AreaStr = \"top\", **kwargs):\nact = args[0] if args else gui.Action(**kwargs)\nself.addAction(act)\nbutton = widgets.ToolButton(self.sidebar)\nbutton.setDefaultAction(act)\nbutton.setFixedWidth(self._button_width)\nbutton.set_style(self._style)\nif area == \"top\":\nself.sidebar.insertWidget(self.spacer_action, button)\nelse:\nself.sidebar.addWidget(button)\nreturn act\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.SpanSlider","title":"<code>SpanSlider</code>","text":"<p>         Bases: <code>widgets.Slider</code></p> Source code in <code>prettyqt\\custom_widgets\\editors\\spanslider.py</code> <pre><code>class SpanSlider(widgets.Slider):\nvalue_changed = core.Signal(object)\nlower_pos_changed = core.Signal(float)\nupper_pos_changed = core.Signal(float)\nslider_pressed = core.Signal(object)\ndef __init__(self, *args, object_name: str = \"span_slider\", **kwargs):\nsuper().__init__(\"horizontal\", *args, object_name=object_name, **kwargs)\nself.rangeChanged.connect(self.update_range)\nself.sliderReleased.connect(self._move_pressed_handle)\nself.lower_val = 0.0\nself.upper_val = 0.0\nself.lower_pos = 0.0\nself.upper_pos = 0.0\nself.offset = 0\nself.position = 0.0\nself.last_pressed: str | None = None\nself.upper_pressed = widgets.Style.SubControl.SC_None\nself.lower_pressed = widgets.Style.SubControl.SC_None\nself.movement: MovementModeStr = \"no_crossing\"\nself._main_control: Literal[\"lower\", \"upper\"] = \"lower\"\nself._first_movement = False\nself._block_tracking = False\ndark_color = self.palette().color(gui.Palette.ColorRole.Dark)\nself.gradient_left = dark_color.lighter(110)\nself.gradient_right = dark_color.lighter(110)\ndef mousePressEvent(self, event):\nif self.minimum() == self.maximum() or event.buttons() ^ event.button():\nevent.ignore()\nreturn\nself.upper_pressed = self._handle_mouse_press(\nevent.position(), self.upper_pressed, self.upper_val, \"upper\"\n)\nif self.upper_pressed != HANDLE_STYLE:\nself.lower_pressed = self._handle_mouse_press(\nevent.position(), self.lower_pressed, self.lower_val, \"lower\"\n)\nself._first_movement = True\nevent.accept()\ndef mouseMoveEvent(self, event):\nif self.lower_pressed != HANDLE_STYLE and self.upper_pressed != HANDLE_STYLE:\nevent.ignore()\nreturn\nopt = widgets.StyleOptionSlider()\nself.initStyleOption(opt)\nm = self.style().pixelMetric(\nwidgets.Style.PixelMetric.PM_MaximumDragDistance, opt, self\n)\npixel_pos = int(self.pick(event.position()) - self.offset)\nnew_pos = float(self._pixel_pos_to_value(pixel_pos))\nif m &gt;= 0:\nr = self.rect().adjusted(-m, -m, m, m)\nif not r.contains(event.position().toPoint()):\nnew_pos = self.position\n# pick the preferred handle on the first movement\nif self._first_movement:\nif self.lower_val == self.upper_val:\nif new_pos &lt; self.lower_value:\nself._swap_controls()\nself._first_movement = False\nelse:\nself._first_movement = False\nmatch HANDLE_STYLE, self.movement:\ncase self.lower_pressed, \"no_crossing\":\nnew_pos = min(new_pos, self.upper_val)\nself.set_lower_pos(new_pos)\ncase self.lower_pressed, \"no_overlap\":\nnew_pos = min(new_pos, self.upper_val - 1)\nself.set_lower_pos(new_pos)\ncase self.lower_pressed, \"free\" if new_pos &gt; self.upper_val:\nself._swap_controls()\nself.set_upper_pos(new_pos)\ncase self.upper_pressed, \"no_crossing\":\nnew_pos = max(new_pos, self.lower_value)\nself.set_upper_pos(new_pos)\ncase self.upper_pressed, \"no_overlap\":\nnew_pos = max(new_pos, self.lower_value + 1)\nself.set_upper_pos(new_pos)\ncase self.upper_pressed, \"free\" if new_pos &lt; self.lower_val:\nself._swap_controls()\nself.set_lower_pos(new_pos)\nevent.accept()\ndef mouseReleaseEvent(self, event):\nsuper().mouseReleaseEvent(event)\nself.setSliderDown(False)\nself.lower_pressed = self.upper_pressed = widgets.Style.SubControl.SC_None\nself.update()\ndef paintEvent(self, event):\npainter = widgets.StylePainter(self)\n# ticks\nopt = widgets.StyleOptionSlider()\nself.initStyleOption(opt)\nopt.subControls = widgets.Style.SubControl.SC_SliderTickmarks\npainter.draw_complex_control(\"slider\", opt)\n# groove\nopt.sliderPosition = 20\nopt.sliderValue = 0\nopt.subControls = GROOVE_STYLE\npainter.draw_complex_control(\"slider\", opt)\n# handle rects\nopt.sliderPosition = int(self.lower_pos)\nlr = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\nlrv = self.pick(lr.center())\nopt.sliderPosition = int(self.upper_pos)\nur = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\nurv = self.pick(ur.center())\n# span\nminv = min(lrv, urv)\nmaxv = max(lrv, urv)\nc = self.style().subControlRect(SLIDER_STYLE, opt, GROOVE_STYLE, self).center()\nif self.is_horizontal():\nrect = core.Rect(core.Point(minv, c.y() - 2), core.Point(maxv, c.y() + 1))\nelse:\nrect = core.Rect(core.Point(c.x() - 2, minv), core.Point(c.x() + 1, maxv))\nself._draw_span(painter, rect)\n# handles\nif self.last_pressed == \"lower\":\nself.draw_handle(painter, \"upper\")\nself.draw_handle(painter, \"lower\")\nelse:\nself.draw_handle(painter, \"lower\")\nself.draw_handle(painter, \"upper\")\n@core.Property(float)\ndef lower_value(self) -&gt; float:\nreturn min(self.lower_val, self.upper_val)\ndef set_lower_value(self, lower: float):\nself.set_span(lower, self.upper_val)\n@core.Property(float)\ndef upper_value(self) -&gt; float:\nreturn max(self.lower_val, self.upper_val)\ndef set_upper_value(self, upper: float):\nself.set_span(self.lower_val, upper)\ndef on_value_change(self):\nself.value_changed.emit((self.lower_val, self.upper_val))\ndef get_value(self) -&gt; tuple[float, float]:\nreturn (self.lower_val, self.upper_val)\ndef set_value(self, value: tuple[float, float]):\nself.set_lower_value(value[0])\nself.set_upper_value(value[1])\ndef get_movement_mode(self) -&gt; MovementModeStr:\nreturn self.movement\ndef set_movement_mode(self, mode: MovementModeStr):\n\"\"\"Set movement mode.\n        Args:\n            mode: movement mode for the main window\n        Raises:\n            ValueError: movement mode type does not exist\n        \"\"\"\nif mode not in MOVEMENT_MODE:\nraise ValueError(\"Invalid movement mode\")\nself.movement = mode\ndef set_span(self, lower: float, upper: float):\nlow = clamp(min(lower, upper), self.minimum(), self.maximum())\nupp = clamp(max(lower, upper), self.minimum(), self.maximum())\nchanged = False\nif low != self.lower_val:\nself.lower_val = low\nself.lower_pos = low\nchanged = True\nif upp != self.upper_val:\nself.upper_val = upp\nself.upper_pos = upp\nchanged = True\nif changed:\nself.on_value_change()\nself.update()\ndef set_lower_pos(self, lower: float):\nif self.lower_pos == lower:\nreturn\nself.lower_pos = lower\nif not self.hasTracking():\nself.update()\nif self.isSliderDown():\nself.lower_pos_changed.emit(lower)\nif self.hasTracking() and not self._block_tracking:\nmain = self._main_control == \"lower\"\nself.trigger_action(\"move\", main)\ndef set_upper_pos(self, upper: float):\nif self.upper_pos == upper:\nreturn\nself.upper_pos = upper\nif not self.hasTracking():\nself.update()\nif self.isSliderDown():\nself.upper_pos_changed.emit(upper)\nif self.hasTracking() and not self._block_tracking:\nmain = self._main_control == \"upper\"\nself.trigger_action(\"move\", main)\ndef set_left_color(self, color: datatypes.ColorType):\nself.gradient_left = colors.get_color(color)\nself.update()\ndef set_right_color(self, color: datatypes.ColorType):\nself.gradient_right = colors.get_color(color)\nself.update()\ndef _move_pressed_handle(self):\nif self.last_pressed == \"lower\":\nif self.lower_pos != self.lower_val:\nmain = self._main_control == \"lower\"\nself.trigger_action(\"move\", main)\nelif self.last_pressed == \"upper\" and self.upper_pos != self.upper_val:\nmain = self._main_control == \"upper\"\nself.trigger_action(\"move\", main)\ndef pick(self, p: datatypes.PointType) -&gt; int:\nif isinstance(p, tuple):\nreturn p[0] if self.is_horizontal() else p[1]\nelse:\nreturn p.x() if self.is_horizontal() else p.y()\ndef trigger_action(self, action: ActionStr, main: bool):\nvalue = 0.0\nno = False\nup = False\nmy_min = self.minimum()\nmy_max = self.maximum()\nself._block_tracking = True\nmain_control = main and self._main_control == \"upper\"\nalt_control = not main and self._main_control == \"lower\"\nis_upper_handle = main_control or alt_control\nval = self.upper_val if is_upper_handle else self.lower_val\nmatch action:\ncase \"single_step_add\":\nup = is_upper_handle\nvalue = clamp(val + self.singleStep(), my_min, my_max)\ncase \"single_step_sub\":\nup = is_upper_handle\nvalue = clamp(val - self.singleStep(), my_min, my_max)\ncase \"to_minimum\":\nup = is_upper_handle\nvalue = my_min\ncase \"to_maximum\":\nup = is_upper_handle\nvalue = my_max\ncase \"move\":\nup = is_upper_handle\nno = True\ncase \"none\":\nno = True\nif not no and not up:\nmatch self.movement:\ncase \"no_crossing\":\nvalue = min(value, self.upper_val)\ncase \"no_overlap\":\nvalue = min(value, self.upper_val - 1)\ncase \"free\" if value &gt; self.upper_val:\nself._swap_controls()\nself.set_upper_pos(value)\ncase \"free\":\nself.set_lower_pos(value)\nelif not no:\nmatch self.movement:\ncase \"no_crossing\":\nvalue = max(value, self.lower_val)\ncase \"no_overlap\":\nvalue = max(value, self.lower_val + 1)\ncase \"free\" if value &lt; self.lower_val:\nself._swap_controls()\nself.set_lower_pos(value)\ncase \"free\":\nself.set_upper_pos(value)\nself._block_tracking = False\nself.set_lower_value(self.lower_pos)\nself.set_upper_value(self.upper_pos)\ndef _swap_controls(self):\nself.lower_val, self.upper_val = self.upper_val, self.lower_val\nself.lower_pressed, self.upper_pressed = self.upper_pressed, self.lower_pressed\nself.last_pressed = \"upper\" if self.last_pressed == \"lower\" else \"lower\"\nself._main_control = \"upper\" if self._main_control == \"lower\" else \"lower\"\ndef update_range(self, min_, max_):\n# set_span() takes care of keeping span in range\nself.set_span(self.lower_val, self.upper_val)\ndef _setup_painter(\nself,\npainter: widgets.StylePainter,\norientation: Literal[\"horizontal\", \"vertical\"],\nx1: int,\ny1: int,\nx2: int,\ny2: int,\n):\nhighlight = self.palette().color(gui.Palette.ColorRole.Highlight)\ngradient = gui.LinearGradient(x1, y1, x2, y2)\ngradient[0] = highlight.darker(120)\ngradient[1] = highlight.lighter(108)\npainter.setBrush(gradient)\nval = 130 if orientation == \"horizontal\" else 150\npainter.set_pen(color=highlight.darker(val), width=0)\ndef _draw_span(self, painter: widgets.StylePainter, rect: core.Rect):\nopt = widgets.StyleOptionSlider()\nself.initStyleOption(opt)\npainter.set_pen(color=self.gradient_left, width=0)\ngroove = self.style().subControlRect(SLIDER_STYLE, opt, GROOVE_STYLE, self)\nif opt.is_horizontal():\ngroove.adjust(0, 0, -1, 0)\nself._setup_painter(\npainter,\nopt.get_orientation(),\ngroove.center().x(),\ngroove.top(),\ngroove.center().x(),\ngroove.bottom(),\n)\nelse:\ngroove.adjust(0, 0, 0, -1)\nself._setup_painter(\npainter,\nopt.get_orientation(),\ngroove.left(),\ngroove.center().y(),\ngroove.right(),\ngroove.center().y(),\n)\n# draw groove\nintersected = core.RectF(rect.intersected(groove))\ngradient = gui.LinearGradient(intersected.topLeft(), intersected.topRight())\ngradient[0] = self.gradient_left\ngradient[1] = self.gradient_right\npainter.fillRect(intersected, gradient)\ndef draw_handle(self, painter: widgets.StylePainter, handle: HandleStr):\nopt = self.get_style_option(handle)\nopt.subControls = HANDLE_STYLE\npressed = self.lower_pressed if handle == \"lower\" else self.upper_pressed\nif pressed == HANDLE_STYLE:\nopt.activeSubControls = pressed\nopt.state |= widgets.Style.StateFlag.State_Sunken\npainter.draw_complex_control(\"slider\", opt)\ndef get_style_option(self, handle: HandleStr) -&gt; widgets.StyleOptionSlider:\noption = widgets.StyleOptionSlider()\nself.initStyleOption(option)\nif handle == \"lower\":\noption.sliderPosition = int(self.lower_pos)\noption.sliderValue = int(self.lower_val)\nelse:\noption.sliderPosition = int(self.upper_pos)\noption.sliderValue = int(self.upper_val)\nreturn option\ndef _handle_mouse_press(\nself, pos: QtCore.QPointF, control, value: float, handle: HandleStr\n):\nopt = self.get_style_option(handle)\nold_control = control\ncontrol = self.style().hitTestComplexControl(\nSLIDER_STYLE, opt, pos.toPoint(), self\n)\nsr = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\nif control == HANDLE_STYLE:\nself.position = value\nself.offset = self.pick(pos.toPoint() - sr.topLeft())\nself.last_pressed = handle\nself.setSliderDown(True)\nself.slider_pressed.emit(handle)\nif control != old_control:\nself.update(sr)\nreturn control\ndef _pixel_pos_to_value(self, pos: int) -&gt; int:\nopt = widgets.StyleOptionSlider()\nself.initStyleOption(opt)\ngr = self.style().subControlRect(SLIDER_STYLE, opt, GROOVE_STYLE, self)\nsr = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\nif self.is_horizontal():\nlen_slider = sr.width()\nslider_min = gr.x()\nslider_end = gr.right()\nelse:\nlen_slider = sr.height()\nslider_min = gr.y()\nslider_end = gr.bottom()\nreturn widgets.Style.sliderValueFromPosition(\nself.minimum(),\nself.maximum(),\npos - slider_min,\nslider_end - len_slider + 1 - slider_min,\nopt.upsideDown,\n)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.editors.spanslider.SpanSlider.set_movement_mode","title":"<code>set_movement_mode(mode: MovementModeStr)</code>","text":"<p>Set movement mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>MovementModeStr</code> <p>movement mode for the main window</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>movement mode type does not exist</p> Source code in <code>prettyqt\\custom_widgets\\editors\\spanslider.py</code> <pre><code>def set_movement_mode(self, mode: MovementModeStr):\n\"\"\"Set movement mode.\n    Args:\n        mode: movement mode for the main window\n    Raises:\n        ValueError: movement mode type does not exist\n    \"\"\"\nif mode not in MOVEMENT_MODE:\nraise ValueError(\"Invalid movement mode\")\nself.movement = mode\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.StandardIconsWidget","title":"<code>StandardIconsWidget</code>","text":"<p>         Bases: <code>widgets.Widget</code></p> <p>Dialog showing standard icons.</p> Source code in <code>prettyqt\\custom_widgets\\standardiconswidget.py</code> <pre><code>class StandardIconsWidget(widgets.Widget):\n\"\"\"Dialog showing standard icons.\"\"\"\ndef __init__(self, parent: QtWidgets.QWidget | None = None):\nsuper().__init__(parent)\nlayout = multilinelayout.MultiLineLayout(parent=self)\nfor k in widgets.style.STANDARD_PIXMAP:\nicon_layout = widgets.HBoxLayout()\nicon = widgets.Application.get_style_icon(k)\nlabel = widgets.Label(pixmap=icon.pixmap(32, 32))\nicon_layout.addWidget(label)\nicon_layout.addWidget(widgets.LineEdit(k))\nlayout.addLayout(icon_layout)\nself.set_layout(layout)\nself.set_title(\"Standard Platform Icons\")\nicon = widgets.Application.get_style_icon(\"titlebar_menu_button\")\nself.set_icon(icon)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.SubsequenceCompleter","title":"<code>SubsequenceCompleter</code>","text":"<p>         Bases: <code>widgets.Completer</code></p> <p>QCompleter specialised for subsequence matching.</p> Source code in <code>prettyqt\\custom_widgets\\subsequencecompleter.py</code> <pre><code>class SubsequenceCompleter(widgets.Completer):\n\"\"\"QCompleter specialised for subsequence matching.\"\"\"\ndef __init__(self, *args):\nsuper().__init__(*args)\nself.completion_search_term = \"\"\nself.source_model = None\nself.set_completion_mode(\"unfiltered_popup\")\nself.proxy_model = custom_models.SubsequenceSortFilterProxyModel(parent=self)\nself.proxy_model.setFilterCaseSensitivity(self.caseSensitivity())\nself.set_case_sensitive(False)\nself._force_next_update = True\nself.path_updated.connect(self._on_path_updated)\nself.setCompletionRole(constants.DISPLAY_ROLE)\ndef setModel(self, model: QtCore.QAbstractItemModel):\nself.source_model = model\nself.proxy_model = custom_models.SubsequenceSortFilterProxyModel(parent=self)\nself.proxy_model.setFilterCaseSensitivity(self.caseSensitivity())\nself.proxy_model.set_search_term(self.completion_search_term)\nself.proxy_model.setSourceModel(self.source_model)\nsuper().setModel(self.proxy_model)\nself.proxy_model.invalidateRowsFilter()\n# self.proxy_model.sort(0)\nself._force_next_update = True\n# def __getattr__(self, key):\n#     return getattr(self.proxy_model, key)\ndef set_case_sensitive(self, value: bool):\nsuper().set_case_sensitive(value)\nself.proxy_model.set_filter_case_sensitive(value)\ndef _on_path_updated(self, path: str):\nif path == self.completion_search_term:\nreturn None\nself.completion_search_term = path\ncount = self.completionCount()\nif count or len(self.completion_search_term) &lt;= 1 or self._force_next_update:\nself.proxy_model.set_search_term(self.completion_search_term)\nif count &gt; 1:\nself.proxy_model.sort(0)\nself._force_next_update = False\nself.proxy_model.invalidateRowsFilter()  # force sorting/filtering\n</code></pre>"},{"location":"api/gui.html","title":"gui module","text":"<p>Gui module.</p> <p>Contains QtGui-based classes</p>"},{"location":"api/gui.html#prettyqt.gui.ActionGroup","title":"<code>ActionGroup</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtGui.QActionGroup</code></p> Source code in <code>prettyqt\\gui\\actiongroup.py</code> <pre><code>class ActionGroup(core.ObjectMixin, QtGui.QActionGroup):\ndef __init__(self, parent: QtCore.QObject | None = None, **kwargs):\nsuper().__init__(parent, **kwargs)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"exclusionPolicy\": EXCLUSION_POLICY}\nreturn maps\ndef __len__(self) -&gt; int:\nreturn len(self.actions())\ndef __getitem__(self, item: int) -&gt; QtGui.QAction:\nreturn self.actions()[item]\ndef set_exclusion_policy(\nself, policy: ExclusionPolicyStr | QtGui.QActionGroup.ExclusionPolicy | None\n):\n\"\"\"Set exclusion policy to use.\n        Args:\n            policy: exclusion policy to use\n        \"\"\"\nif policy is None:\npolicy = \"none\"\nself.setExclusionPolicy(EXCLUSION_POLICY.get_enum_value(policy))\ndef get_exclusion_policy(self) -&gt; ExclusionPolicyStr:\n\"\"\"Return current exclusion policy.\n        Returns:\n            exclusion policy\n        \"\"\"\nreturn EXCLUSION_POLICY.inverse[self.exclusionPolicy()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.actiongroup.ActionGroup.get_exclusion_policy","title":"<code>get_exclusion_policy() -&gt; ExclusionPolicyStr</code>","text":"<p>Return current exclusion policy.</p> <p>Returns:</p> Type Description <code>ExclusionPolicyStr</code> <p>exclusion policy</p> Source code in <code>prettyqt\\gui\\actiongroup.py</code> <pre><code>def get_exclusion_policy(self) -&gt; ExclusionPolicyStr:\n\"\"\"Return current exclusion policy.\n    Returns:\n        exclusion policy\n    \"\"\"\nreturn EXCLUSION_POLICY.inverse[self.exclusionPolicy()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.actiongroup.ActionGroup.set_exclusion_policy","title":"<code>set_exclusion_policy(policy: ExclusionPolicyStr | QtGui.QActionGroup.ExclusionPolicy | None)</code>","text":"<p>Set exclusion policy to use.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>ExclusionPolicyStr | QtGui.QActionGroup.ExclusionPolicy | None</code> <p>exclusion policy to use</p> required Source code in <code>prettyqt\\gui\\actiongroup.py</code> <pre><code>def set_exclusion_policy(\nself, policy: ExclusionPolicyStr | QtGui.QActionGroup.ExclusionPolicy | None\n):\n\"\"\"Set exclusion policy to use.\n    Args:\n        policy: exclusion policy to use\n    \"\"\"\nif policy is None:\npolicy = \"none\"\nself.setExclusionPolicy(EXCLUSION_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.ActionMixin","title":"<code>ActionMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\gui\\action.py</code> <pre><code>class ActionMixin(core.ObjectMixin):\ndef __init__(\nself,\n*args,\ntext: str | None = None,\nicon: datatypes.IconType = None,\ncallback: Callable | None = None,\n**kwargs,\n):\nsuper().__init__(*args, **kwargs)\nif callback is not None:\nself.triggered.connect(callback)\nself._usage_count = 0\nif text:\nself.setText(text)\nif icon:\nself.set_icon(icon)\nself.triggered.connect(self._increase_usage_counter)\ndef __repr__(self) -&gt; str:\nreturn get_repr(self, self.text())\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"priority\": PRIORITIES,\n\"shortcutContext\": constants.SHORTCUT_CONTEXT,\n\"menuRole\": ROLES,\n}\nreturn maps\ndef _increase_usage_counter(self):\nself._usage_count += 1\ndef get_usage_count(self) -&gt; int:\nreturn self._usage_count\ndef get_type(self) -&gt; Literal[\"menu\", \"separator\", \"widget\", \"regular\"]:\nif self.menu() is not None:\nreturn \"menu\"\nelif self.isSeparator():\nreturn \"separator\"\nelif hasattr(self, \"defaultWidget\"):\nreturn \"widget\"\nelse:\nreturn \"regular\"\ndef set_disabled(self):\nself.setEnabled(False)\ndef set_enabled(self, enabled: bool = True):\nself.setEnabled(enabled)\ndef set_tooltip(\nself,\ntooltip: str | datatypes.PathType,\nsize: datatypes.SizeType | None = None,\nrich_text: bool = False,\n):\nif isinstance(tooltip, os.PathLike):\npath = os.fspath(tooltip)\nif size is None:\ntooltip = f\"&lt;img src={path!r}&gt;\"\nelse:\nif isinstance(size, QtCore.QSize):\nsize = (size.width(), size.height())\ntooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\ntooltip = tooltip.replace(\"\\n\", \"&lt;br/&gt;\")\nif rich_text:\ntooltip = f\"&lt;html&gt;{html.escape(tooltip)}&lt;/html&gt;\"\nsuper().setToolTip(tooltip)\nsetToolTip = set_tooltip\ndef set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n        Args:\n            icon: icon to use\n        \"\"\"\nicon = iconprovider.get_icon(icon)\nsuper().setIcon(icon)\nsetIcon = set_icon\ndef set_shortcut(self, shortcut: None | QtGui.QKeySequence | str):\nif shortcut is None:\nshortcut = \"\"\nif isinstance(shortcut, str):\nshortcut = gui.KeySequence(\nshortcut, gui.KeySequence.SequenceFormat.PortableText\n)\nsuper().setShortcut(shortcut)\nsetShortcut = set_shortcut\ndef setText(self, text: str | None):\nsuper().setText(text or \"\")\ndef get_icon(self) -&gt; gui.Icon | None:\nicon = self.icon()\nreturn None if icon.isNull() else gui.Icon(icon)\ndef get_shortcut(self) -&gt; gui.KeySequence | None:\nshortcut = self.shortcut()\nreturn (\ngui.KeySequence(\nshortcut.toString(), gui.KeySequence.SequenceFormat.PortableText\n)\nif shortcut\nelse None\n)\ndef get_font(self) -&gt; gui.Font:\nreturn gui.Font(self.font())\ndef set_menu(self, menu):\nself.setMenu(menu)\ndef set_priority(self, priority: PriorityStr | QtGui.QAction.Priority):\n\"\"\"Set priority of the action.\n        Args:\n            priority: priority for the action\n        \"\"\"\nsuper().setPriority(PRIORITIES.get_enum_value(priority))\nsetPriority = set_priority\ndef get_priority(self) -&gt; PriorityStr:\n\"\"\"Return current priority.\n        Returns:\n            priority\n        \"\"\"\nreturn PRIORITIES.inverse[self.priority()]\ndef set_shortcut_context(\nself, context: constants.ShortcutContextStr | constants.ShortcutContext\n):\n\"\"\"Set shortcut context.\n        Args:\n            context: shortcut context\n        \"\"\"\nsuper().setShortcutContext(constants.SHORTCUT_CONTEXT.get_enum_value(context))\nsetShortcutContext = set_shortcut_context\ndef get_shortcut_context(self) -&gt; constants.ShortcutContextStr:\n\"\"\"Return shortcut context.\n        Returns:\n            shortcut context\n        \"\"\"\nreturn constants.SHORTCUT_CONTEXT.inverse[super().shortcutContext()]\ndef set_menu_role(self, role: RoleStr | QtGui.QAction.MenuRole):\n\"\"\"Set menu role.\n        Args:\n            role: menu role\n        \"\"\"\nsuper().setMenuRole(ROLES.get_enum_value(role))\nsetMenuRole = set_menu_role\ndef get_menu_role(self) -&gt; RoleStr:\n\"\"\"Return menu role.\n        Returns:\n            menu role\n        \"\"\"\nreturn ROLES.inverse[super().menuRole()]\ndef show_shortcut_in_contextmenu(self, state: bool = True):\nself.setShortcutVisibleInContextMenu(state)\nusage_count = core.Property(int, get_usage_count)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.action.ActionMixin.get_menu_role","title":"<code>get_menu_role() -&gt; RoleStr</code>","text":"<p>Return menu role.</p> <p>Returns:</p> Type Description <code>RoleStr</code> <p>menu role</p> Source code in <code>prettyqt\\gui\\action.py</code> <pre><code>def get_menu_role(self) -&gt; RoleStr:\n\"\"\"Return menu role.\n    Returns:\n        menu role\n    \"\"\"\nreturn ROLES.inverse[super().menuRole()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.action.ActionMixin.get_priority","title":"<code>get_priority() -&gt; PriorityStr</code>","text":"<p>Return current priority.</p> <p>Returns:</p> Type Description <code>PriorityStr</code> <p>priority</p> Source code in <code>prettyqt\\gui\\action.py</code> <pre><code>def get_priority(self) -&gt; PriorityStr:\n\"\"\"Return current priority.\n    Returns:\n        priority\n    \"\"\"\nreturn PRIORITIES.inverse[self.priority()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.action.ActionMixin.get_shortcut_context","title":"<code>get_shortcut_context() -&gt; constants.ShortcutContextStr</code>","text":"<p>Return shortcut context.</p> <p>Returns:</p> Type Description <code>constants.ShortcutContextStr</code> <p>shortcut context</p> Source code in <code>prettyqt\\gui\\action.py</code> <pre><code>def get_shortcut_context(self) -&gt; constants.ShortcutContextStr:\n\"\"\"Return shortcut context.\n    Returns:\n        shortcut context\n    \"\"\"\nreturn constants.SHORTCUT_CONTEXT.inverse[super().shortcutContext()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.action.ActionMixin.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\gui\\action.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n    Args:\n        icon: icon to use\n    \"\"\"\nicon = iconprovider.get_icon(icon)\nsuper().setIcon(icon)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.action.ActionMixin.set_menu_role","title":"<code>set_menu_role(role: RoleStr | QtGui.QAction.MenuRole)</code>","text":"<p>Set menu role.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>RoleStr | QtGui.QAction.MenuRole</code> <p>menu role</p> required Source code in <code>prettyqt\\gui\\action.py</code> <pre><code>def set_menu_role(self, role: RoleStr | QtGui.QAction.MenuRole):\n\"\"\"Set menu role.\n    Args:\n        role: menu role\n    \"\"\"\nsuper().setMenuRole(ROLES.get_enum_value(role))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.action.ActionMixin.set_priority","title":"<code>set_priority(priority: PriorityStr | QtGui.QAction.Priority)</code>","text":"<p>Set priority of the action.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>PriorityStr | QtGui.QAction.Priority</code> <p>priority for the action</p> required Source code in <code>prettyqt\\gui\\action.py</code> <pre><code>def set_priority(self, priority: PriorityStr | QtGui.QAction.Priority):\n\"\"\"Set priority of the action.\n    Args:\n        priority: priority for the action\n    \"\"\"\nsuper().setPriority(PRIORITIES.get_enum_value(priority))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.action.ActionMixin.set_shortcut_context","title":"<code>set_shortcut_context(context: constants.ShortcutContextStr | constants.ShortcutContext)</code>","text":"<p>Set shortcut context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>constants.ShortcutContextStr | constants.ShortcutContext</code> <p>shortcut context</p> required Source code in <code>prettyqt\\gui\\action.py</code> <pre><code>def set_shortcut_context(\nself, context: constants.ShortcutContextStr | constants.ShortcutContext\n):\n\"\"\"Set shortcut context.\n    Args:\n        context: shortcut context\n    \"\"\"\nsuper().setShortcutContext(constants.SHORTCUT_CONTEXT.get_enum_value(context))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Color","title":"<code>Color</code>","text":"<p>         Bases: <code>QtGui.QColor</code></p> Source code in <code>prettyqt\\gui\\color.py</code> <pre><code>class Color(QtGui.QColor):\ndef __init__(self, *args):\nmatch args:\ncase (QtGui.QColor(),):\nsuper().__init__()\nself.setRgba(args[0].rgba())\ncase (str(),):\nif not is_valid_color(args[0]):\nraise ValueError(args[0])\nsuper().__init__(args[0])\ncase _:\nsuper().__init__(*args)\ndef __repr__(self):\nreturn get_repr(self, self.red(), self.green(), self.blue(), self.alpha())\ndef __str__(self):\nreturn self.name() if self.alpha() == 255 else self.name(self.NameFormat.HexArgb)\ndef __reduce__(self):\nreturn type(self), (self.red(), self.green(), self.blue(), self.alpha())\ndef __format__(self, format_spec: NameStr):\ntry:\nreturn self.get_name(format_spec)\nexcept ValueError:\nreturn super().__format__(format_spec)\n@property\ndef _red(self) -&gt; int:\nreturn self.red()\n@property\ndef _green(self) -&gt; int:\nreturn self.green()\n@property\ndef _blue(self) -&gt; int:\nreturn self.blue()\n@property\ndef _alpha(self) -&gt; int:\nreturn self.alpha()\n__match_args__ = (\"_red\", \"_green\", \"_blue\", \"_alpha\")\ndef serialize(self) -&gt; dict[str, Any]:\nreturn dict(color=self.name())\ndef set_color(self, color: str | tuple):\nif isinstance(color, str):\nself.setNamedColor(color)\nelse:\nself.setRgb(*color)\n@classmethod\ndef from_cmyk(cls, c: float, m: float, y: float, k: float, a: float = 1.0) -&gt; Self:\nreturn cls(cls.fromCmykF(c, m, y, k, a))\n@classmethod\ndef from_hsv(cls, h: float, s: float, v: float, a: float = 1.0) -&gt; Self:\nreturn cls(cls.fromHsvF(h, s, v, a))\n@classmethod\ndef interpolate_color(\ncls,\nstart: QtGui.QColor,\nend: QtGui.QColor,\npercent: int,\ncolorspace: SpecStr | None = \"rgb\",\n) -&gt; Self:\n\"\"\"Get an interpolated color value.\n        Args:\n            start: The start color.\n            end: The end color.\n            percent: Which value to get (0 - 100)\n            colorspace: The desired interpolation color system,\n                        QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum)\n                        If None, start is used except when percent is 100.\n        Return:\n            The interpolated QColor, with the same spec as the given start color.\n        \"\"\"\nif colorspace is None:\nreturn cls(*end.getRgb()) if percent == 100 else cls(*start.getRgb())\nout = cls()\nmatch colorspace:\ncase \"rgb\":\ncomponents = helpers.get_color_percentage(\nstart.getRgb(), end.getRgb(), percent  # type: ignore\n)\nout.setRgb(*components)\ncase \"hsv\":\ncomponents = helpers.get_color_percentage(\nstart.getHsv(), end.getHsv(), percent  # type: ignore\n)\nout.setHsv(*components)\ncase \"hsl\":\ncomponents = helpers.get_color_percentage(\nstart.getHsl(), end.getHsl(), percent  # type: ignore\n)\nout.setHsl(*components)\ncase _:\nraise ValueError(\"Invalid colorspace!\")\nreturn cls(out.convertTo(start.spec()))\ndef is_dark(self) -&gt; bool:\n\"\"\"Check whether a color is 'dark'.\"\"\"\nreturn self.lightness() &lt; 128\ndef get_spec(self) -&gt; SpecStr:\nreturn SPEC.inverse[self.spec()]\ndef convert_to(self, spec: SpecStr) -&gt; Self:\n# return Color(self.convertTo(SPEC[spec]))\ncolor = type(self)()\nmatch spec:\ncase \"rgb\":\nrgb = self.getRgb()\ncolor.setRgb(*rgb)\ncase \"hsv\":\nhsv = self.getHsv()\ncolor.setHsv(*hsv)\ncase \"cmyk\":\ncmyk = self.getCmyk()\ncolor.setCmyk(*cmyk)\ncase \"hsl\":\nhsl = self.getHsl()\ncolor.setHsl(*hsl)\ncase \"extended_rgb\":\nergb = self.getRgbF()\ncolor.setRgbF(*ergb)\nreturn color\ndef get_name(self, name_format: NameStr = \"hex_argb\") -&gt; str:\nmatch name_format:\ncase \"svg_rgb\" | \"svg_argb\" if not self.isValid():\nreturn 'fill=\"\"'\ncase \"svg_rgb\":\nreturn f'fill=\"rgb({self.red()}, {self.green()}, {self.blue()})\"'\ncase \"svg_argb\":\nfill_str = f\"rgb({self.red()}, {self.green()}, {self.blue()})\"\nreturn f'fill=\"{fill_str}\" fill-opacity=\"{self.alpha()}\"'\ncase \"qcss_argb\":\nreturn (\nf\"rgba({self.red()}, {self.green()}, {self.blue()}, {self.alpha()})\"\n)\ncase \"qcss_rgb\":\nreturn f\"rgb({self.red()}, {self.green()}, {self.blue()})\"\ncase _ if name_format in NAME_FORMAT:\nreturn self.name(NAME_FORMAT[name_format])\ncase _:\nraise ValueError(name_format)\ndef as_qt(self) -&gt; QtGui.QColor:\nreturn self.convertTo(self.spec())\ndef inverted(self, invert_alpha: bool = False) -&gt; Self:\nreturn type(self)(\n255 - self.red(),\n255 - self.green(),\n255 - self.blue(),\n255 - self.alpha() if invert_alpha else self.alpha(),\n)\ndef drift(self, factor: int = 1.0) -&gt; Self:\n\"\"\"Return color that is lighter or darker than the base color.\"\"\"\nCls = type(self)\nif self == Color(\"#000000\"):\nreturn Cls(Color(\"#050505\").lighter(int(factor * 100)))\nelif self.lightness() &gt; 128:\nreturn Cls(self.darker(int(factor * 100)))\nelse:\nreturn Cls(self.lighter(int(factor * 100)))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.drift","title":"<code>drift(factor: int = 1.0) -&gt; Self</code>","text":"<p>Return color that is lighter or darker than the base color.</p> Source code in <code>prettyqt\\gui\\color.py</code> <pre><code>def drift(self, factor: int = 1.0) -&gt; Self:\n\"\"\"Return color that is lighter or darker than the base color.\"\"\"\nCls = type(self)\nif self == Color(\"#000000\"):\nreturn Cls(Color(\"#050505\").lighter(int(factor * 100)))\nelif self.lightness() &gt; 128:\nreturn Cls(self.darker(int(factor * 100)))\nelse:\nreturn Cls(self.lighter(int(factor * 100)))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.interpolate_color","title":"<code>interpolate_color(start: QtGui.QColor, end: QtGui.QColor, percent: int, colorspace: SpecStr | None = 'rgb') -&gt; Self</code>  <code>classmethod</code>","text":"<p>Get an interpolated color value.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>QtGui.QColor</code> <p>The start color.</p> required <code>end</code> <code>QtGui.QColor</code> <p>The end color.</p> required <code>percent</code> <code>int</code> <p>Which value to get (0 - 100)</p> required <code>colorspace</code> <code>SpecStr | None</code> <p>The desired interpolation color system,         QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum)         If None, start is used except when percent is 100.</p> <code>'rgb'</code> Return <p>The interpolated QColor, with the same spec as the given start color.</p> Source code in <code>prettyqt\\gui\\color.py</code> <pre><code>@classmethod\ndef interpolate_color(\ncls,\nstart: QtGui.QColor,\nend: QtGui.QColor,\npercent: int,\ncolorspace: SpecStr | None = \"rgb\",\n) -&gt; Self:\n\"\"\"Get an interpolated color value.\n    Args:\n        start: The start color.\n        end: The end color.\n        percent: Which value to get (0 - 100)\n        colorspace: The desired interpolation color system,\n                    QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum)\n                    If None, start is used except when percent is 100.\n    Return:\n        The interpolated QColor, with the same spec as the given start color.\n    \"\"\"\nif colorspace is None:\nreturn cls(*end.getRgb()) if percent == 100 else cls(*start.getRgb())\nout = cls()\nmatch colorspace:\ncase \"rgb\":\ncomponents = helpers.get_color_percentage(\nstart.getRgb(), end.getRgb(), percent  # type: ignore\n)\nout.setRgb(*components)\ncase \"hsv\":\ncomponents = helpers.get_color_percentage(\nstart.getHsv(), end.getHsv(), percent  # type: ignore\n)\nout.setHsv(*components)\ncase \"hsl\":\ncomponents = helpers.get_color_percentage(\nstart.getHsl(), end.getHsl(), percent  # type: ignore\n)\nout.setHsl(*components)\ncase _:\nraise ValueError(\"Invalid colorspace!\")\nreturn cls(out.convertTo(start.spec()))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.is_dark","title":"<code>is_dark() -&gt; bool</code>","text":"<p>Check whether a color is 'dark'.</p> Source code in <code>prettyqt\\gui\\color.py</code> <pre><code>def is_dark(self) -&gt; bool:\n\"\"\"Check whether a color is 'dark'.\"\"\"\nreturn self.lightness() &lt; 128\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.ColorSpace","title":"<code>ColorSpace</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QColorSpace</code></p> Source code in <code>prettyqt\\gui\\colorspace.py</code> <pre><code>class ColorSpace(serializemixin.SerializeMixin, QtGui.QColorSpace):\ndef __bool__(self):\nreturn self.isValid()\ndef set_primaries(self, primaries: PrimariesStr | QtGui.QColorSpace.Primaries):\n\"\"\"Set primaries.\n        Args:\n            primaries: primaries to use\n        \"\"\"\nself.setPrimaries(PRIMARIES.get_enum_value(primaries))\ndef get_primaries(self) -&gt; PrimariesStr:\n\"\"\"Return current primaries.\n        Returns:\n            primaries\n        \"\"\"\nreturn PRIMARIES.inverse[self.primaries()]\ndef set_transfer_function(\nself,\nfn: TransformFunctionStr | QtGui.QColorSpace.TransferFunction,\ngamma: float = 0.0,\n):\n\"\"\"Set transfer function.\n        Args:\n            fn: transfer function to use\n            gamma: gamma value\n        \"\"\"\nself.setTransferFunction(TRANSFER_FUNCTION.get_enum_value(fn), gamma)\ndef get_transfer_function(self) -&gt; TransformFunctionStr:\n\"\"\"Return current transfer function.\n        Returns:\n            transfer function\n        \"\"\"\nreturn TRANSFER_FUNCTION.inverse[self.transferFunction()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_primaries","title":"<code>get_primaries() -&gt; PrimariesStr</code>","text":"<p>Return current primaries.</p> <p>Returns:</p> Type Description <code>PrimariesStr</code> <p>primaries</p> Source code in <code>prettyqt\\gui\\colorspace.py</code> <pre><code>def get_primaries(self) -&gt; PrimariesStr:\n\"\"\"Return current primaries.\n    Returns:\n        primaries\n    \"\"\"\nreturn PRIMARIES.inverse[self.primaries()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_transfer_function","title":"<code>get_transfer_function() -&gt; TransformFunctionStr</code>","text":"<p>Return current transfer function.</p> <p>Returns:</p> Type Description <code>TransformFunctionStr</code> <p>transfer function</p> Source code in <code>prettyqt\\gui\\colorspace.py</code> <pre><code>def get_transfer_function(self) -&gt; TransformFunctionStr:\n\"\"\"Return current transfer function.\n    Returns:\n        transfer function\n    \"\"\"\nreturn TRANSFER_FUNCTION.inverse[self.transferFunction()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_primaries","title":"<code>set_primaries(primaries: PrimariesStr | QtGui.QColorSpace.Primaries)</code>","text":"<p>Set primaries.</p> <p>Parameters:</p> Name Type Description Default <code>primaries</code> <code>PrimariesStr | QtGui.QColorSpace.Primaries</code> <p>primaries to use</p> required Source code in <code>prettyqt\\gui\\colorspace.py</code> <pre><code>def set_primaries(self, primaries: PrimariesStr | QtGui.QColorSpace.Primaries):\n\"\"\"Set primaries.\n    Args:\n        primaries: primaries to use\n    \"\"\"\nself.setPrimaries(PRIMARIES.get_enum_value(primaries))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_transfer_function","title":"<code>set_transfer_function(fn: TransformFunctionStr | QtGui.QColorSpace.TransferFunction, gamma: float = 0.0)</code>","text":"<p>Set transfer function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>TransformFunctionStr | QtGui.QColorSpace.TransferFunction</code> <p>transfer function to use</p> required <code>gamma</code> <code>float</code> <p>gamma value</p> <code>0.0</code> Source code in <code>prettyqt\\gui\\colorspace.py</code> <pre><code>def set_transfer_function(\nself,\nfn: TransformFunctionStr | QtGui.QColorSpace.TransferFunction,\ngamma: float = 0.0,\n):\n\"\"\"Set transfer function.\n    Args:\n        fn: transfer function to use\n        gamma: gamma value\n    \"\"\"\nself.setTransferFunction(TRANSFER_FUNCTION.get_enum_value(fn), gamma)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Cursor","title":"<code>Cursor</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QCursor</code></p> Source code in <code>prettyqt\\gui\\cursor.py</code> <pre><code>class Cursor(serializemixin.SerializeMixin, QtGui.QCursor):\n@classmethod\ndef fake_mouse_move(cls):\ncls.setPos(cls.pos() + core.Point(0, 1))\ngui.Application.processEvents()\ncls.setPos(cls.pos() - core.Point(0, 1))\n@classmethod\ndef click(cls, key=constants.MouseButton.LeftButton):\nfrom prettyqt import widgets\napp = widgets.app()\nwidget = app.widgetAt(cls.pos())\nif widget is None:\nreturn\npos = cls.pos().toPointF()\nlocal = pos - widget.mapToGlobal(core.PointF(0, 0))\nlogger.info(f\"sending MouseClick events to {widget} at {local}\")\nevent = gui.QMouseEvent(\nQtCore.QEvent.Type.MouseButtonPress,\nlocal,\npos,\nkey,\nconstants.MouseButton.NoButton,\nconstants.KeyboardModifier(0),\n)\ncore.CoreApplication.sendEvent(widget, event)\nevent = gui.QMouseEvent(\nQtCore.QEvent.Type.MouseButtonRelease,\nlocal,\npos,\nkey,\nconstants.MouseButton.NoButton,\nconstants.KeyboardModifier(0),\n)\ncore.CoreApplication.sendEvent(widget, event)\ndef set_shape(self, shape: constants.CursorShapeStr):\n\"\"\"Set cursor shape.\n        Args:\n            shape: shape to use\n        \"\"\"\nself.setShape(constants.CURSOR_SHAPE.get_enum_value(shape))\ndef get_shape(self) -&gt; constants.CursorShapeStr:\n\"\"\"Return current cursor shape.\n        Returns:\n            cursor shape\n        \"\"\"\nreturn constants.CURSOR_SHAPE.inverse[self.shape()]\n@classmethod\ndef get_pos(cls) -&gt; core.Point:\nreturn core.Point(cls.pos())\n@classmethod\ndef set_pos(\ncls,\nwhere: Literal[\"screen\", \"current\"] | QtGui.QScreen\n# | QtWidgets.QWidget\n| QtCore.QRect | QtCore.QPoint | tuple[int, int] | tuple[int, int, int, int],\nhow: Literal[\n\"center\",\n\"top\",\n\"left\",\n\"bottom\",\n\"right\",\n\"top_left\",\n\"top_right\",\n\"bottom_left\",\n\"bottom_right\",\n] = \"center\",\nx_offset: int = 0,\ny_offset: int = 0,\nduration: int = 0,\n):\n\"\"\"Position cursor onto screen position / widget / window / screen.\n        Arguments:\n            where: where to position on\n            how: How to align\n            x_offset: additional x offset for final position\n            y_offset: additional y offset for final position\n            duration: movement time\n        \"\"\"\nmatch where:\ncase \"current\":\np = cls.pos()\ngeom = core.Rect(p, p)\ncase QtCore.QPoint():\ngeom = core.Rect(where, where)\ncase (int(), int()):\np = core.Point(*where)\ngeom = core.Rect(p, p)\ncase (int(), int(), int(), int()):\ngeom = core.Rect(*where)\ncase QtCore.QRect():\ngeom = where\ncase \"screen\":\ngeom = gui.GuiApplication.primaryScreen().geometry()\ncase QtGui.QScreen():\ngeom = where.geometry()\ncase _:  # not wanting to import QtWidgets here... perhaps create a protocol.\ngeom = where.frameGeometry()\nmatch how:\ncase \"center\":\nnew = geom.center()\ncase \"top\":\nnew = core.Point(geom.center().x(), geom.top())\ncase \"bottom\":\nnew = core.Point(geom.center().x(), geom.bottom())\ncase \"left\":\nnew = core.Point(geom.left(), geom.center().y())\ncase \"right\":\nnew = core.Point(geom.right(), geom.center().y())\ncase \"top_right\":\nnew = geom.topRight()\ncase \"top_left\":\nnew = geom.topLeft()\ncase \"bottom_right\":\nnew = geom.bottomRight()\ncase \"bottom_left\":\nnew = geom.bottomLeft()\nnew_pos = core.Point(new.x() + x_offset, new.y() + y_offset)\nif duration &gt; 0:\nfrom prettyqt.custom_animations import cursormoveanimation\ncls._cursor_animation = cursormoveanimation.CursorMoveAnimation(\nduration=duration, end=new_pos\n)\ncls._cursor_animation.start()\nelse:\ncls.setPos(new_pos)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.get_shape","title":"<code>get_shape() -&gt; constants.CursorShapeStr</code>","text":"<p>Return current cursor shape.</p> <p>Returns:</p> Type Description <code>constants.CursorShapeStr</code> <p>cursor shape</p> Source code in <code>prettyqt\\gui\\cursor.py</code> <pre><code>def get_shape(self) -&gt; constants.CursorShapeStr:\n\"\"\"Return current cursor shape.\n    Returns:\n        cursor shape\n    \"\"\"\nreturn constants.CURSOR_SHAPE.inverse[self.shape()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.set_pos","title":"<code>set_pos(where: Literal['screen', 'current'] | QtGui.QScreen | QtCore.QRect | QtCore.QPoint | tuple[int, int] | tuple[int, int, int, int], how: Literal['center', 'top', 'left', 'bottom', 'right', 'top_left', 'top_right', 'bottom_left', 'bottom_right'] = 'center', x_offset: int = 0, y_offset: int = 0, duration: int = 0)</code>  <code>classmethod</code>","text":"<p>Position cursor onto screen position / widget / window / screen.</p> <p>Parameters:</p> Name Type Description Default <code>where</code> <code>Literal['screen', 'current'] | QtGui.QScreen | QtCore.QRect | QtCore.QPoint | tuple[int, int] | tuple[int, int, int, int]</code> <p>where to position on</p> required <code>how</code> <code>Literal['center', 'top', 'left', 'bottom', 'right', 'top_left', 'top_right', 'bottom_left', 'bottom_right']</code> <p>How to align</p> <code>'center'</code> <code>x_offset</code> <code>int</code> <p>additional x offset for final position</p> <code>0</code> <code>y_offset</code> <code>int</code> <p>additional y offset for final position</p> <code>0</code> <code>duration</code> <code>int</code> <p>movement time</p> <code>0</code> Source code in <code>prettyqt\\gui\\cursor.py</code> <pre><code>@classmethod\ndef set_pos(\ncls,\nwhere: Literal[\"screen\", \"current\"] | QtGui.QScreen\n# | QtWidgets.QWidget\n| QtCore.QRect | QtCore.QPoint | tuple[int, int] | tuple[int, int, int, int],\nhow: Literal[\n\"center\",\n\"top\",\n\"left\",\n\"bottom\",\n\"right\",\n\"top_left\",\n\"top_right\",\n\"bottom_left\",\n\"bottom_right\",\n] = \"center\",\nx_offset: int = 0,\ny_offset: int = 0,\nduration: int = 0,\n):\n\"\"\"Position cursor onto screen position / widget / window / screen.\n    Arguments:\n        where: where to position on\n        how: How to align\n        x_offset: additional x offset for final position\n        y_offset: additional y offset for final position\n        duration: movement time\n    \"\"\"\nmatch where:\ncase \"current\":\np = cls.pos()\ngeom = core.Rect(p, p)\ncase QtCore.QPoint():\ngeom = core.Rect(where, where)\ncase (int(), int()):\np = core.Point(*where)\ngeom = core.Rect(p, p)\ncase (int(), int(), int(), int()):\ngeom = core.Rect(*where)\ncase QtCore.QRect():\ngeom = where\ncase \"screen\":\ngeom = gui.GuiApplication.primaryScreen().geometry()\ncase QtGui.QScreen():\ngeom = where.geometry()\ncase _:  # not wanting to import QtWidgets here... perhaps create a protocol.\ngeom = where.frameGeometry()\nmatch how:\ncase \"center\":\nnew = geom.center()\ncase \"top\":\nnew = core.Point(geom.center().x(), geom.top())\ncase \"bottom\":\nnew = core.Point(geom.center().x(), geom.bottom())\ncase \"left\":\nnew = core.Point(geom.left(), geom.center().y())\ncase \"right\":\nnew = core.Point(geom.right(), geom.center().y())\ncase \"top_right\":\nnew = geom.topRight()\ncase \"top_left\":\nnew = geom.topLeft()\ncase \"bottom_right\":\nnew = geom.bottomRight()\ncase \"bottom_left\":\nnew = geom.bottomLeft()\nnew_pos = core.Point(new.x() + x_offset, new.y() + y_offset)\nif duration &gt; 0:\nfrom prettyqt.custom_animations import cursormoveanimation\ncls._cursor_animation = cursormoveanimation.CursorMoveAnimation(\nduration=duration, end=new_pos\n)\ncls._cursor_animation.start()\nelse:\ncls.setPos(new_pos)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.set_shape","title":"<code>set_shape(shape: constants.CursorShapeStr)</code>","text":"<p>Set cursor shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>constants.CursorShapeStr</code> <p>shape to use</p> required Source code in <code>prettyqt\\gui\\cursor.py</code> <pre><code>def set_shape(self, shape: constants.CursorShapeStr):\n\"\"\"Set cursor shape.\n    Args:\n        shape: shape to use\n    \"\"\"\nself.setShape(constants.CURSOR_SHAPE.get_enum_value(shape))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Font","title":"<code>Font</code>","text":"<p>         Bases: <code>QtGui.QFont</code></p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>class Font(QtGui.QFont):\ndef __repr__(self):\nreturn get_repr(\nself, self.family(), self.pointSize(), self.weight(), self.italic()\n)\ndef __getstate__(self):\nreturn dict(\nfamily=self.family(),\npointsize=self.pointSize(),\nweight=self.weight(),\nitalic=self.italic(),\n)\ndef __setstate__(self, state):\nself.setFamily(state[\"family\"])\nif state[\"pointsize\"] &gt; -1:\nself.setPointSize(state[\"pointsize\"])\nself.setWeight(state[\"weight\"])\nself.setItalic(state[\"italic\"])\n@property\ndef _family(self) -&gt; str:\nreturn self.family()\n__match_args__ = (\"_family\",)\ndef __reduce__(self):\nreturn type(self), (), self.__getstate__()\ndef serialize(self) -&gt; dict[str, Any]:\nreturn self.__getstate__()\n@property\ndef metrics(self) -&gt; gui.FontMetrics:\nreturn gui.FontMetrics(self)\ndef set_size(self, size: int):\nself.setPointSize(size)\n@classmethod\ndef mono(cls, size=8, as_qt: bool = False) -&gt; Self:\nmatch sys.platform:\ncase \"win32\":\nfont = \"Consolas\"\ncase \"darwin\":\nfont = \"Menlo\"\ncase _:\nfont = \"Monospace\"\nif as_qt:\nreturn QtGui.QFont(font)\nelse:\nreturn cls(font, size)\n# font.setStyleHint()\ndef scaled(self, factor: float) -&gt; Self:\nscaled = type(self)(self)\nif self.pointSizeF() != -1:\nscaled.setPointSizeF(self.pointSizeF() * factor)\nelif self.pixelSize() != -1:\nscaled.setPixelSize(int(self.pixelSize() * factor))\nreturn scaled\ndef set_style_hint(self, hint: StyleHintStr | QtGui.QFont.StyleHint):\n\"\"\"Set the style hint.\n        Args:\n            hint: style hint\n        \"\"\"\nself.setStyleHint(STYLE_HINTS.get_enum_value(hint))\ndef set_weight(self, weight: WeightStr | QtGui.QFont.Weight):\n\"\"\"Set the font weight.\n        Args:\n            weight: font weight\n        \"\"\"\nself.setWeight(WEIGHT.get_enum_value(weight))\ndef get_weight(self) -&gt; WeightStr:\n\"\"\"Get current font weight.\n        Returns:\n            current font weight\n        \"\"\"\nreturn WEIGHT.inverse[self.weight()]\ndef set_capitalization(\nself, capitalization: CapitalizationStr | gui.Font.Capitalization\n):\n\"\"\"Set the font capitalization.\n        Args:\n            capitalization: font capitalization\n        \"\"\"\nself.setCapitalization(CAPITALIZATION.get_enum_value(capitalization))\ndef get_capitalization(self) -&gt; CapitalizationStr:\n\"\"\"Get current font capitalization.\n        Returns:\n            current font capitalization\n        \"\"\"\nreturn CAPITALIZATION.inverse[self.capitalization()]\ndef set_hinting_preference(\nself, preference: HintingPreferenceStr | gui.Font.HintingPreference\n):\n\"\"\"Set the hinting preference.\n        Args:\n            preference: hinting preference\n        \"\"\"\nself.setHintingPreference(HINTING_PREFERENCE.get_enum_value(preference))\ndef get_hinting_preference(self) -&gt; HintingPreferenceStr:\n\"\"\"Get current hinting preference.\n        Returns:\n            current hinting preference\n        \"\"\"\nreturn HINTING_PREFERENCE.inverse[self.hintingPreference()]\ndef set_letter_spacing(\nself, typ: SpacingTypeStr | gui.Font.SpacingType, spacing: float\n):\n\"\"\"Set the letter spacing.\n        Args:\n            typ: letter spacing type\n            spacing: spacing\n        \"\"\"\nself.setLetterSpacing(SPACING_TYPE.get_enum_value(typ), spacing)\ndef get_letter_spacing_type(self) -&gt; SpacingTypeStr:\n\"\"\"Get current letter spacing type.\n        Returns:\n            current letter spacing type\n        \"\"\"\nreturn SPACING_TYPE.inverse[self.letterSpacingType()]\ndef set_style(self, style: StyleStr | gui.Font.Style):\n\"\"\"Set the font style.\n        Args:\n            style: font style\n        \"\"\"\nself.setStyle(STYLE.get_enum_value(style))\ndef get_style(self) -&gt; StyleStr:\n\"\"\"Get current font style.\n        Returns:\n            current font style\n        \"\"\"\nreturn STYLE.inverse[self.style()]\ndef set_family(self, family: str, fallback: str | None = None):\n\"\"\"Set the font family.\n        Args:\n            family: font family\n            fallback: fallback font family\n        \"\"\"\nself.setFamily(family)\nfont_info = gui.FontInfo(self)\nif fallback is not None and font_info.family() != family:\nself.setFamily(fallback)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_capitalization","title":"<code>get_capitalization() -&gt; CapitalizationStr</code>","text":"<p>Get current font capitalization.</p> <p>Returns:</p> Type Description <code>CapitalizationStr</code> <p>current font capitalization</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def get_capitalization(self) -&gt; CapitalizationStr:\n\"\"\"Get current font capitalization.\n    Returns:\n        current font capitalization\n    \"\"\"\nreturn CAPITALIZATION.inverse[self.capitalization()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_hinting_preference","title":"<code>get_hinting_preference() -&gt; HintingPreferenceStr</code>","text":"<p>Get current hinting preference.</p> <p>Returns:</p> Type Description <code>HintingPreferenceStr</code> <p>current hinting preference</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def get_hinting_preference(self) -&gt; HintingPreferenceStr:\n\"\"\"Get current hinting preference.\n    Returns:\n        current hinting preference\n    \"\"\"\nreturn HINTING_PREFERENCE.inverse[self.hintingPreference()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_letter_spacing_type","title":"<code>get_letter_spacing_type() -&gt; SpacingTypeStr</code>","text":"<p>Get current letter spacing type.</p> <p>Returns:</p> Type Description <code>SpacingTypeStr</code> <p>current letter spacing type</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def get_letter_spacing_type(self) -&gt; SpacingTypeStr:\n\"\"\"Get current letter spacing type.\n    Returns:\n        current letter spacing type\n    \"\"\"\nreturn SPACING_TYPE.inverse[self.letterSpacingType()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_style","title":"<code>get_style() -&gt; StyleStr</code>","text":"<p>Get current font style.</p> <p>Returns:</p> Type Description <code>StyleStr</code> <p>current font style</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def get_style(self) -&gt; StyleStr:\n\"\"\"Get current font style.\n    Returns:\n        current font style\n    \"\"\"\nreturn STYLE.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_weight","title":"<code>get_weight() -&gt; WeightStr</code>","text":"<p>Get current font weight.</p> <p>Returns:</p> Type Description <code>WeightStr</code> <p>current font weight</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def get_weight(self) -&gt; WeightStr:\n\"\"\"Get current font weight.\n    Returns:\n        current font weight\n    \"\"\"\nreturn WEIGHT.inverse[self.weight()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_capitalization","title":"<code>set_capitalization(capitalization: CapitalizationStr | gui.Font.Capitalization)</code>","text":"<p>Set the font capitalization.</p> <p>Parameters:</p> Name Type Description Default <code>capitalization</code> <code>CapitalizationStr | gui.Font.Capitalization</code> <p>font capitalization</p> required Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_capitalization(\nself, capitalization: CapitalizationStr | gui.Font.Capitalization\n):\n\"\"\"Set the font capitalization.\n    Args:\n        capitalization: font capitalization\n    \"\"\"\nself.setCapitalization(CAPITALIZATION.get_enum_value(capitalization))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_family","title":"<code>set_family(family: str, fallback: str | None = None)</code>","text":"<p>Set the font family.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <code>str</code> <p>font family</p> required <code>fallback</code> <code>str | None</code> <p>fallback font family</p> <code>None</code> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_family(self, family: str, fallback: str | None = None):\n\"\"\"Set the font family.\n    Args:\n        family: font family\n        fallback: fallback font family\n    \"\"\"\nself.setFamily(family)\nfont_info = gui.FontInfo(self)\nif fallback is not None and font_info.family() != family:\nself.setFamily(fallback)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_hinting_preference","title":"<code>set_hinting_preference(preference: HintingPreferenceStr | gui.Font.HintingPreference)</code>","text":"<p>Set the hinting preference.</p> <p>Parameters:</p> Name Type Description Default <code>preference</code> <code>HintingPreferenceStr | gui.Font.HintingPreference</code> <p>hinting preference</p> required Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_hinting_preference(\nself, preference: HintingPreferenceStr | gui.Font.HintingPreference\n):\n\"\"\"Set the hinting preference.\n    Args:\n        preference: hinting preference\n    \"\"\"\nself.setHintingPreference(HINTING_PREFERENCE.get_enum_value(preference))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_letter_spacing","title":"<code>set_letter_spacing(typ: SpacingTypeStr | gui.Font.SpacingType, spacing: float)</code>","text":"<p>Set the letter spacing.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>SpacingTypeStr | gui.Font.SpacingType</code> <p>letter spacing type</p> required <code>spacing</code> <code>float</code> <p>spacing</p> required Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_letter_spacing(\nself, typ: SpacingTypeStr | gui.Font.SpacingType, spacing: float\n):\n\"\"\"Set the letter spacing.\n    Args:\n        typ: letter spacing type\n        spacing: spacing\n    \"\"\"\nself.setLetterSpacing(SPACING_TYPE.get_enum_value(typ), spacing)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style","title":"<code>set_style(style: StyleStr | gui.Font.Style)</code>","text":"<p>Set the font style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>StyleStr | gui.Font.Style</code> <p>font style</p> required Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_style(self, style: StyleStr | gui.Font.Style):\n\"\"\"Set the font style.\n    Args:\n        style: font style\n    \"\"\"\nself.setStyle(STYLE.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style_hint","title":"<code>set_style_hint(hint: StyleHintStr | QtGui.QFont.StyleHint)</code>","text":"<p>Set the style hint.</p> <p>Parameters:</p> Name Type Description Default <code>hint</code> <code>StyleHintStr | QtGui.QFont.StyleHint</code> <p>style hint</p> required Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_style_hint(self, hint: StyleHintStr | QtGui.QFont.StyleHint):\n\"\"\"Set the style hint.\n    Args:\n        hint: style hint\n    \"\"\"\nself.setStyleHint(STYLE_HINTS.get_enum_value(hint))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_weight","title":"<code>set_weight(weight: WeightStr | QtGui.QFont.Weight)</code>","text":"<p>Set the font weight.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>WeightStr | QtGui.QFont.Weight</code> <p>font weight</p> required Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_weight(self, weight: WeightStr | QtGui.QFont.Weight):\n\"\"\"Set the font weight.\n    Args:\n        weight: font weight\n    \"\"\"\nself.setWeight(WEIGHT.get_enum_value(weight))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.GradientMixin","title":"<code>GradientMixin</code>","text":"Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>class GradientMixin:\ndef __setitem__(self, key: float, value):\nself.setColorAt(key, value)\ndef serialize(self) -&gt; dict[str, Any]:\nreturn dict(\ncoordinate_mode=self.get_coordinate_mode(),\nspread=self.get_spread(),\nstops=self.get_stops(),\n)\ndef set_coordinate_mode(\nself, mode: CoordinateModeStr | QtGui.QGradient.CoordinateMode\n):\n\"\"\"Set the coordinate mode.\n        Args:\n            mode: coordinate mode\n        \"\"\"\nself.setCoordinateMode(COORDINATE_MODE.get_enum_value(mode))\ndef get_coordinate_mode(self) -&gt; CoordinateModeStr:\n\"\"\"Return current coordinate mode.\n        Returns:\n            coordinate mode\n        \"\"\"\nreturn COORDINATE_MODE.inverse[self.coordinateMode()]\ndef set_spread(self, method: SpreadStr | QtGui.QGradient.Spread):\n\"\"\"Set the spread method.\n        Args:\n            method: spread method\n        \"\"\"\nself.setSpread(SPREAD.get_enum_value(method))\ndef get_spread(self) -&gt; SpreadStr:\n\"\"\"Return current spread method.\n        Returns:\n            spread method\n        \"\"\"\nreturn SPREAD.inverse[self.spread()]\ndef get_type(self) -&gt; TypeStr:\n\"\"\"Return current gradient type.\n        Returns:\n            gradient type\n        \"\"\"\nreturn TYPE.inverse[self.type()]\ndef get_stops(self) -&gt; list[tuple[float, gui.Color]]:\nreturn [(i, gui.Color(j)) for (i, j) in self.stops()]\n@classmethod\ndef for_palette(cls, palette: gui.Palette, group: gui.palette.GroupStr = \"active\"):\ngradient = cls()\nfor i, role_name in enumerate(gui.palette.ROLE):\ncolor = palette.get_color(role_name, group)\ngradient.setColorAt(i / len(gui.palette.ROLE), color)\nreturn gradient\ndef change_brightness(self, factor: float):\n# still need to streamline changing brightness across the framework...\n# color.lighter returns a lighter color when arg is &gt; 100 (same for darker)\nfactor = int(factor * 100)\nfor pos, color in grad.stops():\nif factor &gt; 0:\nself.setColorAt(pos, color.lighter(factor))\nelse:\nself.setColorAt(pos, color.darker(-factor))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.get_coordinate_mode","title":"<code>get_coordinate_mode() -&gt; CoordinateModeStr</code>","text":"<p>Return current coordinate mode.</p> <p>Returns:</p> Type Description <code>CoordinateModeStr</code> <p>coordinate mode</p> Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>def get_coordinate_mode(self) -&gt; CoordinateModeStr:\n\"\"\"Return current coordinate mode.\n    Returns:\n        coordinate mode\n    \"\"\"\nreturn COORDINATE_MODE.inverse[self.coordinateMode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.get_spread","title":"<code>get_spread() -&gt; SpreadStr</code>","text":"<p>Return current spread method.</p> <p>Returns:</p> Type Description <code>SpreadStr</code> <p>spread method</p> Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>def get_spread(self) -&gt; SpreadStr:\n\"\"\"Return current spread method.\n    Returns:\n        spread method\n    \"\"\"\nreturn SPREAD.inverse[self.spread()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.get_type","title":"<code>get_type() -&gt; TypeStr</code>","text":"<p>Return current gradient type.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>gradient type</p> Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return current gradient type.\n    Returns:\n        gradient type\n    \"\"\"\nreturn TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.set_coordinate_mode","title":"<code>set_coordinate_mode(mode: CoordinateModeStr | QtGui.QGradient.CoordinateMode)</code>","text":"<p>Set the coordinate mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CoordinateModeStr | QtGui.QGradient.CoordinateMode</code> <p>coordinate mode</p> required Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>def set_coordinate_mode(\nself, mode: CoordinateModeStr | QtGui.QGradient.CoordinateMode\n):\n\"\"\"Set the coordinate mode.\n    Args:\n        mode: coordinate mode\n    \"\"\"\nself.setCoordinateMode(COORDINATE_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.set_spread","title":"<code>set_spread(method: SpreadStr | QtGui.QGradient.Spread)</code>","text":"<p>Set the spread method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>SpreadStr | QtGui.QGradient.Spread</code> <p>spread method</p> required Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>def set_spread(self, method: SpreadStr | QtGui.QGradient.Spread):\n\"\"\"Set the spread method.\n    Args:\n        method: spread method\n    \"\"\"\nself.setSpread(SPREAD.get_enum_value(method))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.GuiApplicationMixin","title":"<code>GuiApplicationMixin</code>","text":"<p>         Bases: <code>core.CoreApplicationMixin</code></p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>class GuiApplicationMixin(core.CoreApplicationMixin):\npalette_changed = core.Signal(gui.Palette)\ndef event(self, e):\nmatch e.type():\ncase QtCore.QEvent.Type.ApplicationPaletteChange:\nself.palette_changed.emit(gui.Palette(self.palette()))\nreturn super().event(e)\n@classmethod\n@contextlib.contextmanager\ndef override_cursor(cls, cursor: constants.CursorShapeStr):\ncls.set_override_cursor(cursor)\nyield cursor\ncls.restore_override_cursor()\n@classmethod\ndef set_override_cursor(cls, cursor: constants.CursorShapeStr):\ncrs = gui.Cursor(constants.CURSOR_SHAPE[cursor])\ncls.setOverrideCursor(crs)\n@classmethod\ndef restore_override_cursor(cls):\ncls.restoreOverrideCursor()\n@classmethod\ndef get_clipboard(cls) -&gt; gui.Clipboard:\nreturn gui.Clipboard(cls.clipboard())\n@classmethod\n@contextlib.contextmanager\ndef edit_palette(cls) -&gt; Iterator[gui.Palette]:\npalette = gui.Palette(cls.palette())\nyield palette\ncls.setPalette(palette)\n@classmethod\ndef find_window(cls, h_wnd: SupportsInt) -&gt; QtGui.QWindow:\nfor window in cls.topLevelWindows():\nif window and int(window.winId()) == int(h_wnd):\nreturn window\nreturn None\ndef set_layout_direction(\nself, direction: constants.LayoutDirectionStr | constants.LayoutDirection\n):\n\"\"\"Set layout direction.\n        Args:\n            direction: layout direction\n        \"\"\"\nself.setLayoutDirection(constants.LAYOUT_DIRECTION.get_enum_value(direction))\ndef get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n        Returns:\n            layout direction\n        \"\"\"\nreturn constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\n@classmethod\ndef set_high_dpi_scale_factor_rounding_policy(\ncls,\npolicy: constants.HighDpiScaleFactorRoundingPolicyStr\n| constants.HighDpiScaleFactorRoundingPolicy,\n):\n\"\"\"Set high dpi scale factor rounding policy.\n        Args:\n            policy: rounding policy\n        \"\"\"\ncls.setHighDpiScaleFactorRoundingPolicy(\nconstants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY.get_enum_value(policy)\n)\n@classmethod\ndef get_high_dpi_scale_factor_rounding_policy(\ncls,\n) -&gt; constants.HighDpiScaleFactorRoundingPolicyStr:\n\"\"\"Get the current high dpi scale factor rounding policy.\n        Returns:\n            rounding policy\n        \"\"\"\nreturn constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY.inverse[\ncls.highDpiScaleFactorRoundingPolicy()\n]\n@classmethod\ndef get_application_state(cls) -&gt; list[constants.ApplicationStateStr]:\n\"\"\"Get the current application state.\n        Returns:\n            application state\n        \"\"\"\nreturn [\nk\nfor k, v in constants.APPLICATION_STATES.items()\nif v &amp; cls.applicationState()  # type: ignore\n]\ndef get_primary_screen(self) -&gt; gui.Screen:\nreturn gui.Screen(self.primaryScreen())\ndef get_screen_at(self, point: datatypes.PointType) -&gt; gui.Screen:\np = datatypes.to_point(point)\nreturn gui.Screen(self.screenAt(p))\ndef get_screens(self) -&gt; list[gui.Screen]:\nreturn [gui.Screen(i) for i in self.screens()]\n@classmethod\ndef get_input_method(cls) -&gt; gui.InputMethod:\nreturn gui.InputMethod(cls.inputMethod())\n@classmethod\ndef copy_to_clipboard(cls, text: str):\n\"\"\"Sets clipboard to supplied text.\"\"\"\ncb = cls.clipboard()\ncb.clear(mode=cb.Mode.Clipboard)\ncb.setText(text, mode=cb.Mode.Clipboard)\n@classmethod\ndef get_font(cls) -&gt; gui.Font:\nreturn gui.Font(cls.font())\ndef set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the default window icon.\n        Args:\n            icon: icon to use\n        \"\"\"\nicon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\nself.setWindowIcon(icon)\ndef get_icon(self) -&gt; gui.Icon | None:\nicon = self.windowIcon()\nreturn None if icon.isNull() else gui.Icon(self.windowIcon())\n@classmethod\ndef set_palette(cls, palette: constants.ThemeStr | QtGui.QPalette):\nmatch palette:\ncase \"default\":\npal = gui.Palette()\ncase \"dark\":\npal = gui.Palette.create_dark_palette()\ncase _:\npal = palette\ncls.setPalette(pal)\n@classmethod\ndef get_keyboard_modifiers(cls) -&gt; list[constants.KeyboardModifierStr]:\nreturn constants.KEYBOARD_MODIFIERS.get_list(cls.keyboardModifiers())\n@classmethod\ndef query_keyboard_modifiers(cls) -&gt; list[constants.KeyboardModifierStr]:\nreturn constants.KEYBOARD_MODIFIERS.get_list(cls.queryKeyboardModifiers())\n@classmethod\ndef get_palette(cls) -&gt; gui.Palette:\nreturn gui.Palette(cls.palette())\ndef set_badge_number(self, number: int | None):\nself.setBadgeNumber(number or 0)\ndef set_progress_value(self, value: int, total: int = 100):\nwindows = self.topLevelWindows()\nif not windows:\nreturn None\nif sys.platform.startswith(\"win\"):\nfrom prettyqt.utils.platforms.windows import taskbaritem\nwindow_id = windows[0].winId()\ntb = taskbaritem.TaskBarItem(window_id)\ntb.set_progress_value(value, total)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.copy_to_clipboard","title":"<code>copy_to_clipboard(text: str)</code>  <code>classmethod</code>","text":"<p>Sets clipboard to supplied text.</p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>@classmethod\ndef copy_to_clipboard(cls, text: str):\n\"\"\"Sets clipboard to supplied text.\"\"\"\ncb = cls.clipboard()\ncb.clear(mode=cb.Mode.Clipboard)\ncb.setText(text, mode=cb.Mode.Clipboard)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.get_application_state","title":"<code>get_application_state() -&gt; list[constants.ApplicationStateStr]</code>  <code>classmethod</code>","text":"<p>Get the current application state.</p> <p>Returns:</p> Type Description <code>list[constants.ApplicationStateStr]</code> <p>application state</p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>@classmethod\ndef get_application_state(cls) -&gt; list[constants.ApplicationStateStr]:\n\"\"\"Get the current application state.\n    Returns:\n        application state\n    \"\"\"\nreturn [\nk\nfor k, v in constants.APPLICATION_STATES.items()\nif v &amp; cls.applicationState()  # type: ignore\n]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.get_high_dpi_scale_factor_rounding_policy","title":"<code>get_high_dpi_scale_factor_rounding_policy() -&gt; constants.HighDpiScaleFactorRoundingPolicyStr</code>  <code>classmethod</code>","text":"<p>Get the current high dpi scale factor rounding policy.</p> <p>Returns:</p> Type Description <code>constants.HighDpiScaleFactorRoundingPolicyStr</code> <p>rounding policy</p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>@classmethod\ndef get_high_dpi_scale_factor_rounding_policy(\ncls,\n) -&gt; constants.HighDpiScaleFactorRoundingPolicyStr:\n\"\"\"Get the current high dpi scale factor rounding policy.\n    Returns:\n        rounding policy\n    \"\"\"\nreturn constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY.inverse[\ncls.highDpiScaleFactorRoundingPolicy()\n]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.get_layout_direction","title":"<code>get_layout_direction() -&gt; constants.LayoutDirectionStr</code>","text":"<p>Get the current layout direction.</p> <p>Returns:</p> Type Description <code>constants.LayoutDirectionStr</code> <p>layout direction</p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>def get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n    Returns:\n        layout direction\n    \"\"\"\nreturn constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.set_high_dpi_scale_factor_rounding_policy","title":"<code>set_high_dpi_scale_factor_rounding_policy(policy: constants.HighDpiScaleFactorRoundingPolicyStr | constants.HighDpiScaleFactorRoundingPolicy)</code>  <code>classmethod</code>","text":"<p>Set high dpi scale factor rounding policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>constants.HighDpiScaleFactorRoundingPolicyStr | constants.HighDpiScaleFactorRoundingPolicy</code> <p>rounding policy</p> required Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>@classmethod\ndef set_high_dpi_scale_factor_rounding_policy(\ncls,\npolicy: constants.HighDpiScaleFactorRoundingPolicyStr\n| constants.HighDpiScaleFactorRoundingPolicy,\n):\n\"\"\"Set high dpi scale factor rounding policy.\n    Args:\n        policy: rounding policy\n    \"\"\"\ncls.setHighDpiScaleFactorRoundingPolicy(\nconstants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY.get_enum_value(policy)\n)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the default window icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the default window icon.\n    Args:\n        icon: icon to use\n    \"\"\"\nicon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\nself.setWindowIcon(icon)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.set_layout_direction","title":"<code>set_layout_direction(direction: constants.LayoutDirectionStr | constants.LayoutDirection)</code>","text":"<p>Set layout direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>constants.LayoutDirectionStr | constants.LayoutDirection</code> <p>layout direction</p> required Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>def set_layout_direction(\nself, direction: constants.LayoutDirectionStr | constants.LayoutDirection\n):\n\"\"\"Set layout direction.\n    Args:\n        direction: layout direction\n    \"\"\"\nself.setLayoutDirection(constants.LAYOUT_DIRECTION.get_enum_value(direction))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Icon","title":"<code>Icon</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QIcon</code></p> Source code in <code>prettyqt\\gui\\icon.py</code> <pre><code>class Icon(serializemixin.SerializeMixin, QtGui.QIcon):\ndef __repr__(self):\nreturn get_repr(self)\ndef __bool__(self):\nreturn not self.isNull()\ndef __getstate__(self):\npixmap = self.pixmap(256, 256)\nreturn bytes(gui.Pixmap(pixmap))\ndef __setstate__(self, ba):\npx = gui.Pixmap()\npx.__setstate__(ba)\nself.add_pixmap(px)\n@classmethod\ndef for_color(cls, color_str: str) -&gt; Self:\ncolor = gui.Color(color_str)\nbitmap = gui.Pixmap(16, 16)\nbitmap.fill(color)\nreturn cls(bitmap)\n@classmethod\ndef from_char(cls, char: str, background=\"black\", color=\"white\") -&gt; Self:\n\"\"\"Create a QIcon with a given character.\"\"\"\nicon = cls()\nfor size in (16, 32, 64):\npx = gui.Pixmap.create_char(\nchar, background=background, color=color, size=size\n)\nicon.addPixmap(px)\nreturn icon\n@classmethod\ndef from_image(cls, image: QtGui.QImage) -&gt; Self:\nreturn cls(gui.Pixmap.fromImage(image))\ndef get_available_sizes(\nself,\nmode: ModeStr | QtGui.QIcon.Mode = \"normal\",\nstate: StateStr | QtGui.QIcon.State = \"off\",\n) -&gt; list[core.Size]:\nm = MODE.get_enum_value(mode)\ns = STATE.get_enum_value(state)\nreturn [core.Size(i) for i in self.availableSizes(m, s)]\ndef add_pixmap(\nself,\ndata: QtCore.QByteArray | QtGui.QPixmap | bytes,\nmode: ModeStr | QtGui.QIcon.Mode = \"normal\",\nstate: StateStr | QtGui.QIcon.State = \"off\",\n):\nif isinstance(data, bytes):\ndata = QtCore.QByteArray(data)\nif isinstance(data, QtCore.QByteArray):\npixmap = QtGui.QPixmap()\npixmap.loadFromData(data)\nelse:\npixmap = data\nself.addPixmap(pixmap, MODE.get_enum_value(mode), STATE.get_enum_value(state))\ndef get_pixmap(\nself,\nsize: datatypes.SizeType | int,\nmode: ModeStr | QtGui.QIcon.Mode = \"normal\",\nstate: StateStr | QtGui.QIcon.State = \"off\",\n) -&gt; QtGui.QPixmap:\nsz = datatypes.to_size(size)\nreturn self.pixmap(sz, MODE.get_enum_value(mode), STATE.get_enum_value(state))\ndef get_actual_size(\nself,\nsize: datatypes.SizeType,\nmode: ModeStr | QtGui.QIcon.Mode = \"normal\",\nstate: StateStr | QtGui.QIcon.State = \"off\",\n) -&gt; core.Size:\nsz = datatypes.to_size(size)\nm = MODE.get_enum_value(mode)\ns = STATE.get_enum_value(state)\nactual_size = self.actualSize(sz, m, s)\nreturn core.Size(actual_size)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.icon.Icon.from_char","title":"<code>from_char(char: str, background: str = 'black', color: str = 'white') -&gt; Self</code>  <code>classmethod</code>","text":"<p>Create a QIcon with a given character.</p> Source code in <code>prettyqt\\gui\\icon.py</code> <pre><code>@classmethod\ndef from_char(cls, char: str, background=\"black\", color=\"white\") -&gt; Self:\n\"\"\"Create a QIcon with a given character.\"\"\"\nicon = cls()\nfor size in (16, 32, 64):\npx = gui.Pixmap.create_char(\nchar, background=background, color=color, size=size\n)\nicon.addPixmap(px)\nreturn icon\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Image","title":"<code>Image</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>gui.PaintDeviceMixin</code>, <code>gui.QImage</code></p> Source code in <code>prettyqt\\gui\\image.py</code> <pre><code>class Image(serializemixin.SerializeMixin, gui.PaintDeviceMixin, gui.QImage):\ndef __setitem__(self, index: tuple[int, int], value):\nself.setPixel(index[0], index[1], value)\ndef __getitem__(self, index: tuple[int, int]) -&gt; int:\nreturn self.pixel(index[0], index[1])\n@classmethod\ndef from_ndarray(cls, arr) -&gt; Self:\nimport numpy as np\nheight, width, bytes_per_component = arr.shape\nif arr.dtype in {np.float32, np.float64}:\narr = (255 * arr).round()\narr = arr.astype(np.uint8)\nreturn cls(\narr.data,\nwidth,\nheight,\nbytes_per_component * width,\ngui.QImage.Format.Format_RGB888,\n)\ndef to_ndarray(self, fmt: FormatStr = \"rgb888\", channels: int = 3):\nimport numpy as np\nqimage = self.convert_to_format(fmt)\nwidth = qimage.width()\nheight = qimage.height()\nptr = qimage.constBits()\narray = np.array(ptr).reshape(height, width, channels)  # Copies the data\nreturn array\n@classmethod\ndef from_pil(cls, image) -&gt; Self:\n# from https://github.com/python-pillow/Pillow/blob/main/src/PIL/ImageQt.py\nfrom PIL import ImageQt\ndata = ImageQt._toqclass_helper(image)\nimg = cls(data[\"data\"], data[\"size\"][0], data[\"size\"][1], data[\"format\"])\nif data[\"colortable\"]:\nimg.setColorTable(data[\"colortable\"])\nimg.__data = data[\"data\"]\nreturn img\n@classmethod\ndef for_mimetype(cls, path: os.PathLike) -&gt; Self | None:\n\"\"\"Try to create an icon from theme using the file mimetype.\n        E.g.::\n            return self.mimetype_icon(\n                path, fallback=':/icons/text-x-python.png')\n        :param path: file path for which the icon must be created\n        :param fallback: fallback icon path (qrc or file system)\n        :returns: QIcon or None if the file mimetype icon could not be found.\n        \"\"\"\npath = os.fspath(path)\nif mime := mimetypes.guess_type(path)[0]:\nicon = mime.replace(\"/\", \"-\")\n# if system.WINDOWS:\n#     return icons.file()\nif cls.hasThemeIcon(icon):\nicon = cls(cls.fromTheme(icon))\nif not icon.isNull():\nreturn icon\nreturn None  #  gui.Icon.fromTheme(\"text-x-generic\")\ndef to_pil(self) -&gt; Image:\nfrom PIL import Image as PILImage\nbuffer = core.Buffer()\nbuffer.open(core.Buffer.OpenModeFlag.ReadWrite)\nself.save(buffer, \"PNG\")\nreturn PILImage.open(io.BytesIO(buffer.data()))\ndef invert_pixels(self, invert_alpha: bool = False):\nself.invertPixels(\ngui.QImage.InvertMode.InvertRgba\nif invert_alpha\nelse gui.QImage.InvertMode.InvertRgb\n)\ndef convert_to_format(self, fmt: FormatStr | gui.QImage.Format) -&gt; Self:\nreturn type(self)(self.convertToFormat(FORMAT.get_enum_value(fmt)))\ndef as_bytes(self) -&gt; bytes:\nbits = self.bits()\nif bits is None:\nreturn b\"\"\nmatch API:\ncase \"pyqt6\":\nreturn bits.asstring(self.sizeInBytes())\ncase \"pyside6\":\nreturn bits.tobytes()\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.image.Image.for_mimetype","title":"<code>for_mimetype(path: os.PathLike) -&gt; Self | None</code>  <code>classmethod</code>","text":"<p>Try to create an icon from theme using the file mimetype.</p> <p>E.g.::</p> <pre><code>return self.mimetype_icon(\npath, fallback=':/icons/text-x-python.png')\n</code></pre> <p>:param path: file path for which the icon must be created :param fallback: fallback icon path (qrc or file system) :returns: QIcon or None if the file mimetype icon could not be found.</p> Source code in <code>prettyqt\\gui\\image.py</code> <pre><code>@classmethod\ndef for_mimetype(cls, path: os.PathLike) -&gt; Self | None:\n\"\"\"Try to create an icon from theme using the file mimetype.\n    E.g.::\n        return self.mimetype_icon(\n            path, fallback=':/icons/text-x-python.png')\n    :param path: file path for which the icon must be created\n    :param fallback: fallback icon path (qrc or file system)\n    :returns: QIcon or None if the file mimetype icon could not be found.\n    \"\"\"\npath = os.fspath(path)\nif mime := mimetypes.guess_type(path)[0]:\nicon = mime.replace(\"/\", \"-\")\n# if system.WINDOWS:\n#     return icons.file()\nif cls.hasThemeIcon(icon):\nicon = cls(cls.fromTheme(icon))\nif not icon.isNull():\nreturn icon\nreturn None  #  gui.Icon.fromTheme(\"text-x-generic\")\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.ImageIOHandler","title":"<code>ImageIOHandler</code>","text":"<p>         Bases: <code>mod</code></p> Source code in <code>prettyqt\\gui\\imageiohandler.py</code> <pre><code>class ImageIOHandler(mod):\ndef __getitem__(self, key: ImageOptionStr | mod.ImageOption) -&gt; datatypes.Variant:\nreturn self.get_option(key)\ndef __setitem__(\nself, key: ImageOptionStr | mod.ImageOption, value: datatypes.Variant\n):\nself.set_option(key, value)\ndef get_format(self) -&gt; str:\nreturn self.format().data().decode()\ndef set_option(\nself, option: ImageOptionStr | mod.ImageOption, value: datatypes.Variant\n):\n\"\"\"Set option to given value.\n        Args:\n            option: option to use\n            value: value to set\n        \"\"\"\nself.setOption(IMAGE_OPTION.get_enum_value(option), value)\ndef get_option(self, option: ImageOptionStr | mod.ImageOption) -&gt; datatypes.Variant:\n\"\"\"Return the value assigned to option.\n        Args:\n            option: option to get\n        Returns:\n            option\n        \"\"\"\nreturn self.option(IMAGE_OPTION.get_enum_value(option))\ndef supports_option(self, option: ImageOptionStr | mod.ImageOption) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n        Args:\n            option: option to check\n        Returns:\n            option\n        \"\"\"\nreturn self.supportsOption(IMAGE_OPTION.get_enum_value(option))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.get_option","title":"<code>get_option(option: ImageOptionStr | mod.ImageOption) -&gt; datatypes.Variant</code>","text":"<p>Return the value assigned to option.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>ImageOptionStr | mod.ImageOption</code> <p>option to get</p> required <p>Returns:</p> Type Description <code>datatypes.Variant</code> <p>option</p> Source code in <code>prettyqt\\gui\\imageiohandler.py</code> <pre><code>def get_option(self, option: ImageOptionStr | mod.ImageOption) -&gt; datatypes.Variant:\n\"\"\"Return the value assigned to option.\n    Args:\n        option: option to get\n    Returns:\n        option\n    \"\"\"\nreturn self.option(IMAGE_OPTION.get_enum_value(option))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.set_option","title":"<code>set_option(option: ImageOptionStr | mod.ImageOption, value: datatypes.Variant)</code>","text":"<p>Set option to given value.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>ImageOptionStr | mod.ImageOption</code> <p>option to use</p> required <code>value</code> <code>datatypes.Variant</code> <p>value to set</p> required Source code in <code>prettyqt\\gui\\imageiohandler.py</code> <pre><code>def set_option(\nself, option: ImageOptionStr | mod.ImageOption, value: datatypes.Variant\n):\n\"\"\"Set option to given value.\n    Args:\n        option: option to use\n        value: value to set\n    \"\"\"\nself.setOption(IMAGE_OPTION.get_enum_value(option), value)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.supports_option","title":"<code>supports_option(option: ImageOptionStr | mod.ImageOption) -&gt; bool</code>","text":"<p>Return whether the image handler supports given option.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>ImageOptionStr | mod.ImageOption</code> <p>option to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>option</p> Source code in <code>prettyqt\\gui\\imageiohandler.py</code> <pre><code>def supports_option(self, option: ImageOptionStr | mod.ImageOption) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n    Args:\n        option: option to check\n    Returns:\n        option\n    \"\"\"\nreturn self.supportsOption(IMAGE_OPTION.get_enum_value(option))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.ImageReader","title":"<code>ImageReader</code>","text":"<p>         Bases: <code>QtGui.QImageReader</code></p> Source code in <code>prettyqt\\gui\\imagereader.py</code> <pre><code>class ImageReader(QtGui.QImageReader):\ndef __getitem__(self, key: str) -&gt; str:\nreturn self.text(key)\ndef get_error(self) -&gt; ImageReaderErrorStr:\n\"\"\"Return error type.\n        Returns:\n            error type\n        \"\"\"\nreturn IMAGE_READER_ERROR.inverse[self.error()]\ndef get_background_color(self) -&gt; gui.Color:\nreturn gui.Color(self.backgroundColor())\ndef get_clip_rect(self) -&gt; core.Rect:\nreturn core.Rect(self.clipRect())\ndef get_current_image_rect(self) -&gt; core.Rect:\nreturn core.Rect(self.currentImageRect())\ndef get_scaled_clip_rect(self) -&gt; core.Rect:\nreturn core.Rect(self.scaledClipRect())\ndef get_size(self) -&gt; core.Size:\nreturn core.Size(self.size())\ndef get_scaled_size(self) -&gt; core.Size:\nreturn core.Size(self.scaledSize())\ndef get_format(self) -&gt; str:\nreturn self.format().data().decode()\ndef get_subtype(self) -&gt; str:\nreturn self.subType().data().decode()\ndef get_supported_subtypes(self) -&gt; list[str]:\nreturn [i.data().decode() for i in self.supportedSubTypes()]\ndef set_format(self, fmt: datatypes.ByteArrayType):\nfmt = datatypes.to_bytearray(fmt)\nself.setFormat(fmt)\ndef get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n        Returns:\n            transformation\n        \"\"\"\nreturn gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\ndef read_image(self) -&gt; gui.Image:\nreturn gui.Image(self.read())\ndef supports_option(\nself, option: gui.imageiohandler.ImageOptionStr | gui.QImageIOHandler.ImageOption\n) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n        Args:\n            option: option to check\n        Returns:\n            option\n        \"\"\"\nreturn self.supportsOption(gui.imageiohandler.IMAGE_OPTION.get_enum_value(option))\n@staticmethod\ndef get_image_format(obj: str | QtCore.QIODevice) -&gt; str:\nreturn ImageReader.imageFormat(obj).data().decode()\n@staticmethod\ndef get_supported_image_formats() -&gt; list[str]:\nreturn [i.data().decode() for i in ImageReader.supportedImageFormats()]\n@staticmethod\ndef get_supported_mime_types() -&gt; list[str]:\nreturn [i.data().decode() for i in ImageReader.supportedMimeTypes()]\n@staticmethod\ndef get_image_formats_for_mime_type(typ: datatypes.ByteArrayType) -&gt; list[str]:\ntyp = datatypes.to_bytearray(typ)\nreturn [i.data().decode() for i in ImageReader.imageFormatsForMimeType(typ)]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_error","title":"<code>get_error() -&gt; ImageReaderErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ImageReaderErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\gui\\imagereader.py</code> <pre><code>def get_error(self) -&gt; ImageReaderErrorStr:\n\"\"\"Return error type.\n    Returns:\n        error type\n    \"\"\"\nreturn IMAGE_READER_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_transformation","title":"<code>get_transformation() -&gt; gui.imageiohandler.TransformationStr</code>","text":"<p>Return the transformation and orientation the image has been set to.</p> <p>Returns:</p> Type Description <code>gui.imageiohandler.TransformationStr</code> <p>transformation</p> Source code in <code>prettyqt\\gui\\imagereader.py</code> <pre><code>def get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n    Returns:\n        transformation\n    \"\"\"\nreturn gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.supports_option","title":"<code>supports_option(option: gui.imageiohandler.ImageOptionStr | gui.QImageIOHandler.ImageOption) -&gt; bool</code>","text":"<p>Return whether the image handler supports given option.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>gui.imageiohandler.ImageOptionStr | gui.QImageIOHandler.ImageOption</code> <p>option to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>option</p> Source code in <code>prettyqt\\gui\\imagereader.py</code> <pre><code>def supports_option(\nself, option: gui.imageiohandler.ImageOptionStr | gui.QImageIOHandler.ImageOption\n) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n    Args:\n        option: option to check\n    Returns:\n        option\n    \"\"\"\nreturn self.supportsOption(gui.imageiohandler.IMAGE_OPTION.get_enum_value(option))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.ImageWriter","title":"<code>ImageWriter</code>","text":"<p>         Bases: <code>QtGui.QImageWriter</code></p> Source code in <code>prettyqt\\gui\\imagewriter.py</code> <pre><code>class ImageWriter(QtGui.QImageWriter):\ndef __setitem__(self, key: str, val: str):\nself.setText(key, val)\ndef get_error(self) -&gt; ImageWriterErrorStr:\n\"\"\"Return error type.\n        Returns:\n            error type\n        \"\"\"\nreturn IMAGE_WRITER_ERROR.inverse[self.error()]\ndef get_format(self) -&gt; str:\nreturn self.format().data().decode()\ndef get_subtype(self) -&gt; str:\nreturn self.subType().data().decode()\ndef get_supported_image_formats(self) -&gt; list[str]:\nreturn [i.data().decode() for i in self.supportedImageFormats()]\ndef get_supported_subtypes(self) -&gt; list[str]:\nreturn [i.data().decode() for i in self.supportedSubTypes()]\ndef set_subtype(self, subtype: datatypes.ByteArrayType):\nsubtype = datatypes.to_bytearray(subtype)\nself.setSubType(subtype)\ndef set_format(self, fmt: datatypes.ByteArrayType):\nfmt = datatypes.to_bytearray(fmt)\nself.setFormat(fmt)\ndef set_transformation(\nself,\norigin: gui.imageiohandler.TransformationStr | gui.ImageIOHandler.Transformation,\n):\n\"\"\"Set the image transformations metadata including orientation.\n        Args:\n            origin: transformation to use\n        \"\"\"\nself.setTransformation(gui.imageiohandler.TRANSFORMATION.get_enum_value(origin))\ndef get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n        Returns:\n            transformation\n        \"\"\"\nreturn gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_error","title":"<code>get_error() -&gt; ImageWriterErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ImageWriterErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\gui\\imagewriter.py</code> <pre><code>def get_error(self) -&gt; ImageWriterErrorStr:\n\"\"\"Return error type.\n    Returns:\n        error type\n    \"\"\"\nreturn IMAGE_WRITER_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_transformation","title":"<code>get_transformation() -&gt; gui.imageiohandler.TransformationStr</code>","text":"<p>Return the transformation and orientation the image has been set to.</p> <p>Returns:</p> Type Description <code>gui.imageiohandler.TransformationStr</code> <p>transformation</p> Source code in <code>prettyqt\\gui\\imagewriter.py</code> <pre><code>def get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n    Returns:\n        transformation\n    \"\"\"\nreturn gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.set_transformation","title":"<code>set_transformation(origin: gui.imageiohandler.TransformationStr | gui.ImageIOHandler.Transformation)</code>","text":"<p>Set the image transformations metadata including orientation.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>gui.imageiohandler.TransformationStr | gui.ImageIOHandler.Transformation</code> <p>transformation to use</p> required Source code in <code>prettyqt\\gui\\imagewriter.py</code> <pre><code>def set_transformation(\nself,\norigin: gui.imageiohandler.TransformationStr | gui.ImageIOHandler.Transformation,\n):\n\"\"\"Set the image transformations metadata including orientation.\n    Args:\n        origin: transformation to use\n    \"\"\"\nself.setTransformation(gui.imageiohandler.TRANSFORMATION.get_enum_value(origin))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Movie","title":"<code>Movie</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtGui.QMovie</code></p> Source code in <code>prettyqt\\gui\\movie.py</code> <pre><code>class Movie(core.ObjectMixin, QtGui.QMovie):\ndef __repr__(self):\nreturn get_repr(self, self.fileName(), self.get_format())\ndef set_cache_mode(self, mode: CacheModeStr | QtGui.QMovie.CacheMode):\n\"\"\"Set cache mode.\n        Args:\n            mode: cache mode\n        \"\"\"\nself.setCacheMode(CACHE_MODE.get_enum_value(mode))\ndef get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current cache mode.\n        Returns:\n            cache mode\n        \"\"\"\nreturn CACHE_MODE.inverse[self.cacheMode()]\ndef get_state(self) -&gt; MovieStateStr:\n\"\"\"Get the current state.\n        Returns:\n            state\n        \"\"\"\nreturn MOVIE_STATE.inverse[self.state()]\ndef get_format(self) -&gt; str:\nreturn self.format().data().decode()\n@classmethod\ndef get_supported_formats(cls) -&gt; list[str]:\nreturn [i.data().decode() for i in cls.supportedFormats()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_cache_mode","title":"<code>get_cache_mode() -&gt; CacheModeStr</code>","text":"<p>Get the current cache mode.</p> <p>Returns:</p> Type Description <code>CacheModeStr</code> <p>cache mode</p> Source code in <code>prettyqt\\gui\\movie.py</code> <pre><code>def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current cache mode.\n    Returns:\n        cache mode\n    \"\"\"\nreturn CACHE_MODE.inverse[self.cacheMode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_state","title":"<code>get_state() -&gt; MovieStateStr</code>","text":"<p>Get the current state.</p> <p>Returns:</p> Type Description <code>MovieStateStr</code> <p>state</p> Source code in <code>prettyqt\\gui\\movie.py</code> <pre><code>def get_state(self) -&gt; MovieStateStr:\n\"\"\"Get the current state.\n    Returns:\n        state\n    \"\"\"\nreturn MOVIE_STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.set_cache_mode","title":"<code>set_cache_mode(mode: CacheModeStr | QtGui.QMovie.CacheMode)</code>","text":"<p>Set cache mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CacheModeStr | QtGui.QMovie.CacheMode</code> <p>cache mode</p> required Source code in <code>prettyqt\\gui\\movie.py</code> <pre><code>def set_cache_mode(self, mode: CacheModeStr | QtGui.QMovie.CacheMode):\n\"\"\"Set cache mode.\n    Args:\n        mode: cache mode\n    \"\"\"\nself.setCacheMode(CACHE_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PageLayout","title":"<code>PageLayout</code>","text":"<p>         Bases: <code>QtGui.QPageLayout</code></p> Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>class PageLayout(QtGui.QPageLayout):\ndef __repr__(self):\nreturn get_repr(self)\ndef set_units(self, unit: UnitStr | QtGui.QPageLayout.Unit):\n\"\"\"Set unit.\n        Args:\n            unit: unit\n        \"\"\"\nself.setUnits(UNITS.get_enum_value(unit))\ndef get_units(self) -&gt; UnitStr:\n\"\"\"Get the current unit.\n        Returns:\n            unit\n        \"\"\"\nreturn UNITS.inverse[self.units()]\ndef set_mode(self, mode: ModeStr | QtGui.QPageLayout.Mode):\n\"\"\"Set mode.\n        Args:\n            mode: mode\n        \"\"\"\nself.setMode(MODES.get_enum_value(mode))\ndef get_mode(self) -&gt; ModeStr:\n\"\"\"Get the current mode.\n        Returns:\n            mode\n        \"\"\"\nreturn MODES.inverse[self.mode()]\ndef set_orientation(\nself, orientation: OrientationStr | QtGui.QPageLayout.Orientation\n):\n\"\"\"Set orientation.\n        Args:\n            orientation: orientation\n        \"\"\"\nself.setOrientation(ORIENTATIONS.get_enum_value(orientation))\ndef get_orientation(self) -&gt; OrientationStr:\n\"\"\"Get the current orientation.\n        Returns:\n            orientation\n        \"\"\"\nreturn ORIENTATIONS.inverse[self.orientation()]\ndef get_page_size(self) -&gt; gui.PageSize:\nreturn gui.PageSize(self.pageSize())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_mode","title":"<code>get_mode() -&gt; ModeStr</code>","text":"<p>Get the current mode.</p> <p>Returns:</p> Type Description <code>ModeStr</code> <p>mode</p> Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def get_mode(self) -&gt; ModeStr:\n\"\"\"Get the current mode.\n    Returns:\n        mode\n    \"\"\"\nreturn MODES.inverse[self.mode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_orientation","title":"<code>get_orientation() -&gt; OrientationStr</code>","text":"<p>Get the current orientation.</p> <p>Returns:</p> Type Description <code>OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def get_orientation(self) -&gt; OrientationStr:\n\"\"\"Get the current orientation.\n    Returns:\n        orientation\n    \"\"\"\nreturn ORIENTATIONS.inverse[self.orientation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_units","title":"<code>get_units() -&gt; UnitStr</code>","text":"<p>Get the current unit.</p> <p>Returns:</p> Type Description <code>UnitStr</code> <p>unit</p> Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def get_units(self) -&gt; UnitStr:\n\"\"\"Get the current unit.\n    Returns:\n        unit\n    \"\"\"\nreturn UNITS.inverse[self.units()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_mode","title":"<code>set_mode(mode: ModeStr | QtGui.QPageLayout.Mode)</code>","text":"<p>Set mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ModeStr | QtGui.QPageLayout.Mode</code> <p>mode</p> required Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def set_mode(self, mode: ModeStr | QtGui.QPageLayout.Mode):\n\"\"\"Set mode.\n    Args:\n        mode: mode\n    \"\"\"\nself.setMode(MODES.get_enum_value(mode))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_orientation","title":"<code>set_orientation(orientation: OrientationStr | QtGui.QPageLayout.Orientation)</code>","text":"<p>Set orientation.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>OrientationStr | QtGui.QPageLayout.Orientation</code> <p>orientation</p> required Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def set_orientation(\nself, orientation: OrientationStr | QtGui.QPageLayout.Orientation\n):\n\"\"\"Set orientation.\n    Args:\n        orientation: orientation\n    \"\"\"\nself.setOrientation(ORIENTATIONS.get_enum_value(orientation))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_units","title":"<code>set_units(unit: UnitStr | QtGui.QPageLayout.Unit)</code>","text":"<p>Set unit.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>UnitStr | QtGui.QPageLayout.Unit</code> <p>unit</p> required Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def set_units(self, unit: UnitStr | QtGui.QPageLayout.Unit):\n\"\"\"Set unit.\n    Args:\n        unit: unit\n    \"\"\"\nself.setUnits(UNITS.get_enum_value(unit))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PageSize","title":"<code>PageSize</code>","text":"<p>         Bases: <code>QtGui.QPageSize</code></p> Source code in <code>prettyqt\\gui\\pagesize.py</code> <pre><code>class PageSize(QtGui.QPageSize):\ndef __repr__(self):\nreturn get_repr(self, self.get_id())\ndef __reduce__(self):\nreturn type(self), (self.id(),)\ndef get_definition_units(self) -&gt; UnitStr:\n\"\"\"Get the definition unit.\n        Returns:\n            unit\n        \"\"\"\nunits = self.definitionUnits()\nif units.value == -1:\nraise ValueError(\"Invalid page size\")\nreturn UNITS.inverse[units]\ndef get_id(self) -&gt; str:\n\"\"\"Get the standard page size id.\n        Returns:\n            page size id\n        \"\"\"\nreturn PAGE_SIZE_ID.inverse[self.id()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_definition_units","title":"<code>get_definition_units() -&gt; UnitStr</code>","text":"<p>Get the definition unit.</p> <p>Returns:</p> Type Description <code>UnitStr</code> <p>unit</p> Source code in <code>prettyqt\\gui\\pagesize.py</code> <pre><code>def get_definition_units(self) -&gt; UnitStr:\n\"\"\"Get the definition unit.\n    Returns:\n        unit\n    \"\"\"\nunits = self.definitionUnits()\nif units.value == -1:\nraise ValueError(\"Invalid page size\")\nreturn UNITS.inverse[units]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_id","title":"<code>get_id() -&gt; str</code>","text":"<p>Get the standard page size id.</p> <p>Returns:</p> Type Description <code>str</code> <p>page size id</p> Source code in <code>prettyqt\\gui\\pagesize.py</code> <pre><code>def get_id(self) -&gt; str:\n\"\"\"Get the standard page size id.\n    Returns:\n        page size id\n    \"\"\"\nreturn PAGE_SIZE_ID.inverse[self.id()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PaintDeviceMixin","title":"<code>PaintDeviceMixin</code>","text":"Source code in <code>prettyqt\\gui\\paintdevice.py</code> <pre><code>class PaintDeviceMixin:\ndef get_metric(self, metric: MetricStr | QtGui.QPaintDevice.PaintDeviceMetric) -&gt; int:\n\"\"\"Return metric information.\n        Args:\n            metric: metric information to get\n        Returns:\n            metric information\n        \"\"\"\nreturn self.metric(METRICS.get_enum_value(metric))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.paintdevice.PaintDeviceMixin.get_metric","title":"<code>get_metric(metric: MetricStr | QtGui.QPaintDevice.PaintDeviceMetric) -&gt; int</code>","text":"<p>Return metric information.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>MetricStr | QtGui.QPaintDevice.PaintDeviceMetric</code> <p>metric information to get</p> required <p>Returns:</p> Type Description <code>int</code> <p>metric information</p> Source code in <code>prettyqt\\gui\\paintdevice.py</code> <pre><code>def get_metric(self, metric: MetricStr | QtGui.QPaintDevice.PaintDeviceMetric) -&gt; int:\n\"\"\"Return metric information.\n    Args:\n        metric: metric information to get\n    Returns:\n        metric information\n    \"\"\"\nreturn self.metric(METRICS.get_enum_value(metric))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PainterMixin","title":"<code>PainterMixin</code>","text":"Source code in <code>prettyqt\\gui\\painter.py</code> <pre><code>class PainterMixin:\ndef __enter__(self):\nreturn self\ndef __exit__(self, typ, value, traceback):\nself.end()\n@contextlib.contextmanager\ndef paint_on(self, obj) -&gt; Iterator[Painter]:\nself.begin(obj)\nyield self\nself.end()\n@contextlib.contextmanager\ndef backup_state(self) -&gt; Iterator[Painter]:\nself.save()\nyield self\nself.restore()\n@contextlib.contextmanager\ndef native_mode(self) -&gt; Iterator[Painter]:\nself.beginNativePainting()\nyield self\nself.endNativePainting()\n@contextlib.contextmanager\ndef edit_pen(self) -&gt; Iterator[gui.Pen]:\npen = gui.Pen(self.pen())\nyield pen\nself.setPen(pen)\n@contextlib.contextmanager\ndef edit_font(self) -&gt; Iterator[gui.Font]:\nfont = gui.Font(self.font())\nyield font\nself.setFont(font)\ndef draw_text(\nself,\nposition: datatypes.PointType | datatypes.RectType | datatypes.RectFType,\ntext: str,\nalignment: constants.AlignmentStr = \"center\",\n):\nmatch position:\ncase (_, _):\nposition = core.Point(*position)\ncase (_, _, _, _):\nposition = core.RectF(*position)\nself.drawText(position, constants.ALIGNMENTS[alignment].value, text)\ndef draw_image(\nself,\ntarget: QtCore.QPoint | QtCore.QPointF | QtCore.QRect | QtCore.QRectF,\nframe_buffer: QtGui.QImage,\n):\nself.set_composition_mode(\"source_atop\")\nself.drawImage(target, frame_buffer)\ndef draw_polygon(\nself,\npoints: (\nQtGui.QPolygon | QtGui.QPolygonF | list[QtCore.QPoint] | list[QtCore.QPointF]\n),\nfill_rule: constants.FillRuleStr | constants.FillRule = \"odd_even\",\n):\nself.drawPolygon(points, fillRule=constants.FILL_RULE.get_enum_value(fill_rule))\ndef draw_rounded_rect(\nself,\nrect: datatypes.RectType | datatypes.RectFType,\nx_radius: float,\ny_radius: float,\nrelative: bool = False,\n):\nflag = (\nconstants.SizeMode.RelativeSize\nif relative\nelse constants.SizeMode.AbsoluteSize\n)\nself.drawRoundedRect(datatypes.to_rect(rect), x_radius, y_radius, flag)\ndef draw_star(self, size: float = 1.0, fill_rule: constants.FillRuleStr = \"winding\"):\nstar = gui.PolygonF.create_star(size)\nself.drawPolygon(star, constants.FILL_RULE[fill_rule])\ndef draw_diamond(\nself, size: float = 1.0, fill_rule: constants.FillRuleStr = \"winding\"\n):\nstar = gui.PolygonF.create_diamond(size)\nself.drawPolygon(star, constants.FILL_RULE[fill_rule])\ndef use_antialiasing(self):\nself.setRenderHint(self.RenderHint.Antialiasing, True)\ndef fill_rect(\nself,\nrect: datatypes.RectType | datatypes.RectFType,\ncolor: datatypes.ColorType,\npattern: constants.BrushStyleStr | constants.BrushStyle = \"solid\",\n):\ncolor = colors.get_color(color)\nif pattern != \"solid\":\ncolor = gui.Brush(color, constants.BRUSH_STYLE.get_enum_value(pattern))\nself.fillRect(datatypes.to_rect(rect), color)\ndef set_pen(\nself,\nstyle: constants.PenStyleStr | None = \"solid\",\nwidth: float = 1.0,\ncolor: datatypes.ColorType = \"black\",\nbrush: QtGui.QBrush | None = None,\nmiter_limit: float = 2.0,\njoin_style: constants.JoinStyleStr = \"bevel\",\ncap_style: constants.CapStyleStr = \"square\",\n) -&gt; gui.Pen:\n\"\"\"Set pen to use.\n        Args:\n            style: pen style\n            width: pen width\n            color: pen color\n            brush: pen brush\n            miter_limit: miter limit\n            join_style: pen join style\n            cap_style: pen cap style\n        \"\"\"\npen = gui.Pen()\npen.set_style(style)\nif style in [\"none\", None]:\nself.setPen(pen)\nreturn pen\npen.set_cap_style(cap_style)\npen.set_join_style(join_style)\npen.setMiterLimit(miter_limit)\npen.setWidthF(width)\nif brush is not None:\npen.setBrush(brush)\npen.set_color(color)\nself.setPen(pen)\nreturn pen\ndef get_pen(self) -&gt; gui.Pen:\n\"\"\"Return current pen.\n        Returns:\n            current pen\n        \"\"\"\nreturn gui.Pen(self.pen())\ndef set_color(self, color: datatypes.ColorType):\ncolor = colors.get_color(color)\nself.setPen(color)\ndef set_brush(self, brush: QtGui.QBrush | datatypes.ColorType):\nif not isinstance(brush, QtGui.QBrush):\nbrush = colors.get_color(brush)\nself.setBrush(brush)\ndef set_transparent_background(self, transparent: bool = True):\nmode = (\nconstants.BGMode.TransparentMode\nif transparent\nelse constants.BGMode.OpaqueMode\n)\nself.setBackgroundMode(mode)\ndef set_composition_mode(\nself, mode: CompositionModeStr | QtGui.QPainter.CompositionMode\n):\n\"\"\"Set the current composition mode.\n        Arguments:\n            mode: composition mode\n        \"\"\"\nself.setCompositionMode(COMPOSITION_MODE.get_enum_value(mode))\ndef get_composition_mode(self) -&gt; CompositionModeStr:\n\"\"\"Get the current composition mode.\n        Returns:\n            composition mode\n        \"\"\"\nreturn COMPOSITION_MODE.inverse[self.compositionMode()]\ndef set_transform(self, transform: datatypes.TransformType, combine: bool = False):\nself.setTransform(datatypes.to_transform(transform), combine)\ndef get_font_metrics(self) -&gt; gui.FontMetrics:\nreturn gui.FontMetrics(self.fontMetrics())\ndef set_clip_path(\nself,\npath: QtGui.QPainterPath,\noperation: constants.ClipOperationStr | constants.ClipOperation = \"replace\",\n):\nself.setClipPath(path, constants.CLIP_OPERATION.get_enum_value(operation))\ndef get_text_rect(self, text: str) -&gt; core.Rect:\nreturn self.drawText(\ncore.Rect(), constants.TextFlag.TextDontPrint, text\n)  # type: ignore\n@contextlib.contextmanager\ndef clip_path(\nself, operation: constants.ClipOperationStr = \"replace\"\n) -&gt; Iterator[gui.PainterPath]:\npath = gui.PainterPath()\nyield path\nself.set_clip_path(path, operation)\n@contextlib.contextmanager\ndef apply_transform(self, combine: bool = True) -&gt; Iterator[gui.Transform]:\ntransform = gui.Transform()\nyield transform\nself.setTransform(transform, combine)\n@contextlib.contextmanager\ndef offset_by(self, x: int = 0, y: int = 0) -&gt; Iterator[Painter]:\nself.translate(x, y)\nyield self\nself.translate(-x, -y)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.get_composition_mode","title":"<code>get_composition_mode() -&gt; CompositionModeStr</code>","text":"<p>Get the current composition mode.</p> <p>Returns:</p> Type Description <code>CompositionModeStr</code> <p>composition mode</p> Source code in <code>prettyqt\\gui\\painter.py</code> <pre><code>def get_composition_mode(self) -&gt; CompositionModeStr:\n\"\"\"Get the current composition mode.\n    Returns:\n        composition mode\n    \"\"\"\nreturn COMPOSITION_MODE.inverse[self.compositionMode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.get_pen","title":"<code>get_pen() -&gt; gui.Pen</code>","text":"<p>Return current pen.</p> <p>Returns:</p> Type Description <code>gui.Pen</code> <p>current pen</p> Source code in <code>prettyqt\\gui\\painter.py</code> <pre><code>def get_pen(self) -&gt; gui.Pen:\n\"\"\"Return current pen.\n    Returns:\n        current pen\n    \"\"\"\nreturn gui.Pen(self.pen())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.set_composition_mode","title":"<code>set_composition_mode(mode: CompositionModeStr | QtGui.QPainter.CompositionMode)</code>","text":"<p>Set the current composition mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CompositionModeStr | QtGui.QPainter.CompositionMode</code> <p>composition mode</p> required Source code in <code>prettyqt\\gui\\painter.py</code> <pre><code>def set_composition_mode(\nself, mode: CompositionModeStr | QtGui.QPainter.CompositionMode\n):\n\"\"\"Set the current composition mode.\n    Arguments:\n        mode: composition mode\n    \"\"\"\nself.setCompositionMode(COMPOSITION_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.set_pen","title":"<code>set_pen(style: constants.PenStyleStr | None = 'solid', width: float = 1.0, color: datatypes.ColorType = 'black', brush: QtGui.QBrush | None = None, miter_limit: float = 2.0, join_style: constants.JoinStyleStr = 'bevel', cap_style: constants.CapStyleStr = 'square') -&gt; gui.Pen</code>","text":"<p>Set pen to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.PenStyleStr | None</code> <p>pen style</p> <code>'solid'</code> <code>width</code> <code>float</code> <p>pen width</p> <code>1.0</code> <code>color</code> <code>datatypes.ColorType</code> <p>pen color</p> <code>'black'</code> <code>brush</code> <code>QtGui.QBrush | None</code> <p>pen brush</p> <code>None</code> <code>miter_limit</code> <code>float</code> <p>miter limit</p> <code>2.0</code> <code>join_style</code> <code>constants.JoinStyleStr</code> <p>pen join style</p> <code>'bevel'</code> <code>cap_style</code> <code>constants.CapStyleStr</code> <p>pen cap style</p> <code>'square'</code> Source code in <code>prettyqt\\gui\\painter.py</code> <pre><code>def set_pen(\nself,\nstyle: constants.PenStyleStr | None = \"solid\",\nwidth: float = 1.0,\ncolor: datatypes.ColorType = \"black\",\nbrush: QtGui.QBrush | None = None,\nmiter_limit: float = 2.0,\njoin_style: constants.JoinStyleStr = \"bevel\",\ncap_style: constants.CapStyleStr = \"square\",\n) -&gt; gui.Pen:\n\"\"\"Set pen to use.\n    Args:\n        style: pen style\n        width: pen width\n        color: pen color\n        brush: pen brush\n        miter_limit: miter limit\n        join_style: pen join style\n        cap_style: pen cap style\n    \"\"\"\npen = gui.Pen()\npen.set_style(style)\nif style in [\"none\", None]:\nself.setPen(pen)\nreturn pen\npen.set_cap_style(cap_style)\npen.set_join_style(join_style)\npen.setMiterLimit(miter_limit)\npen.setWidthF(width)\nif brush is not None:\npen.setBrush(brush)\npen.set_color(color)\nself.setPen(pen)\nreturn pen\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PainterPath","title":"<code>PainterPath</code>","text":"<p>         Bases: <code>QtGui.QPainterPath</code></p> Source code in <code>prettyqt\\gui\\painterpath.py</code> <pre><code>class PainterPath(QtGui.QPainterPath):\ndef __len__(self):\nreturn self.elementCount()\ndef __getitem__(self, index: int) -&gt; QtGui.QPainterPath.Element:\nreturn self.elementAt(index)\ndef __iter__(self) -&gt; Iterator[QtGui.QPainterPath.Element]:\nreturn iter(self.elementAt(i) for i in range(self.elementCount()))\ndef __setitem__(self, index: int, value: tuple[int, int]):\nself.setElementPositionAt(index, *value)\ndef __iadd__(self, other):\nif not isinstance(\nother,\nQtCore.QPoint | QtCore.QRect | QtGui.QPainterPath | QtGui.QRegion,\n):\nraise ValueError(other)\nself.add(other)\nreturn self\ndef add(\nself, other: QtCore.QPoint | QtCore.QRect | QtGui.QPainterPath | QtGui.QRegion\n):\nmatch other:\ncase QtGui.QPolygonF():\nself.addPolygon(other)\ncase QtGui.QPainterPath():\nself.addPath(other)\ncase QtCore.QRect():\nself.addRect(other)\ncase QtGui.QRegion():\nself.addRegion(other)\ndef __bool__(self):\nreturn not self.isEmpty()\ndef __contains__(self, item: QtCore.QPointF | QtCore.QRectF | QtGui.QPainterPath):\nreturn self.contains(item)\ndef add_rect(self, rect: datatypes.RectType | datatypes.RectFType):\nself.addRect(datatypes.to_rectf(rect))\ndef set_fill_rule(self, rule: constants.FillRuleStr):\n\"\"\"Set fill rule.\n        Args:\n            rule: fill rule to use\n        \"\"\"\nself.setFillRule(constants.FILL_RULE[rule])\ndef get_fill_rule(self) -&gt; constants.FillRuleStr:\n\"\"\"Return current fill rule.\n        Returns:\n            fill rule\n        \"\"\"\nreturn constants.FILL_RULE.inverse[self.fillRule()]\ndef get_bounding_rect(self) -&gt; core.RectF:\nreturn core.RectF(self.boundingRect())\ndef get_simplified(self) -&gt; PainterPath:\nreturn PainterPath(self.simplified())\ndef to_reversed(self) -&gt; PainterPath:\nreturn PainterPath(self.toReversed())\n@classmethod\ndef create_star(cls, size: int):\npath = cls()\nstar_center_x = size / 2\nstar_center_y = size / 2\nradius_outer = size * 0.35\ngolden_ratio = (1 + math.sqrt(5)) / 2\nradius_inner = radius_outer / (1 + golden_ratio)\ntheta_start = math.pi / 2\ntheta_inc = (2 * math.pi) / 10\nfor n in range(11):\ntheta = theta_start + (n * theta_inc)\ntheta = theta % (2 * math.pi)\nif n % 2 == 0:\nx = radius_outer * math.cos(theta)\ny = radius_outer * math.sin(theta)\nelse:\nx = radius_inner * math.cos(theta)\ny = radius_inner * math.sin(theta)\nx_adj = star_center_x - x\ny_adj = star_center_y - y + 3\nif n == 0:\npath.moveTo(x_adj, y_adj)\nelse:\npath.lineTo(x_adj, y_adj)\nreturn path\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.get_fill_rule","title":"<code>get_fill_rule() -&gt; constants.FillRuleStr</code>","text":"<p>Return current fill rule.</p> <p>Returns:</p> Type Description <code>constants.FillRuleStr</code> <p>fill rule</p> Source code in <code>prettyqt\\gui\\painterpath.py</code> <pre><code>def get_fill_rule(self) -&gt; constants.FillRuleStr:\n\"\"\"Return current fill rule.\n    Returns:\n        fill rule\n    \"\"\"\nreturn constants.FILL_RULE.inverse[self.fillRule()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.set_fill_rule","title":"<code>set_fill_rule(rule: constants.FillRuleStr)</code>","text":"<p>Set fill rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>constants.FillRuleStr</code> <p>fill rule to use</p> required Source code in <code>prettyqt\\gui\\painterpath.py</code> <pre><code>def set_fill_rule(self, rule: constants.FillRuleStr):\n\"\"\"Set fill rule.\n    Args:\n        rule: fill rule to use\n    \"\"\"\nself.setFillRule(constants.FILL_RULE[rule])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PainterPathStroker","title":"<code>PainterPathStroker</code>","text":"<p>         Bases: <code>QtGui.QPainterPathStroker</code></p> Source code in <code>prettyqt\\gui\\painterpathstroker.py</code> <pre><code>class PainterPathStroker(QtGui.QPainterPathStroker):\ndef set_cap_style(self, style: constants.CapStyleStr | constants.PenCapStyle):\n\"\"\"Set cap style to use.\n        Args:\n            style: cap style to use\n        \"\"\"\nself.setCapStyle(constants.CAP_STYLE.get_enum_value(style))\ndef get_cap_style(self) -&gt; constants.CapStyleStr | constants.PenCapStyle:\n\"\"\"Return current cap style.\n        Returns:\n            cap style\n        \"\"\"\nreturn constants.CAP_STYLE.inverse[self.capStyle()]\ndef set_join_style(self, style: constants.JoinStyleStr | constants.PenJoinStyle):\n\"\"\"Set join style to use.\n        Args:\n            style: join style to use\n        \"\"\"\nself.setJoinStyle(constants.JOIN_STYLE.get_enum_value(style))\ndef get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n        Returns:\n            join style\n        \"\"\"\nreturn constants.JOIN_STYLE.inverse[self.joinStyle()]\ndef create_stroke(self, path: QtGui.QPainterPath) -&gt; gui.PainterPath:\nreturn gui.PainterPath(self.createStroke(path))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_cap_style","title":"<code>get_cap_style() -&gt; constants.CapStyleStr | constants.PenCapStyle</code>","text":"<p>Return current cap style.</p> <p>Returns:</p> Type Description <code>constants.CapStyleStr | constants.PenCapStyle</code> <p>cap style</p> Source code in <code>prettyqt\\gui\\painterpathstroker.py</code> <pre><code>def get_cap_style(self) -&gt; constants.CapStyleStr | constants.PenCapStyle:\n\"\"\"Return current cap style.\n    Returns:\n        cap style\n    \"\"\"\nreturn constants.CAP_STYLE.inverse[self.capStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_join_style","title":"<code>get_join_style() -&gt; constants.JoinStyleStr</code>","text":"<p>Return current join style.</p> <p>Returns:</p> Type Description <code>constants.JoinStyleStr</code> <p>join style</p> Source code in <code>prettyqt\\gui\\painterpathstroker.py</code> <pre><code>def get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n    Returns:\n        join style\n    \"\"\"\nreturn constants.JOIN_STYLE.inverse[self.joinStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_cap_style","title":"<code>set_cap_style(style: constants.CapStyleStr | constants.PenCapStyle)</code>","text":"<p>Set cap style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.CapStyleStr | constants.PenCapStyle</code> <p>cap style to use</p> required Source code in <code>prettyqt\\gui\\painterpathstroker.py</code> <pre><code>def set_cap_style(self, style: constants.CapStyleStr | constants.PenCapStyle):\n\"\"\"Set cap style to use.\n    Args:\n        style: cap style to use\n    \"\"\"\nself.setCapStyle(constants.CAP_STYLE.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_join_style","title":"<code>set_join_style(style: constants.JoinStyleStr | constants.PenJoinStyle)</code>","text":"<p>Set join style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.JoinStyleStr | constants.PenJoinStyle</code> <p>join style to use</p> required Source code in <code>prettyqt\\gui\\painterpathstroker.py</code> <pre><code>def set_join_style(self, style: constants.JoinStyleStr | constants.PenJoinStyle):\n\"\"\"Set join style to use.\n    Args:\n        style: join style to use\n    \"\"\"\nself.setJoinStyle(constants.JOIN_STYLE.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Palette","title":"<code>Palette</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QPalette</code></p> Source code in <code>prettyqt\\gui\\palette.py</code> <pre><code>class Palette(serializemixin.SerializeMixin, QtGui.QPalette):\ndef __getitem__(self, index: RoleStr | QtGui.QPalette.ColorRole) -&gt; gui.Color:\nreturn self.get_color(index)\ndef __setitem__(\nself, index: RoleStr | QtGui.QPalette.ColorRole, value: datatypes.ColorType\n):\nself.set_color(index, value)\ndef __repr__(self):\nreturn get_repr(self, self.get_color(\"button\"), self.get_color(\"window\"))\ndef highlight_inactive(self, enable: bool = True):\nif enable:\ncolor = self.color(self.ColorGroup.Active, self.ColorRole.Highlight)\nelse:\npal = gui.Palette()\ncolor = pal.color(self.ColorGroup.Inactive, self.ColorRole.Highlight)\nself.setColor(self.ColorGroup.Inactive, self.ColorRole.Highlight, color)\ndef set_color(\nself,\nrole: RoleStr | QtGui.QPalette.ColorRole,\ncolor: datatypes.ColorType,\ngroup: GroupStr | QtGui.QPalette.ColorGroup = \"active\",\n):\ncolor = colors.get_color(color)\nself.setColor(GROUP.get_enum_value(group), ROLE.get_enum_value(role), color)\ndef get_colors(\nself, group: GroupStr | QtGui.QPalette.ColorGroup = \"active\"\n) -&gt; dict[str, gui.Color]:\nreturn {k: self.get_color(k, group) for k in ROLE}\ndef get_color(\nself,\nrole: RoleStr | QtGui.QPalette.ColorRole,\ngroup: GroupStr | QtGui.QPalette.ColorGroup = \"active\",\n) -&gt; gui.Color:\nreturn gui.Color(\nself.color(GROUP.get_enum_value(group), ROLE.get_enum_value(role))\n)\ndef set_brush(\nself,\nrole: RoleStr | QtGui.QPalette.ColorRole,\nbrush: datatypes.ColorAndBrushType,\ngroup: GroupStr | QtGui.QPalette.ColorGroup = \"active\",\n):\nif not isinstance(brush, QtGui.QBrush):\nbrush = gui.Brush(colors.get_color(brush))\nself.setBrush(GROUP.get_enum_value(group), ROLE.get_enum_value(role), brush)\ndef get_brushes(\nself, group: GroupStr | QtGui.QPalette.ColorGroup = \"active\"\n) -&gt; dict[str, gui.Brush]:\nreturn {k: self.get_brush(k, group) for k in ROLE}\ndef get_brush(\nself,\nrole: RoleStr | QtGui.QPalette.ColorRole,\ngroup: GroupStr | QtGui.QPalette.ColorGroup = \"active\",\n) -&gt; gui.Brush:\nreturn gui.Brush(\nself.brush(GROUP.get_enum_value(group), ROLE.get_enum_value(role))\n)\ndef set_color_group(\nself, group: GroupStr | QtGui.QPalette.ColorGroup, **kwargs: QtGui.QBrush\n):\n\"\"\"Set the color group.\n        Args:\n            group: color group to use\n            kwargs: keyword arguments passed to setColorGroup\n        \"\"\"\nself.setColorGroup(GROUP.get_enum_value(group), **kwargs)\ndef get_color_group(self) -&gt; GroupStr:\n\"\"\"Return color group.\n        Returns:\n            color group\n        \"\"\"\nreturn GROUP.inverse[self.colorGroup()]\ndef inverted(self) -&gt; Self:\npal = type(self)()\nfor group in GROUP:\nfor role in ROLE:\ncolor = self.get_color(role, group)\npal.set_color(role, color.inverted(), group)\nreturn pal\n@classmethod\ndef create_dark_palette(cls) -&gt; Self:\npal = cls()\npal.set_color(\"window\", gui.Color(53, 53, 53))\npal.set_color(\"window_text\", \"white\")\npal.set_color(\"window_text\", \"grey\", group=\"disabled\")\npal.set_color(\"base\", gui.Color(25, 25, 25))\npal.set_color(\"alternate_base\", gui.Color(53, 53, 53))\npal.set_color(\"tool_tip_base\", \"slategrey\")\npal.set_color(\"tool_tip_base\", \"slategrey\", group=\"inactive\")\npal.set_color(\"tool_tip_text\", \"white\")\npal.set_color(\"tool_tip_text\", \"white\", group=\"inactive\")\npal.set_color(\"text\", \"white\")\npal.set_color(\"text\", \"grey\", group=\"disabled\")\npal.set_color(\"button\", gui.Color(53, 53, 53))\npal.set_color(\"button_text\", \"white\")\npal.set_color(\"button_text\", \"grey\", group=\"disabled\")\npal.set_color(\"bright_text\", \"red\")\npal.set_color(\"link\", \"dodgerblue\")\npal.set_color(\"highlight\", \"dodgerblue\")\npal.set_color(\"highlight\", gui.Color(80, 80, 80), group=\"disabled\")\npal.set_color(\"highlighted_text\", \"black\")\npal.set_color(\"highlighted_text\", \"grey\", group=\"disabled\")\nreturn pal\ndef is_dark(self) -&gt; bool:\ncol = self.color(self.ColorRole.Window)\nreturn max(col.getRgb()[:3]) &lt; 115\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.palette.Palette.get_color_group","title":"<code>get_color_group() -&gt; GroupStr</code>","text":"<p>Return color group.</p> <p>Returns:</p> Type Description <code>GroupStr</code> <p>color group</p> Source code in <code>prettyqt\\gui\\palette.py</code> <pre><code>def get_color_group(self) -&gt; GroupStr:\n\"\"\"Return color group.\n    Returns:\n        color group\n    \"\"\"\nreturn GROUP.inverse[self.colorGroup()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.palette.Palette.set_color_group","title":"<code>set_color_group(group: GroupStr | QtGui.QPalette.ColorGroup, **kwargs: QtGui.QBrush)</code>","text":"<p>Set the color group.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>GroupStr | QtGui.QPalette.ColorGroup</code> <p>color group to use</p> required <code>kwargs</code> <code>QtGui.QBrush</code> <p>keyword arguments passed to setColorGroup</p> <code>{}</code> Source code in <code>prettyqt\\gui\\palette.py</code> <pre><code>def set_color_group(\nself, group: GroupStr | QtGui.QPalette.ColorGroup, **kwargs: QtGui.QBrush\n):\n\"\"\"Set the color group.\n    Args:\n        group: color group to use\n        kwargs: keyword arguments passed to setColorGroup\n    \"\"\"\nself.setColorGroup(GROUP.get_enum_value(group), **kwargs)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PdfWriter","title":"<code>PdfWriter</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>gui.PagedPaintDeviceMixin</code>, <code>QtGui.QPdfWriter</code></p> Source code in <code>prettyqt\\gui\\pdfwriter.py</code> <pre><code>class PdfWriter(core.ObjectMixin, gui.PagedPaintDeviceMixin, QtGui.QPdfWriter):\ndef set_desktop_resolution(self):\nprimary = gui.app().primaryScreen()\ndpi = primary.logicalDotsPerInch()\nself.setResolution(int(dpi))\ndef set_page_margins(\nself,\nmargins: datatypes.MarginsFType,\nunit: gui.pagelayout.UnitStr | gui.PageLayout.Unit | None = None,\n) -&gt; bool:\nmargins = datatypes.to_marginsf(margins)\nif unit is None:\nreturn self.setPageMargins(margins)\nreturn self.setPageMargins(margins, gui.pagelayout.UNITS.get_enum_value(unit))\ndef get_pdf_version(self) -&gt; gui.pagedpaintdevice.PdfVersionStr:\nreturn gui.pagedpaintdevice.PDF_VERSION.inverse[self.pdfVersion()]\ndef set_pdf_version(\nself,\nversion: gui.pagedpaintdevice.PdfVersionStr | gui.PagedPaintDevice.PdfVersion,\n):\n\"\"\"Set pdf version.\n        Args:\n            version: pdf version\n        \"\"\"\nself.setPdfVersion(gui.pagedpaintdevice.PDF_VERSION.get_enum_value(version))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pdfwriter.PdfWriter.set_pdf_version","title":"<code>set_pdf_version(version: gui.pagedpaintdevice.PdfVersionStr | gui.PagedPaintDevice.PdfVersion)</code>","text":"<p>Set pdf version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>gui.pagedpaintdevice.PdfVersionStr | gui.PagedPaintDevice.PdfVersion</code> <p>pdf version</p> required Source code in <code>prettyqt\\gui\\pdfwriter.py</code> <pre><code>def set_pdf_version(\nself,\nversion: gui.pagedpaintdevice.PdfVersionStr | gui.PagedPaintDevice.PdfVersion,\n):\n\"\"\"Set pdf version.\n    Args:\n        version: pdf version\n    \"\"\"\nself.setPdfVersion(gui.pagedpaintdevice.PDF_VERSION.get_enum_value(version))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Pen","title":"<code>Pen</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QPen</code></p> Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>class Pen(serializemixin.SerializeMixin, QtGui.QPen):\ndef __repr__(self):\nreturn get_repr(self, self.get_color())\ndef set_color(self, color: datatypes.ColorType):\ncolor = colors.get_color(color)\nself.setColor(color)\ndef get_color(self) -&gt; gui.Color:\nreturn gui.Color(self.color())\ndef get_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.brush())\ndef set_cap_style(self, style: constants.CapStyleStr | constants.PenCapStyle):\n\"\"\"Set cap style to use.\n        Args:\n            style: cap style to use\n        \"\"\"\nself.setCapStyle(constants.CAP_STYLE.get_enum_value(style))\ndef get_cap_style(self) -&gt; constants.CapStyleStr:\n\"\"\"Return current cap style.\n        Returns:\n            cap style\n        \"\"\"\nreturn constants.CAP_STYLE.inverse[self.capStyle()]\ndef set_join_style(self, style: constants.JoinStyleStr | constants.PenJoinStyle):\n\"\"\"Set join style to use.\n        Args:\n            style: join style to use\n        \"\"\"\nself.setJoinStyle(constants.JOIN_STYLE.get_enum_value(style))\ndef get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n        Returns:\n            join style\n        \"\"\"\nreturn constants.JOIN_STYLE.inverse[self.joinStyle()]\ndef set_style(\nself, style: constants.PenStyleStr | constants.PenStyle | list[float] | None\n):\n\"\"\"Set pen style to use.\n        Args:\n            style: pen style to use\n        \"\"\"\nif isinstance(style, list):\nself.setDashPattern(style)\nelse:\nif style is None:\nstyle = \"none\"\nself.setStyle(constants.PEN_STYLE.get_enum_value(style))\ndef get_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return current pen style.\n        Returns:\n            pen style\n        \"\"\"\nreturn constants.PEN_STYLE.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_cap_style","title":"<code>get_cap_style() -&gt; constants.CapStyleStr</code>","text":"<p>Return current cap style.</p> <p>Returns:</p> Type Description <code>constants.CapStyleStr</code> <p>cap style</p> Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def get_cap_style(self) -&gt; constants.CapStyleStr:\n\"\"\"Return current cap style.\n    Returns:\n        cap style\n    \"\"\"\nreturn constants.CAP_STYLE.inverse[self.capStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_join_style","title":"<code>get_join_style() -&gt; constants.JoinStyleStr</code>","text":"<p>Return current join style.</p> <p>Returns:</p> Type Description <code>constants.JoinStyleStr</code> <p>join style</p> Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n    Returns:\n        join style\n    \"\"\"\nreturn constants.JOIN_STYLE.inverse[self.joinStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_style","title":"<code>get_style() -&gt; constants.PenStyleStr</code>","text":"<p>Return current pen style.</p> <p>Returns:</p> Type Description <code>constants.PenStyleStr</code> <p>pen style</p> Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def get_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return current pen style.\n    Returns:\n        pen style\n    \"\"\"\nreturn constants.PEN_STYLE.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_cap_style","title":"<code>set_cap_style(style: constants.CapStyleStr | constants.PenCapStyle)</code>","text":"<p>Set cap style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.CapStyleStr | constants.PenCapStyle</code> <p>cap style to use</p> required Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def set_cap_style(self, style: constants.CapStyleStr | constants.PenCapStyle):\n\"\"\"Set cap style to use.\n    Args:\n        style: cap style to use\n    \"\"\"\nself.setCapStyle(constants.CAP_STYLE.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_join_style","title":"<code>set_join_style(style: constants.JoinStyleStr | constants.PenJoinStyle)</code>","text":"<p>Set join style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.JoinStyleStr | constants.PenJoinStyle</code> <p>join style to use</p> required Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def set_join_style(self, style: constants.JoinStyleStr | constants.PenJoinStyle):\n\"\"\"Set join style to use.\n    Args:\n        style: join style to use\n    \"\"\"\nself.setJoinStyle(constants.JOIN_STYLE.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_style","title":"<code>set_style(style: constants.PenStyleStr | constants.PenStyle | list[float] | None)</code>","text":"<p>Set pen style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.PenStyleStr | constants.PenStyle | list[float] | None</code> <p>pen style to use</p> required Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def set_style(\nself, style: constants.PenStyleStr | constants.PenStyle | list[float] | None\n):\n\"\"\"Set pen style to use.\n    Args:\n        style: pen style to use\n    \"\"\"\nif isinstance(style, list):\nself.setDashPattern(style)\nelse:\nif style is None:\nstyle = \"none\"\nself.setStyle(constants.PEN_STYLE.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PixmapMixin","title":"<code>PixmapMixin</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>gui.PaintDeviceMixin</code></p> Source code in <code>prettyqt\\gui\\pixmap.py</code> <pre><code>class PixmapMixin(serializemixin.SerializeMixin, gui.PaintDeviceMixin):\ndef __bool__(self):\nreturn not self.isNull()\ndef __eq__(self, other):\nreturn self.toImage() == other.toImage() if isinstance(other, Pixmap) else False\ndef __hash__(self):\nreturn self.cacheKey()\n@classmethod\ndef from_file(cls, path: datatypes.PathType) -&gt; Self:\npath = pathlib.Path(path)\nwith path.open(mode=\"rb\") as f:\ndata = f.read()\n# Create widget\npixmap = cls()\npixmap.loadFromData(QtCore.QByteArray(data))\nreturn pixmap\n@classmethod\ndef from_image(\ncls,\nimg: QtGui.QImage,\ncolor_preference: constants.ColorPreferenceStr = \"auto\",\ndithering: constants.DitherPreferenceStr = \"diffuse\",\nalpha_dithering: constants.AlphaDitherPreferenceStr = \"threshold\",\nmode_preference: constants.ModePreferenceStr = \"auto\",\n) -&gt; Self:\nflag = constants.ImageConversionFlag(0)\nflag |= constants.COLOR_PREFERENCE.inverse[color_preference]\nflag |= constants.DITHER_PREFERENCE.inverse[dithering]\nflag |= constants.ALPHA_DITHER_PREFERENCE.inverse[alpha_dithering]\nflag |= constants.MODE_PREFERENCE.inverse[mode_preference]\nreturn cls(cls.fromImage(img, flag))\ndef save_to_file(\nself, path: os.PathLike, fmt: str = \"png\", quality: int | None = None\n) -&gt; bool:\nreturn self.save(os.fspath(path), fmt, -1 if quality is None else quality)\ndef get_size(self) -&gt; core.Size:\nreturn core.Size(self.size())\ndef get_rect(self) -&gt; core.Rect:\nreturn core.Rect(self.rect())\ndef to_image(self) -&gt; gui.Image:\nreturn gui.Image(self.toImage())\ndef rotated(self, rotation: int) -&gt; Pixmap:\nw, h = self.width(), self.height()\npixmap = self.transformed(gui.Transform().rotate(rotation))\nreturn pixmap.copy((pixmap.width() - w) // 2, (pixmap.height() - h) // 2, w, h)\ndef get_image_data_url(self) -&gt; str:\n\"\"\"Render the contents of the pixmap as a data URL (RFC-2397).\n        Returns:\n            datauri : str\n        \"\"\"\ndevice = core.Buffer()\nassert device.open_file(\"read_write\")\nself.save(device, b\"png\")\ndevice.close()\ndata = bytes(device.data())\npayload = base64.b64encode(data).decode(\"ascii\")\nreturn f\"data:image/png;base64,{payload}\"\n@classmethod\ndef create_dot(cls, color: datatypes.ColorType = \"black\", size: int = 16) -&gt; Self:\ncol = colors.get_color(color)\npx = cls(size, size)\npx.fill(constants.GlobalColor.transparent)  # type: ignore\npx_size = px.rect().adjusted(1, 1, -1, -1)\nwith gui.Painter(px) as painter:\npainter.use_antialiasing()\npainter.setBrush(col)\npen_color = gui.Color(15, 15, 15)\npainter.set_pen(color=pen_color, width=1)\npainter.drawEllipse(px_size)\nreturn px\n@classmethod\ndef create_checkerboard_pattern(\ncls, n: int, color_1: datatypes.ColorType, color_2: datatypes.ColorType\n) -&gt; Self:\n\"\"\"Construct tileable checkerboard pattern for paint events.\"\"\"\n# Brush will be an nxn checkerboard pattern\npat = cls(2 * n, 2 * n)\nbg0 = colors.get_color(color_1)\nbg1 = colors.get_color(color_2)\nwith gui.Painter(pat) as p:\np.setPen(constants.PenStyle.NoPen)\n# Paint a checkerboard pattern for the color to be overlaid on\np.fillRect(pat.rect(), bg0)\np.fillRect(0, 0, n, n, bg1)\np.fillRect(n, n, 2 * n, 2 * n, bg1)\nreturn pat\n@classmethod\ndef create_char(\ncls,\nchar: str,\nsize: int,\nbackground: datatypes.ColorType = \"black\",\ncolor: datatypes.ColorType = \"white\",\n) -&gt; Self:\npixmap = cls(size, size)\npixmap.fill(constants.GlobalColor.transparent)\nwith gui.Painter(pixmap) as painter:\npainter.setRenderHints(\npainter.RenderHint.Antialiasing\n| painter.RenderHint.TextAntialiasing\n| painter.RenderHint.SmoothPixmapTransform\n)\npainter.set_pen(color=background)\npainter.set_brush(background)\nmargin = 1 + size // 16\ntext_margin = size // 20\nw = size - 2 * margin\nrect = core.RectF(margin, margin, w, w)\npainter.draw_rounded_rect(rect, 30, 30, relative=True)\npainter.set_pen(color=color)\nwith painter.edit_font() as font:  # type: QtGui.QFont\nfont.setPixelSize(size - 2 * margin - 2 * text_margin)\npainter.draw_text(rect, char, alignment=\"center\")\nreturn pixmap\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pixmap.PixmapMixin.create_checkerboard_pattern","title":"<code>create_checkerboard_pattern(n: int, color_1: datatypes.ColorType, color_2: datatypes.ColorType) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Construct tileable checkerboard pattern for paint events.</p> Source code in <code>prettyqt\\gui\\pixmap.py</code> <pre><code>@classmethod\ndef create_checkerboard_pattern(\ncls, n: int, color_1: datatypes.ColorType, color_2: datatypes.ColorType\n) -&gt; Self:\n\"\"\"Construct tileable checkerboard pattern for paint events.\"\"\"\n# Brush will be an nxn checkerboard pattern\npat = cls(2 * n, 2 * n)\nbg0 = colors.get_color(color_1)\nbg1 = colors.get_color(color_2)\nwith gui.Painter(pat) as p:\np.setPen(constants.PenStyle.NoPen)\n# Paint a checkerboard pattern for the color to be overlaid on\np.fillRect(pat.rect(), bg0)\np.fillRect(0, 0, n, n, bg1)\np.fillRect(n, n, 2 * n, 2 * n, bg1)\nreturn pat\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pixmap.PixmapMixin.get_image_data_url","title":"<code>get_image_data_url() -&gt; str</code>","text":"<p>Render the contents of the pixmap as a data URL (RFC-2397).</p> <p>Returns:</p> Name Type Description <code>datauri</code> <code>str</code> <p>str</p> Source code in <code>prettyqt\\gui\\pixmap.py</code> <pre><code>def get_image_data_url(self) -&gt; str:\n\"\"\"Render the contents of the pixmap as a data URL (RFC-2397).\n    Returns:\n        datauri : str\n    \"\"\"\ndevice = core.Buffer()\nassert device.open_file(\"read_write\")\nself.save(device, b\"png\")\ndevice.close()\ndata = bytes(device.data())\npayload = base64.b64encode(data).decode(\"ascii\")\nreturn f\"data:image/png;base64,{payload}\"\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.SessionManager","title":"<code>SessionManager</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\gui\\sessionmanager.py</code> <pre><code>class SessionManager(core.ObjectMixin):\ndef __init__(self, item: QtGui.QSessionManager):\nself.item = item\ndef __getattr__(self, val):\nreturn getattr(self.item, val)\ndef set_restart_hint(self, style: RestartHintStr | QtGui.QSessionManager.RestartHint):\n\"\"\"Set the restart hint.\n        Args:\n            style: restart hint\n        \"\"\"\nself.setRestartHint(RESTART_HINT.get_enum_value(style))\ndef get_restart_hint(self) -&gt; RestartHintStr:\n\"\"\"Return current restart hint.\n        Returns:\n            restart hint\n        \"\"\"\nreturn RESTART_HINT.inverse[self.restartHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.get_restart_hint","title":"<code>get_restart_hint() -&gt; RestartHintStr</code>","text":"<p>Return current restart hint.</p> <p>Returns:</p> Type Description <code>RestartHintStr</code> <p>restart hint</p> Source code in <code>prettyqt\\gui\\sessionmanager.py</code> <pre><code>def get_restart_hint(self) -&gt; RestartHintStr:\n\"\"\"Return current restart hint.\n    Returns:\n        restart hint\n    \"\"\"\nreturn RESTART_HINT.inverse[self.restartHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.set_restart_hint","title":"<code>set_restart_hint(style: RestartHintStr | QtGui.QSessionManager.RestartHint)</code>","text":"<p>Set the restart hint.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>RestartHintStr | QtGui.QSessionManager.RestartHint</code> <p>restart hint</p> required Source code in <code>prettyqt\\gui\\sessionmanager.py</code> <pre><code>def set_restart_hint(self, style: RestartHintStr | QtGui.QSessionManager.RestartHint):\n\"\"\"Set the restart hint.\n    Args:\n        style: restart hint\n    \"\"\"\nself.setRestartHint(RESTART_HINT.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Shortcut","title":"<code>Shortcut</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtGui.QShortcut</code></p> Source code in <code>prettyqt\\gui\\shortcut.py</code> <pre><code>class Shortcut(core.ObjectMixin, QtGui.QShortcut):\ndef __init__(self, *args, **kwargs):\nmatch args:\ncase (str(), *rest):\nargs = (gui.KeySequence(args[0]), *rest)\nsuper().__init__(*args, **kwargs)\ndef __str__(self):\nreturn self.key().toString()\ndef set_context(\nself, context: constants.ShortcutContextStr | constants.ShortcutContext\n):\n\"\"\"Set shortcut context.\n        Args:\n            context: shortcut context\n        \"\"\"\nself.setContext(constants.SHORTCUT_CONTEXT.get_enum_value(context))\ndef get_context(self) -&gt; constants.ShortcutContextStr:\n\"\"\"Return shortcut context.\n        Returns:\n            shortcut context\n        \"\"\"\nreturn constants.SHORTCUT_CONTEXT.inverse[self.context()]\ndef set_key(\nself,\nkey: datatypes.KeyCombinationType,\n):\nkeysequence = gui.KeySequence(key)\nself.setKey(keysequence)\ndef set_keys(self, keys: Iterable[datatypes.KeyCombinationType]):\nkeysequences = [gui.KeySequence(key) for key in keys]\nself.setKeys(keysequences)\ndef get_key(self) -&gt; gui.KeySequence:\n\"\"\"Return the shortcut's key sequence.\n        Returns:\n            Key sequence\n        \"\"\"\nreturn gui.KeySequence(self.key())\ndef get_keys(self) -&gt; list[gui.KeySequence]:\nreturn [gui.KeySequence(i) for i in self.keys()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.shortcut.Shortcut.get_context","title":"<code>get_context() -&gt; constants.ShortcutContextStr</code>","text":"<p>Return shortcut context.</p> <p>Returns:</p> Type Description <code>constants.ShortcutContextStr</code> <p>shortcut context</p> Source code in <code>prettyqt\\gui\\shortcut.py</code> <pre><code>def get_context(self) -&gt; constants.ShortcutContextStr:\n\"\"\"Return shortcut context.\n    Returns:\n        shortcut context\n    \"\"\"\nreturn constants.SHORTCUT_CONTEXT.inverse[self.context()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.shortcut.Shortcut.get_key","title":"<code>get_key() -&gt; gui.KeySequence</code>","text":"<p>Return the shortcut's key sequence.</p> <p>Returns:</p> Type Description <code>gui.KeySequence</code> <p>Key sequence</p> Source code in <code>prettyqt\\gui\\shortcut.py</code> <pre><code>def get_key(self) -&gt; gui.KeySequence:\n\"\"\"Return the shortcut's key sequence.\n    Returns:\n        Key sequence\n    \"\"\"\nreturn gui.KeySequence(self.key())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.shortcut.Shortcut.set_context","title":"<code>set_context(context: constants.ShortcutContextStr | constants.ShortcutContext)</code>","text":"<p>Set shortcut context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>constants.ShortcutContextStr | constants.ShortcutContext</code> <p>shortcut context</p> required Source code in <code>prettyqt\\gui\\shortcut.py</code> <pre><code>def set_context(\nself, context: constants.ShortcutContextStr | constants.ShortcutContext\n):\n\"\"\"Set shortcut context.\n    Args:\n        context: shortcut context\n    \"\"\"\nself.setContext(constants.SHORTCUT_CONTEXT.get_enum_value(context))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.StandardItem","title":"<code>StandardItem</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QStandardItem</code></p> Source code in <code>prettyqt\\gui\\standarditem.py</code> <pre><code>class StandardItem(serializemixin.SerializeMixin, QtGui.QStandardItem):\ndef __repr__(self):\nreturn get_repr(self, self.get_icon(), self.text())\ndef __getitem__(\nself, index: int | slice | tuple[int | slice, int | slice] | QtCore.QModelIndex\n) -&gt; QtGui.QStandardItem | listdelegators.BaseListDelegator[QtGui.QStandardItem]:\nmatch index:\ncase int():\nif index &gt;= self.childCount():\nraise IndexError(index)\nreturn self.child(index)\ncase slice():\nreturn self.__getitem__(index, 0)\ncase int() as row, int() as col:\nreturn self.child(row, col)\ncase (row, col):\nrowcount = self.rowCount()\ncolcount = self.columnCount()\nchildren = [\nself.child(i, j)\nfor i, j in helpers.yield_positions(row, col, rowcount, colcount)\n]\nreturn listdelegators.BaseListDelegator(children)\ncase _:\nraise TypeError(index)\ndef __delitem__(self, index: int | tuple[int, int]):\nitem = self.takeRow(index) if isinstance(index, int) else self.takeChild(*index)\nif item is None:\nraise KeyError(index)\nreturn item\ndef __iter__(self) -&gt; Iterator[QtGui.QStandardItem]:\nreturn iter(self.get_children())\ndef __add__(self, other: str | QtGui.QStandardItem) -&gt; StandardItem:\nmatch other:\ncase QtGui.QStandardItem() | str():\nself.add(other)\nreturn self\ncase _:\nraise TypeError(\"wrong type for addition\")\ndef get_children(self) -&gt; listdelegators.BaseListDelegator[QtGui.QStandardItem]:\nitems = [self.child(index) for index in range(self.rowCount())]\nreturn listdelegators.BaseListDelegator(items)\ndef add(self, *item: str | QtGui.QStandardItem):\nfor i in item:\nnew_item = type(self)(i) if isinstance(i, str) else i\nself.appendRow([new_item])\ndef clone(self) -&gt; Self:\nitem = type(self)()\ncore.DataStream.copy_data(self, item)\nreturn item\ndef set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n        Args:\n            icon: icon to use\n        \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(icon)\ndef set_checkstate(self, state: constants.CheckStateStr | constants.CheckState):\n\"\"\"Set checkstate of the checkbox.\n        Args:\n            state: checkstate to use\n        \"\"\"\nself.setCheckState(constants.CHECK_STATE.get_enum_value(state))\ndef get_checkstate(self) -&gt; constants.CheckStateStr:\n\"\"\"Return checkstate.\n        Returns:\n            checkstate\n        \"\"\"\nreturn constants.CHECK_STATE.inverse[self.checkState()]\ndef set_text_alignment(\nself, alignment: constants.AlignmentStr | constants.AlignmentFlag\n):\n\"\"\"Set the alignment of the text.\n        Args:\n            alignment: alignment for the format\n        \"\"\"\nself.setTextAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\ndef get_text_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current text alignment.\n        Returns:\n            alignment\n        \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.textAlignment()]\ndef get_background(self) -&gt; gui.Brush:\nreturn gui.Brush(self.background())\ndef get_foreground(self) -&gt; gui.Brush:\nreturn gui.Brush(self.foreground())\ndef get_font(self) -&gt; gui.Font:\nreturn gui.Font(self.font())\ndef get_icon(self) -&gt; gui.Icon | None:\nicon = self.icon()\nreturn None if icon.isNull() else gui.Icon(icon)\ndef set_data(self, data: Any, role: constants.ItemDataRoleStr | int):\nitem_role = constants.ITEM_DATA_ROLE[role] if isinstance(role, str) else role\nsuper().setData(data, item_role)\ndef get_data(self, role: constants.ItemDataRoleStr | int):\nitem_role = constants.ITEM_DATA_ROLE[role] if isinstance(role, str) else role\nreturn super().data(item_role)\ndef set_tooltip(\nself,\ntooltip: str | datatypes.PathType,\nsize: datatypes.SizeType | None = None,\nrich_text: bool = False,\n):\nif isinstance(tooltip, os.PathLike):\npath = os.fspath(tooltip)\nif size is None:\ntooltip = f\"&lt;img src={path!r}&gt;\"\nelse:\nif isinstance(size, QtCore.QSize):\nsize = (size.width(), size.height())\ntooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\nif rich_text:\ntooltip = f\"&lt;html&gt;{html.escape(tooltip)}&lt;/html&gt;\"\nsuper().setToolTip(tooltip)\ndef set_size_hint(self, hint: datatypes.SizeType):\nself.setSizeHint(datatypes.to_size(hint))\ndef add_item(\nself,\nname: str = \"\",\nicon: datatypes.IconType = None,\ndata: dict | None = None,\nforeground: QtGui.QBrush | None = None,\nbackground: QtGui.QBrush | None = None,\nfont: QtGui.QFont | None = None,\nselectable: bool = True,\nenabled: bool = True,\neditable: bool = False,\nstatus_tip: str = \"\",\ntool_tip: str = \"\",\nwhats_this: str | None = None,\n# text_alignment: Optional[str] = None,\ncheckstate: constants.CheckStateStr | None = None,\nflags: constants.ItemFlag | None = None,\nsize_hint: datatypes.SizeType | None = None,\nis_user_type: bool = False,\n) -&gt; Self:\nitem = type(self)(name)\nif icon is not None:\nicon = iconprovider.get_icon(icon)\nitem.setIcon(icon)\nif data is not None:\nfor k, v in data.items():\nitem.set_data(v, k)\nif foreground is not None:\nitem.setForeground(foreground)\nif background is not None:\nitem.setBackground(background)\nif font is not None:\nitem.setFont(font)\nif flags is not None:\nitem.setFlags(flags)\nif enabled:\nitem.setEnabled(enabled)\nif editable:\nitem.setEditable(editable)\nif selectable:\nitem.setSelectable(selectable)\nif status_tip:\nitem.setStatusTip(status_tip)\nif tool_tip:\nitem.setToolTip(tool_tip)\nif whats_this:\nitem.setWhatsThis(whats_this)\nif size_hint is not None:\nitem.set_size_hint(size_hint)\nif checkstate is not None:\nitem.set_checkstate(checkstate)\nself.appendRow([item])\nreturn item\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.get_checkstate","title":"<code>get_checkstate() -&gt; constants.CheckStateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.CheckStateStr</code> <p>checkstate</p> Source code in <code>prettyqt\\gui\\standarditem.py</code> <pre><code>def get_checkstate(self) -&gt; constants.CheckStateStr:\n\"\"\"Return checkstate.\n    Returns:\n        checkstate\n    \"\"\"\nreturn constants.CHECK_STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.get_text_alignment","title":"<code>get_text_alignment() -&gt; constants.AlignmentStr</code>","text":"<p>Return current text alignment.</p> <p>Returns:</p> Type Description <code>constants.AlignmentStr</code> <p>alignment</p> Source code in <code>prettyqt\\gui\\standarditem.py</code> <pre><code>def get_text_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current text alignment.\n    Returns:\n        alignment\n    \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.textAlignment()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_checkstate","title":"<code>set_checkstate(state: constants.CheckStateStr | constants.CheckState)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.CheckStateStr | constants.CheckState</code> <p>checkstate to use</p> required Source code in <code>prettyqt\\gui\\standarditem.py</code> <pre><code>def set_checkstate(self, state: constants.CheckStateStr | constants.CheckState):\n\"\"\"Set checkstate of the checkbox.\n    Args:\n        state: checkstate to use\n    \"\"\"\nself.setCheckState(constants.CHECK_STATE.get_enum_value(state))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\gui\\standarditem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n    Args:\n        icon: icon to use\n    \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(icon)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_text_alignment","title":"<code>set_text_alignment(alignment: constants.AlignmentStr | constants.AlignmentFlag)</code>","text":"<p>Set the alignment of the text.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr | constants.AlignmentFlag</code> <p>alignment for the format</p> required Source code in <code>prettyqt\\gui\\standarditem.py</code> <pre><code>def set_text_alignment(\nself, alignment: constants.AlignmentStr | constants.AlignmentFlag\n):\n\"\"\"Set the alignment of the text.\n    Args:\n        alignment: alignment for the format\n    \"\"\"\nself.setTextAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.StaticText","title":"<code>StaticText</code>","text":"<p>         Bases: <code>QtGui.QStaticText</code></p> Source code in <code>prettyqt\\gui\\statictext.py</code> <pre><code>class StaticText(QtGui.QStaticText):\ndef __repr__(self):\nreturn get_repr(self, self.text())\ndef __str__(self):\nreturn self.text()\ndef get_size(self) -&gt; core.SizeF:\nreturn core.SizeF(self.size())\ndef set_text_format(\nself, text_format: constants.TextFormatStr | constants.TextFormat\n):\n\"\"\"Set the text format.\n        Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"\n        Args:\n            text_format: text format to use\n        \"\"\"\nself.setTextFormat(constants.TEXT_FORMAT.get_enum_value(text_format))\ndef get_text_format(self) -&gt; constants.TextFormatStr:\n\"\"\"Return current text format.\n        Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"\n        Returns:\n            text format\n        \"\"\"\nreturn constants.TEXT_FORMAT.inverse[self.textFormat()]\ndef set_performance_hint(\nself, hint: PerformanceHintStr | QtGui.QStaticText.PerformanceHint\n):\n\"\"\"Set the performance hint.\n        Args:\n            hint: performance hint to use\n        \"\"\"\nself.setPerformanceHint(PERFORMANCE_HINT.get_enum_value(hint))\ndef get_performance_hint(self) -&gt; PerformanceHintStr:\n\"\"\"Return current performance hint.\n        Returns:\n            performance hint\n        \"\"\"\nreturn PERFORMANCE_HINT.inverse[self.performanceHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_performance_hint","title":"<code>get_performance_hint() -&gt; PerformanceHintStr</code>","text":"<p>Return current performance hint.</p> <p>Returns:</p> Type Description <code>PerformanceHintStr</code> <p>performance hint</p> Source code in <code>prettyqt\\gui\\statictext.py</code> <pre><code>def get_performance_hint(self) -&gt; PerformanceHintStr:\n\"\"\"Return current performance hint.\n    Returns:\n        performance hint\n    \"\"\"\nreturn PERFORMANCE_HINT.inverse[self.performanceHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_text_format","title":"<code>get_text_format() -&gt; constants.TextFormatStr</code>","text":"<p>Return current text format.</p> <p>Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"</p> <p>Returns:</p> Type Description <code>constants.TextFormatStr</code> <p>text format</p> Source code in <code>prettyqt\\gui\\statictext.py</code> <pre><code>def get_text_format(self) -&gt; constants.TextFormatStr:\n\"\"\"Return current text format.\n    Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"\n    Returns:\n        text format\n    \"\"\"\nreturn constants.TEXT_FORMAT.inverse[self.textFormat()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_performance_hint","title":"<code>set_performance_hint(hint: PerformanceHintStr | QtGui.QStaticText.PerformanceHint)</code>","text":"<p>Set the performance hint.</p> <p>Parameters:</p> Name Type Description Default <code>hint</code> <code>PerformanceHintStr | QtGui.QStaticText.PerformanceHint</code> <p>performance hint to use</p> required Source code in <code>prettyqt\\gui\\statictext.py</code> <pre><code>def set_performance_hint(\nself, hint: PerformanceHintStr | QtGui.QStaticText.PerformanceHint\n):\n\"\"\"Set the performance hint.\n    Args:\n        hint: performance hint to use\n    \"\"\"\nself.setPerformanceHint(PERFORMANCE_HINT.get_enum_value(hint))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_text_format","title":"<code>set_text_format(text_format: constants.TextFormatStr | constants.TextFormat)</code>","text":"<p>Set the text format.</p> <p>Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"</p> <p>Parameters:</p> Name Type Description Default <code>text_format</code> <code>constants.TextFormatStr | constants.TextFormat</code> <p>text format to use</p> required Source code in <code>prettyqt\\gui\\statictext.py</code> <pre><code>def set_text_format(\nself, text_format: constants.TextFormatStr | constants.TextFormat\n):\n\"\"\"Set the text format.\n    Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"\n    Args:\n        text_format: text format to use\n    \"\"\"\nself.setTextFormat(constants.TEXT_FORMAT.get_enum_value(text_format))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.SurfaceMixin","title":"<code>SurfaceMixin</code>","text":"Source code in <code>prettyqt\\gui\\surface.py</code> <pre><code>class SurfaceMixin:\ndef __repr__(self):\nreturn get_repr(self)\ndef get_surface_class(self) -&gt; SurfaceClassStr:\n\"\"\"Get the current surface class.\n        Returns:\n            surface class\n        \"\"\"\nreturn SURFACE_CLASS.inverse[self.surfaceClass()]\ndef get_surface_type(self) -&gt; SurfaceTypeStr:\n\"\"\"Get the current surface type.\n        Returns:\n            surface type\n        \"\"\"\nreturn SURFACE_TYPES.inverse[self.surfaceType()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.surface.SurfaceMixin.get_surface_class","title":"<code>get_surface_class() -&gt; SurfaceClassStr</code>","text":"<p>Get the current surface class.</p> <p>Returns:</p> Type Description <code>SurfaceClassStr</code> <p>surface class</p> Source code in <code>prettyqt\\gui\\surface.py</code> <pre><code>def get_surface_class(self) -&gt; SurfaceClassStr:\n\"\"\"Get the current surface class.\n    Returns:\n        surface class\n    \"\"\"\nreturn SURFACE_CLASS.inverse[self.surfaceClass()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.surface.SurfaceMixin.get_surface_type","title":"<code>get_surface_type() -&gt; SurfaceTypeStr</code>","text":"<p>Get the current surface type.</p> <p>Returns:</p> Type Description <code>SurfaceTypeStr</code> <p>surface type</p> Source code in <code>prettyqt\\gui\\surface.py</code> <pre><code>def get_surface_type(self) -&gt; SurfaceTypeStr:\n\"\"\"Get the current surface type.\n    Returns:\n        surface type\n    \"\"\"\nreturn SURFACE_TYPES.inverse[self.surfaceType()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextBlock","title":"<code>TextBlock</code>","text":"<p>         Bases: <code>QtGui.QTextBlock</code></p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>class TextBlock(QtGui.QTextBlock):\ndef __repr__(self):\nreturn get_repr(self, self.text())\ndef __contains__(self, position: int):\nreturn self.contains(position)\ndef __bool__(self):\nreturn self.isValid()\ndef __str__(self):\nreturn self.text()\ndef get_previous(self) -&gt; TextBlock:\nreturn TextBlock(self.previous())\ndef get_next(self) -&gt; TextBlock:\nreturn TextBlock(self.next())\ndef get_text_direction(self) -&gt; constants.LayoutDirectionStr:\nreturn constants.LAYOUT_DIRECTION.inverse[self.textDirection()]\ndef set_user_data(self, data):\nif isinstance(data, QtGui.QTextBlockUserData):\nself.setUserData(data)\nreturn None\nuser_data = UserData(data)\nself.setUserData(user_data)\ndef get_user_data(self):\nuser_data = self.userData()\nreturn user_data.data if isinstance(user_data, UserData) else user_data\n@contextlib.contextmanager\ndef edit_user_state(self):\nstate = self.userState()\nyield state\nself.setUserState(state)\ndef get_state(self) -&gt; int:\n\"\"\"Get the user state, generally used for syntax highlighting.\n        :return: The block state\n        \"\"\"\nstate = self.userState()\nreturn state if state == -1 else state &amp; 0x0000FFFF\ndef set_state(self, state: int):\n\"\"\"Set the user state, generally used for syntax highlighting.\n        :param state: new state value.\n        \"\"\"\nuser_state = self.userState()\nif user_state == -1:\nuser_state = 0\nhigher_part = user_state &amp; 0x7FFF0000\nstate &amp;= 0x0000FFFF\nstate |= higher_part\nself.setUserState(state)\ndef get_fold_level(self) -&gt; int:\n\"\"\"Get the block fold level.\n        :return: The block fold level\n        \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nreturn (state &amp; 0x03FF0000) &gt;&gt; 16\ndef set_fold_level(self, val: int):\n\"\"\"Set the block fold level.\n        :param val: The new fold level [0-7]\n        \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nval = min(val, 0x3FF)\nstate &amp;= 0x7C00FFFF\nstate |= val &lt;&lt; 16\nself.setUserState(state)\ndef is_fold_trigger(self) -&gt; bool:\n\"\"\"Check if the block is a fold trigger.\n        :return: True if the block is a fold trigger (represented as a node in\n            the fold panel)\n        \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nreturn bool(state &amp; 0x04000000)\ndef set_fold_trigger(self, val: int):\n\"\"\"Set the block fold trigger flag (True means the block is a fold trigger).\n        :param val: value to set\n        \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nstate &amp;= 0x7BFFFFFF\nstate |= val &lt;&lt; 26\nself.setUserState(state)\ndef is_collapsed(self) -&gt; bool:\n\"\"\"Check if the block is expanded or collased.\n        :return: False for an open trigger, True for for closed trigger\n        \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nreturn bool(state &amp; 0x08000000)\ndef set_collapsed(self, val: int):\n\"\"\"Set the fold trigger state (collapsed or expanded).\n        :param val: The new trigger state (True=collapsed, False=expanded)\n        \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nstate &amp;= 0x77FFFFFF\nstate |= val &lt;&lt; 27\nself.setUserState(state)\ndef find_parent_scope(self, limit: int = 5000) -&gt; TextBlock | None:\n\"\"\"Find parent scope, if the block is not a fold trigger.\"\"\"\n# if we moved up for more than n lines, just give up otherwise this\n# would take too much time.\ncounter = 0\noriginal = TextBlock(self)\nstart = TextBlock(self)\nif not self.is_fold_trigger():\n# search level of next non blank line\nwhile start.text().strip() == \"\" and start.isValid():\nstart = start.next()\nref_level = self.get_fold_level() - 1\nstart = original\nwhile (\nstart.blockNumber()\nand counter &lt; limit\nand (not self.is_fold_trigger() or self.get_fold_level() &gt; ref_level)\n):\ncounter += 1\nstart = start.previous()\nreturn TextBlock(start) if counter &lt; limit else None\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.find_parent_scope","title":"<code>find_parent_scope(limit: int = 5000) -&gt; TextBlock | None</code>","text":"<p>Find parent scope, if the block is not a fold trigger.</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def find_parent_scope(self, limit: int = 5000) -&gt; TextBlock | None:\n\"\"\"Find parent scope, if the block is not a fold trigger.\"\"\"\n# if we moved up for more than n lines, just give up otherwise this\n# would take too much time.\ncounter = 0\noriginal = TextBlock(self)\nstart = TextBlock(self)\nif not self.is_fold_trigger():\n# search level of next non blank line\nwhile start.text().strip() == \"\" and start.isValid():\nstart = start.next()\nref_level = self.get_fold_level() - 1\nstart = original\nwhile (\nstart.blockNumber()\nand counter &lt; limit\nand (not self.is_fold_trigger() or self.get_fold_level() &gt; ref_level)\n):\ncounter += 1\nstart = start.previous()\nreturn TextBlock(start) if counter &lt; limit else None\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.get_fold_level","title":"<code>get_fold_level() -&gt; int</code>","text":"<p>Get the block fold level.</p> <p>:return: The block fold level</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def get_fold_level(self) -&gt; int:\n\"\"\"Get the block fold level.\n    :return: The block fold level\n    \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nreturn (state &amp; 0x03FF0000) &gt;&gt; 16\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.get_state","title":"<code>get_state() -&gt; int</code>","text":"<p>Get the user state, generally used for syntax highlighting.</p> <p>:return: The block state</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def get_state(self) -&gt; int:\n\"\"\"Get the user state, generally used for syntax highlighting.\n    :return: The block state\n    \"\"\"\nstate = self.userState()\nreturn state if state == -1 else state &amp; 0x0000FFFF\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.is_collapsed","title":"<code>is_collapsed() -&gt; bool</code>","text":"<p>Check if the block is expanded or collased.</p> <p>:return: False for an open trigger, True for for closed trigger</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def is_collapsed(self) -&gt; bool:\n\"\"\"Check if the block is expanded or collased.\n    :return: False for an open trigger, True for for closed trigger\n    \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nreturn bool(state &amp; 0x08000000)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.is_fold_trigger","title":"<code>is_fold_trigger() -&gt; bool</code>","text":"<p>Check if the block is a fold trigger.</p> <p>:return: True if the block is a fold trigger (represented as a node in     the fold panel)</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def is_fold_trigger(self) -&gt; bool:\n\"\"\"Check if the block is a fold trigger.\n    :return: True if the block is a fold trigger (represented as a node in\n        the fold panel)\n    \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nreturn bool(state &amp; 0x04000000)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_collapsed","title":"<code>set_collapsed(val: int)</code>","text":"<p>Set the fold trigger state (collapsed or expanded).</p> <p>:param val: The new trigger state (True=collapsed, False=expanded)</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def set_collapsed(self, val: int):\n\"\"\"Set the fold trigger state (collapsed or expanded).\n    :param val: The new trigger state (True=collapsed, False=expanded)\n    \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nstate &amp;= 0x77FFFFFF\nstate |= val &lt;&lt; 27\nself.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_fold_level","title":"<code>set_fold_level(val: int)</code>","text":"<p>Set the block fold level.</p> <p>:param val: The new fold level [0-7]</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def set_fold_level(self, val: int):\n\"\"\"Set the block fold level.\n    :param val: The new fold level [0-7]\n    \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nval = min(val, 0x3FF)\nstate &amp;= 0x7C00FFFF\nstate |= val &lt;&lt; 16\nself.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_fold_trigger","title":"<code>set_fold_trigger(val: int)</code>","text":"<p>Set the block fold trigger flag (True means the block is a fold trigger).</p> <p>:param val: value to set</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def set_fold_trigger(self, val: int):\n\"\"\"Set the block fold trigger flag (True means the block is a fold trigger).\n    :param val: value to set\n    \"\"\"\nstate = self.userState()\nif state == -1:\nstate = 0\nstate &amp;= 0x7BFFFFFF\nstate |= val &lt;&lt; 26\nself.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_state","title":"<code>set_state(state: int)</code>","text":"<p>Set the user state, generally used for syntax highlighting.</p> <p>:param state: new state value.</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def set_state(self, state: int):\n\"\"\"Set the user state, generally used for syntax highlighting.\n    :param state: new state value.\n    \"\"\"\nuser_state = self.userState()\nif user_state == -1:\nuser_state = 0\nhigher_part = user_state &amp; 0x7FFF0000\nstate &amp;= 0x0000FFFF\nstate |= higher_part\nself.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextBlockFormat","title":"<code>TextBlockFormat</code>","text":"<p>         Bases: <code>gui.TextFormatMixin</code>, <code>QtGui.QTextBlockFormat</code></p> Source code in <code>prettyqt\\gui\\textblockformat.py</code> <pre><code>class TextBlockFormat(gui.TextFormatMixin, QtGui.QTextBlockFormat):\ndef set_marker(self, marker: MarkerTypeStr | QtGui.QTextBlockFormat.MarkerType):\n\"\"\"Set the marker.\n        Args:\n            marker: marker\n        \"\"\"\nself.setMarker(MARKER_TYPE.get_enum_value(marker))\ndef get_marker(self) -&gt; MarkerTypeStr:\n\"\"\"Get current marker.\n        Returns:\n            current marker\n        \"\"\"\nreturn MARKER_TYPE.inverse[self.marker()]\ndef set_alignment(self, alignment: constants.AlignmentStr | constants.AlignmentFlag):\n\"\"\"Set the alignment of the format.\n        Args:\n            alignment: alignment for the format\n        \"\"\"\nself.setAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\ndef get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n        Returns:\n            alignment\n        \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.alignment()]\ndef set_page_break_policy(\nself, policy: gui.textformat.PageBreakFlagStr | gui.QTextFormat.PageBreakFlag\n):\n\"\"\"Set page break policy.\n        Args:\n            policy: page break policy\n        \"\"\"\nself.setPageBreakPolicy(gui.textformat.PAGE_BREAK_FLAG.get_enum_value(policy))\ndef get_page_break_policy(self) -&gt; gui.textformat.PageBreakFlagStr:\n\"\"\"Get the current page break policy.\n        Returns:\n            page break policy\n        \"\"\"\nreturn gui.textformat.PAGE_BREAK_FLAG.inverse[self.pageBreakPolicy()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblockformat.TextBlockFormat.get_alignment","title":"<code>get_alignment() -&gt; constants.AlignmentStr</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.AlignmentStr</code> <p>alignment</p> Source code in <code>prettyqt\\gui\\textblockformat.py</code> <pre><code>def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n    Returns:\n        alignment\n    \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.alignment()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblockformat.TextBlockFormat.get_marker","title":"<code>get_marker() -&gt; MarkerTypeStr</code>","text":"<p>Get current marker.</p> <p>Returns:</p> Type Description <code>MarkerTypeStr</code> <p>current marker</p> Source code in <code>prettyqt\\gui\\textblockformat.py</code> <pre><code>def get_marker(self) -&gt; MarkerTypeStr:\n\"\"\"Get current marker.\n    Returns:\n        current marker\n    \"\"\"\nreturn MARKER_TYPE.inverse[self.marker()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblockformat.TextBlockFormat.get_page_break_policy","title":"<code>get_page_break_policy() -&gt; gui.textformat.PageBreakFlagStr</code>","text":"<p>Get the current page break policy.</p> <p>Returns:</p> Type Description <code>gui.textformat.PageBreakFlagStr</code> <p>page break policy</p> Source code in <code>prettyqt\\gui\\textblockformat.py</code> <pre><code>def get_page_break_policy(self) -&gt; gui.textformat.PageBreakFlagStr:\n\"\"\"Get the current page break policy.\n    Returns:\n        page break policy\n    \"\"\"\nreturn gui.textformat.PAGE_BREAK_FLAG.inverse[self.pageBreakPolicy()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblockformat.TextBlockFormat.set_alignment","title":"<code>set_alignment(alignment: constants.AlignmentStr | constants.AlignmentFlag)</code>","text":"<p>Set the alignment of the format.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr | constants.AlignmentFlag</code> <p>alignment for the format</p> required Source code in <code>prettyqt\\gui\\textblockformat.py</code> <pre><code>def set_alignment(self, alignment: constants.AlignmentStr | constants.AlignmentFlag):\n\"\"\"Set the alignment of the format.\n    Args:\n        alignment: alignment for the format\n    \"\"\"\nself.setAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblockformat.TextBlockFormat.set_marker","title":"<code>set_marker(marker: MarkerTypeStr | QtGui.QTextBlockFormat.MarkerType)</code>","text":"<p>Set the marker.</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>MarkerTypeStr | QtGui.QTextBlockFormat.MarkerType</code> <p>marker</p> required Source code in <code>prettyqt\\gui\\textblockformat.py</code> <pre><code>def set_marker(self, marker: MarkerTypeStr | QtGui.QTextBlockFormat.MarkerType):\n\"\"\"Set the marker.\n    Args:\n        marker: marker\n    \"\"\"\nself.setMarker(MARKER_TYPE.get_enum_value(marker))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblockformat.TextBlockFormat.set_page_break_policy","title":"<code>set_page_break_policy(policy: gui.textformat.PageBreakFlagStr | gui.QTextFormat.PageBreakFlag)</code>","text":"<p>Set page break policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>gui.textformat.PageBreakFlagStr | gui.QTextFormat.PageBreakFlag</code> <p>page break policy</p> required Source code in <code>prettyqt\\gui\\textblockformat.py</code> <pre><code>def set_page_break_policy(\nself, policy: gui.textformat.PageBreakFlagStr | gui.QTextFormat.PageBreakFlag\n):\n\"\"\"Set page break policy.\n    Args:\n        policy: page break policy\n    \"\"\"\nself.setPageBreakPolicy(gui.textformat.PAGE_BREAK_FLAG.get_enum_value(policy))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextBlockUserData","title":"<code>TextBlockUserData</code>","text":"<p>         Bases: <code>QtGui.QTextBlockUserData</code></p> <p>Storage for the user data associated with each line.</p> Source code in <code>prettyqt\\gui\\textblockuserdata.py</code> <pre><code>class TextBlockUserData(QtGui.QTextBlockUserData):\n\"\"\"Storage for the user data associated with each line.\"\"\"\ndef __init__(self, **kwds):\nfor key, value in kwds.items():\nsetattr(self, key, value)\nsuper().__init__()\ndef __repr__(self):\nkwargs = {i: getattr(self, i) for i in dir(self) if not i.startswith(\"__\")}\nreturn get_repr(self, **kwargs)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextCharFormatMixin","title":"<code>TextCharFormatMixin</code>","text":"<p>         Bases: <code>gui.TextFormatMixin</code></p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>class TextCharFormatMixin(gui.TextFormatMixin):\ndef __init__(\nself,\ntext_color: datatypes.ColorType | QtGui.QBrush = None,\nbold: bool = False,\nitalic: bool = False,\n):\nsuper().__init__()\nif text_color is not None:\nself.set_foreground_color(text_color)\nif bold:\nself.set_font_weight(\"bold\")\nself.setFontItalic(italic)\ndef set_foreground_color(self, color: datatypes.ColorType | QtGui.QBrush):\nif not isinstance(color, QtGui.QBrush):\ncolor = colors.get_color(color)\nself.setForeground(color)\ndef set_background_color(self, color: datatypes.ColorType | QtGui.QBrush):\nif not isinstance(color, QtGui.QBrush):\ncolor = colors.get_color(color)\nself.setBackground(color)\ndef set_font_weight(self, weight: gui.font.WeightStr | gui.Font.Weight):\n\"\"\"Set the font weight.\n        Args:\n            weight: font weight\n        \"\"\"\nself.setFontWeight(gui.font.WEIGHT.get_enum_value(weight))\ndef get_font_weight(self) -&gt; gui.font.WeightStr:\n\"\"\"Get current font weight.\n        Returns:\n            current font weight\n        \"\"\"\nreturn gui.font.WEIGHT.inverse[self.fontWeight()]\ndef set_underline_style(self, style: UnderlineStyleStr | mod.UnderlineStyle):\n\"\"\"Set the underline style.\n        Args:\n            style: underline style\n        \"\"\"\nself.setUnderlineStyle(UNDERLINE_STYLE.get_enum_value(style))\ndef get_underline_style(self) -&gt; UnderlineStyleStr:\n\"\"\"Get current underline style.\n        Returns:\n            current underline style\n        \"\"\"\nreturn UNDERLINE_STYLE.inverse[self.underlineStyle()]\ndef set_vertical_alignment(\nself, alignment: VerticalAlignmentStr | QtGui.QTextCharFormat.VerticalAlignment\n):\n\"\"\"Set the vertical alignment.\n        Args:\n            alignment: vertical alignment\n        \"\"\"\nself.setVerticalAlignment(VERTICAL_ALIGNMENT.get_enum_value(alignment))\ndef get_vertical_alignment(self) -&gt; VerticalAlignmentStr:\n\"\"\"Get current vertical alignment.\n        Returns:\n            current vertical alignment\n        \"\"\"\nreturn VERTICAL_ALIGNMENT.inverse[self.verticalAlignment()]\ndef set_font_style_hint(self, hint: gui.font.StyleHintStr | gui.Font.StyleHint):\n\"\"\"Set the font style hint.\n        Args:\n            hint: font style hint\n        \"\"\"\nself.setFontStyleHint(gui.font.STYLE_HINTS.get_enum_value(hint))\ndef get_font(self) -&gt; gui.Font:\nreturn gui.Font(self.font())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.get_font_weight","title":"<code>get_font_weight() -&gt; gui.font.WeightStr</code>","text":"<p>Get current font weight.</p> <p>Returns:</p> Type Description <code>gui.font.WeightStr</code> <p>current font weight</p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def get_font_weight(self) -&gt; gui.font.WeightStr:\n\"\"\"Get current font weight.\n    Returns:\n        current font weight\n    \"\"\"\nreturn gui.font.WEIGHT.inverse[self.fontWeight()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.get_underline_style","title":"<code>get_underline_style() -&gt; UnderlineStyleStr</code>","text":"<p>Get current underline style.</p> <p>Returns:</p> Type Description <code>UnderlineStyleStr</code> <p>current underline style</p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def get_underline_style(self) -&gt; UnderlineStyleStr:\n\"\"\"Get current underline style.\n    Returns:\n        current underline style\n    \"\"\"\nreturn UNDERLINE_STYLE.inverse[self.underlineStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.get_vertical_alignment","title":"<code>get_vertical_alignment() -&gt; VerticalAlignmentStr</code>","text":"<p>Get current vertical alignment.</p> <p>Returns:</p> Type Description <code>VerticalAlignmentStr</code> <p>current vertical alignment</p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def get_vertical_alignment(self) -&gt; VerticalAlignmentStr:\n\"\"\"Get current vertical alignment.\n    Returns:\n        current vertical alignment\n    \"\"\"\nreturn VERTICAL_ALIGNMENT.inverse[self.verticalAlignment()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_font_style_hint","title":"<code>set_font_style_hint(hint: gui.font.StyleHintStr | gui.Font.StyleHint)</code>","text":"<p>Set the font style hint.</p> <p>Parameters:</p> Name Type Description Default <code>hint</code> <code>gui.font.StyleHintStr | gui.Font.StyleHint</code> <p>font style hint</p> required Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def set_font_style_hint(self, hint: gui.font.StyleHintStr | gui.Font.StyleHint):\n\"\"\"Set the font style hint.\n    Args:\n        hint: font style hint\n    \"\"\"\nself.setFontStyleHint(gui.font.STYLE_HINTS.get_enum_value(hint))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_font_weight","title":"<code>set_font_weight(weight: gui.font.WeightStr | gui.Font.Weight)</code>","text":"<p>Set the font weight.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>gui.font.WeightStr | gui.Font.Weight</code> <p>font weight</p> required Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def set_font_weight(self, weight: gui.font.WeightStr | gui.Font.Weight):\n\"\"\"Set the font weight.\n    Args:\n        weight: font weight\n    \"\"\"\nself.setFontWeight(gui.font.WEIGHT.get_enum_value(weight))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_underline_style","title":"<code>set_underline_style(style: UnderlineStyleStr | mod.UnderlineStyle)</code>","text":"<p>Set the underline style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>UnderlineStyleStr | mod.UnderlineStyle</code> <p>underline style</p> required Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def set_underline_style(self, style: UnderlineStyleStr | mod.UnderlineStyle):\n\"\"\"Set the underline style.\n    Args:\n        style: underline style\n    \"\"\"\nself.setUnderlineStyle(UNDERLINE_STYLE.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_vertical_alignment","title":"<code>set_vertical_alignment(alignment: VerticalAlignmentStr | QtGui.QTextCharFormat.VerticalAlignment)</code>","text":"<p>Set the vertical alignment.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>VerticalAlignmentStr | QtGui.QTextCharFormat.VerticalAlignment</code> <p>vertical alignment</p> required Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def set_vertical_alignment(\nself, alignment: VerticalAlignmentStr | QtGui.QTextCharFormat.VerticalAlignment\n):\n\"\"\"Set the vertical alignment.\n    Args:\n        alignment: vertical alignment\n    \"\"\"\nself.setVerticalAlignment(VERTICAL_ALIGNMENT.get_enum_value(alignment))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextCursor","title":"<code>TextCursor</code>","text":"<p>         Bases: <code>QtGui.QTextCursor</code></p> Source code in <code>prettyqt\\gui\\textcursor.py</code> <pre><code>class TextCursor(QtGui.QTextCursor):\ndef __str__(self):\nreturn self.selectedText().replace(\"\\u2029\", \"\\n\")\ndef __contains__(self, other):\nreturn (\nself.selectionStart() &lt;= other.selectionStart()\nand self.selectionEnd() &gt;= other.selectionEnd()\n)\ndef move_position(\nself, operation: MoveOperationStr, mode: MoveModeStr = \"move\", n: int = 1\n) -&gt; bool:\nif n &lt; 0:\nraise ValueError(n)\nreturn self.movePosition(MOVE_OPERATION[operation], MOVE_MODE[mode], n)\ndef set_position(self, pos: int | tuple[int, int], mode: MoveModeStr = \"move\"):\n\"\"\"Set cursor to given position.\n        0-indexed.\n        Args:\n            pos: Cursor position\n            mode: Move mode\n        \"\"\"\nmatch pos:\ncase int():\nself.setPosition(pos, MOVE_MODE[mode])\ncase (int() as row, int() as col):\nposition = self.document().find_block_by_number(row).position()\nposition += col\nself.set_position(position, mode=mode)\ncase _:\nraise TypeError(pos)\ndef select(self, selection: SelectionTypeStr | QtGui.QTextCursor.SelectionType):\nif isinstance(selection, QtGui.QTextCursor.SelectionType):\nsel = selection\nelse:\nsel = SELECTION_TYPE[selection]\nsuper().select(sel)\ndef span(self) -&gt; tuple[int, int]:\nreturn (self.anchor(), self.position())\ndef get_cursor_position(self) -&gt; tuple[int, int]:\n\"\"\"Return the QTextCursor position.\n        The position is a tuple made up of\n        the line number (0 based) and the column number (0 based).\n        :return: tuple(line, column)\n        \"\"\"\nreturn (self.blockNumber(), self.positionInBlock())\ndef get_selection(self) -&gt; gui.TextDocumentFragment:\nreturn gui.TextDocumentFragment(self.selection())\ndef select_text(\nself,\nstart_pos: int | tuple[int, int] | MoveOperationStr,\nend_pos: int | tuple[int, int] | MoveOperationStr,\n) -&gt; str:\n\"\"\"Select text from start position to end position.\n        Positions can be either an integer index or a move operation\n        Args:\n            start_pos: Start position\n            end_pos: End position\n        \"\"\"\nmatch start_pos:\ncase int() | (int(), int()):\nself.set_position(start_pos)\ncase str():\nself.move_position(start_pos)\ncase _:\nraise TypeError(start_pos)\nmatch end_pos:\ncase int() | (int(), int()):\nself.set_position(end_pos, mode=\"keep\")\ncase str():\nself.move_position(end_pos, mode=\"keep\")\ncase _:\nraise TypeError(end_pos)\nreturn self.selectedText()\ndef replace_text(\nself,\nstart_pos: int,\nend_pos: MoveOperationStr | int,\nto_replace: str,\n):\nself.set_position(start_pos)\nif isinstance(end_pos, int):\nself.set_position(end_pos, mode=\"keep\")\nelse:\nself.move_position(end_pos, mode=\"keep\")\nself.insertText(to_replace)\nself.select_text(start_pos, start_pos + len(to_replace))\n@contextlib.contextmanager\ndef edit_block(self, join_previous: bool = False):\n\"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\"\nself.joinPreviousEditBlock() if join_previous else self.beginEditBlock()\nyield\nself.endEditBlock()\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.edit_block","title":"<code>edit_block(join_previous: bool = False)</code>","text":"<p>Context manager for edit blocks. Can be used for undo actions.</p> Source code in <code>prettyqt\\gui\\textcursor.py</code> <pre><code>@contextlib.contextmanager\ndef edit_block(self, join_previous: bool = False):\n\"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\"\nself.joinPreviousEditBlock() if join_previous else self.beginEditBlock()\nyield\nself.endEditBlock()\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.get_cursor_position","title":"<code>get_cursor_position() -&gt; tuple[int, int]</code>","text":"<p>Return the QTextCursor position.</p> <p>The position is a tuple made up of the line number (0 based) and the column number (0 based). :return: tuple(line, column)</p> Source code in <code>prettyqt\\gui\\textcursor.py</code> <pre><code>def get_cursor_position(self) -&gt; tuple[int, int]:\n\"\"\"Return the QTextCursor position.\n    The position is a tuple made up of\n    the line number (0 based) and the column number (0 based).\n    :return: tuple(line, column)\n    \"\"\"\nreturn (self.blockNumber(), self.positionInBlock())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select_text","title":"<code>select_text(start_pos: int | tuple[int, int] | MoveOperationStr, end_pos: int | tuple[int, int] | MoveOperationStr) -&gt; str</code>","text":"<p>Select text from start position to end position.</p> <p>Positions can be either an integer index or a move operation</p> <p>Parameters:</p> Name Type Description Default <code>start_pos</code> <code>int | tuple[int, int] | MoveOperationStr</code> <p>Start position</p> required <code>end_pos</code> <code>int | tuple[int, int] | MoveOperationStr</code> <p>End position</p> required Source code in <code>prettyqt\\gui\\textcursor.py</code> <pre><code>def select_text(\nself,\nstart_pos: int | tuple[int, int] | MoveOperationStr,\nend_pos: int | tuple[int, int] | MoveOperationStr,\n) -&gt; str:\n\"\"\"Select text from start position to end position.\n    Positions can be either an integer index or a move operation\n    Args:\n        start_pos: Start position\n        end_pos: End position\n    \"\"\"\nmatch start_pos:\ncase int() | (int(), int()):\nself.set_position(start_pos)\ncase str():\nself.move_position(start_pos)\ncase _:\nraise TypeError(start_pos)\nmatch end_pos:\ncase int() | (int(), int()):\nself.set_position(end_pos, mode=\"keep\")\ncase str():\nself.move_position(end_pos, mode=\"keep\")\ncase _:\nraise TypeError(end_pos)\nreturn self.selectedText()\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.set_position","title":"<code>set_position(pos: int | tuple[int, int], mode: MoveModeStr = 'move')</code>","text":"<p>Set cursor to given position.</p> <p>0-indexed.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>int | tuple[int, int]</code> <p>Cursor position</p> required <code>mode</code> <code>MoveModeStr</code> <p>Move mode</p> <code>'move'</code> Source code in <code>prettyqt\\gui\\textcursor.py</code> <pre><code>def set_position(self, pos: int | tuple[int, int], mode: MoveModeStr = \"move\"):\n\"\"\"Set cursor to given position.\n    0-indexed.\n    Args:\n        pos: Cursor position\n        mode: Move mode\n    \"\"\"\nmatch pos:\ncase int():\nself.setPosition(pos, MOVE_MODE[mode])\ncase (int() as row, int() as col):\nposition = self.document().find_block_by_number(row).position()\nposition += col\nself.set_position(position, mode=mode)\ncase _:\nraise TypeError(pos)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextFormatMixin","title":"<code>TextFormatMixin</code>","text":"Source code in <code>prettyqt\\gui\\textformat.py</code> <pre><code>class TextFormatMixin:\ndef __getitem__(self, key: int):\nreturn self.property(key)\ndef __setitem__(self, key: int, value):\nself.setProperty(key, value)\ndef __contains__(self, key: int):\nreturn self.hasProperty(key)\ndef __bool__(self):\nreturn self.isValid()\ndef __repr__(self):\nreturn get_repr(self, self.type())\ndef get_background(self) -&gt; gui.Brush:\nreturn gui.Brush(self.background())\ndef get_foreground(self) -&gt; gui.Brush:\nreturn gui.Brush(self.foreground())\ndef get_brush_property(self, property_id: int) -&gt; gui.Brush:\nreturn gui.Brush(self.brushProperty(property_id))\ndef get_color_property(self, property_id: int) -&gt; gui.Color:\nreturn gui.Color(self.colorProperty(property_id))\ndef get_pen_property(self, property_id: int) -&gt; gui.Pen:\nreturn gui.Pen(self.penProperty(property_id))\ndef set_layout_direction(\nself, direction: constants.LayoutDirectionStr | constants.LayoutDirection\n):\n\"\"\"Set layout direction.\n        Args:\n            direction: layout direction\n        \"\"\"\nself.setLayoutDirection(constants.LAYOUT_DIRECTION.get_enum_value(direction))\ndef get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n        Returns:\n            layout direction\n        \"\"\"\nreturn constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\ndef select_full_width(self, value: bool = True):\nprop = QtGui.QTextFormat.Property.FullWidthSelection\nself.setProperty(prop, value)  # type: ignore\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormatMixin.get_layout_direction","title":"<code>get_layout_direction() -&gt; constants.LayoutDirectionStr</code>","text":"<p>Get the current layout direction.</p> <p>Returns:</p> Type Description <code>constants.LayoutDirectionStr</code> <p>layout direction</p> Source code in <code>prettyqt\\gui\\textformat.py</code> <pre><code>def get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n    Returns:\n        layout direction\n    \"\"\"\nreturn constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormatMixin.set_layout_direction","title":"<code>set_layout_direction(direction: constants.LayoutDirectionStr | constants.LayoutDirection)</code>","text":"<p>Set layout direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>constants.LayoutDirectionStr | constants.LayoutDirection</code> <p>layout direction</p> required Source code in <code>prettyqt\\gui\\textformat.py</code> <pre><code>def set_layout_direction(\nself, direction: constants.LayoutDirectionStr | constants.LayoutDirection\n):\n\"\"\"Set layout direction.\n    Args:\n        direction: layout direction\n    \"\"\"\nself.setLayoutDirection(constants.LAYOUT_DIRECTION.get_enum_value(direction))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextLength","title":"<code>TextLength</code>","text":"<p>         Bases: <code>QtGui.QTextLength</code></p> Source code in <code>prettyqt\\gui\\textlength.py</code> <pre><code>class TextLength(QtGui.QTextLength):\ndef __repr__(self):\nreturn get_repr(self, self.type(), self.rawValue())\ndef get_type(self) -&gt; TypeStr:\n\"\"\"Return type of this length object.\n        Returns:\n            timer type\n        \"\"\"\nreturn TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textlength.TextLength.get_type","title":"<code>get_type() -&gt; TypeStr</code>","text":"<p>Return type of this length object.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>timer type</p> Source code in <code>prettyqt\\gui\\textlength.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return type of this length object.\n    Returns:\n        timer type\n    \"\"\"\nreturn TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextListFormat","title":"<code>TextListFormat</code>","text":"<p>         Bases: <code>gui.TextFormatMixin</code>, <code>QtGui.QTextListFormat</code></p> Source code in <code>prettyqt\\gui\\textlistformat.py</code> <pre><code>class TextListFormat(gui.TextFormatMixin, QtGui.QTextListFormat):\ndef set_style(self, style: StyleStr | QtGui.QTextListFormat.Style):\n\"\"\"Set the style.\n        Args:\n            style: style\n        \"\"\"\nself.setStyle(STYLES.get_enum_value(style))\ndef get_style(self) -&gt; StyleStr:\n\"\"\"Get current style.\n        Returns:\n            current style\n        \"\"\"\nreturn STYLES.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.get_style","title":"<code>get_style() -&gt; StyleStr</code>","text":"<p>Get current style.</p> <p>Returns:</p> Type Description <code>StyleStr</code> <p>current style</p> Source code in <code>prettyqt\\gui\\textlistformat.py</code> <pre><code>def get_style(self) -&gt; StyleStr:\n\"\"\"Get current style.\n    Returns:\n        current style\n    \"\"\"\nreturn STYLES.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.set_style","title":"<code>set_style(style: StyleStr | QtGui.QTextListFormat.Style)</code>","text":"<p>Set the style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>StyleStr | QtGui.QTextListFormat.Style</code> <p>style</p> required Source code in <code>prettyqt\\gui\\textlistformat.py</code> <pre><code>def set_style(self, style: StyleStr | QtGui.QTextListFormat.Style):\n\"\"\"Set the style.\n    Args:\n        style: style\n    \"\"\"\nself.setStyle(STYLES.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextTableCellFormat","title":"<code>TextTableCellFormat</code>","text":"<p>         Bases: <code>gui.TextCharFormatMixin</code>, <code>QtGui.QTextTableCellFormat</code></p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>class TextTableCellFormat(gui.TextCharFormatMixin, QtGui.QTextTableCellFormat):\ndef get_bottom_border_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.bottomBorderBrush())\ndef set_border_style(\nself, style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle\n):\n\"\"\"Set border style.\n        Args:\n            style: border style\n        \"\"\"\nself.setBorderStyle(gui.textframeformat.BORDER_STYLES.get_enum_value(style))\ndef set_bottom_border_style(\nself, style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle\n):\n\"\"\"Set bottom border style.\n        Args:\n            style: bottom border style\n        \"\"\"\nself.setBottomBorderStyle(gui.textframeformat.BORDER_STYLES.get_enum_value(style))\ndef get_bottom_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current bottom border style.\n        Returns:\n            bottom border style\n        \"\"\"\nreturn gui.textframeformat.BORDER_STYLES.inverse[self.bottomBorderStyle()]\ndef get_left_border_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.leftBorderBrush())\ndef set_left_border_style(\nself, style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle\n):\n\"\"\"Set left border style.\n        Args:\n            style: left border style\n        \"\"\"\nself.setLeftBorderStyle(gui.textframeformat.BORDER_STYLES.get_enum_value(style))\ndef get_left_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current left border style.\n        Returns:\n            left border style\n        \"\"\"\nreturn gui.textframeformat.BORDER_STYLES.inverse[self.leftBorderStyle()]\ndef get_right_border_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.rightBorderBrush())\ndef set_right_border_style(\nself, style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle\n):\n\"\"\"Set right border style.\n        Args:\n            style: right border style\n        \"\"\"\nself.setRightBorderStyle(gui.textframeformat.BORDER_STYLES.get_enum_value(style))\ndef get_right_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current right border style.\n        Returns:\n            right border style\n        \"\"\"\nreturn gui.textframeformat.BORDER_STYLES.inverse[self.rightBorderStyle()]\ndef get_top_border_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.topBorderBrush())\ndef set_top_border_style(\nself, style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle\n):\n\"\"\"Set top border style.\n        Args:\n            style: top border style\n        \"\"\"\nself.setTopBorderStyle(gui.textframeformat.BORDER_STYLES.get_enum_value(style))\ndef get_top_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current top border style.\n        Returns:\n            top border style\n        \"\"\"\nreturn gui.textframeformat.BORDER_STYLES.inverse[self.topBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_bottom_border_style","title":"<code>get_bottom_border_style() -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current bottom border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>bottom border style</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def get_bottom_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current bottom border style.\n    Returns:\n        bottom border style\n    \"\"\"\nreturn gui.textframeformat.BORDER_STYLES.inverse[self.bottomBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_left_border_style","title":"<code>get_left_border_style() -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current left border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>left border style</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def get_left_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current left border style.\n    Returns:\n        left border style\n    \"\"\"\nreturn gui.textframeformat.BORDER_STYLES.inverse[self.leftBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_right_border_style","title":"<code>get_right_border_style() -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current right border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>right border style</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def get_right_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current right border style.\n    Returns:\n        right border style\n    \"\"\"\nreturn gui.textframeformat.BORDER_STYLES.inverse[self.rightBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_top_border_style","title":"<code>get_top_border_style() -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current top border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>top border style</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def get_top_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current top border style.\n    Returns:\n        top border style\n    \"\"\"\nreturn gui.textframeformat.BORDER_STYLES.inverse[self.topBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_border_style","title":"<code>set_border_style(style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle)</code>","text":"<p>Set border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle</code> <p>border style</p> required Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def set_border_style(\nself, style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle\n):\n\"\"\"Set border style.\n    Args:\n        style: border style\n    \"\"\"\nself.setBorderStyle(gui.textframeformat.BORDER_STYLES.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_bottom_border_style","title":"<code>set_bottom_border_style(style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle)</code>","text":"<p>Set bottom border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle</code> <p>bottom border style</p> required Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def set_bottom_border_style(\nself, style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle\n):\n\"\"\"Set bottom border style.\n    Args:\n        style: bottom border style\n    \"\"\"\nself.setBottomBorderStyle(gui.textframeformat.BORDER_STYLES.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_left_border_style","title":"<code>set_left_border_style(style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle)</code>","text":"<p>Set left border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle</code> <p>left border style</p> required Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def set_left_border_style(\nself, style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle\n):\n\"\"\"Set left border style.\n    Args:\n        style: left border style\n    \"\"\"\nself.setLeftBorderStyle(gui.textframeformat.BORDER_STYLES.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_right_border_style","title":"<code>set_right_border_style(style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle)</code>","text":"<p>Set right border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle</code> <p>right border style</p> required Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def set_right_border_style(\nself, style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle\n):\n\"\"\"Set right border style.\n    Args:\n        style: right border style\n    \"\"\"\nself.setRightBorderStyle(gui.textframeformat.BORDER_STYLES.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_top_border_style","title":"<code>set_top_border_style(style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle)</code>","text":"<p>Set top border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle</code> <p>top border style</p> required Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def set_top_border_style(\nself, style: gui.textframeformat.BorderStyleStr | gui.QTextFrameFormat.BorderStyle\n):\n\"\"\"Set top border style.\n    Args:\n        style: top border style\n    \"\"\"\nself.setTopBorderStyle(gui.textframeformat.BORDER_STYLES.get_enum_value(style))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextTableFormat","title":"<code>TextTableFormat</code>","text":"<p>         Bases: <code>gui.textframeformat.TextFrameFormatMixin</code>, <code>QtGui.QTextTableFormat</code></p> Source code in <code>prettyqt\\gui\\texttableformat.py</code> <pre><code>class TextTableFormat(gui.textframeformat.TextFrameFormatMixin, QtGui.QTextTableFormat):\ndef __bool__(self):\nreturn self.isValid()\ndef set_alignment(self, alignment: constants.AlignmentStr | constants.AlignmentFlag):\n\"\"\"Set the alignment of the format.\n        Args:\n            alignment: alignment for the format\n        \"\"\"\nself.setAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\ndef get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n        Returns:\n            alignment\n        \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.alignment()]\ndef get_column_width_constraints(self) -&gt; list[gui.TextLength]:\nreturn [gui.TextLength(i) for i in self.columnWidthConstraints()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttableformat.TextTableFormat.get_alignment","title":"<code>get_alignment() -&gt; constants.AlignmentStr</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.AlignmentStr</code> <p>alignment</p> Source code in <code>prettyqt\\gui\\texttableformat.py</code> <pre><code>def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n    Returns:\n        alignment\n    \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.alignment()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttableformat.TextTableFormat.set_alignment","title":"<code>set_alignment(alignment: constants.AlignmentStr | constants.AlignmentFlag)</code>","text":"<p>Set the alignment of the format.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr | constants.AlignmentFlag</code> <p>alignment for the format</p> required Source code in <code>prettyqt\\gui\\texttableformat.py</code> <pre><code>def set_alignment(self, alignment: constants.AlignmentStr | constants.AlignmentFlag):\n\"\"\"Set the alignment of the format.\n    Args:\n        alignment: alignment for the format\n    \"\"\"\nself.setAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.WindowMixin","title":"<code>WindowMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>gui.SurfaceMixin</code></p> Source code in <code>prettyqt\\gui\\window.py</code> <pre><code>class WindowMixin(core.ObjectMixin, gui.SurfaceMixin):\ndef __repr__(self):\nreturn get_repr(self)\ndef add_shortcut(\nself,\nkeysequence: datatypes.KeyCombinationType,\ncallback: Callable | None = None,\ncontext: constants.ShortcutContextStr | constants.ShortcutContext = \"window\",\n) -&gt; gui.Shortcut:\nif not isinstance(keysequence, QtGui.QKeySequence):\nkeysequence = gui.KeySequence(keysequence)\ncontext = constants.SHORTCUT_CONTEXT.get_enum_value(context)\nreturn gui.Shortcut(keysequence, self, callback, context=context)\ndef set_visibility(self, visibility: VisibilityStr | QtGui.QWindow.Visibility):\n\"\"\"Set window visibility.\n        Args:\n            visibility: window visibility\n        \"\"\"\nself.setVisibility(VISIBILITY.get_enum_value(visibility))\ndef get_visibility(self) -&gt; VisibilityStr:\n\"\"\"Get the current window visibility.\n        Returns:\n            window visibility\n        \"\"\"\nreturn VISIBILITY.inverse[self.visibility()]\ndef start_system_resize(self, edge: constants.EdgeStr | constants.Edge) -&gt; bool:\n\"\"\"Start system resize.\n        Args:\n            edge: edge to resize\n        \"\"\"\nreturn self.startSystemResize(constants.EDGES.get_enum_value(edge))\ndef get_screen(self) -&gt; gui.Screen:\nreturn gui.Screen(self.screen())\ndef get_cursor(self) -&gt; gui.Cursor:\nreturn gui.Cursor(self.cursor())\ndef get_icon(self) -&gt; gui.Icon | None:\nicon = self.icon()\nreturn None if icon.isNull() else gui.Icon(icon)\ndef set_modality(\nself, modality: constants.WindowModalityStr | constants.WindowModality\n) -&gt; None:\n\"\"\"Set modality for the window.\n        Args:\n            modality: modality for the window\n        \"\"\"\nself.setModality(constants.WINDOW_MODALITY.get_enum_value(modality))\ndef get_modality(self) -&gt; constants.WindowModalityStr:\nreturn constants.WINDOW_MODALITY.inverse[self.modality()]\ndef set_file_path(self, file_path: os.PathLike):\npath = os.fspath(file_path)\nself.setFilePath(path)\ndef get_file_path(self) -&gt; pathlib.Path:\nreturn pathlib.Path(self.filePath())\ndef get_type(self) -&gt; constants.WindowTypeStr:\nreturn constants.WINDOW_TYPE.inverse[self.type()]\ndef get_window_state(self) -&gt; constants.WindowStateStr:\nreturn constants.WINDOW_STATES.inverse[self.windowState()]\ndef get_window_states(self) -&gt; list[constants.WindowStateStr]:\nreturn constants.WINDOW_STATES.get_list(self.windowStates())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.window.WindowMixin.get_visibility","title":"<code>get_visibility() -&gt; VisibilityStr</code>","text":"<p>Get the current window visibility.</p> <p>Returns:</p> Type Description <code>VisibilityStr</code> <p>window visibility</p> Source code in <code>prettyqt\\gui\\window.py</code> <pre><code>def get_visibility(self) -&gt; VisibilityStr:\n\"\"\"Get the current window visibility.\n    Returns:\n        window visibility\n    \"\"\"\nreturn VISIBILITY.inverse[self.visibility()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.window.WindowMixin.set_modality","title":"<code>set_modality(modality: constants.WindowModalityStr | constants.WindowModality) -&gt; None</code>","text":"<p>Set modality for the window.</p> <p>Parameters:</p> Name Type Description Default <code>modality</code> <code>constants.WindowModalityStr | constants.WindowModality</code> <p>modality for the window</p> required Source code in <code>prettyqt\\gui\\window.py</code> <pre><code>def set_modality(\nself, modality: constants.WindowModalityStr | constants.WindowModality\n) -&gt; None:\n\"\"\"Set modality for the window.\n    Args:\n        modality: modality for the window\n    \"\"\"\nself.setModality(constants.WINDOW_MODALITY.get_enum_value(modality))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.window.WindowMixin.set_visibility","title":"<code>set_visibility(visibility: VisibilityStr | QtGui.QWindow.Visibility)</code>","text":"<p>Set window visibility.</p> <p>Parameters:</p> Name Type Description Default <code>visibility</code> <code>VisibilityStr | QtGui.QWindow.Visibility</code> <p>window visibility</p> required Source code in <code>prettyqt\\gui\\window.py</code> <pre><code>def set_visibility(self, visibility: VisibilityStr | QtGui.QWindow.Visibility):\n\"\"\"Set window visibility.\n    Args:\n        visibility: window visibility\n    \"\"\"\nself.setVisibility(VISIBILITY.get_enum_value(visibility))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.window.WindowMixin.start_system_resize","title":"<code>start_system_resize(edge: constants.EdgeStr | constants.Edge) -&gt; bool</code>","text":"<p>Start system resize.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>constants.EdgeStr | constants.Edge</code> <p>edge to resize</p> required Source code in <code>prettyqt\\gui\\window.py</code> <pre><code>def start_system_resize(self, edge: constants.EdgeStr | constants.Edge) -&gt; bool:\n\"\"\"Start system resize.\n    Args:\n        edge: edge to resize\n    \"\"\"\nreturn self.startSystemResize(constants.EDGES.get_enum_value(edge))\n</code></pre>"},{"location":"api/location.html","title":"location module","text":"<p>Location module.</p>"},{"location":"api/location.html#prettyqt.location.GeoManeuver","title":"<code>GeoManeuver</code>","text":"<p>         Bases: <code>QtLocation.QGeoManeuver</code></p> Source code in <code>prettyqt\\location\\geomaneuver.py</code> <pre><code>class GeoManeuver(QtLocation.QGeoManeuver):\ndef __bool__(self):\nreturn self.isValid()\ndef __str__(self):\nreturn self.instructionText()\ndef __setitem__(self, index: str, val):\nattrs = self.extendedAttributes()\nattrs[index] = val\nself.setExtendedAttributes(attrs)\ndef __getitem__(self, index: str):\nattr = self.extendedAttributes()\nif index not in attr:\nraise KeyError(f\"Key {index!r} does not exist.\")\nreturn attr[index]\ndef get_position(self) -&gt; positioning.GeoCoordinate:\nreturn positioning.GeoCoordinate(self.position())\ndef get_waypoint(self) -&gt; positioning.GeoCoordinate | None:\nwp = self.waypoint()\nreturn positioning.GeoCoordinate(wp) if wp.isValid() else None\ndef set_direction(\nself,\ndirection: InstructionDirectionStr | QtLocation.QGeoManeuver.InstructionDirection,\n):\n\"\"\"Set the direction.\n        Args:\n            direction: Direction\n        \"\"\"\nself.setDirection(INSTRUCTION_DIRECTION.get_enum_value(direction))\ndef get_direction(self) -&gt; InstructionDirectionStr:\n\"\"\"Return current direction.\n        Returns:\n            Direction\n        \"\"\"\nreturn INSTRUCTION_DIRECTION.inverse[self.direction()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.geomaneuver.GeoManeuver.get_direction","title":"<code>get_direction() -&gt; InstructionDirectionStr</code>","text":"<p>Return current direction.</p> <p>Returns:</p> Type Description <code>InstructionDirectionStr</code> <p>Direction</p> Source code in <code>prettyqt\\location\\geomaneuver.py</code> <pre><code>def get_direction(self) -&gt; InstructionDirectionStr:\n\"\"\"Return current direction.\n    Returns:\n        Direction\n    \"\"\"\nreturn INSTRUCTION_DIRECTION.inverse[self.direction()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.geomaneuver.GeoManeuver.set_direction","title":"<code>set_direction(direction: InstructionDirectionStr | QtLocation.QGeoManeuver.InstructionDirection)</code>","text":"<p>Set the direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>InstructionDirectionStr | QtLocation.QGeoManeuver.InstructionDirection</code> <p>Direction</p> required Source code in <code>prettyqt\\location\\geomaneuver.py</code> <pre><code>def set_direction(\nself,\ndirection: InstructionDirectionStr | QtLocation.QGeoManeuver.InstructionDirection,\n):\n\"\"\"Set the direction.\n    Args:\n        direction: Direction\n    \"\"\"\nself.setDirection(INSTRUCTION_DIRECTION.get_enum_value(direction))\n</code></pre>"},{"location":"api/location.html#prettyqt.location.GeoRouteRequest","title":"<code>GeoRouteRequest</code>","text":"<p>         Bases: <code>QtLocation.QGeoRouteRequest</code></p> Source code in <code>prettyqt\\location\\georouterequest.py</code> <pre><code>class GeoRouteRequest(QtLocation.QGeoRouteRequest):\ndef get_waypoints(self) -&gt; list[positioning.GeoCoordinate]:\nreturn [positioning.GeoCoordinate(wp) for wp in self.waypoints()]\ndef get_exclude_areas(self) -&gt; list[positioning.GeoRectangle]:\nreturn [positioning.GeoRectangle(wp) for wp in self.excludeAreas()]\ndef get_departure_time(self) -&gt; core.DateTime:\nreturn core.DateTime(self.departureTime())\ndef set_feature_weight(\nself,\nfeature: FeatureTypeStr | QtLocation.QGeoRouteRequest.FeatureType,\nweight: FeatureWeightStr | QtLocation.QGeoRouteRequest.FeatureWeight,\n):\n\"\"\"Set the feature weight.\n        Args:\n            feature: Feature type\n            weight: Feature weight\n        \"\"\"\nself.setFeatureWeight(\nFEATURE_TYPES.get_enum_value(feature), FEATURE_WEIGHTS.get_enum_value(weight)\n)\ndef get_feature_weight(\nself, feature: FeatureTypeStr | QtLocation.QGeoRouteRequest.FeatureType\n) -&gt; FeatureWeightStr:\n\"\"\"Return current feature weight.\n        Returns:\n            Feature weight\n        \"\"\"\nreturn FEATURE_WEIGHTS.inverse[\nself.featureWeight(FEATURE_TYPES.get_enum_value(feature))\n]\ndef set_route_optimization(\nself,\noptimization: RouteOptimizationStr\n| QtLocation.QGeoRouteRequest.RouteOptimization,\n):\n\"\"\"Set the route optimization.\n        Args:\n            optimization: Route optimization\n        \"\"\"\nself.setRouteOptimization(ROUTE_OPTIMIZATION.get_enum_value(optimization))\ndef get_route_optimization(self) -&gt; RouteOptimizationStr:\n\"\"\"Return current route optimization.\n        Returns:\n            Route optimization\n        \"\"\"\nreturn ROUTE_OPTIMIZATION.inverse[self.routeOptimization()]\ndef get_travel_modes(self) -&gt; list[TravelModeStr]:\nreturn TRAVEL_MODE.get_list(self.travelModes())\ndef set_travel_modes(self, *mode: TravelModeStr):\nflags = TRAVEL_MODE.merge_flags(mode)\nself.setTravelModes(flags)\ndef get_feature_types(self) -&gt; list[FeatureTypeStr]:\nreturn [k for k, v in FEATURE_TYPES.items() for t in self.featureTypes() if v &amp; t]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.get_feature_weight","title":"<code>get_feature_weight(feature: FeatureTypeStr | QtLocation.QGeoRouteRequest.FeatureType) -&gt; FeatureWeightStr</code>","text":"<p>Return current feature weight.</p> <p>Returns:</p> Type Description <code>FeatureWeightStr</code> <p>Feature weight</p> Source code in <code>prettyqt\\location\\georouterequest.py</code> <pre><code>def get_feature_weight(\nself, feature: FeatureTypeStr | QtLocation.QGeoRouteRequest.FeatureType\n) -&gt; FeatureWeightStr:\n\"\"\"Return current feature weight.\n    Returns:\n        Feature weight\n    \"\"\"\nreturn FEATURE_WEIGHTS.inverse[\nself.featureWeight(FEATURE_TYPES.get_enum_value(feature))\n]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.get_route_optimization","title":"<code>get_route_optimization() -&gt; RouteOptimizationStr</code>","text":"<p>Return current route optimization.</p> <p>Returns:</p> Type Description <code>RouteOptimizationStr</code> <p>Route optimization</p> Source code in <code>prettyqt\\location\\georouterequest.py</code> <pre><code>def get_route_optimization(self) -&gt; RouteOptimizationStr:\n\"\"\"Return current route optimization.\n    Returns:\n        Route optimization\n    \"\"\"\nreturn ROUTE_OPTIMIZATION.inverse[self.routeOptimization()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.set_feature_weight","title":"<code>set_feature_weight(feature: FeatureTypeStr | QtLocation.QGeoRouteRequest.FeatureType, weight: FeatureWeightStr | QtLocation.QGeoRouteRequest.FeatureWeight)</code>","text":"<p>Set the feature weight.</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>FeatureTypeStr | QtLocation.QGeoRouteRequest.FeatureType</code> <p>Feature type</p> required <code>weight</code> <code>FeatureWeightStr | QtLocation.QGeoRouteRequest.FeatureWeight</code> <p>Feature weight</p> required Source code in <code>prettyqt\\location\\georouterequest.py</code> <pre><code>def set_feature_weight(\nself,\nfeature: FeatureTypeStr | QtLocation.QGeoRouteRequest.FeatureType,\nweight: FeatureWeightStr | QtLocation.QGeoRouteRequest.FeatureWeight,\n):\n\"\"\"Set the feature weight.\n    Args:\n        feature: Feature type\n        weight: Feature weight\n    \"\"\"\nself.setFeatureWeight(\nFEATURE_TYPES.get_enum_value(feature), FEATURE_WEIGHTS.get_enum_value(weight)\n)\n</code></pre>"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.set_route_optimization","title":"<code>set_route_optimization(optimization: RouteOptimizationStr | QtLocation.QGeoRouteRequest.RouteOptimization)</code>","text":"<p>Set the route optimization.</p> <p>Parameters:</p> Name Type Description Default <code>optimization</code> <code>RouteOptimizationStr | QtLocation.QGeoRouteRequest.RouteOptimization</code> <p>Route optimization</p> required Source code in <code>prettyqt\\location\\georouterequest.py</code> <pre><code>def set_route_optimization(\nself,\noptimization: RouteOptimizationStr\n| QtLocation.QGeoRouteRequest.RouteOptimization,\n):\n\"\"\"Set the route optimization.\n    Args:\n        optimization: Route optimization\n    \"\"\"\nself.setRouteOptimization(ROUTE_OPTIMIZATION.get_enum_value(optimization))\n</code></pre>"},{"location":"api/location.html#prettyqt.location.Place","title":"<code>Place</code>","text":"<p>         Bases: <code>QtLocation.QPlace</code></p> Source code in <code>prettyqt\\location\\place.py</code> <pre><code>class Place(QtLocation.QPlace):\ndef __bool__(self):\nreturn not self.isEmpty()\ndef __setitem__(self, index: str, val: QtLocation.QPlaceAttribute | None):\nif val is None:\nval = location.PlaceAttribute()\nself.setExtendedAttribute(index, val)\ndef __getitem__(self, index: str) -&gt; location.PlaceAttribute:\nattr = self.extendedAttribute(index)\nreturn location.PlaceAttribute(attr)\ndef get_categories(self) -&gt; list[location.PlaceCategory]:\nreturn [location.PlaceCategory(i) for i in self.categories()]\ndef get_contact_details(self, contact_type: str) -&gt; list[location.PlaceContactDetail]:\nreturn [location.PlaceContactDetail(i) for i in self.contactDetails(contact_type)]\ndef set_content(self, typ: str, value: dict[int, QtLocation.QPlaceContent]):\nself.setContent(location.placecontent.TYPE.get_enum_value(typ), value)\ndef get_content(self, typ: str) -&gt; dict[int, QtLocation.QPlaceContent]:\nreturn self.content(location.placecontent.TYPE.get_enum_value(typ))\ndef get_icon(self) -&gt; location.PlaceIcon | None:\nicon = self.icon()\nreturn None if icon.isEmpty() else location.PlaceIcon(icon)\ndef get_location(self) -&gt; positioning.GeoLocation:\nreturn positioning.GeoLocation(self.location())\ndef get_primary_website(self) -&gt; core.Url:\nreturn core.Url(self.primaryWebsite())\ndef get_ratings(self) -&gt; location.PlaceRatings:\nreturn location.PlaceRatings(self.ratings())\ndef get_supplier(self) -&gt; location.PlaceSupplier:\nreturn location.PlaceSupplier(self.supplier())\ndef get_visibility(self) -&gt; location.VisibilityStr:\n\"\"\"Return visibility.\n        Returns:\n            Visibility\n        \"\"\"\nreturn location.VISIBILITY.inverse[self.visibility()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.place.Place.get_visibility","title":"<code>get_visibility() -&gt; location.VisibilityStr</code>","text":"<p>Return visibility.</p> <p>Returns:</p> Type Description <code>location.VisibilityStr</code> <p>Visibility</p> Source code in <code>prettyqt\\location\\place.py</code> <pre><code>def get_visibility(self) -&gt; location.VisibilityStr:\n\"\"\"Return visibility.\n    Returns:\n        Visibility\n    \"\"\"\nreturn location.VISIBILITY.inverse[self.visibility()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.PlaceCategory","title":"<code>PlaceCategory</code>","text":"<p>         Bases: <code>QtLocation.QPlaceCategory</code></p> Source code in <code>prettyqt\\location\\placecategory.py</code> <pre><code>class PlaceCategory(QtLocation.QPlaceCategory):\ndef __str__(self):\nreturn self.name()\ndef __bool__(self):\nreturn not self.isEmpty()\ndef get_icon(self) -&gt; location.PlaceIcon | None:\nicon = self.icon()\nreturn None if icon.isEmpty() else location.PlaceIcon(icon)\ndef get_visibility(self) -&gt; location.VisibilityStr:\n\"\"\"Return the visibility of the place.\n        Returns:\n            Visibility\n        \"\"\"\nreturn location.VISIBILITY.inverse[self.visibility()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.placecategory.PlaceCategory.get_visibility","title":"<code>get_visibility() -&gt; location.VisibilityStr</code>","text":"<p>Return the visibility of the place.</p> <p>Returns:</p> Type Description <code>location.VisibilityStr</code> <p>Visibility</p> Source code in <code>prettyqt\\location\\placecategory.py</code> <pre><code>def get_visibility(self) -&gt; location.VisibilityStr:\n\"\"\"Return the visibility of the place.\n    Returns:\n        Visibility\n    \"\"\"\nreturn location.VISIBILITY.inverse[self.visibility()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.PlaceContentMixin","title":"<code>PlaceContentMixin</code>","text":"Source code in <code>prettyqt\\location\\placecontent.py</code> <pre><code>class PlaceContentMixin:\ndef get_type(self) -&gt; TypeStr:\n\"\"\"Return the visibility of the place.\n        Returns:\n            Place type\n        \"\"\"\nreturn TYPE.inverse[self.type()]\ndef get_user(self) -&gt; location.PlaceUser:\nreturn location.PlaceUser(self.user())\ndef get_supplier(self) -&gt; location.PlaceSupplier:\nreturn location.PlaceSupplier(self.supplier())\n</code></pre>"},{"location":"api/location.html#prettyqt.location.placecontent.PlaceContentMixin.get_type","title":"<code>get_type() -&gt; TypeStr</code>","text":"<p>Return the visibility of the place.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>Place type</p> Source code in <code>prettyqt\\location\\placecontent.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return the visibility of the place.\n    Returns:\n        Place type\n    \"\"\"\nreturn TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.PlaceContentRequest","title":"<code>PlaceContentRequest</code>","text":"<p>         Bases: <code>QtLocation.QPlaceContentRequest</code></p> Source code in <code>prettyqt\\location\\placecontentrequest.py</code> <pre><code>class PlaceContentRequest(QtLocation.QPlaceContentRequest):\ndef set_content_type(\nself, typ: location.placecontent.TypeStr | location.PlaceContent.Type\n):\n\"\"\"Set the content type.\n        Args:\n            typ: Relevance type\n        \"\"\"\nself.setContentType(location.placecontent.TYPE.get_enum_value(typ))\ndef get_content_type(self) -&gt; location.placecontent.TypeStr:\n\"\"\"Return current content type.\n        Returns:\n            Relevance type\n        \"\"\"\nreturn location.placecontent.TYPE.inverse[self.contentType()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.placecontentrequest.PlaceContentRequest.get_content_type","title":"<code>get_content_type() -&gt; location.placecontent.TypeStr</code>","text":"<p>Return current content type.</p> <p>Returns:</p> Type Description <code>location.placecontent.TypeStr</code> <p>Relevance type</p> Source code in <code>prettyqt\\location\\placecontentrequest.py</code> <pre><code>def get_content_type(self) -&gt; location.placecontent.TypeStr:\n\"\"\"Return current content type.\n    Returns:\n        Relevance type\n    \"\"\"\nreturn location.placecontent.TYPE.inverse[self.contentType()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.placecontentrequest.PlaceContentRequest.set_content_type","title":"<code>set_content_type(typ: location.placecontent.TypeStr | location.PlaceContent.Type)</code>","text":"<p>Set the content type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>location.placecontent.TypeStr | location.PlaceContent.Type</code> <p>Relevance type</p> required Source code in <code>prettyqt\\location\\placecontentrequest.py</code> <pre><code>def set_content_type(\nself, typ: location.placecontent.TypeStr | location.PlaceContent.Type\n):\n\"\"\"Set the content type.\n    Args:\n        typ: Relevance type\n    \"\"\"\nself.setContentType(location.placecontent.TYPE.get_enum_value(typ))\n</code></pre>"},{"location":"api/location.html#prettyqt.location.PlaceIdReply","title":"<code>PlaceIdReply</code>","text":"<p>         Bases: <code>location.PlaceReplyMixin</code>, <code>QtLocation.QPlaceIdReply</code></p> Source code in <code>prettyqt\\location\\placeidreply.py</code> <pre><code>class PlaceIdReply(location.PlaceReplyMixin, QtLocation.QPlaceIdReply):\ndef __repr__(self):\nreturn get_repr(self, self.operationType())\n@classmethod\ndef clone_from(cls, obj: QtLocation.QPlaceIdReply) -&gt; Self:\nreply = cls(obj.operationType(), obj.parent())\nreply.setId(obj.id())\nreturn reply\ndef get_operation_type(self) -&gt; OperationTypeStr:\n\"\"\"Get current operation_type.\n        Returns:\n            current operation_type\n        \"\"\"\nreturn OPERATION_TYPES.inverse[self.operationType()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.placeidreply.PlaceIdReply.get_operation_type","title":"<code>get_operation_type() -&gt; OperationTypeStr</code>","text":"<p>Get current operation_type.</p> <p>Returns:</p> Type Description <code>OperationTypeStr</code> <p>current operation_type</p> Source code in <code>prettyqt\\location\\placeidreply.py</code> <pre><code>def get_operation_type(self) -&gt; OperationTypeStr:\n\"\"\"Get current operation_type.\n    Returns:\n        current operation_type\n    \"\"\"\nreturn OPERATION_TYPES.inverse[self.operationType()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.PlaceReplyMixin","title":"<code>PlaceReplyMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\location\\placereply.py</code> <pre><code>class PlaceReplyMixin(core.ObjectMixin):\ndef get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n        Returns:\n            Error type\n        \"\"\"\nreturn ERROR.inverse[self.error()]\ndef get_type(self) -&gt; TypeStr:\n\"\"\"Return type.\n        Returns:\n            Type\n        \"\"\"\nreturn TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.placereply.PlaceReplyMixin.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>Error type</p> Source code in <code>prettyqt\\location\\placereply.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n    Returns:\n        Error type\n    \"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.placereply.PlaceReplyMixin.get_type","title":"<code>get_type() -&gt; TypeStr</code>","text":"<p>Return type.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>Type</p> Source code in <code>prettyqt\\location\\placereply.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return type.\n    Returns:\n        Type\n    \"\"\"\nreturn TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.PlaceSearchRequest","title":"<code>PlaceSearchRequest</code>","text":"<p>         Bases: <code>QtLocation.QPlaceSearchRequest</code></p> Source code in <code>prettyqt\\location\\placesearchrequest.py</code> <pre><code>class PlaceSearchRequest(QtLocation.QPlaceSearchRequest):\ndef get_visibility_scope(self) -&gt; location.VisibilityStr:\n\"\"\"Return the scope of the visibility.\n        Returns:\n            Visibility scope\n        \"\"\"\nreturn location.VISIBILITY.inverse[self.visibilityScope()]\ndef get_categories(self) -&gt; list[location.PlaceCategory]:\nreturn [location.PlaceCategory(i) for i in self.categories()]\ndef get_search_area(self) -&gt; positioning.GeoShape:\narea = self.searchArea()\nmatch area:\ncase QtPositioning.QGeoCircle():\nreturn positioning.GeoCircle(area)\ncase QtPositioning.QGeoPath():\nreturn positioning.GeoPath(area)\ncase QtPositioning.QGeoPolygon():\nreturn positioning.GeoPolygon(area)\ncase QtPositioning.QGeoRectangle():\nreturn positioning.GeoRectangle(area)\ncase _:\nreturn positioning.GeoShape(area)\ndef set_relevance_hint(\nself, hint: RelevanceHintStr | QtLocation.QPlaceSearchRequest.RelevanceHint\n):\n\"\"\"Set the relevance hint.\n        Args:\n            hint: Relevance hint\n        \"\"\"\nself.setRelevanceHint(RELEVANCE_HINT.get_enum_value(hint))\ndef get_relevance_hint(self) -&gt; RelevanceHintStr:\n\"\"\"Return current relevance hint.\n        Returns:\n            Relevance hint\n        \"\"\"\nreturn RELEVANCE_HINT.inverse[self.relevanceHint()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.placesearchrequest.PlaceSearchRequest.get_relevance_hint","title":"<code>get_relevance_hint() -&gt; RelevanceHintStr</code>","text":"<p>Return current relevance hint.</p> <p>Returns:</p> Type Description <code>RelevanceHintStr</code> <p>Relevance hint</p> Source code in <code>prettyqt\\location\\placesearchrequest.py</code> <pre><code>def get_relevance_hint(self) -&gt; RelevanceHintStr:\n\"\"\"Return current relevance hint.\n    Returns:\n        Relevance hint\n    \"\"\"\nreturn RELEVANCE_HINT.inverse[self.relevanceHint()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.placesearchrequest.PlaceSearchRequest.get_visibility_scope","title":"<code>get_visibility_scope() -&gt; location.VisibilityStr</code>","text":"<p>Return the scope of the visibility.</p> <p>Returns:</p> Type Description <code>location.VisibilityStr</code> <p>Visibility scope</p> Source code in <code>prettyqt\\location\\placesearchrequest.py</code> <pre><code>def get_visibility_scope(self) -&gt; location.VisibilityStr:\n\"\"\"Return the scope of the visibility.\n    Returns:\n        Visibility scope\n    \"\"\"\nreturn location.VISIBILITY.inverse[self.visibilityScope()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.placesearchrequest.PlaceSearchRequest.set_relevance_hint","title":"<code>set_relevance_hint(hint: RelevanceHintStr | QtLocation.QPlaceSearchRequest.RelevanceHint)</code>","text":"<p>Set the relevance hint.</p> <p>Parameters:</p> Name Type Description Default <code>hint</code> <code>RelevanceHintStr | QtLocation.QPlaceSearchRequest.RelevanceHint</code> <p>Relevance hint</p> required Source code in <code>prettyqt\\location\\placesearchrequest.py</code> <pre><code>def set_relevance_hint(\nself, hint: RelevanceHintStr | QtLocation.QPlaceSearchRequest.RelevanceHint\n):\n\"\"\"Set the relevance hint.\n    Args:\n        hint: Relevance hint\n    \"\"\"\nself.setRelevanceHint(RELEVANCE_HINT.get_enum_value(hint))\n</code></pre>"},{"location":"api/location.html#prettyqt.location.PlaceSearchResultMixin","title":"<code>PlaceSearchResultMixin</code>","text":"Source code in <code>prettyqt\\location\\placesearchresult.py</code> <pre><code>class PlaceSearchResultMixin:\ndef get_icon(self) -&gt; location.PlaceIcon | None:\nicon = self.icon()\nreturn None if icon.isEmpty() else location.PlaceIcon(icon)\ndef get_type(self) -&gt; TypeStr:\n\"\"\"Return result type.\n        Returns:\n            Result type\n        \"\"\"\nreturn TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/location.html#prettyqt.location.placesearchresult.PlaceSearchResultMixin.get_type","title":"<code>get_type() -&gt; TypeStr</code>","text":"<p>Return result type.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>Result type</p> Source code in <code>prettyqt\\location\\placesearchresult.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return result type.\n    Returns:\n        Result type\n    \"\"\"\nreturn TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/multimedia.html","title":"multimedia module","text":"<p>multimedia module.</p> <p>contains QtMultimedia-based classes</p>"},{"location":"api/multimedia.html#prettyqt.multimedia.Camera","title":"<code>Camera</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtMultimedia.QCamera</code></p> Source code in <code>prettyqt\\multimedia\\camera.py</code> <pre><code>class Camera(core.ObjectMixin, QtMultimedia.QCamera):\ndef set_exposure_mode(\nself, mode: ExposureModeStr | QtMultimedia.QCamera.ExposureMode\n):\n\"\"\"Set the exposure mode.\n        Args:\n            mode: exposure mode\n        \"\"\"\nself.setExposureMode(EXPOSURE_MODE.get_enum_value(mode))\ndef get_exposure_mode(self) -&gt; ExposureModeStr:\n\"\"\"Return current exposure mode.\n        Returns:\n            exposure mode\n        \"\"\"\nreturn EXPOSURE_MODE.inverse[self.exposureMode()]\ndef set_torch_mode(self, mode: TorchModeStr | QtMultimedia.QCamera.TorchMode):\n\"\"\"Set the torch mode.\n        Args:\n            mode: torch mode\n        \"\"\"\nself.setTorchMode(TORCH_MODE.get_enum_value(mode))\ndef get_torch_mode(self) -&gt; TorchModeStr:\n\"\"\"Return current torch mode.\n        Returns:\n            torch mode\n        \"\"\"\nreturn TORCH_MODE.inverse[self.torchMode()]\ndef set_flash_mode(self, mode: FlashModeStr | QtMultimedia.QCamera.FlashMode):\n\"\"\"Set the flash mode.\n        Args:\n            mode: flash mode\n        \"\"\"\nself.setFlashMode(FLASH_MODE.get_enum_value(mode))\ndef get_flash_mode(self) -&gt; FlashModeStr:\n\"\"\"Return current flash mode.\n        Returns:\n            flash mode\n        \"\"\"\nreturn FLASH_MODE.inverse[self.flashMode()]\ndef set_white_balance_mode(\nself, mode: WhiteBalanceModeStr | QtMultimedia.QCamera.WhiteBalanceMode\n):\n\"\"\"Set the white balance mode.\n        Args:\n            mode: white balance mode\n        \"\"\"\nself.setWhiteBalanceMode(WHITE_BALANCE.get_enum_value(mode))\ndef get_white_balance_mode(self) -&gt; WhiteBalanceModeStr:\n\"\"\"Return current white balance mode.\n        Returns:\n            white balance mode\n        \"\"\"\nreturn WHITE_BALANCE.inverse[self.whiteBalanceMode()]\ndef get_supported_features(self) -&gt; list[FeatureStr]:\nreturn FEATURE.get_list(self.supportedFeatures())\ndef get_error(self) -&gt; ErrorStr:\n\"\"\"Return current error state.\n        Returns:\n            error state\n        \"\"\"\nreturn ERROR.inverse[self.error()]\ndef get_camera_format(self) -&gt; multimedia.CameraFormat:\nreturn multimedia.CameraFormat(self.cameraFormat())\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return current error state.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>error state</p> Source code in <code>prettyqt\\multimedia\\camera.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return current error state.\n    Returns:\n        error state\n    \"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_exposure_mode","title":"<code>get_exposure_mode() -&gt; ExposureModeStr</code>","text":"<p>Return current exposure mode.</p> <p>Returns:</p> Type Description <code>ExposureModeStr</code> <p>exposure mode</p> Source code in <code>prettyqt\\multimedia\\camera.py</code> <pre><code>def get_exposure_mode(self) -&gt; ExposureModeStr:\n\"\"\"Return current exposure mode.\n    Returns:\n        exposure mode\n    \"\"\"\nreturn EXPOSURE_MODE.inverse[self.exposureMode()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_flash_mode","title":"<code>get_flash_mode() -&gt; FlashModeStr</code>","text":"<p>Return current flash mode.</p> <p>Returns:</p> Type Description <code>FlashModeStr</code> <p>flash mode</p> Source code in <code>prettyqt\\multimedia\\camera.py</code> <pre><code>def get_flash_mode(self) -&gt; FlashModeStr:\n\"\"\"Return current flash mode.\n    Returns:\n        flash mode\n    \"\"\"\nreturn FLASH_MODE.inverse[self.flashMode()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_torch_mode","title":"<code>get_torch_mode() -&gt; TorchModeStr</code>","text":"<p>Return current torch mode.</p> <p>Returns:</p> Type Description <code>TorchModeStr</code> <p>torch mode</p> Source code in <code>prettyqt\\multimedia\\camera.py</code> <pre><code>def get_torch_mode(self) -&gt; TorchModeStr:\n\"\"\"Return current torch mode.\n    Returns:\n        torch mode\n    \"\"\"\nreturn TORCH_MODE.inverse[self.torchMode()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_white_balance_mode","title":"<code>get_white_balance_mode() -&gt; WhiteBalanceModeStr</code>","text":"<p>Return current white balance mode.</p> <p>Returns:</p> Type Description <code>WhiteBalanceModeStr</code> <p>white balance mode</p> Source code in <code>prettyqt\\multimedia\\camera.py</code> <pre><code>def get_white_balance_mode(self) -&gt; WhiteBalanceModeStr:\n\"\"\"Return current white balance mode.\n    Returns:\n        white balance mode\n    \"\"\"\nreturn WHITE_BALANCE.inverse[self.whiteBalanceMode()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.set_exposure_mode","title":"<code>set_exposure_mode(mode: ExposureModeStr | QtMultimedia.QCamera.ExposureMode)</code>","text":"<p>Set the exposure mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ExposureModeStr | QtMultimedia.QCamera.ExposureMode</code> <p>exposure mode</p> required Source code in <code>prettyqt\\multimedia\\camera.py</code> <pre><code>def set_exposure_mode(\nself, mode: ExposureModeStr | QtMultimedia.QCamera.ExposureMode\n):\n\"\"\"Set the exposure mode.\n    Args:\n        mode: exposure mode\n    \"\"\"\nself.setExposureMode(EXPOSURE_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.set_flash_mode","title":"<code>set_flash_mode(mode: FlashModeStr | QtMultimedia.QCamera.FlashMode)</code>","text":"<p>Set the flash mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>FlashModeStr | QtMultimedia.QCamera.FlashMode</code> <p>flash mode</p> required Source code in <code>prettyqt\\multimedia\\camera.py</code> <pre><code>def set_flash_mode(self, mode: FlashModeStr | QtMultimedia.QCamera.FlashMode):\n\"\"\"Set the flash mode.\n    Args:\n        mode: flash mode\n    \"\"\"\nself.setFlashMode(FLASH_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.set_torch_mode","title":"<code>set_torch_mode(mode: TorchModeStr | QtMultimedia.QCamera.TorchMode)</code>","text":"<p>Set the torch mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>TorchModeStr | QtMultimedia.QCamera.TorchMode</code> <p>torch mode</p> required Source code in <code>prettyqt\\multimedia\\camera.py</code> <pre><code>def set_torch_mode(self, mode: TorchModeStr | QtMultimedia.QCamera.TorchMode):\n\"\"\"Set the torch mode.\n    Args:\n        mode: torch mode\n    \"\"\"\nself.setTorchMode(TORCH_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.set_white_balance_mode","title":"<code>set_white_balance_mode(mode: WhiteBalanceModeStr | QtMultimedia.QCamera.WhiteBalanceMode)</code>","text":"<p>Set the white balance mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>WhiteBalanceModeStr | QtMultimedia.QCamera.WhiteBalanceMode</code> <p>white balance mode</p> required Source code in <code>prettyqt\\multimedia\\camera.py</code> <pre><code>def set_white_balance_mode(\nself, mode: WhiteBalanceModeStr | QtMultimedia.QCamera.WhiteBalanceMode\n):\n\"\"\"Set the white balance mode.\n    Args:\n        mode: white balance mode\n    \"\"\"\nself.setWhiteBalanceMode(WHITE_BALANCE.get_enum_value(mode))\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.MediaPlayer","title":"<code>MediaPlayer</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtMultimedia.QMediaPlayer</code></p> Source code in <code>prettyqt\\multimedia\\mediaplayer.py</code> <pre><code>class MediaPlayer(core.ObjectMixin, QtMultimedia.QMediaPlayer):\ndef set_source_device(\nself, device: QtCore.QIODevice, url: datatypes.UrlType | None = None\n):\nurl = datatypes.to_local_url(url)\nself.setSourceDevice(device, url)\ndef set_source(self, url: datatypes.UrlType):\nurl = datatypes.to_local_url(url)\nself.setSource(url)\ndef get_source(self) -&gt; core.Url | None:\nurl = self.source()\nreturn core.Url(url) if url.isValid() else None\ndef get_playback_state(self) -&gt; PlaybackStateStr:\n\"\"\"Return current playback state.\n        Returns:\n            playback state\n        \"\"\"\nreturn PLAYBACK_STATE.inverse[self.playbackState()]\ndef get_media_status(self) -&gt; MediaStatusStr:\n\"\"\"Return current media status.\n        Returns:\n            media status\n        \"\"\"\nreturn MEDIA_STATUS.inverse[self.mediaStatus()]\ndef get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n        Returns:\n            error type\n        \"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\multimedia\\mediaplayer.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n    Returns:\n        error type\n    \"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_media_status","title":"<code>get_media_status() -&gt; MediaStatusStr</code>","text":"<p>Return current media status.</p> <p>Returns:</p> Type Description <code>MediaStatusStr</code> <p>media status</p> Source code in <code>prettyqt\\multimedia\\mediaplayer.py</code> <pre><code>def get_media_status(self) -&gt; MediaStatusStr:\n\"\"\"Return current media status.\n    Returns:\n        media status\n    \"\"\"\nreturn MEDIA_STATUS.inverse[self.mediaStatus()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_playback_state","title":"<code>get_playback_state() -&gt; PlaybackStateStr</code>","text":"<p>Return current playback state.</p> <p>Returns:</p> Type Description <code>PlaybackStateStr</code> <p>playback state</p> Source code in <code>prettyqt\\multimedia\\mediaplayer.py</code> <pre><code>def get_playback_state(self) -&gt; PlaybackStateStr:\n\"\"\"Return current playback state.\n    Returns:\n        playback state\n    \"\"\"\nreturn PLAYBACK_STATE.inverse[self.playbackState()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.MediaRecorder","title":"<code>MediaRecorder</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtMultimedia.QMediaRecorder</code></p> Source code in <code>prettyqt\\multimedia\\mediarecorder.py</code> <pre><code>class MediaRecorder(core.ObjectMixin, QtMultimedia.QMediaRecorder):\ndef set_output_location(self, url: datatypes.UrlType | os.PathLike | None = None):\nurl = datatypes.to_local_url(url)\nself.setOutputLocation(url)\ndef get_recorder_state(self) -&gt; RecorderStateStr:\n\"\"\"Return current recorder state.\n        Returns:\n            recorder state\n        \"\"\"\nreturn RECORDER_STATE.inverse[self.recorderState()]\ndef get_encoding_mode(self) -&gt; EncodingModeStr:\n\"\"\"Return current encoding mode.\n        Returns:\n            encoding mode\n        \"\"\"\nreturn ENCODING_MODE.inverse[self.encodingMode()]\ndef set_encoding_mode(self, mode: EncodingModeStr):\n\"\"\"Set encoding mode.\n        Args:\n            mode: encoding mode to use\n        \"\"\"\nself.setEncodingMode(ENCODING_MODE[mode])\ndef get_quality(self) -&gt; QualityStr:\n\"\"\"Return current quality setting.\n        Returns:\n            quality setting\n        \"\"\"\nreturn QUALITY.inverse[self.quality()]\ndef set_quality(self, quality: QualityStr):\n\"\"\"Set quality.\n        Args:\n            quality: quality to use\n        \"\"\"\nself.setQuality(QUALITY[quality])\ndef get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n        Returns:\n            error type\n        \"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder.get_encoding_mode","title":"<code>get_encoding_mode() -&gt; EncodingModeStr</code>","text":"<p>Return current encoding mode.</p> <p>Returns:</p> Type Description <code>EncodingModeStr</code> <p>encoding mode</p> Source code in <code>prettyqt\\multimedia\\mediarecorder.py</code> <pre><code>def get_encoding_mode(self) -&gt; EncodingModeStr:\n\"\"\"Return current encoding mode.\n    Returns:\n        encoding mode\n    \"\"\"\nreturn ENCODING_MODE.inverse[self.encodingMode()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\multimedia\\mediarecorder.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n    Returns:\n        error type\n    \"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder.get_quality","title":"<code>get_quality() -&gt; QualityStr</code>","text":"<p>Return current quality setting.</p> <p>Returns:</p> Type Description <code>QualityStr</code> <p>quality setting</p> Source code in <code>prettyqt\\multimedia\\mediarecorder.py</code> <pre><code>def get_quality(self) -&gt; QualityStr:\n\"\"\"Return current quality setting.\n    Returns:\n        quality setting\n    \"\"\"\nreturn QUALITY.inverse[self.quality()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder.get_recorder_state","title":"<code>get_recorder_state() -&gt; RecorderStateStr</code>","text":"<p>Return current recorder state.</p> <p>Returns:</p> Type Description <code>RecorderStateStr</code> <p>recorder state</p> Source code in <code>prettyqt\\multimedia\\mediarecorder.py</code> <pre><code>def get_recorder_state(self) -&gt; RecorderStateStr:\n\"\"\"Return current recorder state.\n    Returns:\n        recorder state\n    \"\"\"\nreturn RECORDER_STATE.inverse[self.recorderState()]\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder.set_encoding_mode","title":"<code>set_encoding_mode(mode: EncodingModeStr)</code>","text":"<p>Set encoding mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>EncodingModeStr</code> <p>encoding mode to use</p> required Source code in <code>prettyqt\\multimedia\\mediarecorder.py</code> <pre><code>def set_encoding_mode(self, mode: EncodingModeStr):\n\"\"\"Set encoding mode.\n    Args:\n        mode: encoding mode to use\n    \"\"\"\nself.setEncodingMode(ENCODING_MODE[mode])\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder.set_quality","title":"<code>set_quality(quality: QualityStr)</code>","text":"<p>Set quality.</p> <p>Parameters:</p> Name Type Description Default <code>quality</code> <code>QualityStr</code> <p>quality to use</p> required Source code in <code>prettyqt\\multimedia\\mediarecorder.py</code> <pre><code>def set_quality(self, quality: QualityStr):\n\"\"\"Set quality.\n    Args:\n        quality: quality to use\n    \"\"\"\nself.setQuality(QUALITY[quality])\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.ScreenCapture","title":"<code>ScreenCapture</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtMultimedia.QScreenCapture</code></p> Source code in <code>prettyqt\\multimedia\\screencapture.py</code> <pre><code>class ScreenCapture(core.ObjectMixin, QtMultimedia.QScreenCapture):\ndef get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n        Returns:\n            error type\n        \"\"\"\nreturn ERROR.inverse[self.error()]\ndef set_screen(self, screen: int | gui.QScreen | Literal[\"primary\"]):\nmatch screen:\ncase int():\nscreen = gui.GuiApplication.screens()[screen]\ncase gui.QScreen():\npass\ncase \"primary\":\nscreen = gui.GuiApplication.primaryScreen()\ncase _:\nraise TypeError(screen)\nself.setScreen(screen)\n</code></pre>"},{"location":"api/multimedia.html#prettyqt.multimedia.screencapture.ScreenCapture.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\multimedia\\screencapture.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n    Returns:\n        error type\n    \"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/multimediawidgets.html","title":"multimediawidgets module","text":"<p>Multimediawidgets module.</p>"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.GraphicsVideoItem","title":"<code>GraphicsVideoItem</code>","text":"<p>         Bases: <code>widgets.GraphicsObjectMixin</code>, <code>QtMultimediaWidgets.QGraphicsVideoItem</code></p> Source code in <code>prettyqt\\multimediawidgets\\graphicsvideoitem.py</code> <pre><code>class GraphicsVideoItem(\nwidgets.GraphicsObjectMixin, QtMultimediaWidgets.QGraphicsVideoItem\n):\ndef get_offset(self) -&gt; core.PointF:\nreturn core.PointF(self.offset())\ndef get_native_size(self) -&gt; core.SizeF:\nreturn core.SizeF(self.nativeSize())\ndef get_size(self) -&gt; core.SizeF:\nreturn core.SizeF(self.size())\ndef set_aspect_ratio_mode(\nself, mode: constants.AspectRatioModeStr | constants.AspectRatioMode\n):\n\"\"\"Set the aspect ratio mode.\n        Args:\n            mode: aspect ratio mode\n        \"\"\"\nself.setAspectRatioMode(constants.ASPECT_RATIO_MODE.get_enum_value(mode))\ndef get_aspect_ratio_mode(self) -&gt; constants.AspectRatioModeStr:\n\"\"\"Return current aspect ratio mode.\n        Returns:\n            aspect ratio mode\n        \"\"\"\nreturn constants.ASPECT_RATIO_MODE.inverse[self.aspectRatioMode()]\n</code></pre>"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.graphicsvideoitem.GraphicsVideoItem.get_aspect_ratio_mode","title":"<code>get_aspect_ratio_mode() -&gt; constants.AspectRatioModeStr</code>","text":"<p>Return current aspect ratio mode.</p> <p>Returns:</p> Type Description <code>constants.AspectRatioModeStr</code> <p>aspect ratio mode</p> Source code in <code>prettyqt\\multimediawidgets\\graphicsvideoitem.py</code> <pre><code>def get_aspect_ratio_mode(self) -&gt; constants.AspectRatioModeStr:\n\"\"\"Return current aspect ratio mode.\n    Returns:\n        aspect ratio mode\n    \"\"\"\nreturn constants.ASPECT_RATIO_MODE.inverse[self.aspectRatioMode()]\n</code></pre>"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.graphicsvideoitem.GraphicsVideoItem.set_aspect_ratio_mode","title":"<code>set_aspect_ratio_mode(mode: constants.AspectRatioModeStr | constants.AspectRatioMode)</code>","text":"<p>Set the aspect ratio mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.AspectRatioModeStr | constants.AspectRatioMode</code> <p>aspect ratio mode</p> required Source code in <code>prettyqt\\multimediawidgets\\graphicsvideoitem.py</code> <pre><code>def set_aspect_ratio_mode(\nself, mode: constants.AspectRatioModeStr | constants.AspectRatioMode\n):\n\"\"\"Set the aspect ratio mode.\n    Args:\n        mode: aspect ratio mode\n    \"\"\"\nself.setAspectRatioMode(constants.ASPECT_RATIO_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/network.html","title":"network module","text":"<p>Network module.</p> <p>Contains QtNetWork-based classes</p>"},{"location":"api/network.html#prettyqt.network.AbstractSocketMixin","title":"<code>AbstractSocketMixin</code>","text":"<p>         Bases: <code>core.IODeviceMixin</code></p> Source code in <code>prettyqt\\network\\abstractsocket.py</code> <pre><code>class AbstractSocketMixin(core.IODeviceMixin):\ndef __repr__(self):\nreturn get_repr(self)\ndef bind_to(\nself,\naddress: str | QtNetwork.QHostAddress,\nport: int = 0,\nbind_mode: (\nQtNetwork.QAbstractSocket.BindFlag | BindModeStr\n) = \"default_for_platform\",\n) -&gt; bool:\nif isinstance(address, str):\naddress = QtNetwork.QHostAddress(address)\nmode = BIND_MODE.get_enum_value(bind_mode)\nreturn self.bind(address, port, mode)\ndef connect_to_host(\nself,\nhostname: str,\nport: int,\nopen_mode: QtCore.QIODevice.OpenModeFlag\n| core.iodevice.OpenModeStr = \"read_write\",\nprotocol: (\nQtNetwork.QAbstractSocket.NetworkLayerProtocol | NetworkLayerProtocolStr\n) = \"any_ip\",\n):\nmode = core.iodevice.OPEN_MODES.get_enum_value(open_mode)\nprot = NETWORK_LAYER_PROTOCOL.get_enum_value(protocol)\nself.connectToHost(hostname, port, mode, prot)\ndef get_error(self) -&gt; SocketErrorStr:\nreturn SOCKET_ERROR.inverse[self.error()]\ndef set_pause_mode(self, mode: PauseModeStr | mod.PauseMode):\n\"\"\"Set pause mode.\n        Args:\n            mode: pause mode\n        \"\"\"\nself.setPauseMode(PAUSE_MODES.get_enum_value(mode))\ndef get_pause_mode(self) -&gt; PauseModeStr:\nreturn PAUSE_MODES.inverse[self.pauseMode()]\ndef get_proxy(self) -&gt; network.NetworkProxy:\nreturn network.NetworkProxy(self.proxy())\n# def set_socket_option(self, name: str, value):\n#     self.setSocketOption(SOCKET_OPTION.get_enum_value(name), value)\n# def get_socket_option(self, name: str):\n#     return self.socketOption(SOCKET_OPTION.get_enum_value(name))\n# def set_type_of_service(self, typ: str):\n#     self.set_socket_option(\"type_of_service\", TYPE_OF_SERVICE.get_enum_value(typ))\n# def get_type_of_service(self):\n#     opt = self.get_socket_option(\"type_of_service\")\n#     return TYPE_OF_SERVICE.inverse[opt]\ndef get_socket_type(self) -&gt; SocketTypeStr:\nreturn SOCKET_TYPE.inverse[self.socketType()]\ndef get_state(self) -&gt; SocketStateStr:\nreturn SOCKET_STATE.inverse[self.state()]\ndef get_local_address(self) -&gt; network.HostAddress:\nreturn network.HostAddress(self.localAddress())\n</code></pre>"},{"location":"api/network.html#prettyqt.network.abstractsocket.AbstractSocketMixin.set_pause_mode","title":"<code>set_pause_mode(mode: PauseModeStr | mod.PauseMode)</code>","text":"<p>Set pause mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>PauseModeStr | mod.PauseMode</code> <p>pause mode</p> required Source code in <code>prettyqt\\network\\abstractsocket.py</code> <pre><code>def set_pause_mode(self, mode: PauseModeStr | mod.PauseMode):\n\"\"\"Set pause mode.\n    Args:\n        mode: pause mode\n    \"\"\"\nself.setPauseMode(PAUSE_MODES.get_enum_value(mode))\n</code></pre>"},{"location":"api/network.html#prettyqt.network.HttpMultiPart","title":"<code>HttpMultiPart</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtNetwork.QHttpMultiPart</code></p> Source code in <code>prettyqt\\network\\httpmultipart.py</code> <pre><code>class HttpMultiPart(core.ObjectMixin, QtNetwork.QHttpMultiPart):\ndef __add__(self, other: QtNetwork.QHttpPart):\nself.append(other)\nreturn self\ndef set_content_type(\nself, typ: ContentTypeStr | QtNetwork.QHttpMultiPart.ContentType\n):\n\"\"\"Set content type.\n        Args:\n            typ: content type\n        \"\"\"\nself.setContentType(CONTENT_TYPES.get_enum_value(typ))\ndef set_boundary(self, boundary: datatypes.ByteArrayType):\nboundary = datatypes.to_bytearray(boundary)\nself.setBoundary(boundary)\ndef get_boundary(self) -&gt; str:\nreturn self.boundary().data().decode()\n</code></pre>"},{"location":"api/network.html#prettyqt.network.httpmultipart.HttpMultiPart.set_content_type","title":"<code>set_content_type(typ: ContentTypeStr | QtNetwork.QHttpMultiPart.ContentType)</code>","text":"<p>Set content type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>ContentTypeStr | QtNetwork.QHttpMultiPart.ContentType</code> <p>content type</p> required Source code in <code>prettyqt\\network\\httpmultipart.py</code> <pre><code>def set_content_type(\nself, typ: ContentTypeStr | QtNetwork.QHttpMultiPart.ContentType\n):\n\"\"\"Set content type.\n    Args:\n        typ: content type\n    \"\"\"\nself.setContentType(CONTENT_TYPES.get_enum_value(typ))\n</code></pre>"},{"location":"api/network.html#prettyqt.network.NetworkAccessManager","title":"<code>NetworkAccessManager</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtNetwork.QNetworkAccessManager</code></p> Source code in <code>prettyqt\\network\\networkaccessmanager.py</code> <pre><code>class NetworkAccessManager(core.ObjectMixin, QtNetwork.QNetworkAccessManager):\n# def request(\n#     self,\n#     method,\n#     url,\n#     headers=None,\n#     cookies=None,\n#     files=None,\n#     auth=None,\n#     timeout=None,\n#     allow_redirects=True,\n# ):\n#     req = network.NetworkRequest()\n#     if allow_redirects:\n#         pass\ndef get(self, request: datatypes.UrlType | QtNetwork.QNetworkRequest):\nif isinstance(request, str):\nrequest = core.Url(request)\nrequest = network.NetworkRequest(request)\nreturn super().get(request)\n# def post(self, url, data=None, json=None):\n#     pass\n# def put(self, url, data=None, json=None):\n#     pass\n# def patch(self, url, data=None):\n#     pass\n# def delete(self, url):\n#     pass\ndef set_redirect_policy(\nself,\npolicy: network.networkrequest.RedirectPolicyStr\n| network.NetworkRequest.RedirectPolicy,\n):\n\"\"\"Set redirect policy.\n        Args:\n            policy: redirect policy\n        \"\"\"\nself.setRedirectPolicy(\nnetwork.networkrequest.REDIRECT_POLICIES.get_enum_value(policy)\n)\ndef get_redirect_policy(self) -&gt; network.networkrequest.RedirectPolicyStr:\n\"\"\"Get the current redirect policy.\n        Returns:\n            redirect policy\n        \"\"\"\nreturn network.networkrequest.REDIRECT_POLICIES.inverse[self.redirectPolicy()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.get_redirect_policy","title":"<code>get_redirect_policy() -&gt; network.networkrequest.RedirectPolicyStr</code>","text":"<p>Get the current redirect policy.</p> <p>Returns:</p> Type Description <code>network.networkrequest.RedirectPolicyStr</code> <p>redirect policy</p> Source code in <code>prettyqt\\network\\networkaccessmanager.py</code> <pre><code>def get_redirect_policy(self) -&gt; network.networkrequest.RedirectPolicyStr:\n\"\"\"Get the current redirect policy.\n    Returns:\n        redirect policy\n    \"\"\"\nreturn network.networkrequest.REDIRECT_POLICIES.inverse[self.redirectPolicy()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.set_redirect_policy","title":"<code>set_redirect_policy(policy: network.networkrequest.RedirectPolicyStr | network.NetworkRequest.RedirectPolicy)</code>","text":"<p>Set redirect policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>network.networkrequest.RedirectPolicyStr | network.NetworkRequest.RedirectPolicy</code> <p>redirect policy</p> required Source code in <code>prettyqt\\network\\networkaccessmanager.py</code> <pre><code>def set_redirect_policy(\nself,\npolicy: network.networkrequest.RedirectPolicyStr\n| network.NetworkRequest.RedirectPolicy,\n):\n\"\"\"Set redirect policy.\n    Args:\n        policy: redirect policy\n    \"\"\"\nself.setRedirectPolicy(\nnetwork.networkrequest.REDIRECT_POLICIES.get_enum_value(policy)\n)\n</code></pre>"},{"location":"api/network.html#prettyqt.network.NetworkAddressEntry","title":"<code>NetworkAddressEntry</code>","text":"<p>         Bases: <code>QtNetwork.QNetworkAddressEntry</code></p> Source code in <code>prettyqt\\network\\networkaddressentry.py</code> <pre><code>class NetworkAddressEntry(QtNetwork.QNetworkAddressEntry):\ndef get_dns_eligibility(self) -&gt; DnsEligibilityStatusStr:\n\"\"\"Return whether this address is eligible for publication in the DNS.\n        Returns:\n            DNS eligibility\n        \"\"\"\nreturn DNS_ELIGIBILITY_STATUS.inverse[self.dnsEligibility()]\ndef set_dns_eligibility(\nself,\nstatus: DnsEligibilityStatusStr\n| QtNetwork.QNetworkAddressEntry.DnsEligibilityStatus,\n):\n\"\"\"Set the DNS eligibility flag for this address to status.\n        Args:\n            status: DNS eligibility status\n        \"\"\"\nself.setDnsEligibility(DNS_ELIGIBILITY_STATUS.get_enum_value(status))\ndef get_ip(self) -&gt; network.HostAddress:\nreturn network.HostAddress(self.ip())\ndef set_ip(self, ip: QtNetwork.QHostAddress | str):\nself.setIp(network.HostAddress(ip))\ndef get_netmask(self) -&gt; network.HostAddress:\nreturn network.HostAddress(self.netmask())\ndef set_netmask(self, netmask: QtNetwork.QHostAddress | str):\nself.setNetmask(network.HostAddress(netmask))\ndef get_preferred_lifetime(self) -&gt; core.DeadlineTimer:\nreturn core.DeadlineTimer(self.preferredLifetime())\ndef get_validity_lifetime(self) -&gt; core.DeadlineTimer:\nreturn core.DeadlineTimer(self.validityLifetime())\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.get_dns_eligibility","title":"<code>get_dns_eligibility() -&gt; DnsEligibilityStatusStr</code>","text":"<p>Return whether this address is eligible for publication in the DNS.</p> <p>Returns:</p> Type Description <code>DnsEligibilityStatusStr</code> <p>DNS eligibility</p> Source code in <code>prettyqt\\network\\networkaddressentry.py</code> <pre><code>def get_dns_eligibility(self) -&gt; DnsEligibilityStatusStr:\n\"\"\"Return whether this address is eligible for publication in the DNS.\n    Returns:\n        DNS eligibility\n    \"\"\"\nreturn DNS_ELIGIBILITY_STATUS.inverse[self.dnsEligibility()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.set_dns_eligibility","title":"<code>set_dns_eligibility(status: DnsEligibilityStatusStr | QtNetwork.QNetworkAddressEntry.DnsEligibilityStatus)</code>","text":"<p>Set the DNS eligibility flag for this address to status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>DnsEligibilityStatusStr | QtNetwork.QNetworkAddressEntry.DnsEligibilityStatus</code> <p>DNS eligibility status</p> required Source code in <code>prettyqt\\network\\networkaddressentry.py</code> <pre><code>def set_dns_eligibility(\nself,\nstatus: DnsEligibilityStatusStr\n| QtNetwork.QNetworkAddressEntry.DnsEligibilityStatus,\n):\n\"\"\"Set the DNS eligibility flag for this address to status.\n    Args:\n        status: DNS eligibility status\n    \"\"\"\nself.setDnsEligibility(DNS_ELIGIBILITY_STATUS.get_enum_value(status))\n</code></pre>"},{"location":"api/network.html#prettyqt.network.NetworkInterface","title":"<code>NetworkInterface</code>","text":"<p>         Bases: <code>QtNetwork.QNetworkInterface</code></p> Source code in <code>prettyqt\\network\\networkinterface.py</code> <pre><code>class NetworkInterface(QtNetwork.QNetworkInterface):\n# def __bool__(self):\n#     return self.isValid()\ndef get_type(self) -&gt; InterfaceTypeStr:\n\"\"\"Get the interface type.\n        Returns:\n            interface type\n        \"\"\"\nreturn INTERFACE_TYPE.inverse[self.type()]\ndef get_address_entries(self) -&gt; list[network.NetworkAddressEntry]:\nreturn [network.NetworkAddressEntry(i) for i in self.addressEntries()]\n@staticmethod\ndef get_all_addresses() -&gt; list[network.HostAddress]:\nreturn [network.HostAddress(i) for i in NetworkInterface.allAddresses()]\n@staticmethod\ndef get_all_interfaces() -&gt; list[network.HostAddress]:\nreturn [network.NetworkInterface(i) for i in NetworkInterface.allInterfaces()]\n@staticmethod\ndef get_interface_from_name(name: str) -&gt; NetworkInterface:\ninterface = NetworkInterface.interfaceFromName(name)\n# if not interface:\n#     return None\nreturn NetworkInterface(interface)\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkinterface.NetworkInterface.get_type","title":"<code>get_type() -&gt; InterfaceTypeStr</code>","text":"<p>Get the interface type.</p> <p>Returns:</p> Type Description <code>InterfaceTypeStr</code> <p>interface type</p> Source code in <code>prettyqt\\network\\networkinterface.py</code> <pre><code>def get_type(self) -&gt; InterfaceTypeStr:\n\"\"\"Get the interface type.\n    Returns:\n        interface type\n    \"\"\"\nreturn INTERFACE_TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.NetworkProxy","title":"<code>NetworkProxy</code>","text":"<p>         Bases: <code>QtNetwork.QNetworkProxy</code></p> Source code in <code>prettyqt\\network\\networkproxy.py</code> <pre><code>class NetworkProxy(QtNetwork.QNetworkProxy):\ndef get_capabilities(self) -&gt; list[CapabilityStr]:\nreturn CAPABILITIES.get_list(self.capabilities())\ndef set_capabilities(self, *capability: CapabilityStr):\nflags = CAPABILITIES.merge_flags(capability)\nself.setCapabilities(flags)\ndef get_header(\nself,\nname: network.networkrequest.KnownHeaderStr | network.NetworkRequest.KnownHeaders,\n) -&gt; str:\nreturn self.header(network.networkrequest.KNOWN_HEADER.get_enum_value(name))\ndef set_header(\nself,\nname: network.networkrequest.KnownHeaderStr | network.NetworkRequest.KnownHeaders,\nvalue: str,\n):\nself.setHeader(network.networkrequest.KNOWN_HEADER.get_enum_value(name), value)\ndef get_headers(self) -&gt; dict[str, str]:\nreturn {\nh.data().decode(): self.rawHeader(h).data().decode()\nfor h in self.rawHeaderList()\n}\ndef set_headers(self, headers: dict[str, str]):\nfor k, v in headers.items():\nself.setRawHeader(\nQtCore.QByteArray(k.encode()), QtCore.QByteArray(v.encode())\n)\ndef set_type(self, typ: ProxyTypeStr | QtNetwork.QNetworkProxy.ProxyType):\n\"\"\"Set proxy type.\n        Args:\n            typ: proxy type\n        \"\"\"\nself.setType(PROXY_TYPES.get_enum_value(typ))\ndef get_type(self) -&gt; ProxyTypeStr:\n\"\"\"Get the proxy type.\n        Returns:\n            type\n        \"\"\"\nreturn PROXY_TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.get_type","title":"<code>get_type() -&gt; ProxyTypeStr</code>","text":"<p>Get the proxy type.</p> <p>Returns:</p> Type Description <code>ProxyTypeStr</code> <p>type</p> Source code in <code>prettyqt\\network\\networkproxy.py</code> <pre><code>def get_type(self) -&gt; ProxyTypeStr:\n\"\"\"Get the proxy type.\n    Returns:\n        type\n    \"\"\"\nreturn PROXY_TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.set_type","title":"<code>set_type(typ: ProxyTypeStr | QtNetwork.QNetworkProxy.ProxyType)</code>","text":"<p>Set proxy type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>ProxyTypeStr | QtNetwork.QNetworkProxy.ProxyType</code> <p>proxy type</p> required Source code in <code>prettyqt\\network\\networkproxy.py</code> <pre><code>def set_type(self, typ: ProxyTypeStr | QtNetwork.QNetworkProxy.ProxyType):\n\"\"\"Set proxy type.\n    Args:\n        typ: proxy type\n    \"\"\"\nself.setType(PROXY_TYPES.get_enum_value(typ))\n</code></pre>"},{"location":"api/network.html#prettyqt.network.NetworkReply","title":"<code>NetworkReply</code>","text":"Source code in <code>prettyqt\\network\\networkreply.py</code> <pre><code>class NetworkReply:\ndef __init__(self, reply: QtNetwork.QNetworkReply):\nself.item = reply\ndef __getattr__(self, val):\nreturn getattr(self.item, val)\ndef get_error(self) -&gt; NetworkErrorStr:\n\"\"\"Return error type.\n        Returns:\n            error type\n        \"\"\"\nreturn NETWORK_ERROR.inverse[self.error()]\ndef set_raw_headers(self, headers: dict[str, str]):\nfor k, v in headers.items():\nself.setRawHeader(\nQtCore.QByteArray(k.encode()), QtCore.QByteArray(v.encode())\n)\ndef get_raw_headers(self) -&gt; dict[str, str]:\nreturn {\nh.data().decode(): self.rawHeader(h).data().decode()\nfor h in self.rawHeaderList()\n}\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkreply.NetworkReply.get_error","title":"<code>get_error() -&gt; NetworkErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>NetworkErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\network\\networkreply.py</code> <pre><code>def get_error(self) -&gt; NetworkErrorStr:\n\"\"\"Return error type.\n    Returns:\n        error type\n    \"\"\"\nreturn NETWORK_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.NetworkRequest","title":"<code>NetworkRequest</code>","text":"<p>         Bases: <code>QtNetwork.QNetworkRequest</code></p> Source code in <code>prettyqt\\network\\networkrequest.py</code> <pre><code>class NetworkRequest(QtNetwork.QNetworkRequest):\ndef __init__(self, obj: datatypes.UrlType | QtNetwork.QNetworkRequest | None = None):\nif isinstance(obj, QtNetwork.QNetworkRequest):\nsuper().__init__(obj)\nelse:\nsuper().__init__()\nif obj is not None:\nself.set_url(obj)\ndef __repr__(self):\nreturn get_repr(self, self.get_url())\ndef set_header(self, name: KnownHeaderStr | Req.KnownHeaders, value: str):\nself.setHeader(KNOWN_HEADER.get_enum_value(name), value)\ndef get_header(self, name: KnownHeaderStr | Req.KnownHeaders) -&gt; str:\nreturn self.header(KNOWN_HEADER.get_enum_value(name))\ndef set_headers(self, headers: Mapping[str, str]):\nfor k, v in headers.items():\nself.setRawHeader(\nQtCore.QByteArray(k.encode()), QtCore.QByteArray(v.encode())\n)\ndef get_headers(self) -&gt; Mapping[str, str]:\nreturn {\nh.data().decode(): self.rawHeader(h).data().decode()\nfor h in self.rawHeaderList()\n}\ndef set_url(self, url: str | QtCore.QUrl):\nurl = core.Url(url)\nself.setUrl(url)\ndef get_url(self) -&gt; core.Url:\nreturn core.Url(self.url())\ndef set_priority(self, priority: PriorityStr | Req.Priority):\n\"\"\"Set priority.\n        Args:\n            priority: priority\n        \"\"\"\nself.setPriority(PRIORITY.get_enum_value(priority))\ndef get_priority(self) -&gt; PriorityStr:\n\"\"\"Get the current priority.\n        Returns:\n            priority\n        \"\"\"\nreturn PRIORITY.inverse[self.priority()]\ndef set_attribute(\nself, attribute: AttributeStr | Req.Attribute, value: datatypes.Variant\n):\nself.setAttribute(ATTRIBUTE.get_enum_value(attribute), value)\ndef set_attributes(self, **kwargs):\nfor k, v in kwargs.items():\nself.set_attribute(k, v)\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.get_priority","title":"<code>get_priority() -&gt; PriorityStr</code>","text":"<p>Get the current priority.</p> <p>Returns:</p> Type Description <code>PriorityStr</code> <p>priority</p> Source code in <code>prettyqt\\network\\networkrequest.py</code> <pre><code>def get_priority(self) -&gt; PriorityStr:\n\"\"\"Get the current priority.\n    Returns:\n        priority\n    \"\"\"\nreturn PRIORITY.inverse[self.priority()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.set_priority","title":"<code>set_priority(priority: PriorityStr | Req.Priority)</code>","text":"<p>Set priority.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>PriorityStr | Req.Priority</code> <p>priority</p> required Source code in <code>prettyqt\\network\\networkrequest.py</code> <pre><code>def set_priority(self, priority: PriorityStr | Req.Priority):\n\"\"\"Set priority.\n    Args:\n        priority: priority\n    \"\"\"\nself.setPriority(PRIORITY.get_enum_value(priority))\n</code></pre>"},{"location":"api/objbrowser.html","title":"objbrowser module","text":"<p>Objbrowser package.</p>"},{"location":"api/pdf.html","title":"pdf module","text":"<p>Pdf module.</p>"},{"location":"api/pdf.html#prettyqt.pdf.PdfBookmarkModel","title":"<code>PdfBookmarkModel</code>","text":"<p>         Bases: <code>core.AbstractItemModelMixin</code>, <code>QtPdf.QPdfBookmarkModel</code></p> Source code in <code>prettyqt\\pdf\\pdfbookmarkmodel.py</code> <pre><code>class PdfBookmarkModel(core.AbstractItemModelMixin, QtPdf.QPdfBookmarkModel):\ndef __init__(self, parent: QtCore.QObject | None = None):\nsuper().__init__(parent)\nself.setDocument(pdf.PdfDocument(self))\ndef set_document(self, document: datatypes.PathType | QtPdf.QPdfDocument):\n\"\"\"Set document for model.\"\"\"\nif not isinstance(document, QtPdf.QPdfDocument):\npath = os.fspath(document)\ndocument = pdf.PdfDocument(self)\ndocument.load(path)\nself.setDocument(document)\n</code></pre>"},{"location":"api/pdf.html#prettyqt.pdf.pdfbookmarkmodel.PdfBookmarkModel.set_document","title":"<code>set_document(document: datatypes.PathType | QtPdf.QPdfDocument)</code>","text":"<p>Set document for model.</p> Source code in <code>prettyqt\\pdf\\pdfbookmarkmodel.py</code> <pre><code>def set_document(self, document: datatypes.PathType | QtPdf.QPdfDocument):\n\"\"\"Set document for model.\"\"\"\nif not isinstance(document, QtPdf.QPdfDocument):\npath = os.fspath(document)\ndocument = pdf.PdfDocument(self)\ndocument.load(path)\nself.setDocument(document)\n</code></pre>"},{"location":"api/pdf.html#prettyqt.pdf.PdfDocument","title":"<code>PdfDocument</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtPdf.QPdfDocument</code></p> Source code in <code>prettyqt\\pdf\\pdfdocument.py</code> <pre><code>class PdfDocument(core.ObjectMixin, QtPdf.QPdfDocument):\ndef get_error(self) -&gt; ErrorStr:\n\"\"\"Return current error.\n        Returns:\n            page mode\n        \"\"\"\nreturn ERROR.inverse[self.error()]\ndef get_status(self) -&gt; StatusStr:\n\"\"\"Return current status.\n        Returns:\n            zoom mode\n        \"\"\"\nreturn STATUS.inverse[self.status()]\n</code></pre>"},{"location":"api/pdf.html#prettyqt.pdf.pdfdocument.PdfDocument.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return current error.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>page mode</p> Source code in <code>prettyqt\\pdf\\pdfdocument.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return current error.\n    Returns:\n        page mode\n    \"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/pdf.html#prettyqt.pdf.pdfdocument.PdfDocument.get_status","title":"<code>get_status() -&gt; StatusStr</code>","text":"<p>Return current status.</p> <p>Returns:</p> Type Description <code>StatusStr</code> <p>zoom mode</p> Source code in <code>prettyqt\\pdf\\pdfdocument.py</code> <pre><code>def get_status(self) -&gt; StatusStr:\n\"\"\"Return current status.\n    Returns:\n        zoom mode\n    \"\"\"\nreturn STATUS.inverse[self.status()]\n</code></pre>"},{"location":"api/pdf.html#prettyqt.pdf.PdfSearchModel","title":"<code>PdfSearchModel</code>","text":"<p>         Bases: <code>core.AbstractItemModelMixin</code>, <code>QtPdf.QPdfSearchModel</code></p> Source code in <code>prettyqt\\pdf\\pdfsearchmodel.py</code> <pre><code>class PdfSearchModel(core.AbstractItemModelMixin, QtPdf.QPdfSearchModel):\ndef __init__(self, parent: QtCore.QObject | None = None):\nsuper().__init__(parent)\nself.setDocument(pdf.PdfDocument(self))\ndef set_document(self, document: datatypes.PathType | QtPdf.QPdfDocument):\n\"\"\"Set document for model.\"\"\"\nif not isinstance(document, QtPdf.QPdfDocument):\npath = os.fspath(document)\ndocument = pdf.PdfDocument(self)\ndocument.load(path)\nself.setDocument(document)\n</code></pre>"},{"location":"api/pdf.html#prettyqt.pdf.pdfsearchmodel.PdfSearchModel.set_document","title":"<code>set_document(document: datatypes.PathType | QtPdf.QPdfDocument)</code>","text":"<p>Set document for model.</p> Source code in <code>prettyqt\\pdf\\pdfsearchmodel.py</code> <pre><code>def set_document(self, document: datatypes.PathType | QtPdf.QPdfDocument):\n\"\"\"Set document for model.\"\"\"\nif not isinstance(document, QtPdf.QPdfDocument):\npath = os.fspath(document)\ndocument = pdf.PdfDocument(self)\ndocument.load(path)\nself.setDocument(document)\n</code></pre>"},{"location":"api/pdfwidgets.html","title":"pdfwidgets module","text":"<p>Pdfwidgets module.</p>"},{"location":"api/pdfwidgets.html#prettyqt.pdfwidgets.PdfView","title":"<code>PdfView</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code>, <code>QtPdfWidgets.QPdfView</code></p> Source code in <code>prettyqt\\pdfwidgets\\pdfview.py</code> <pre><code>class PdfView(widgets.AbstractScrollAreaMixin, QtPdfWidgets.QPdfView):\ndef __init__(self, parent: QtWidgets.QWidget | None = None, **kwargs):\nsuper().__init__(parent, **kwargs)\nself.setDocument(pdf.PdfDocument(self))\ndef get_document_margins(self) -&gt; core.Margins:\nreturn core.Margins(self.documentMargins())\ndef set_file(self, path: datatypes.PathType):\ndoc = pdf.PdfDocument(self)\ndoc.load(os.fspath(path))\nself.setDocument(doc)\ndef set_page_mode(self, mode: PageModeStr | QtPdfWidgets.QPdfView.PageMode):\n\"\"\"Set the page mode.\n        Args:\n            mode: page mode\n        \"\"\"\nself.setPageMode(PAGE_MODE.get_enum_value(mode))\ndef get_page_mode(self) -&gt; PageModeStr:\n\"\"\"Return current page mode.\n        Returns:\n            page mode\n        \"\"\"\nreturn PAGE_MODE.inverse[self.pageMode()]\ndef set_zoom_mode(self, mode: ZoomModeStr | QtPdfWidgets.QPdfView.ZoomMode):\n\"\"\"Set the zoom mode.\n        Args:\n            mode: zoom mode\n        \"\"\"\nself.setZoomMode(ZOOM_MODE.get_enum_value(mode))\ndef get_zoom_mode(self) -&gt; ZoomModeStr:\n\"\"\"Return current zoom mode.\n        Returns:\n            zoom mode\n        \"\"\"\nreturn ZOOM_MODE.inverse[self.zoomMode()]\n</code></pre>"},{"location":"api/pdfwidgets.html#prettyqt.pdfwidgets.pdfview.PdfView.get_page_mode","title":"<code>get_page_mode() -&gt; PageModeStr</code>","text":"<p>Return current page mode.</p> <p>Returns:</p> Type Description <code>PageModeStr</code> <p>page mode</p> Source code in <code>prettyqt\\pdfwidgets\\pdfview.py</code> <pre><code>def get_page_mode(self) -&gt; PageModeStr:\n\"\"\"Return current page mode.\n    Returns:\n        page mode\n    \"\"\"\nreturn PAGE_MODE.inverse[self.pageMode()]\n</code></pre>"},{"location":"api/pdfwidgets.html#prettyqt.pdfwidgets.pdfview.PdfView.get_zoom_mode","title":"<code>get_zoom_mode() -&gt; ZoomModeStr</code>","text":"<p>Return current zoom mode.</p> <p>Returns:</p> Type Description <code>ZoomModeStr</code> <p>zoom mode</p> Source code in <code>prettyqt\\pdfwidgets\\pdfview.py</code> <pre><code>def get_zoom_mode(self) -&gt; ZoomModeStr:\n\"\"\"Return current zoom mode.\n    Returns:\n        zoom mode\n    \"\"\"\nreturn ZOOM_MODE.inverse[self.zoomMode()]\n</code></pre>"},{"location":"api/pdfwidgets.html#prettyqt.pdfwidgets.pdfview.PdfView.set_page_mode","title":"<code>set_page_mode(mode: PageModeStr | QtPdfWidgets.QPdfView.PageMode)</code>","text":"<p>Set the page mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>PageModeStr | QtPdfWidgets.QPdfView.PageMode</code> <p>page mode</p> required Source code in <code>prettyqt\\pdfwidgets\\pdfview.py</code> <pre><code>def set_page_mode(self, mode: PageModeStr | QtPdfWidgets.QPdfView.PageMode):\n\"\"\"Set the page mode.\n    Args:\n        mode: page mode\n    \"\"\"\nself.setPageMode(PAGE_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/pdfwidgets.html#prettyqt.pdfwidgets.pdfview.PdfView.set_zoom_mode","title":"<code>set_zoom_mode(mode: ZoomModeStr | QtPdfWidgets.QPdfView.ZoomMode)</code>","text":"<p>Set the zoom mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ZoomModeStr | QtPdfWidgets.QPdfView.ZoomMode</code> <p>zoom mode</p> required Source code in <code>prettyqt\\pdfwidgets\\pdfview.py</code> <pre><code>def set_zoom_mode(self, mode: ZoomModeStr | QtPdfWidgets.QPdfView.ZoomMode):\n\"\"\"Set the zoom mode.\n    Args:\n        mode: zoom mode\n    \"\"\"\nself.setZoomMode(ZOOM_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/positioning.html","title":"positioning module","text":"<p>Positioning module.</p> <p>Contains QtPositioning-based classes</p>"},{"location":"api/positioning.html#prettyqt.positioning.GeoAreaMonitorSource","title":"<code>GeoAreaMonitorSource</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtPositioning.QGeoAreaMonitorSource</code></p> Source code in <code>prettyqt\\positioning\\geoareamonitorsource.py</code> <pre><code>class GeoAreaMonitorSource(core.ObjectMixin, QtPositioning.QGeoAreaMonitorSource):\ndef __str__(self):\nreturn self.sourceName()\ndef __repr__(self):\nreturn get_repr(self, self.name())\ndef get_error(self) -&gt; AreaMonitorFeatureStr:\n\"\"\"Return error type.\n        Returns:\n            error type\n        \"\"\"\nreturn ERRORS.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource.GeoAreaMonitorSource.get_error","title":"<code>get_error() -&gt; AreaMonitorFeatureStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>AreaMonitorFeatureStr</code> <p>error type</p> Source code in <code>prettyqt\\positioning\\geoareamonitorsource.py</code> <pre><code>def get_error(self) -&gt; AreaMonitorFeatureStr:\n\"\"\"Return error type.\n    Returns:\n        error type\n    \"\"\"\nreturn ERRORS.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.GeoPositionInfoSourceMixin","title":"<code>GeoPositionInfoSourceMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\positioning\\geopositioninfosource.py</code> <pre><code>class GeoPositionInfoSourceMixin(core.ObjectMixin):\ndef __str__(self):\nreturn self.sourceName()\ndef __repr__(self):\nreturn get_repr(self)\ndef get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n        Returns:\n            error type\n        \"\"\"\nreturn ERRORS.inverse[self.error()]\ndef set_preferred_positioning_methods(self, *methods: PositioningMethodStr):\n\"\"\"Set preferred positioning methods.\n        Args:\n            methods: positioning methods to use\n        \"\"\"\nflags = POSITIONING_METHODS.merge_flags(methods)\nself.setPreferredPositioningMethods(flags)\ndef get_preferred_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of preferred positioning methods.\n        Returns:\n            list of preferred positioning methods\n        \"\"\"\nreturn POSITIONING_METHODS.get_list(self.preferredPositioningMethods())\ndef get_supported_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of supported positioning methods.\n        Returns:\n            list of supported positioning methods\n        \"\"\"\nreturn POSITIONING_METHODS.get_list(self.supportedPositioningMethods())\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\positioning\\geopositioninfosource.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n    Returns:\n        error type\n    \"\"\"\nreturn ERRORS.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.get_preferred_positioning_methods","title":"<code>get_preferred_positioning_methods() -&gt; list[PositioningMethodStr]</code>","text":"<p>Return list of preferred positioning methods.</p> <p>Returns:</p> Type Description <code>list[PositioningMethodStr]</code> <p>list of preferred positioning methods</p> Source code in <code>prettyqt\\positioning\\geopositioninfosource.py</code> <pre><code>def get_preferred_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of preferred positioning methods.\n    Returns:\n        list of preferred positioning methods\n    \"\"\"\nreturn POSITIONING_METHODS.get_list(self.preferredPositioningMethods())\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.get_supported_positioning_methods","title":"<code>get_supported_positioning_methods() -&gt; list[PositioningMethodStr]</code>","text":"<p>Return list of supported positioning methods.</p> <p>Returns:</p> Type Description <code>list[PositioningMethodStr]</code> <p>list of supported positioning methods</p> Source code in <code>prettyqt\\positioning\\geopositioninfosource.py</code> <pre><code>def get_supported_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of supported positioning methods.\n    Returns:\n        list of supported positioning methods\n    \"\"\"\nreturn POSITIONING_METHODS.get_list(self.supportedPositioningMethods())\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.set_preferred_positioning_methods","title":"<code>set_preferred_positioning_methods(*methods: PositioningMethodStr)</code>","text":"<p>Set preferred positioning methods.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>PositioningMethodStr</code> <p>positioning methods to use</p> <code>()</code> Source code in <code>prettyqt\\positioning\\geopositioninfosource.py</code> <pre><code>def set_preferred_positioning_methods(self, *methods: PositioningMethodStr):\n\"\"\"Set preferred positioning methods.\n    Args:\n        methods: positioning methods to use\n    \"\"\"\nflags = POSITIONING_METHODS.merge_flags(methods)\nself.setPreferredPositioningMethods(flags)\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.GeoSatelliteInfo","title":"<code>GeoSatelliteInfo</code>","text":"<p>         Bases: <code>QtPositioning.QGeoSatelliteInfo</code></p> Source code in <code>prettyqt\\positioning\\geosatelliteinfo.py</code> <pre><code>class GeoSatelliteInfo(QtPositioning.QGeoSatelliteInfo):\ndef __getitem__(self, index: AttributeStr):\nreturn self.attribute(ATTRIBUTE[index])\ndef __setitem__(self, index: AttributeStr, value: float):\nself.setAttribute(ATTRIBUTE[index], value)\ndef __delitem__(self, index: AttributeStr):\nself.removeAttribute(ATTRIBUTE[index])\ndef __contains__(self, value: AttributeStr):\nreturn self.hasAttribute(ATTRIBUTE[value])\ndef __int__(self):\nreturn self.satelliteIdentifier()\ndef set_satellite_system(\nself, system: SatelliteSystemStr | QtPositioning.QGeoSatelliteInfo.SatelliteSystem\n):\n\"\"\"Set satellite system.\n        Args:\n            system: satellite system to use\n        \"\"\"\nself.setSatelliteSystem(SATELLITE_SYSTEMS.get_enum_value(system))\ndef get_satellite_system(self) -&gt; SatelliteSystemStr:\n\"\"\"Return satellite system.\n        Returns:\n            satellite system\n        \"\"\"\nreturn SATELLITE_SYSTEMS.inverse[self.satelliteSystem()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.get_satellite_system","title":"<code>get_satellite_system() -&gt; SatelliteSystemStr</code>","text":"<p>Return satellite system.</p> <p>Returns:</p> Type Description <code>SatelliteSystemStr</code> <p>satellite system</p> Source code in <code>prettyqt\\positioning\\geosatelliteinfo.py</code> <pre><code>def get_satellite_system(self) -&gt; SatelliteSystemStr:\n\"\"\"Return satellite system.\n    Returns:\n        satellite system\n    \"\"\"\nreturn SATELLITE_SYSTEMS.inverse[self.satelliteSystem()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.set_satellite_system","title":"<code>set_satellite_system(system: SatelliteSystemStr | QtPositioning.QGeoSatelliteInfo.SatelliteSystem)</code>","text":"<p>Set satellite system.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>SatelliteSystemStr | QtPositioning.QGeoSatelliteInfo.SatelliteSystem</code> <p>satellite system to use</p> required Source code in <code>prettyqt\\positioning\\geosatelliteinfo.py</code> <pre><code>def set_satellite_system(\nself, system: SatelliteSystemStr | QtPositioning.QGeoSatelliteInfo.SatelliteSystem\n):\n\"\"\"Set satellite system.\n    Args:\n        system: satellite system to use\n    \"\"\"\nself.setSatelliteSystem(SATELLITE_SYSTEMS.get_enum_value(system))\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.GeoSatelliteInfoSource","title":"<code>GeoSatelliteInfoSource</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtPositioning.QGeoSatelliteInfoSource</code></p> Source code in <code>prettyqt\\positioning\\geosatelliteinfosource.py</code> <pre><code>class GeoSatelliteInfoSource(core.ObjectMixin, QtPositioning.QGeoSatelliteInfoSource):\ndef __str__(self):\nreturn self.sourceName()\ndef __repr__(self):\nreturn get_repr(self)\ndef get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n        Returns:\n            error type\n        \"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource.GeoSatelliteInfoSource.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\positioning\\geosatelliteinfosource.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n    Returns:\n        error type\n    \"\"\"\nreturn ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/qml.html","title":"qml module","text":"<p>Qml module.</p> <p>Contains QtQml-based classes</p>"},{"location":"api/qml.html#prettyqt.qml.JSValue","title":"<code>JSValue</code>","text":"<p>         Bases: <code>QtQml.QJSValue</code></p> Source code in <code>prettyqt\\qml\\jsvalue.py</code> <pre><code>class JSValue(QtQml.QJSValue):\ndef __repr__(self):\nreturn get_repr(self, self.toVariant())\ndef __len__(self):\nreturn self.property(\"length\").toVariant()\ndef __getitem__(self, index: int | str):\nreturn self.property(index).toVariant()\ndef __delitem__(self, index: str):\nself.deleteProperty(index)\ndef __setitem__(self, index: int | str, value):\nself.setProperty(index, value)\ndef __iter__(self):\niterator = qml.JSValueIterator(self)\nreturn iter(list(iterator))\ndef __contains__(self, index: str):\nreturn self.hasProperty(index)\ndef __call__(self, *args) -&gt; JSValue:\nresult = self.call(args)\nreturn JSValue(result)\ndef get_value(self):\nreturn self.toVariant()\ndef get_error_type(self) -&gt; ErrorTypeStr | None:\nif (error_type := self.errorType()) == QtQml.QJSValue.ErrorType(0):\nreturn None\nelse:\nreturn ERROR_TYPES.inverse[error_type]\n@classmethod\ndef from_object(cls, obj, jsengine: QtQml.QJSEngine) -&gt; Self:\n\"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\"\nmatch obj:\ncase None:\nreturn cls()\ncase list() | tuple():\nlength = len(obj)\narray = cls(jsengine.newArray(length))\nfor i, v in enumerate(obj):\narray.setProperty(i, cls.from_object(v, jsengine))\nreturn array\ncase dict():\narray = cls(jsengine.newArray())\nfor k, v in obj.items():\narray.setProperty(k, cls.from_object(v, jsengine))\nreturn array\ncase _:\ntry:\nreturn cls(obj)\nexcept TypeError:\nlogger.debug(f\"unknown type: {str(obj)}\")\nreturn cls()\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.jsvalue.JSValue.from_object","title":"<code>from_object(obj, jsengine: QtQml.QJSEngine) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Convert any python object into a QJSValue (must happen in GUI thread).</p> Source code in <code>prettyqt\\qml\\jsvalue.py</code> <pre><code>@classmethod\ndef from_object(cls, obj, jsengine: QtQml.QJSEngine) -&gt; Self:\n\"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\"\nmatch obj:\ncase None:\nreturn cls()\ncase list() | tuple():\nlength = len(obj)\narray = cls(jsengine.newArray(length))\nfor i, v in enumerate(obj):\narray.setProperty(i, cls.from_object(v, jsengine))\nreturn array\ncase dict():\narray = cls(jsengine.newArray())\nfor k, v in obj.items():\narray.setProperty(k, cls.from_object(v, jsengine))\nreturn array\ncase _:\ntry:\nreturn cls(obj)\nexcept TypeError:\nlogger.debug(f\"unknown type: {str(obj)}\")\nreturn cls()\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.QmlEngineMixin","title":"<code>QmlEngineMixin</code>","text":"<p>         Bases: <code>qml.JSEngineMixin</code></p> Source code in <code>prettyqt\\qml\\qmlengine.py</code> <pre><code>class QmlEngineMixin(qml.JSEngineMixin):\ndef set_object_ownership(\nself,\nobj: QtCore.QObject,\nmode: ObjectOwnershipStr | QtQml.QQmlEngine.ObjectOwnership,\n):\n\"\"\"Set the object ownership.\n        Args:\n            obj: object to set ownership for\n            mode: object ownership to use\n        \"\"\"\nself.setObjectOwnership(obj, OBJECT_OWNERSHIP.get_enum_value(mode))\ndef get_object_ownership(self, obj: QtCore.QObject) -&gt; ObjectOwnershipStr:\n\"\"\"Return object ownership.\n        Returns:\n            object ownership\n        \"\"\"\nreturn OBJECT_OWNERSHIP.inverse[self.objectOwnership(obj)]\ndef add_import_path(self, path: datatypes.PathType):\nself.addImportPath(os.fspath(path))\ndef add_plugin_path(self, path: datatypes.PathType):\nself.addPluginPath(os.fspath(path))\ndef get_plugin_paths(self) -&gt; list[pathlib.Path]:\nreturn [pathlib.Path(p) for p in self.pluginPathList()]\ndef get_import_paths(self) -&gt; list[pathlib.Path]:\nreturn [pathlib.Path(p) for p in self.importPathList()]\ndef set_base_url(self, url: str | QtCore.QUrl):\nif isinstance(url, str):\nurl = QtCore.QUrl(url)\nself.setBaseUrl(url)\ndef get_base_url(self) -&gt; core.Url:\nreturn core.Url(self.baseUrl())\ndef set_offline_storage_path(self, path: datatypes.PathType):\nself.setOfflineStoragePath(os.fspath(path))\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngineMixin.get_object_ownership","title":"<code>get_object_ownership(obj: QtCore.QObject) -&gt; ObjectOwnershipStr</code>","text":"<p>Return object ownership.</p> <p>Returns:</p> Type Description <code>ObjectOwnershipStr</code> <p>object ownership</p> Source code in <code>prettyqt\\qml\\qmlengine.py</code> <pre><code>def get_object_ownership(self, obj: QtCore.QObject) -&gt; ObjectOwnershipStr:\n\"\"\"Return object ownership.\n    Returns:\n        object ownership\n    \"\"\"\nreturn OBJECT_OWNERSHIP.inverse[self.objectOwnership(obj)]\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngineMixin.set_object_ownership","title":"<code>set_object_ownership(obj: QtCore.QObject, mode: ObjectOwnershipStr | QtQml.QQmlEngine.ObjectOwnership)</code>","text":"<p>Set the object ownership.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>QtCore.QObject</code> <p>object to set ownership for</p> required <code>mode</code> <code>ObjectOwnershipStr | QtQml.QQmlEngine.ObjectOwnership</code> <p>object ownership to use</p> required Source code in <code>prettyqt\\qml\\qmlengine.py</code> <pre><code>def set_object_ownership(\nself,\nobj: QtCore.QObject,\nmode: ObjectOwnershipStr | QtQml.QQmlEngine.ObjectOwnership,\n):\n\"\"\"Set the object ownership.\n    Args:\n        obj: object to set ownership for\n        mode: object ownership to use\n    \"\"\"\nself.setObjectOwnership(obj, OBJECT_OWNERSHIP.get_enum_value(mode))\n</code></pre>"},{"location":"api/qthelp.html","title":"qthelp module","text":"<p>qthelp module.</p> <p>contains QtHelp-based classes</p>"},{"location":"api/quick.html","title":"quick module","text":"<p>quick module.</p> <p>contains QtQuick-based classes</p>"},{"location":"api/quick.html#prettyqt.quick.QuickItemMixin","title":"<code>QuickItemMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>qml.QmlParserStatusMixin</code></p> Source code in <code>prettyqt\\quick\\quickitem.py</code> <pre><code>class QuickItemMixin(core.ObjectMixin, qml.QmlParserStatusMixin):\ndef __getitem__(self, index: tuple[int, int]) -&gt; QtQuick.QQuickItem:\nreturn self.childAt(*index)\ndef __contains__(self, item: QtCore.QPointF):\nreturn self.contains(item)\ndef get_children_rect(self) -&gt; core.RectF:\nreturn core.RectF(self.childrenRect())\ndef get_cursor(self) -&gt; gui.Cursor:\nreturn gui.Cursor(self.cursor())\ndef get_flags(self):\npass\ndef set_transform_origin(\nself, origin: TransformOriginStr | QtQuick.QQuickItem.TransformOrigin\n):\n\"\"\"Set the origin point around which scale and rotation transform.\n        The default is \"center\".\n        Args:\n            origin: transform origin to use\n        \"\"\"\nself.setTransformOrigin(TRANSFORM_ORIGIN.get_enum_value(origin))\ndef get_transform_origin(self) -&gt; TransformOriginStr:\n\"\"\"Return the render type of text-like elements in Qt Quick.\n        Returns:\n            transform origin\n        \"\"\"\nreturn TRANSFORM_ORIGIN.inverse[self.transformOrigin()]\ndef set_size(self, size: QtCore.QSize | datatypes.SizeFType):\nself.setSize(datatypes.to_sizef(size))\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItemMixin.get_transform_origin","title":"<code>get_transform_origin() -&gt; TransformOriginStr</code>","text":"<p>Return the render type of text-like elements in Qt Quick.</p> <p>Returns:</p> Type Description <code>TransformOriginStr</code> <p>transform origin</p> Source code in <code>prettyqt\\quick\\quickitem.py</code> <pre><code>def get_transform_origin(self) -&gt; TransformOriginStr:\n\"\"\"Return the render type of text-like elements in Qt Quick.\n    Returns:\n        transform origin\n    \"\"\"\nreturn TRANSFORM_ORIGIN.inverse[self.transformOrigin()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItemMixin.set_transform_origin","title":"<code>set_transform_origin(origin: TransformOriginStr | QtQuick.QQuickItem.TransformOrigin)</code>","text":"<p>Set the origin point around which scale and rotation transform.</p> <p>The default is \"center\".</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>TransformOriginStr | QtQuick.QQuickItem.TransformOrigin</code> <p>transform origin to use</p> required Source code in <code>prettyqt\\quick\\quickitem.py</code> <pre><code>def set_transform_origin(\nself, origin: TransformOriginStr | QtQuick.QQuickItem.TransformOrigin\n):\n\"\"\"Set the origin point around which scale and rotation transform.\n    The default is \"center\".\n    Args:\n        origin: transform origin to use\n    \"\"\"\nself.setTransformOrigin(TRANSFORM_ORIGIN.get_enum_value(origin))\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.QuickPaintedItem","title":"<code>QuickPaintedItem</code>","text":"<p>         Bases: <code>quick.QuickItemMixin</code>, <code>QtQuick.QQuickPaintedItem</code></p> Source code in <code>prettyqt\\quick\\quickpainteditem.py</code> <pre><code>class QuickPaintedItem(quick.QuickItemMixin, QtQuick.QQuickPaintedItem):\ndef get_fill_color(self) -&gt; gui.Color:\nreturn gui.Color(self.fillColor())\ndef get_texture_size(self) -&gt; core.Size:\nreturn core.Size(self.textureSize())\ndef set_render_target(self, target: RenderTargetStr | mod.RenderTarget):\n\"\"\"Set the render target.\n        Args:\n            target: render target to use\n        \"\"\"\nself.setRenderTarget(RENDER_TARGET[target])\ndef get_render_target(self) -&gt; RenderTargetStr:\n\"\"\"Return the render target.\n        Returns:\n            render target\n        \"\"\"\nreturn RENDER_TARGET.inverse[self.renderTarget()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.get_render_target","title":"<code>get_render_target() -&gt; RenderTargetStr</code>","text":"<p>Return the render target.</p> <p>Returns:</p> Type Description <code>RenderTargetStr</code> <p>render target</p> Source code in <code>prettyqt\\quick\\quickpainteditem.py</code> <pre><code>def get_render_target(self) -&gt; RenderTargetStr:\n\"\"\"Return the render target.\n    Returns:\n        render target\n    \"\"\"\nreturn RENDER_TARGET.inverse[self.renderTarget()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.set_render_target","title":"<code>set_render_target(target: RenderTargetStr | mod.RenderTarget)</code>","text":"<p>Set the render target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>RenderTargetStr | mod.RenderTarget</code> <p>render target to use</p> required Source code in <code>prettyqt\\quick\\quickpainteditem.py</code> <pre><code>def set_render_target(self, target: RenderTargetStr | mod.RenderTarget):\n\"\"\"Set the render target.\n    Args:\n        target: render target to use\n    \"\"\"\nself.setRenderTarget(RENDER_TARGET[target])\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.SGNode","title":"<code>SGNode</code>","text":"<p>         Bases: <code>QtQuick.QSGNode</code></p> Source code in <code>prettyqt\\quick\\sgnode.py</code> <pre><code>class SGNode(QtQuick.QSGNode):\ndef __getitem__(self, index: int) -&gt; QtQuick.QSGNode:\nreturn self.childAtIndex(index)\ndef __delitem__(self, item: int | QtQuick.QSGNode):\nif isinstance(item, int):\nitem = self.childAtIndex(item)\nself.removeChildNode(item)\ndef get_type(self) -&gt; NodeTypeStr:\n\"\"\"Get the type of the node.\n        Returns:\n            Node type\n        \"\"\"\nreturn NODE_TYPE.inverse[self.type()]\ndef get_flags(self) -&gt; list[FlagStr]:\nreturn FLAG.get_list(self.flags())\ndef get_children(self, recursive: bool = False) -&gt; list[SGNode]:\n\"\"\"Get children of this item.\n        recursive option is written iteratively to also support original QTreeWidgetItems.\n        \"\"\"\nif not recursive:\nreturn [self.childAtIndex(i) for i in range(self.childCount())]\nresults = []\nnodes = [self]\nwhile nodes:\nitems = []\nfor node in nodes:\nresults.append(node)\nitems.extend(node.childAtIndex(i) for i in range(node.childCount()))\nnodes = items\nreturn results[1:]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.sgnode.SGNode.get_children","title":"<code>get_children(recursive: bool = False) -&gt; list[SGNode]</code>","text":"<p>Get children of this item.</p> <p>recursive option is written iteratively to also support original QTreeWidgetItems.</p> Source code in <code>prettyqt\\quick\\sgnode.py</code> <pre><code>def get_children(self, recursive: bool = False) -&gt; list[SGNode]:\n\"\"\"Get children of this item.\n    recursive option is written iteratively to also support original QTreeWidgetItems.\n    \"\"\"\nif not recursive:\nreturn [self.childAtIndex(i) for i in range(self.childCount())]\nresults = []\nnodes = [self]\nwhile nodes:\nitems = []\nfor node in nodes:\nresults.append(node)\nitems.extend(node.childAtIndex(i) for i in range(node.childCount()))\nnodes = items\nreturn results[1:]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.sgnode.SGNode.get_type","title":"<code>get_type() -&gt; NodeTypeStr</code>","text":"<p>Get the type of the node.</p> <p>Returns:</p> Type Description <code>NodeTypeStr</code> <p>Node type</p> Source code in <code>prettyqt\\quick\\sgnode.py</code> <pre><code>def get_type(self) -&gt; NodeTypeStr:\n\"\"\"Get the type of the node.\n    Returns:\n        Node type\n    \"\"\"\nreturn NODE_TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/quickwidgets.html","title":"quickwidgets module","text":"<p>quick module.</p> <p>contains QtQuickWidgets-based classes</p>"},{"location":"api/svg.html","title":"svg module","text":"<p>svg module.</p> <p>contains QtSvg-based classes</p>"},{"location":"api/svg.html#prettyqt.svg.SvgRenderer","title":"<code>SvgRenderer</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtSvg.QSvgRenderer</code></p> Source code in <code>prettyqt\\svg\\svgrenderer.py</code> <pre><code>class SvgRenderer(core.ObjectMixin, QtSvg.QSvgRenderer):\ndef load_file(self, path: datatypes.PathType):\nresult = self.load(os.fspath(path))\nif not result:\nraise ValueError(\"invalid path\")\ndef set_aspect_ratio_mode(\nself, mode: constants.AspectRatioModeStr | constants.AspectRatioMode\n):\n\"\"\"Set the aspect ratio mode.\n        Args:\n            mode: aspect ratio mode\n        \"\"\"\nself.setAspectRatioMode(constants.ASPECT_RATIO_MODE.get_enum_value(mode))\ndef get_aspect_ratio_mode(self) -&gt; constants.AspectRatioModeStr:\n\"\"\"Return current aspect ratio mode.\n        Returns:\n            aspect ratio mode\n        \"\"\"\nreturn constants.ASPECT_RATIO_MODE.inverse[self.aspectRatioMode()]\n</code></pre>"},{"location":"api/svg.html#prettyqt.svg.svgrenderer.SvgRenderer.get_aspect_ratio_mode","title":"<code>get_aspect_ratio_mode() -&gt; constants.AspectRatioModeStr</code>","text":"<p>Return current aspect ratio mode.</p> <p>Returns:</p> Type Description <code>constants.AspectRatioModeStr</code> <p>aspect ratio mode</p> Source code in <code>prettyqt\\svg\\svgrenderer.py</code> <pre><code>def get_aspect_ratio_mode(self) -&gt; constants.AspectRatioModeStr:\n\"\"\"Return current aspect ratio mode.\n    Returns:\n        aspect ratio mode\n    \"\"\"\nreturn constants.ASPECT_RATIO_MODE.inverse[self.aspectRatioMode()]\n</code></pre>"},{"location":"api/svg.html#prettyqt.svg.svgrenderer.SvgRenderer.set_aspect_ratio_mode","title":"<code>set_aspect_ratio_mode(mode: constants.AspectRatioModeStr | constants.AspectRatioMode)</code>","text":"<p>Set the aspect ratio mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.AspectRatioModeStr | constants.AspectRatioMode</code> <p>aspect ratio mode</p> required Source code in <code>prettyqt\\svg\\svgrenderer.py</code> <pre><code>def set_aspect_ratio_mode(\nself, mode: constants.AspectRatioModeStr | constants.AspectRatioMode\n):\n\"\"\"Set the aspect ratio mode.\n    Args:\n        mode: aspect ratio mode\n    \"\"\"\nself.setAspectRatioMode(constants.ASPECT_RATIO_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/syntaxhighlighters.html","title":"syntaxhighlighters module","text":"<p>syntaxhighlighters module.</p> <p>contains some custom syntax highlighers</p>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.JsonHighlighter","title":"<code>JsonHighlighter</code>","text":"<p>         Bases: <code>gui.SyntaxHighlighter</code></p> Source code in <code>prettyqt\\syntaxhighlighters\\jsonhighlighter.py</code> <pre><code>class JsonHighlighter(gui.SyntaxHighlighter):\ndef highlightBlock(self, text: str):\n\"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\"\nfor m in BRACKETS.finditer(text):\nself.setFormat(m.span()[0], m.span()[1] - m.span()[0], SYMBOL_FORMAT)\ntext.replace('\\\\\"', \"  \")\nfor m in REGEXP1.finditer(text):\nself.setFormat(m.span()[0], m.span()[1] - m.span()[0], NAME_FORMAT)\nfor m in REGEXP2.finditer(text):\nself.setFormat(m.span()[0], m.span()[1] - m.span()[0], VALUE_FORMAT)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter.highlightBlock","title":"<code>highlightBlock(text: str)</code>","text":"<p>Highlight a block of code using the rules outlined in the Constructor.</p> Source code in <code>prettyqt\\syntaxhighlighters\\jsonhighlighter.py</code> <pre><code>def highlightBlock(self, text: str):\n\"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\"\nfor m in BRACKETS.finditer(text):\nself.setFormat(m.span()[0], m.span()[1] - m.span()[0], SYMBOL_FORMAT)\ntext.replace('\\\\\"', \"  \")\nfor m in REGEXP1.finditer(text):\nself.setFormat(m.span()[0], m.span()[1] - m.span()[0], NAME_FORMAT)\nfor m in REGEXP2.finditer(text):\nself.setFormat(m.span()[0], m.span()[1] - m.span()[0], VALUE_FORMAT)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.PygmentsHighlighter","title":"<code>PygmentsHighlighter</code>","text":"<p>         Bases: <code>gui.SyntaxHighlighter</code></p> <p>Syntax highlighter that uses Pygments for parsing.</p> Source code in <code>prettyqt\\syntaxhighlighters\\pygmentshighlighter.py</code> <pre><code>class PygmentsHighlighter(gui.SyntaxHighlighter):\n\"\"\"Syntax highlighter that uses Pygments for parsing.\"\"\"\n# ---------------------------------------------------------------------------\n#  \"QSyntaxHighlighter\" interface\n# ---------------------------------------------------------------------------\ndef __init__(\nself,\nparent: QtGui.QTextDocument,\nlexer: str,\nstyle: None | StyleStr = None,\n):\nsuper().__init__(parent)\nself._document = self.document()\nself._formatter = html.HtmlFormatter(nowrap=True)\nself._style = None\nself._stylename = \"\"\nif style is None:\ngui.GuiApplication.styleHints().colorSchemeChanged.connect(\nself.adjust_style_to_palette\n)\nself.set_style(style)\nif lexer == \"regex\":\nself._lexer = lexers.load_lexer_from_file(str(paths.RE_LEXER_PATH))\nelse:\nself._lexer = lexers.get_lexer_by_name(lexer)\ndef __repr__(self):\nreturn get_repr(self, lexer=self._lexer.aliases[0])\ndef highlightBlock(self, string):\n\"\"\"Highlight a block of text.\"\"\"\nif (prev_data := self.currentBlock().previous().userData()) is not None:\nself._lexer._saved_state_stack = prev_data.syntax_stack\nelif hasattr(self._lexer, \"_saved_state_stack\"):\ndel self._lexer._saved_state_stack\n# Lex the text using Pygments\nindex = 0\nfor token, text in self._lexer.get_tokens(string):\nlength = qstring_length(text)\nself.setFormat(index, length, self._get_format(token))\nindex += length\nif hasattr(self._lexer, \"_saved_state_stack\"):\ndata = gui.TextBlockUserData(syntax_stack=self._lexer._saved_state_stack)\nself.currentBlock().setUserData(data)\n# Clean up for the next go-round.\ndel self._lexer._saved_state_stack\n# ---------------------------------------------------------------------------\n# \"PygmentsHighlighter\" interface\n# ---------------------------------------------------------------------------\ndef set_style(self, style: None | StyleStr):\nmatch style:\ncase None:\nself.adjust_style_to_palette()\nreturn\ncase str():\nself._style = styles.get_style_by_name(style)\nself._stylename = style\ncase _:\nraise TypeError(style)\nself._clear_caches()\ndef get_style(self) -&gt; StyleStr:\nreturn self._stylename\ndef adjust_style_to_palette(self):\npal = gui.GuiApplication.get_palette()\nstyle = \"monokai\" if pal.is_dark() else \"default\"\nself.set_style(style)\ndef set_style_sheet(self, stylesheet: str):\n\"\"\"Sets a CSS stylesheet.\n        The classes in the stylesheet should correspond to those generated by:\n            pygmentize -S &lt;style&gt; -f html\n        Note that \"set_style\" and \"set_style_sheet\" completely override each\n        other, i.e. they cannot be used in conjunction.\n        \"\"\"\nself._document.setDefaultStyleSheet(stylesheet)\nself._style = None\nself._clear_caches()\n# ---------------------------------------------------------------------------\n# Protected interface\n# ---------------------------------------------------------------------------\ndef _clear_caches(self):\n\"\"\"Clear caches for brushes and formats.\"\"\"\n_get_brush.cache_clear()\nself._get_format.cache_clear()\n@functools.cache  # noqa: B019\ndef _get_format(self, token: str) -&gt; QtGui.QTextCharFormat:\n\"\"\"Returns a QTextCharFormat for token or None.\"\"\"\nif self._style is None:\nreturn self._get_format_from_document(token, self._document)\nelse:\nreturn _get_format_from_style(token, self._style)\ndef _get_format_from_document(\nself, token: str, document: QtGui.QTextDocument\n) -&gt; QtGui.QTextCharFormat:\n\"\"\"Return a QTextCharFormat for token from document.\"\"\"\n_, html = next(self._formatter._format_lines([(token, \"dummy\")]))\ndocument.setHtml(html)\nreturn gui.TextCursor(document).charFormat()\nstyle = core.Property(str, get_style, set_style)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.highlightBlock","title":"<code>highlightBlock(string)</code>","text":"<p>Highlight a block of text.</p> Source code in <code>prettyqt\\syntaxhighlighters\\pygmentshighlighter.py</code> <pre><code>def highlightBlock(self, string):\n\"\"\"Highlight a block of text.\"\"\"\nif (prev_data := self.currentBlock().previous().userData()) is not None:\nself._lexer._saved_state_stack = prev_data.syntax_stack\nelif hasattr(self._lexer, \"_saved_state_stack\"):\ndel self._lexer._saved_state_stack\n# Lex the text using Pygments\nindex = 0\nfor token, text in self._lexer.get_tokens(string):\nlength = qstring_length(text)\nself.setFormat(index, length, self._get_format(token))\nindex += length\nif hasattr(self._lexer, \"_saved_state_stack\"):\ndata = gui.TextBlockUserData(syntax_stack=self._lexer._saved_state_stack)\nself.currentBlock().setUserData(data)\n# Clean up for the next go-round.\ndel self._lexer._saved_state_stack\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style_sheet","title":"<code>set_style_sheet(stylesheet: str)</code>","text":"<p>Sets a CSS stylesheet.</p> The classes in the stylesheet should correspond to those generated by <p>pygmentize -S"},{"location":"api/texttospeech.html","title":"texttospeech module","text":"<p>TextToSpeech module.</p> <p>Contains QtTextToSpeech-based classes</p>"},{"location":"api/webenginecore.html","title":"webenginecore module","text":"<p>Webenginewidgets module.</p> <p>contains QtWebEngineCore-based classes</p>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineContextMenuRequest","title":"<code>WebEngineContextMenuRequest</code>","text":"<p>         Bases: <code>QtWebEngineCore.QWebEngineContextMenuRequest</code></p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>class WebEngineContextMenuRequest(QtWebEngineCore.QWebEngineContextMenuRequest):\ndef get_media_url(self) -&gt; core.Url:\nreturn core.Url(self.mediaUrl())\ndef get_link_url(self) -&gt; core.Url:\nreturn core.Url(self.linkUrl())\ndef get_media_type(self) -&gt; MediaTypeStr:\n\"\"\"Get media type.\"\"\"\nreturn MEDIA_TYPES.inverse[self.mediaType()]\ndef get_media_flags(self) -&gt; list[MediaFlagStr]:\n\"\"\"Get media flags.\"\"\"\nreturn MEDIA_FLAGS.get_list(self.mediaFlags())\ndef get_edit_flags(self) -&gt; list[MediaFlagStr]:\n\"\"\"Get edit flags.\"\"\"\nreturn EDIT_FLAGS.get_list(self.editFlags())\ndef can_undo(self) -&gt; bool:\n\"\"\"Returns whether undo is possible.\"\"\"\nreturn bool(mod.EditFlag.CanUndo &amp; self.editFlags())\ndef can_redo(self) -&gt; bool:\n\"\"\"Returns whether redo is possible.\"\"\"\nreturn bool(mod.EditFlag.CanRedo &amp; self.editFlags())\ndef can_cut(self) -&gt; bool:\n\"\"\"Returns whether cut is possible.\"\"\"\nreturn bool(mod.EditFlag.CanCut &amp; self.editFlags())\ndef can_copy(self) -&gt; bool:\n\"\"\"Returns whether copy is possible.\"\"\"\nreturn bool(mod.EditFlag.CanCopy &amp; self.editFlags())\ndef can_paste(self) -&gt; bool:\n\"\"\"Returns whether paste is possible.\"\"\"\nreturn bool(mod.EditFlag.CanPaste &amp; self.editFlags())\ndef can_delete(self) -&gt; bool:\n\"\"\"Returns whether delete is possible.\"\"\"\nreturn bool(mod.EditFlag.CanDelete &amp; self.editFlags())\ndef can_select_all(self) -&gt; bool:\n\"\"\"Returns whether select_all is possible.\"\"\"\nreturn bool(mod.EditFlag.CanSelectAll &amp; self.editFlags())\ndef can_translate(self) -&gt; bool:\n\"\"\"Returns whether translate is possible.\"\"\"\nreturn bool(mod.EditFlag.CanTranslate &amp; self.editFlags())\ndef can_edit_richly(self) -&gt; bool:\n\"\"\"Returns whether edit_richly is possible.\"\"\"\nreturn bool(mod.EditFlag.CanEditRichly &amp; self.editFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.can_copy","title":"<code>can_copy() -&gt; bool</code>","text":"<p>Returns whether copy is possible.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def can_copy(self) -&gt; bool:\n\"\"\"Returns whether copy is possible.\"\"\"\nreturn bool(mod.EditFlag.CanCopy &amp; self.editFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.can_cut","title":"<code>can_cut() -&gt; bool</code>","text":"<p>Returns whether cut is possible.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def can_cut(self) -&gt; bool:\n\"\"\"Returns whether cut is possible.\"\"\"\nreturn bool(mod.EditFlag.CanCut &amp; self.editFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.can_delete","title":"<code>can_delete() -&gt; bool</code>","text":"<p>Returns whether delete is possible.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def can_delete(self) -&gt; bool:\n\"\"\"Returns whether delete is possible.\"\"\"\nreturn bool(mod.EditFlag.CanDelete &amp; self.editFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.can_edit_richly","title":"<code>can_edit_richly() -&gt; bool</code>","text":"<p>Returns whether edit_richly is possible.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def can_edit_richly(self) -&gt; bool:\n\"\"\"Returns whether edit_richly is possible.\"\"\"\nreturn bool(mod.EditFlag.CanEditRichly &amp; self.editFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.can_paste","title":"<code>can_paste() -&gt; bool</code>","text":"<p>Returns whether paste is possible.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def can_paste(self) -&gt; bool:\n\"\"\"Returns whether paste is possible.\"\"\"\nreturn bool(mod.EditFlag.CanPaste &amp; self.editFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.can_redo","title":"<code>can_redo() -&gt; bool</code>","text":"<p>Returns whether redo is possible.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def can_redo(self) -&gt; bool:\n\"\"\"Returns whether redo is possible.\"\"\"\nreturn bool(mod.EditFlag.CanRedo &amp; self.editFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.can_select_all","title":"<code>can_select_all() -&gt; bool</code>","text":"<p>Returns whether select_all is possible.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def can_select_all(self) -&gt; bool:\n\"\"\"Returns whether select_all is possible.\"\"\"\nreturn bool(mod.EditFlag.CanSelectAll &amp; self.editFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.can_translate","title":"<code>can_translate() -&gt; bool</code>","text":"<p>Returns whether translate is possible.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def can_translate(self) -&gt; bool:\n\"\"\"Returns whether translate is possible.\"\"\"\nreturn bool(mod.EditFlag.CanTranslate &amp; self.editFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.can_undo","title":"<code>can_undo() -&gt; bool</code>","text":"<p>Returns whether undo is possible.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def can_undo(self) -&gt; bool:\n\"\"\"Returns whether undo is possible.\"\"\"\nreturn bool(mod.EditFlag.CanUndo &amp; self.editFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.get_edit_flags","title":"<code>get_edit_flags() -&gt; list[MediaFlagStr]</code>","text":"<p>Get edit flags.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def get_edit_flags(self) -&gt; list[MediaFlagStr]:\n\"\"\"Get edit flags.\"\"\"\nreturn EDIT_FLAGS.get_list(self.editFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.get_media_flags","title":"<code>get_media_flags() -&gt; list[MediaFlagStr]</code>","text":"<p>Get media flags.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def get_media_flags(self) -&gt; list[MediaFlagStr]:\n\"\"\"Get media flags.\"\"\"\nreturn MEDIA_FLAGS.get_list(self.mediaFlags())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginecontextmenurequest.WebEngineContextMenuRequest.get_media_type","title":"<code>get_media_type() -&gt; MediaTypeStr</code>","text":"<p>Get media type.</p> Source code in <code>prettyqt\\webenginecore\\webenginecontextmenurequest.py</code> <pre><code>def get_media_type(self) -&gt; MediaTypeStr:\n\"\"\"Get media type.\"\"\"\nreturn MEDIA_TYPES.inverse[self.mediaType()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineDownloadRequest","title":"<code>WebEngineDownloadRequest</code>","text":"Source code in <code>prettyqt\\webenginecore\\webenginedownloadrequest.py</code> <pre><code>class WebEngineDownloadRequest:\ndef __init__(self, item: QtWebEngineCore.QWebEngineDownloadRequest):\nself.item = item\ndef __getattr__(self, val):\nreturn getattr(self.item, val)\ndef get_interrupt_reason(self) -&gt; DownloadInterruptReasonStr:\n\"\"\"Get reason for download interruption.\"\"\"\nreturn DOWNLOAD_INTERRUPT_REASONS.inverse[self.item.interruptReason()]\ndef get_state(self) -&gt; DownloadStateStr:\n\"\"\"Get current state.\"\"\"\nreturn DOWNLOAD_STATE.inverse[self.item.state()]\ndef set_save_page_format(self, fmt: SavePageFormatStr | Item.SavePageFormat):\n\"\"\"Set the save page format.\n        Args:\n            fmt: save page format for the layout\n        \"\"\"\nself.item.setSavePageFormat(SAVE_PAGE_FORMAT.get_enum_value(fmt))\ndef get_save_page_format(self) -&gt; SavePageFormatStr:\n\"\"\"Return current save page format.\n        Returns:\n            Save page format\n        \"\"\"\nreturn SAVE_PAGE_FORMAT.inverse[self.item.savePageFormat()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest.get_interrupt_reason","title":"<code>get_interrupt_reason() -&gt; DownloadInterruptReasonStr</code>","text":"<p>Get reason for download interruption.</p> Source code in <code>prettyqt\\webenginecore\\webenginedownloadrequest.py</code> <pre><code>def get_interrupt_reason(self) -&gt; DownloadInterruptReasonStr:\n\"\"\"Get reason for download interruption.\"\"\"\nreturn DOWNLOAD_INTERRUPT_REASONS.inverse[self.item.interruptReason()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest.get_save_page_format","title":"<code>get_save_page_format() -&gt; SavePageFormatStr</code>","text":"<p>Return current save page format.</p> <p>Returns:</p> Type Description <code>SavePageFormatStr</code> <p>Save page format</p> Source code in <code>prettyqt\\webenginecore\\webenginedownloadrequest.py</code> <pre><code>def get_save_page_format(self) -&gt; SavePageFormatStr:\n\"\"\"Return current save page format.\n    Returns:\n        Save page format\n    \"\"\"\nreturn SAVE_PAGE_FORMAT.inverse[self.item.savePageFormat()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest.get_state","title":"<code>get_state() -&gt; DownloadStateStr</code>","text":"<p>Get current state.</p> Source code in <code>prettyqt\\webenginecore\\webenginedownloadrequest.py</code> <pre><code>def get_state(self) -&gt; DownloadStateStr:\n\"\"\"Get current state.\"\"\"\nreturn DOWNLOAD_STATE.inverse[self.item.state()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest.set_save_page_format","title":"<code>set_save_page_format(fmt: SavePageFormatStr | Item.SavePageFormat)</code>","text":"<p>Set the save page format.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>SavePageFormatStr | Item.SavePageFormat</code> <p>save page format for the layout</p> required Source code in <code>prettyqt\\webenginecore\\webenginedownloadrequest.py</code> <pre><code>def set_save_page_format(self, fmt: SavePageFormatStr | Item.SavePageFormat):\n\"\"\"Set the save page format.\n    Args:\n        fmt: save page format for the layout\n    \"\"\"\nself.item.setSavePageFormat(SAVE_PAGE_FORMAT.get_enum_value(fmt))\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineHistory","title":"<code>WebEngineHistory</code>","text":"Source code in <code>prettyqt\\webenginecore\\webenginehistory.py</code> <pre><code>class WebEngineHistory:\ndef __init__(self, history: QtWebEngineCore.QWebEngineHistory):\nself.history = history\ndef __getattr__(self, val):\nreturn getattr(self.history, val)\ndef __len__(self):\n# pyside2 does not support len(self.history)\nreturn self.history.count()\ndef __getitem__(self, index: int) -&gt; webenginecore.WebEngineHistoryItem:\nitem = self.history.itemAt(index)\nreturn webenginecore.WebEngineHistoryItem(item)\ndef __iter__(self) -&gt; Iterator[webenginecore.WebEngineHistoryItem]:\nitems = [webenginecore.WebEngineHistoryItem(i) for i in self.history.items()]\nreturn iter(items)\ndef get_items(self) -&gt; list[webenginecore.WebEngineHistoryItem]:\n\"\"\"Get history items.\"\"\"\nreturn [webenginecore.WebEngineHistoryItem(i) for i in self.history.items()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehistory.WebEngineHistory.get_items","title":"<code>get_items() -&gt; list[webenginecore.WebEngineHistoryItem]</code>","text":"<p>Get history items.</p> Source code in <code>prettyqt\\webenginecore\\webenginehistory.py</code> <pre><code>def get_items(self) -&gt; list[webenginecore.WebEngineHistoryItem]:\n\"\"\"Get history items.\"\"\"\nreturn [webenginecore.WebEngineHistoryItem(i) for i in self.history.items()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineHttpRequest","title":"<code>WebEngineHttpRequest</code>","text":"<p>         Bases: <code>QtWebEngineCore.QWebEngineHttpRequest</code></p> Source code in <code>prettyqt\\webenginecore\\webenginehttprequest.py</code> <pre><code>class WebEngineHttpRequest(QtWebEngineCore.QWebEngineHttpRequest):\ndef __repr__(self):\nreturn f\"{type(self).__name__}({self.get_url()})\"\ndef set_headers(self, headers: dict[str, str]):\nfor k, v in headers.items():\nself.setHeader(QtCore.QByteArray(k.encode()), QtCore.QByteArray(v.encode()))\ndef get_headers(self) -&gt; dict[str, str]:\nreturn {h.data().decode(): self.header(h).data().decode() for h in self.headers()}\ndef set_url(self, url: datatypes.UrlType):\nurl = core.Url(url)\nself.setUrl(url)\ndef get_url(self) -&gt; core.Url:\nreturn core.Url(self.url())\ndef get_post_data(self) -&gt; str:\nreturn self.postData().data().decode()\ndef set_method(\nself, method: MethodStr | QtWebEngineCore.QWebEngineHttpRequest.Method\n):\n\"\"\"Set method this WebEngine request is using.\n        Args:\n            method: method\n        \"\"\"\nself.setMethod(METHODS.get_enum_value(method))\ndef get_method(self) -&gt; MethodStr:\n\"\"\"Get the method this WebEngine request is using.\n        Returns:\n            method\n        \"\"\"\nreturn METHODS.inverse[self.method()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.get_method","title":"<code>get_method() -&gt; MethodStr</code>","text":"<p>Get the method this WebEngine request is using.</p> <p>Returns:</p> Type Description <code>MethodStr</code> <p>method</p> Source code in <code>prettyqt\\webenginecore\\webenginehttprequest.py</code> <pre><code>def get_method(self) -&gt; MethodStr:\n\"\"\"Get the method this WebEngine request is using.\n    Returns:\n        method\n    \"\"\"\nreturn METHODS.inverse[self.method()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.set_method","title":"<code>set_method(method: MethodStr | QtWebEngineCore.QWebEngineHttpRequest.Method)</code>","text":"<p>Set method this WebEngine request is using.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>MethodStr | QtWebEngineCore.QWebEngineHttpRequest.Method</code> <p>method</p> required Source code in <code>prettyqt\\webenginecore\\webenginehttprequest.py</code> <pre><code>def set_method(\nself, method: MethodStr | QtWebEngineCore.QWebEngineHttpRequest.Method\n):\n\"\"\"Set method this WebEngine request is using.\n    Args:\n        method: method\n    \"\"\"\nself.setMethod(METHODS.get_enum_value(method))\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEnginePage","title":"<code>WebEnginePage</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtWebEngineCore.QWebEnginePage</code></p> <p>A web engine page holds the HTML document contents, link history + actions.</p> Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>class WebEnginePage(core.ObjectMixin, QtWebEngineCore.QWebEnginePage):\n\"\"\"A web engine page holds the HTML document contents, link history + actions.\"\"\"\ndef get_icon(self) -&gt; gui.Icon | None:\nicon = self.icon()\nreturn None if icon.isNull() else gui.Icon(icon)\ndef set_url(self, url: datatypes.PathType | datatypes.UrlType):\n\"\"\"Set the url of the WebEnginePage.\n        Clears the Page and loads the URL.\n        Args:\n            url: URL to set\n        \"\"\"\nself.setUrl(datatypes.to_url(url))\ndef get_url(self) -&gt; core.Url:\nreturn core.Url(self.url())\ndef get_icon_url(self) -&gt; core.Url:\nreturn core.Url(self.iconUrl())\ndef get_requested_url(self) -&gt; core.Url:\nreturn core.Url(self.requestedUrl())\ndef get_scroll_position(self) -&gt; core.PointF:\nreturn core.PointF(self.scrollPosition())\ndef get_contents_size(self) -&gt; core.SizeF:\nreturn core.SizeF(self.contentsSize())\ndef load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n        Loads the specified url and displays it.\n        Note: The Page remains the same until enough data has arrived\n        to display the new URL.\n        Args:\n            url: URL to load\n        \"\"\"\nself.load(datatypes.to_url(url))\ndef set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the Page.\n        Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n        Args:\n            zoom: Zoom factor\n        \"\"\"\nself.setZoomFactor(zoom)\ndef find_text(\nself,\nstring: str,\nbackward: bool = False,\ncase_sensitive: bool = False,\ncallback: Callable[[bool], None] | None = None,\n):\n\"\"\"Find text in the current page.\n        Finds the specified string, subString, in the page, using the given options.\n        The findTextFinished() signal is emitted when a string search is completed.\n        To clear the search highlight, just pass an empty string.\n        The resultCallback must take a boolean parameter.\n        It will be called with a value of true if the subString was found;\n        otherwise the callback value will be false.\n        Warning: It is guaranteed that the callback is always called,\n        but it might be done during page destruction. When WebEnginePage is deleted,\n        the callback is triggered with an invalid value and it is not safe to use\n        the corresponding QWebEnginePage or QWebEnginePage instance inside it.\n        Args:\n            string: string to search for\n            backward: search backwards\n            case_sensitive: case-sensitive search\n            callback: result callback\n        \"\"\"\nif callback is None:\ndef do_nothing(x):\npass\ncallback = do_nothing\nflag = QtWebEngineCore.QWebEnginePage.FindFlag(0)\nif case_sensitive:\nflag |= self.FindFlag.FindCaseSensitively\nif backward:\nflag |= self.FindFlag.FindBackward\nself.findText(string, flag, callback)\ndef set_lifecycle_state(self, state: LifecycleStateStr | mod.LifecycleState):\n\"\"\"Set lifecycle state.\n        Args:\n            state: lifecycle state\n        \"\"\"\nself.setLifecycleState(LIFECYCLE_STATE.get_enum_value(state))\ndef get_lifecycle_state(self) -&gt; LifecycleStateStr:\n\"\"\"Get the current lifecycle state.\n        Returns:\n            lifecycle state\n        \"\"\"\nreturn LIFECYCLE_STATE.inverse[self.lifecycleState()]\ndef trigger_action(self, action: WebActionStr | mod.WebAction, checked: bool = False):\nself.triggerAction(WEB_ACTION.get_enum_value(action), checked)\ndef set_feature_permission(\nself,\nurl: datatypes.UrlType,\nfeature: FeatureStr | mod.Feature,\npolicy: PermissionPolicyStr | mod.PermissionPolicy,\n):\nurl = core.Url(url)\nself.setFeaturePermission(\nurl, FEATURE.get_enum_value(feature), PERMISSION_POLICY.get_enum_value(policy)\n)\ndef get_history(self) -&gt; webenginecore.WebEngineHistory:\nhist = self.history()\nreturn webenginecore.WebEngineHistory(hist)\ndef get_settings(self) -&gt; webenginecore.WebEngineSettings:\nsettings = self.settings()\nreturn webenginecore.WebEngineSettings(settings)\ndef set_setting(\nself,\nsetting_name: webenginecore.webenginesettings.WebAttributeStr,\nvalue: bool,\n):\nself.get_settings()[setting_name] = value\ndef get_setting(\nself,\nsetting_name: webenginecore.webenginesettings.WebAttributeStr,\n) -&gt; bool:\nreturn self.get_settings()[setting_name]\ndef get_scripts(self) -&gt; webenginecore.WebEngineScriptCollection:\nreturn webenginecore.WebEngineScriptCollection(self.scripts())\ndef open_in_browser(self):\ntry:\nwebbrowser.open(self.getUrl().toString())\nexcept ValueError as e:\nlogger.exception(e)\n# def choose_files(\n#     self,\n#     mode: FileSelectionModeStr,\n#     old_files: List[str],\n#     mimetypes: List[str],\n# ) -&gt; List[str]:\n#     return self.chooseFiles(FILE_SELECTION_MODE[mode], old_files, mimetypes)\ndef mousedown(self, selector: str, btn: int = 0):\n\"\"\"Simulate a mousedown event on the targeted element.\n        :param selector: A CSS3 selector to targeted element.\n        :param btn: The number of mouse button.\n            0 - left button,\n            1 - middle button,\n            2 - right button\n        \"\"\"\nreturn self.runJavaScript(\nf\"\"\"\n            (function () {{\n                var element = document.querySelector({selector!r});\n                var evt = document.createEvent(\"MouseEvents\");\n                evt.initMouseEvent(\"mousedown\", true, true, window,\n                                   1, 1, 1, 1, 1, false, false, false, false,\n{btn!r}, element);\n                return element.dispatchEvent(evt);\n}})();\n        \"\"\"\n)\ndef set_input_value(self, selector: str, value):\n\"\"\"Set the value of the input matched by given selector.\"\"\"\nscript = f'document.querySelector({selector!r}).setAttribute(\"value\", \"{value}\")'\nself.runJavaScript(script)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.find_text","title":"<code>find_text(string: str, backward: bool = False, case_sensitive: bool = False, callback: Callable[[bool], None] | None = None)</code>","text":"<p>Find text in the current page.</p> <p>Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed.</p> <p>To clear the search highlight, just pass an empty string.</p> <p>The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false.</p> <p>Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>string to search for</p> required <code>backward</code> <code>bool</code> <p>search backwards</p> <code>False</code> <code>case_sensitive</code> <code>bool</code> <p>case-sensitive search</p> <code>False</code> <code>callback</code> <code>Callable[[bool], None] | None</code> <p>result callback</p> <code>None</code> Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def find_text(\nself,\nstring: str,\nbackward: bool = False,\ncase_sensitive: bool = False,\ncallback: Callable[[bool], None] | None = None,\n):\n\"\"\"Find text in the current page.\n    Finds the specified string, subString, in the page, using the given options.\n    The findTextFinished() signal is emitted when a string search is completed.\n    To clear the search highlight, just pass an empty string.\n    The resultCallback must take a boolean parameter.\n    It will be called with a value of true if the subString was found;\n    otherwise the callback value will be false.\n    Warning: It is guaranteed that the callback is always called,\n    but it might be done during page destruction. When WebEnginePage is deleted,\n    the callback is triggered with an invalid value and it is not safe to use\n    the corresponding QWebEnginePage or QWebEnginePage instance inside it.\n    Args:\n        string: string to search for\n        backward: search backwards\n        case_sensitive: case-sensitive search\n        callback: result callback\n    \"\"\"\nif callback is None:\ndef do_nothing(x):\npass\ncallback = do_nothing\nflag = QtWebEngineCore.QWebEnginePage.FindFlag(0)\nif case_sensitive:\nflag |= self.FindFlag.FindCaseSensitively\nif backward:\nflag |= self.FindFlag.FindBackward\nself.findText(string, flag, callback)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.get_lifecycle_state","title":"<code>get_lifecycle_state() -&gt; LifecycleStateStr</code>","text":"<p>Get the current lifecycle state.</p> <p>Returns:</p> Type Description <code>LifecycleStateStr</code> <p>lifecycle state</p> Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def get_lifecycle_state(self) -&gt; LifecycleStateStr:\n\"\"\"Get the current lifecycle state.\n    Returns:\n        lifecycle state\n    \"\"\"\nreturn LIFECYCLE_STATE.inverse[self.lifecycleState()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.load_url","title":"<code>load_url(url: datatypes.UrlType | datatypes.PathType)</code>","text":"<p>Load the URL.</p> <p>Loads the specified url and displays it.</p> <p>Note: The Page remains the same until enough data has arrived to display the new URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.UrlType | datatypes.PathType</code> <p>URL to load</p> required Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n    Loads the specified url and displays it.\n    Note: The Page remains the same until enough data has arrived\n    to display the new URL.\n    Args:\n        url: URL to load\n    \"\"\"\nself.load(datatypes.to_url(url))\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.mousedown","title":"<code>mousedown(selector: str, btn: int = 0)</code>","text":"<p>Simulate a mousedown event on the targeted element.</p> <p>:param selector: A CSS3 selector to targeted element. :param btn: The number of mouse button.     0 - left button,     1 - middle button,     2 - right button</p> Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def mousedown(self, selector: str, btn: int = 0):\n\"\"\"Simulate a mousedown event on the targeted element.\n    :param selector: A CSS3 selector to targeted element.\n    :param btn: The number of mouse button.\n        0 - left button,\n        1 - middle button,\n        2 - right button\n    \"\"\"\nreturn self.runJavaScript(\nf\"\"\"\n        (function () {{\n            var element = document.querySelector({selector!r});\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"mousedown\", true, true, window,\n                               1, 1, 1, 1, 1, false, false, false, false,\n{btn!r}, element);\n            return element.dispatchEvent(evt);\n}})();\n    \"\"\"\n)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_input_value","title":"<code>set_input_value(selector: str, value: str)</code>","text":"<p>Set the value of the input matched by given selector.</p> Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def set_input_value(self, selector: str, value):\n\"\"\"Set the value of the input matched by given selector.\"\"\"\nscript = f'document.querySelector({selector!r}).setAttribute(\"value\", \"{value}\")'\nself.runJavaScript(script)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_lifecycle_state","title":"<code>set_lifecycle_state(state: LifecycleStateStr | mod.LifecycleState)</code>","text":"<p>Set lifecycle state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>LifecycleStateStr | mod.LifecycleState</code> <p>lifecycle state</p> required Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def set_lifecycle_state(self, state: LifecycleStateStr | mod.LifecycleState):\n\"\"\"Set lifecycle state.\n    Args:\n        state: lifecycle state\n    \"\"\"\nself.setLifecycleState(LIFECYCLE_STATE.get_enum_value(state))\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_url","title":"<code>set_url(url: datatypes.PathType | datatypes.UrlType)</code>","text":"<p>Set the url of the WebEnginePage.</p> <p>Clears the Page and loads the URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.PathType | datatypes.UrlType</code> <p>URL to set</p> required Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def set_url(self, url: datatypes.PathType | datatypes.UrlType):\n\"\"\"Set the url of the WebEnginePage.\n    Clears the Page and loads the URL.\n    Args:\n        url: URL to set\n    \"\"\"\nself.setUrl(datatypes.to_url(url))\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_zoom","title":"<code>set_zoom(zoom: float)</code>","text":"<p>Set the zoom factor for the Page.</p> <p>Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom factor</p> required Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the Page.\n    Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n    Args:\n        zoom: Zoom factor\n    \"\"\"\nself.setZoomFactor(zoom)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineProfile","title":"<code>WebEngineProfile</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtWebEngineCore.QWebEngineProfile</code></p> Source code in <code>prettyqt\\webenginecore\\webengineprofile.py</code> <pre><code>class WebEngineProfile(core.ObjectMixin, QtWebEngineCore.QWebEngineProfile):\ndef set_persistent_cookie_policy(\nself, policy: PersistentCookiePolicyStr | mod.PersistentCookiesPolicy\n):\n\"\"\"Set the persistent cookie policy.\n        Args:\n            policy: persistent cookie policy\n        \"\"\"\nself.setPersistentCookiesPolicy(PERSISTENT_COOKIE_POLICY.get_enum_value(policy))\ndef get_persistent_cookie_policy(self) -&gt; PersistentCookiePolicyStr:\n\"\"\"Return current persistent cookie policy.\n        Returns:\n            Persistent cookie policy\n        \"\"\"\nreturn PERSISTENT_COOKIE_POLICY.inverse[self.persistentCookiesPolicy()]\ndef set_http_cache_type(self, typ: HttpCacheTypeStr | mod.PersistentCookiesPolicy):\n\"\"\"Set the http cache type.\n        Args:\n            typ: http cache type\n        \"\"\"\nself.setHttpCacheType(HTTP_CACHE_TYPE.get_enum_value(typ))\ndef get_http_cache_type(self) -&gt; HttpCacheTypeStr:\n\"\"\"Return current http cache type.\n        Returns:\n            Http cache type\n        \"\"\"\nreturn HTTP_CACHE_TYPE.inverse[self.httpCacheType()]\ndef get_scripts(self) -&gt; webenginecore.WebEngineScriptCollection:\nreturn webenginecore.WebEngineScriptCollection(self.scripts())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.get_http_cache_type","title":"<code>get_http_cache_type() -&gt; HttpCacheTypeStr</code>","text":"<p>Return current http cache type.</p> <p>Returns:</p> Type Description <code>HttpCacheTypeStr</code> <p>Http cache type</p> Source code in <code>prettyqt\\webenginecore\\webengineprofile.py</code> <pre><code>def get_http_cache_type(self) -&gt; HttpCacheTypeStr:\n\"\"\"Return current http cache type.\n    Returns:\n        Http cache type\n    \"\"\"\nreturn HTTP_CACHE_TYPE.inverse[self.httpCacheType()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.get_persistent_cookie_policy","title":"<code>get_persistent_cookie_policy() -&gt; PersistentCookiePolicyStr</code>","text":"<p>Return current persistent cookie policy.</p> <p>Returns:</p> Type Description <code>PersistentCookiePolicyStr</code> <p>Persistent cookie policy</p> Source code in <code>prettyqt\\webenginecore\\webengineprofile.py</code> <pre><code>def get_persistent_cookie_policy(self) -&gt; PersistentCookiePolicyStr:\n\"\"\"Return current persistent cookie policy.\n    Returns:\n        Persistent cookie policy\n    \"\"\"\nreturn PERSISTENT_COOKIE_POLICY.inverse[self.persistentCookiesPolicy()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.set_http_cache_type","title":"<code>set_http_cache_type(typ: HttpCacheTypeStr | mod.PersistentCookiesPolicy)</code>","text":"<p>Set the http cache type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>HttpCacheTypeStr | mod.PersistentCookiesPolicy</code> <p>http cache type</p> required Source code in <code>prettyqt\\webenginecore\\webengineprofile.py</code> <pre><code>def set_http_cache_type(self, typ: HttpCacheTypeStr | mod.PersistentCookiesPolicy):\n\"\"\"Set the http cache type.\n    Args:\n        typ: http cache type\n    \"\"\"\nself.setHttpCacheType(HTTP_CACHE_TYPE.get_enum_value(typ))\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.set_persistent_cookie_policy","title":"<code>set_persistent_cookie_policy(policy: PersistentCookiePolicyStr | mod.PersistentCookiesPolicy)</code>","text":"<p>Set the persistent cookie policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>PersistentCookiePolicyStr | mod.PersistentCookiesPolicy</code> <p>persistent cookie policy</p> required Source code in <code>prettyqt\\webenginecore\\webengineprofile.py</code> <pre><code>def set_persistent_cookie_policy(\nself, policy: PersistentCookiePolicyStr | mod.PersistentCookiesPolicy\n):\n\"\"\"Set the persistent cookie policy.\n    Args:\n        policy: persistent cookie policy\n    \"\"\"\nself.setPersistentCookiesPolicy(PERSISTENT_COOKIE_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineScript","title":"<code>WebEngineScript</code>","text":"<p>         Bases: <code>QtWebEngineCore.QWebEngineScript</code></p> Source code in <code>prettyqt\\webenginecore\\webenginescript.py</code> <pre><code>class WebEngineScript(QtWebEngineCore.QWebEngineScript):\ndef set_injection_point(\nself, point: InjectionPointStr | QtWebEngineCore.QWebEngineScript.InjectionPoint\n):\n\"\"\"Set injection point.\n        Args:\n            point: injection point to use\n        \"\"\"\nself.setInjectionPoint(INJECTION_POINT.get_enum_value(point))\ndef get_injection_point(self) -&gt; InjectionPointStr:\n\"\"\"Return injection point.\n        Returns:\n            injection point\n        \"\"\"\nreturn INJECTION_POINT.inverse[self.injectionPoint()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript.WebEngineScript.get_injection_point","title":"<code>get_injection_point() -&gt; InjectionPointStr</code>","text":"<p>Return injection point.</p> <p>Returns:</p> Type Description <code>InjectionPointStr</code> <p>injection point</p> Source code in <code>prettyqt\\webenginecore\\webenginescript.py</code> <pre><code>def get_injection_point(self) -&gt; InjectionPointStr:\n\"\"\"Return injection point.\n    Returns:\n        injection point\n    \"\"\"\nreturn INJECTION_POINT.inverse[self.injectionPoint()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript.WebEngineScript.set_injection_point","title":"<code>set_injection_point(point: InjectionPointStr | QtWebEngineCore.QWebEngineScript.InjectionPoint)</code>","text":"<p>Set injection point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>InjectionPointStr | QtWebEngineCore.QWebEngineScript.InjectionPoint</code> <p>injection point to use</p> required Source code in <code>prettyqt\\webenginecore\\webenginescript.py</code> <pre><code>def set_injection_point(\nself, point: InjectionPointStr | QtWebEngineCore.QWebEngineScript.InjectionPoint\n):\n\"\"\"Set injection point.\n    Args:\n        point: injection point to use\n    \"\"\"\nself.setInjectionPoint(INJECTION_POINT.get_enum_value(point))\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineSettings","title":"<code>WebEngineSettings</code>","text":"<p>         Bases: <code>MutableMapping</code></p> Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>class WebEngineSettings(MutableMapping):\ndef __init__(self, item: QtWebEngineCore.QWebEngineSettings):\nself.item = item\ndef __repr__(self):\nreturn get_repr(self, dict(self))\ndef __getattr__(self, val):\nreturn getattr(self.item, val)\ndef __setitem__(self, index: WebAttributeStr, value: bool):\nself.item.setAttribute(WEB_ATTRIBUTES[index], value)\ndef __getitem__(self, index: WebAttributeStr) -&gt; bool:\nif index not in WEB_ATTRIBUTES:\nraise KeyError(index)\nreturn self.item.testAttribute(WEB_ATTRIBUTES[index])\ndef __delitem__(self, index: WebAttributeStr):\nreturn self.item.resetAttribute(WEB_ATTRIBUTES[index])\ndef __iter__(self):\nreturn iter(WEB_ATTRIBUTES.keys())\ndef __len__(self):\nreturn len(WEB_ATTRIBUTES)\ndef set_unknown_url_scheme_policy(self, policy: UnknownUrlSchemePolicyStr | pol):\n\"\"\"Set the unknown url scheme policy.\n        Args:\n            policy: unknown url scheme policy\n        \"\"\"\nself.item.setUnknownUrlSchemePolicy(\nUNKNOWN_URL_SCHEME_POLICY.get_enum_value(policy)\n)\ndef get_unknown_url_scheme_policy(self) -&gt; UnknownUrlSchemePolicyStr:\n\"\"\"Return current unknown url scheme policy.\n        Returns:\n            Unknown url scheme policy\n        \"\"\"\nreturn UNKNOWN_URL_SCHEME_POLICY.inverse[self.item.unknownUrlSchemePolicy()]\ndef set_font_family(\nself,\nwhich: FontFamilyStr | QtWebEngineCore.QWebEngineSettings.FontFamily,\nfamily: str,\n):\n\"\"\"Set the actual font family to family for the specified generic family, which.\n        Args:\n            which: family to set\n            family: generic family\n        \"\"\"\nself.item.setFontFamily(FONT_FAMILY.get_enum_value(which), family)\ndef get_font_family(self, family: FontFamilyStr) -&gt; str:\n\"\"\"Return the actual font family for the specified generic font family.\n        Args:\n            family: generic font family\n        Returns:\n            Font family\n        \"\"\"\nreturn self.item.fontFamily(FONT_FAMILY[family])\ndef set_font_size(\nself, typ: FontSizeStr | QtWebEngineCore.QWebEngineSettings.FontSize, size: int\n):\n\"\"\"Set the font size for type to size in pixels.\n        Args:\n            typ: font size type\n            size: size in pixels\n        \"\"\"\nself.item.setFontSize(FONT_SIZE.get_enum_value(typ), size)\ndef get_font_size(self, typ: FontSizeStr) -&gt; int:\n\"\"\"Return the default font size for type in pixels.\n        Args:\n            typ: font size type\n        Returns:\n            Font size\n        \"\"\"\nreturn self.item.fontSize(FONT_SIZE[typ])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_font_family","title":"<code>get_font_family(family: FontFamilyStr) -&gt; str</code>","text":"<p>Return the actual font family for the specified generic font family.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <code>FontFamilyStr</code> <p>generic font family</p> required <p>Returns:</p> Type Description <code>str</code> <p>Font family</p> Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def get_font_family(self, family: FontFamilyStr) -&gt; str:\n\"\"\"Return the actual font family for the specified generic font family.\n    Args:\n        family: generic font family\n    Returns:\n        Font family\n    \"\"\"\nreturn self.item.fontFamily(FONT_FAMILY[family])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_font_size","title":"<code>get_font_size(typ: FontSizeStr) -&gt; int</code>","text":"<p>Return the default font size for type in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>FontSizeStr</code> <p>font size type</p> required <p>Returns:</p> Type Description <code>int</code> <p>Font size</p> Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def get_font_size(self, typ: FontSizeStr) -&gt; int:\n\"\"\"Return the default font size for type in pixels.\n    Args:\n        typ: font size type\n    Returns:\n        Font size\n    \"\"\"\nreturn self.item.fontSize(FONT_SIZE[typ])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_unknown_url_scheme_policy","title":"<code>get_unknown_url_scheme_policy() -&gt; UnknownUrlSchemePolicyStr</code>","text":"<p>Return current unknown url scheme policy.</p> <p>Returns:</p> Type Description <code>UnknownUrlSchemePolicyStr</code> <p>Unknown url scheme policy</p> Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def get_unknown_url_scheme_policy(self) -&gt; UnknownUrlSchemePolicyStr:\n\"\"\"Return current unknown url scheme policy.\n    Returns:\n        Unknown url scheme policy\n    \"\"\"\nreturn UNKNOWN_URL_SCHEME_POLICY.inverse[self.item.unknownUrlSchemePolicy()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_font_family","title":"<code>set_font_family(which: FontFamilyStr | QtWebEngineCore.QWebEngineSettings.FontFamily, family: str)</code>","text":"<p>Set the actual font family to family for the specified generic family, which.</p> <p>Parameters:</p> Name Type Description Default <code>which</code> <code>FontFamilyStr | QtWebEngineCore.QWebEngineSettings.FontFamily</code> <p>family to set</p> required <code>family</code> <code>str</code> <p>generic family</p> required Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def set_font_family(\nself,\nwhich: FontFamilyStr | QtWebEngineCore.QWebEngineSettings.FontFamily,\nfamily: str,\n):\n\"\"\"Set the actual font family to family for the specified generic family, which.\n    Args:\n        which: family to set\n        family: generic family\n    \"\"\"\nself.item.setFontFamily(FONT_FAMILY.get_enum_value(which), family)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_font_size","title":"<code>set_font_size(typ: FontSizeStr | QtWebEngineCore.QWebEngineSettings.FontSize, size: int)</code>","text":"<p>Set the font size for type to size in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>FontSizeStr | QtWebEngineCore.QWebEngineSettings.FontSize</code> <p>font size type</p> required <code>size</code> <code>int</code> <p>size in pixels</p> required Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def set_font_size(\nself, typ: FontSizeStr | QtWebEngineCore.QWebEngineSettings.FontSize, size: int\n):\n\"\"\"Set the font size for type to size in pixels.\n    Args:\n        typ: font size type\n        size: size in pixels\n    \"\"\"\nself.item.setFontSize(FONT_SIZE.get_enum_value(typ), size)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_unknown_url_scheme_policy","title":"<code>set_unknown_url_scheme_policy(policy: UnknownUrlSchemePolicyStr | pol)</code>","text":"<p>Set the unknown url scheme policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>UnknownUrlSchemePolicyStr | pol</code> <p>unknown url scheme policy</p> required Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def set_unknown_url_scheme_policy(self, policy: UnknownUrlSchemePolicyStr | pol):\n\"\"\"Set the unknown url scheme policy.\n    Args:\n        policy: unknown url scheme policy\n    \"\"\"\nself.item.setUnknownUrlSchemePolicy(\nUNKNOWN_URL_SCHEME_POLICY.get_enum_value(policy)\n)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineUrlScheme","title":"<code>WebEngineUrlScheme</code>","text":"<p>         Bases: <code>QtWebEngineCore.QWebEngineUrlScheme</code></p> Source code in <code>prettyqt\\webenginecore\\webengineurlscheme.py</code> <pre><code>class WebEngineUrlScheme(QtWebEngineCore.QWebEngineUrlScheme):\ndef get_name(self) -&gt; str:\nreturn self.name().data().decode()\n@classmethod\ndef get_scheme_by_name(cls, name: datatypes.ByteArrayType) -&gt; Self:\nscheme = cls.schemeByName(datatypes.to_bytearray(name))\nreturn cls(scheme)\ndef set_name(self, name: datatypes.ByteArrayType):\nself.setName(datatypes.to_bytearray(name))\ndef set_syntax(self, syntax: SyntaxStr | QWebEngineUrlScheme.Syntax):\n\"\"\"Set syntax.\n        Args:\n            syntax: syntax to use\n        \"\"\"\nself.setSyntax(SYNTAX.get_enum_value(syntax))\ndef get_syntax(self) -&gt; SyntaxStr:\n\"\"\"Return syntax.\n        Returns:\n            syntax\n        \"\"\"\nreturn SYNTAX.inverse[self.syntax()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.get_syntax","title":"<code>get_syntax() -&gt; SyntaxStr</code>","text":"<p>Return syntax.</p> <p>Returns:</p> Type Description <code>SyntaxStr</code> <p>syntax</p> Source code in <code>prettyqt\\webenginecore\\webengineurlscheme.py</code> <pre><code>def get_syntax(self) -&gt; SyntaxStr:\n\"\"\"Return syntax.\n    Returns:\n        syntax\n    \"\"\"\nreturn SYNTAX.inverse[self.syntax()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.set_syntax","title":"<code>set_syntax(syntax: SyntaxStr | QWebEngineUrlScheme.Syntax)</code>","text":"<p>Set syntax.</p> <p>Parameters:</p> Name Type Description Default <code>syntax</code> <code>SyntaxStr | QWebEngineUrlScheme.Syntax</code> <p>syntax to use</p> required Source code in <code>prettyqt\\webenginecore\\webengineurlscheme.py</code> <pre><code>def set_syntax(self, syntax: SyntaxStr | QWebEngineUrlScheme.Syntax):\n\"\"\"Set syntax.\n    Args:\n        syntax: syntax to use\n    \"\"\"\nself.setSyntax(SYNTAX.get_enum_value(syntax))\n</code></pre>"},{"location":"api/webenginewidgets.html","title":"webenginewidgets module","text":"<p>Webenginewidgets module.</p> <p>contains QtWebEngineWidgets-based classes</p>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.WebEngineView","title":"<code>WebEngineView</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWebEngineWidgets.QWebEngineView</code></p> Source code in <code>prettyqt\\webenginewidgets\\webengineview.py</code> <pre><code>class WebEngineView(widgets.WidgetMixin, QtWebEngineWidgets.QWebEngineView):\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.setPage(webenginecore.WebEnginePage(self))\ndef set_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Set the url of the WebEngineView.\n        Clears the view and loads the URL.\n        Args:\n            url: URL to set\n        \"\"\"\nmatch url:\ncase str():\nurl = core.Url(url)\ncase os.PathLike():\nurl = core.Url.fromLocalFile(os.fspath(url))\ncase None:\nurl = core.QUrl()\ncase core.QUrl():\npass\ncase _:\nraise TypeError(url)\nself.setUrl(url)\ndef get_url(self) -&gt; core.Url:\nreturn core.Url(self.url())\ndef load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n        Loads the specified url and displays it.\n        Note: The view remains the same until enough data has arrived\n        to display the new URL.\n        Args:\n            url: URL to load\n        \"\"\"\nmatch url:\ncase str():\nurl = core.Url(url)\ncase os.PathLike():\nurl = core.Url.fromLocalFile(os.fspath(url))\ncase None:\nurl = core.QUrl()\ncase core.QUrl():\npass\ncase _:\nraise TypeError(url)\nself.load(url)\ndef set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the view.\n        Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n        Args:\n            zoom: Zoom factor\n        \"\"\"\nself.setZoomFactor(zoom)\ndef find_text(\nself,\nstring: str,\nbackward: bool = False,\ncase_sensitive: bool = False,\ncallback: Callable[[bool], None] | None = None,\n):\n\"\"\"Find text in the current page.\n        Finds the specified string, subString, in the page, using the given options.\n        The findTextFinished() signal is emitted when a string search is completed.\n        To clear the search highlight, just pass an empty string.\n        The resultCallback must take a boolean parameter.\n        It will be called with a value of true if the subString was found;\n        otherwise the callback value will be false.\n        Warning: It is guaranteed that the callback is always called,\n        but it might be done during page destruction. When WebEnginePage is deleted,\n        the callback is triggered with an invalid value and it is not safe to use\n        the corresponding QWebEnginePage or QWebEngineView instance inside it.\n        Args:\n            string: string to search for\n            backward: search backwards\n            case_sensitive: case-sensitive search\n            callback: result callback\n        \"\"\"\nif callback is None:\ndef do_nothing(x):\npass\ncallback = do_nothing\nflag = webenginecore.WebEnginePage.FindFlag(0)\nif case_sensitive:\nflag |= webenginecore.WebEnginePage.FindFlag.FindCaseSensitively\nif backward:\nflag |= webenginecore.WebEnginePage.FindFlag.FindBackward\nself.findText(string, flag, callback)\ndef get_settings(self) -&gt; webenginecore.WebEngineSettings:\nsettings = self.settings()\nreturn webenginecore.WebEngineSettings(settings)\ndef set_setting(\nself,\nsetting_name: webenginecore.webenginesettings.WebAttributeStr,\nvalue: bool,\n):\nself.get_settings()[setting_name] = value\ndef get_setting(\nself, setting_name: webenginecore.webenginesettings.WebAttributeStr\n) -&gt; bool:\nreturn self.get_settings()[setting_name]\n@classmethod\ndef register_as_browser(cls, tabwidget: widgets.TabWidget):\nclass BuiltInBrowser(webbrowser.BaseBrowser):\ndef open(self, url: str, new: int = 0, autoraise: bool = True):\n# logger.info(f\"opening {url} with builtin browser..\")\nwebview = cls()\nwebview.load_url(url)\nif new == 1:\nwebview.show()\nelse:\ntabwidget.add_tab(webview, url, show=autoraise)\nwebbrowser.register(\"BuiltInBrowser\", BuiltInBrowser)\ndef last_context_menu_request(\nself,\n) -&gt; webenginecore.WebEngineContextMenuRequest | None:\nreq = self.lastContextMenuRequest()\nreturn webenginecore.WebEngineContextMenuRequest(req) if req else None\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.find_text","title":"<code>find_text(string: str, backward: bool = False, case_sensitive: bool = False, callback: Callable[[bool], None] | None = None)</code>","text":"<p>Find text in the current page.</p> <p>Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed.</p> <p>To clear the search highlight, just pass an empty string.</p> <p>The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false.</p> <p>Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>string to search for</p> required <code>backward</code> <code>bool</code> <p>search backwards</p> <code>False</code> <code>case_sensitive</code> <code>bool</code> <p>case-sensitive search</p> <code>False</code> <code>callback</code> <code>Callable[[bool], None] | None</code> <p>result callback</p> <code>None</code> Source code in <code>prettyqt\\webenginewidgets\\webengineview.py</code> <pre><code>def find_text(\nself,\nstring: str,\nbackward: bool = False,\ncase_sensitive: bool = False,\ncallback: Callable[[bool], None] | None = None,\n):\n\"\"\"Find text in the current page.\n    Finds the specified string, subString, in the page, using the given options.\n    The findTextFinished() signal is emitted when a string search is completed.\n    To clear the search highlight, just pass an empty string.\n    The resultCallback must take a boolean parameter.\n    It will be called with a value of true if the subString was found;\n    otherwise the callback value will be false.\n    Warning: It is guaranteed that the callback is always called,\n    but it might be done during page destruction. When WebEnginePage is deleted,\n    the callback is triggered with an invalid value and it is not safe to use\n    the corresponding QWebEnginePage or QWebEngineView instance inside it.\n    Args:\n        string: string to search for\n        backward: search backwards\n        case_sensitive: case-sensitive search\n        callback: result callback\n    \"\"\"\nif callback is None:\ndef do_nothing(x):\npass\ncallback = do_nothing\nflag = webenginecore.WebEnginePage.FindFlag(0)\nif case_sensitive:\nflag |= webenginecore.WebEnginePage.FindFlag.FindCaseSensitively\nif backward:\nflag |= webenginecore.WebEnginePage.FindFlag.FindBackward\nself.findText(string, flag, callback)\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.load_url","title":"<code>load_url(url: datatypes.UrlType | datatypes.PathType)</code>","text":"<p>Load the URL.</p> <p>Loads the specified url and displays it.</p> <p>Note: The view remains the same until enough data has arrived to display the new URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.UrlType | datatypes.PathType</code> <p>URL to load</p> required Source code in <code>prettyqt\\webenginewidgets\\webengineview.py</code> <pre><code>def load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n    Loads the specified url and displays it.\n    Note: The view remains the same until enough data has arrived\n    to display the new URL.\n    Args:\n        url: URL to load\n    \"\"\"\nmatch url:\ncase str():\nurl = core.Url(url)\ncase os.PathLike():\nurl = core.Url.fromLocalFile(os.fspath(url))\ncase None:\nurl = core.QUrl()\ncase core.QUrl():\npass\ncase _:\nraise TypeError(url)\nself.load(url)\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_url","title":"<code>set_url(url: datatypes.UrlType | datatypes.PathType)</code>","text":"<p>Set the url of the WebEngineView.</p> <p>Clears the view and loads the URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.UrlType | datatypes.PathType</code> <p>URL to set</p> required Source code in <code>prettyqt\\webenginewidgets\\webengineview.py</code> <pre><code>def set_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Set the url of the WebEngineView.\n    Clears the view and loads the URL.\n    Args:\n        url: URL to set\n    \"\"\"\nmatch url:\ncase str():\nurl = core.Url(url)\ncase os.PathLike():\nurl = core.Url.fromLocalFile(os.fspath(url))\ncase None:\nurl = core.QUrl()\ncase core.QUrl():\npass\ncase _:\nraise TypeError(url)\nself.setUrl(url)\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_zoom","title":"<code>set_zoom(zoom: float)</code>","text":"<p>Set the zoom factor for the view.</p> <p>Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom factor</p> required Source code in <code>prettyqt\\webenginewidgets\\webengineview.py</code> <pre><code>def set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the view.\n    Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n    Args:\n        zoom: Zoom factor\n    \"\"\"\nself.setZoomFactor(zoom)\n</code></pre>"},{"location":"api/widgets.html","title":"widgets module","text":"<p>widgets module.</p> <p>contains QtWidgets-based classes</p>"},{"location":"api/widgets.html#prettyqt.widgets.AbstractButtonMixin","title":"<code>AbstractButtonMixin</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code></p> Source code in <code>prettyqt\\widgets\\abstractbutton.py</code> <pre><code>class AbstractButtonMixin(widgets.WidgetMixin):\ndef __bool__(self):\nreturn self.isChecked()\ndef set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the button.\n        Args:\n            icon: icon to use\n        \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(icon)\ndef get_icon(self) -&gt; gui.Icon | None:\nicon = self.icon()\nreturn None if icon.isNull() else gui.Icon(icon)\ndef set_style_icon(\nself,\nicon: widgets.style.StandardPixmapStr | widgets.QStyle.StandardPixmap,\nsize: datatypes.SizeType = 15,\n):\n\"\"\"Set theme icon for the button.\n        Args:\n            icon: icon to use\n            size: icon size\n        \"\"\"\nqicon = self.style().standardIcon(\nwidgets.style.STANDARD_PIXMAP.get_enum_value(icon), None, self\n)\nself.set_icon(qicon)\nself.setIconSize(datatypes.to_size(size))\ndef set_shortcut(self, shortcut: datatypes.KeySequenceType):\nself.setShortcut(datatypes.to_keysequence(shortcut))\ndef get_shortcut(self) -&gt; gui.KeySequence:\nreturn gui.KeySequence(\nself.shortcut().toString(), gui.KeySequence.SequenceFormat.PortableText\n)\ndef setText(self, text: str):\nif not self.objectName() and widgets.app().is_debug():\nself.setObjectName(text)\nsuper().setText(text)\ndef set_icon_size(self, size: datatypes.SizeType):\n\"\"\"Set size of the icon.\"\"\"\nself.setIconSize(datatypes.to_size(size))\ndef get_icon_size(self) -&gt; core.Size:\nreturn core.Size(self.iconSize())\ndef get_value(self) -&gt; bool:\nreturn self.isChecked()\ndef set_value(self, value: bool):\nself.setChecked(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButtonMixin.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the button.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\abstractbutton.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the button.\n    Args:\n        icon: icon to use\n    \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButtonMixin.set_icon_size","title":"<code>set_icon_size(size: datatypes.SizeType)</code>","text":"<p>Set size of the icon.</p> Source code in <code>prettyqt\\widgets\\abstractbutton.py</code> <pre><code>def set_icon_size(self, size: datatypes.SizeType):\n\"\"\"Set size of the icon.\"\"\"\nself.setIconSize(datatypes.to_size(size))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButtonMixin.set_style_icon","title":"<code>set_style_icon(icon: widgets.style.StandardPixmapStr | widgets.QStyle.StandardPixmap, size: datatypes.SizeType = 15)</code>","text":"<p>Set theme icon for the button.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>widgets.style.StandardPixmapStr | widgets.QStyle.StandardPixmap</code> <p>icon to use</p> required <code>size</code> <code>datatypes.SizeType</code> <p>icon size</p> <code>15</code> Source code in <code>prettyqt\\widgets\\abstractbutton.py</code> <pre><code>def set_style_icon(\nself,\nicon: widgets.style.StandardPixmapStr | widgets.QStyle.StandardPixmap,\nsize: datatypes.SizeType = 15,\n):\n\"\"\"Set theme icon for the button.\n    Args:\n        icon: icon to use\n        size: icon size\n    \"\"\"\nqicon = self.style().standardIcon(\nwidgets.style.STANDARD_PIXMAP.get_enum_value(icon), None, self\n)\nself.set_icon(qicon)\nself.setIconSize(datatypes.to_size(size))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.AbstractItemViewMixin","title":"<code>AbstractItemViewMixin</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code></p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>class AbstractItemViewMixin(widgets.AbstractScrollAreaMixin):\nmodel_changed = core.Signal(QtCore.QAbstractItemModel)\ndef __init__(\nself,\n*args,\nhorizontal_scroll_mode=\"pixel\",\nvertical_scroll_mode=\"pixel\",\n**kwargs,\n):\nsuper().__init__(\n*args,\nhorizontal_scroll_mode=horizontal_scroll_mode,\nvertical_scroll_mode=vertical_scroll_mode,\n**kwargs,\n)\nfrom prettyqt.utils import proxifier\nself.proxifier = proxifier.Proxyfier(self)\ndef __len__(self) -&gt; int:\nreturn model.rowCount() if (model := self.model()) is not None else 0\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"dragDropMode\": DRAG_DROP_MODE,\n\"horizontalScrollMode\": SCROLL_MODE,\n\"verticalScrollMode\": SCROLL_MODE,\n\"selectionMode\": SELECTION_MODE,\n\"selectionBehavior\": SELECTION_BEHAVIOR,\n\"defaultDropAction\": constants.DROP_ACTION,\n\"textElideMode\": constants.TEXT_ELIDE_MODE,\n\"editTriggers\": EDIT_TRIGGERS,\n}\nreturn maps\ndef selectAll(self):\n\"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\"\nif self.model() is None:\nreturn\nif self.model().rowCount() * self.model().columnCount() &gt; 1_000_000:\nlogger.warning(\"Too many cells to select.\")\nreturn\nsuper().selectAll()\ndef set_model(self, model: QtCore.QAbstractItemModel | None):\n\"\"\"Set the model of this View.\"\"\"\n# Delete old selection model explicitely, seems to help with memory usage.\nold_model = self.model()\nold_sel_model = self.selectionModel()\nif old_model is not None or model is not None:\nself.setModel(model)\nif model is not None:\n# always set a parent. PySide6 needs one for proxying.\nmodel.setParent(self)\nself.setSelectionModel(core.ItemSelectionModel(model))\nself.model_changed.emit(model)\n# if old_model:\n#     old_model.deleteLater()\n#     del old_model\nif old_sel_model:\nold_sel_model.deleteLater()\ndel old_sel_model\nreturn model\ndef set_model_for(self, data: Any):\n\"\"\"Set model for given data type.\n        Pass any data structure and an appropriate model will be chosen automatically.\n        Args:\n            data: data to choose model for.\n        \"\"\"\n# we import to collect the models\nfrom prettyqt import custom_models  # noqa: F401\n# TODO: probably better to check models from external modules later\n# so we dont have to import everything even if not needed.\nif importlib.util.find_spec(\"pandas\") is not None:\nfrom prettyqt.qtpandas import pandasmodels  # noqa: F401\nfor Klass in helpers.get_subclasses(core.QAbstractItemModel):\nif (\n\"supports\" in Klass.__dict__\nand callable(Klass.supports)\nand Klass.supports(data)\nand Klass.__name__ != \"PythonObjectTreeModel\"\n):\nlogger.debug(f\"found model for data structure {data!r}\")\nbreak\nelse:\nraise TypeError(\"No suiting model found.\")\nmodel = Klass(data, parent=self)\nself.set_model(model)\ndef get_model(self, skip_proxies: bool = False) -&gt; QtCore.QAbstractItemModel:\nmodel = self.model()\nif skip_proxies:\nwhile isinstance(model, QtCore.QAbstractProxyModel):\nmodel = model.sourceModel()\nreturn model\ndef get_models(\nself, proxies_only: bool = False\n) -&gt; listdelegators.BaseListDelegator[QtCore.QAbstractProxyModel]:\n\"\"\"Get a list of all (proxy) models connected to this view.\"\"\"\nmodel = self.model()\nmodels = []\nwhile isinstance(model, QtCore.QAbstractProxyModel):\nmodels.append(model)\nmodel = model.sourceModel()\nif (not proxies_only) and model is not None:\nmodels.append(model)\nreturn listdelegators.BaseListDelegator(models)\ndef set_current_index(\nself,\nindex: QtCore.QModelIndex | tuple | None,\noperation: Literal[\"select\", \"deselect\", \"toggle\"] = \"select\",\nclear: bool = True,\ncurrent: bool = False,\nexpand: Literal[\"rows\", \"columns\"] | None = None,\n):\n# index = self.model().index(self._selected_index)\nmatch index:\ncase None:\nself.selectionModel().setCurrentIndex(\nindex, core.ItemSelectionModel.SelectionFlag.Clear\n)\nreturn\ncase tuple():\nindex = self.model().index(*index)\ncase QtCore.QModelIndex():\npass\ncase _:\nraise ValueError(index)\nmatch operation:\ncase \"select\":\nflag = core.ItemSelectionModel.SelectionFlag.Select\ncase \"deselect\":\nflag = core.ItemSelectionModel.SelectionFlag.Deselect\ncase \"toggle\":\nflag = core.ItemSelectionModel.SelectionFlag.Toggle\ncase _:\nraise ValueError(operation)\nif clear:\nflag |= core.ItemSelectionModel.SelectionFlag.Clear\nif current:\nflag |= core.ItemSelectionModel.SelectionFlag.Current\nmatch expand:\ncase \"rows\":\nflag |= core.ItemSelectionModel.SelectionFlag.Rows\ncase \"columns\":\nflag |= core.ItemSelectionModel.SelectionFlag.Columns\ncase None:\npass\ncase _:\nraise ValueError(expand)\nself.selectionModel().setCurrentIndex(index, flag)\ndef select_index(\nself,\nindex: QtCore.QModelIndex | tuple | None,\noperation: Literal[\"select\", \"deselect\", \"toggle\"] = \"select\",\nclear: bool = True,\ncurrent: bool = False,\nexpand: Literal[\"rows\", \"columns\"] | None = None,\n):\n# index = self.model().index(self._selected_index)\nmatch index:\ncase None:\nself.selectionModel().setCurrentIndex(\ncore.ModelIndex(), core.ItemSelectionModel.SelectionFlag.Clear\n)\nreturn\ncase tuple():\nindex = self.model().index(*index)\ncase QtCore.QModelIndex():\npass\ncase _:\nraise ValueError(index)\nmatch operation:\ncase \"select\":\nflag = core.ItemSelectionModel.SelectionFlag.Select\ncase \"deselect\":\nflag = core.ItemSelectionModel.SelectionFlag.Deselect\ncase \"toggle\":\nflag = core.ItemSelectionModel.SelectionFlag.Toggle\ncase _:\nraise ValueError(operation)\nif clear:\nflag |= core.ItemSelectionModel.SelectionFlag.Clear\nif current:\nflag |= core.ItemSelectionModel.SelectionFlag.Current\nmatch expand:\ncase \"rows\":\nflag |= core.ItemSelectionModel.SelectionFlag.Rows\ncase \"columns\":\nflag |= core.ItemSelectionModel.SelectionFlag.Columns\ncase None:\npass\ncase _:\nraise ValueError(expand)\nself.selectionModel().select(index, flag)\ndef move_row_selection(self, dy: int):\nfor row in self.selected_rows():\nnew_idx = self.model().index(row + dy, 0)\nif new_idx.isValid():\nself.set_current_index(new_idx, current=True, expand=\"rows\")\ndef set_delegate(\nself,\ndelegate: QtWidgets.QAbstractItemDelegate | DelegateStr,\n*,\ncolumn: int | None = None,\nrow: int | None = None,\npersistent: bool = False,\n**kwargs,\n):\n\"\"\"Set a delegate. Delegates can also be set by Id.\"\"\"\nmatch delegate:\ncase QtWidgets.QAbstractItemDelegate():\ndlg = delegate\n# case \"variant\":\n#     delegate = custom_delegates.VariantDelegate(parent=self, **kwargs)\n# case \"widget\":\n#     delegate = custom_delegates.WidgetDelegate(parent=self, **kwargs)\n# case \"html\":\n#     delegate = custom_delegates.HtmlItemDelegate(parent=self, **kwargs)\n# case \"button\":\n#     delegate = custom_delegates.ButtonDelegate(parent=self, **kwargs)\ncase str():\nKlass = helpers.get_class_for_id(widgets.StyledItemDelegate, delegate)\ndlg = Klass(parent=self, **kwargs)\ncase _:\nraise ValueError(delegate)\nmatch column, row:\ncase int(), int():\nraise ValueError(\"Only set column or row, not both.\")\ncase int(), None:\nself.setItemDelegateForColumn(column, dlg)\nif persistent:\nmodel = self.model()\nfor i in range(model.rowCount()):\nindex = model.index(i, column)\nself.openPersistentEditor(index)\ncase None, int():\nself.setItemDelegateForRow(row, dlg)\nif persistent:\nmodel = self.model()\nfor i in range(model.columnCount()):\nself.openPersistentEditor(model.index(row, i))\ncase None, None:\nself.setItemDelegate(dlg)\nif persistent:\nmodel = self.model()\nfor i in range(model.rowCount()):\nfor j in range(model.columnCount()):\nself.openPersistentEditor(model.index(i, j))\nreturn dlg\ndef toggle_select_all(self):\n\"\"\"Select all items from list (deselect when all selected).\"\"\"\nif self.selectionModel() is None:\nreturn\nif self.selectionModel().hasSelection():\nself.clearSelection()\nelse:\nself.selectAll()\ndef set_table_color(self, color: str):\nwith self.edit_stylesheet() as ss:\nss.QHeaderView.section.backgroundColor.setValue(color)\ndef current_index(self) -&gt; QtCore.QModelIndex | None:\nif (model := self.selectionModel()) is not None:\nreturn model.currentIndex()\nreturn None\ndef current_data(self, role=constants.USER_ROLE):\nif (model := self.selectionModel()) is not None:\nidx = model.currentIndex()\nreturn idx.data(role)\ndef current_row(self) -&gt; int | None:\nif (model := self.selectionModel()) is not None:\nreturn model.currentIndex().row()\nreturn None\ndef current_column(self) -&gt; int | None:\nif (model := self.selectionModel()) is not None:\nreturn model.currentIndex().column()\nreturn None\ndef selected_indexes(self) -&gt; listdelegators.BaseListDelegator[QtCore.QModelIndex]:\n\"\"\"Return list of selected indexes in first row.\"\"\"\nindexes = (x for x in self.selectedIndexes() if x.column() == 0)\nindexes = sorted(indexes, key=lambda x: x.row())\nreturn listdelegators.BaseListDelegator(indexes)\ndef selected_names(self) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding item names.\"\"\"\nreturn (x.data(constants.NAME_ROLE) for x in self.selected_indexes())\ndef selected_rows(self) -&gt; Generator[int, None, None]:\n\"\"\"Return generator yielding row nums.\"\"\"\nreturn (x.row() for x in self.selected_indexes())\ndef selected_data(self, role=constants.USER_ROLE) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding selected userData.\"\"\"\nreturn (x.data(role) for x in self.selected_indexes())\ndef setup_dragdrop_move(self):\nself.setDragEnabled(True)\nself.setAcceptDrops(True)\nself.setDragDropMode(self.DragDropMode.DragDrop)\nself.setDefaultDropAction(constants.MOVE_ACTION)\nself.setDropIndicatorShown(True)\ndef set_edit_triggers(self, *triggers: EditTriggerStr | None):\nitems = [\"none\" if t is None else t for t in triggers]\nflags = EDIT_TRIGGERS.merge_flags(items)\nself.setEditTriggers(flags)\ndef get_edit_triggers(self) -&gt; list[EditTriggerStr]:\nreturn EDIT_TRIGGERS.get_list(self.editTriggers())\ndef set_selection_behavior(\nself,\nbehaviour: SelectionBehaviourStr | QtWidgets.QAbstractItemView.SelectionBehavior,\n):\n\"\"\"Set selection behaviour for given item view.\n        Args:\n            behaviour: selection behaviour to use\n        \"\"\"\nself.setSelectionBehavior(SELECTION_BEHAVIOR.get_enum_value(behaviour))\ndef get_selection_behavior(self) -&gt; SelectionBehaviourStr:\n\"\"\"Return current selection behaviour.\n        Returns:\n            selection behaviour\n        \"\"\"\nreturn SELECTION_BEHAVIOR.inverse[self.selectionBehavior()]\ndef get_drop_indicator_position(self) -&gt; DropIndicatorPositionStr:\n\"\"\"Return position of the drop indicator in relation to the closest item.\n        Returns:\n            drop indicator position\n        \"\"\"\nreturn DROP_INDICATOR_POSITION.inverse[self.dropIndicatorPosition()]\ndef set_drag_drop_mode(\nself, mode: DragDropModeStr | QtWidgets.QAbstractItemView.DragDropMode\n):\n\"\"\"Set drag-drop mode for given item view.\n        Args:\n            mode: drag-drop mode to use\n        \"\"\"\nself.setDragDropMode(DRAG_DROP_MODE.get_enum_value(mode))\ndef get_drag_drop_mode(self) -&gt; DragDropModeStr:\n\"\"\"Return current drag-drop mode.\n        Returns:\n            drag-drop mode\n        \"\"\"\nreturn DRAG_DROP_MODE.inverse[self.dragDropMode()]\ndef set_state(self, state: StateStr | QtWidgets.QAbstractItemView.State):\n\"\"\"Set state for given item view.\n        Args:\n            state: state to use\n        \"\"\"\nself.setState(STATE.get_enum_value(state))\ndef get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n        Returns:\n            state\n        \"\"\"\nreturn STATE.inverse[self.state()]\ndef set_selection_mode(\nself, mode: SelectionModeStr | QtWidgets.QAbstractItemView.SelectionMode | None\n):\n\"\"\"Set selection mode for given item view.\n        Args:\n            mode: selection mode to use\n        \"\"\"\nif mode is None:\nmode = \"none\"\nself.setSelectionMode(SELECTION_MODE.get_enum_value(mode))\ndef get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n        Returns:\n            selection mode\n        \"\"\"\nreturn SELECTION_MODE.inverse[self.selectionMode()]\ndef set_scroll_mode(\nself, mode: ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode\n):\n\"\"\"Set the scroll mode for both directions.\n        Args:\n            mode: mode to set\n        \"\"\"\nself.setHorizontalScrollMode(SCROLL_MODE.get_enum_value(mode))\nself.setVerticalScrollMode(SCROLL_MODE.get_enum_value(mode))\ndef set_horizontal_scroll_mode(\nself, mode: ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode\n):\n\"\"\"Set the horizontal scroll mode.\n        Args:\n            mode: mode to set\n        \"\"\"\nself.setHorizontalScrollMode(SCROLL_MODE.get_enum_value(mode))\ndef get_horizontal_scroll_mode(self) -&gt; ScrollModeStr:\n\"\"\"Return current horizontal scroll mode.\n        Returns:\n            horizontal scroll mode\n        \"\"\"\nreturn SCROLL_MODE.inverse[self.horizontalScrollMode()]\ndef set_vertical_scroll_mode(\nself, mode: ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode\n):\n\"\"\"Set the vertical scroll mode.\n        Args:\n            mode: mode to set\n        \"\"\"\nself.setVerticalScrollMode(SCROLL_MODE.get_enum_value(mode))\ndef get_vertical_scroll_mode(self) -&gt; ScrollModeStr:\n\"\"\"Return current vertical scroll mode.\n        Returns:\n            vertical scroll mode\n        \"\"\"\nreturn SCROLL_MODE.inverse[self.verticalScrollMode()]\ndef num_selected(self) -&gt; int:\n\"\"\"Return amount of selected rows.\n        Returns:\n            amount of selected rows\n        \"\"\"\nif (model := self.selectionModel()) is not None:\nreturn len(model.selectedRows())\nreturn 0\ndef jump_to_column(self, col_num: int):\n\"\"\"Make sure column at given index is visible.\n        scrolls to column at given index\n        Args:\n            col_num: column to scroll to\n        \"\"\"\nif (model := self.model()) is not None:\nidx = model.index(0, col_num)\nself.scrollTo(idx)\ndef scroll_to_top(self):\n\"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\"\nself.scrollToTop()\ndef scroll_to_bottom(self):\n\"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\"\nself.scrollToBottom()\ndef select_last_row(self):\nidx = self.model().createIndex(self.model().rowCount() - 1, 0)\nself.setCurrentIndex(idx)\ndef select_first_row(self):\nidx = self.model().index(0, 0)\nself.set_current_index(idx, current=True, expand=\"rows\")\ndef scroll_to(\nself,\nindex: QtCore.QModelIndex,\nmode: ScrollHintStr | QtWidgets.QAbstractItemView.ScrollHint = \"ensure_visible\",\n):\nself.scrollTo(index, SCROLL_HINT.get_enum_value(mode))\ndef highlight_when_inactive(self):\n\"\"\"Highlight items when widget does not have focus.\"\"\"\np = self.get_palette()\np.highlight_inactive()\nself.setPalette(p)\ndef set_icon_size(self, size: datatypes.SizeType):\nself.setIconSize(datatypes.to_size(size))\ndef get_size_hint_for_column(self, col: int, row_limit: int = 25) -&gt; int:\n\"\"\"Get a size hint for given column by finding widest cell.\"\"\"\nto_check = min(row_limit, self.model().rowCount())\nreturn max(\nself.sizeHintForIndex(self.model().index(row, col)).width()\nfor row in range(to_check)\n)\ndef sync_with(\nself,\ntable_to_sync: widgets.QAbstractItemView,\norientation: constants.OrientationStr | constants.Orientation,\n) -&gt; list[core.QMetaObject.Connection]:\norientation = constants.ORIENTATION.get_enum_value(orientation)\ndef _table_resized(col, _, new_size, table, orientation):\nif orientation == constants.HORIZONTAL:\ntable.setColumnWidth(col, new_size)\nelse:\ntable.setRowHeight(col, new_size)\n_table_1_resized = functools.partial(\n_table_resized, table=self, orientation=orientation\n)\n_table_2_resized = functools.partial(\n_table_resized, table=table_to_sync, orientation=orientation\n)\nif orientation == constants.VERTICAL:\nh1 = self.v_scrollbar.valueChanged.connect(table_to_sync.v_scrollbar.setValue)\nh2 = table_to_sync.v_scrollbar.valueChanged.connect(self.v_scrollbar.setValue)\nh3 = self.v_header.sectionResized.connect(_table_2_resized)\nh4 = table_to_sync.v_header.sectionResized.connect(_table_1_resized)\nelse:\nh1 = self.h_scrollbar.valueChanged.connect(table_to_sync.h_scrollbar.setValue)\nh2 = table_to_sync.h_scrollbar.valueChanged.connect(self.h_scrollbar.setValue)\nh3 = self.h_header.sectionResized.connect(_table_2_resized)\nh4 = table_to_sync.h_header.sectionResized.connect(_table_1_resized)\nreturn [h1, h2, h3, h4]\ndef get_visible_section_span(\nself, orientation: constants.OrientationStr | constants.Orientation\n) -&gt; tuple[int, int]:\norientation = constants.ORIENTATION.get_enum_value(orientation)\ntop_left = QtCore.QPoint(0, 0)\nbottom_right = self.viewport().rect().bottomRight()\nif orientation == constants.HORIZONTAL:\nstart = self.indexAt(top_left).column()\ncount = self.model().columnCount()\nend = self.indexAt(bottom_right).column()\nelse:\nstart = self.indexAt(top_left).row()\ncount = self.model().rowCount()\nend = self.indexAt(bottom_right).row()\nif count == 0:\nreturn (-1, -1)\nend = count if end == -1 else end + 1\nreturn (start, end)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.__init__","title":"<code>__init__(*args, horizontal_scroll_mode = 'pixel', vertical_scroll_mode = 'pixel', **kwargs)</code>","text":"Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def __init__(\nself,\n*args,\nhorizontal_scroll_mode=\"pixel\",\nvertical_scroll_mode=\"pixel\",\n**kwargs,\n):\nsuper().__init__(\n*args,\nhorizontal_scroll_mode=horizontal_scroll_mode,\nvertical_scroll_mode=vertical_scroll_mode,\n**kwargs,\n)\nfrom prettyqt.utils import proxifier\nself.proxifier = proxifier.Proxyfier(self)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_drag_drop_mode","title":"<code>get_drag_drop_mode() -&gt; DragDropModeStr</code>","text":"<p>Return current drag-drop mode.</p> <p>Returns:</p> Type Description <code>DragDropModeStr</code> <p>drag-drop mode</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_drag_drop_mode(self) -&gt; DragDropModeStr:\n\"\"\"Return current drag-drop mode.\n    Returns:\n        drag-drop mode\n    \"\"\"\nreturn DRAG_DROP_MODE.inverse[self.dragDropMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_drop_indicator_position","title":"<code>get_drop_indicator_position() -&gt; DropIndicatorPositionStr</code>","text":"<p>Return position of the drop indicator in relation to the closest item.</p> <p>Returns:</p> Type Description <code>DropIndicatorPositionStr</code> <p>drop indicator position</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_drop_indicator_position(self) -&gt; DropIndicatorPositionStr:\n\"\"\"Return position of the drop indicator in relation to the closest item.\n    Returns:\n        drop indicator position\n    \"\"\"\nreturn DROP_INDICATOR_POSITION.inverse[self.dropIndicatorPosition()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_horizontal_scroll_mode","title":"<code>get_horizontal_scroll_mode() -&gt; ScrollModeStr</code>","text":"<p>Return current horizontal scroll mode.</p> <p>Returns:</p> Type Description <code>ScrollModeStr</code> <p>horizontal scroll mode</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_horizontal_scroll_mode(self) -&gt; ScrollModeStr:\n\"\"\"Return current horizontal scroll mode.\n    Returns:\n        horizontal scroll mode\n    \"\"\"\nreturn SCROLL_MODE.inverse[self.horizontalScrollMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_models","title":"<code>get_models(proxies_only: bool = False) -&gt; listdelegators.BaseListDelegator[QtCore.QAbstractProxyModel]</code>","text":"<p>Get a list of all (proxy) models connected to this view.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_models(\nself, proxies_only: bool = False\n) -&gt; listdelegators.BaseListDelegator[QtCore.QAbstractProxyModel]:\n\"\"\"Get a list of all (proxy) models connected to this view.\"\"\"\nmodel = self.model()\nmodels = []\nwhile isinstance(model, QtCore.QAbstractProxyModel):\nmodels.append(model)\nmodel = model.sourceModel()\nif (not proxies_only) and model is not None:\nmodels.append(model)\nreturn listdelegators.BaseListDelegator(models)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_selection_behavior","title":"<code>get_selection_behavior() -&gt; SelectionBehaviourStr</code>","text":"<p>Return current selection behaviour.</p> <p>Returns:</p> Type Description <code>SelectionBehaviourStr</code> <p>selection behaviour</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_selection_behavior(self) -&gt; SelectionBehaviourStr:\n\"\"\"Return current selection behaviour.\n    Returns:\n        selection behaviour\n    \"\"\"\nreturn SELECTION_BEHAVIOR.inverse[self.selectionBehavior()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_selection_mode","title":"<code>get_selection_mode() -&gt; SelectionModeStr</code>","text":"<p>Return current selection mode.</p> <p>Returns:</p> Type Description <code>SelectionModeStr</code> <p>selection mode</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n    Returns:\n        selection mode\n    \"\"\"\nreturn SELECTION_MODE.inverse[self.selectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_size_hint_for_column","title":"<code>get_size_hint_for_column(col: int, row_limit: int = 25) -&gt; int</code>","text":"<p>Get a size hint for given column by finding widest cell.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_size_hint_for_column(self, col: int, row_limit: int = 25) -&gt; int:\n\"\"\"Get a size hint for given column by finding widest cell.\"\"\"\nto_check = min(row_limit, self.model().rowCount())\nreturn max(\nself.sizeHintForIndex(self.model().index(row, col)).width()\nfor row in range(to_check)\n)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_state","title":"<code>get_state() -&gt; StateStr</code>","text":"<p>Return current state.</p> <p>Returns:</p> Type Description <code>StateStr</code> <p>state</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n    Returns:\n        state\n    \"\"\"\nreturn STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_vertical_scroll_mode","title":"<code>get_vertical_scroll_mode() -&gt; ScrollModeStr</code>","text":"<p>Return current vertical scroll mode.</p> <p>Returns:</p> Type Description <code>ScrollModeStr</code> <p>vertical scroll mode</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_vertical_scroll_mode(self) -&gt; ScrollModeStr:\n\"\"\"Return current vertical scroll mode.\n    Returns:\n        vertical scroll mode\n    \"\"\"\nreturn SCROLL_MODE.inverse[self.verticalScrollMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.highlight_when_inactive","title":"<code>highlight_when_inactive()</code>","text":"<p>Highlight items when widget does not have focus.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def highlight_when_inactive(self):\n\"\"\"Highlight items when widget does not have focus.\"\"\"\np = self.get_palette()\np.highlight_inactive()\nself.setPalette(p)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.jump_to_column","title":"<code>jump_to_column(col_num: int)</code>","text":"<p>Make sure column at given index is visible.</p> <p>scrolls to column at given index</p> <p>Parameters:</p> Name Type Description Default <code>col_num</code> <code>int</code> <p>column to scroll to</p> required Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def jump_to_column(self, col_num: int):\n\"\"\"Make sure column at given index is visible.\n    scrolls to column at given index\n    Args:\n        col_num: column to scroll to\n    \"\"\"\nif (model := self.model()) is not None:\nidx = model.index(0, col_num)\nself.scrollTo(idx)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.num_selected","title":"<code>num_selected() -&gt; int</code>","text":"<p>Return amount of selected rows.</p> <p>Returns:</p> Type Description <code>int</code> <p>amount of selected rows</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def num_selected(self) -&gt; int:\n\"\"\"Return amount of selected rows.\n    Returns:\n        amount of selected rows\n    \"\"\"\nif (model := self.selectionModel()) is not None:\nreturn len(model.selectedRows())\nreturn 0\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.scroll_to_bottom","title":"<code>scroll_to_bottom()</code>","text":"<p>Override to use abstractitemview-way of scrolling to bottom.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def scroll_to_bottom(self):\n\"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\"\nself.scrollToBottom()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.scroll_to_top","title":"<code>scroll_to_top()</code>","text":"<p>Override to use abstractitemview-way of scrolling to top.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def scroll_to_top(self):\n\"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\"\nself.scrollToTop()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selectAll","title":"<code>selectAll()</code>","text":"<p>Override, we dont want to selectAll for too many items bc of performance.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def selectAll(self):\n\"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\"\nif self.model() is None:\nreturn\nif self.model().rowCount() * self.model().columnCount() &gt; 1_000_000:\nlogger.warning(\"Too many cells to select.\")\nreturn\nsuper().selectAll()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_data","title":"<code>selected_data(role = constants.USER_ROLE) -&gt; Generator[Any, None, None]</code>","text":"<p>Return generator yielding selected userData.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def selected_data(self, role=constants.USER_ROLE) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding selected userData.\"\"\"\nreturn (x.data(role) for x in self.selected_indexes())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_indexes","title":"<code>selected_indexes() -&gt; listdelegators.BaseListDelegator[QtCore.QModelIndex]</code>","text":"<p>Return list of selected indexes in first row.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def selected_indexes(self) -&gt; listdelegators.BaseListDelegator[QtCore.QModelIndex]:\n\"\"\"Return list of selected indexes in first row.\"\"\"\nindexes = (x for x in self.selectedIndexes() if x.column() == 0)\nindexes = sorted(indexes, key=lambda x: x.row())\nreturn listdelegators.BaseListDelegator(indexes)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_names","title":"<code>selected_names() -&gt; Generator[Any, None, None]</code>","text":"<p>Return generator yielding item names.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def selected_names(self) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding item names.\"\"\"\nreturn (x.data(constants.NAME_ROLE) for x in self.selected_indexes())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_rows","title":"<code>selected_rows() -&gt; Generator[int, None, None]</code>","text":"<p>Return generator yielding row nums.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def selected_rows(self) -&gt; Generator[int, None, None]:\n\"\"\"Return generator yielding row nums.\"\"\"\nreturn (x.row() for x in self.selected_indexes())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_delegate","title":"<code>set_delegate(delegate: QtWidgets.QAbstractItemDelegate | DelegateStr, *, column: int | None = None, row: int | None = None, persistent: bool = False, **kwargs: bool)</code>","text":"<p>Set a delegate. Delegates can also be set by Id.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_delegate(\nself,\ndelegate: QtWidgets.QAbstractItemDelegate | DelegateStr,\n*,\ncolumn: int | None = None,\nrow: int | None = None,\npersistent: bool = False,\n**kwargs,\n):\n\"\"\"Set a delegate. Delegates can also be set by Id.\"\"\"\nmatch delegate:\ncase QtWidgets.QAbstractItemDelegate():\ndlg = delegate\n# case \"variant\":\n#     delegate = custom_delegates.VariantDelegate(parent=self, **kwargs)\n# case \"widget\":\n#     delegate = custom_delegates.WidgetDelegate(parent=self, **kwargs)\n# case \"html\":\n#     delegate = custom_delegates.HtmlItemDelegate(parent=self, **kwargs)\n# case \"button\":\n#     delegate = custom_delegates.ButtonDelegate(parent=self, **kwargs)\ncase str():\nKlass = helpers.get_class_for_id(widgets.StyledItemDelegate, delegate)\ndlg = Klass(parent=self, **kwargs)\ncase _:\nraise ValueError(delegate)\nmatch column, row:\ncase int(), int():\nraise ValueError(\"Only set column or row, not both.\")\ncase int(), None:\nself.setItemDelegateForColumn(column, dlg)\nif persistent:\nmodel = self.model()\nfor i in range(model.rowCount()):\nindex = model.index(i, column)\nself.openPersistentEditor(index)\ncase None, int():\nself.setItemDelegateForRow(row, dlg)\nif persistent:\nmodel = self.model()\nfor i in range(model.columnCount()):\nself.openPersistentEditor(model.index(row, i))\ncase None, None:\nself.setItemDelegate(dlg)\nif persistent:\nmodel = self.model()\nfor i in range(model.rowCount()):\nfor j in range(model.columnCount()):\nself.openPersistentEditor(model.index(i, j))\nreturn dlg\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_drag_drop_mode","title":"<code>set_drag_drop_mode(mode: DragDropModeStr | QtWidgets.QAbstractItemView.DragDropMode)</code>","text":"<p>Set drag-drop mode for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>DragDropModeStr | QtWidgets.QAbstractItemView.DragDropMode</code> <p>drag-drop mode to use</p> required Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_drag_drop_mode(\nself, mode: DragDropModeStr | QtWidgets.QAbstractItemView.DragDropMode\n):\n\"\"\"Set drag-drop mode for given item view.\n    Args:\n        mode: drag-drop mode to use\n    \"\"\"\nself.setDragDropMode(DRAG_DROP_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_horizontal_scroll_mode","title":"<code>set_horizontal_scroll_mode(mode: ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode)</code>","text":"<p>Set the horizontal scroll mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode</code> <p>mode to set</p> required Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_horizontal_scroll_mode(\nself, mode: ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode\n):\n\"\"\"Set the horizontal scroll mode.\n    Args:\n        mode: mode to set\n    \"\"\"\nself.setHorizontalScrollMode(SCROLL_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_model","title":"<code>set_model(model: QtCore.QAbstractItemModel | None)</code>","text":"<p>Set the model of this View.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_model(self, model: QtCore.QAbstractItemModel | None):\n\"\"\"Set the model of this View.\"\"\"\n# Delete old selection model explicitely, seems to help with memory usage.\nold_model = self.model()\nold_sel_model = self.selectionModel()\nif old_model is not None or model is not None:\nself.setModel(model)\nif model is not None:\n# always set a parent. PySide6 needs one for proxying.\nmodel.setParent(self)\nself.setSelectionModel(core.ItemSelectionModel(model))\nself.model_changed.emit(model)\n# if old_model:\n#     old_model.deleteLater()\n#     del old_model\nif old_sel_model:\nold_sel_model.deleteLater()\ndel old_sel_model\nreturn model\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_model_for","title":"<code>set_model_for(data: Any)</code>","text":"<p>Set model for given data type.</p> <p>Pass any data structure and an appropriate model will be chosen automatically.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>data to choose model for.</p> required Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_model_for(self, data: Any):\n\"\"\"Set model for given data type.\n    Pass any data structure and an appropriate model will be chosen automatically.\n    Args:\n        data: data to choose model for.\n    \"\"\"\n# we import to collect the models\nfrom prettyqt import custom_models  # noqa: F401\n# TODO: probably better to check models from external modules later\n# so we dont have to import everything even if not needed.\nif importlib.util.find_spec(\"pandas\") is not None:\nfrom prettyqt.qtpandas import pandasmodels  # noqa: F401\nfor Klass in helpers.get_subclasses(core.QAbstractItemModel):\nif (\n\"supports\" in Klass.__dict__\nand callable(Klass.supports)\nand Klass.supports(data)\nand Klass.__name__ != \"PythonObjectTreeModel\"\n):\nlogger.debug(f\"found model for data structure {data!r}\")\nbreak\nelse:\nraise TypeError(\"No suiting model found.\")\nmodel = Klass(data, parent=self)\nself.set_model(model)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_scroll_mode","title":"<code>set_scroll_mode(mode: ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode)</code>","text":"<p>Set the scroll mode for both directions.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode</code> <p>mode to set</p> required Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_scroll_mode(\nself, mode: ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode\n):\n\"\"\"Set the scroll mode for both directions.\n    Args:\n        mode: mode to set\n    \"\"\"\nself.setHorizontalScrollMode(SCROLL_MODE.get_enum_value(mode))\nself.setVerticalScrollMode(SCROLL_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_selection_behavior","title":"<code>set_selection_behavior(behaviour: SelectionBehaviourStr | QtWidgets.QAbstractItemView.SelectionBehavior)</code>","text":"<p>Set selection behaviour for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>behaviour</code> <code>SelectionBehaviourStr | QtWidgets.QAbstractItemView.SelectionBehavior</code> <p>selection behaviour to use</p> required Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_selection_behavior(\nself,\nbehaviour: SelectionBehaviourStr | QtWidgets.QAbstractItemView.SelectionBehavior,\n):\n\"\"\"Set selection behaviour for given item view.\n    Args:\n        behaviour: selection behaviour to use\n    \"\"\"\nself.setSelectionBehavior(SELECTION_BEHAVIOR.get_enum_value(behaviour))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_selection_mode","title":"<code>set_selection_mode(mode: SelectionModeStr | QtWidgets.QAbstractItemView.SelectionMode | None)</code>","text":"<p>Set selection mode for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SelectionModeStr | QtWidgets.QAbstractItemView.SelectionMode | None</code> <p>selection mode to use</p> required Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_selection_mode(\nself, mode: SelectionModeStr | QtWidgets.QAbstractItemView.SelectionMode | None\n):\n\"\"\"Set selection mode for given item view.\n    Args:\n        mode: selection mode to use\n    \"\"\"\nif mode is None:\nmode = \"none\"\nself.setSelectionMode(SELECTION_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_state","title":"<code>set_state(state: StateStr | QtWidgets.QAbstractItemView.State)</code>","text":"<p>Set state for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>StateStr | QtWidgets.QAbstractItemView.State</code> <p>state to use</p> required Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_state(self, state: StateStr | QtWidgets.QAbstractItemView.State):\n\"\"\"Set state for given item view.\n    Args:\n        state: state to use\n    \"\"\"\nself.setState(STATE.get_enum_value(state))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_vertical_scroll_mode","title":"<code>set_vertical_scroll_mode(mode: ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode)</code>","text":"<p>Set the vertical scroll mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode</code> <p>mode to set</p> required Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_vertical_scroll_mode(\nself, mode: ScrollModeStr | QtWidgets.QAbstractItemView.ScrollMode\n):\n\"\"\"Set the vertical scroll mode.\n    Args:\n        mode: mode to set\n    \"\"\"\nself.setVerticalScrollMode(SCROLL_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.toggle_select_all","title":"<code>toggle_select_all()</code>","text":"<p>Select all items from list (deselect when all selected).</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def toggle_select_all(self):\n\"\"\"Select all items from list (deselect when all selected).\"\"\"\nif self.selectionModel() is None:\nreturn\nif self.selectionModel().hasSelection():\nself.clearSelection()\nelse:\nself.selectAll()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.AbstractScrollAreaMixin","title":"<code>AbstractScrollAreaMixin</code>","text":"<p>         Bases: <code>widgets.FrameMixin</code></p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>class AbstractScrollAreaMixin(widgets.FrameMixin):\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.setHorizontalScrollBar(widgets.ScrollBar(parent=self))\nself.setVerticalScrollBar(widgets.ScrollBar(parent=self))\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"horizontalScrollBarPolicy\": constants.SCROLLBAR_POLICY,\n\"sizeAdjustPolicy\": SIZE_ADJUST_POLICY,\n\"verticalScrollBarPolicy\": constants.SCROLLBAR_POLICY,\n}\nreturn maps\n@property\ndef h_scrollbar(self) -&gt; widgets.ScrollBar:\nreturn self.horizontalScrollBar()\n@h_scrollbar.setter\ndef h_scrollbar(self, scrollbar: widgets.ScrollBar):\nself.setHorizontalScrollBar(scrollbar)\n@property\ndef v_scrollbar(self) -&gt; widgets.ScrollBar:\nreturn self.verticalScrollBar()\n@v_scrollbar.setter\ndef v_scrollbar(self, scrollbar: widgets.ScrollBar):\nself.setVerticalScrollBar(scrollbar)\ndef scroll_by_pixels(self, x: int = 0, y: int = 0):\nnew_x = self.h_scrollbar.value() + x\nx_val = max(min(new_x, self.h_scrollbar.maximum()), self.h_scrollbar.minimum())\nnew_y = self.h_scrollbar.value() + y\ny_val = max(min(new_y, self.v_scrollbar.maximum()), self.v_scrollbar.minimum())\nself.h_scrollbar.setValue(x_val)\nself.v_scrollbar.setValue(y_val)\ndef set_size_adjust_policy(self, policy: SizeAdjustPolicyStr | area.SizeAdjustPolicy):\n\"\"\"Set size adjust policy.\n        Args:\n            policy: size adjust policy to use\n        \"\"\"\nself.setSizeAdjustPolicy(SIZE_ADJUST_POLICY.get_enum_value(policy))\ndef get_size_adjust_policy(self) -&gt; SizeAdjustPolicyStr:\n\"\"\"Return size adjust policy.\n        Returns:\n            size adjust policy\n        \"\"\"\nreturn SIZE_ADJUST_POLICY.inverse[self.sizeAdjustPolicy()]\ndef set_scrollbar_smooth(\nself,\nvalue: bool = True,\nanimation_duration: int = 500,\neasing: core.easingcurve.TypeStr | core.QEasingCurve.Type = \"out_cubic\",\n):\nif value:\nself.h_scrollbar = widgets.SmoothScrollBar(\n\"horizontal\",\nparent=self,\nanimation_duration=animation_duration,\neasing=easing,\n)\nself.v_scrollbar = widgets.SmoothScrollBar(\n\"vertical\",\nparent=self,\nanimation_duration=animation_duration,\neasing=easing,\n)\nelse:\nself.h_scrollbar = widgets.ScrollBar(parent=self)\nself.v_scrollbar = widgets.ScrollBar(parent=self)\ndef set_scrollbar_policy(\nself, mode: constants.ScrollBarPolicyStr | constants.ScrollBarPolicy\n):\n\"\"\"Set the policy for both scrollbars.\n        Args:\n            mode: visibilty to set\n        \"\"\"\nself.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY.get_enum_value(mode))\nself.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY.get_enum_value(mode))\ndef set_horizontal_scrollbar_policy(\nself, mode: constants.ScrollBarPolicyStr | constants.ScrollBarPolicy\n):\n\"\"\"Set the horizontal scrollbar visibility.\n        Args:\n            mode: visibilty to set\n        \"\"\"\nself.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\ndef get_horizontal_scrollbar_policy(self) -&gt; constants.ScrollBarPolicyStr:\nreturn constants.SCROLLBAR_POLICY.inverse[self.horizontalScrollBarPolicy()]\ndef set_vertical_scrollbar_policy(\nself, mode: constants.ScrollBarPolicyStr | constants.ScrollBarPolicy\n):\n\"\"\"Set the vertical scrollbar visibility.\n        Args:\n            mode: visibilty to set\n        \"\"\"\nself.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY.get_enum_value(mode))\ndef get_vertical_scrollbar_policy(self) -&gt; constants.ScrollBarPolicyStr:\nreturn constants.SCROLLBAR_POLICY.inverse[self.verticalScrollBarPolicy()]\ndef set_scrollbar_width(self, width: int):\n\"\"\"Set the width for both scrollbars.\n        Args:\n            width: width in pixels\n        \"\"\"\nself.set_horizontal_scrollbar_width(width)\nself.set_vertical_scrollbar_width(width)\ndef set_horizontal_scrollbar_width(self, width: int):\n\"\"\"Set the horizontal scrollbar width.\n        Args:\n            width: width in pixels\n        \"\"\"\nwith self.h_scrollbar.edit_stylesheet() as ss:\nss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\ndef set_vertical_scrollbar_width(self, width: int):\n\"\"\"Set the vertical scrollbar width.\n        Args:\n            width: width in pixels\n        \"\"\"\nwith self.v_scrollbar.edit_stylesheet() as ss:\nss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\ndef scroll_to_top(self):\n\"\"\"Scroll to the top of the scroll area.\"\"\"\nself.verticalScrollBar().scroll_to_min()\ndef scroll_to_bottom(self):\n\"\"\"Scroll to the bottom of the scroll area.\"\"\"\nself.verticalScrollBar().scroll_to_max()\ndef set_viewport_margins(self, margins: int):\nself.setViewportMargins(margins, margins, margins, margins)\ndef add_scrollbar_widget(\nself,\nwidget: QtWidgets.QWidget,\nalignment: constants.AlignmentStr | constants.AlignmentFlag,\n):\nalignment = constants.ALIGNMENTS.get_enum_value(alignment)\nself.addScrollBarWidget(widget, alignment)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.get_size_adjust_policy","title":"<code>get_size_adjust_policy() -&gt; SizeAdjustPolicyStr</code>","text":"<p>Return size adjust policy.</p> <p>Returns:</p> Type Description <code>SizeAdjustPolicyStr</code> <p>size adjust policy</p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def get_size_adjust_policy(self) -&gt; SizeAdjustPolicyStr:\n\"\"\"Return size adjust policy.\n    Returns:\n        size adjust policy\n    \"\"\"\nreturn SIZE_ADJUST_POLICY.inverse[self.sizeAdjustPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.scroll_to_bottom","title":"<code>scroll_to_bottom()</code>","text":"<p>Scroll to the bottom of the scroll area.</p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def scroll_to_bottom(self):\n\"\"\"Scroll to the bottom of the scroll area.\"\"\"\nself.verticalScrollBar().scroll_to_max()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.scroll_to_top","title":"<code>scroll_to_top()</code>","text":"<p>Scroll to the top of the scroll area.</p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def scroll_to_top(self):\n\"\"\"Scroll to the top of the scroll area.\"\"\"\nself.verticalScrollBar().scroll_to_min()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_horizontal_scrollbar_policy","title":"<code>set_horizontal_scrollbar_policy(mode: constants.ScrollBarPolicyStr | constants.ScrollBarPolicy)</code>","text":"<p>Set the horizontal scrollbar visibility.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ScrollBarPolicyStr | constants.ScrollBarPolicy</code> <p>visibilty to set</p> required Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_horizontal_scrollbar_policy(\nself, mode: constants.ScrollBarPolicyStr | constants.ScrollBarPolicy\n):\n\"\"\"Set the horizontal scrollbar visibility.\n    Args:\n        mode: visibilty to set\n    \"\"\"\nself.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_horizontal_scrollbar_width","title":"<code>set_horizontal_scrollbar_width(width: int)</code>","text":"<p>Set the horizontal scrollbar width.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>width in pixels</p> required Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_horizontal_scrollbar_width(self, width: int):\n\"\"\"Set the horizontal scrollbar width.\n    Args:\n        width: width in pixels\n    \"\"\"\nwith self.h_scrollbar.edit_stylesheet() as ss:\nss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_scrollbar_policy","title":"<code>set_scrollbar_policy(mode: constants.ScrollBarPolicyStr | constants.ScrollBarPolicy)</code>","text":"<p>Set the policy for both scrollbars.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ScrollBarPolicyStr | constants.ScrollBarPolicy</code> <p>visibilty to set</p> required Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_scrollbar_policy(\nself, mode: constants.ScrollBarPolicyStr | constants.ScrollBarPolicy\n):\n\"\"\"Set the policy for both scrollbars.\n    Args:\n        mode: visibilty to set\n    \"\"\"\nself.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY.get_enum_value(mode))\nself.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_scrollbar_width","title":"<code>set_scrollbar_width(width: int)</code>","text":"<p>Set the width for both scrollbars.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>width in pixels</p> required Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_scrollbar_width(self, width: int):\n\"\"\"Set the width for both scrollbars.\n    Args:\n        width: width in pixels\n    \"\"\"\nself.set_horizontal_scrollbar_width(width)\nself.set_vertical_scrollbar_width(width)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_size_adjust_policy","title":"<code>set_size_adjust_policy(policy: SizeAdjustPolicyStr | area.SizeAdjustPolicy)</code>","text":"<p>Set size adjust policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizeAdjustPolicyStr | area.SizeAdjustPolicy</code> <p>size adjust policy to use</p> required Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_size_adjust_policy(self, policy: SizeAdjustPolicyStr | area.SizeAdjustPolicy):\n\"\"\"Set size adjust policy.\n    Args:\n        policy: size adjust policy to use\n    \"\"\"\nself.setSizeAdjustPolicy(SIZE_ADJUST_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_vertical_scrollbar_policy","title":"<code>set_vertical_scrollbar_policy(mode: constants.ScrollBarPolicyStr | constants.ScrollBarPolicy)</code>","text":"<p>Set the vertical scrollbar visibility.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ScrollBarPolicyStr | constants.ScrollBarPolicy</code> <p>visibilty to set</p> required Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_vertical_scrollbar_policy(\nself, mode: constants.ScrollBarPolicyStr | constants.ScrollBarPolicy\n):\n\"\"\"Set the vertical scrollbar visibility.\n    Args:\n        mode: visibilty to set\n    \"\"\"\nself.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_vertical_scrollbar_width","title":"<code>set_vertical_scrollbar_width(width: int)</code>","text":"<p>Set the vertical scrollbar width.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>width in pixels</p> required Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_vertical_scrollbar_width(self, width: int):\n\"\"\"Set the vertical scrollbar width.\n    Args:\n        width: width in pixels\n    \"\"\"\nwith self.v_scrollbar.edit_stylesheet() as ss:\nss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.AbstractSliderMixin","title":"<code>AbstractSliderMixin</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code></p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>class AbstractSliderMixin(widgets.WidgetMixin):\nvalue_changed = core.Signal(int)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"orientation\": constants.ORIENTATION,\n}\nreturn maps\ndef on_value_change(self):\nself.value_changed.emit(self.value())\ndef is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n        Returns:\n            True if horizontal, else False\n        \"\"\"\nreturn self.orientation() == constants.HORIZONTAL\ndef is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n        Returns:\n            True if vertical, else False\n        \"\"\"\nreturn self.orientation() == constants.VERTICAL\ndef set_horizontal(self):\n\"\"\"Set slider orientation to horizontal.\"\"\"\nself.setOrientation(constants.HORIZONTAL)\ndef set_vertical(self):\n\"\"\"Set slider orientation to vertical.\"\"\"\nself.setOrientation(constants.VERTICAL)\ndef set_orientation(\nself, orientation: constants.OrientationStr | constants.Orientation\n):\n\"\"\"Set the orientation of the slider.\n        Args:\n            orientation: orientation for the slider\n        \"\"\"\nself.setOrientation(constants.ORIENTATION.get_enum_value(orientation))\ndef get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n        Returns:\n            orientation\n        \"\"\"\nreturn constants.ORIENTATION.inverse[self.orientation()]\ndef scroll_to_min(self):\n\"\"\"Scroll to the minimum value of the slider.\"\"\"\nself.setValue(self.minimum())\ndef scroll_to_max(self):\n\"\"\"Scroll to the maximum value of the slider.\"\"\"\nself.setValue(self.maximum())\ndef set_range(self, min_val: int, max_val: int):\nself.setRange(min_val, max_val)\ndef set_step_size(self, step_size: int):\nself.setSingleStep(step_size)\ndef set_repeat_action(\nself,\naction: SliderActionStr | QtWidgets.QAbstractSlider.SliderAction,\nthreshold: int = 500,\nrepeat_time: int = 50,\n):\n\"\"\"Set the repeat action.\n        Args:\n            action: repeat action\n            threshold: initial delay in ms\n            repeat_time: repeat time in ms\n        \"\"\"\nself.setRepeatAction(SLIDER_ACTION.get_enum_value(action), threshold, repeat_time)\ndef get_repeat_action(self) -&gt; SliderActionStr:\n\"\"\"Get current repeat action.\n        Returns:\n            current repeat action\n        \"\"\"\nreturn SLIDER_ACTION.inverse[self.repeatAction()]\ndef trigger_action(\nself, action: SliderActionStr | QtWidgets.QAbstractSlider.SliderAction\n):\n\"\"\"Trigger slider action.\"\"\"\nself.triggerAction(SLIDER_ACTION.get_enum_value(action))\ndef get_value(self) -&gt; int:\nreturn self.value()\ndef set_value(self, value: int):\nself.setValue(value)\ndef on_scrollbar_range_changed(self, minval: int, maxval: int):\nif self.value() &gt;= self.maximum() - 1:\nself.setValue(maxval)\ndef set_auto_scroll_to_end(self, scroll: bool = True):\n\"\"\"Set to always scroll to the end when range changes.\"\"\"\nif scroll:\nself.rangeChanged.connect(self.on_scrollbar_range_changed)\nelse:\nself.rangeChanged.disconnect(self.on_scrollbar_range_changed)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n    Returns:\n        orientation\n    \"\"\"\nreturn constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.get_repeat_action","title":"<code>get_repeat_action() -&gt; SliderActionStr</code>","text":"<p>Get current repeat action.</p> <p>Returns:</p> Type Description <code>SliderActionStr</code> <p>current repeat action</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def get_repeat_action(self) -&gt; SliderActionStr:\n\"\"\"Get current repeat action.\n    Returns:\n        current repeat action\n    \"\"\"\nreturn SLIDER_ACTION.inverse[self.repeatAction()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.is_horizontal","title":"<code>is_horizontal() -&gt; bool</code>","text":"<p>Check if silder is horizontal.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if horizontal, else False</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n    Returns:\n        True if horizontal, else False\n    \"\"\"\nreturn self.orientation() == constants.HORIZONTAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.is_vertical","title":"<code>is_vertical() -&gt; bool</code>","text":"<p>Check if silder is vertical.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if vertical, else False</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n    Returns:\n        True if vertical, else False\n    \"\"\"\nreturn self.orientation() == constants.VERTICAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.scroll_to_max","title":"<code>scroll_to_max()</code>","text":"<p>Scroll to the maximum value of the slider.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def scroll_to_max(self):\n\"\"\"Scroll to the maximum value of the slider.\"\"\"\nself.setValue(self.maximum())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.scroll_to_min","title":"<code>scroll_to_min()</code>","text":"<p>Scroll to the minimum value of the slider.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def scroll_to_min(self):\n\"\"\"Scroll to the minimum value of the slider.\"\"\"\nself.setValue(self.minimum())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_auto_scroll_to_end","title":"<code>set_auto_scroll_to_end(scroll: bool = True)</code>","text":"<p>Set to always scroll to the end when range changes.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def set_auto_scroll_to_end(self, scroll: bool = True):\n\"\"\"Set to always scroll to the end when range changes.\"\"\"\nif scroll:\nself.rangeChanged.connect(self.on_scrollbar_range_changed)\nelse:\nself.rangeChanged.disconnect(self.on_scrollbar_range_changed)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_horizontal","title":"<code>set_horizontal()</code>","text":"<p>Set slider orientation to horizontal.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def set_horizontal(self):\n\"\"\"Set slider orientation to horizontal.\"\"\"\nself.setOrientation(constants.HORIZONTAL)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_orientation","title":"<code>set_orientation(orientation: constants.OrientationStr | constants.Orientation)</code>","text":"<p>Set the orientation of the slider.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr | constants.Orientation</code> <p>orientation for the slider</p> required Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def set_orientation(\nself, orientation: constants.OrientationStr | constants.Orientation\n):\n\"\"\"Set the orientation of the slider.\n    Args:\n        orientation: orientation for the slider\n    \"\"\"\nself.setOrientation(constants.ORIENTATION.get_enum_value(orientation))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_repeat_action","title":"<code>set_repeat_action(action: SliderActionStr | QtWidgets.QAbstractSlider.SliderAction, threshold: int = 500, repeat_time: int = 50)</code>","text":"<p>Set the repeat action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>SliderActionStr | QtWidgets.QAbstractSlider.SliderAction</code> <p>repeat action</p> required <code>threshold</code> <code>int</code> <p>initial delay in ms</p> <code>500</code> <code>repeat_time</code> <code>int</code> <p>repeat time in ms</p> <code>50</code> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def set_repeat_action(\nself,\naction: SliderActionStr | QtWidgets.QAbstractSlider.SliderAction,\nthreshold: int = 500,\nrepeat_time: int = 50,\n):\n\"\"\"Set the repeat action.\n    Args:\n        action: repeat action\n        threshold: initial delay in ms\n        repeat_time: repeat time in ms\n    \"\"\"\nself.setRepeatAction(SLIDER_ACTION.get_enum_value(action), threshold, repeat_time)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_vertical","title":"<code>set_vertical()</code>","text":"<p>Set slider orientation to vertical.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def set_vertical(self):\n\"\"\"Set slider orientation to vertical.\"\"\"\nself.setOrientation(constants.VERTICAL)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.trigger_action","title":"<code>trigger_action(action: SliderActionStr | QtWidgets.QAbstractSlider.SliderAction)</code>","text":"<p>Trigger slider action.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def trigger_action(\nself, action: SliderActionStr | QtWidgets.QAbstractSlider.SliderAction\n):\n\"\"\"Trigger slider action.\"\"\"\nself.triggerAction(SLIDER_ACTION.get_enum_value(action))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.AbstractSpinBoxMixin","title":"<code>AbstractSpinBoxMixin</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code></p> Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>class AbstractSpinBoxMixin(widgets.WidgetMixin):\ndef __init__(self, *args, show_group_separator: bool = True, **kwargs):\nsuper().__init__(*args, show_group_separator=show_group_separator, **kwargs)\nself.setLineEdit(widgets.LineEdit(parent=self))\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"alignment\": constants.ALIGNMENTS,\n\"buttonSymbols\": SYMBOLS,\n\"correctionMode\": CORRECTION_MODES,\n}\nreturn maps\ndef is_valid(self) -&gt; bool:\nreturn self.hasAcceptableInput()\ndef set_validator(\nself, validator: QtGui.QValidator | widgets.lineedit.ValidatorStr | None, **kwargs\n) -&gt; QtGui.QValidator:\nreturn self.lineEdit().set_validator(validator)\ndef get_button_symbols(self) -&gt; SymbolStr:\n\"\"\"Return button symbol type.\n        Returns:\n            button symbol type\n        \"\"\"\nreturn SYMBOLS.inverse[self.buttonSymbols()]\ndef set_button_symbols(self, mode: SymbolStr | QtWidgets.QSpinBox.ButtonSymbols):\n\"\"\"Set button symbol type.\n        Args:\n            mode: button symbol type to use\n        \"\"\"\nself.setButtonSymbols(SYMBOLS.get_enum_value(mode))\ndef set_correction_mode(\nself, mode: CorrectionModeStr | QtWidgets.QSpinBox.CorrectionMode\n):\n\"\"\"Set correction mode.\n        Args:\n            mode: correction mode to use\n        \"\"\"\nself.setCorrectionMode(CORRECTION_MODES.get_enum_value(mode))\ndef get_correction_mode(self) -&gt; CorrectionModeStr:\n\"\"\"Return correction mode.\n        Returns:\n            correction mode\n        \"\"\"\nreturn CORRECTION_MODES.inverse[self.correctionMode()]\ndef set_step_type(self, mode: StepTypeStr | QtWidgets.QSpinBox.StepType):\n\"\"\"Set step type.\n        Args:\n            mode: step type to use\n        \"\"\"\nself.setStepType(STEP_TYPES.get_enum_value(mode))\ndef get_step_type(self) -&gt; StepTypeStr:\n\"\"\"Return step type.\n        Returns:\n            step type\n        \"\"\"\nreturn STEP_TYPES.inverse[self.stepType()]\ndef set_special_value(self, value: str):\nself.setSpecialValueText(value)\ndef get_value(self) -&gt; int:\nreturn self.value()\ndef set_value(self, value: int | float):\nself.setValue(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.get_button_symbols","title":"<code>get_button_symbols() -&gt; SymbolStr</code>","text":"<p>Return button symbol type.</p> <p>Returns:</p> Type Description <code>SymbolStr</code> <p>button symbol type</p> Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def get_button_symbols(self) -&gt; SymbolStr:\n\"\"\"Return button symbol type.\n    Returns:\n        button symbol type\n    \"\"\"\nreturn SYMBOLS.inverse[self.buttonSymbols()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.get_correction_mode","title":"<code>get_correction_mode() -&gt; CorrectionModeStr</code>","text":"<p>Return correction mode.</p> <p>Returns:</p> Type Description <code>CorrectionModeStr</code> <p>correction mode</p> Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def get_correction_mode(self) -&gt; CorrectionModeStr:\n\"\"\"Return correction mode.\n    Returns:\n        correction mode\n    \"\"\"\nreturn CORRECTION_MODES.inverse[self.correctionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.get_step_type","title":"<code>get_step_type() -&gt; StepTypeStr</code>","text":"<p>Return step type.</p> <p>Returns:</p> Type Description <code>StepTypeStr</code> <p>step type</p> Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def get_step_type(self) -&gt; StepTypeStr:\n\"\"\"Return step type.\n    Returns:\n        step type\n    \"\"\"\nreturn STEP_TYPES.inverse[self.stepType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.set_button_symbols","title":"<code>set_button_symbols(mode: SymbolStr | QtWidgets.QSpinBox.ButtonSymbols)</code>","text":"<p>Set button symbol type.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SymbolStr | QtWidgets.QSpinBox.ButtonSymbols</code> <p>button symbol type to use</p> required Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def set_button_symbols(self, mode: SymbolStr | QtWidgets.QSpinBox.ButtonSymbols):\n\"\"\"Set button symbol type.\n    Args:\n        mode: button symbol type to use\n    \"\"\"\nself.setButtonSymbols(SYMBOLS.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.set_correction_mode","title":"<code>set_correction_mode(mode: CorrectionModeStr | QtWidgets.QSpinBox.CorrectionMode)</code>","text":"<p>Set correction mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CorrectionModeStr | QtWidgets.QSpinBox.CorrectionMode</code> <p>correction mode to use</p> required Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def set_correction_mode(\nself, mode: CorrectionModeStr | QtWidgets.QSpinBox.CorrectionMode\n):\n\"\"\"Set correction mode.\n    Args:\n        mode: correction mode to use\n    \"\"\"\nself.setCorrectionMode(CORRECTION_MODES.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.set_step_type","title":"<code>set_step_type(mode: StepTypeStr | QtWidgets.QSpinBox.StepType)</code>","text":"<p>Set step type.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>StepTypeStr | QtWidgets.QSpinBox.StepType</code> <p>step type to use</p> required Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def set_step_type(self, mode: StepTypeStr | QtWidgets.QSpinBox.StepType):\n\"\"\"Set step type.\n    Args:\n        mode: step type to use\n    \"\"\"\nself.setStepType(STEP_TYPES.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.CalendarWidget","title":"<code>CalendarWidget</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QCalendarWidget</code></p> Source code in <code>prettyqt\\widgets\\calendarwidget.py</code> <pre><code>class CalendarWidget(widgets.WidgetMixin, QtWidgets.QCalendarWidget):\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"firstDayOfWeek\": constants.DAY_OF_WEEK,\n\"horizontalHeaderFormat\": HORIZONTAL_HEADER_FORMAT,\n\"verticalHeaderFormat\": VERTICAL_HEADER_FORMAT,\n\"selectionMode\": SELECTION_MODE,\n}\nreturn maps\ndef get_date(self) -&gt; datetime.date:\nreturn self.selectedDate().toPython()\ndef get_value(self) -&gt; datetime.date:\nreturn self.get_date()\ndef set_value(self, value: datatypes.DateType):\nself.setSelectedDate(datatypes.to_date(value))\ndef set_range(\nself,\nlower: datatypes.DateType,\nupper: datatypes.DateType,\n):\nself.setMinimumDate(datatypes.to_date(lower))\nself.setMaximumDate(datatypes.to_date(upper))\ndef set_selection_mode(\nself, mode: SelectionModeStr | QtWidgets.QCalendarWidget.SelectionMode | None\n):\n\"\"\"Set selection mode for given calendar widget.\n        Args:\n            mode: selection mode to use\n        \"\"\"\nif mode is None:\nmode = \"none\"\nself.setSelectionMode(SELECTION_MODE.get_enum_value(mode))\ndef get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n        Returns:\n            selection mode\n        \"\"\"\nreturn SELECTION_MODE.inverse[self.selectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.get_selection_mode","title":"<code>get_selection_mode() -&gt; SelectionModeStr</code>","text":"<p>Return current selection mode.</p> <p>Returns:</p> Type Description <code>SelectionModeStr</code> <p>selection mode</p> Source code in <code>prettyqt\\widgets\\calendarwidget.py</code> <pre><code>def get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n    Returns:\n        selection mode\n    \"\"\"\nreturn SELECTION_MODE.inverse[self.selectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.set_selection_mode","title":"<code>set_selection_mode(mode: SelectionModeStr | QtWidgets.QCalendarWidget.SelectionMode | None)</code>","text":"<p>Set selection mode for given calendar widget.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SelectionModeStr | QtWidgets.QCalendarWidget.SelectionMode | None</code> <p>selection mode to use</p> required Source code in <code>prettyqt\\widgets\\calendarwidget.py</code> <pre><code>def set_selection_mode(\nself, mode: SelectionModeStr | QtWidgets.QCalendarWidget.SelectionMode | None\n):\n\"\"\"Set selection mode for given calendar widget.\n    Args:\n        mode: selection mode to use\n    \"\"\"\nif mode is None:\nmode = \"none\"\nself.setSelectionMode(SELECTION_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.CheckBox","title":"<code>CheckBox</code>","text":"<p>         Bases: <code>widgets.AbstractButtonMixin</code>, <code>QtWidgets.QCheckBox</code></p> Source code in <code>prettyqt\\widgets\\checkbox.py</code> <pre><code>class CheckBox(widgets.AbstractButtonMixin, QtWidgets.QCheckBox):\nvalue_changed = core.Signal(int)\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.stateChanged.connect(self.value_changed)\ndef set_checkstate(self, state: constants.CheckStateStr | constants.CheckState):\n\"\"\"Set checkstate of the checkbox.\n        Args:\n            state: checkstate to use\n        \"\"\"\nself.setCheckState(constants.CHECK_STATE.get_enum_value(state))\ndef get_checkstate(self) -&gt; constants.CheckStateStr:\n\"\"\"Return checkstate.\n        Returns:\n            checkstate\n        \"\"\"\nreturn constants.CHECK_STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.get_checkstate","title":"<code>get_checkstate() -&gt; constants.CheckStateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.CheckStateStr</code> <p>checkstate</p> Source code in <code>prettyqt\\widgets\\checkbox.py</code> <pre><code>def get_checkstate(self) -&gt; constants.CheckStateStr:\n\"\"\"Return checkstate.\n    Returns:\n        checkstate\n    \"\"\"\nreturn constants.CHECK_STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.set_checkstate","title":"<code>set_checkstate(state: constants.CheckStateStr | constants.CheckState)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.CheckStateStr | constants.CheckState</code> <p>checkstate to use</p> required Source code in <code>prettyqt\\widgets\\checkbox.py</code> <pre><code>def set_checkstate(self, state: constants.CheckStateStr | constants.CheckState):\n\"\"\"Set checkstate of the checkbox.\n    Args:\n        state: checkstate to use\n    \"\"\"\nself.setCheckState(constants.CHECK_STATE.get_enum_value(state))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ComboBoxMixin","title":"<code>ComboBoxMixin</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code></p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>class ComboBoxMixin(widgets.WidgetMixin):\nvalue_changed = core.Signal(object)\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.currentIndexChanged.connect(self._index_changed)\ndef __len__(self) -&gt; int:\nreturn self.count()\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"insertPolicy\": INSERT_POLICY,\n\"sizeAdjustPolicy\": SIZE_ADJUST_POLICY,\n}\nreturn maps\n# def __reduce__(self):\n#     return type(self), (), self.__getstate__()\ndef _index_changed(self, index: int):\n# data = self.itemData(index)\ndata = self.get_value()\nself.value_changed.emit(data)\ndef add_items(\nself, items: Iterable[str | tuple | list] | Mapping[Any, str], default=...\n):\nif isinstance(items, Mapping):\nfor k, v in items.items():\nself.addItem(v, userData=k)\nelse:\nfor i in items:\nif isinstance(i, tuple | list):\nself.add(*i)\nelse:\nself.addItem(i, i)\nif default is not ...:\nself.set_value(default)\ndef add(self, label: str, data=..., icon: datatypes.IconType = None):\nif data is ...:\ndata = label\nif icon is not None:\nicon = iconprovider.get_icon(icon)\nself.addItem(gui.Icon(icon), label, userData=data)\nelse:\nself.addItem(label, userData=data)\ndef get_item_icon(self, index: int) -&gt; gui.Icon | None:\nicon = self.itemIcon(index)\nreturn None if icon.isNull() else gui.Icon(icon)\ndef set_editable(self, editable: bool):\nself.setEditable(editable)\nif self.completer() is None and editable:\nself.setCompleter(widgets.Completer(self))\ndef set_insert_policy(self, policy: InsertPolicyStr | mod.InsertPolicy):\n\"\"\"Set insert policy.\n        Args:\n            policy: insert policy to use\n        \"\"\"\nself.setInsertPolicy(INSERT_POLICY.get_enum_value(policy))\ndef get_insert_policy(self) -&gt; InsertPolicyStr:\n\"\"\"Return insert policy.\n        Returns:\n            insert policy\n        \"\"\"\nreturn INSERT_POLICY.inverse[self.insertPolicy()]\ndef set_size_adjust_policy(self, policy: SizeAdjustPolicyStr | mod.SizeAdjustPolicy):\n\"\"\"Set size adjust policy.\n        Args:\n            policy: size adjust policy to use\n        \"\"\"\nself.setSizeAdjustPolicy(SIZE_ADJUST_POLICY.get_enum_value(policy))\ndef get_size_adjust_policy(self) -&gt; SizeAdjustPolicyStr:\n\"\"\"Return size adjust policy.\n        Returns:\n            size adjust policy\n        \"\"\"\nreturn SIZE_ADJUST_POLICY.inverse[self.sizeAdjustPolicy()]\ndef set_icon_size(self, size: datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\nself.setIconSize(datatypes.to_size(size))\ndef get_icon_size(self) -&gt; core.Size:\nreturn core.Size(self.iconSize())\ndef set_min_char_length(self, chars: int):\nself.setMinimumContentsLength(chars)\ndef get_value(self) -&gt; Any:\n# if all(self.itemData(i) is None for i in range(self.count())):\n#     return self.currentText()\n# else:\n#     return self.currentData()\nreturn self.currentData()\ndef set_value(self, value: Any):\nself.set_data(value)\ndef set_text(self, text: str):\nself.setCurrentText(text)\ndef set_data(self, data: Any):\nidx = self.findData(data)\nif idx == -1:\nraise ValueError(\"invalid data\")\nself.setCurrentIndex(idx)\ndef text(self) -&gt; str:\nreturn self.currentText()\ndef hide_completer(self):\n\"\"\"Hides the completion widget.\"\"\"\ncompleter = widgets.Completer(self)\nself.setCompleter(completer)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.get_insert_policy","title":"<code>get_insert_policy() -&gt; InsertPolicyStr</code>","text":"<p>Return insert policy.</p> <p>Returns:</p> Type Description <code>InsertPolicyStr</code> <p>insert policy</p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def get_insert_policy(self) -&gt; InsertPolicyStr:\n\"\"\"Return insert policy.\n    Returns:\n        insert policy\n    \"\"\"\nreturn INSERT_POLICY.inverse[self.insertPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.get_size_adjust_policy","title":"<code>get_size_adjust_policy() -&gt; SizeAdjustPolicyStr</code>","text":"<p>Return size adjust policy.</p> <p>Returns:</p> Type Description <code>SizeAdjustPolicyStr</code> <p>size adjust policy</p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def get_size_adjust_policy(self) -&gt; SizeAdjustPolicyStr:\n\"\"\"Return size adjust policy.\n    Returns:\n        size adjust policy\n    \"\"\"\nreturn SIZE_ADJUST_POLICY.inverse[self.sizeAdjustPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.hide_completer","title":"<code>hide_completer()</code>","text":"<p>Hides the completion widget.</p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def hide_completer(self):\n\"\"\"Hides the completion widget.\"\"\"\ncompleter = widgets.Completer(self)\nself.setCompleter(completer)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.set_icon_size","title":"<code>set_icon_size(size: datatypes.SizeType)</code>","text":"<p>Set size of the icons.</p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def set_icon_size(self, size: datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\nself.setIconSize(datatypes.to_size(size))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.set_insert_policy","title":"<code>set_insert_policy(policy: InsertPolicyStr | mod.InsertPolicy)</code>","text":"<p>Set insert policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>InsertPolicyStr | mod.InsertPolicy</code> <p>insert policy to use</p> required Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def set_insert_policy(self, policy: InsertPolicyStr | mod.InsertPolicy):\n\"\"\"Set insert policy.\n    Args:\n        policy: insert policy to use\n    \"\"\"\nself.setInsertPolicy(INSERT_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.set_size_adjust_policy","title":"<code>set_size_adjust_policy(policy: SizeAdjustPolicyStr | mod.SizeAdjustPolicy)</code>","text":"<p>Set size adjust policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizeAdjustPolicyStr | mod.SizeAdjustPolicy</code> <p>size adjust policy to use</p> required Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def set_size_adjust_policy(self, policy: SizeAdjustPolicyStr | mod.SizeAdjustPolicy):\n\"\"\"Set size adjust policy.\n    Args:\n        policy: size adjust policy to use\n    \"\"\"\nself.setSizeAdjustPolicy(SIZE_ADJUST_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.Completer","title":"<code>Completer</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>widgets.QCompleter</code></p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>class Completer(core.ObjectMixin, widgets.QCompleter):\npath_updated = core.Signal(str)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"caseSensitivity\": constants.CASE_SENSITIVITY,\n\"completionMode\": COMPLETION_MODE,\n\"modelSorting\": SORT_MODE,\n\"filterMode\": constants.MATCH_FLAGS,\n}\nreturn maps\ndef splitPath(self, path: str) -&gt; list[str]:\nself.path_updated.emit(path)\nreturn super().splitPath(path)\ndef get_completions(self) -&gt; list[str]:\ncompletions = []\n# count = self.completionCount()\n# for i in range(count):\n#     self.setCurrentRow(i)\n#     completions.append(self.currentCompletion())\n# according to docs, completionCount should be avoided. Not sure if thats true.\ni = 0\nwhile self.setCurrentRow(i):\ncompletions.append(self.currentCompletion())\ni += 1\nreturn completions\ndef set_strings(self, strings: list[str]):\nmodel = core.StringListModel(strings)\nself.setModel(model)\ndef set_sort_mode(self, mode: SortModeStr | widgets.QCompleter.ModelSorting | None):\n\"\"\"Set sort mode to use.\n        Args:\n            mode: sort mode to use\n        \"\"\"\nif mode is None:\nmode = \"unsorted\"\nself.setModelSorting(SORT_MODE.get_enum_value(mode))\ndef get_sort_mode(self) -&gt; SortModeStr:\n\"\"\"Return current sort mode.\n        Returns:\n            sort mode\n        \"\"\"\nreturn SORT_MODE.inverse[self.modelSorting()]\ndef set_completion_mode(\nself, mode: CompletionModeStr | widgets.QCompleter.CompletionMode\n):\n\"\"\"Set completion mode to use.\n        Args:\n            mode: completion mode to use\n        \"\"\"\nself.setCompletionMode(COMPLETION_MODE.get_enum_value(mode))\ndef get_completion_mode(self) -&gt; CompletionModeStr:\n\"\"\"Return current completion mode.\n        Returns:\n            completion mode\n        \"\"\"\nreturn COMPLETION_MODE.inverse[self.completionMode()]\ndef set_filter_mode(self, mode: constants.FilterModeStr | constants.MatchFlag):\n\"\"\"Set filter mode to use.\n        Args:\n            mode: filter mode to use\n        \"\"\"\nself.setFilterMode(constants.FILTER_MODES.get_enum_value(mode))\ndef get_filter_mode(self) -&gt; constants.FilterModeStr:\n\"\"\"Return current filter mode.\n        Returns:\n            filter mode\n        \"\"\"\nreturn constants.FILTER_MODES.inverse[self.filterMode()]\ndef set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n        Args:\n            state: case sensitive\n        \"\"\"\nsensitivity = (\nconstants.CaseSensitivity.CaseSensitive\nif state\nelse constants.CaseSensitivity.CaseInsensitive\n)\nself.setCaseSensitivity(sensitivity)\ndef is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n        Returns:\n            case sensitivity\n        \"\"\"\nreturn self.caseSensitivity() == constants.CaseSensitivity.CaseSensitive\ndef set_completion_role(\nself, role: constants.ItemDataRoleStr | constants.ItemDataRole | int\n):\nrole = constants.ITEM_DATA_ROLE[role] if isinstance(role, str) else role\nself.setCompletionRole(role)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_completion_mode","title":"<code>get_completion_mode() -&gt; CompletionModeStr</code>","text":"<p>Return current completion mode.</p> <p>Returns:</p> Type Description <code>CompletionModeStr</code> <p>completion mode</p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def get_completion_mode(self) -&gt; CompletionModeStr:\n\"\"\"Return current completion mode.\n    Returns:\n        completion mode\n    \"\"\"\nreturn COMPLETION_MODE.inverse[self.completionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_filter_mode","title":"<code>get_filter_mode() -&gt; constants.FilterModeStr</code>","text":"<p>Return current filter mode.</p> <p>Returns:</p> Type Description <code>constants.FilterModeStr</code> <p>filter mode</p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def get_filter_mode(self) -&gt; constants.FilterModeStr:\n\"\"\"Return current filter mode.\n    Returns:\n        filter mode\n    \"\"\"\nreturn constants.FILTER_MODES.inverse[self.filterMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_sort_mode","title":"<code>get_sort_mode() -&gt; SortModeStr</code>","text":"<p>Return current sort mode.</p> <p>Returns:</p> Type Description <code>SortModeStr</code> <p>sort mode</p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def get_sort_mode(self) -&gt; SortModeStr:\n\"\"\"Return current sort mode.\n    Returns:\n        sort mode\n    \"\"\"\nreturn SORT_MODE.inverse[self.modelSorting()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.is_case_sensitive","title":"<code>is_case_sensitive() -&gt; bool</code>","text":"<p>Return case sensitivity.</p> <p>Returns:</p> Type Description <code>bool</code> <p>case sensitivity</p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n    Returns:\n        case sensitivity\n    \"\"\"\nreturn self.caseSensitivity() == constants.CaseSensitivity.CaseSensitive\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_case_sensitive","title":"<code>set_case_sensitive(state: bool)</code>","text":"<p>Set case sensitivity.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>case sensitive</p> required Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n    Args:\n        state: case sensitive\n    \"\"\"\nsensitivity = (\nconstants.CaseSensitivity.CaseSensitive\nif state\nelse constants.CaseSensitivity.CaseInsensitive\n)\nself.setCaseSensitivity(sensitivity)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_completion_mode","title":"<code>set_completion_mode(mode: CompletionModeStr | widgets.QCompleter.CompletionMode)</code>","text":"<p>Set completion mode to use.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CompletionModeStr | widgets.QCompleter.CompletionMode</code> <p>completion mode to use</p> required Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def set_completion_mode(\nself, mode: CompletionModeStr | widgets.QCompleter.CompletionMode\n):\n\"\"\"Set completion mode to use.\n    Args:\n        mode: completion mode to use\n    \"\"\"\nself.setCompletionMode(COMPLETION_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_filter_mode","title":"<code>set_filter_mode(mode: constants.FilterModeStr | constants.MatchFlag)</code>","text":"<p>Set filter mode to use.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.FilterModeStr | constants.MatchFlag</code> <p>filter mode to use</p> required Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def set_filter_mode(self, mode: constants.FilterModeStr | constants.MatchFlag):\n\"\"\"Set filter mode to use.\n    Args:\n        mode: filter mode to use\n    \"\"\"\nself.setFilterMode(constants.FILTER_MODES.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_sort_mode","title":"<code>set_sort_mode(mode: SortModeStr | widgets.QCompleter.ModelSorting | None)</code>","text":"<p>Set sort mode to use.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SortModeStr | widgets.QCompleter.ModelSorting | None</code> <p>sort mode to use</p> required Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def set_sort_mode(self, mode: SortModeStr | widgets.QCompleter.ModelSorting | None):\n\"\"\"Set sort mode to use.\n    Args:\n        mode: sort mode to use\n    \"\"\"\nif mode is None:\nmode = \"unsorted\"\nself.setModelSorting(SORT_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.DataWidgetMapper","title":"<code>DataWidgetMapper</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>widgets.QDataWidgetMapper</code></p> Source code in <code>prettyqt\\widgets\\datawidgetmapper.py</code> <pre><code>class DataWidgetMapper(core.ObjectMixin, widgets.QDataWidgetMapper):\ndef __setitem__(self, key: int, value: widgets.QWidget):\nself.addMapping(value, key)\ndef __getitem__(self, key: int) -&gt; widgets.QWidget:\nreturn self.mappedWidgetAt(key)\ndef __delitem__(self, key_or_widget: int | widgets.QWidget):\nwidget = (\nself.mappedWidgetAt(key_or_widget)\nif isinstance(key_or_widget, int)\nelse key_or_widget\n)\nself.removeMapping(widget)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"submitPolicy\": SUBMIT_POLICY, \"orientation\": constants.ORIENTATION}\nreturn maps\ndef set_orientation(\nself, orientation: constants.OrientationStr | constants.Orientation\n):\n\"\"\"Set the orientation of the data widget mapper.\n        Args:\n            orientation: orientation for the data widget mapper\n        \"\"\"\nself.setOrientation(constants.ORIENTATION.get_enum_value(orientation))\ndef get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n        Returns:\n            orientation\n        \"\"\"\nreturn constants.ORIENTATION.inverse[self.orientation()]\ndef set_submit_policy(\nself, policy: SubmitPolicyStr | widgets.QDataWidgetMapper.SubmitPolicy\n):\n\"\"\"Set the submit policy of the mapper.\n        Args:\n            policy: submit_policy for the data widget mapper\n        \"\"\"\nself.setSubmitPolicy(SUBMIT_POLICY.get_enum_value(policy))\ndef get_submit_policy(self) -&gt; SubmitPolicyStr:\n\"\"\"Return current submit policy.\n        Returns:\n            submit policy\n        \"\"\"\nreturn SUBMIT_POLICY.inverse[self.submitPolicy()]\ndef add_mapping(\nself, widget: widgets.QWidget, section: int, property_name: str | None = None\n):\nif property_name is None:\nself.addMapping(widget, section)\nelse:\nba = core.QByteArray(property_name.encode())\nself.addMapping(widget, section, ba)\ndef get_mapped_property_name(self, widget: widgets.QWidget) -&gt; str:\nreturn self.mappedPropertyName(widget).data().decode()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\widgets\\datawidgetmapper.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n    Returns:\n        orientation\n    \"\"\"\nreturn constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_submit_policy","title":"<code>get_submit_policy() -&gt; SubmitPolicyStr</code>","text":"<p>Return current submit policy.</p> <p>Returns:</p> Type Description <code>SubmitPolicyStr</code> <p>submit policy</p> Source code in <code>prettyqt\\widgets\\datawidgetmapper.py</code> <pre><code>def get_submit_policy(self) -&gt; SubmitPolicyStr:\n\"\"\"Return current submit policy.\n    Returns:\n        submit policy\n    \"\"\"\nreturn SUBMIT_POLICY.inverse[self.submitPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_orientation","title":"<code>set_orientation(orientation: constants.OrientationStr | constants.Orientation)</code>","text":"<p>Set the orientation of the data widget mapper.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr | constants.Orientation</code> <p>orientation for the data widget mapper</p> required Source code in <code>prettyqt\\widgets\\datawidgetmapper.py</code> <pre><code>def set_orientation(\nself, orientation: constants.OrientationStr | constants.Orientation\n):\n\"\"\"Set the orientation of the data widget mapper.\n    Args:\n        orientation: orientation for the data widget mapper\n    \"\"\"\nself.setOrientation(constants.ORIENTATION.get_enum_value(orientation))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_submit_policy","title":"<code>set_submit_policy(policy: SubmitPolicyStr | widgets.QDataWidgetMapper.SubmitPolicy)</code>","text":"<p>Set the submit policy of the mapper.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SubmitPolicyStr | widgets.QDataWidgetMapper.SubmitPolicy</code> <p>submit_policy for the data widget mapper</p> required Source code in <code>prettyqt\\widgets\\datawidgetmapper.py</code> <pre><code>def set_submit_policy(\nself, policy: SubmitPolicyStr | widgets.QDataWidgetMapper.SubmitPolicy\n):\n\"\"\"Set the submit policy of the mapper.\n    Args:\n        policy: submit_policy for the data widget mapper\n    \"\"\"\nself.setSubmitPolicy(SUBMIT_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.DialogButtonBox","title":"<code>DialogButtonBox</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QDialogButtonBox</code></p> Source code in <code>prettyqt\\widgets\\dialogbuttonbox.py</code> <pre><code>class DialogButtonBox(widgets.WidgetMixin, QtWidgets.QDialogButtonBox):\nbutton_clicked = core.Signal(str)\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.clicked.connect(self.on_click)\ndef __len__(self) -&gt; int:\nreturn len(self.buttons())\ndef __getitem__(self, index: StandardButtonStr) -&gt; QtWidgets.QPushButton:\nreturn self.button(STANDARD_BUTTON[index])\ndef __iter__(self) -&gt; Iterator[QtWidgets.QAbstractButton]:\nreturn iter(self.buttons())\ndef __contains__(self, index: StandardButtonStr):\nreturn self.button(STANDARD_BUTTON[index]) is not None\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"orientation\": constants.ORIENTATION,\n\"standardButtons\": STANDARD_BUTTON,\n}\nreturn maps\n@classmethod\ndef create(cls, **kwargs) -&gt; Self:\nbox = cls()\nfor k, v in kwargs.items():\nbox.add_default_button(k, callback=v)  # type: ignore\nreturn box\ndef on_click(self, button: QtCore.QObject):\nself.button_clicked.emit(button.objectName())\ndef set_horizontal(self):\nself.setOrientation(constants.HORIZONTAL)\ndef set_vertical(self):\nself.setOrientation(constants.VERTICAL)\ndef set_orientation(\nself, orientation: constants.OrientationStr | constants.Orientation\n):\n\"\"\"Set the orientation of the button box.\n        Args:\n            orientation: orientation for the button box\n        \"\"\"\nself.setOrientation(constants.ORIENTATION.get_enum_value(orientation))\ndef get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n        Returns:\n            orientation\n        \"\"\"\nreturn constants.ORIENTATION.inverse[self.orientation()]\ndef add_default_buttons(\nself, buttons: Sequence[StandardButtonStr]\n) -&gt; listdelegators.BaseListDelegator[QtWidgets.QPushButton]:\nreturn [self.add_default_button(btn) for btn in buttons]\ndef add_default_button(\nself,\nbutton: StandardButtonStr | QtWidgets.QDialogButtonBox.StandardButton,\ncallback: Callable | None = None,\n) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n        Args:\n            button: button to add\n            callback: function to call when button gets clicked\n        Returns:\n            created button\n        \"\"\"\nbtn = super().addButton(STANDARD_BUTTON.get_enum_value(button))\nbtn.setObjectName(button)\nif callback:\nbtn.clicked.connect(callback)\nreturn btn\ndef add_button(\nself,\nbutton: QtWidgets.QPushButton | str,\nrole: RoleStr | QtWidgets.QDialogButtonBox.ButtonRole = \"accept\",\ncallback: Callable | None = None,\n) -&gt; widgets.QPushButton:\n\"\"\"Add a button.\n        Args:\n            button: button to add\n            role: role of the button\n            callback: function to call when button gets clicked\n        Returns:\n            created button\n        \"\"\"\nif isinstance(button, str):\nbutton = widgets.PushButton(button)\nself.addButton(button, ROLES.get_enum_value(role))\nif callback:\nbutton.clicked.connect(callback)\nreturn button\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_button","title":"<code>add_button(button: QtWidgets.QPushButton | str, role: RoleStr | QtWidgets.QDialogButtonBox.ButtonRole = 'accept', callback: Callable | None = None) -&gt; widgets.QPushButton</code>","text":"<p>Add a button.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>QtWidgets.QPushButton | str</code> <p>button to add</p> required <code>role</code> <code>RoleStr | QtWidgets.QDialogButtonBox.ButtonRole</code> <p>role of the button</p> <code>'accept'</code> <code>callback</code> <code>Callable | None</code> <p>function to call when button gets clicked</p> <code>None</code> <p>Returns:</p> Type Description <code>widgets.QPushButton</code> <p>created button</p> Source code in <code>prettyqt\\widgets\\dialogbuttonbox.py</code> <pre><code>def add_button(\nself,\nbutton: QtWidgets.QPushButton | str,\nrole: RoleStr | QtWidgets.QDialogButtonBox.ButtonRole = \"accept\",\ncallback: Callable | None = None,\n) -&gt; widgets.QPushButton:\n\"\"\"Add a button.\n    Args:\n        button: button to add\n        role: role of the button\n        callback: function to call when button gets clicked\n    Returns:\n        created button\n    \"\"\"\nif isinstance(button, str):\nbutton = widgets.PushButton(button)\nself.addButton(button, ROLES.get_enum_value(role))\nif callback:\nbutton.clicked.connect(callback)\nreturn button\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_default_button","title":"<code>add_default_button(button: StandardButtonStr | QtWidgets.QDialogButtonBox.StandardButton, callback: Callable | None = None) -&gt; QtWidgets.QPushButton</code>","text":"<p>Add a default button.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>StandardButtonStr | QtWidgets.QDialogButtonBox.StandardButton</code> <p>button to add</p> required <code>callback</code> <code>Callable | None</code> <p>function to call when button gets clicked</p> <code>None</code> <p>Returns:</p> Type Description <code>QtWidgets.QPushButton</code> <p>created button</p> Source code in <code>prettyqt\\widgets\\dialogbuttonbox.py</code> <pre><code>def add_default_button(\nself,\nbutton: StandardButtonStr | QtWidgets.QDialogButtonBox.StandardButton,\ncallback: Callable | None = None,\n) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n    Args:\n        button: button to add\n        callback: function to call when button gets clicked\n    Returns:\n        created button\n    \"\"\"\nbtn = super().addButton(STANDARD_BUTTON.get_enum_value(button))\nbtn.setObjectName(button)\nif callback:\nbtn.clicked.connect(callback)\nreturn btn\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\widgets\\dialogbuttonbox.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n    Returns:\n        orientation\n    \"\"\"\nreturn constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.set_orientation","title":"<code>set_orientation(orientation: constants.OrientationStr | constants.Orientation)</code>","text":"<p>Set the orientation of the button box.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr | constants.Orientation</code> <p>orientation for the button box</p> required Source code in <code>prettyqt\\widgets\\dialogbuttonbox.py</code> <pre><code>def set_orientation(\nself, orientation: constants.OrientationStr | constants.Orientation\n):\n\"\"\"Set the orientation of the button box.\n    Args:\n        orientation: orientation for the button box\n    \"\"\"\nself.setOrientation(constants.ORIENTATION.get_enum_value(orientation))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.FileDialog","title":"<code>FileDialog</code>","text":"<p>         Bases: <code>widgets.DialogMixin</code>, <code>QtWidgets.QFileDialog</code></p> <p>Simple dialog used to display some widget.</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>class FileDialog(widgets.DialogMixin, QtWidgets.QFileDialog):\n\"\"\"Simple dialog used to display some widget.\"\"\"\ndef __init__(\nself,\npath: None | datatypes.PathType = None,\nmode: AcceptModeStr = \"open\",\ncaption: str | None = None,\npath_id: str | None = None,\nextension_filter: dict | None = None,\nfile_mode: FileModeStr = \"existing_files\",\n**kwargs,\n):\nsuper().__init__(**kwargs)\nself.set_title(caption)\nself.path_id = path_id\nif extension_filter:\nself.set_extension_filter(extension_filter)\nif path_id is not None and path is None:\nsettings = core.Settings()\npath = settings.get(path_id, \"\")\nif path is not None:\nself.set_directory(path)\nself.set_file_mode(file_mode)\nself.set_accept_mode(mode)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"acceptMode\": ACCEPT_MODE,\n\"fileMode\": FILE_MODE,\n\"viewMode\": VIEW_MODE,\n}\nreturn maps\ndef set_accept_mode(self, mode: AcceptModeStr | QtWidgets.QFileDialog.AcceptMode):\n\"\"\"Set accept mode.\n        Args:\n            mode: accept mode to use\n        \"\"\"\nself.setAcceptMode(ACCEPT_MODE.get_enum_value(mode))\ndef get_accept_mode(self) -&gt; AcceptModeStr:\n\"\"\"Return accept mode.\n        Returns:\n            accept mode\n        \"\"\"\nreturn ACCEPT_MODE.inverse[self.acceptMode()]\ndef set_view_mode(self, mode: ViewModeStr | QtWidgets.QFileDialog.ViewMode):\n\"\"\"Set view mode.\n        Args:\n            mode: view mode to use\n        \"\"\"\nself.setViewMode(VIEW_MODE.get_enum_value(mode))\ndef get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n        Returns:\n            view mode\n        \"\"\"\nreturn VIEW_MODE.inverse[self.viewMode()]\ndef set_label_text(\nself, label: LabelStr | QtWidgets.QFileDialog.DialogLabel, text: str\n):\n\"\"\"Set the label text for button label.\n        Args:\n            label: button to set text for\n            text: text to use\n        \"\"\"\nself.setLabelText(LABEL.get_enum_value(label), text)\ndef get_label_text(self, label: LabelStr | QtWidgets.QFileDialog.DialogLabel) -&gt; str:\n\"\"\"Return label text.\n        Returns:\n            label text\n        \"\"\"\nreturn self.labelText(LABEL.get_enum_value(label))\ndef get_file_mode(self) -&gt; FileModeStr:\n\"\"\"Return file mode.\n        Returns:\n            file mode\n        \"\"\"\nreturn FILE_MODE.inverse[self.fileMode()]\ndef set_file_mode(self, mode: FileModeStr | QtWidgets.QFileDialog.FileMode):\n\"\"\"Set the file mode of the dialog.\n        Args:\n            mode: mode to use\n        \"\"\"\nself.setFileMode(FILE_MODE.get_enum_value(mode))\ndef selected_files(self) -&gt; list[pathlib.Path]:\nreturn [pathlib.Path(p) for p in self.selectedFiles()]\ndef selected_file(self) -&gt; pathlib.Path | None:\nselected = self.selectedFiles()\nreturn pathlib.Path(selected[0]) if selected else None\ndef choose_folder(self) -&gt; list[pathlib.Path] | None:\nself.set_file_mode(\"directory\")\nreturn self.choose()\ndef open_file(self) -&gt; list[pathlib.Path] | None:\nself.set_file_mode(\"existing_file\")\nreturn self.choose()\ndef choose(self) -&gt; list[pathlib.Path] | None:\nresult = self.exec()\nif result != self.DialogCode.Accepted:\nreturn None\npaths = self.selected_files()\nif self.path_id:\nsettings = core.Settings()\nfolder_path = paths[0].parent\nsettings.setValue(self.path_id, str(folder_path))\nreturn paths\ndef set_extension_filter(self, extension_dict: dict[str, list[str]]):\n\"\"\"Set filter based on given dictionary.\n        dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs\n        Args:\n            extension_dict: filter dictionary\n        \"\"\"\nitems = [\nf\"{k} ({' '.join(f'*{ext}' for ext in v)})\" for k, v in extension_dict.items()\n]\nfilter_str = \";;\".join(items)\nself.setNameFilter(filter_str)\ndef get_directory(self) -&gt; pathlib.Path:\n\"\"\"Return current directory.\n        returns current directory level as a Pathlib object\n        Returns:\n            Pathlib object\n        \"\"\"\nreturn pathlib.Path(self.directory().absolutePath())\ndef set_directory(self, path: datatypes.PathType):\n\"\"\"Set start directory.\"\"\"\npath = os.fspath(path)\nself.setDirectory(path)\ndef set_filter(self, *filters: core.dir.FilterStr):\nflags = core.dir.FILTERS.merge_flags(filters)\nself.setFilter(flags)\ndef get_filter(self) -&gt; list[core.dir.FilterStr]:\nreturn core.dir.FILTERS.get_list(self.filter())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_accept_mode","title":"<code>get_accept_mode() -&gt; AcceptModeStr</code>","text":"<p>Return accept mode.</p> <p>Returns:</p> Type Description <code>AcceptModeStr</code> <p>accept mode</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def get_accept_mode(self) -&gt; AcceptModeStr:\n\"\"\"Return accept mode.\n    Returns:\n        accept mode\n    \"\"\"\nreturn ACCEPT_MODE.inverse[self.acceptMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_directory","title":"<code>get_directory() -&gt; pathlib.Path</code>","text":"<p>Return current directory.</p> <p>returns current directory level as a Pathlib object</p> <p>Returns:</p> Type Description <code>pathlib.Path</code> <p>Pathlib object</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def get_directory(self) -&gt; pathlib.Path:\n\"\"\"Return current directory.\n    returns current directory level as a Pathlib object\n    Returns:\n        Pathlib object\n    \"\"\"\nreturn pathlib.Path(self.directory().absolutePath())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_file_mode","title":"<code>get_file_mode() -&gt; FileModeStr</code>","text":"<p>Return file mode.</p> <p>Returns:</p> Type Description <code>FileModeStr</code> <p>file mode</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def get_file_mode(self) -&gt; FileModeStr:\n\"\"\"Return file mode.\n    Returns:\n        file mode\n    \"\"\"\nreturn FILE_MODE.inverse[self.fileMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_label_text","title":"<code>get_label_text(label: LabelStr | QtWidgets.QFileDialog.DialogLabel) -&gt; str</code>","text":"<p>Return label text.</p> <p>Returns:</p> Type Description <code>str</code> <p>label text</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def get_label_text(self, label: LabelStr | QtWidgets.QFileDialog.DialogLabel) -&gt; str:\n\"\"\"Return label text.\n    Returns:\n        label text\n    \"\"\"\nreturn self.labelText(LABEL.get_enum_value(label))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_view_mode","title":"<code>get_view_mode() -&gt; ViewModeStr</code>","text":"<p>Return view mode.</p> <p>Returns:</p> Type Description <code>ViewModeStr</code> <p>view mode</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n    Returns:\n        view mode\n    \"\"\"\nreturn VIEW_MODE.inverse[self.viewMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_accept_mode","title":"<code>set_accept_mode(mode: AcceptModeStr | QtWidgets.QFileDialog.AcceptMode)</code>","text":"<p>Set accept mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>AcceptModeStr | QtWidgets.QFileDialog.AcceptMode</code> <p>accept mode to use</p> required Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_accept_mode(self, mode: AcceptModeStr | QtWidgets.QFileDialog.AcceptMode):\n\"\"\"Set accept mode.\n    Args:\n        mode: accept mode to use\n    \"\"\"\nself.setAcceptMode(ACCEPT_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_directory","title":"<code>set_directory(path: datatypes.PathType)</code>","text":"<p>Set start directory.</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_directory(self, path: datatypes.PathType):\n\"\"\"Set start directory.\"\"\"\npath = os.fspath(path)\nself.setDirectory(path)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_extension_filter","title":"<code>set_extension_filter(extension_dict: dict[str, list[str]])</code>","text":"<p>Set filter based on given dictionary.</p> <p>dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs</p> <p>Parameters:</p> Name Type Description Default <code>extension_dict</code> <code>dict[str, list[str]]</code> <p>filter dictionary</p> required Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_extension_filter(self, extension_dict: dict[str, list[str]]):\n\"\"\"Set filter based on given dictionary.\n    dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs\n    Args:\n        extension_dict: filter dictionary\n    \"\"\"\nitems = [\nf\"{k} ({' '.join(f'*{ext}' for ext in v)})\" for k, v in extension_dict.items()\n]\nfilter_str = \";;\".join(items)\nself.setNameFilter(filter_str)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_file_mode","title":"<code>set_file_mode(mode: FileModeStr | QtWidgets.QFileDialog.FileMode)</code>","text":"<p>Set the file mode of the dialog.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>FileModeStr | QtWidgets.QFileDialog.FileMode</code> <p>mode to use</p> required Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_file_mode(self, mode: FileModeStr | QtWidgets.QFileDialog.FileMode):\n\"\"\"Set the file mode of the dialog.\n    Args:\n        mode: mode to use\n    \"\"\"\nself.setFileMode(FILE_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_label_text","title":"<code>set_label_text(label: LabelStr | QtWidgets.QFileDialog.DialogLabel, text: str)</code>","text":"<p>Set the label text for button label.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>LabelStr | QtWidgets.QFileDialog.DialogLabel</code> <p>button to set text for</p> required <code>text</code> <code>str</code> <p>text to use</p> required Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_label_text(\nself, label: LabelStr | QtWidgets.QFileDialog.DialogLabel, text: str\n):\n\"\"\"Set the label text for button label.\n    Args:\n        label: button to set text for\n        text: text to use\n    \"\"\"\nself.setLabelText(LABEL.get_enum_value(label), text)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_view_mode","title":"<code>set_view_mode(mode: ViewModeStr | QtWidgets.QFileDialog.ViewMode)</code>","text":"<p>Set view mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewModeStr | QtWidgets.QFileDialog.ViewMode</code> <p>view mode to use</p> required Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_view_mode(self, mode: ViewModeStr | QtWidgets.QFileDialog.ViewMode):\n\"\"\"Set view mode.\n    Args:\n        mode: view mode to use\n    \"\"\"\nself.setViewMode(VIEW_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.FontComboBox","title":"<code>FontComboBox</code>","text":"<p>         Bases: <code>widgets.ComboBoxMixin</code>, <code>QtWidgets.QFontComboBox</code></p> Source code in <code>prettyqt\\widgets\\fontcombobox.py</code> <pre><code>class FontComboBox(widgets.ComboBoxMixin, QtWidgets.QFontComboBox):\nvalue_changed = core.Signal(gui.QFont)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"fontFilters\": FONT_FILTERS,\n\"writingSystem\": gui.fontdatabase.WRITING_SYSTEM,\n}\nreturn maps\ndef set_font_filters(self, *filters: FontFilterStr):\n\"\"\"Set font filters.\n        Args:\n            filters: font filters to use\n        \"\"\"\nif not filters:\nfilters = (\"all\",)\nflags = FONT_FILTERS.merge_flags(filters)\nself.setFontFilters(flags)\ndef get_font_filters(self) -&gt; list[FontFilterStr]:\n\"\"\"Return list of font filters.\n        Returns:\n            font filter list\n        \"\"\"\nreturn FONT_FILTERS.get_list(self.fontFilters())\ndef set_value(self, value: QtGui.QFont):\nself.setCurrentFont(value)\ndef get_value(self) -&gt; gui.QFont:\nreturn gui.QFont(self.get_current_font())\ndef get_current_font(self) -&gt; gui.Font:\nreturn gui.Font(self.currentFont())\n# without this, the user property would be currentText, which is not what we want.\n# PyQt6 doesnt like gui.Font here.\nvalue = core.Property(QtGui.QFont, get_value, set_value, user=True)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.get_font_filters","title":"<code>get_font_filters() -&gt; list[FontFilterStr]</code>","text":"<p>Return list of font filters.</p> <p>Returns:</p> Type Description <code>list[FontFilterStr]</code> <p>font filter list</p> Source code in <code>prettyqt\\widgets\\fontcombobox.py</code> <pre><code>def get_font_filters(self) -&gt; list[FontFilterStr]:\n\"\"\"Return list of font filters.\n    Returns:\n        font filter list\n    \"\"\"\nreturn FONT_FILTERS.get_list(self.fontFilters())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.set_font_filters","title":"<code>set_font_filters(*filters: FontFilterStr)</code>","text":"<p>Set font filters.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>FontFilterStr</code> <p>font filters to use</p> <code>()</code> Source code in <code>prettyqt\\widgets\\fontcombobox.py</code> <pre><code>def set_font_filters(self, *filters: FontFilterStr):\n\"\"\"Set font filters.\n    Args:\n        filters: font filters to use\n    \"\"\"\nif not filters:\nfilters = (\"all\",)\nflags = FONT_FILTERS.merge_flags(filters)\nself.setFontFilters(flags)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.FormLayout","title":"<code>FormLayout</code>","text":"<p>         Bases: <code>widgets.LayoutMixin</code>, <code>QtWidgets.QFormLayout</code></p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>class FormLayout(widgets.LayoutMixin, QtWidgets.QFormLayout):\nID = \"form\"\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.set_size_constraint(\"maximum\")\nself.setVerticalSpacing(8)\ndef __setitem__(\nself, index: int | tuple[int, ItemRoleStr], value: str | QtWidgets.QWidget\n):\nmatch index:\ncase (int() as row, str() as role):\nself.set_widget(value, row, role)\ncase int() as row:\nself.set_widget(value, row, \"both\")\ncase _:\nraise TypeError(index)\ndef __delitem__(self, index: int):\nself.removeRow(index)\ndef __iter__(self) -&gt; Iterator[QtWidgets.QWidget | QtWidgets.QLayout]:\nreturn iter(self[i] for i in range(self.count()) if self[i] is not None)\ndef __len__(self) -&gt; int:\n\"\"\"Needed for PySide2.\"\"\"\nreturn self.rowCount()\ndef __add__(self, other: QtWidgets.QWidget | QtWidgets.QLayout | tuple):\nself.add(other)\nreturn self\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"FieldGrowthPolicy\": FIELD_GROWTH_POLICY,\n\"formAlignment\": constants.ALIGNMENTS,\n\"labelAlignment\": constants.ALIGNMENTS,\n\"rowWrapPolicy\": ROW_WRAP_POLICY,\n}\nreturn maps\ndef set_form_alignment(\nself, alignment: constants.AlignmentStr | constants.AlignmentFlag\n):\n\"\"\"Set the alignment of the form.\n        Args:\n            alignment: alignment for the form\n        \"\"\"\nself.setFormAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\ndef get_form_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current form alignment.\n        Returns:\n            form alignment\n        \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.formAlignment()]\ndef set_label_alignment(\nself, alignment: constants.AlignmentStr | constants.AlignmentFlag\n):\n\"\"\"Set the alignment of the label.\n        Args:\n            alignment: alignment for the label\n        \"\"\"\nself.setFormAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\ndef get_label_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current label alignment.\n        Returns:\n            label alignment\n        \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.labelAlignment()]\ndef set_widget(\nself,\nwidget: str | QtWidgets.QWidget,\nrow: int,\nrole: ItemRoleStr | mod.ItemRole = \"both\",\n):\nwidget = widgets.Label(widget) if isinstance(widget, str) else widget\nself.setWidget(row, ITEM_ROLE.get_enum_value(role), widget)\ndef get_widget(\nself, row: int, role: ItemRoleStr | mod.ItemRole = \"both\"\n) -&gt; QtWidgets.QLayout | QtWidgets.QWidget:\nitem = self.itemAt(row, ITEM_ROLE.get_enum_value(role))\nreturn i if (i := item.widget()) is not None else item.layout()\ndef get_item_position(self, index: int) -&gt; tuple[int, ItemRoleStr] | None:\nrow, role = self.getItemPosition(index)  # type: ignore\nreturn None if row == -1 else (row, ITEM_ROLE.inverse[role])\ndef add(self, *items):\nfor i in items:\nmatch i:\ncase QtWidgets.QWidget() | QtWidgets.QLayout():\nself.addRow(i)\ncase tuple():\nself.addRow(*i)\ncase _:\nraise TypeError(i)\ndef set_row_wrap_policy(self, policy: RowWrapPolicyStr | mod.RowWrapPolicy):\n\"\"\"Set row wrap policy to use.\n        Args:\n            policy: row wrap policy to use\n        \"\"\"\nself.setRowWrapPolicy(ROW_WRAP_POLICY.get_enum_value(policy))\ndef get_row_wrap_policy(self) -&gt; RowWrapPolicyStr:\n\"\"\"Return current row wrap policy.\n        Returns:\n            row wrap policy\n        \"\"\"\nreturn ROW_WRAP_POLICY.inverse[self.rowWrapPolicy()]\ndef set_field_growth_policy(\nself, policy: FieldGrowthPolicyStr | mod.FieldGrowthPolicy\n):\n\"\"\"Set field growth policy to use.\n        Args:\n            policy: field growth policy to use\n        \"\"\"\nself.setFieldGrowthPolicy(FIELD_GROWTH_POLICY.get_enum_value(policy))\ndef get_field_growth_policy(self) -&gt; FieldGrowthPolicyStr:\n\"\"\"Return current field growth policy.\n        Returns:\n            field growth policy\n        \"\"\"\nreturn FIELD_GROWTH_POLICY.inverse[self.fieldGrowthPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>Needed for PySide2.</p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Needed for PySide2.\"\"\"\nreturn self.rowCount()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_field_growth_policy","title":"<code>get_field_growth_policy() -&gt; FieldGrowthPolicyStr</code>","text":"<p>Return current field growth policy.</p> <p>Returns:</p> Type Description <code>FieldGrowthPolicyStr</code> <p>field growth policy</p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def get_field_growth_policy(self) -&gt; FieldGrowthPolicyStr:\n\"\"\"Return current field growth policy.\n    Returns:\n        field growth policy\n    \"\"\"\nreturn FIELD_GROWTH_POLICY.inverse[self.fieldGrowthPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_form_alignment","title":"<code>get_form_alignment() -&gt; constants.AlignmentStr</code>","text":"<p>Return current form alignment.</p> <p>Returns:</p> Type Description <code>constants.AlignmentStr</code> <p>form alignment</p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def get_form_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current form alignment.\n    Returns:\n        form alignment\n    \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.formAlignment()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_label_alignment","title":"<code>get_label_alignment() -&gt; constants.AlignmentStr</code>","text":"<p>Return current label alignment.</p> <p>Returns:</p> Type Description <code>constants.AlignmentStr</code> <p>label alignment</p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def get_label_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current label alignment.\n    Returns:\n        label alignment\n    \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.labelAlignment()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_row_wrap_policy","title":"<code>get_row_wrap_policy() -&gt; RowWrapPolicyStr</code>","text":"<p>Return current row wrap policy.</p> <p>Returns:</p> Type Description <code>RowWrapPolicyStr</code> <p>row wrap policy</p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def get_row_wrap_policy(self) -&gt; RowWrapPolicyStr:\n\"\"\"Return current row wrap policy.\n    Returns:\n        row wrap policy\n    \"\"\"\nreturn ROW_WRAP_POLICY.inverse[self.rowWrapPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_field_growth_policy","title":"<code>set_field_growth_policy(policy: FieldGrowthPolicyStr | mod.FieldGrowthPolicy)</code>","text":"<p>Set field growth policy to use.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>FieldGrowthPolicyStr | mod.FieldGrowthPolicy</code> <p>field growth policy to use</p> required Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def set_field_growth_policy(\nself, policy: FieldGrowthPolicyStr | mod.FieldGrowthPolicy\n):\n\"\"\"Set field growth policy to use.\n    Args:\n        policy: field growth policy to use\n    \"\"\"\nself.setFieldGrowthPolicy(FIELD_GROWTH_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_form_alignment","title":"<code>set_form_alignment(alignment: constants.AlignmentStr | constants.AlignmentFlag)</code>","text":"<p>Set the alignment of the form.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr | constants.AlignmentFlag</code> <p>alignment for the form</p> required Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def set_form_alignment(\nself, alignment: constants.AlignmentStr | constants.AlignmentFlag\n):\n\"\"\"Set the alignment of the form.\n    Args:\n        alignment: alignment for the form\n    \"\"\"\nself.setFormAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_label_alignment","title":"<code>set_label_alignment(alignment: constants.AlignmentStr | constants.AlignmentFlag)</code>","text":"<p>Set the alignment of the label.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr | constants.AlignmentFlag</code> <p>alignment for the label</p> required Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def set_label_alignment(\nself, alignment: constants.AlignmentStr | constants.AlignmentFlag\n):\n\"\"\"Set the alignment of the label.\n    Args:\n        alignment: alignment for the label\n    \"\"\"\nself.setFormAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_row_wrap_policy","title":"<code>set_row_wrap_policy(policy: RowWrapPolicyStr | mod.RowWrapPolicy)</code>","text":"<p>Set row wrap policy to use.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>RowWrapPolicyStr | mod.RowWrapPolicy</code> <p>row wrap policy to use</p> required Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def set_row_wrap_policy(self, policy: RowWrapPolicyStr | mod.RowWrapPolicy):\n\"\"\"Set row wrap policy to use.\n    Args:\n        policy: row wrap policy to use\n    \"\"\"\nself.setRowWrapPolicy(ROW_WRAP_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.FrameMixin","title":"<code>FrameMixin</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code></p> Source code in <code>prettyqt\\widgets\\frame.py</code> <pre><code>class FrameMixin(widgets.WidgetMixin):\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"frameShape\": FRAME_SHAPE, \"frameShadow\": SHADOW}\nreturn maps\ndef set_frame_shadow(self, style: ShadowStr | QtWidgets.QFrame.Shadow):\n\"\"\"Set frame shadow.\n        Args:\n            style: frame style to use\n        \"\"\"\nself.setFrameShadow(SHADOW.get_enum_value(style))\ndef get_frame_shadow(self) -&gt; ShadowStr | None:\n\"\"\"Return current frame shadow.\n        Returns:\n            frame style\n        \"\"\"\nif (frame_shadow := self.frameShadow()) == 0:\nreturn None\nreturn SHADOW.inverse[frame_shadow]\ndef set_frame_shape(self, shape: FrameShapeStr | QtWidgets.QFrame.Shape):\n\"\"\"Set frame shape.\n        Args:\n            shape: frame shape to use\n        \"\"\"\nself.setFrameShape(FRAME_SHAPE.get_enum_value(shape))\ndef get_frame_shape(self) -&gt; FrameShapeStr:\n\"\"\"Return current frame shape.\n        Returns:\n            frame shape\n        \"\"\"\nreturn FRAME_SHAPE.inverse[self.frameShape()]\ndef set_frame_rect(self, rect: datatypes.RectType):\nself.setFrameRect(datatypes.to_rect(rect))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.get_frame_shadow","title":"<code>get_frame_shadow() -&gt; ShadowStr | None</code>","text":"<p>Return current frame shadow.</p> <p>Returns:</p> Type Description <code>ShadowStr | None</code> <p>frame style</p> Source code in <code>prettyqt\\widgets\\frame.py</code> <pre><code>def get_frame_shadow(self) -&gt; ShadowStr | None:\n\"\"\"Return current frame shadow.\n    Returns:\n        frame style\n    \"\"\"\nif (frame_shadow := self.frameShadow()) == 0:\nreturn None\nreturn SHADOW.inverse[frame_shadow]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.get_frame_shape","title":"<code>get_frame_shape() -&gt; FrameShapeStr</code>","text":"<p>Return current frame shape.</p> <p>Returns:</p> Type Description <code>FrameShapeStr</code> <p>frame shape</p> Source code in <code>prettyqt\\widgets\\frame.py</code> <pre><code>def get_frame_shape(self) -&gt; FrameShapeStr:\n\"\"\"Return current frame shape.\n    Returns:\n        frame shape\n    \"\"\"\nreturn FRAME_SHAPE.inverse[self.frameShape()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.set_frame_shadow","title":"<code>set_frame_shadow(style: ShadowStr | QtWidgets.QFrame.Shadow)</code>","text":"<p>Set frame shadow.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>ShadowStr | QtWidgets.QFrame.Shadow</code> <p>frame style to use</p> required Source code in <code>prettyqt\\widgets\\frame.py</code> <pre><code>def set_frame_shadow(self, style: ShadowStr | QtWidgets.QFrame.Shadow):\n\"\"\"Set frame shadow.\n    Args:\n        style: frame style to use\n    \"\"\"\nself.setFrameShadow(SHADOW.get_enum_value(style))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.set_frame_shape","title":"<code>set_frame_shape(shape: FrameShapeStr | QtWidgets.QFrame.Shape)</code>","text":"<p>Set frame shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>FrameShapeStr | QtWidgets.QFrame.Shape</code> <p>frame shape to use</p> required Source code in <code>prettyqt\\widgets\\frame.py</code> <pre><code>def set_frame_shape(self, shape: FrameShapeStr | QtWidgets.QFrame.Shape):\n\"\"\"Set frame shape.\n    Args:\n        shape: frame shape to use\n    \"\"\"\nself.setFrameShape(FRAME_SHAPE.get_enum_value(shape))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GestureMixin","title":"<code>GestureMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\widgets\\gesture.py</code> <pre><code>class GestureMixin(core.ObjectMixin):\ndef get_state(self) -&gt; constants.GestureStateStr:\n\"\"\"Return current state.\n        Returns:\n            state\n        \"\"\"\nreturn constants.GESTURE_STATE.inverse[self.state()]\ndef get_gesture_type(self) -&gt; constants.GestureTypeStr:\n\"\"\"Return current gesture type.\n        Returns:\n            gesture type\n        \"\"\"\nreturn constants.GESTURE_TYPE.inverse[self.gestureType()]\ndef get_hot_spot(self) -&gt; core.PointF:\nreturn core.PointF(self.hotSpot())\ndef set_gesture_cancel_policy(\nself, policy: GestureCancelPolicyStr | widgets.QGesture.GestureCancelPolicy\n):\n\"\"\"Set gesture cancel policy.\n        Args:\n            policy: gesture cancel policy to use\n        \"\"\"\nself.setGestureCancelPolicy(GESTURE_CANCEL_POLICY.get_enum_value(policy))\ndef get_gesture_cancel_policy(self) -&gt; GestureCancelPolicyStr:\n\"\"\"Return current gesture cancel policy.\n        Returns:\n            gesture cancel policy\n        \"\"\"\nreturn GESTURE_CANCEL_POLICY.inverse[self.gestureCancelPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.get_gesture_cancel_policy","title":"<code>get_gesture_cancel_policy() -&gt; GestureCancelPolicyStr</code>","text":"<p>Return current gesture cancel policy.</p> <p>Returns:</p> Type Description <code>GestureCancelPolicyStr</code> <p>gesture cancel policy</p> Source code in <code>prettyqt\\widgets\\gesture.py</code> <pre><code>def get_gesture_cancel_policy(self) -&gt; GestureCancelPolicyStr:\n\"\"\"Return current gesture cancel policy.\n    Returns:\n        gesture cancel policy\n    \"\"\"\nreturn GESTURE_CANCEL_POLICY.inverse[self.gestureCancelPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.get_gesture_type","title":"<code>get_gesture_type() -&gt; constants.GestureTypeStr</code>","text":"<p>Return current gesture type.</p> <p>Returns:</p> Type Description <code>constants.GestureTypeStr</code> <p>gesture type</p> Source code in <code>prettyqt\\widgets\\gesture.py</code> <pre><code>def get_gesture_type(self) -&gt; constants.GestureTypeStr:\n\"\"\"Return current gesture type.\n    Returns:\n        gesture type\n    \"\"\"\nreturn constants.GESTURE_TYPE.inverse[self.gestureType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.get_state","title":"<code>get_state() -&gt; constants.GestureStateStr</code>","text":"<p>Return current state.</p> <p>Returns:</p> Type Description <code>constants.GestureStateStr</code> <p>state</p> Source code in <code>prettyqt\\widgets\\gesture.py</code> <pre><code>def get_state(self) -&gt; constants.GestureStateStr:\n\"\"\"Return current state.\n    Returns:\n        state\n    \"\"\"\nreturn constants.GESTURE_STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.set_gesture_cancel_policy","title":"<code>set_gesture_cancel_policy(policy: GestureCancelPolicyStr | widgets.QGesture.GestureCancelPolicy)</code>","text":"<p>Set gesture cancel policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>GestureCancelPolicyStr | widgets.QGesture.GestureCancelPolicy</code> <p>gesture cancel policy to use</p> required Source code in <code>prettyqt\\widgets\\gesture.py</code> <pre><code>def set_gesture_cancel_policy(\nself, policy: GestureCancelPolicyStr | widgets.QGesture.GestureCancelPolicy\n):\n\"\"\"Set gesture cancel policy.\n    Args:\n        policy: gesture cancel policy to use\n    \"\"\"\nself.setGestureCancelPolicy(GESTURE_CANCEL_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsItemMixin","title":"<code>GraphicsItemMixin</code>","text":"Source code in <code>prettyqt\\widgets\\graphicsitem.py</code> <pre><code>class GraphicsItemMixin:\ndef __repr__(self):\nreturn get_repr(self)\ndef __contains__(self, value: QtCore.QPointF) -&gt; bool:\nreturn self.contains(value)\ndef __getitem__(self, key: int):\nreturn self.data(key)\ndef __setitem__(self, key: int, value):\nself.setData(key, value)\ndef set_focus(\nself, reason: constants.FocusReasonStr | constants.FocusReason = \"other\"\n):\nself.setFocus(constants.FOCUS_REASONS.get_enum_value(reason))\ndef colliding_items(\nself,\nmode: constants.ItemSelectionModeStr\n| constants.ItemSelectionMode = \"intersects_shape\",\n) -&gt; listdelegators.BaseListDelegator[QtWidgets.QGraphicsItem]:\nitems = self.collidingItems(constants.ITEM_SELECTION_MODE.get_enum_value(mode))\nreturn listdelegators.BaseListDelegator(items)\ndef collides_with(\nself,\nitem: QtGui.QPainterPath | QtWidgets.QGraphicsItem,\nmode: constants.ItemSelectionModeStr\n| constants.ItemSelectionMode = \"intersects_shape\",\n) -&gt; bool:\nif isinstance(item, QtGui.QPainterPath):\nreturn self.collidesWithPath(\nitem, constants.ITEM_SELECTION_MODE.get_enum_value(mode)\n)\nelse:\nreturn self.collidesWithItem(\nitem, constants.ITEM_SELECTION_MODE.get_enum_value(mode)\n)\ndef set_panel_modality(\nself, modality: PanelModalityStr | QtWidgets.QGraphicsItem.PanelModality\n):\n\"\"\"Set panel modality.\n        Args:\n            modality: panel modality\n        \"\"\"\nself.setPanelModality(PANEL_MODALITY.get_enum_value(modality))\ndef get_panel_modality(self) -&gt; PanelModalityStr:\n\"\"\"Get the current modality modes as a string.\n        Returns:\n            panel modality\n        \"\"\"\nreturn PANEL_MODALITY.inverse[self.panelModality()]\ndef set_cache_mode(self, mode: CacheModeStr | QtWidgets.QGraphicsItem.CacheMode):\n\"\"\"Set cache mode.\n        Args:\n            mode: cache mode\n        \"\"\"\nself.setCacheMode(CACHE_MODE.get_enum_value(mode))\ndef get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current mode modes as a string.\n        Returns:\n            cache mode\n        \"\"\"\nreturn CACHE_MODE.inverse[self.cacheMode()]\ndef get_shape(self) -&gt; gui.PainterPath:\nreturn gui.PainterPath(self.shape())\ndef set_scale(self, scale: tuple[float, float] | float):\nif isinstance(scale, float):\nself.setScale(scale)\nelse:\nself.setTransform(gui.Transform.fromScale(scale[0], scale[1]), True)\ndef set_transform(self, transform: datatypes.TransformType, combine: bool = False):\nif isinstance(transform, tuple):\ntransform = gui.Transform(*transform)\nself.setTransform(transform, combine)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.get_cache_mode","title":"<code>get_cache_mode() -&gt; CacheModeStr</code>","text":"<p>Get the current mode modes as a string.</p> <p>Returns:</p> Type Description <code>CacheModeStr</code> <p>cache mode</p> Source code in <code>prettyqt\\widgets\\graphicsitem.py</code> <pre><code>def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current mode modes as a string.\n    Returns:\n        cache mode\n    \"\"\"\nreturn CACHE_MODE.inverse[self.cacheMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.get_panel_modality","title":"<code>get_panel_modality() -&gt; PanelModalityStr</code>","text":"<p>Get the current modality modes as a string.</p> <p>Returns:</p> Type Description <code>PanelModalityStr</code> <p>panel modality</p> Source code in <code>prettyqt\\widgets\\graphicsitem.py</code> <pre><code>def get_panel_modality(self) -&gt; PanelModalityStr:\n\"\"\"Get the current modality modes as a string.\n    Returns:\n        panel modality\n    \"\"\"\nreturn PANEL_MODALITY.inverse[self.panelModality()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.set_cache_mode","title":"<code>set_cache_mode(mode: CacheModeStr | QtWidgets.QGraphicsItem.CacheMode)</code>","text":"<p>Set cache mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CacheModeStr | QtWidgets.QGraphicsItem.CacheMode</code> <p>cache mode</p> required Source code in <code>prettyqt\\widgets\\graphicsitem.py</code> <pre><code>def set_cache_mode(self, mode: CacheModeStr | QtWidgets.QGraphicsItem.CacheMode):\n\"\"\"Set cache mode.\n    Args:\n        mode: cache mode\n    \"\"\"\nself.setCacheMode(CACHE_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.set_panel_modality","title":"<code>set_panel_modality(modality: PanelModalityStr | QtWidgets.QGraphicsItem.PanelModality)</code>","text":"<p>Set panel modality.</p> <p>Parameters:</p> Name Type Description Default <code>modality</code> <code>PanelModalityStr | QtWidgets.QGraphicsItem.PanelModality</code> <p>panel modality</p> required Source code in <code>prettyqt\\widgets\\graphicsitem.py</code> <pre><code>def set_panel_modality(\nself, modality: PanelModalityStr | QtWidgets.QGraphicsItem.PanelModality\n):\n\"\"\"Set panel modality.\n    Args:\n        modality: panel modality\n    \"\"\"\nself.setPanelModality(PANEL_MODALITY.get_enum_value(modality))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsLayoutItemMixin","title":"<code>GraphicsLayoutItemMixin</code>","text":"Source code in <code>prettyqt\\widgets\\graphicslayoutitem.py</code> <pre><code>class GraphicsLayoutItemMixin:\ndef __repr__(self):\nreturn get_repr(self)\ndef __bool__(self):\nreturn not self.isEmpty()\n@functools.singledispatchmethod\ndef set_size_policy(\nself,\nhorizontal: widgets.sizepolicy.SizePolicyStr,\nvertical: widgets.sizepolicy.SizePolicyStr,\ncontrol_type: widgets.sizepolicy.ControlTypeStr = \"default\",\n):\n\"\"\"Set the size policy.\n        Args:\n            horizontal: horizontal size policy\n            vertical: vertical size policy\n            control_type: control type associated with the widget\n        \"\"\"\nh_policy = widgets.sizepolicy.SIZE_POLICY[horizontal]\nv_policy = widgets.sizepolicy.SIZE_POLICY[vertical]\nc = widgets.sizepolicy.CONTROL_TYPE[control_type]\nself.setSizePolicy(h_policy, v_policy, c)\n@set_size_policy.register\ndef _(self, policy: QtWidgets.QSizePolicy):\nself.setSizePolicy(policy)\ndef get_size_policy(self) -&gt; widgets.SizePolicy:\nqpol = self.sizePolicy()\nreturn widgets.SizePolicy.clone(qpol)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicslayoutitem.GraphicsLayoutItemMixin.set_size_policy","title":"<code>set_size_policy(horizontal: widgets.sizepolicy.SizePolicyStr, vertical: widgets.sizepolicy.SizePolicyStr, control_type: widgets.sizepolicy.ControlTypeStr = 'default')</code>","text":"<p>Set the size policy.</p> <p>Parameters:</p> Name Type Description Default <code>horizontal</code> <code>widgets.sizepolicy.SizePolicyStr</code> <p>horizontal size policy</p> required <code>vertical</code> <code>widgets.sizepolicy.SizePolicyStr</code> <p>vertical size policy</p> required <code>control_type</code> <code>widgets.sizepolicy.ControlTypeStr</code> <p>control type associated with the widget</p> <code>'default'</code> Source code in <code>prettyqt\\widgets\\graphicslayoutitem.py</code> <pre><code>@functools.singledispatchmethod\ndef set_size_policy(\nself,\nhorizontal: widgets.sizepolicy.SizePolicyStr,\nvertical: widgets.sizepolicy.SizePolicyStr,\ncontrol_type: widgets.sizepolicy.ControlTypeStr = \"default\",\n):\n\"\"\"Set the size policy.\n    Args:\n        horizontal: horizontal size policy\n        vertical: vertical size policy\n        control_type: control type associated with the widget\n    \"\"\"\nh_policy = widgets.sizepolicy.SIZE_POLICY[horizontal]\nv_policy = widgets.sizepolicy.SIZE_POLICY[vertical]\nc = widgets.sizepolicy.CONTROL_TYPE[control_type]\nself.setSizePolicy(h_policy, v_policy, c)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsPixmapItem","title":"<code>GraphicsPixmapItem</code>","text":"<p>         Bases: <code>widgets.GraphicsItemMixin</code>, <code>QtWidgets.QGraphicsPixmapItem</code></p> Source code in <code>prettyqt\\widgets\\graphicspixmapitem.py</code> <pre><code>class GraphicsPixmapItem(widgets.GraphicsItemMixin, QtWidgets.QGraphicsPixmapItem):\ndef set_transformation_mode(\nself, mode: constants.TransformationModeStr | constants.TransformationMode\n):\n\"\"\"Set transformation mode.\n        Args:\n            mode: transformation mode to use\n        \"\"\"\nself.setTransformationMode(constants.TRANSFORMATION_MODE.get_enum_value(mode))\ndef get_transformation_mode(self) -&gt; constants.TransformationModeStr:\n\"\"\"Return current transformation mode.\n        Returns:\n            transformation mode\n        \"\"\"\nreturn constants.TRANSFORMATION_MODE.inverse[self.transformationMode()]\ndef set_shape_mode(\nself, mode: ShapeModeStr | QtWidgets.QGraphicsPixmapItem.ShapeMode\n):\n\"\"\"Set shape mode.\n        Args:\n            mode: shape mode to use\n        \"\"\"\nself.setShapeMode(SHAPE_MODE.get_enum_value(mode))\ndef get_shape_mode(self) -&gt; ShapeModeStr:\n\"\"\"Return current shape mode.\n        Returns:\n            shape mode\n        \"\"\"\nreturn SHAPE_MODE.inverse[self.shapeMode()]\ndef get_pixmap(self) -&gt; gui.Pixmap | None:\npix = self.pixmap()\nreturn None if pix.isNull() else gui.Pixmap(pix)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.get_shape_mode","title":"<code>get_shape_mode() -&gt; ShapeModeStr</code>","text":"<p>Return current shape mode.</p> <p>Returns:</p> Type Description <code>ShapeModeStr</code> <p>shape mode</p> Source code in <code>prettyqt\\widgets\\graphicspixmapitem.py</code> <pre><code>def get_shape_mode(self) -&gt; ShapeModeStr:\n\"\"\"Return current shape mode.\n    Returns:\n        shape mode\n    \"\"\"\nreturn SHAPE_MODE.inverse[self.shapeMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.get_transformation_mode","title":"<code>get_transformation_mode() -&gt; constants.TransformationModeStr</code>","text":"<p>Return current transformation mode.</p> <p>Returns:</p> Type Description <code>constants.TransformationModeStr</code> <p>transformation mode</p> Source code in <code>prettyqt\\widgets\\graphicspixmapitem.py</code> <pre><code>def get_transformation_mode(self) -&gt; constants.TransformationModeStr:\n\"\"\"Return current transformation mode.\n    Returns:\n        transformation mode\n    \"\"\"\nreturn constants.TRANSFORMATION_MODE.inverse[self.transformationMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.set_shape_mode","title":"<code>set_shape_mode(mode: ShapeModeStr | QtWidgets.QGraphicsPixmapItem.ShapeMode)</code>","text":"<p>Set shape mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ShapeModeStr | QtWidgets.QGraphicsPixmapItem.ShapeMode</code> <p>shape mode to use</p> required Source code in <code>prettyqt\\widgets\\graphicspixmapitem.py</code> <pre><code>def set_shape_mode(\nself, mode: ShapeModeStr | QtWidgets.QGraphicsPixmapItem.ShapeMode\n):\n\"\"\"Set shape mode.\n    Args:\n        mode: shape mode to use\n    \"\"\"\nself.setShapeMode(SHAPE_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.set_transformation_mode","title":"<code>set_transformation_mode(mode: constants.TransformationModeStr | constants.TransformationMode)</code>","text":"<p>Set transformation mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.TransformationModeStr | constants.TransformationMode</code> <p>transformation mode to use</p> required Source code in <code>prettyqt\\widgets\\graphicspixmapitem.py</code> <pre><code>def set_transformation_mode(\nself, mode: constants.TransformationModeStr | constants.TransformationMode\n):\n\"\"\"Set transformation mode.\n    Args:\n        mode: transformation mode to use\n    \"\"\"\nself.setTransformationMode(constants.TRANSFORMATION_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsScene","title":"<code>GraphicsScene</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>widgets.QGraphicsScene</code></p> Source code in <code>prettyqt\\widgets\\graphicsscene.py</code> <pre><code>class GraphicsScene(core.ObjectMixin, widgets.QGraphicsScene):\nclass GridType(enum.IntEnum):\n\"\"\"Grid type for background.\"\"\"\nNoGrid = 0\nDotGrid = 1\nLineGrid = 2\ndef __init__(self, parent=None):\nsuper().__init__(parent)\nself._grid_mode = self.GridType.LineGrid\nself._grid_size = 50\nself._pen_width = 0.65\nself._grid_color = self.get_palette().get_color(\"text\")\nself._bg_color = self.get_palette().get_color(\"window\")\n# self.setBackgroundBrush(self._bg_color)\ndef __repr__(self):\ncls_name = str(self.__class__.__name__)\nreturn f'&lt;{cls_name}(\"{self.viewer()}\") object at {hex(id(self))}&gt;'\ndef __getitem__(self, index: int) -&gt; widgets.QGraphicsItem:\nreturn self.items()[index]\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"itemIndexMethod\": ITEM_INDEX_METHOD}\nreturn maps\ndef get_palette(self) -&gt; gui.Palette:\nreturn gui.Palette(self.palette())\ndef get_font(self) -&gt; gui.Font:\nreturn gui.Font(self.font())\ndef get_background_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.backgroundBrush())\ndef get_foreground_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.foregroundBrush())\ndef add(self, item) -&gt; widgets.QGraphicsItem:\nmatch item:\ncase widgets.QGraphicsItem():\nself.addItem(item)\nreturn item\ncase gui.QPixmap():\nreturn self.add_pixmap(item)\ncase gui.QPainterPath():\nreturn self.add_path(item)\ncase gui.QPolygonF():\nreturn self.add_polygon(item)\ncase core.QRectF():\nreturn self.add_rect(item)\ncase core.QLine():\nreturn self.add_line(item)\ncase str():\nreturn self.add_text(item)\ncase widgets.QWidget():\nreturn self.add_widget(item)\ncase _:\nraise TypeError(item)\ndef add_pixmap(self, pixmap: gui.QPixmap) -&gt; widgets.GraphicsPixmapItem:\ng_item = widgets.GraphicsPixmapItem(pixmap)\nself.addItem(g_item)\nreturn g_item\ndef add_polygon(\nself,\npolygon: gui.QPolygonF | gui.QPolygon,\npen: gui.QPen | None = None,\nbrush: gui.QBrush | None = None,\n) -&gt; widgets.GraphicsPolygonItem:\nif isinstance(polygon, gui.QPolygon):\npolygon = gui.PolygonF(polygon)\ng_item = widgets.GraphicsPolygonItem(polygon)\nif brush is not None:\ng_item.setBrush(brush)\nif pen is not None:\ng_item.setPen(pen)\nself.addItem(g_item)\nreturn g_item\ndef add_path(\nself,\npath: gui.QPainterPath,\npen: gui.QPen | None = None,\nbrush: gui.QBrush | None = None,\n) -&gt; widgets.GraphicsPathItem:\ng_item = widgets.GraphicsPathItem(path)\nif brush is not None:\ng_item.setBrush(brush)\nif pen is not None:\ng_item.setPen(pen)\nself.addItem(g_item)\nreturn g_item\ndef add_rect(\nself,\nrect: datatypes.RectType | datatypes.RectFType,\npen: gui.QPen | None = None,\nbrush: gui.QBrush | None = None,\n) -&gt; widgets.GraphicsRectItem:\ng_item = widgets.GraphicsRectItem(datatypes.to_rectf(rect))\nif brush is not None:\ng_item.setBrush(brush)\nif pen is not None:\ng_item.setPen(pen)\nself.addItem(g_item)\nreturn g_item\ndef add_line(\nself,\nline: core.QLineF | core.QLine | tuple[float, float, float, float],\npen: gui.QPen | None = None,\n) -&gt; widgets.GraphicsLineItem:\ng_item = widgets.GraphicsLineItem(datatypes.to_linef(line))\nif pen is not None:\ng_item.setPen(pen)\nself.addItem(g_item)\nreturn g_item\ndef add_ellipse(\nself,\nellipse: datatypes.RectType | datatypes.RectFType,\npen: gui.QPen | None = None,\nbrush: gui.QBrush | None = None,\n) -&gt; widgets.GraphicsEllipseItem:\ng_item = widgets.GraphicsEllipseItem(datatypes.to_rectf(ellipse))\nif brush is not None:\ng_item.setBrush(brush)\nif pen is not None:\ng_item.setPen(pen)\nself.addItem(g_item)\nreturn g_item\ndef add_text(\nself, text: str, font: gui.QFont | None = None\n) -&gt; widgets.GraphicsTextItem:\ng_item = widgets.GraphicsTextItem(text)\nif font is not None:\ng_item.setFont(font)\nself.addItem(g_item)\nreturn g_item\ndef add_simple_text(\nself, text: str, font: gui.QFont | None = None\n) -&gt; widgets.GraphicsSimpleTextItem:\ng_item = widgets.GraphicsSimpleTextItem(text)\nif font is not None:\ng_item.setFont(font)\nself.addItem(g_item)\nreturn g_item\ndef add_widget(self, widget: widgets.QWidget) -&gt; widgets.GraphicsProxyWidget:\ng_item = widgets.GraphicsProxyWidget()\ng_item.setWidget(widget)\nself.addItem(g_item)\nreturn g_item\ndef colliding_items(\nself,\nitem: widgets.QGraphicsItem,\nmode: constants.ItemSelectionModeStr\n| constants.ItemSelectionMode = \"intersects_shape\",\n) -&gt; listdelegators.BaseListDelegator[widgets.QGraphicsItem]:\nitems = self.collidingItems(item, constants.ITEM_SELECTION_MODE[mode])\nreturn listdelegators.BaseListDelegator(items)\ndef add_item_group(\nself, *items: widgets.QGraphicsItem\n) -&gt; widgets.GraphicsItemGroup:\ngroup = widgets.GraphicsItemGroup()\nfor item in items:\ngroup.addToGroup(item)\nreturn group\ndef _draw_grid(\nself,\npainter: gui.QPainter,\nrect: core.QRectF,\npen: gui.QPen,\ngrid_size: int,\n):\nleft = int(rect.left())\nright = int(rect.right())\ntop = int(rect.top())\nbottom = int(rect.bottom())\nfirst_left = left - (left % grid_size)\nfirst_top = top - (top % grid_size)\nlines = [\ncore.QLineF(x, top, x, bottom) for x in range(first_left, right, grid_size)\n]\nlines.extend(\n[\ncore.QLineF(left, y, right, y)\nfor y in range(first_top, bottom, grid_size)\n]\n)\npainter.setPen(pen)\npainter.drawLines(lines)\ndef _draw_dots(\nself,\npainter: gui.QPainter,\nrect: core.QRectF,\npen: gui.QPen,\ngrid_size: int,\n):\nif (zoom := self._get_viewer_zoom()) &lt; 0:\ngrid_size *= int(abs(zoom) / 0.3 + 1)\nleft = int(rect.left())\nright = int(rect.right())\ntop = int(rect.top())\nbottom = int(rect.bottom())\nfirst_left = left - (left % grid_size)\nfirst_top = top - (top % grid_size)\npen.setWidth(grid_size / 10)\npainter.setPen(pen)\n[\npainter.drawPoint(int(x), int(y))\nfor x in range(first_left, right, grid_size)\nfor y in range(first_top, bottom, grid_size)\n]\ndef drawBackground(self, painter: gui.QPainter, rect: core.QRect):\nsuper().drawBackground(painter, rect)\npainter.save()\npainter.setRenderHint(gui.QPainter.RenderHint.Antialiasing, False)\npainter.setBrush(self.backgroundBrush())\nif self._grid_mode == self.GridType.DotGrid:\npen = gui.QPen(self.grid_color, self._pen_width)\nself._draw_dots(painter, rect, pen, self._grid_size)\nelif self._grid_mode == self.GridType.LineGrid:\nzoom = self._get_viewer_zoom()\nif zoom &gt; -0.5:\npen = gui.QPen(self.grid_color, self._pen_width)\nself._draw_grid(painter, rect, pen, self._grid_size)\ncolor = self._bg_color.darker(150)\nif zoom &lt; -0.0:\ncolor = color.darker(100 - int(zoom * 110))\npen = gui.QPen(color, self._pen_width)\nself._draw_grid(painter, rect, pen, self._grid_size * 8)\npainter.restore()\ndef _get_viewer_zoom(self):\nviewer = self.viewer()\nif viewer is None:\nreturn 1.0\ntransform = viewer.transform()\ncur_scale = (transform.m11(), transform.m22())\nreturn float(f\"{cur_scale[0] - 1.0:0.2f}\")\n# def mousePressEvent(self, event):\n#     selected = self.viewer().selectedItems()\n#     if viewer := self.viewer():\n#         viewer.sceneMousePressEvent(event)\n#     super().mousePressEvent(event)\n#     keep_selection = any(\n#         [\n#             event.button() == core.Qt.MiddleButton,\n#             event.button() == core.Qt.RightButton,\n#             event.modifiers() == core.Qt.AltModifier,\n#         ]\n#     )\n#     if keep_selection:\n#         for node in selected:\n#             node.setSelected(True)\n# def mouseMoveEvent(self, event):\n#     if viewer := self.viewer():\n#         viewer.sceneMouseMoveEvent(event)\n#     super().mouseMoveEvent(event)\n# def mouseReleaseEvent(self, event):\n#     if viewer := self.viewer():\n#         viewer.sceneMouseReleaseEvent(event)\n#     super().mouseReleaseEvent(event)\ndef viewer(self):\nreturn self.views()[0] if self.views() else None\ndef get_grid_mode(self) -&gt; GridType:\nreturn self._grid_mode\ndef set_grid_mode(self, mode: GridType | None = None):\n# alternative?\n# brush = gui.Brush()\n# brush.set_style(\"cross\")\n# scene.setBackgroundBrush(brush)\nif mode is None:\nmode = self.GridType.NoGrid\nself._grid_mode = mode\ndef get_grid_color(self) -&gt; gui.Color:\nreturn self._grid_color\ndef set_grid_color(self, color: datatypes.ColorType):\nself._grid_color = colors.get_color(color)\ndef get_background_color(self) -&gt; gui.Color:\nreturn self._bg_color\ndef set_background_color(self, color: datatypes.ColorType):\nself._bg_color = colors.get_color(color)\nself.setBackgroundBrush(self._bg_color)\ndef set_item_index_method(\nself, method: ItemIndexMethodStr | widgets.QGraphicsScene.ItemIndexMethod\n):\n\"\"\"Set item index method.\n        Args:\n            method: item index method to use\n        \"\"\"\nself.setItemIndexMethod(ITEM_INDEX_METHOD.get_enum_value(method))\ndef get_item_index_method(self) -&gt; ItemIndexMethodStr:\n\"\"\"Return item index method.\n        Returns:\n            item index method\n        \"\"\"\nreturn ITEM_INDEX_METHOD.inverse[self.itemIndexMethod()]\nbg_color = core.Property(gui.QColor, get_background_color, set_background_color)\ngrid_color = core.Property(gui.QColor, get_grid_color, set_grid_color)\ngrid_mode = core.Property(int, get_grid_mode, set_grid_mode)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.GridType","title":"<code>GridType</code>","text":"<p>         Bases: <code>enum.IntEnum</code></p> <p>Grid type for background.</p> Source code in <code>prettyqt\\widgets\\graphicsscene.py</code> <pre><code>class GridType(enum.IntEnum):\n\"\"\"Grid type for background.\"\"\"\nNoGrid = 0\nDotGrid = 1\nLineGrid = 2\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.get_item_index_method","title":"<code>get_item_index_method() -&gt; ItemIndexMethodStr</code>","text":"<p>Return item index method.</p> <p>Returns:</p> Type Description <code>ItemIndexMethodStr</code> <p>item index method</p> Source code in <code>prettyqt\\widgets\\graphicsscene.py</code> <pre><code>def get_item_index_method(self) -&gt; ItemIndexMethodStr:\n\"\"\"Return item index method.\n    Returns:\n        item index method\n    \"\"\"\nreturn ITEM_INDEX_METHOD.inverse[self.itemIndexMethod()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.set_item_index_method","title":"<code>set_item_index_method(method: ItemIndexMethodStr | widgets.QGraphicsScene.ItemIndexMethod)</code>","text":"<p>Set item index method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>ItemIndexMethodStr | widgets.QGraphicsScene.ItemIndexMethod</code> <p>item index method to use</p> required Source code in <code>prettyqt\\widgets\\graphicsscene.py</code> <pre><code>def set_item_index_method(\nself, method: ItemIndexMethodStr | widgets.QGraphicsScene.ItemIndexMethod\n):\n\"\"\"Set item index method.\n    Args:\n        method: item index method to use\n    \"\"\"\nself.setItemIndexMethod(ITEM_INDEX_METHOD.get_enum_value(method))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsViewMixin","title":"<code>GraphicsViewMixin</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code></p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>class GraphicsViewMixin(widgets.AbstractScrollAreaMixin):\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nif not args or not isinstance(args[0], QtWidgets.QGraphicsScene):\nself.setScene(widgets.GraphicsScene())\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"alignment\": constants.ALIGNMENTS,\n\"resizeAnchor\": VIEWPORT_ANCHOR,\n\"transformationAnchor\": VIEWPORT_ANCHOR,\n\"cacheMode\": CACHE_MODES,\n\"dragMode\": DRAG_MODE,\n\"viewportUpdateMode\": VIEWPORT_UPDATE_MODE,\n\"rubberBandSelectionMode\": constants.ITEM_SELECTION_MODE,\n\"renderHints\": gui.painter.RENDER_HINTS,\n\"optimizationFlags\": OPTIMIZATION_FLAGS,\n}\nreturn maps\ndef enable_mousewheel_zoom(self, state: bool = True):\nif state:\nself.viewport().installEventFilter(self)\nelse:\nself.viewport().removeEventFilter(self)\ndef __getitem__(self, index: int) -&gt; QtWidgets.QGraphicsItem:\nreturn self.items()[index]\ndef eventFilter(self, source, event) -&gt; bool:\nif source is not self.viewport() or event.type() != event.Type.Wheel:\nreturn super().eventFilter(source, event)\n# Zoom Factor\nzoom_in_factor = 1.25\nzoom_out_factor = 1 / zoom_in_factor\n# Set Anchors\nself.setTransformationAnchor(self.ViewportAnchor.NoAnchor)\nself.setResizeAnchor(self.ViewportAnchor.NoAnchor)\n# Save the scene pos\nold_pos = self.mapToScene(event.position().toPoint())\n# Zoom\nzoom_factor = zoom_in_factor if event.angleDelta().y() &gt; 0 else zoom_out_factor\nself.scale(zoom_factor, zoom_factor)\n# # Get the new position\nnew_pos = self.mapToScene(event.position().toPoint())\n# Move scene to old position\ndelta = new_pos - old_pos\nself.translate(delta.x(), delta.y())\nreturn True\ndef get_zoom(self) -&gt; float:\n\"\"\"Return the viewer zoom level.\n        Returns:\n            float: zoom level.\n        \"\"\"\ntransform = self.transform()\ncur_scale = (transform.m11(), transform.m22())\nreturn float(f\"{cur_scale[0] - 1.0:0.2f}\")\ndef add_item(self, *args):\nreturn self.scene().addItem(*args)\ndef remove_item(self, *args):\nreturn self.scene().removeItem(*args)\ndef get_view_rect(self) -&gt; QtCore.QRect:\n\"\"\"Return the boundaries of the view in scene coordinates.\"\"\"\nr = QtCore.QRectF(self.rect())\nreturn self.viewportTransform().inverted()[0].mapRect(r)\ndef get_pixel_size(self):\n\"\"\"Return vector with length and width of one view pixel in scene coordinates.\"\"\"\np0 = core.PointF(0, 0)\np1 = core.PointF(1, 1)\ntr = self.transform().inverted()[0]\np01 = tr.map(p0)\np11 = tr.map(p1)\nreturn core.PointF(p11 - p01)\ndef get_background_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.backgroundBrush())\ndef get_foreground_brush(self) -&gt; gui.Brush:\nreturn gui.Brush(self.foregroundBrush())\ndef invalidate_scene(\nself,\nrect: QtCore.QRectF,\nlayer: widgets.graphicsscene.SceneLayerStr\n| widgets.QGraphicsScene.SceneLayer = \"all\",\n):\nself.invalidateScene(\nrect, widgets.graphicsscene.SCENE_LAYER.get_enum_value(layer)\n)\ndef set_transformation_anchor(self, mode: ViewportAnchorStr | mod.ViewportAnchor):\n\"\"\"Set how the view should position the scene during transformations.\n        Args:\n            mode: transformation anchor to use\n        \"\"\"\nself.setTransformationAnchor(VIEWPORT_ANCHOR.get_enum_value(mode))\ndef get_transformation_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current transformation anchor.\n        Returns:\n            viewport anchor\n        \"\"\"\nreturn VIEWPORT_ANCHOR.inverse[self.transformationAnchor()]\ndef set_transform(self, transform: datatypes.TransformType, combine: bool = False):\nself.setTransform(datatypes.to_transform(transform), combine)\ndef set_resize_anchor(self, mode: ViewportAnchorStr | mod.ViewportAnchor):\n\"\"\"Set how the view should position the scene during resizes.\n        Args:\n            mode: resize anchor to use\n        \"\"\"\nself.setResizeAnchor(VIEWPORT_ANCHOR.get_enum_value(mode))\ndef get_resize_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current resize anchor.\n        Returns:\n            resize anchor\n        \"\"\"\nreturn VIEWPORT_ANCHOR.inverse[self.resizeAnchor()]\ndef set_viewport_update_mode(\nself, mode: ViewportUpdateModeStr | mod.ViewportUpdateMode\n):\n\"\"\"Set how the viewport should update its contents.\n        Args:\n            mode: viewport update mode to use\n        \"\"\"\nself.setViewportUpdateMode(VIEWPORT_UPDATE_MODE.get_enum_value(mode))\ndef get_viewport_update_mode(self) -&gt; ViewportUpdateModeStr:\n\"\"\"Return current viewport update mode.\n        Returns:\n            viewport update mode\n        \"\"\"\nreturn VIEWPORT_UPDATE_MODE.inverse[self.viewportUpdateMode()]\ndef set_drag_mode(self, mode: DragModeStr | mod.DragMode):\n\"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed.\n        Args:\n            mode: drag mode to use\n        \"\"\"\nself.setDragMode(DRAG_MODE.get_enum_value(mode))\ndef get_drag_mode(self) -&gt; DragModeStr:\n\"\"\"Return current drag mode.\n        Returns:\n            drag mode\n        \"\"\"\nreturn DRAG_MODE.inverse[self.dragMode()]\ndef set_rubberband_selection_mode(\nself, mode: constants.ItemSelectionModeStr | constants.ItemSelectionMode\n):\n\"\"\"Set the behavior for selecting items with a rubber band selection rectangle.\n        Args:\n            mode: rubberband selection mode to use\n        \"\"\"\nself.setRubberBandSelectionMode(\nconstants.ITEM_SELECTION_MODE.get_enum_value(mode)\n)\ndef get_rubberband_selection_mode(self) -&gt; constants.ItemSelectionModeStr:\n\"\"\"Return current rubberband selection mode.\n        Returns:\n            rubberband selection mode\n        \"\"\"\nreturn constants.ITEM_SELECTION_MODE.inverse[self.rubberBandSelectionMode()]\ndef set_cache_mode(self, mode: CacheModeStr | mod.CacheModeFlag):\n\"\"\"Set the cache mode.\n        Args:\n            mode: cache mode to use\n        \"\"\"\nself.setCacheMode(CACHE_MODES.get_enum_value(mode))\ndef get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Return current cache mode.\n        Returns:\n            cache mode\n        \"\"\"\nreturn CACHE_MODES.inverse[self.cacheMode()]\ndef set_optimization_flags(self, *items: OptimizationFlagStr):\nflags = OPTIMIZATION_FLAGS.merge_flags(items)\nself.setOptimizationFlags(flags)\ndef get_optimization_flags(self) -&gt; list[OptimizationFlagStr]:\nreturn OPTIMIZATION_FLAGS.get_list(self.optimizationFlags())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_cache_mode","title":"<code>get_cache_mode() -&gt; CacheModeStr</code>","text":"<p>Return current cache mode.</p> <p>Returns:</p> Type Description <code>CacheModeStr</code> <p>cache mode</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Return current cache mode.\n    Returns:\n        cache mode\n    \"\"\"\nreturn CACHE_MODES.inverse[self.cacheMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_drag_mode","title":"<code>get_drag_mode() -&gt; DragModeStr</code>","text":"<p>Return current drag mode.</p> <p>Returns:</p> Type Description <code>DragModeStr</code> <p>drag mode</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_drag_mode(self) -&gt; DragModeStr:\n\"\"\"Return current drag mode.\n    Returns:\n        drag mode\n    \"\"\"\nreturn DRAG_MODE.inverse[self.dragMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_pixel_size","title":"<code>get_pixel_size()</code>","text":"<p>Return vector with length and width of one view pixel in scene coordinates.</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_pixel_size(self):\n\"\"\"Return vector with length and width of one view pixel in scene coordinates.\"\"\"\np0 = core.PointF(0, 0)\np1 = core.PointF(1, 1)\ntr = self.transform().inverted()[0]\np01 = tr.map(p0)\np11 = tr.map(p1)\nreturn core.PointF(p11 - p01)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_resize_anchor","title":"<code>get_resize_anchor() -&gt; ViewportAnchorStr</code>","text":"<p>Return current resize anchor.</p> <p>Returns:</p> Type Description <code>ViewportAnchorStr</code> <p>resize anchor</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_resize_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current resize anchor.\n    Returns:\n        resize anchor\n    \"\"\"\nreturn VIEWPORT_ANCHOR.inverse[self.resizeAnchor()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_rubberband_selection_mode","title":"<code>get_rubberband_selection_mode() -&gt; constants.ItemSelectionModeStr</code>","text":"<p>Return current rubberband selection mode.</p> <p>Returns:</p> Type Description <code>constants.ItemSelectionModeStr</code> <p>rubberband selection mode</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_rubberband_selection_mode(self) -&gt; constants.ItemSelectionModeStr:\n\"\"\"Return current rubberband selection mode.\n    Returns:\n        rubberband selection mode\n    \"\"\"\nreturn constants.ITEM_SELECTION_MODE.inverse[self.rubberBandSelectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_transformation_anchor","title":"<code>get_transformation_anchor() -&gt; ViewportAnchorStr</code>","text":"<p>Return current transformation anchor.</p> <p>Returns:</p> Type Description <code>ViewportAnchorStr</code> <p>viewport anchor</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_transformation_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current transformation anchor.\n    Returns:\n        viewport anchor\n    \"\"\"\nreturn VIEWPORT_ANCHOR.inverse[self.transformationAnchor()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_view_rect","title":"<code>get_view_rect() -&gt; QtCore.QRect</code>","text":"<p>Return the boundaries of the view in scene coordinates.</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_view_rect(self) -&gt; QtCore.QRect:\n\"\"\"Return the boundaries of the view in scene coordinates.\"\"\"\nr = QtCore.QRectF(self.rect())\nreturn self.viewportTransform().inverted()[0].mapRect(r)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_viewport_update_mode","title":"<code>get_viewport_update_mode() -&gt; ViewportUpdateModeStr</code>","text":"<p>Return current viewport update mode.</p> <p>Returns:</p> Type Description <code>ViewportUpdateModeStr</code> <p>viewport update mode</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_viewport_update_mode(self) -&gt; ViewportUpdateModeStr:\n\"\"\"Return current viewport update mode.\n    Returns:\n        viewport update mode\n    \"\"\"\nreturn VIEWPORT_UPDATE_MODE.inverse[self.viewportUpdateMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_zoom","title":"<code>get_zoom() -&gt; float</code>","text":"<p>Return the viewer zoom level.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>zoom level.</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_zoom(self) -&gt; float:\n\"\"\"Return the viewer zoom level.\n    Returns:\n        float: zoom level.\n    \"\"\"\ntransform = self.transform()\ncur_scale = (transform.m11(), transform.m22())\nreturn float(f\"{cur_scale[0] - 1.0:0.2f}\")\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_cache_mode","title":"<code>set_cache_mode(mode: CacheModeStr | mod.CacheModeFlag)</code>","text":"<p>Set the cache mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CacheModeStr | mod.CacheModeFlag</code> <p>cache mode to use</p> required Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_cache_mode(self, mode: CacheModeStr | mod.CacheModeFlag):\n\"\"\"Set the cache mode.\n    Args:\n        mode: cache mode to use\n    \"\"\"\nself.setCacheMode(CACHE_MODES.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_drag_mode","title":"<code>set_drag_mode(mode: DragModeStr | mod.DragMode)</code>","text":"<p>Set the behavior for dragging the mouse while the left mouse button is pressed.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>DragModeStr | mod.DragMode</code> <p>drag mode to use</p> required Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_drag_mode(self, mode: DragModeStr | mod.DragMode):\n\"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed.\n    Args:\n        mode: drag mode to use\n    \"\"\"\nself.setDragMode(DRAG_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_resize_anchor","title":"<code>set_resize_anchor(mode: ViewportAnchorStr | mod.ViewportAnchor)</code>","text":"<p>Set how the view should position the scene during resizes.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewportAnchorStr | mod.ViewportAnchor</code> <p>resize anchor to use</p> required Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_resize_anchor(self, mode: ViewportAnchorStr | mod.ViewportAnchor):\n\"\"\"Set how the view should position the scene during resizes.\n    Args:\n        mode: resize anchor to use\n    \"\"\"\nself.setResizeAnchor(VIEWPORT_ANCHOR.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_rubberband_selection_mode","title":"<code>set_rubberband_selection_mode(mode: constants.ItemSelectionModeStr | constants.ItemSelectionMode)</code>","text":"<p>Set the behavior for selecting items with a rubber band selection rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ItemSelectionModeStr | constants.ItemSelectionMode</code> <p>rubberband selection mode to use</p> required Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_rubberband_selection_mode(\nself, mode: constants.ItemSelectionModeStr | constants.ItemSelectionMode\n):\n\"\"\"Set the behavior for selecting items with a rubber band selection rectangle.\n    Args:\n        mode: rubberband selection mode to use\n    \"\"\"\nself.setRubberBandSelectionMode(\nconstants.ITEM_SELECTION_MODE.get_enum_value(mode)\n)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_transformation_anchor","title":"<code>set_transformation_anchor(mode: ViewportAnchorStr | mod.ViewportAnchor)</code>","text":"<p>Set how the view should position the scene during transformations.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewportAnchorStr | mod.ViewportAnchor</code> <p>transformation anchor to use</p> required Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_transformation_anchor(self, mode: ViewportAnchorStr | mod.ViewportAnchor):\n\"\"\"Set how the view should position the scene during transformations.\n    Args:\n        mode: transformation anchor to use\n    \"\"\"\nself.setTransformationAnchor(VIEWPORT_ANCHOR.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_viewport_update_mode","title":"<code>set_viewport_update_mode(mode: ViewportUpdateModeStr | mod.ViewportUpdateMode)</code>","text":"<p>Set how the viewport should update its contents.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewportUpdateModeStr | mod.ViewportUpdateMode</code> <p>viewport update mode to use</p> required Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_viewport_update_mode(\nself, mode: ViewportUpdateModeStr | mod.ViewportUpdateMode\n):\n\"\"\"Set how the viewport should update its contents.\n    Args:\n        mode: viewport update mode to use\n    \"\"\"\nself.setViewportUpdateMode(VIEWPORT_UPDATE_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsWidgetMixin","title":"<code>GraphicsWidgetMixin</code>","text":"<p>         Bases: <code>widgets.GraphicsObjectMixin</code>, <code>widgets.GraphicsLayoutItemMixin</code></p> Source code in <code>prettyqt\\widgets\\graphicswidget.py</code> <pre><code>class GraphicsWidgetMixin(widgets.GraphicsObjectMixin, widgets.GraphicsLayoutItemMixin):\n@property\ndef box(self):\nreturn self.layout()\n@box.setter\ndef box(self, layout):\nself.set_layout(layout)\ndef set_layout(\nself, layout: LayoutStr | QtWidgets.QGraphicsLayout\n) -&gt; QtWidgets.QGraphicsLayout:\nmatch layout:\ncase QtWidgets.QGraphicsLayout():\nlayout = layout\ncase \"grid\":\nlayout = widgets.GraphicsGridLayout()\ncase \"anchor\":\nlayout = widgets.GraphicsAnchorLayout()\ncase \"horizontal\" | \"vertical\":\nlayout = widgets.GraphicsLinearLayout(layout)\ncase _:\nraise ValueError(f\"Invalid Layout {layout}\")\nself.setLayout(layout)\nreturn layout\ndef set_focus_policy(\nself, policy: constants.FocusPolicyStr | constants.FocusPolicy\n):\n\"\"\"Set the way the widget accepts keyboard focus.\n        Args:\n            policy: Focus policy\n        \"\"\"\nself.setFocusPolicy(constants.FOCUS_POLICY.get_enum_value(policy))\ndef get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return way the widget accepts keyboard focus.\n        Returns:\n            str: Focus policy\n        \"\"\"\nreturn constants.FOCUS_POLICY.inverse[self.focusPolicy()]\ndef window_frame_section_at(\nself, point: datatypes.PointType\n) -&gt; constants.WindowFrameSectionStr:\n\"\"\"Return the window frame section at given position.\n        Returns:\n            str: Window frame section\n        \"\"\"\nsection = self.windowFrameSectionAt(datatypes.to_point(point))\nreturn constants.WINDOW_FRAME_SECTION.inverse[section]\ndef get_font(self) -&gt; gui.Font:\nreturn gui.Font(self.font())\ndef get_palette(self) -&gt; gui.Palette:\nreturn gui.Palette(self.palette())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidgetMixin.get_focus_policy","title":"<code>get_focus_policy() -&gt; constants.FocusPolicyStr</code>","text":"<p>Return way the widget accepts keyboard focus.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>constants.FocusPolicyStr</code> <p>Focus policy</p> Source code in <code>prettyqt\\widgets\\graphicswidget.py</code> <pre><code>def get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return way the widget accepts keyboard focus.\n    Returns:\n        str: Focus policy\n    \"\"\"\nreturn constants.FOCUS_POLICY.inverse[self.focusPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidgetMixin.set_focus_policy","title":"<code>set_focus_policy(policy: constants.FocusPolicyStr | constants.FocusPolicy)</code>","text":"<p>Set the way the widget accepts keyboard focus.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>constants.FocusPolicyStr | constants.FocusPolicy</code> <p>Focus policy</p> required Source code in <code>prettyqt\\widgets\\graphicswidget.py</code> <pre><code>def set_focus_policy(\nself, policy: constants.FocusPolicyStr | constants.FocusPolicy\n):\n\"\"\"Set the way the widget accepts keyboard focus.\n    Args:\n        policy: Focus policy\n    \"\"\"\nself.setFocusPolicy(constants.FOCUS_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidgetMixin.window_frame_section_at","title":"<code>window_frame_section_at(point: datatypes.PointType) -&gt; constants.WindowFrameSectionStr</code>","text":"<p>Return the window frame section at given position.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>constants.WindowFrameSectionStr</code> <p>Window frame section</p> Source code in <code>prettyqt\\widgets\\graphicswidget.py</code> <pre><code>def window_frame_section_at(\nself, point: datatypes.PointType\n) -&gt; constants.WindowFrameSectionStr:\n\"\"\"Return the window frame section at given position.\n    Returns:\n        str: Window frame section\n    \"\"\"\nsection = self.windowFrameSectionAt(datatypes.to_point(point))\nreturn constants.WINDOW_FRAME_SECTION.inverse[section]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GridLayout","title":"<code>GridLayout</code>","text":"<p>         Bases: <code>widgets.LayoutMixin</code>, <code>widgets.QGridLayout</code></p> Source code in <code>prettyqt\\widgets\\gridlayout.py</code> <pre><code>class GridLayout(widgets.LayoutMixin, widgets.QGridLayout):\nID = \"grid\"\ndef __getitem__(\nself, index: tuple[int | slice, int | slice] | int | str\n) -&gt; (\nwidgets.QWidget\n| widgets.QLayout\n| listdelegators.BaseListDelegator[widgets.QWidget | widgets.QLayout]\n| None\n):\nrowcount = self.rowCount()\ncolcount = self.columnCount()\nmatch index:\ncase int() as row, int() as col:\nif row &gt;= rowcount or col &gt;= rowcount:\nraise IndexError(index)\nitem = self.itemAtPosition(row, col)\nreturn i if (i := item.widget()) is not None else item.layout()\ncase (row, col):\nitems = [\nitem\nfor i, j in helpers.yield_positions(row, col, rowcount, colcount)\nif (item := self.itemAtPosition(i, j)) is not None\n]\nitems = [\nw if (w := i.widget()) is not None else i.layout() for i in items\n]\nreturn listdelegators.BaseListDelegator(list(set(items)))\ncase int() as row:\nif row &gt;= rowcount:\nraise IndexError(index)\nitem = self.itemAt(row)\nreturn i if (i := item.widget()) is not None else item.layout()\ncase slice() as rowslice:\ncount = rowcount if rowslice.stop is None else rowslice.stop\nitems = [self.itemAt(i) for i in range(count)[rowslice]]\nitems = [\nw if (w := i.widget()) is not None else i.layout() for i in items\n]\nreturn listdelegators.BaseListDelegator(list(set(items)))\ncase str():\nreturn self.find_child(widgets.QWidget | widgets.QLayout, index)\ncase _:\nraise TypeError(index)\ndef __setitem__(\nself,\nidx: tuple[int | slice, int | slice],\nvalue: widgets.QWidget | widgets.QLayout | widgets.QLayoutItem,\n):\nrow, col = idx\nrowspan = row.stop - row.start + 1 if isinstance(row, slice) else 1\ncolspan = col.stop - col.start + 1 if isinstance(col, slice) else 1\nrowstart = row.start if isinstance(row, slice) else row\ncolstart = col.start if isinstance(col, slice) else col\nself.add(value, rowstart, colstart, rowspan, colspan)\n# def __setstate__(self, state):\n#     for item, pos in zip(state[\"widgets\"], state[\"positions\"]):\n#         x, y, w, h = pos\n#         self[x : x + w - 1, y : y + h - 1] = item\n# def __reduce__(self):\n#     return type(self), (), self.__getstate__()\ndef __iter__(self) -&gt; Iterator[widgets.QWidget | widgets.QLayout]:\nreturn iter(item for i in range(self.count()) if (item := self[i]) is not None)\ndef __add__(\nself,\nother: (\ntuple | list | widgets.QWidget | widgets.QLayout | widgets.QLayoutItem\n),\n):\nif isinstance(other, tuple | list):\nfor i, _control in enumerate(other):\nself[self.rowCount(), i] = other  # type: ignore\nelse:\nself[self.rowCount(), 0 : self.columnCount() - 1] = other\nreturn self\ndef __iadd__(self, item, *args, **kwargs):\nself.__add__(item, *args, **kwargs)\nreturn self\ndef add(\nself,\nitem: widgets.QWidget | widgets.QLayout | widgets.QLayoutItem,\nrowstart: int,\ncolstart: int,\nrowspan: int = 1,\ncolspan: int = 1,\nalignment: constants.AlignmentStr | None = None,\n):\nflag = constants.ALIGNMENTS[alignment or \"none\"]\nmatch item:\ncase widgets.QWidget():\nself.addWidget(item, rowstart, colstart, rowspan, colspan, flag)\ncase widgets.QLayout():\nself.addLayout(item, rowstart, colstart, rowspan, colspan, flag)\ncase widgets.QLayoutItem():\nself.addItem(item, rowstart, colstart, rowspan, colspan, flag)\ndef append(self, item: widgets.QWidget | widgets.QLayout | widgets.QLayoutItem):\nself[self.rowCount(), 0 : self.columnCount() - 1] = item\ndef set_origin_corner(self, corner: constants.CornerStr | constants.Corner):\n\"\"\"Set the origin corner.\n        Args:\n            corner: origin corner\n        \"\"\"\nself.setOriginCorner(constants.CORNER.get_enum_value(corner))\ndef get_origin_corner(self) -&gt; constants.CornerStr:\n\"\"\"Return current origin corner.\n        Returns:\n            origin corner\n        \"\"\"\nreturn constants.CORNER.inverse[self.originCorner()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.get_origin_corner","title":"<code>get_origin_corner() -&gt; constants.CornerStr</code>","text":"<p>Return current origin corner.</p> <p>Returns:</p> Type Description <code>constants.CornerStr</code> <p>origin corner</p> Source code in <code>prettyqt\\widgets\\gridlayout.py</code> <pre><code>def get_origin_corner(self) -&gt; constants.CornerStr:\n\"\"\"Return current origin corner.\n    Returns:\n        origin corner\n    \"\"\"\nreturn constants.CORNER.inverse[self.originCorner()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.set_origin_corner","title":"<code>set_origin_corner(corner: constants.CornerStr | constants.Corner)</code>","text":"<p>Set the origin corner.</p> <p>Parameters:</p> Name Type Description Default <code>corner</code> <code>constants.CornerStr | constants.Corner</code> <p>origin corner</p> required Source code in <code>prettyqt\\widgets\\gridlayout.py</code> <pre><code>def set_origin_corner(self, corner: constants.CornerStr | constants.Corner):\n\"\"\"Set the origin corner.\n    Args:\n        corner: origin corner\n    \"\"\"\nself.setOriginCorner(constants.CORNER.get_enum_value(corner))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GroupBox","title":"<code>GroupBox</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QGroupBox</code></p> <p>GroupBox widget.</p> <p>A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets.</p> Source code in <code>prettyqt\\widgets\\groupbox.py</code> <pre><code>class GroupBox(widgets.WidgetMixin, QtWidgets.QGroupBox):\n\"\"\"GroupBox widget.\n    A group box provides a frame, a title on top, a keyboard shortcut,\n    and displays various other widgets inside itself.\n    The keyboard shortcut moves keyboard focus to one of the group box's child widgets.\n    \"\"\"\ndef __repr__(self):\nreturn get_repr(self, self.title())\ndef set_title(self, title: str):\nself.setTitle(title)\ndef set_alignment(\nself, alignment: constants.HorizontalAlignmentStr | constants.AlignmentFlag\n):\n\"\"\"Set the title alignment of the groupbox.\n        Args:\n            alignment: title alignment for the groupbox\n        \"\"\"\nself.setAlignment(constants.H_ALIGNMENT.get_enum_value(alignment))\ndef get_alignment(self) -&gt; constants.HorizontalAlignmentStr:\n\"\"\"Return current title alignment.\n        Returns:\n            title alignment\n        \"\"\"\nreturn constants.H_ALIGNMENT.inverse[self.alignment()]\ndef set_enabled(self, state):\nfor widget in self.layout():\nwidget.setEnabled(state)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.groupbox.GroupBox.get_alignment","title":"<code>get_alignment() -&gt; constants.HorizontalAlignmentStr</code>","text":"<p>Return current title alignment.</p> <p>Returns:</p> Type Description <code>constants.HorizontalAlignmentStr</code> <p>title alignment</p> Source code in <code>prettyqt\\widgets\\groupbox.py</code> <pre><code>def get_alignment(self) -&gt; constants.HorizontalAlignmentStr:\n\"\"\"Return current title alignment.\n    Returns:\n        title alignment\n    \"\"\"\nreturn constants.H_ALIGNMENT.inverse[self.alignment()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.groupbox.GroupBox.set_alignment","title":"<code>set_alignment(alignment: constants.HorizontalAlignmentStr | constants.AlignmentFlag)</code>","text":"<p>Set the title alignment of the groupbox.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.HorizontalAlignmentStr | constants.AlignmentFlag</code> <p>title alignment for the groupbox</p> required Source code in <code>prettyqt\\widgets\\groupbox.py</code> <pre><code>def set_alignment(\nself, alignment: constants.HorizontalAlignmentStr | constants.AlignmentFlag\n):\n\"\"\"Set the title alignment of the groupbox.\n    Args:\n        alignment: title alignment for the groupbox\n    \"\"\"\nself.setAlignment(constants.H_ALIGNMENT.get_enum_value(alignment))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.InputDialog","title":"<code>InputDialog</code>","text":"<p>         Bases: <code>widgets.DialogMixin</code>, <code>QtWidgets.QInputDialog</code></p> Source code in <code>prettyqt\\widgets\\inputdialog.py</code> <pre><code>class InputDialog(widgets.DialogMixin, QtWidgets.QInputDialog):\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"textEchoMode\": widgets.lineedit.ECHO_MODE,\n\"inputMode\": INPUT_MODE,\n\"options\": INPUT_DIALOG_OPTION,\n}\nreturn maps\n@classmethod\ndef get_int(\ncls,\ntitle: str = \"\",\nlabel: str = \"\",\nicon: datatypes.IconType = None,\n) -&gt; int | None:\npar = widgets.Dialog()\npar.set_icon(icon)\nv = cls.getInt(par, title, label, value=0)\nreturn v[0] if v[1] else None\n@classmethod\ndef get_float(\ncls,\ntitle: str = \"\",\nlabel: str = \"\",\nicon: datatypes.IconType = None,\n) -&gt; float | None:\npar = widgets.Dialog()\npar.set_icon(icon)\nv = cls.getDouble(par, title, label, value=0.0)\nreturn v[0] if v[1] else None\n@classmethod\ndef get_text(\ncls,\ntitle: str = \"\",\nlabel: str = \"\",\nicon: datatypes.IconType = None,\nvalue: str = \"\",\necho_mode: widgets.lineedit.EchoModeStr | widgets.QLineEdit.EchoMode = \"normal\",\n) -&gt; str | None:\npar = widgets.Dialog()\npar.set_icon(icon)\nv = cls.getText(\npar, title, label, widgets.lineedit.ECHO_MODE.get_enum_value(echo_mode), value\n)\nreturn v[0] if v[1] else None\n@classmethod\ndef get_item(\ncls,\nitems: list[str],\ntitle: str = \"\",\nlabel: str = \"\",\nicon: datatypes.IconType = None,\neditable: bool = False,\n) -&gt; str | None:\npar = widgets.Dialog()\npar.set_icon(icon)\nv = cls.getItem(par, title, label, items, editable=editable, current=0)\nreturn v[0] if v[1] else None\ndef set_text_echo_mode(\nself, mode: widgets.lineedit.EchoModeStr | widgets.QLineEdit.EchoMode\n):\n\"\"\"Set text echo mode.\n        Args:\n            mode: echo mode to use\n        \"\"\"\nself.setTextEchoMode(widgets.lineedit.ECHO_MODE.get_enum_value(mode))\ndef get_text_echo_mode(self) -&gt; widgets.lineedit.EchoModeStr:\n\"\"\"Return text echo mode.\n        Returns:\n            echo mode\n        \"\"\"\nreturn widgets.lineedit.ECHO_MODE.inverse[self.textEchoMode()]\ndef set_input_mode(self, mode: InputModeStr | mod.InputMode):\n\"\"\"Set input mode.\n        Args:\n            mode: input mode to use\n        \"\"\"\nself.setInputMode(INPUT_MODE.get_enum_value(mode))\ndef get_input_mode(self) -&gt; InputModeStr:\n\"\"\"Return input mode.\n        Returns:\n            input mode\n        \"\"\"\nreturn INPUT_MODE.inverse[self.inputMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.get_input_mode","title":"<code>get_input_mode() -&gt; InputModeStr</code>","text":"<p>Return input mode.</p> <p>Returns:</p> Type Description <code>InputModeStr</code> <p>input mode</p> Source code in <code>prettyqt\\widgets\\inputdialog.py</code> <pre><code>def get_input_mode(self) -&gt; InputModeStr:\n\"\"\"Return input mode.\n    Returns:\n        input mode\n    \"\"\"\nreturn INPUT_MODE.inverse[self.inputMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.get_text_echo_mode","title":"<code>get_text_echo_mode() -&gt; widgets.lineedit.EchoModeStr</code>","text":"<p>Return text echo mode.</p> <p>Returns:</p> Type Description <code>widgets.lineedit.EchoModeStr</code> <p>echo mode</p> Source code in <code>prettyqt\\widgets\\inputdialog.py</code> <pre><code>def get_text_echo_mode(self) -&gt; widgets.lineedit.EchoModeStr:\n\"\"\"Return text echo mode.\n    Returns:\n        echo mode\n    \"\"\"\nreturn widgets.lineedit.ECHO_MODE.inverse[self.textEchoMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.set_input_mode","title":"<code>set_input_mode(mode: InputModeStr | mod.InputMode)</code>","text":"<p>Set input mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>InputModeStr | mod.InputMode</code> <p>input mode to use</p> required Source code in <code>prettyqt\\widgets\\inputdialog.py</code> <pre><code>def set_input_mode(self, mode: InputModeStr | mod.InputMode):\n\"\"\"Set input mode.\n    Args:\n        mode: input mode to use\n    \"\"\"\nself.setInputMode(INPUT_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.set_text_echo_mode","title":"<code>set_text_echo_mode(mode: widgets.lineedit.EchoModeStr | widgets.QLineEdit.EchoMode)</code>","text":"<p>Set text echo mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>widgets.lineedit.EchoModeStr | widgets.QLineEdit.EchoMode</code> <p>echo mode to use</p> required Source code in <code>prettyqt\\widgets\\inputdialog.py</code> <pre><code>def set_text_echo_mode(\nself, mode: widgets.lineedit.EchoModeStr | widgets.QLineEdit.EchoMode\n):\n\"\"\"Set text echo mode.\n    Args:\n        mode: echo mode to use\n    \"\"\"\nself.setTextEchoMode(widgets.lineedit.ECHO_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.LCDNumber","title":"<code>LCDNumber</code>","text":"<p>         Bases: <code>widgets.FrameMixin</code>, <code>QtWidgets.QLCDNumber</code></p> Source code in <code>prettyqt\\widgets\\lcdnumber.py</code> <pre><code>class LCDNumber(widgets.FrameMixin, QtWidgets.QLCDNumber):\nvalue_changed = core.Signal(float)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"segmentStyle\": SEGMENT_STYLE, \"mode\": MODE}\nreturn maps\ndef set_mode(self, mode: ModeStr | QtWidgets.QLCDNumber.Mode):\n\"\"\"Set the lcd mode.\n        Args:\n            mode: lcd mode to use\n        \"\"\"\nself.setMode(MODE.get_enum_value(mode))\ndef get_mode(self) -&gt; ModeStr:\n\"\"\"Return current lcd mode.\n        Returns:\n            lcd mode\n        \"\"\"\nreturn MODE.inverse[self.mode()]\ndef set_segment_style(\nself, style: SegmentStyleStr | QtWidgets.QLCDNumber.SegmentStyle\n):\n\"\"\"Set the segment style.\n        Args:\n            style: segment style to use\n        \"\"\"\nself.setSegmentStyle(SEGMENT_STYLE.get_enum_value(style))\ndef get_segment_style(self) -&gt; SegmentStyleStr:\n\"\"\"Return current segment style.\n        Returns:\n            segment style\n        \"\"\"\nreturn SEGMENT_STYLE.inverse[self.segmentStyle()]\ndef set_value(self, value: float | str):\nif value != self.value():\nself.value_changed.emit(float(value))\nself.display(value)\ndef get_value(self) -&gt; float:\nreturn self.value()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_mode","title":"<code>get_mode() -&gt; ModeStr</code>","text":"<p>Return current lcd mode.</p> <p>Returns:</p> Type Description <code>ModeStr</code> <p>lcd mode</p> Source code in <code>prettyqt\\widgets\\lcdnumber.py</code> <pre><code>def get_mode(self) -&gt; ModeStr:\n\"\"\"Return current lcd mode.\n    Returns:\n        lcd mode\n    \"\"\"\nreturn MODE.inverse[self.mode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_segment_style","title":"<code>get_segment_style() -&gt; SegmentStyleStr</code>","text":"<p>Return current segment style.</p> <p>Returns:</p> Type Description <code>SegmentStyleStr</code> <p>segment style</p> Source code in <code>prettyqt\\widgets\\lcdnumber.py</code> <pre><code>def get_segment_style(self) -&gt; SegmentStyleStr:\n\"\"\"Return current segment style.\n    Returns:\n        segment style\n    \"\"\"\nreturn SEGMENT_STYLE.inverse[self.segmentStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_mode","title":"<code>set_mode(mode: ModeStr | QtWidgets.QLCDNumber.Mode)</code>","text":"<p>Set the lcd mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ModeStr | QtWidgets.QLCDNumber.Mode</code> <p>lcd mode to use</p> required Source code in <code>prettyqt\\widgets\\lcdnumber.py</code> <pre><code>def set_mode(self, mode: ModeStr | QtWidgets.QLCDNumber.Mode):\n\"\"\"Set the lcd mode.\n    Args:\n        mode: lcd mode to use\n    \"\"\"\nself.setMode(MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_segment_style","title":"<code>set_segment_style(style: SegmentStyleStr | QtWidgets.QLCDNumber.SegmentStyle)</code>","text":"<p>Set the segment style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>SegmentStyleStr | QtWidgets.QLCDNumber.SegmentStyle</code> <p>segment style to use</p> required Source code in <code>prettyqt\\widgets\\lcdnumber.py</code> <pre><code>def set_segment_style(\nself, style: SegmentStyleStr | QtWidgets.QLCDNumber.SegmentStyle\n):\n\"\"\"Set the segment style.\n    Args:\n        style: segment style to use\n    \"\"\"\nself.setSegmentStyle(SEGMENT_STYLE.get_enum_value(style))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.Label","title":"<code>Label</code>","text":"<p>         Bases: <code>widgets.FrameMixin</code>, <code>QtWidgets.QLabel</code></p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>class Label(widgets.FrameMixin, QtWidgets.QLabel):\nelision_changed = core.Signal(bool)\nclicked = core.Signal()\ndef __init__(self, *args, **kwargs):\nself._elide_mode = constants.TextElideMode.ElideNone\nsuper().__init__(*args, **kwargs)\nself.openExternalLinks()\nself._is_elided = False\ndef mouseReleaseEvent(self, ev: QtGui.QMouseEvent):\nif ev.button() == constants.MouseButton.LeftButton:\nself.clicked.emit()\nreturn super().mouseReleaseEvent(ev)\ndef set_elide_mode(self, mode: constants.TextElideModeStr):\nself._elide_mode = constants.TEXT_ELIDE_MODE[mode]\nself.update()\ndef get_elide_mode(self) -&gt; constants.TextElideModeStr:\nreturn constants.TEXT_ELIDE_MODE.inverse[self._elide_mode]\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"textFormat\": constants.TEXT_FORMAT, \"alignment\": constants.ALIGNMENTS}\nreturn maps\ndef __repr__(self):\nreturn get_repr(self, self.text())\n# # adapted from https://forum.qt.io/topic/24530/solved-shortening-a-label/3\n# def minimumSizeHint(self):\n#     if self._elide_mode != constants.TextElideMode.ElideNone:\n#         # TODO: tweak sizeHint\n#         # -&gt; text should expand if user increases window size,\n#         #    but don't automatically adapt window size to label width on UI update!\n#         #    (somehow calculate minimumSizeHint + sizeHint with font metrics???)\n#         fm = self.fontMetrics()\n#         size = QtCore.QSize(fm.width(\"...\"), fm.height())\n#         return size\n#     else:\n#         size = self.minimumSizeHint()\n#         return QtCore.QSize(size.width() + 13, size.height())\n# # adapted from https://www.mimec.org/blog/status-bar-and-elided-label\n# def paintEvent(self, event):\n#     with gui.Painter(self) as painter:\n#         self.drawFrame(painter)\n#         rect = self.contentsRect()\n#         rect.adjust(self.margin(), self.margin(), -self.margin(), -self.margin())\n#         elided_text = painter.fontMetrics().elidedText(\n#             self.text(), self._elide_mode, rect.width()\n#         )\n#         style_option = QtWidgets.QStyleOption()\n#         style_option.initFrom(self)\n#         self.style().drawItemText(\n#             painter,\n#             rect,\n#             self.alignment(),\n#             style_option.palette,\n#             self.isEnabled(),\n#             elided_text,\n#             self.foregroundRole(),\n#         )\ndef paintEvent(self, event):\nif self._elide_mode == constants.TextElideMode.ElideNone:\nsuper().paintEvent(event)\nreturn\ndid_elide = False\nwith gui.Painter(self) as painter:\nfont_metrics = painter.fontMetrics()\ntext_lines = self.text().split(\"\\n\")\ntext_width = font_metrics.horizontalAdvance(self.text())\nline_spacing = font_metrics.lineSpacing()\n# layout phase\ntext_layout = gui.TextLayout(self.text(), painter.font())\ncurrent_y = 0\nwith text_layout.process_layout():\nfor line in text_lines:\ntext_width = font_metrics.horizontalAdvance(line)\n# if self.height() &gt;= next_line_y + line_spacing:\n#     line.draw(painter, core.PointF(0, y))\n#     y = next_line_y\n# else:\n#     last_line = self._text[line.textStart() :]\n#     elided_line = metrics.elided_text(\n#         last_line, \"right\", self.width()\n#     )\n#     painter.drawText(0, y + metrics.ascent(), elided_line)\n#     line = layout.createLine()\n#     did_elide = line.isValid()\n#     break\nif text_width &gt;= self.width():\nelided_line = font_metrics.elidedText(\nline, self._elide_mode, self.width()\n)\npainter.drawText(\nQtCore.QRect(0, current_y, self.width(), self.height()),\nint(self.alignment()),\nelided_line,\n)\ndid_elide = True\nelse:\npainter.drawText(\nQtCore.QRect(0, current_y, self.width(), self.height()),\nint(self.alignment()),\nline,\n)\ncurrent_y += line_spacing\nif did_elide != self._is_elided:\nself._is_elided = did_elide\nself.elision_changed.emit(did_elide)\ndef allow_links(self) -&gt; Label:\n# self.setText(\"&lt;a href=\\\"http://example.com/\\\"&gt;Click Here!&lt;/a&gt;\")\nself.setTextFormat(constants.TextFormat.RichText)\nself.setTextInteractionFlags(constants.TextInteractionFlag.TextBrowserInteraction)\nself.setOpenExternalLinks(True)\nreturn self\ndef set_alignment(\nself,\nhorizontal: constants.HorizontalAlignmentStr | None = None,\nvertical: constants.VerticalAlignmentStr | None = None,\n):\n\"\"\"Set the alignment of the label's contents.\"\"\"\nmatch horizontal, vertical:\ncase None, None:\nreturn self\ncase None, _:\nflag = constants.V_ALIGNMENT[vertical]\ncase _, None:\nflag = constants.H_ALIGNMENT[horizontal]\ncase _, _:\nflag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\nself.setAlignment(flag)\nreturn self\ndef get_horizontal_alignment(self) -&gt; constants.HorizontalAlignmentStr:\nalign = self.alignment()\nif align &amp; constants.ALIGN_RIGHT:  # type: ignore\nreturn \"right\"\nelif align &amp; constants.ALIGN_H_CENTER:  # type: ignore\nreturn \"center\"\nelif align &amp; constants.ALIGN_JUSTIFY:  # type: ignore\nreturn \"justify\"\nelse:\nreturn \"left\"\ndef get_vertical_alignment(self) -&gt; constants.VerticalAlignmentStr:\nalign = self.alignment()\nif align &amp; constants.ALIGN_TOP:  # type: ignore\nreturn \"top\"\nelif align &amp; constants.ALIGN_BOTTOM:  # type: ignore\nreturn \"bottom\"\nelif align &amp; constants.ALIGN_BASELINE:  # type: ignore\nreturn \"baseline\"\nelse:\nreturn \"center\"\ndef set_indent(self, indent: int) -&gt; Label:\n\"\"\"Set the label's text indent in pixels.\"\"\"\nself.setIndent(indent)\nreturn self\ndef set_text_format(\nself, text_format: constants.TextFormatStr | constants.TextFormat\n) -&gt; Label:\n\"\"\"Set the text format.\n        Args:\n            text_format: text format to use\n        \"\"\"\nself.setTextFormat(constants.TEXT_FORMAT.get_enum_value(text_format))\nreturn self\ndef get_text_format(self) -&gt; constants.TextFormatStr:\n\"\"\"Return current text format.\n        Returns:\n            text format\n        \"\"\"\nreturn constants.TEXT_FORMAT.inverse[self.textFormat()]\ndef set_text_interaction(self, *types: constants.TextInteractionStr) -&gt; Label:\n\"\"\"Set the text interaction mode.\n        Args:\n            types: text interaction mode to use\n        \"\"\"\nflags = constants.TEXT_INTERACTION.merge_flags(types)\nself.setTextInteractionFlags(flags)\nreturn self\ndef get_text_interaction(self) -&gt; list[constants.TextInteractionStr]:\n\"\"\"Return current text interaction mode.\n        Returns:\n            list of text interaction modes\n        \"\"\"\nreturn constants.TEXT_INTERACTION.get_list(self.textInteractionFlags())\ndef set_text(self, text: str) -&gt; Label:\n\"\"\"Set the label's text.\"\"\"\nself.setText(text)\nreturn self\ndef set_bold(self, bold: bool = True) -&gt; Label:\nfont = self.font()\nfont.setBold(bold)\nself.setFont(font)\nreturn self\ndef set_italic(self, italic: bool = True) -&gt; Label:\nfont = self.font()\nfont.setItalic(italic)\nself.setFont(font)\nreturn self\ndef set_point_size(self, size: int) -&gt; Label:\nfont = self.font()\nfont.setPointSize(size)\nself.setFont(font)\nreturn self\ndef set_weight(self, weight: gui.font.WeightStr | gui.QFont.Weight) -&gt; Label:\n\"\"\"Set the font weight.\n        Args:\n            weight: font weight\n        \"\"\"\nfont = self.font()\nfont.setWeight(gui.font.WEIGHT.get_enum_value(weight))\nself.setFont(font)\nreturn self\ndef set_color(self, color: datatypes.ColorType) -&gt; Label:\nwith self.edit_stylesheet() as ss:\nif color is None:\nss.color.setValue(\"\")\nelse:\ncolor = colors.get_color(color)\nss.color.setValue(color.name())\nreturn self\ndef set_image(self, path: datatypes.PathType, width: int = 300) -&gt; Label:\nself.setScaledContents(True)\nself.set_alignment(horizontal=\"center\")\nself.setText(\n\"&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;\"\nf\"&lt;img src={os.fspath(path)!r} width={str(width)!r}/&gt;\"\n\"&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\n)\nreturn self\n@classmethod\ndef image_from_path(\ncls, path: datatypes.PathType, parent: QtWidgets.QWidget | None = None\n) -&gt; Self:\npixmap = gui.Pixmap.from_file(path)\nlabel = cls(parent=parent)\nlabel.setPixmap(pixmap)\nlabel.resize(pixmap.width(), pixmap.height())\nreturn label\nelideMode = core.Property(str, get_elide_mode, set_elide_mode)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_format","title":"<code>get_text_format() -&gt; constants.TextFormatStr</code>","text":"<p>Return current text format.</p> <p>Returns:</p> Type Description <code>constants.TextFormatStr</code> <p>text format</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def get_text_format(self) -&gt; constants.TextFormatStr:\n\"\"\"Return current text format.\n    Returns:\n        text format\n    \"\"\"\nreturn constants.TEXT_FORMAT.inverse[self.textFormat()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_interaction","title":"<code>get_text_interaction() -&gt; list[constants.TextInteractionStr]</code>","text":"<p>Return current text interaction mode.</p> <p>Returns:</p> Type Description <code>list[constants.TextInteractionStr]</code> <p>list of text interaction modes</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def get_text_interaction(self) -&gt; list[constants.TextInteractionStr]:\n\"\"\"Return current text interaction mode.\n    Returns:\n        list of text interaction modes\n    \"\"\"\nreturn constants.TEXT_INTERACTION.get_list(self.textInteractionFlags())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_alignment","title":"<code>set_alignment(horizontal: constants.HorizontalAlignmentStr | None = None, vertical: constants.VerticalAlignmentStr | None = None)</code>","text":"<p>Set the alignment of the label's contents.</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_alignment(\nself,\nhorizontal: constants.HorizontalAlignmentStr | None = None,\nvertical: constants.VerticalAlignmentStr | None = None,\n):\n\"\"\"Set the alignment of the label's contents.\"\"\"\nmatch horizontal, vertical:\ncase None, None:\nreturn self\ncase None, _:\nflag = constants.V_ALIGNMENT[vertical]\ncase _, None:\nflag = constants.H_ALIGNMENT[horizontal]\ncase _, _:\nflag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\nself.setAlignment(flag)\nreturn self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_indent","title":"<code>set_indent(indent: int) -&gt; Label</code>","text":"<p>Set the label's text indent in pixels.</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_indent(self, indent: int) -&gt; Label:\n\"\"\"Set the label's text indent in pixels.\"\"\"\nself.setIndent(indent)\nreturn self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text","title":"<code>set_text(text: str) -&gt; Label</code>","text":"<p>Set the label's text.</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_text(self, text: str) -&gt; Label:\n\"\"\"Set the label's text.\"\"\"\nself.setText(text)\nreturn self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_format","title":"<code>set_text_format(text_format: constants.TextFormatStr | constants.TextFormat) -&gt; Label</code>","text":"<p>Set the text format.</p> <p>Parameters:</p> Name Type Description Default <code>text_format</code> <code>constants.TextFormatStr | constants.TextFormat</code> <p>text format to use</p> required Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_text_format(\nself, text_format: constants.TextFormatStr | constants.TextFormat\n) -&gt; Label:\n\"\"\"Set the text format.\n    Args:\n        text_format: text format to use\n    \"\"\"\nself.setTextFormat(constants.TEXT_FORMAT.get_enum_value(text_format))\nreturn self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_interaction","title":"<code>set_text_interaction(*types: constants.TextInteractionStr) -&gt; Label</code>","text":"<p>Set the text interaction mode.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>constants.TextInteractionStr</code> <p>text interaction mode to use</p> <code>()</code> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_text_interaction(self, *types: constants.TextInteractionStr) -&gt; Label:\n\"\"\"Set the text interaction mode.\n    Args:\n        types: text interaction mode to use\n    \"\"\"\nflags = constants.TEXT_INTERACTION.merge_flags(types)\nself.setTextInteractionFlags(flags)\nreturn self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_weight","title":"<code>set_weight(weight: gui.font.WeightStr | gui.QFont.Weight) -&gt; Label</code>","text":"<p>Set the font weight.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>gui.font.WeightStr | gui.QFont.Weight</code> <p>font weight</p> required Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_weight(self, weight: gui.font.WeightStr | gui.QFont.Weight) -&gt; Label:\n\"\"\"Set the font weight.\n    Args:\n        weight: font weight\n    \"\"\"\nfont = self.font()\nfont.setWeight(gui.font.WEIGHT.get_enum_value(weight))\nself.setFont(font)\nreturn self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.LayoutItemMixin","title":"<code>LayoutItemMixin</code>","text":"Source code in <code>prettyqt\\widgets\\layoutitem.py</code> <pre><code>class LayoutItemMixin:\ndef __bool__(self):\nreturn not self.isEmpty()\ndef set_alignment(self, alignment: constants.AlignmentStr):\n\"\"\"Set the alignment of the layout.\n        Args:\n            alignment: alignment for the layout\n        \"\"\"\nself.setAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\ndef get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n        Returns:\n            alignment\n        \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.alignment()]\ndef get_item(\nself,\n) -&gt; QtWidgets.QWidget | QtWidgets.QLayout | QtWidgets.QSpacerItem | None:\nif content := self.widget():\nreturn content\nif content := self.layout():\nreturn content\nreturn content if (content := self.spacerItem()) else None\ndef get_control_types(self) -&gt; list[widgets.sizepolicy.ControlTypeStr]:\nreturn widgets.sizepolicy.CONTROL_TYPE.get_list(self.controlTypes())\ndef get_expanding_directions(self) -&gt; list[constants.OrientationStr]:\nreturn constants.ORIENTATION.get_list(self.expandingDirections())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layoutitem.LayoutItemMixin.get_alignment","title":"<code>get_alignment() -&gt; constants.AlignmentStr</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.AlignmentStr</code> <p>alignment</p> Source code in <code>prettyqt\\widgets\\layoutitem.py</code> <pre><code>def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n    Returns:\n        alignment\n    \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.alignment()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layoutitem.LayoutItemMixin.set_alignment","title":"<code>set_alignment(alignment: constants.AlignmentStr)</code>","text":"<p>Set the alignment of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr</code> <p>alignment for the layout</p> required Source code in <code>prettyqt\\widgets\\layoutitem.py</code> <pre><code>def set_alignment(self, alignment: constants.AlignmentStr):\n\"\"\"Set the alignment of the layout.\n    Args:\n        alignment: alignment for the layout\n    \"\"\"\nself.setAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.LayoutMixin","title":"<code>LayoutMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>widgets.LayoutItemMixin</code></p> Source code in <code>prettyqt\\widgets\\layout.py</code> <pre><code>class LayoutMixin(core.ObjectMixin, widgets.LayoutItemMixin):\ndef __init__(self, *args, margin=None, **kwargs):\nself._next_container = None\nself._stack = []\nsuper().__init__(*args, **kwargs)\nif margin is not None:\nself.set_margin(margin)\n@overload\ndef __getitem__(\nself, index: slice\n) -&gt; listdelegators.BaseListDelegator[widgets.QWidget | widgets.QLayout]:\n...\n@overload\ndef __getitem__(self, index: int | str) -&gt; widgets.QWidget | widgets.QLayout:\n...\ndef __getitem__(\nself, index: str | int | slice\n) -&gt; (\nwidgets.QWidget\n| widgets.QLayout\n| listdelegators.BaseListDelegator[widgets.QWidget | widgets.QLayout]\n):\nmatch index:\ncase int():\nif index &lt; 0:\nindex + self.count()\nif index &lt; 0 or index &gt;= self.count():\nraise IndexError(index)\nitem = self.itemAt(index)\nreturn i if (i := item.widget()) is not None else item.layout()\ncase str():\nif (item := self.find_child(typ=QtCore.QObject, name=index)) is not None:\nreturn item\nraise KeyError(index)\ncase slice():\nstop = index.stop or self.count()\nrng = range(index.start or 0, stop, index.step or 1)\nwidgets = [self[i] for i in rng]\nreturn listdelegators.BaseListDelegator(widgets, parent=self)\ncase _:\nraise TypeError(index)\ndef __setitem__(self, key, value):\nif self._container != self:\nself._container.__setitem__(key, value)\ndef __delitem__(self, item: int | QtWidgets.QLayoutItem):\nif isinstance(item, int):\nitem = self.itemAt(item)\nself.removeItem(item)\nitem.deleteLater()\ndef __len__(self) -&gt; int:\nreturn self.count()\ndef __iter__(self) -&gt; Iterator[QtWidgets.QWidget | QtWidgets.QLayout | None]:\nreturn iter(self[i] for i in range(self.count()))\ndef __contains__(self, item: QtWidgets.QWidget | QtWidgets.QLayoutItem):\nreturn self.indexOf(item) &gt;= 0\ndef __iadd__(self, item, *args, **kwargs):\nself.add(item, *args, **kwargs)\nreturn self\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"sizeConstraint\": SIZE_CONSTRAINT}\nreturn maps\ndef add(self, item, *args, **kwargs):\nmatch item:\ncase QtWidgets.QWidget():\nself._container.addWidget(item, *args, **kwargs)\ncase QtWidgets.QLayout():\nself._container.addLayout(item, *args, **kwargs)\ncase QtWidgets.QLayoutItem():\nself._container.addItem(item, *args, **kwargs)\ncase list():\nfor i in item:\nself._container.add(i, *args, **kwargs)\nreturn item\ndef __enter__(self):\ndef enter(item):\nif item._next_container is not None:\nenter(item._next_container)\nitem._stack.append(item._next_container)\nitem._next_container = None\nreturn item\nreturn enter(self)\ndef __exit__(self, *_):\ndef exit(item):\nif item._stack:\nitem = item._stack.pop()\nexit(item)\nexit(self)\n@property\ndef _container(self):\nreturn self._stack[-1] if self._stack else self\ndef get_sub_layout(\nself,\nlayout: str,\norientation: constants.OrientationStr | None = None,\nstretch: int | None = None,\n**kwargs,\n) -&gt; Self:\nfrom prettyqt import custom_widgets\nCONTEXT_LAYOUTS = dict(\nhorizontal=widgets.HBoxLayout,\nvertical=widgets.VBoxLayout,\ngrid=widgets.GridLayout,\nform=widgets.FormLayout,\nstacked=widgets.StackedLayout,\nflow=custom_widgets.FlowLayout,\nsplitter=widgets.Splitter,\nscroll=widgets.ScrollArea,\nframe=widgets.GroupBox,\n)\nKlass = CONTEXT_LAYOUTS[layout]\nmatch self._container:\ncase QtWidgets.QWidget() if layout == \"scroll\":\nscroller = Klass(parent=self._container)\nscroller.setWidgetResizable(True)\nwidget = widgets.Widget()\nscroller.set_widget(widget)\nnew = widget.set_layout(orientation, **kwargs)\ncase QtWidgets.QLayout() if layout == \"scroll\":\nscroller = Klass(parent=self._container)\nscroller.setWidgetResizable(True)\nwidget = widgets.Widget()\nscroller.set_widget(widget)\nnew = widget.set_layout(orientation, **kwargs)\nself._container.add(new)\ncase QtWidgets.QWidget() if layout == \"splitter\":\nnew = Klass(orientation=orientation, parent=self._container, **kwargs)\ncase QtWidgets.QLayout() if layout == \"splitter\":\nnew = Klass(orientation=orientation, **kwargs)\nself._container.add(new)\ncase QtWidgets.QWidget() if layout == \"frame\":\nframe = Klass(parent=self._container, **kwargs)\nwidget = widgets.Widget()\nnew = widget.set_layout(orientation or \"horizontal\")\nframe.set_layout(new)\ncase QtWidgets.QLayout() if layout == \"frame\":\nframe = Klass(**kwargs)\nwidget = widgets.Widget()\nnew = widget.set_layout(orientation or \"horizontal\")\nframe.set_layout(new)\nself._container.add(new)\ncase QtWidgets.QMainWindow():\nwidget = widgets.Widget(parent=self._container)\nself._container.setCentralWidget(widget)\nnew = Klass(widget, **kwargs)\ncase QtWidgets.QScrollArea():\nwidget = widgets.Widget(parent=self._container)\nself._container.setWidget(widget)\nself._container.setWidgetResizable(True)\nnew = widget.set_layout(\"vertical\", **kwargs)\ncase QtWidgets.QSplitter():\nwidget = widgets.Widget(parent=self._container)\nself._container.addWidget(widget)\nnew = Klass(widget, **kwargs)\ncase None | QtWidgets.QWidget():\nnew = Klass(self._container, **kwargs)\ncase QtWidgets.QLayout():\nnew = Klass(**kwargs)\nif stretch:\nself._container.add(new, stretch)\nelse:\nself._container.add(new)\nnew._stack = []\nnew._next_container = None\nself._next_container = new\nreturn self\ndef item_at(self, pos_or_index: int | core.Point) -&gt; widgets.QLayoutItem:\nmatch pos_or_index:\ncase int():\nreturn super().itemAt(pos_or_index)\ncase QtCore.QPoint():\nfor i in range(self.count()):\nitem = self.itemAt(i)\nif item.geometry().contains(pos_or_index):\nreturn item\ncase _:\nraise ValueError(pos_or_index)\ndef clear(self):\nfor i in reversed(range(self.count())):\nself.takeAt(i)\n# def takeAt(self, index: int):\n#     if index &lt; 0:\n#         index = self.count() + index\n#     return super().takeAt(index)\ndef get_items(self):\nreturn [self.itemAt(i) for i in range(self.count())]\ndef get_children(\nself,\n) -&gt; listdelegators.BaseListDelegator[QtWidgets.QWidget | QtWidgets.QLayout]:\nreturn listdelegators.BaseListDelegator(self)\ndef set_margin(self, margin: tuple[int, int, int, int] | int | None):\nmatch margin:\ncase None:\nself.unsetContentsMargins()\ncase int():\nself.setContentsMargins(margin, margin, margin, margin)\ncase (int(), int(), int(), int()):\nself.setContentsMargins(*margin)\ncase _:\nraise ValueError(margin)\ndef set_spacing(self, pixels: int):\nself.setSpacing(pixels)\ndef set_size_constraint(\nself, mode: SizeConstraintStr | QtWidgets.QLayout.SizeConstraint\n):\n\"\"\"Set the size mode of the layout.\n        Args:\n            mode: size mode for the layout\n        \"\"\"\nself.setSizeConstraint(SIZE_CONSTRAINT.get_enum_value(mode))\ndef get_size_constraint(self) -&gt; SizeConstraintStr:\n\"\"\"Return current size mode.\n        Returns:\n            size mode\n        \"\"\"\nreturn SIZE_CONSTRAINT.inverse[self.sizeConstraint()]\ndef set_alignment(\nself,\nalignment: constants.AlignmentStr | constants.AlignmentFlag,\nitem: QtWidgets.QWidget | QtWidgets.QLayout | None = None,\n) -&gt; bool:\n\"\"\"Set the alignment for widget / layout to alignment.\n        Returns true if w is found in this layout (not including child layouts).\n        Args:\n            alignment: alignment for the layout\n            item: set alignment for specific child only\n        \"\"\"\nif item is not None:\nreturn self.setAlignment(item, constants.ALIGNMENTS.get_enum_value(alignment))\nelse:\nreturn self.setAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layout.LayoutMixin.get_size_constraint","title":"<code>get_size_constraint() -&gt; SizeConstraintStr</code>","text":"<p>Return current size mode.</p> <p>Returns:</p> Type Description <code>SizeConstraintStr</code> <p>size mode</p> Source code in <code>prettyqt\\widgets\\layout.py</code> <pre><code>def get_size_constraint(self) -&gt; SizeConstraintStr:\n\"\"\"Return current size mode.\n    Returns:\n        size mode\n    \"\"\"\nreturn SIZE_CONSTRAINT.inverse[self.sizeConstraint()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layout.LayoutMixin.set_alignment","title":"<code>set_alignment(alignment: constants.AlignmentStr | constants.AlignmentFlag, item: QtWidgets.QWidget | QtWidgets.QLayout | None = None) -&gt; bool</code>","text":"<p>Set the alignment for widget / layout to alignment.</p> <p>Returns true if w is found in this layout (not including child layouts).</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr | constants.AlignmentFlag</code> <p>alignment for the layout</p> required <code>item</code> <code>QtWidgets.QWidget | QtWidgets.QLayout | None</code> <p>set alignment for specific child only</p> <code>None</code> Source code in <code>prettyqt\\widgets\\layout.py</code> <pre><code>def set_alignment(\nself,\nalignment: constants.AlignmentStr | constants.AlignmentFlag,\nitem: QtWidgets.QWidget | QtWidgets.QLayout | None = None,\n) -&gt; bool:\n\"\"\"Set the alignment for widget / layout to alignment.\n    Returns true if w is found in this layout (not including child layouts).\n    Args:\n        alignment: alignment for the layout\n        item: set alignment for specific child only\n    \"\"\"\nif item is not None:\nreturn self.setAlignment(item, constants.ALIGNMENTS.get_enum_value(alignment))\nelse:\nreturn self.setAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layout.LayoutMixin.set_size_constraint","title":"<code>set_size_constraint(mode: SizeConstraintStr | QtWidgets.QLayout.SizeConstraint)</code>","text":"<p>Set the size mode of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SizeConstraintStr | QtWidgets.QLayout.SizeConstraint</code> <p>size mode for the layout</p> required Source code in <code>prettyqt\\widgets\\layout.py</code> <pre><code>def set_size_constraint(\nself, mode: SizeConstraintStr | QtWidgets.QLayout.SizeConstraint\n):\n\"\"\"Set the size mode of the layout.\n    Args:\n        mode: size mode for the layout\n    \"\"\"\nself.setSizeConstraint(SIZE_CONSTRAINT.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.LineEdit","title":"<code>LineEdit</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>widgets.QLineEdit</code></p> Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>class LineEdit(widgets.WidgetMixin, widgets.QLineEdit):\nvalue_changed = core.Signal(str)\ntab_pressed = core.Signal()\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.textChanged.connect(self._on_value_change)\ndef _on_value_change(self):\nval = self.get_value()\nself._set_validation_color()\nself.value_changed.emit(val)\ndef __repr__(self):\nreturn get_repr(self, self.text())\ndef __add__(self, other: str):\nself.append_text(other)\nreturn self\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"echoMode\": ECHO_MODE,\n\"cursorMoveStyle\": constants.CURSOR_MOVE_STYLE,\n\"alignment\": constants.ALIGNMENTS,\n}\nreturn maps\ndef font(self) -&gt; gui.Font:\nreturn gui.Font(super().font())\ndef keyPressEvent(self, event):\nsuper().keyPressEvent(event)\nif event.key() == constants.Key.Key_Tab:\nself.tab_pressed.emit()\ndef append_text(self, text: str):\nself.set_text(self.text() + text)\ndef set_text(self, text: str):\nself.setText(text)\ndef set_completer(self, completer: widgets.QCompleter | Literal[\"files\"]):\nmatch completer:\ncase widgets.QCompleter():\nself.setCompleter(completer)\ncase \"files\":\nmodel = widgets.FileSystemModel()\nmodel.set_root_path(\"\")\ncompleter = widgets.Completer(self)\ncompleter.setModel(model)\nself.setCompleter(completer)\ndef set_read_only(self, value: bool = True):\n\"\"\"Set text to read-only.\n        Args:\n            value: True, for read-only, otherwise False\n        \"\"\"\nself.setReadOnly(value)\ndef set_regex_validator(\nself, regex: str, flags: int = 0\n) -&gt; gui.RegularExpressionValidator:\nvalidator = gui.RegularExpressionValidator(self)\nvalidator.set_regex(regex, flags)\nself.set_validator(validator)\nreturn validator\ndef set_range(self, lower: int | None, upper: int | None):\nval = gui.IntValidator()\nval.set_range(lower, upper)\nself.set_validator(val)\ndef set_validator(\nself,\nvalidator: gui.QValidator\n| ValidatorStr\n| datatypes.PatternType\n| Callable\n| None,\nstrict: bool = True,\nempty_allowed: bool | None = None,\nappend: bool = False,\n**kwargs,\n) -&gt; gui.QValidator:\nfrom prettyqt import custom_validators\nmatch validator:\ncase str() if \"|\" in validator:\nvalidators = [get_validator(i, **kwargs) for i in validator.split(\"|\")]\nvalidator: widgets.QValidator = custom_validators.AndValidator(validators)\ncase str() | re.Pattern() | core.QRegularExpression() | Callable():\nvalidator = get_validator(validator, **kwargs)\ncase None | gui.QValidator():\npass\ncase _:\nraise ValueError(validator)\nif empty_allowed is False:\nvalidator = custom_validators.AndValidator(\n[validator, custom_validators.NotEmptyValidator()]\n)\nelif empty_allowed is True:\nvalidator = custom_validators.OrValidator(\n[validator, custom_validators.EmptyValidator()]\n)\nif not strict:\nvalidator = custom_validators.NotStrictValidator(validator)\nif append and (prev := widget.validator()) is not None:\nvalidator = custom_validators.AndValidator([prev, validator])\nself.setValidator(validator)\nself._set_validation_color()\nreturn validator\ndef set_input_mask(self, mask: str):\nmatch mask:\ncase \"ip_address\":\nmask = \"000.000.000.000;_\"\ncase \"mac_address\":\nmask = \"HH:HH:HH:HH:HH:HH;_\"\ncase \"iso_date\":\nmask = \"0000-00-00\"\nself.setInputMask(mask)\ndef _set_validation_color(self):\ncolor = None if self.hasAcceptableInput() else \"orange\"\nself.set_background_color(color)\ndef set_echo_mode(self, mode: EchoModeStr | widgets.QLineEdit.EchoMode):\n\"\"\"Set echo mode.\n        Args:\n            mode: echo mode to use\n        \"\"\"\nself.setEchoMode(ECHO_MODE.get_enum_value(mode))\ndef get_echo_mode(self) -&gt; EchoModeStr:\n\"\"\"Return echo mode.\n        Returns:\n            echo mode\n        \"\"\"\nreturn ECHO_MODE.inverse[self.echoMode()]\ndef set_cursor_move_style(\nself, style: constants.CursorMoveStyleStr | constants.CursorMoveStyle\n):\n\"\"\"Set cursor move style.\n        Args:\n            style: cursor move style to use\n        \"\"\"\nself.setCursorMoveStyle(constants.CURSOR_MOVE_STYLE.get_enum_value(style))\ndef get_cursor_move_style(self) -&gt; constants.CursorMoveStyleStr:\n\"\"\"Return cursor move style.\n        Returns:\n            cursor move style\n        \"\"\"\nreturn constants.CURSOR_MOVE_STYLE.inverse[self.cursorMoveStyle()]\ndef add_action(\nself,\naction: gui.QAction,\nposition: ActionPositionStr | widgets.QLineEdit.ActionPosition = \"trailing\",\n):\nself.addAction(action, ACTION_POSITION.get_enum_value(position))\ndef set_value(self, value: str):\nself.setText(value)\ndef get_value(self) -&gt; str:\nreturn self.text()\ndef is_valid(self) -&gt; bool:\nreturn self.hasAcceptableInput()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_cursor_move_style","title":"<code>get_cursor_move_style() -&gt; constants.CursorMoveStyleStr</code>","text":"<p>Return cursor move style.</p> <p>Returns:</p> Type Description <code>constants.CursorMoveStyleStr</code> <p>cursor move style</p> Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>def get_cursor_move_style(self) -&gt; constants.CursorMoveStyleStr:\n\"\"\"Return cursor move style.\n    Returns:\n        cursor move style\n    \"\"\"\nreturn constants.CURSOR_MOVE_STYLE.inverse[self.cursorMoveStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_echo_mode","title":"<code>get_echo_mode() -&gt; EchoModeStr</code>","text":"<p>Return echo mode.</p> <p>Returns:</p> Type Description <code>EchoModeStr</code> <p>echo mode</p> Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>def get_echo_mode(self) -&gt; EchoModeStr:\n\"\"\"Return echo mode.\n    Returns:\n        echo mode\n    \"\"\"\nreturn ECHO_MODE.inverse[self.echoMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_cursor_move_style","title":"<code>set_cursor_move_style(style: constants.CursorMoveStyleStr | constants.CursorMoveStyle)</code>","text":"<p>Set cursor move style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.CursorMoveStyleStr | constants.CursorMoveStyle</code> <p>cursor move style to use</p> required Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>def set_cursor_move_style(\nself, style: constants.CursorMoveStyleStr | constants.CursorMoveStyle\n):\n\"\"\"Set cursor move style.\n    Args:\n        style: cursor move style to use\n    \"\"\"\nself.setCursorMoveStyle(constants.CURSOR_MOVE_STYLE.get_enum_value(style))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_echo_mode","title":"<code>set_echo_mode(mode: EchoModeStr | widgets.QLineEdit.EchoMode)</code>","text":"<p>Set echo mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>EchoModeStr | widgets.QLineEdit.EchoMode</code> <p>echo mode to use</p> required Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>def set_echo_mode(self, mode: EchoModeStr | widgets.QLineEdit.EchoMode):\n\"\"\"Set echo mode.\n    Args:\n        mode: echo mode to use\n    \"\"\"\nself.setEchoMode(ECHO_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_read_only","title":"<code>set_read_only(value: bool = True)</code>","text":"<p>Set text to read-only.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True, for read-only, otherwise False</p> <code>True</code> Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>def set_read_only(self, value: bool = True):\n\"\"\"Set text to read-only.\n    Args:\n        value: True, for read-only, otherwise False\n    \"\"\"\nself.setReadOnly(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ListViewMixin","title":"<code>ListViewMixin</code>","text":"<p>         Bases: <code>widgets.AbstractItemViewMixin</code></p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>class ListViewMixin(widgets.AbstractItemViewMixin):\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"viewMode\": VIEW_MODE,\n\"resizeMode\": RESIZE_MODE,\n\"layoutMode\": LAYOUT_MODE,\n\"movement\": MOVEMENT,\n\"flow\": FLOW,\n}\nreturn maps\ndef set_view_mode(self, mode: ViewModeStr | QtWidgets.QListView.ViewMode):\n\"\"\"Set view mode.\n        Args:\n            mode: view mode to use\n        \"\"\"\nself.setViewMode(VIEW_MODE.get_enum_value(mode))\ndef get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n        Returns:\n            view mode\n        \"\"\"\nreturn VIEW_MODE.inverse[self.viewMode()]\ndef set_resize_mode(self, mode: ResizeModeStr | QtWidgets.QListView.ResizeMode):\n\"\"\"Set resize mode.\n        Args:\n            mode: resize mode to use\n        \"\"\"\nself.setResizeMode(RESIZE_MODE.get_enum_value(mode))\ndef get_resize_mode(self) -&gt; ResizeModeStr:\n\"\"\"Return resize mode.\n        Returns:\n            resize mode\n        \"\"\"\nreturn RESIZE_MODE.inverse[self.resizeMode()]\ndef set_layout_mode(self, mode: LayoutModeStr | QtWidgets.QListView.LayoutMode):\n\"\"\"Set layout mode.\n        Args:\n            mode: layout mode to use\n        \"\"\"\nself.setLayoutMode(LAYOUT_MODE.get_enum_value(mode))\ndef get_layout_mode(self) -&gt; LayoutModeStr:\n\"\"\"Return layout mode.\n        Returns:\n            layout mode\n        \"\"\"\nreturn LAYOUT_MODE.inverse[self.layoutMode()]\ndef set_movement(self, mode: MovementStr | QtWidgets.QListView.Movement):\n\"\"\"Set movement mode.\n        Args:\n            mode: movement mode to use\n        \"\"\"\nself.setMovement(MOVEMENT.get_enum_value(mode))\ndef get_movement(self) -&gt; MovementStr:\n\"\"\"Return movement mode.\n        Returns:\n            movement mode\n        \"\"\"\nreturn MOVEMENT.inverse[self.movement()]\ndef set_flow(self, mode: FlowStr | QtWidgets.QListView.Flow):\n\"\"\"Set flow mode.\n        Args:\n            mode: flow mode to use\n        \"\"\"\nself.setFlow(FLOW.get_enum_value(mode))\ndef get_flow(self) -&gt; FlowStr:\n\"\"\"Return flow mode.\n        Returns:\n            flow mode\n        \"\"\"\nreturn FLOW.inverse[self.flow()]\ndef set_grid_size(self, size: datatypes.SizeType):\nself.setGridSize(datatypes.to_size(size))\ndef get_grid_size(self) -&gt; core.Size:\nreturn core.Size(self.gridSize())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_flow","title":"<code>get_flow() -&gt; FlowStr</code>","text":"<p>Return flow mode.</p> <p>Returns:</p> Type Description <code>FlowStr</code> <p>flow mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def get_flow(self) -&gt; FlowStr:\n\"\"\"Return flow mode.\n    Returns:\n        flow mode\n    \"\"\"\nreturn FLOW.inverse[self.flow()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_layout_mode","title":"<code>get_layout_mode() -&gt; LayoutModeStr</code>","text":"<p>Return layout mode.</p> <p>Returns:</p> Type Description <code>LayoutModeStr</code> <p>layout mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def get_layout_mode(self) -&gt; LayoutModeStr:\n\"\"\"Return layout mode.\n    Returns:\n        layout mode\n    \"\"\"\nreturn LAYOUT_MODE.inverse[self.layoutMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_movement","title":"<code>get_movement() -&gt; MovementStr</code>","text":"<p>Return movement mode.</p> <p>Returns:</p> Type Description <code>MovementStr</code> <p>movement mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def get_movement(self) -&gt; MovementStr:\n\"\"\"Return movement mode.\n    Returns:\n        movement mode\n    \"\"\"\nreturn MOVEMENT.inverse[self.movement()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_resize_mode","title":"<code>get_resize_mode() -&gt; ResizeModeStr</code>","text":"<p>Return resize mode.</p> <p>Returns:</p> Type Description <code>ResizeModeStr</code> <p>resize mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def get_resize_mode(self) -&gt; ResizeModeStr:\n\"\"\"Return resize mode.\n    Returns:\n        resize mode\n    \"\"\"\nreturn RESIZE_MODE.inverse[self.resizeMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_view_mode","title":"<code>get_view_mode() -&gt; ViewModeStr</code>","text":"<p>Return view mode.</p> <p>Returns:</p> Type Description <code>ViewModeStr</code> <p>view mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n    Returns:\n        view mode\n    \"\"\"\nreturn VIEW_MODE.inverse[self.viewMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_flow","title":"<code>set_flow(mode: FlowStr | QtWidgets.QListView.Flow)</code>","text":"<p>Set flow mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>FlowStr | QtWidgets.QListView.Flow</code> <p>flow mode to use</p> required Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def set_flow(self, mode: FlowStr | QtWidgets.QListView.Flow):\n\"\"\"Set flow mode.\n    Args:\n        mode: flow mode to use\n    \"\"\"\nself.setFlow(FLOW.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_layout_mode","title":"<code>set_layout_mode(mode: LayoutModeStr | QtWidgets.QListView.LayoutMode)</code>","text":"<p>Set layout mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>LayoutModeStr | QtWidgets.QListView.LayoutMode</code> <p>layout mode to use</p> required Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def set_layout_mode(self, mode: LayoutModeStr | QtWidgets.QListView.LayoutMode):\n\"\"\"Set layout mode.\n    Args:\n        mode: layout mode to use\n    \"\"\"\nself.setLayoutMode(LAYOUT_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_movement","title":"<code>set_movement(mode: MovementStr | QtWidgets.QListView.Movement)</code>","text":"<p>Set movement mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>MovementStr | QtWidgets.QListView.Movement</code> <p>movement mode to use</p> required Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def set_movement(self, mode: MovementStr | QtWidgets.QListView.Movement):\n\"\"\"Set movement mode.\n    Args:\n        mode: movement mode to use\n    \"\"\"\nself.setMovement(MOVEMENT.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_resize_mode","title":"<code>set_resize_mode(mode: ResizeModeStr | QtWidgets.QListView.ResizeMode)</code>","text":"<p>Set resize mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ResizeModeStr | QtWidgets.QListView.ResizeMode</code> <p>resize mode to use</p> required Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def set_resize_mode(self, mode: ResizeModeStr | QtWidgets.QListView.ResizeMode):\n\"\"\"Set resize mode.\n    Args:\n        mode: resize mode to use\n    \"\"\"\nself.setResizeMode(RESIZE_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_view_mode","title":"<code>set_view_mode(mode: ViewModeStr | QtWidgets.QListView.ViewMode)</code>","text":"<p>Set view mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewModeStr | QtWidgets.QListView.ViewMode</code> <p>view mode to use</p> required Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def set_view_mode(self, mode: ViewModeStr | QtWidgets.QListView.ViewMode):\n\"\"\"Set view mode.\n    Args:\n        mode: view mode to use\n    \"\"\"\nself.setViewMode(VIEW_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ListWidgetItem","title":"<code>ListWidgetItem</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtWidgets.QListWidgetItem</code></p> Source code in <code>prettyqt\\widgets\\listwidgetitem.py</code> <pre><code>class ListWidgetItem(serializemixin.SerializeMixin, QtWidgets.QListWidgetItem):\ndef __repr__(self):\nreturn get_repr(self, self.icon(), self.text())\ndef __setitem__(self, index: int | constants.ItemDataRoleStr, value):\nself.set_data(index, value)\ndef __getitem__(self, index: int | constants.ItemDataRoleStr):\nreturn self.get_data(index)\ndef set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n        Args:\n            icon: icon to use\n        \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(icon)\ndef set_checkstate(self, state: constants.CheckStateStr | constants.CheckState):\n\"\"\"Set checkstate of the checkbox.\n        Args:\n            state: checkstate to use\n        \"\"\"\nself.setCheckState(constants.CHECK_STATE.get_enum_value(state))\ndef get_checkstate(self) -&gt; constants.CheckStateStr:\n\"\"\"Return checkstate.\n        Returns:\n            checkstate\n        \"\"\"\nreturn constants.CHECK_STATE.inverse[self.checkState()]\ndef get_background(self) -&gt; gui.Brush:\nreturn gui.Brush(self.background())\ndef get_foreground(self) -&gt; gui.Brush:\nreturn gui.Brush(self.foreground())\ndef get_font(self) -&gt; gui.Font:\nreturn gui.Font(self.font())\ndef get_icon(self) -&gt; gui.Icon | None:\nreturn None if (icon := super().icon()).isNull() else gui.Icon(icon)\ndef set_data(self, role: constants.ItemDataRoleStr | int, data: Any):\nrole = constants.ITEM_DATA_ROLE[role] if isinstance(role, str) else role\nsuper().setData(role, data)\ndef get_data(self, role: constants.ItemDataRoleStr | int):\nrole = constants.ITEM_DATA_ROLE[role] if isinstance(role, str) else role\nreturn super().data(role)\ndef set_size_hint(self, hint: datatypes.SizeType):\nsuper().setSizeHint(datatypes.to_size(hint))\ndef set_text_alignment(\nself,\nhorizontal: constants.HorizontalAlignmentStr\n| constants.AlignmentFlag\n| None = None,\nvertical: constants.VerticalAlignmentStr | constants.AlignmentFlag | None = None,\n):\n\"\"\"Set text alignment of the checkbox.\n        Args:\n            horizontal: horizontal text alignment to use\n            vertical: vertical text alignment to use\n        \"\"\"\nmatch horizontal, vertical:\ncase None, None:\nreturn\ncase None, _:\nflag = constants.V_ALIGNMENT.get_enum_value(vertical)\ncase _, None:\nflag = constants.H_ALIGNMENT.get_enum_value(horizontal)\ncase _, _:\nflag = constants.V_ALIGNMENT.get_enum_value(\nvertical\n) | constants.H_ALIGNMENT.get_enum_value(horizontal)\nself.setTextAlignment(flag)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.get_checkstate","title":"<code>get_checkstate() -&gt; constants.CheckStateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.CheckStateStr</code> <p>checkstate</p> Source code in <code>prettyqt\\widgets\\listwidgetitem.py</code> <pre><code>def get_checkstate(self) -&gt; constants.CheckStateStr:\n\"\"\"Return checkstate.\n    Returns:\n        checkstate\n    \"\"\"\nreturn constants.CHECK_STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_checkstate","title":"<code>set_checkstate(state: constants.CheckStateStr | constants.CheckState)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.CheckStateStr | constants.CheckState</code> <p>checkstate to use</p> required Source code in <code>prettyqt\\widgets\\listwidgetitem.py</code> <pre><code>def set_checkstate(self, state: constants.CheckStateStr | constants.CheckState):\n\"\"\"Set checkstate of the checkbox.\n    Args:\n        state: checkstate to use\n    \"\"\"\nself.setCheckState(constants.CHECK_STATE.get_enum_value(state))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\listwidgetitem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n    Args:\n        icon: icon to use\n    \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_text_alignment","title":"<code>set_text_alignment(horizontal: constants.HorizontalAlignmentStr | constants.AlignmentFlag | None = None, vertical: constants.VerticalAlignmentStr | constants.AlignmentFlag | None = None)</code>","text":"<p>Set text alignment of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>horizontal</code> <code>constants.HorizontalAlignmentStr | constants.AlignmentFlag | None</code> <p>horizontal text alignment to use</p> <code>None</code> <code>vertical</code> <code>constants.VerticalAlignmentStr | constants.AlignmentFlag | None</code> <p>vertical text alignment to use</p> <code>None</code> Source code in <code>prettyqt\\widgets\\listwidgetitem.py</code> <pre><code>def set_text_alignment(\nself,\nhorizontal: constants.HorizontalAlignmentStr\n| constants.AlignmentFlag\n| None = None,\nvertical: constants.VerticalAlignmentStr | constants.AlignmentFlag | None = None,\n):\n\"\"\"Set text alignment of the checkbox.\n    Args:\n        horizontal: horizontal text alignment to use\n        vertical: vertical text alignment to use\n    \"\"\"\nmatch horizontal, vertical:\ncase None, None:\nreturn\ncase None, _:\nflag = constants.V_ALIGNMENT.get_enum_value(vertical)\ncase _, None:\nflag = constants.H_ALIGNMENT.get_enum_value(horizontal)\ncase _, _:\nflag = constants.V_ALIGNMENT.get_enum_value(\nvertical\n) | constants.H_ALIGNMENT.get_enum_value(horizontal)\nself.setTextAlignment(flag)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.MainWindow","title":"<code>MainWindow</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QMainWindow</code></p> Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>class MainWindow(widgets.WidgetMixin, QtWidgets.QMainWindow):\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, dock_options=DEFAULT_OPTS, **kwargs)\nself.setMenuBar(widgets.MenuBar())\ndef __getitem__(self, index: str) -&gt; QtWidgets.QWidget:\nresult = self.find_child(QtWidgets.QWidget, index)\nif result is None:\nraise KeyError(\"Widget not found\")\nreturn result\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"toolButtonStyle\": constants.TOOLBUTTON_STYLE,\n\"tabShape\": widgets.tabwidget.TAB_SHAPES,\n}\nreturn maps\ndef set_widget(self, widget: QtWidgets.QWidget | None) -&gt; QtWidgets.QWidget | None:\n\"\"\"Set widget and return previous one if existing.\"\"\"\nprevious = self.takeCentralWidget()\nif widget:\nself.setCentralWidget(widget)\nreturn previous\ndef createPopupMenu(self) -&gt; widgets.Menu:\nmenu = widgets.Menu(parent=self, title=\"Window\")\nfor i, item in enumerate(self.get_docks()):\naction = gui.Action(\ntext=item.windowTitle(),\nparent=self,\ncheckable=True,\nchecked=item.isVisible(),\nshortcut=f\"Ctrl+Shift+{i}\",\nshortcut_context=\"application\",\ntoggled=item.setVisible,\n)\nmenu.add(action)\nmenu.add_separator()\nfor tb in self.get_toolbars():\naction = gui.Action(\ntext=tb.windowTitle(),\nparent=self,\ncheckable=True,\ntoggled=tb.setVisible,\nchecked=tb.isVisible(),\n)\nmenu.add(action)\nreturn menu\ndef add(self, widget: QtWidgets.QWidget, **kwargs):\nmatch widget:\ncase QtWidgets.QToolBar():\nself.add_toolbar(widget, **kwargs)\ncase QtWidgets.QDockWidget():\nself.add_dockwidget(widget, **kwargs)\ncase QtWidgets.QWidget():\nself.centralWidget().layout().add(widget, **kwargs)\ndef get_corner(\nself, corner: constants.CornerStr | constants.Corner\n) -&gt; constants.DockWidgetAreaStr:\ncorner_flag = constants.CORNER.get_enum_value(corner)\narea = self.corner(corner_flag)\nreturn constants.DOCK_WIDGET_AREAS.inverse[area]\ndef set_corner(\nself,\ncorner: constants.CornerStr | constants.Corner,\narea: constants.DockWidgetAreaStr | constants.DockWidgetArea,\n):\ncorner_flag = constants.CORNER.get_enum_value(corner)\narea_flag = constants.DOCK_WIDGET_AREAS.get_enum_value(area)\nself.setCorner(corner_flag, area_flag)\ndef add_toolbar(\nself,\ntoolbar: QtWidgets.QToolBar,\narea: constants.ToolbarAreaStr | constants.ToolBarArea | Literal[\"auto\"] = \"auto\",\n):\n\"\"\"Adds a toolbar to the mainmenu at specified area.\n        Args:\n            toolbar: toolbar to use\n            area: area of the toolbar\n        \"\"\"\nif area == \"auto\":\narea = self._get_preferred_toolbar_position()\nself.addToolBar(constants.TOOLBAR_AREA.get_enum_value(area), toolbar)\ndef add_toolbar_break(\nself, position: constants.ToolbarAreaStr | constants.ToolBarArea = \"top\"\n):\n\"\"\"Adds a toolbar break to the given area behind the last item.\n        Args:\n            position: position of the toolbar\n        \"\"\"\nself.addToolBarBreak(constants.TOOLBAR_AREA.get_enum_value(position))\ndef load_window_state(self, recursive: bool = False) -&gt; bool:\nsettings = core.Settings()\nname = self.get_id()\ngeom = settings.get(f\"{name}.geometry\")\nstate = settings.get(f\"{name}.state\")\nrestored = False\nif geom is not None and state is not None:\ntry:\nlogger.debug(f\"Loading window state for {self.windowTitle()!r}...\")\nself.restoreGeometry(geom)\nif isinstance(state, str):\nstate = state.encode()\nself.restoreState(state)\nrestored = True\nexcept TypeError:\nlogger.error(\"Wrong type for window state. Probably Qt binding switch?\")\nif recursive:\nfor window in self.find_children(MainWindow, recursive=True):\nif window.get_id():\nwindow.load_window_state()\nreturn restored\ndef save_window_state(self, recursive: bool = False):\n\"\"\"Save current window state as QSetting.\n        Args:\n            recursive (bool, optional): Description\n        \"\"\"\nsettings = core.Settings()\nname = self.get_id()\nlogger.debug(f\"Saving window state for {self.windowTitle()!r}...\")\nsettings[f\"{name}.geometry\"] = self.saveGeometry()\nsettings[f\"{name}.state\"] = self.saveState()\nif recursive:\nfor window in self.find_children(MainWindow, recursive=True):\nif window.get_id():\nwindow.save_window_state()\ndef add_widget_as_dock(\nself,\nname: str,\ntitle: str,\nlayout: widgets.layout.LayoutTypeStr | widgets.QLayout = \"horizontal\",\nposition: constants.DockWidgetAreaStr | constants.DockWidgetArea = \"left\",\n) -&gt; widgets.DockWidget:\ndock_widget = widgets.DockWidget(self, object_name=name, window_title=title)\nwidget = widgets.Widget()\nwidget.set_id(f\"{name}.widget\")\nwidget.set_layout(layout, margin=0)\ndock_widget.setWidget(widget)\nself.add_dockwidget(dock_widget, position)\nreturn dock_widget\ndef add_dockwidget(\nself,\nwidget: QtWidgets.QWidget,\nposition: constants.DockWidgetAreaStr\n| constants.DockWidgetArea\n| Literal[\"auto\"] = \"auto\",\n**kwargs,\n):\nif position == \"auto\":\nposition = self._get_preferred_dock_position()\nif not isinstance(widget, QtWidgets.QDockWidget):\ndock_widget = widgets.DockWidget(self, **kwargs)\ndock_widget.set_widget(widget)\nself.addDockWidget(\nconstants.DOCK_WIDGET_AREA.get_enum_value(position), dock_widget\n)\nreturn dock_widget\nelse:\nself.addDockWidget(\nconstants.DOCK_WIDGET_AREA.get_enum_value(position), widget\n)\ndef remove(\nself,\nwidgets: Sequence[QtWidgets.QDockWidget | QtWidgets.QToolBar | QtGui.QAction]\n| QtWidgets.QDockWidget\n| QtWidgets.QToolBar\n| QtGui.QAction,\n):\nwidget_list = widgets if isinstance(widgets, list) else [widgets]\nfor i in widget_list:\nmatch i:\ncase QtWidgets.QDockWidget():\nself.removeDockWidget(i)\ncase QtWidgets.QToolBar():\nself.removeToolBar(i)\ncase QtGui.QAction():\nself.removeAction(i)\ndef show_blocking(self):\nself.set_modality(\"application\")\nself.show()\ndef get_dock_area(self, widget: QtWidgets.QDockWidget) -&gt; constants.DockWidgetAreaStr:\narea = self.dockWidgetArea(widget)\nreturn constants.DOCK_WIDGET_AREAS.inverse[area]\ndef get_toolbar_area(self, widget: QtWidgets.QToolBar) -&gt; constants.ToolbarAreaStr:\narea = self.toolBarArea(widget)\nreturn constants.TOOLBAR_AREA.inverse[area]\ndef set_tool_button_style(\nself, style: constants.ToolButtonStyleStr | constants.ToolButtonStyle\n):\nself.setToolButtonStyle(constants.TOOLBUTTON_STYLE.get_enum_value(style))\ndef get_tool_button_style(self) -&gt; constants.ToolButtonStyleStr:\n\"\"\"Return current tool button style.\n        Returns:\n            tool button style\n        \"\"\"\nreturn constants.TOOLBUTTON_STYLE.inverse[self.toolButtonStyle()]\ndef set_tab_shape(\nself, shape: widgets.tabwidget.TabShapeStr | widgets.QTabWidget.TabShape\n):\n\"\"\"Set tab shape for the tabwidget.\n        Args:\n            shape: tab shape to use\n        \"\"\"\nself.setTabShape(widgets.tabwidget.TAB_SHAPES.get_enum_value(shape))\ndef get_tab_shape(self) -&gt; widgets.tabwidget.TabShapeStr:\n\"\"\"Return tab shape.\n        Returns:\n            tab shape\n        \"\"\"\nreturn widgets.tabwidget.TAB_SHAPES.inverse[self.tabShape()]\ndef get_docks(\nself, position: constants.DockWidgetAreaStr | None = None\n) -&gt; listdelegators.BaseListDelegator[QtWidgets.QDockWidget]:\ndocks = self.find_children(QtWidgets.QDockWidget, recursive=False)\nif position is None:\nreturn docks\nelse:\nreturn [i for i in docks if self.get_dock_area(i) == position]\ndef _get_preferred_dock_position(\nself,\npreference: constants.DockWidgetAreaStr = \"left\",\n) -&gt; constants.DockWidgetAreaStr:\n\"\"\"Get location with least amount of docks. If same score, use preference.\"\"\"\nareas = [self.get_dock_area(i) for i in self.get_docks()]\n# by prepending the prio order, we can choose order because\n# collections.Counter takes insertion order into account.\npositions = [\"bottom\", \"top\", \"right\", \"left\"]\npositions.remove(preference)\npositions.append(preference)\ncounter = collections.Counter(positions + areas)  # type: ignore[operator]\nreturn counter.most_common()[-1][0]  # type: ignore[return-value]\ndef _get_preferred_toolbar_position(\nself,\npreference: constants.ToolbarAreaStr = \"top\",\n) -&gt; constants.ToolbarAreaStr:\n\"\"\"See _get_preferred_dock_position.\"\"\"\nareas = [self.get_toolbar_area(i) for i in self.get_toolbars()]\npositions = [\"right\", \"left\", \"bottom\", \"top\"]\npositions.remove(preference)\npositions.append(preference)\ncounter = collections.Counter(positions + areas)  # type: ignore[operator]\nreturn counter.most_common()[-1][0]  # type: ignore[return-value]\ndef get_toolbars(\nself, position: constants.ToolbarAreaStr | None = None\n) -&gt; listdelegators.BaseListDelegator[QtWidgets.QToolBar]:\ntoolbars = self.find_children(QtWidgets.QToolBar, recursive=False)\nif position is None:\nreturn toolbars\nelse:\nreturn [i for i in toolbars if self.get_toolbar_area(i) == position]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar","title":"<code>add_toolbar(toolbar: QtWidgets.QToolBar, area: constants.ToolbarAreaStr | constants.ToolBarArea | Literal['auto'] = 'auto')</code>","text":"<p>Adds a toolbar to the mainmenu at specified area.</p> <p>Parameters:</p> Name Type Description Default <code>toolbar</code> <code>QtWidgets.QToolBar</code> <p>toolbar to use</p> required <code>area</code> <code>constants.ToolbarAreaStr | constants.ToolBarArea | Literal['auto']</code> <p>area of the toolbar</p> <code>'auto'</code> Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>def add_toolbar(\nself,\ntoolbar: QtWidgets.QToolBar,\narea: constants.ToolbarAreaStr | constants.ToolBarArea | Literal[\"auto\"] = \"auto\",\n):\n\"\"\"Adds a toolbar to the mainmenu at specified area.\n    Args:\n        toolbar: toolbar to use\n        area: area of the toolbar\n    \"\"\"\nif area == \"auto\":\narea = self._get_preferred_toolbar_position()\nself.addToolBar(constants.TOOLBAR_AREA.get_enum_value(area), toolbar)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar_break","title":"<code>add_toolbar_break(position: constants.ToolbarAreaStr | constants.ToolBarArea = 'top')</code>","text":"<p>Adds a toolbar break to the given area behind the last item.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>constants.ToolbarAreaStr | constants.ToolBarArea</code> <p>position of the toolbar</p> <code>'top'</code> Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>def add_toolbar_break(\nself, position: constants.ToolbarAreaStr | constants.ToolBarArea = \"top\"\n):\n\"\"\"Adds a toolbar break to the given area behind the last item.\n    Args:\n        position: position of the toolbar\n    \"\"\"\nself.addToolBarBreak(constants.TOOLBAR_AREA.get_enum_value(position))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.get_tab_shape","title":"<code>get_tab_shape() -&gt; widgets.tabwidget.TabShapeStr</code>","text":"<p>Return tab shape.</p> <p>Returns:</p> Type Description <code>widgets.tabwidget.TabShapeStr</code> <p>tab shape</p> Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>def get_tab_shape(self) -&gt; widgets.tabwidget.TabShapeStr:\n\"\"\"Return tab shape.\n    Returns:\n        tab shape\n    \"\"\"\nreturn widgets.tabwidget.TAB_SHAPES.inverse[self.tabShape()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.get_tool_button_style","title":"<code>get_tool_button_style() -&gt; constants.ToolButtonStyleStr</code>","text":"<p>Return current tool button style.</p> <p>Returns:</p> Type Description <code>constants.ToolButtonStyleStr</code> <p>tool button style</p> Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>def get_tool_button_style(self) -&gt; constants.ToolButtonStyleStr:\n\"\"\"Return current tool button style.\n    Returns:\n        tool button style\n    \"\"\"\nreturn constants.TOOLBUTTON_STYLE.inverse[self.toolButtonStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.save_window_state","title":"<code>save_window_state(recursive: bool = False)</code>","text":"<p>Save current window state as QSetting.</p> <p>Parameters:</p> Name Type Description Default <code>recursive</code> <code>bool</code> <p>Description</p> <code>False</code> Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>def save_window_state(self, recursive: bool = False):\n\"\"\"Save current window state as QSetting.\n    Args:\n        recursive (bool, optional): Description\n    \"\"\"\nsettings = core.Settings()\nname = self.get_id()\nlogger.debug(f\"Saving window state for {self.windowTitle()!r}...\")\nsettings[f\"{name}.geometry\"] = self.saveGeometry()\nsettings[f\"{name}.state\"] = self.saveState()\nif recursive:\nfor window in self.find_children(MainWindow, recursive=True):\nif window.get_id():\nwindow.save_window_state()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.set_tab_shape","title":"<code>set_tab_shape(shape: widgets.tabwidget.TabShapeStr | widgets.QTabWidget.TabShape)</code>","text":"<p>Set tab shape for the tabwidget.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>widgets.tabwidget.TabShapeStr | widgets.QTabWidget.TabShape</code> <p>tab shape to use</p> required Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>def set_tab_shape(\nself, shape: widgets.tabwidget.TabShapeStr | widgets.QTabWidget.TabShape\n):\n\"\"\"Set tab shape for the tabwidget.\n    Args:\n        shape: tab shape to use\n    \"\"\"\nself.setTabShape(widgets.tabwidget.TAB_SHAPES.get_enum_value(shape))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.set_widget","title":"<code>set_widget(widget: QtWidgets.QWidget | None) -&gt; QtWidgets.QWidget | None</code>","text":"<p>Set widget and return previous one if existing.</p> Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>def set_widget(self, widget: QtWidgets.QWidget | None) -&gt; QtWidgets.QWidget | None:\n\"\"\"Set widget and return previous one if existing.\"\"\"\nprevious = self.takeCentralWidget()\nif widget:\nself.setCentralWidget(widget)\nreturn previous\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.MdiArea","title":"<code>MdiArea</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code>, <code>QtWidgets.QMdiArea</code></p> Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>class MdiArea(widgets.AbstractScrollAreaMixin, QtWidgets.QMdiArea):\ndef __add__(self, other: QtWidgets.QWidget):\nself.add(other)\nreturn self\ndef set_view_mode(self, mode: ViewModeStr | QtWidgets.QMdiArea.ViewMode):\n\"\"\"Set view mode for the MDI area.\n        Args:\n            mode: view mode to use\n        \"\"\"\nself.setViewMode(VIEW_MODE.get_enum_value(mode))\ndef get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return current view mode.\n        Returns:\n            view mode\n        \"\"\"\nreturn VIEW_MODE.inverse[self.viewMode()]\ndef set_window_order(self, mode: WindowOrderStr | QtWidgets.QMdiArea.WindowOrder):\n\"\"\"Set the window order behaviour for the MDI area.\n        Args:\n            mode: window order behaviour to use\n        \"\"\"\nself.setActivationOrder(WINDOW_ORDER.get_enum_value(mode))\ndef get_window_order(self) -&gt; WindowOrderStr:\n\"\"\"Return current window order.\n        Returns:\n            view mode\n        \"\"\"\nreturn WINDOW_ORDER.inverse[self.activationOrder()]\ndef set_tab_position(\nself, position: TabPositionStr | QtWidgets.QTabWidget.TabPosition\n):\n\"\"\"Set tab position for the MDI area.\n        Args:\n            position: tabs position to use\n        \"\"\"\nself.setTabPosition(TAB_POSITION.get_enum_value(position))\ndef get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return current tab position.\n        Returns:\n            tab position\n        \"\"\"\nreturn TAB_POSITION.inverse[self.tabPosition()]\ndef set_background(\nself,\nbrush_or_color: datatypes.ColorAndBrushType,\npattern: constants.BrushStyleStr = \"solid\",\n):\nif isinstance(brush_or_color, QtGui.QBrush):\nbrush = brush_or_color\nelse:\ncolor = colors.get_color(brush_or_color)\nbrush = gui.Brush(color, constants.BRUSH_STYLE[pattern])\nself.setBackground(brush)\ndef get_background(self) -&gt; gui.Brush:\nreturn gui.Brush(self.background())\ndef add(self, *item: QtWidgets.QWidget):\nfor i in item:\nself.add_subwindow(i)\ndef add_subwindow(self, widget: QtWidgets.QWidget) -&gt; QtWidgets.QMdiSubWindow:\nif not isinstance(widget, QtWidgets.QMdiSubWindow):\nwindow = widgets.MdiSubWindow()\nwindow.setWidget(widget)\nself.addSubWindow(window)\nreturn window\nelse:\nreturn self.addSubWindow(widget)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_tab_position","title":"<code>get_tab_position() -&gt; TabPositionStr</code>","text":"<p>Return current tab position.</p> <p>Returns:</p> Type Description <code>TabPositionStr</code> <p>tab position</p> Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return current tab position.\n    Returns:\n        tab position\n    \"\"\"\nreturn TAB_POSITION.inverse[self.tabPosition()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_view_mode","title":"<code>get_view_mode() -&gt; ViewModeStr</code>","text":"<p>Return current view mode.</p> <p>Returns:</p> Type Description <code>ViewModeStr</code> <p>view mode</p> Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return current view mode.\n    Returns:\n        view mode\n    \"\"\"\nreturn VIEW_MODE.inverse[self.viewMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_window_order","title":"<code>get_window_order() -&gt; WindowOrderStr</code>","text":"<p>Return current window order.</p> <p>Returns:</p> Type Description <code>WindowOrderStr</code> <p>view mode</p> Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def get_window_order(self) -&gt; WindowOrderStr:\n\"\"\"Return current window order.\n    Returns:\n        view mode\n    \"\"\"\nreturn WINDOW_ORDER.inverse[self.activationOrder()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_tab_position","title":"<code>set_tab_position(position: TabPositionStr | QtWidgets.QTabWidget.TabPosition)</code>","text":"<p>Set tab position for the MDI area.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>TabPositionStr | QtWidgets.QTabWidget.TabPosition</code> <p>tabs position to use</p> required Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def set_tab_position(\nself, position: TabPositionStr | QtWidgets.QTabWidget.TabPosition\n):\n\"\"\"Set tab position for the MDI area.\n    Args:\n        position: tabs position to use\n    \"\"\"\nself.setTabPosition(TAB_POSITION.get_enum_value(position))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_view_mode","title":"<code>set_view_mode(mode: ViewModeStr | QtWidgets.QMdiArea.ViewMode)</code>","text":"<p>Set view mode for the MDI area.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewModeStr | QtWidgets.QMdiArea.ViewMode</code> <p>view mode to use</p> required Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def set_view_mode(self, mode: ViewModeStr | QtWidgets.QMdiArea.ViewMode):\n\"\"\"Set view mode for the MDI area.\n    Args:\n        mode: view mode to use\n    \"\"\"\nself.setViewMode(VIEW_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_window_order","title":"<code>set_window_order(mode: WindowOrderStr | QtWidgets.QMdiArea.WindowOrder)</code>","text":"<p>Set the window order behaviour for the MDI area.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>WindowOrderStr | QtWidgets.QMdiArea.WindowOrder</code> <p>window order behaviour to use</p> required Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def set_window_order(self, mode: WindowOrderStr | QtWidgets.QMdiArea.WindowOrder):\n\"\"\"Set the window order behaviour for the MDI area.\n    Args:\n        mode: window order behaviour to use\n    \"\"\"\nself.setActivationOrder(WINDOW_ORDER.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.MessageBox","title":"<code>MessageBox</code>","text":"<p>         Bases: <code>widgets.DialogMixin</code>, <code>QtWidgets.QMessageBox</code></p> Source code in <code>prettyqt\\widgets\\messagebox.py</code> <pre><code>class MessageBox(widgets.DialogMixin, QtWidgets.QMessageBox):\ndef __init__(\nself,\nicon: datatypes.IconType | IconStr = None,\nbuttons: list[StandardButtonStr | QtWidgets.QMessageBox.StandardButton]\n| None = None,\n**kwargs,\n):\nsuper().__init__(**kwargs)\nself.set_icon(icon)\nself.setWindowFlags(\nconstants.WindowType.Dialog\n| constants.WindowType.WindowTitleHint\n| constants.WindowType.CustomizeWindowHint\n)\nif isinstance(buttons, list):\nfor b in buttons:\nself.add_button(b)\ndef get_button(\nself, button: QtWidgets.QMessageBox.StandardButton | StandardButtonStr\n) -&gt; QtWidgets.QAbstractButton:\nreturn self.button(STANDARD_BUTTON.get_enum_value(button))\n@classmethod\ndef message(\ncls,\ntext: str,\ntitle: str = \"\",\nicon: datatypes.IconType = None,\ndetail_text: str | None = None,\n) -&gt; str:\nm = cls(\"none\", title, text)\nm.set_icon(icon)\nif detail_text is not None:\nm.setDetailedText(detail_text)\nreturn m.show_blocking()\n@classmethod\ndef show_exception(cls, exception: Exception):\nexctype, value = sys.exc_info()[:2]\ntb = traceback.format_exc()\ndlg = cls(text=str(value), title=str(exctype), icon=\"critical\", details=tb)\ndlg.show_blocking()\ndef set_icon(self, icon: datatypes.IconType | IconStr):\nif icon in ICONS:\nself.setIcon(ICONS[icon])\nelse:\nico = iconprovider.get_icon(icon)\nself.setIconPixmap(ico.get_pixmap(size=64))\ndef show_blocking(self) -&gt; StandardButtonStr:\nreturn STANDARD_BUTTON.inverse[self.exec()]\ndef get_icon_pixmap(self) -&gt; gui.Pixmap | None:\npix = self.iconPixmap()\nreturn None if pix.isNull() else gui.Pixmap(pix)\ndef set_standard_buttons(\nself, buttons: list[StandardButtonStr | QtWidgets.QMessageBox.StandardButton]\n):\nflag = self.StandardButton.NoButton\nfor val in buttons:\nflag |= STANDARD_BUTTON.get_enum_value(val)\nself.setStandardButtons(flag)\ndef get_standard_buttons(self) -&gt; list[StandardButtonStr]:\nreturn STANDARD_BUTTON.get_list(self.standardButtons())\ndef add_button(\nself, button: StandardButtonStr | QtWidgets.QMessageBox.StandardButton\n) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n        Args:\n            button: button to add\n        Returns:\n            created button\n        \"\"\"\nreturn self.addButton(STANDARD_BUTTON.get_enum_value(button))\ndef add_custom_button(\nself,\nbutton: str,\nrole: ButtonRoleStr | QtWidgets.QMessageBox.ButtonRole,\ncallback: Callable | None = None,\n) -&gt; QtWidgets.QPushButton:\nbtn = self.addButton(button, BUTTON_ROLE.get_enum_value(role))\nif callback:\nbtn.clicked.connect(callback)\n# @classmethod\n# def show_exception(cls, exception):\n#     header = str(exception[0])\n#     error_text = str(exception[1])\n#     widgets.MessageBox.message(error_text, header, \"mdi.exclamation\")\ndef set_text_format(\nself, text_format: constants.TextFormatStr | constants.TextFormat\n):\n\"\"\"Set the text format.\n        Args:\n            text_format: text format to use\n        \"\"\"\nself.setTextFormat(constants.TEXT_FORMAT.get_enum_value(text_format))\ndef get_text_format(self) -&gt; constants.TextFormatStr:\n\"\"\"Return current text format.\n        Returns:\n            text format\n        \"\"\"\nreturn constants.TEXT_FORMAT.inverse[self.textFormat()]\ndef set_escape_button(self, button: StandardButtonStr | QtWidgets.QAbstractButton):\nif isinstance(button, QtWidgets.QAbstractButton):\nself.setEscapeButton(button)\nelse:\nself.setEscapeButton(STANDARD_BUTTON.get_enum_value(button))\ndef set_default_button(self, button: StandardButtonStr | QtWidgets.QPushButton):\nif isinstance(button, QtWidgets.QPushButton):\nself.setDefaultButton(button)\nelse:\nself.setDefaultButton(STANDARD_BUTTON.get_enum_value(button))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.add_button","title":"<code>add_button(button: StandardButtonStr | QtWidgets.QMessageBox.StandardButton) -&gt; QtWidgets.QPushButton</code>","text":"<p>Add a default button.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>StandardButtonStr | QtWidgets.QMessageBox.StandardButton</code> <p>button to add</p> required <p>Returns:</p> Type Description <code>QtWidgets.QPushButton</code> <p>created button</p> Source code in <code>prettyqt\\widgets\\messagebox.py</code> <pre><code>def add_button(\nself, button: StandardButtonStr | QtWidgets.QMessageBox.StandardButton\n) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n    Args:\n        button: button to add\n    Returns:\n        created button\n    \"\"\"\nreturn self.addButton(STANDARD_BUTTON.get_enum_value(button))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.get_text_format","title":"<code>get_text_format() -&gt; constants.TextFormatStr</code>","text":"<p>Return current text format.</p> <p>Returns:</p> Type Description <code>constants.TextFormatStr</code> <p>text format</p> Source code in <code>prettyqt\\widgets\\messagebox.py</code> <pre><code>def get_text_format(self) -&gt; constants.TextFormatStr:\n\"\"\"Return current text format.\n    Returns:\n        text format\n    \"\"\"\nreturn constants.TEXT_FORMAT.inverse[self.textFormat()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_text_format","title":"<code>set_text_format(text_format: constants.TextFormatStr | constants.TextFormat)</code>","text":"<p>Set the text format.</p> <p>Parameters:</p> Name Type Description Default <code>text_format</code> <code>constants.TextFormatStr | constants.TextFormat</code> <p>text format to use</p> required Source code in <code>prettyqt\\widgets\\messagebox.py</code> <pre><code>def set_text_format(\nself, text_format: constants.TextFormatStr | constants.TextFormat\n):\n\"\"\"Set the text format.\n    Args:\n        text_format: text format to use\n    \"\"\"\nself.setTextFormat(constants.TEXT_FORMAT.get_enum_value(text_format))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.PlainTextEditMixin","title":"<code>PlainTextEditMixin</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code></p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>class PlainTextEditMixin(widgets.AbstractScrollAreaMixin):\nvalue_changed = core.Signal(str)\ndef __init__(self, text: str = \"\", **kwargs):\nsuper().__init__(**kwargs)\nself._allow_wheel_zoom = False\nself._hl = None\nself._current_line_color = gui.Color(0, 0, 0, 0)\nself.selecter = texteditselecter.TextEditSelecter(self)\nself.validator: QtGui.QValidator | None = None\nself.textChanged.connect(self._on_value_change)\ndoc = gui.TextDocument(self)\nlayout = widgets.PlainTextDocumentLayout(doc)\ndoc.setDocumentLayout(layout)\nself.setDocument(doc)\nself.set_text(text)\ndef __add__(self, other: str):\nself.append_text(other)\nreturn self\ndef wheelEvent(self, event):\n\"\"\"Handle wheel event for zooming.\"\"\"\nif not self._allow_wheel_zoom:\nreturn super().wheelEvent(event)\nif event.modifiers() &amp; constants.CTRL_MOD:\nself.zoomIn() if event.angleDelta().y() &gt; 0 else self.zoomOut()\nevent.accept()\nelse:\nsuper().wheelEvent(event)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"lineWrapMode\": LINE_WRAP_MODE,\n\"wordWrapMode\": gui.textoption.WORD_WRAP_MODE,\n}\nreturn maps\ndef allow_wheel_zoom(self, do_zoom: bool = True):\nself._allow_wheel_zoom = do_zoom\ndef append_text(\nself,\ntext: str,\nnewline: bool = True,\nensure_visible: Literal[\"always\", \"when_bottom\", \"never\"] = \"always\",\n):\nscrollbar = self.verticalScrollBar()\nat_bottom = scrollbar.value() &gt;= (scrollbar.maximum() - 4)\nprev_val = scrollbar.value()\nif newline:\nself.appendPlainText(text)\nelse:\nself.selecter.move_cursor(\"end\")\nself.insertPlainText(text)\nself.selecter.move_cursor(\"end\")\nmatch ensure_visible:\ncase \"always\":\nself.ensureCursorVisible()\ncase \"when_bottom\":\nif at_bottom:\nself.ensureCursorVisible()\ncase \"never\":\nscrollbar.setValue(prev_val)\ndef set_text(self, text: str):\nself.setPlainText(text)\ndef set_syntaxhighlighter(\nself, syntax: str | QtGui.QSyntaxHighlighter, style: str | None = None\n):\nif isinstance(syntax, QtGui.QSyntaxHighlighter):\nself._hl = syntax\nelse:\nself._hl = syntaxhighlighters.PygmentsHighlighter(\nself.document(), syntax, style\n)\ndef text(self) -&gt; str:\nreturn self.toPlainText()\ndef set_read_only(self, value: bool = True):\n\"\"\"Make the PlainTextEdit read-only.\n        Args:\n            value: True, for read-only, otherwise False\n        \"\"\"\nself.setReadOnly(value)\ndef show_whitespace_and_tabs(self, show: bool):\n\"\"\"Set show white spaces flag.\"\"\"\ndoc = self.document()\noptions = doc.defaultTextOption()\nflag = QtGui.QTextOption.Flag.ShowTabsAndSpaces\nif show:\noptions.setFlags(options.flags() | flag)  # type: ignore\nelse:\noptions.setFlags(options.flags() &amp; ~flag)  # type: ignore\ndoc.setDefaultTextOption(options)\ndef paintEvent(self, event: QtGui.QPaintEvent):\nif self._current_line_color:\nwith gui.Painter(self.viewport()) as painter:\ncursor_rect = self.cursorRect()\nr = QtCore.QRect(0, cursor_rect.top(), self.width(), cursor_rect.height())\npainter.set_pen(None)\npainter.setBrush(gui.Color(self._current_line_color))\npainter.drawRect(r)\nsuper().paintEvent(event)\ndef set_word_wrap_mode(\nself, mode: gui.textoption.WordWrapModeStr | gui.QTextOption.WrapMode\n):\n\"\"\"Set word wrap mode.\n        Args:\n            mode: word wrap mode to use\n        \"\"\"\nself.setWordWrapMode(gui.textoption.WORD_WRAP_MODE.get_enum_value(mode))\ndef get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n        Returns:\n            Word wrap mode\n        \"\"\"\nreturn gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\ndef set_line_wrap_mode(\nself, mode: LineWrapModeStr | QtWidgets.QPlainTextEdit.LineWrapMode\n):\n\"\"\"Set line wrap mode.\n        Args:\n            mode: line wrap mode to use\n        \"\"\"\nself.setLineWrapMode(LINE_WRAP_MODE.get_enum_value(mode))\ndef get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n        Returns:\n            Wrap mode\n        \"\"\"\nreturn LINE_WRAP_MODE.inverse[self.lineWrapMode()]\ndef _on_value_change(self):\nself.value_changed.emit(self.text())\nif self.validator is not None:\nself._set_validation_color()\ndef _set_validation_color(self):\ncolor = None if self.is_valid() else \"orange\"\nself.set_background_color(color)\ndef set_validator(\nself, validator: QtGui.QValidator | widgets.lineedit.ValidatorStr | None, **kwargs\n) -&gt; QtGui.QValidator:\nif isinstance(validator, str):\nValidatorClass = helpers.get_class_for_id(gui.ValidatorMixin, validator)\nvalidator = ValidatorClass(**kwargs)\nself.validator = validator\nself._set_validation_color()\nreturn validator\ndef set_regex_validator(self, regex: str, flags=0) -&gt; gui.RegularExpressionValidator:\nvalidator = gui.RegularExpressionValidator(self)\nvalidator.set_regex(regex, flags)\nself.set_validator(validator)\nreturn validator\ndef is_valid(self) -&gt; bool:\nif self.validator is None:\nreturn True\nval = self.validator.validate(self.text(), 0)\nreturn val[0] == self.validator.State.Acceptable\ndef set_value(self, value: str):\nself.setPlainText(value)\ndef get_value(self) -&gt; str:\nreturn self.text()\ndef set_current_line_color(self, color: datatypes.ColorType):\nif self._current_line_color is None:\nself.cursorPositionChanged.connect(self.selecter._update_on_block_change)\nif color is None:\nself.cursorPositionChanged.disconnect(self.selecter._update_on_block_change)\nself._current_line_color = colors.get_color(color) if color else None\ndef get_current_line_color(self) -&gt; gui.Color:\nreturn self._current_line_color\ncurrent_line_color = core.Property(\nQtGui.QColor, get_current_line_color, set_current_line_color\n)\ndef get_visible_line_span(self) -&gt; tuple[int, int]:\nblock = self.firstVisibleBlock()\nstart = block.blockNumber()\npage_step = self.v_scrollbar.pageStep()\nend = min(start + page_step, self.blockCount())\nreturn (start, end)\ndef get_pixel_height(self, exact: bool = True) -&gt; int:\n\"\"\"Returns the pixel height of the text area.\"\"\"\nwidget_margins = self.contentsMargins()\ndoc_height = self.document().get_pixel_height(exact=exact)\nreturn widget_margins.top() + doc_height + widget_margins.bottom()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.get_line_wrap_mode","title":"<code>get_line_wrap_mode() -&gt; LineWrapModeStr</code>","text":"<p>Get the current wrap mode.</p> <p>Returns:</p> Type Description <code>LineWrapModeStr</code> <p>Wrap mode</p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n    Returns:\n        Wrap mode\n    \"\"\"\nreturn LINE_WRAP_MODE.inverse[self.lineWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.get_pixel_height","title":"<code>get_pixel_height(exact: bool = True) -&gt; int</code>","text":"<p>Returns the pixel height of the text area.</p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def get_pixel_height(self, exact: bool = True) -&gt; int:\n\"\"\"Returns the pixel height of the text area.\"\"\"\nwidget_margins = self.contentsMargins()\ndoc_height = self.document().get_pixel_height(exact=exact)\nreturn widget_margins.top() + doc_height + widget_margins.bottom()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.get_word_wrap_mode","title":"<code>get_word_wrap_mode() -&gt; gui.textoption.WordWrapModeStr</code>","text":"<p>Get the current word wrap mode.</p> <p>Returns:</p> Type Description <code>gui.textoption.WordWrapModeStr</code> <p>Word wrap mode</p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n    Returns:\n        Word wrap mode\n    \"\"\"\nreturn gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.set_line_wrap_mode","title":"<code>set_line_wrap_mode(mode: LineWrapModeStr | QtWidgets.QPlainTextEdit.LineWrapMode)</code>","text":"<p>Set line wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>LineWrapModeStr | QtWidgets.QPlainTextEdit.LineWrapMode</code> <p>line wrap mode to use</p> required Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def set_line_wrap_mode(\nself, mode: LineWrapModeStr | QtWidgets.QPlainTextEdit.LineWrapMode\n):\n\"\"\"Set line wrap mode.\n    Args:\n        mode: line wrap mode to use\n    \"\"\"\nself.setLineWrapMode(LINE_WRAP_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.set_read_only","title":"<code>set_read_only(value: bool = True)</code>","text":"<p>Make the PlainTextEdit read-only.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True, for read-only, otherwise False</p> <code>True</code> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def set_read_only(self, value: bool = True):\n\"\"\"Make the PlainTextEdit read-only.\n    Args:\n        value: True, for read-only, otherwise False\n    \"\"\"\nself.setReadOnly(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.set_word_wrap_mode","title":"<code>set_word_wrap_mode(mode: gui.textoption.WordWrapModeStr | gui.QTextOption.WrapMode)</code>","text":"<p>Set word wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>gui.textoption.WordWrapModeStr | gui.QTextOption.WrapMode</code> <p>word wrap mode to use</p> required Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def set_word_wrap_mode(\nself, mode: gui.textoption.WordWrapModeStr | gui.QTextOption.WrapMode\n):\n\"\"\"Set word wrap mode.\n    Args:\n        mode: word wrap mode to use\n    \"\"\"\nself.setWordWrapMode(gui.textoption.WORD_WRAP_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.show_whitespace_and_tabs","title":"<code>show_whitespace_and_tabs(show: bool)</code>","text":"<p>Set show white spaces flag.</p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def show_whitespace_and_tabs(self, show: bool):\n\"\"\"Set show white spaces flag.\"\"\"\ndoc = self.document()\noptions = doc.defaultTextOption()\nflag = QtGui.QTextOption.Flag.ShowTabsAndSpaces\nif show:\noptions.setFlags(options.flags() | flag)  # type: ignore\nelse:\noptions.setFlags(options.flags() &amp; ~flag)  # type: ignore\ndoc.setDefaultTextOption(options)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.wheelEvent","title":"<code>wheelEvent(event)</code>","text":"<p>Handle wheel event for zooming.</p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def wheelEvent(self, event):\n\"\"\"Handle wheel event for zooming.\"\"\"\nif not self._allow_wheel_zoom:\nreturn super().wheelEvent(event)\nif event.modifiers() &amp; constants.CTRL_MOD:\nself.zoomIn() if event.angleDelta().y() &gt; 0 else self.zoomOut()\nevent.accept()\nelse:\nsuper().wheelEvent(event)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ProgressBar","title":"<code>ProgressBar</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QProgressBar</code></p> Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>class ProgressBar(widgets.WidgetMixin, QtWidgets.QProgressBar):\ndef __init__(self, *args, text_visible: bool = True, **kwargs):\nsuper().__init__(*args, text_visible=text_visible, **kwargs)\ndef set_alignment(self, alignment: constants.AlignmentStr | constants.AlignmentFlag):\n\"\"\"Set the alignment of the layout.\n        Args:\n            alignment: alignment for the layout\n        \"\"\"\nself.setAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\ndef get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n        Returns:\n            alignment\n        \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.alignment()]\ndef set_text_direction(\nself, text_direction: TextDirectionStr | QtWidgets.QProgressBar.Direction\n):\n\"\"\"Set the text direction of the layout.\n        Args:\n            text_direction: text direction for the layout\n        \"\"\"\nself.setTextDirection(TEXT_DIRECTIONS.get_enum_value(text_direction))\ndef get_text_direction(self) -&gt; TextDirectionStr:\n\"\"\"Return current text direction.\n        Returns:\n            Text direction\n        \"\"\"\nreturn TEXT_DIRECTIONS.inverse[self.textDirection()]\ndef set_orientation(\nself, orientation: constants.OrientationStr | constants.Orientation\n):\n\"\"\"Set the orientation of the progress bar.\n        Args:\n            orientation: orientation for the progress bar\n        \"\"\"\nself.setOrientation(constants.ORIENTATION.get_enum_value(orientation))\ndef get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n        Returns:\n            orientation\n        \"\"\"\nreturn constants.ORIENTATION.inverse[self.orientation()]\ndef set_range(self, start: int, end: int):\nself.setRange(start, end)\ndef set_value(self, value: int):\nself.setValue(value)\ndef get_value(self) -&gt; int:\nreturn self.value()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_alignment","title":"<code>get_alignment() -&gt; constants.AlignmentStr</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.AlignmentStr</code> <p>alignment</p> Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n    Returns:\n        alignment\n    \"\"\"\nreturn constants.ALIGNMENTS.inverse[self.alignment()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n    Returns:\n        orientation\n    \"\"\"\nreturn constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_text_direction","title":"<code>get_text_direction() -&gt; TextDirectionStr</code>","text":"<p>Return current text direction.</p> <p>Returns:</p> Type Description <code>TextDirectionStr</code> <p>Text direction</p> Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def get_text_direction(self) -&gt; TextDirectionStr:\n\"\"\"Return current text direction.\n    Returns:\n        Text direction\n    \"\"\"\nreturn TEXT_DIRECTIONS.inverse[self.textDirection()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_alignment","title":"<code>set_alignment(alignment: constants.AlignmentStr | constants.AlignmentFlag)</code>","text":"<p>Set the alignment of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr | constants.AlignmentFlag</code> <p>alignment for the layout</p> required Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def set_alignment(self, alignment: constants.AlignmentStr | constants.AlignmentFlag):\n\"\"\"Set the alignment of the layout.\n    Args:\n        alignment: alignment for the layout\n    \"\"\"\nself.setAlignment(constants.ALIGNMENTS.get_enum_value(alignment))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_orientation","title":"<code>set_orientation(orientation: constants.OrientationStr | constants.Orientation)</code>","text":"<p>Set the orientation of the progress bar.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr | constants.Orientation</code> <p>orientation for the progress bar</p> required Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def set_orientation(\nself, orientation: constants.OrientationStr | constants.Orientation\n):\n\"\"\"Set the orientation of the progress bar.\n    Args:\n        orientation: orientation for the progress bar\n    \"\"\"\nself.setOrientation(constants.ORIENTATION.get_enum_value(orientation))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_text_direction","title":"<code>set_text_direction(text_direction: TextDirectionStr | QtWidgets.QProgressBar.Direction)</code>","text":"<p>Set the text direction of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>text_direction</code> <code>TextDirectionStr | QtWidgets.QProgressBar.Direction</code> <p>text direction for the layout</p> required Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def set_text_direction(\nself, text_direction: TextDirectionStr | QtWidgets.QProgressBar.Direction\n):\n\"\"\"Set the text direction of the layout.\n    Args:\n        text_direction: text direction for the layout\n    \"\"\"\nself.setTextDirection(TEXT_DIRECTIONS.get_enum_value(text_direction))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ProgressDialog","title":"<code>ProgressDialog</code>","text":"<p>         Bases: <code>widgets.DialogMixin</code>, <code>QtWidgets.QProgressDialog</code></p> <p>Progress dialog.</p> <p>Wrapper for QtWidgets.QProgressDialog</p> Source code in <code>prettyqt\\widgets\\progressdialog.py</code> <pre><code>class ProgressDialog(widgets.DialogMixin, QtWidgets.QProgressDialog):\n\"\"\"Progress dialog.\n    Wrapper for QtWidgets.QProgressDialog\n    \"\"\"\ndef __init__(self, parent: QtWidgets.QWidget | None = None):\nsuper().__init__(parent=parent)\nprogress_bar = widgets.ProgressBar()\nprogress_bar.setRange(0, 0)\nprogress_bar.setTextVisible(False)\nself.setBar(progress_bar)\nself.set_icon(\"mdi.timer-sand-empty\")\nself.set_modality(\"application\")\nself.set_flags(\nminimize=False, maximize=False, close=False, stay_on_top=True, window=True\n)\nself.setCancelButton(None)  # type: ignore\nself.cancel()\ndef show_message(self, message: str):\nself.setLabelText(message)\nself.show()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ScrollArea","title":"<code>ScrollArea</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code>, <code>QtWidgets.QScrollArea</code></p> Source code in <code>prettyqt\\widgets\\scrollarea.py</code> <pre><code>class ScrollArea(widgets.AbstractScrollAreaMixin, QtWidgets.QScrollArea):\ndef __init__(self, *args, **kwargs):\nsuper().__init__(*args, **kwargs)\nviewport = widgets.Widget(self, object_name=f\"{type(self).__name__}_viewport\")\nself.setViewport(viewport)\ndef __add__(self, other: QtWidgets.QWidget | QtWidgets.QLayout | list):\nself.add(other)\nreturn self\ndef get_visible_widgets(\nself,\ntyp: type[T] = QtWidgets.QWidget,\npartial_allowed: bool = True,\nmargin: int = 10,\nrecursive: bool = True,\n) -&gt; listdelegators.BaseListDelegator[T]:\n\"\"\"Return all widgets which are visible in the viewport.\n        Results can be filtered by type and whether widget is fully or partially visible.\n        A positive margin increases the area to search for widgets, a negative margin\n        decreases it.\n        \"\"\"\nwidget = self.widget()\nviewport = self.viewport()\nrect = viewport.rect().adjusted(-margin, -margin, margin, margin)\nfound = []\nfor w in widget.find_children(typ, recursive=recursive):\ntop_left = w.mapTo(viewport, w.rect().topLeft())\nbottom_right = w.mapTo(viewport, w.rect().bottomRight())\nmapped = core.Rect(top_left, bottom_right)\nif partial_allowed and rect.intersects(mapped):\nfound.append(w)\nelif not partial_allowed and rect.contains(mapped):\nfound.append(w)\nreturn listdelegators.BaseListDelegator(found)\ndef get_children(self) -&gt; listdelegators.BaseListDelegator[QtWidgets.QWidget]:\nreturn self.widget().layout().get_children()\ndef set_widget(self, widget: QtWidgets.QWidget):\nself.setWidget(widget)\ndef add_widget(self, *args, **kwargs):\nself.widget().layout().addWidget(*args, **kwargs)\ndef add_layout(self, *args, **kwargs):\nself.widget().layout().addLayout(*args, **kwargs)\ndef add(\nself,\nitem: QtWidgets.QWidget | QtWidgets.QLayout | list,\nstretch: float | None = None,\n):\nmatch item:\ncase QtWidgets.QWidget():\nself.add_widget(item)\nif stretch:\nself.widget().layout().setStretchFactor(self.count() - 1, stretch)\ncase QtWidgets.QLayout():\nwidget = widgets.Widget(self)\nwidget.set_layout(item)\nself.add_widget(widget)\nif stretch:\nself.setStretchFactor(self.count() - 1, stretch)\ncase list():\nfor i in item:\nself.add(i, stretch)\nreturn item\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollarea.ScrollArea.get_visible_widgets","title":"<code>get_visible_widgets(typ: type[T] = QtWidgets.QWidget, partial_allowed: bool = True, margin: int = 10, recursive: bool = True) -&gt; listdelegators.BaseListDelegator[T]</code>","text":"<p>Return all widgets which are visible in the viewport.</p> <p>Results can be filtered by type and whether widget is fully or partially visible. A positive margin increases the area to search for widgets, a negative margin decreases it.</p> Source code in <code>prettyqt\\widgets\\scrollarea.py</code> <pre><code>def get_visible_widgets(\nself,\ntyp: type[T] = QtWidgets.QWidget,\npartial_allowed: bool = True,\nmargin: int = 10,\nrecursive: bool = True,\n) -&gt; listdelegators.BaseListDelegator[T]:\n\"\"\"Return all widgets which are visible in the viewport.\n    Results can be filtered by type and whether widget is fully or partially visible.\n    A positive margin increases the area to search for widgets, a negative margin\n    decreases it.\n    \"\"\"\nwidget = self.widget()\nviewport = self.viewport()\nrect = viewport.rect().adjusted(-margin, -margin, margin, margin)\nfound = []\nfor w in widget.find_children(typ, recursive=recursive):\ntop_left = w.mapTo(viewport, w.rect().topLeft())\nbottom_right = w.mapTo(viewport, w.rect().bottomRight())\nmapped = core.Rect(top_left, bottom_right)\nif partial_allowed and rect.intersects(mapped):\nfound.append(w)\nelif not partial_allowed and rect.contains(mapped):\nfound.append(w)\nreturn listdelegators.BaseListDelegator(found)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.Scroller","title":"<code>Scroller</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\widgets\\scroller.py</code> <pre><code>class Scroller(core.ObjectMixin):\ndef __init__(self, item: QtWidgets.QScroller):\nself.item = item\ndef __getattr__(self, val):\nreturn getattr(self.item, val)\ndef get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n        Returns:\n            state\n        \"\"\"\nreturn STATE.inverse[self.state()]\ndef get_velocity(self) -&gt; core.PointF:\nreturn core.PointF(self.velocity())\ndef get_pixel_per_meter(self) -&gt; core.PointF:\nreturn core.PointF(self.pixelPerMeter())\ndef get_final_position(self) -&gt; core.PointF:\nreturn core.PointF(self.finalPosition())\ndef handle_input(\nself,\ninput_type: InputStr | QtWidgets.QScroller.Input,\nposition: datatypes.PointFType,\ntimestamp: int = 0,\n) -&gt; bool:\nreturn self.handleInput(\nINPUT.get_enum_value(input_type), datatypes.to_pointf(position), timestamp\n)\ndef get_scroller_properties(self) -&gt; widgets.ScrollerProperties:\nreturn widgets.ScrollerProperties(self.scrollerProperties())\n@classmethod\ndef get_scroller(cls, obj: QtCore.QObject) -&gt; Self:\nreturn cls(QtWidgets.QScroller.scroller(obj))\n@staticmethod\ndef grab_gesture(\ntarget: QtCore.QObject,\ngesture_type: ScrollGestureTypeStr\n| QtWidgets.QScroller.ScrollerGestureType = \"touch\",\n) -&gt; constants.GestureTypeStr:\ngesture = QtWidgets.QScroller.grabGesture(\ntarget, SCROLLER_GESTURE_TYPE.get_enum_value(gesture_type)\n)\nif gesture &gt;= 256:\ngesture -= 256\nreturn constants.GESTURE_TYPE.inverse[gesture]\n@staticmethod\ndef grabbed_gesture(target: QtCore.QObject) -&gt; constants.GestureTypeStr:\nreturn constants.GESTURE_TYPE.inverse[QtWidgets.QScroller.grabbedGesture(target)]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scroller.Scroller.get_state","title":"<code>get_state() -&gt; StateStr</code>","text":"<p>Return current state.</p> <p>Returns:</p> Type Description <code>StateStr</code> <p>state</p> Source code in <code>prettyqt\\widgets\\scroller.py</code> <pre><code>def get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n    Returns:\n        state\n    \"\"\"\nreturn STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ScrollerProperties","title":"<code>ScrollerProperties</code>","text":"<p>         Bases: <code>QtWidgets.QScrollerProperties</code></p> Source code in <code>prettyqt\\widgets\\scrollerproperties.py</code> <pre><code>class ScrollerProperties(QtWidgets.QScrollerProperties):\ndef __getitem__(self, metric: ScrollmetricStr | mod.ScrollMetric):\nreturn self.get_scroll_metric(metric)\ndef __setitem__(self, metric: ScrollmetricStr | mod.ScrollMetric, value: Any):\nself.set_scroll_metric(metric, value)\ndef keys(self) -&gt; ScrollmetricStr:\nreturn SCROLL_METRIC.keys()\ndef __iter__(self) -&gt; Iterator[ScrollmetricStr]:\nreturn iter(SCROLL_METRIC.keys())\ndef set_scroll_metric(self, metric: ScrollmetricStr | mod.ScrollMetric, value: Any):\n\"\"\"Set scroll metric.\n        Args:\n            metric: Scroll metric to set\n            value: Value to set\n        \"\"\"\nself.setScrollMetric(SCROLL_METRIC.get_enum_value(metric), value)\ndef get_scroll_metric(self, metric: ScrollmetricStr | mod.ScrollMetric) -&gt; Any:\n\"\"\"Return scroll metric.\n        Args:\n            metric: Scroll metric to get\n        Returns:\n            state\n        \"\"\"\nreturn self.scrollMetric(SCROLL_METRIC.get_enum_value(metric))\ndef get_scroll_metrics(self) -&gt; dict[ScrollmetricStr, Any]:\nreturn {i: self.get_scroll_metric(i) for i in SCROLL_METRIC}\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.get_scroll_metric","title":"<code>get_scroll_metric(metric: ScrollmetricStr | mod.ScrollMetric) -&gt; Any</code>","text":"<p>Return scroll metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>ScrollmetricStr | mod.ScrollMetric</code> <p>Scroll metric to get</p> required <p>Returns:</p> Type Description <code>Any</code> <p>state</p> Source code in <code>prettyqt\\widgets\\scrollerproperties.py</code> <pre><code>def get_scroll_metric(self, metric: ScrollmetricStr | mod.ScrollMetric) -&gt; Any:\n\"\"\"Return scroll metric.\n    Args:\n        metric: Scroll metric to get\n    Returns:\n        state\n    \"\"\"\nreturn self.scrollMetric(SCROLL_METRIC.get_enum_value(metric))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.set_scroll_metric","title":"<code>set_scroll_metric(metric: ScrollmetricStr | mod.ScrollMetric, value: Any)</code>","text":"<p>Set scroll metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>ScrollmetricStr | mod.ScrollMetric</code> <p>Scroll metric to set</p> required <code>value</code> <code>Any</code> <p>Value to set</p> required Source code in <code>prettyqt\\widgets\\scrollerproperties.py</code> <pre><code>def set_scroll_metric(self, metric: ScrollmetricStr | mod.ScrollMetric, value: Any):\n\"\"\"Set scroll metric.\n    Args:\n        metric: Scroll metric to set\n        value: Value to set\n    \"\"\"\nself.setScrollMetric(SCROLL_METRIC.get_enum_value(metric), value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.SizePolicy","title":"<code>SizePolicy</code>","text":"<p>         Bases: <code>QtWidgets.QSizePolicy</code></p> Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>class SizePolicy(QtWidgets.QSizePolicy):\ndef __init__(self, *args, **kwargs):\nmatch args:\ncase (str(), str()):\nsuper().__init__(SIZE_POLICY[args[0]], SIZE_POLICY[args[1]])\ncase (str(), str(), str()):\nsuper().__init__(\nSIZE_POLICY[args[0]], SIZE_POLICY[args[1]], CONTROL_TYPE[args[2]]\n)\ncase _:\nsuper().__init__(*args, **kwargs)\ndef __repr__(self) -&gt; str:\nreturn get_repr(\nself,\nself.get_horizontal_policy(),\nself.get_vertical_policy(),\nself.get_control_type(),\n)\ndef __getstate__(self):\nreturn dict(\nhas_height_for_width=self.hasHeightForWidth(),\nhas_width_for_height=self.hasWidthForHeight(),\nhorizontal_stretch=self.horizontalStretch(),\nvertical_stretch=self.verticalStretch(),\nhorizontal_policy=self.get_horizontal_policy(),\nvertical_policy=self.get_vertical_policy(),\nretain_size_when_hidden=self.retainSizeWhenHidden(),\ncontrol_type=self.get_control_type(),\n)\ndef __setstate__(self, state: dict[str, Any]):\nself.setHeightForWidth(state[\"has_height_for_width\"])\nself.setWidthForHeight(state[\"has_width_for_height\"])\nself.setHorizontalStretch(state[\"horizontal_stretch\"])\nself.setVerticalStretch(state[\"vertical_stretch\"])\nself.set_horizontal_policy(state[\"horizontal_policy\"])\nself.set_vertical_policy(state[\"vertical_policy\"])\nself.setRetainSizeWhenHidden(state[\"retain_size_when_hidden\"])\nself.set_control_type(state[\"control_type\"])\ndef __reduce__(self):\nreturn type(self), (), self.__getstate__()\ndef serialize(self) -&gt; dict[str, Any]:\nreturn self.__getstate__()\n@classmethod\ndef clone(cls, qpol: QtWidgets.QSizePolicy) -&gt; Self:\npol = cls(qpol.horizontalPolicy(), qpol.verticalPolicy(), qpol.controlType())\npol.setHeightForWidth(qpol.hasHeightForWidth())\npol.setWidthForHeight(qpol.hasWidthForHeight())\npol.setHorizontalStretch(qpol.horizontalStretch())\npol.setVerticalStretch(qpol.verticalStretch())\npol.setRetainSizeWhenHidden(qpol.retainSizeWhenHidden())\nreturn pol\ndef get_horizontal_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n        Returns:\n            horizontal size policy\n        \"\"\"\nreturn SIZE_POLICY.inverse[self.horizontalPolicy()]\ndef set_horizontal_policy(self, policy: SizePolicyStr | QtWidgets.QSizePolicy.Policy):\n\"\"\"Set the horizontal policy.\n        Args:\n            policy: policy to set\n        \"\"\"\nself.setHorizontalPolicy(SIZE_POLICY.get_enum_value(policy))\ndef get_vertical_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n        Returns:\n            vertical size policy\n        \"\"\"\nreturn SIZE_POLICY.inverse[self.verticalPolicy()]\ndef set_vertical_policy(self, policy: SizePolicyStr | QtWidgets.QSizePolicy.Policy):\n\"\"\"Set the horizontal policy.\n        Args:\n            policy: policy to set\n        \"\"\"\nself.setVerticalPolicy(SIZE_POLICY.get_enum_value(policy))\ndef get_control_type(self) -&gt; ControlTypeStr:\n\"\"\"Return control type.\n        Returns:\n            control type\n        \"\"\"\nreturn CONTROL_TYPE.inverse[self.controlType()]\ndef set_control_type(self, typ: ControlTypeStr | QtWidgets.QSizePolicy.ControlType):\n\"\"\"Set the control type.\n        Args:\n            typ: control type to set\n        \"\"\"\nself.setControlType(CONTROL_TYPE.get_enum_value(typ))\ndef get_transposed(self) -&gt; Self:\ntransposed = self.transposed()\nreturn type(self).clone(transposed)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_control_type","title":"<code>get_control_type() -&gt; ControlTypeStr</code>","text":"<p>Return control type.</p> <p>Returns:</p> Type Description <code>ControlTypeStr</code> <p>control type</p> Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def get_control_type(self) -&gt; ControlTypeStr:\n\"\"\"Return control type.\n    Returns:\n        control type\n    \"\"\"\nreturn CONTROL_TYPE.inverse[self.controlType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_horizontal_policy","title":"<code>get_horizontal_policy() -&gt; SizePolicyStr</code>","text":"<p>Return size policy.</p> <p>Returns:</p> Type Description <code>SizePolicyStr</code> <p>horizontal size policy</p> Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def get_horizontal_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n    Returns:\n        horizontal size policy\n    \"\"\"\nreturn SIZE_POLICY.inverse[self.horizontalPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_vertical_policy","title":"<code>get_vertical_policy() -&gt; SizePolicyStr</code>","text":"<p>Return size policy.</p> <p>Returns:</p> Type Description <code>SizePolicyStr</code> <p>vertical size policy</p> Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def get_vertical_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n    Returns:\n        vertical size policy\n    \"\"\"\nreturn SIZE_POLICY.inverse[self.verticalPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_control_type","title":"<code>set_control_type(typ: ControlTypeStr | QtWidgets.QSizePolicy.ControlType)</code>","text":"<p>Set the control type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>ControlTypeStr | QtWidgets.QSizePolicy.ControlType</code> <p>control type to set</p> required Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def set_control_type(self, typ: ControlTypeStr | QtWidgets.QSizePolicy.ControlType):\n\"\"\"Set the control type.\n    Args:\n        typ: control type to set\n    \"\"\"\nself.setControlType(CONTROL_TYPE.get_enum_value(typ))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_horizontal_policy","title":"<code>set_horizontal_policy(policy: SizePolicyStr | QtWidgets.QSizePolicy.Policy)</code>","text":"<p>Set the horizontal policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizePolicyStr | QtWidgets.QSizePolicy.Policy</code> <p>policy to set</p> required Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def set_horizontal_policy(self, policy: SizePolicyStr | QtWidgets.QSizePolicy.Policy):\n\"\"\"Set the horizontal policy.\n    Args:\n        policy: policy to set\n    \"\"\"\nself.setHorizontalPolicy(SIZE_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_vertical_policy","title":"<code>set_vertical_policy(policy: SizePolicyStr | QtWidgets.QSizePolicy.Policy)</code>","text":"<p>Set the horizontal policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizePolicyStr | QtWidgets.QSizePolicy.Policy</code> <p>policy to set</p> required Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def set_vertical_policy(self, policy: SizePolicyStr | QtWidgets.QSizePolicy.Policy):\n\"\"\"Set the horizontal policy.\n    Args:\n        policy: policy to set\n    \"\"\"\nself.setVerticalPolicy(SIZE_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.Slider","title":"<code>Slider</code>","text":"<p>         Bases: <code>widgets.AbstractSliderMixin</code>, <code>QtWidgets.QSlider</code></p> Source code in <code>prettyqt\\widgets\\slider.py</code> <pre><code>class Slider(widgets.AbstractSliderMixin, QtWidgets.QSlider):\nvalue_changed = core.Signal(int)\nclicked = core.Signal(int)\ndef __init__(self, *args, **kwargs):\nmatch args:\ncase (str(), *rest):\nsuper().__init__(constants.ORIENTATION[args[0]], *rest, **kwargs)\ncase _:\nsuper().__init__(*args, **kwargs)\nself.valueChanged.connect(self.on_value_change)\n# style = HollowHandleStyle(\n#     {\n#         \"groove.height\": 4,\n#         \"sub-page.color\": QtGui.QColor(72, 210, 242),\n#         \"add-page.color\": QtGui.QColor(255, 255, 255, 50),\n#         \"handle.color\": QtGui.QColor(72, 210, 242),\n#         \"handle.ring-width\": 2,\n#         \"handle.hollow-radius\": 10,\n#         \"handle.margin\": 0,\n#     }\n# )\n# self.setStyle(style)\ndef mousePressEvent(self, e: QtGui.QMouseEvent):\nself.clicked.emit(self.value())\nif self.orientation() == constants.Orientation.Horizontal:\nvalue = e.pos().x() / self.width() * self.maximum()\nelse:\nvalue = (self.height() - e.pos().y()) / self.height() * self.maximum()\nself.setValue(int(value))\nsuper().mousePressEvent(e)\ndef set_tick_position(\nself, position: TickPositionAllStr | QtWidgets.QSlider.TickPosition\n):\n\"\"\"Set the tick position for the slider.\n        For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\".\n        Args:\n            position: position for the ticks\n        \"\"\"\nif position == \"left\":\nposition = \"above\"\nelif position == \"right\":\nposition = \"below\"\nself.setTickPosition(TICK_POSITION.get_enum_value(position))\ndef get_tick_position(self) -&gt; TickPositionStr:\n\"\"\"Return tick position.\n        Returns:\n            tick position\n        \"\"\"\nreturn TICK_POSITION.inverse[self.tickPosition()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.get_tick_position","title":"<code>get_tick_position() -&gt; TickPositionStr</code>","text":"<p>Return tick position.</p> <p>Returns:</p> Type Description <code>TickPositionStr</code> <p>tick position</p> Source code in <code>prettyqt\\widgets\\slider.py</code> <pre><code>def get_tick_position(self) -&gt; TickPositionStr:\n\"\"\"Return tick position.\n    Returns:\n        tick position\n    \"\"\"\nreturn TICK_POSITION.inverse[self.tickPosition()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.set_tick_position","title":"<code>set_tick_position(position: TickPositionAllStr | QtWidgets.QSlider.TickPosition)</code>","text":"<p>Set the tick position for the slider.</p> <p>For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\".</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>TickPositionAllStr | QtWidgets.QSlider.TickPosition</code> <p>position for the ticks</p> required Source code in <code>prettyqt\\widgets\\slider.py</code> <pre><code>def set_tick_position(\nself, position: TickPositionAllStr | QtWidgets.QSlider.TickPosition\n):\n\"\"\"Set the tick position for the slider.\n    For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\".\n    Args:\n        position: position for the ticks\n    \"\"\"\nif position == \"left\":\nposition = \"above\"\nelif position == \"right\":\nposition = \"below\"\nself.setTickPosition(TICK_POSITION.get_enum_value(position))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.SmoothScrollBar","title":"<code>SmoothScrollBar</code>","text":"<p>         Bases: <code>ScrollBar</code></p> Source code in <code>prettyqt\\widgets\\scrollbar.py</code> <pre><code>class SmoothScrollBar(ScrollBar):\nscroll_ended = core.Signal()\ndef __init__(\nself,\norientation: constants.Orientation | constants.OrientationStr = \"horizontal\",\nparent: QtWidgets.QAbstractScrollArea | None = None,\nanimation_duration: int = 500,\neasing: core.easingcurve.TypeStr | core.QEasingCurve.Type = \"out_cubic\",\ntrigger: bool = False,\n):\nsuper().__init__(orientation, parent)\nself._value = self.value()\nself.widget = parent\nself.animation = core.PropertyAnimation()\nself.animation.apply_to(self.value)\nself.animation.set_easing(easing)\nself.animation.setDuration(animation_duration)\nself.animation.finished.connect(self.scroll_ended)\nself.widget.viewport().installEventFilter(self)\nif trigger:\nself.widget.h_scrollbar.valueChanged.connect(gui.Cursor.fake_mouse_move)\ndef mouseMoveEvent(self, e):\nself.animation.stop()\nself._value = self.value()\nsuper().mouseMoveEvent(e)\ndef mousePressEvent(self, e):\nself.animation.stop()\nself._value = self.value()\nsuper().mousePressEvent(e)\ndef mouseReleaseEvent(self, e):\nself.animation.stop()\nself._value = self.value()\nsuper().mouseReleaseEvent(e)\ndef setValue(self, value: int):\nif value == self.value():\nreturn\nself.animation.stop()\nself.scroll_ended.emit()\nself.animation.set_range(self.value(), value)\nself.animation.start()\ndef scroll_by_value(self, value: int):\n\"\"\"Scroll by given distance.\"\"\"\nself._value += value\nself._value = min(max(self.minimum(), self._value), self.maximum())\nself.setValue(self._value)\ndef scroll_to(self, value: int):\n\"\"\"Scroll to given position.\"\"\"\nself._value = value\nself._value = min(max(self.minimum(), self._value), self.maximum())\nself.setValue(self._value)\ndef reset_value(self, value):\nself._value = value\ndef eventFilter(self, source, event) -&gt; bool:\nif event.type() == core.Event.Type.Wheel and source == self.widget.viewport():\nself.widget.v_scrollbar.scroll_by_value(-event.angleDelta().y())\nreturn True\nreturn False\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollbar.SmoothScrollBar.scroll_by_value","title":"<code>scroll_by_value(value: int)</code>","text":"<p>Scroll by given distance.</p> Source code in <code>prettyqt\\widgets\\scrollbar.py</code> <pre><code>def scroll_by_value(self, value: int):\n\"\"\"Scroll by given distance.\"\"\"\nself._value += value\nself._value = min(max(self.minimum(), self._value), self.maximum())\nself.setValue(self._value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollbar.SmoothScrollBar.scroll_to","title":"<code>scroll_to(value: int)</code>","text":"<p>Scroll to given position.</p> Source code in <code>prettyqt\\widgets\\scrollbar.py</code> <pre><code>def scroll_to(self, value: int):\n\"\"\"Scroll to given position.\"\"\"\nself._value = value\nself._value = min(max(self.minimum(), self._value), self.maximum())\nself.setValue(self._value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.SplitterHandle","title":"<code>SplitterHandle</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QSplitterHandle</code></p> Source code in <code>prettyqt\\widgets\\splitterhandle.py</code> <pre><code>class SplitterHandle(widgets.WidgetMixin, QtWidgets.QSplitterHandle):\ndouble_clicked = core.Signal(object)\ndef __init__(\nself,\norientation: constants.OrientationStr | constants.Orientation,\nparent: QtWidgets.QSplitter,\n**kwargs,\n):\nori = (\nconstants.ORIENTATION[orientation]\nif isinstance(orientation, str)\nelse orientation\n)\nsuper().__init__(ori, parent, **kwargs)\ndef mouseDoubleClickEvent(self, ev):\nself.double_clicked.emit(self)\ndef set_orientation(\nself, orientation: constants.OrientationStr | constants.Orientation\n):\n\"\"\"Set the orientation of the slider.\n        Args:\n            orientation: orientation for the slider\n        \"\"\"\nself.setOrientation(constants.ORIENTATION.get_enum_value(orientation))\ndef get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n        Returns:\n            orientation\n        \"\"\"\nreturn constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle.SplitterHandle.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\widgets\\splitterhandle.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n    Returns:\n        orientation\n    \"\"\"\nreturn constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle.SplitterHandle.set_orientation","title":"<code>set_orientation(orientation: constants.OrientationStr | constants.Orientation)</code>","text":"<p>Set the orientation of the slider.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr | constants.Orientation</code> <p>orientation for the slider</p> required Source code in <code>prettyqt\\widgets\\splitterhandle.py</code> <pre><code>def set_orientation(\nself, orientation: constants.OrientationStr | constants.Orientation\n):\n\"\"\"Set the orientation of the slider.\n    Args:\n        orientation: orientation for the slider\n    \"\"\"\nself.setOrientation(constants.ORIENTATION.get_enum_value(orientation))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.StyleOptionSlider","title":"<code>StyleOptionSlider</code>","text":"<p>         Bases: <code>widgets.StyleOptionComplexMixin</code>, <code>QtWidgets.QStyleOptionSlider</code></p> Source code in <code>prettyqt\\widgets\\styleoptionslider.py</code> <pre><code>class StyleOptionSlider(widgets.StyleOptionComplexMixin, QtWidgets.QStyleOptionSlider):\ndef is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n        Returns:\n            True if horizontal, else False\n        \"\"\"\nreturn self.orientation == constants.HORIZONTAL\ndef is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n        Returns:\n            True if vertical, else False\n        \"\"\"\nreturn self.orientation == constants.VERTICAL\ndef set_horizontal(self) -&gt; None:\n\"\"\"Set slider orientation to horizontal.\"\"\"\nself.orientation = constants.HORIZONTAL\ndef set_vertical(self) -&gt; None:\n\"\"\"Set slider orientation to vertical.\"\"\"\nself.orientation = constants.VERTICAL\ndef get_orientation(self) -&gt; Literal[\"horizontal\", \"vertical\"]:\nreturn \"horizontal\" if self.is_horizontal() else \"vertical\"\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_horizontal","title":"<code>is_horizontal() -&gt; bool</code>","text":"<p>Check if silder is horizontal.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if horizontal, else False</p> Source code in <code>prettyqt\\widgets\\styleoptionslider.py</code> <pre><code>def is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n    Returns:\n        True if horizontal, else False\n    \"\"\"\nreturn self.orientation == constants.HORIZONTAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_vertical","title":"<code>is_vertical() -&gt; bool</code>","text":"<p>Check if silder is vertical.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if vertical, else False</p> Source code in <code>prettyqt\\widgets\\styleoptionslider.py</code> <pre><code>def is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n    Returns:\n        True if vertical, else False\n    \"\"\"\nreturn self.orientation == constants.VERTICAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_horizontal","title":"<code>set_horizontal() -&gt; None</code>","text":"<p>Set slider orientation to horizontal.</p> Source code in <code>prettyqt\\widgets\\styleoptionslider.py</code> <pre><code>def set_horizontal(self) -&gt; None:\n\"\"\"Set slider orientation to horizontal.\"\"\"\nself.orientation = constants.HORIZONTAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_vertical","title":"<code>set_vertical() -&gt; None</code>","text":"<p>Set slider orientation to vertical.</p> Source code in <code>prettyqt\\widgets\\styleoptionslider.py</code> <pre><code>def set_vertical(self) -&gt; None:\n\"\"\"Set slider orientation to vertical.\"\"\"\nself.orientation = constants.VERTICAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.SystemTrayIcon","title":"<code>SystemTrayIcon</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtWidgets.QSystemTrayIcon</code></p> Source code in <code>prettyqt\\widgets\\systemtrayicon.py</code> <pre><code>class SystemTrayIcon(core.ObjectMixin, QtWidgets.QSystemTrayIcon):\ndef set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the system tray icon.\n        Args:\n            icon: icon to use\n        \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(icon)\ndef show_message(\nself,\ntitle: str,\nmessage: str = \"\",\nicon: datatypes.IconType = None,\ntimeout: int = 10,\n):\nif icon is None:\nico = gui.Icon()\nif icon in MESSAGE_ICONS:\nico = MESSAGE_ICONS[icon]\nelse:\nico = iconprovider.get_icon(icon)\nself.showMessage(title, message, ico, timeout * 1000)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the system tray icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\systemtrayicon.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the system tray icon.\n    Args:\n        icon: icon to use\n    \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.TabWidget","title":"<code>TabWidget</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QTabWidget</code></p> <p>Widget for managing the tabs section.</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>class TabWidget(widgets.WidgetMixin, QtWidgets.QTabWidget):\n\"\"\"Widget for managing the tabs section.\"\"\"\ndef __init__(\nself, closable: bool = False, detachable: bool = False, **kwargs\n) -&gt; None:\n# Basic initalization\nsuper().__init__(**kwargs)\nself.animator = animator.Animator(self)\nself.tabCloseRequested.connect(self.remove_tab)\nself.tab_bar = widgets.TabBar(self)\nself.setTabBar(self.tab_bar)\n# Used to keep a reference to detached tabs since their QMainWindow\n# does not have a parent\nself.detached_tabs: dict[str, DetachedTab] = {}\nif detachable:\nself.set_detachable()\nself.set_closable(closable)\ndef __len__(self) -&gt; int:\nreturn self.count()\n@overload\ndef __getitem__(self, index: int) -&gt; QtWidgets.QWidget:\n...\n@overload\ndef __getitem__(\nself, index: slice\n) -&gt; listdelegators.BaseListDelegator[QtWidgets.QWidget]:\n...\ndef __getitem__(\nself, index: int | slice\n) -&gt; QtWidgets.QWidget | listdelegators.BaseListDelegator[QtWidgets.QWidget]:\nmatch index:\ncase int():\nif index &gt;= self.count():\nraise IndexError(index)\nreturn self.widget(index)\ncase slice():\nrng = range(index.start or 0, index.stop or self.count(), index.step or 1)\nreturn listdelegators.BaseListDelegator(self.widget(i) for i in rng)\ncase _:\nraise TypeError(index)\ndef __contains__(self, item: QtWidgets.QWidget):\nreturn self.indexOf(item) &gt;= 0\ndef update_tab_bar_visibility(self):\n\"\"\"Update visibility of the tabBar depending of the number of tabs.\n        0 or 1 tab -&gt; tabBar hidden, 2+ tabs - &gt;tabBar visible\n        need to be called explicitly, or be connected to tabInserted/tabRemoved\n        \"\"\"\nself.tabBar().setVisible(self.count() &gt; 1)\ndef set_icon_size(self, size: datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\nself.setIconSize(datatypes.to_size(size))\ndef set_document_mode(self, state: bool = True) -&gt; None:\nself.setDocumentMode(state)\ndef set_tab_shape(self, shape: TabShapeStr | QtWidgets.QTabWidget.TabShape):\n\"\"\"Set tab shape for the tabwidget.\n        Args:\n            shape: tab shape to use\n        \"\"\"\nself.setTabShape(TAB_SHAPES.get_enum_value(shape))\ndef get_tab_shape(self) -&gt; TabShapeStr:\n\"\"\"Return tab shape.\n        Returns:\n            tab shape\n        \"\"\"\nreturn TAB_SHAPES.inverse[self.tabShape()]\ndef set_tab_position(\nself, position: TabPositionStr | QtWidgets.QTabWidget.TabPosition\n):\n\"\"\"Set tab position for the tabwidget.\n        Args:\n            position: tab position to use\n        \"\"\"\nself.setTabPosition(TAB_POSITION.get_enum_value(position))\ndef get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return tab position.\n        Returns:\n            tab position\n        \"\"\"\nreturn TAB_POSITION.inverse[self.tabPosition()]\ndef get_children(self) -&gt; list[tuple]:\nreturn [\n(\nself.widget(i),\nself.tabText(i),\nself.tab_icon(i),\nself.tabToolTip(i),\nself.tabWhatsThis(i),\n)\nfor i in range(self.count())\n]\ndef tab_icon(self, i: int) -&gt; gui.Icon | None:\nicon = self.tabIcon(i)\nreturn None if icon.isNull() else gui.Icon(icon)\ndef set_detachable(self):\nself.tab_bar.tab_doubleclicked.connect(self.detach_tab)\ncore.CoreApplication.call_on_exit(self.close_detached_tabs)\nself.setMovable(True)\ndef set_closable(self, closable: bool = True):\nself.setTabsClosable(closable)\n@core.Slot(int, QtCore.QPoint)\ndef detach_tab(self, index: int, point: datatypes.PointType):\n\"\"\"Detach tab by removing its contents and placing them in a DetachedTab window.\n        Args:\n            index (int): index location of the tab to be detached\n            point (QtCore.QPoint): screen pos for creating the new DetachedTab window\n        \"\"\"\n# Get the tab content\nname = self.tabText(index)\nicon = self.tab_icon(index) or self.window().windowIcon()\nwidget = self.widget(index)\ntry:\nwidget_rect = widget.frameGeometry()\nexcept AttributeError:\nreturn\n# Create a new detached tab window\ndetached_tab = DetachedTab(name, widget)\ndetached_tab.set_modality(\"none\")\ndetached_tab.set_icon(icon)\ndetached_tab.setGeometry(widget_rect)\ndetached_tab.on_close.connect(self.attach_tab)\ndetached_tab.move(datatypes.to_point(point))\ndetached_tab.show()\n# Create a reference to maintain access to the detached tab\nself.detached_tabs[name] = detached_tab\ndef add_tab(\nself,\nitem: QtWidgets.QWidget | QtWidgets.QLayout,\nlabel: str,\nicon: datatypes.IconType = None,\nposition: int | None = None,\nshow: bool = False,\n) -&gt; int:\nif isinstance(item, QtWidgets.QLayout):\nwidget = widgets.Widget()\nwidget.set_layout(item)\nelse:\nwidget = item\nif position is None:\nposition = len(self)\nif not icon:\nindex = self.insertTab(position, widget, label)\nelse:\nicon = iconprovider.get_icon(icon)\nindex = self.insertTab(position, widget, icon, label)\nif show:\nself.setCurrentIndex(index)\nreturn index\ndef attach_tab(\nself,\nwidget: QtWidgets.QWidget | QtWidgets.QLayout,\nname: str,\nicon: datatypes.IconType = None,\ninsert_at: int | None = None,\n):\n\"\"\"Re-attach tab.\n        Re-attach the tab by removing the content from the DetachedTab window,\n        closing it, and placing the content back into the DetachableTabWidget.\n        Args:\n            widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget\n                from the DetachedTab window\n            name (str): the name of the detached tab\n            icon (datatypes.IconType, optional): the window icon for the detached tab\n            insert_at (Optional[int], optional): insert the re-attached tab at the\n                given index\n        \"\"\"\nwidget.setParent(self)\n# Remove the reference\ndel self.detached_tabs[name]\n# Determine if the given image and the main window icon are the same.\n# If they are, then do not add the icon to the tab\nself.add_tab(widget, name, icon=icon, position=insert_at, show=True)\ndef close_detached_tabs(self):\n\"\"\"Close all tabs that are currently detached.\"\"\"\ntabs = list(self.detached_tabs.values())\nfor tab in tabs:\ntab.close()\n@core.Slot(int)\ndef remove_tab(self, index_or_widget: int | QtWidgets.QWidget):\nindex = (\nself.indexOf(index_or_widget)\nif isinstance(index_or_widget, QtWidgets.QWidget)\nelse index_or_widget\n)\nwidget = (\nself.widget(index_or_widget)\nif isinstance(index_or_widget, int)\nelse index_or_widget\n)\nself.removeTab(index)\nif widget is not None:\nwidget.deleteLater()\n@core.Slot(QtWidgets.QWidget, str)\ndef open_widget(self, widget: QtWidgets.QWidget, title: str = \"Unnamed\"):\n\"\"\"Create a tab containing delivered widget.\"\"\"\nself.add_tab(widget, title, icon=\"mdi.widgets\", show=True)\ndef set_tab(self, index: int, position: str, widget: QtWidgets.QWidget | None = None):\nself.tabBar().set_tab(index, position, widget)\ndef create_tab_preview(self, index: int, width: int = 200) -&gt; widgets.Label:\nwidget = widgets.Label(self)\nwidget.setScaledContents(True)\npx = self.widget(index).grab().scaledToWidth(width)\nwidget.setPixmap(px)\nwidget.resize(width, width)\nreturn widget\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.attach_tab","title":"<code>attach_tab(widget: QtWidgets.QWidget | QtWidgets.QLayout, name: str, icon: datatypes.IconType = None, insert_at: int | None = None)</code>","text":"<p>Re-attach tab.</p> <p>Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>Union[QtWidgets.QWidget, QtWidgets.QLayout]</code> <p>the content widget from the DetachedTab window</p> required <code>name</code> <code>str</code> <p>the name of the detached tab</p> required <code>icon</code> <code>datatypes.IconType</code> <p>the window icon for the detached tab</p> <code>None</code> <code>insert_at</code> <code>Optional[int]</code> <p>insert the re-attached tab at the given index</p> <code>None</code> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def attach_tab(\nself,\nwidget: QtWidgets.QWidget | QtWidgets.QLayout,\nname: str,\nicon: datatypes.IconType = None,\ninsert_at: int | None = None,\n):\n\"\"\"Re-attach tab.\n    Re-attach the tab by removing the content from the DetachedTab window,\n    closing it, and placing the content back into the DetachableTabWidget.\n    Args:\n        widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget\n            from the DetachedTab window\n        name (str): the name of the detached tab\n        icon (datatypes.IconType, optional): the window icon for the detached tab\n        insert_at (Optional[int], optional): insert the re-attached tab at the\n            given index\n    \"\"\"\nwidget.setParent(self)\n# Remove the reference\ndel self.detached_tabs[name]\n# Determine if the given image and the main window icon are the same.\n# If they are, then do not add the icon to the tab\nself.add_tab(widget, name, icon=icon, position=insert_at, show=True)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.close_detached_tabs","title":"<code>close_detached_tabs()</code>","text":"<p>Close all tabs that are currently detached.</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def close_detached_tabs(self):\n\"\"\"Close all tabs that are currently detached.\"\"\"\ntabs = list(self.detached_tabs.values())\nfor tab in tabs:\ntab.close()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.detach_tab","title":"<code>detach_tab(index: int, point: datatypes.PointType)</code>","text":"<p>Detach tab by removing its contents and placing them in a DetachedTab window.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index location of the tab to be detached</p> required <code>point</code> <code>QtCore.QPoint</code> <p>screen pos for creating the new DetachedTab window</p> required Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>@core.Slot(int, QtCore.QPoint)\ndef detach_tab(self, index: int, point: datatypes.PointType):\n\"\"\"Detach tab by removing its contents and placing them in a DetachedTab window.\n    Args:\n        index (int): index location of the tab to be detached\n        point (QtCore.QPoint): screen pos for creating the new DetachedTab window\n    \"\"\"\n# Get the tab content\nname = self.tabText(index)\nicon = self.tab_icon(index) or self.window().windowIcon()\nwidget = self.widget(index)\ntry:\nwidget_rect = widget.frameGeometry()\nexcept AttributeError:\nreturn\n# Create a new detached tab window\ndetached_tab = DetachedTab(name, widget)\ndetached_tab.set_modality(\"none\")\ndetached_tab.set_icon(icon)\ndetached_tab.setGeometry(widget_rect)\ndetached_tab.on_close.connect(self.attach_tab)\ndetached_tab.move(datatypes.to_point(point))\ndetached_tab.show()\n# Create a reference to maintain access to the detached tab\nself.detached_tabs[name] = detached_tab\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_position","title":"<code>get_tab_position() -&gt; TabPositionStr</code>","text":"<p>Return tab position.</p> <p>Returns:</p> Type Description <code>TabPositionStr</code> <p>tab position</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return tab position.\n    Returns:\n        tab position\n    \"\"\"\nreturn TAB_POSITION.inverse[self.tabPosition()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_shape","title":"<code>get_tab_shape() -&gt; TabShapeStr</code>","text":"<p>Return tab shape.</p> <p>Returns:</p> Type Description <code>TabShapeStr</code> <p>tab shape</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def get_tab_shape(self) -&gt; TabShapeStr:\n\"\"\"Return tab shape.\n    Returns:\n        tab shape\n    \"\"\"\nreturn TAB_SHAPES.inverse[self.tabShape()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.open_widget","title":"<code>open_widget(widget: QtWidgets.QWidget, title: str = 'Unnamed')</code>","text":"<p>Create a tab containing delivered widget.</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>@core.Slot(QtWidgets.QWidget, str)\ndef open_widget(self, widget: QtWidgets.QWidget, title: str = \"Unnamed\"):\n\"\"\"Create a tab containing delivered widget.\"\"\"\nself.add_tab(widget, title, icon=\"mdi.widgets\", show=True)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_icon_size","title":"<code>set_icon_size(size: datatypes.SizeType)</code>","text":"<p>Set size of the icons.</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def set_icon_size(self, size: datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\nself.setIconSize(datatypes.to_size(size))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_position","title":"<code>set_tab_position(position: TabPositionStr | QtWidgets.QTabWidget.TabPosition)</code>","text":"<p>Set tab position for the tabwidget.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>TabPositionStr | QtWidgets.QTabWidget.TabPosition</code> <p>tab position to use</p> required Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def set_tab_position(\nself, position: TabPositionStr | QtWidgets.QTabWidget.TabPosition\n):\n\"\"\"Set tab position for the tabwidget.\n    Args:\n        position: tab position to use\n    \"\"\"\nself.setTabPosition(TAB_POSITION.get_enum_value(position))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_shape","title":"<code>set_tab_shape(shape: TabShapeStr | QtWidgets.QTabWidget.TabShape)</code>","text":"<p>Set tab shape for the tabwidget.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>TabShapeStr | QtWidgets.QTabWidget.TabShape</code> <p>tab shape to use</p> required Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def set_tab_shape(self, shape: TabShapeStr | QtWidgets.QTabWidget.TabShape):\n\"\"\"Set tab shape for the tabwidget.\n    Args:\n        shape: tab shape to use\n    \"\"\"\nself.setTabShape(TAB_SHAPES.get_enum_value(shape))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.update_tab_bar_visibility","title":"<code>update_tab_bar_visibility()</code>","text":"<p>Update visibility of the tabBar depending of the number of tabs.</p> <p>0 or 1 tab -&gt; tabBar hidden, 2+ tabs - &gt;tabBar visible need to be called explicitly, or be connected to tabInserted/tabRemoved</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def update_tab_bar_visibility(self):\n\"\"\"Update visibility of the tabBar depending of the number of tabs.\n    0 or 1 tab -&gt; tabBar hidden, 2+ tabs - &gt;tabBar visible\n    need to be called explicitly, or be connected to tabInserted/tabRemoved\n    \"\"\"\nself.tabBar().setVisible(self.count() &gt; 1)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.TableViewMixin","title":"<code>TableViewMixin</code>","text":"<p>         Bases: <code>widgets.AbstractItemViewMixin</code></p> Source code in <code>prettyqt\\widgets\\tableview.py</code> <pre><code>class TableViewMixin(widgets.AbstractItemViewMixin):\ndef __init__(\nself,\n*args,\nalternating_row_colors: bool = True,\nword_wrap: bool = False,\n**kwargs,\n):\nsuper().__init__(\n*args,\nalternating_row_colors=alternating_row_colors,\nword_wrap=word_wrap,\n**kwargs,\n)\nclass_name = type(self).__name__\nself.setObjectName(class_name)\nself.setHorizontalHeader(widgets.HeaderView(\"horizontal\", parent=self))\nself.setVerticalHeader(widgets.HeaderView(\"vertical\", parent=self))\nself.setAlternatingRowColors(True)\nself.setWordWrap(False)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\"gridStyle\": constants.PEN_STYLE}\nreturn maps\n@property\ndef h_header(self):\nreturn self.horizontalHeader()\n@h_header.setter\ndef h_header(self, header):\nself.setHorizontalHeader(header)\n@property\ndef v_header(self):\nreturn self.verticalHeader()\n@v_header.setter\ndef v_header(self, header):\nself.setVerticalHeader(header)\ndef is_cell_visible(self, row: int, column: int) -&gt; bool:\nis_in_horizontal = self.h_header.is_in_visual_range(column)\nis_in_vertical = self.v_header.is_in_visual_range(row)\nreturn is_in_horizontal and is_in_vertical\ndef set_sorting_enabled(self, enabled: bool, do_sort: bool = False):\n\"\"\"Hack to avoid direct sort when setting sorting enabled.\"\"\"\nmodel = self.model()\nif not do_sort and model is not None:\nbackup = model.sort\nmodel.sort = lambda x, y: None\nself.setSortingEnabled(enabled)\nif not do_sort and model is not None:\nmodel.sort = backup\ndef setup_list_style(self):\nself.set_selection_behavior(\"rows\")\nself.h_header.setStretchLastSection(True)\nself.v_header.set_resize_mode(\"fixed\")\nself.v_header.set_default_section_size(28)\ndef adapt_sizes(self):\nmodel = self.model()\nif model is not None and (model.rowCount() * model.columnCount()) &lt; 1000:\nself.resizeColumnsToContents()\nelse:\nself.h_header.resize_sections(\"interactive\")\ndef sort_by_column(self, column: int | None, ascending: bool = True):\ncolumn = -1 if column is None else column\norder = constants.ASCENDING if ascending else constants.DESCENDING\nself.sortByColumn(column, order)\ndef set_grid_style(self, style: constants.PenStyleStr | constants.PenStyle):\n\"\"\"Set grid style.\n        Args:\n            style: grid style to use\n        \"\"\"\nself.setGridStyle(constants.PEN_STYLE.get_enum_value(style))\ndef get_grid_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return grid style.\n        Returns:\n            grid style\n        \"\"\"\nreturn constants.PEN_STYLE.inverse[self.gridStyle()]\ndef get_visible_section_span(\nself,\norientation: constants.OrientationStr | constants.Orientation,\nmargin: int = 0,\n) -&gt; tuple[int, int]:\n\"\"\"Get a tuple containing the visible start/end indexes.\n        if there are no items visible, return -1, -1\n        \"\"\"\nrect = self.viewport().rect()\nif orientation in [\"horizontal\", constants.HORIZONTAL]:\nstart = self.columnAt(rect.left())\ncount = self.model().columnCount()\nend = self.columnAt(rect.right())\nelse:\nstart = self.rowAt(rect.top())\ncount = self.model().rowCount()\nend = self.rowAt(rect.bottom())\nif count == 0:\nreturn (-1, -1)\nstart = max(0, start - margin)\nend = count if end == -1 else min(end + margin, count)\nreturn (start, end)\ndef resizeColumnsToContents(self, max_columns: int | None = 500):\ncolcount = self.model().columnCount()\nif max_columns is None or colcount &gt; max_columns:\nsuper().resizeColumnsToContents()\nreturn\nto_check = min(colcount, max_columns)\nfor i in range(to_check):\nself.resizeColumnToContents(i)\ndef resize_visible_columns_to_contents(self, margin: int = 0):\nif not self.isVisible():\nlogger.warning(\"trying resize_visible_columns_to_contents while not visible.\")\ncolcount = self.model().columnCount()\nautosized_cols = set()\ncol, end = self.get_visible_section_span(\"horizontal\", margin=margin)\nwidth = self.viewport().width()\nwhile col &lt;= end:\nif col not in autosized_cols:\nautosized_cols.add(col)\nself.resizeColumnToContents(col)\ncol += 1\n#  end may change during resize\nend = self.columnAt(width)\nend = colcount if end == -1 else end\ndef auto_span(\nself,\norientation: constants.OrientationStr\n| constants.Orientation = constants.HORIZONTAL,\nrole=constants.DISPLAY_ROLE,\nstart: tuple[int, int] = (0, 0),\nend: tuple[int, int] | None = None,\n) -&gt; list[tuple[int, int, int, int]]:\n\"\"\"Set spans in given direction based on same content in given role.\"\"\"\nis_horizontal = orientation in [constants.HORIZONTAL, \"horizontal\"]\nmodel = self.model()\nspans = []\n# figure out the ranges\nif is_horizontal:\nstart_level = max(0, start[0])\nstart_section = max(0, start[1])\nend_level = model.rowCount()\nend_section = model.columnCount()\nif end:\nend_level = min(max(0, end[0]), end_level)\nend_section = min(max(0, end[1]), end_section)\nelse:\nstart_level = max(0, start[1])\nstart_section = max(0, start[0])\nend_level = model.columnCount()\nend_section = model.rowCount()\nif end:\nend_level = min(max(0, end[1]), end_level)\nend_section = min(max(0, end[0]), end_section)\n# adjust the spans.\nfor level in range(start_level, end_level):\nmatch_start = None\nif is_horizontal:\narr = [\nmodel.index(level, i).data(role)\nfor i in range(start_section, end_section + 1)\n]\nlogger.debug(f\"{type(self).__name__}: spanning horizontal {arr}\")\nelse:\narr = [\nmodel.index(i, level).data(role)\nfor i in range(start_section, end_section + 1)\n]\nlogger.debug(f\"{type(self).__name__}: spanning vertical {arr}\")\nfor section in range(1, len(arr)):\nif arr[section] == arr[section - 1]:\nif match_start is None:\nmatch_start = section - 1\n# If this is the last cell, need to end it\nif section == end_section - start_section:\nmatch_end = section\nspan_size = match_end - match_start + 1\nbegin = match_start + start_section\nif is_horizontal:\nself.setSpan(level, begin, 1, span_size)\nspans.append((level, begin, 1, span_size))\nelse:\nspans.append((begin, level, span_size, 1))\nself.setSpan(begin, level, span_size, 1)\nelif match_start is not None:\nmatch_end = section - 1\nspan_size = match_end - match_start + 1\nbegin = match_start + start_section\nif is_horizontal:\nself.setSpan(level, begin, 1, span_size)\nspans.append((level, begin, 1, span_size))\nelse:\nself.setSpan(begin, level, span_size, 1)\nspans.append((begin, level, span_size, 1))\nmatch_start = None\nreturn spans\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableViewMixin.auto_span","title":"<code>auto_span(orientation: constants.OrientationStr | constants.Orientation = constants.HORIZONTAL, role: constants.OrientationStr | constants.Orientation = constants.DISPLAY_ROLE, start: tuple[int, int] = (0, 0), end: tuple[int, int] | None = None) -&gt; list[tuple[int, int, int, int]]</code>","text":"<p>Set spans in given direction based on same content in given role.</p> Source code in <code>prettyqt\\widgets\\tableview.py</code> <pre><code>def auto_span(\nself,\norientation: constants.OrientationStr\n| constants.Orientation = constants.HORIZONTAL,\nrole=constants.DISPLAY_ROLE,\nstart: tuple[int, int] = (0, 0),\nend: tuple[int, int] | None = None,\n) -&gt; list[tuple[int, int, int, int]]:\n\"\"\"Set spans in given direction based on same content in given role.\"\"\"\nis_horizontal = orientation in [constants.HORIZONTAL, \"horizontal\"]\nmodel = self.model()\nspans = []\n# figure out the ranges\nif is_horizontal:\nstart_level = max(0, start[0])\nstart_section = max(0, start[1])\nend_level = model.rowCount()\nend_section = model.columnCount()\nif end:\nend_level = min(max(0, end[0]), end_level)\nend_section = min(max(0, end[1]), end_section)\nelse:\nstart_level = max(0, start[1])\nstart_section = max(0, start[0])\nend_level = model.columnCount()\nend_section = model.rowCount()\nif end:\nend_level = min(max(0, end[1]), end_level)\nend_section = min(max(0, end[0]), end_section)\n# adjust the spans.\nfor level in range(start_level, end_level):\nmatch_start = None\nif is_horizontal:\narr = [\nmodel.index(level, i).data(role)\nfor i in range(start_section, end_section + 1)\n]\nlogger.debug(f\"{type(self).__name__}: spanning horizontal {arr}\")\nelse:\narr = [\nmodel.index(i, level).data(role)\nfor i in range(start_section, end_section + 1)\n]\nlogger.debug(f\"{type(self).__name__}: spanning vertical {arr}\")\nfor section in range(1, len(arr)):\nif arr[section] == arr[section - 1]:\nif match_start is None:\nmatch_start = section - 1\n# If this is the last cell, need to end it\nif section == end_section - start_section:\nmatch_end = section\nspan_size = match_end - match_start + 1\nbegin = match_start + start_section\nif is_horizontal:\nself.setSpan(level, begin, 1, span_size)\nspans.append((level, begin, 1, span_size))\nelse:\nspans.append((begin, level, span_size, 1))\nself.setSpan(begin, level, span_size, 1)\nelif match_start is not None:\nmatch_end = section - 1\nspan_size = match_end - match_start + 1\nbegin = match_start + start_section\nif is_horizontal:\nself.setSpan(level, begin, 1, span_size)\nspans.append((level, begin, 1, span_size))\nelse:\nself.setSpan(begin, level, span_size, 1)\nspans.append((begin, level, span_size, 1))\nmatch_start = None\nreturn spans\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableViewMixin.get_grid_style","title":"<code>get_grid_style() -&gt; constants.PenStyleStr</code>","text":"<p>Return grid style.</p> <p>Returns:</p> Type Description <code>constants.PenStyleStr</code> <p>grid style</p> Source code in <code>prettyqt\\widgets\\tableview.py</code> <pre><code>def get_grid_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return grid style.\n    Returns:\n        grid style\n    \"\"\"\nreturn constants.PEN_STYLE.inverse[self.gridStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableViewMixin.get_visible_section_span","title":"<code>get_visible_section_span(orientation: constants.OrientationStr | constants.Orientation, margin: int = 0) -&gt; tuple[int, int]</code>","text":"<p>Get a tuple containing the visible start/end indexes.</p> <p>if there are no items visible, return -1, -1</p> Source code in <code>prettyqt\\widgets\\tableview.py</code> <pre><code>def get_visible_section_span(\nself,\norientation: constants.OrientationStr | constants.Orientation,\nmargin: int = 0,\n) -&gt; tuple[int, int]:\n\"\"\"Get a tuple containing the visible start/end indexes.\n    if there are no items visible, return -1, -1\n    \"\"\"\nrect = self.viewport().rect()\nif orientation in [\"horizontal\", constants.HORIZONTAL]:\nstart = self.columnAt(rect.left())\ncount = self.model().columnCount()\nend = self.columnAt(rect.right())\nelse:\nstart = self.rowAt(rect.top())\ncount = self.model().rowCount()\nend = self.rowAt(rect.bottom())\nif count == 0:\nreturn (-1, -1)\nstart = max(0, start - margin)\nend = count if end == -1 else min(end + margin, count)\nreturn (start, end)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableViewMixin.set_grid_style","title":"<code>set_grid_style(style: constants.PenStyleStr | constants.PenStyle)</code>","text":"<p>Set grid style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.PenStyleStr | constants.PenStyle</code> <p>grid style to use</p> required Source code in <code>prettyqt\\widgets\\tableview.py</code> <pre><code>def set_grid_style(self, style: constants.PenStyleStr | constants.PenStyle):\n\"\"\"Set grid style.\n    Args:\n        style: grid style to use\n    \"\"\"\nself.setGridStyle(constants.PEN_STYLE.get_enum_value(style))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableViewMixin.set_sorting_enabled","title":"<code>set_sorting_enabled(enabled: bool, do_sort: bool = False)</code>","text":"<p>Hack to avoid direct sort when setting sorting enabled.</p> Source code in <code>prettyqt\\widgets\\tableview.py</code> <pre><code>def set_sorting_enabled(self, enabled: bool, do_sort: bool = False):\n\"\"\"Hack to avoid direct sort when setting sorting enabled.\"\"\"\nmodel = self.model()\nif not do_sort and model is not None:\nbackup = model.sort\nmodel.sort = lambda x, y: None\nself.setSortingEnabled(enabled)\nif not do_sort and model is not None:\nmodel.sort = backup\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.TableWidgetItem","title":"<code>TableWidgetItem</code>","text":"<p>         Bases: <code>QtWidgets.QTableWidgetItem</code></p> Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>class TableWidgetItem(QtWidgets.QTableWidgetItem):\ndef __setitem__(self, index: int | constants.ItemDataRoleStr, value):\nself.set_data(index, value)\ndef __getitem__(self, index: int | constants.ItemDataRoleStr):\nreturn self.get_data(index)\ndef set_flag(\nself, flag_name: constants.ItemFlagStr | constants.ItemFlag, value: bool\n):\n\"\"\"Set a flag based on str name.\"\"\"\nflag = constants.ITEM_FLAG.get_enum_value(flag_name)\nif value:\nself.setFlags(self.flags() | flag)\nelse:\nself.setFlags(self.flags() &amp; ~flag)\ndef set_editable(self, editable: bool):\n\"\"\"Set whether this item is user-editable.\"\"\"\nself.set_flag(\"editable\", editable)\ndef set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n        Args:\n            icon: icon to use\n        \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(icon)\ndef set_checkstate(self, state: constants.CheckStateStr | constants.CheckState):\n\"\"\"Set checkstate of the checkbox.\n        Args:\n            state: checkstate to use\n        \"\"\"\nself.setCheckState(constants.CHECK_STATE.get_enum_value(state))\ndef get_checkstate(self) -&gt; constants.CheckStateStr:\n\"\"\"Return checkstate.\n        Returns:\n            checkstate\n        \"\"\"\nreturn constants.CHECK_STATE.inverse[self.checkState()]\ndef set_text_alignment(\nself,\nhorizontal: constants.HorizontalAlignmentStr\n| constants.AlignmentFlag\n| None = None,\nvertical: constants.VerticalAlignmentStr | constants.AlignmentFlag | None = None,\n):\n\"\"\"Set text alignment of the checkbox.\n        Args:\n            horizontal: horizontal text alignment to use\n            vertical: vertical text alignment to use\n        \"\"\"\nmatch horizontal, vertical:\ncase None, None:\nreturn\ncase None, _:\nflag = constants.V_ALIGNMENT.get_enum_value(vertical)\ncase _, None:\nflag = constants.H_ALIGNMENT.get_enum_value(horizontal)\ncase _, _:\nflag = constants.V_ALIGNMENT.get_enum_value(\nvertical\n) | constants.H_ALIGNMENT.get_enum_value(horizontal)\nself.setTextAlignment(flag)\ndef get_background(self) -&gt; gui.Brush:\nreturn gui.Brush(self.background())\ndef get_foreground(self) -&gt; gui.Brush:\nreturn gui.Brush(self.foreground())\ndef get_font(self) -&gt; gui.Font:\nreturn gui.Font(self.font())\ndef get_icon(self) -&gt; gui.Icon | None:\nreturn None if (icon := self.icon()).isNull() else gui.Icon(icon)\ndef set_data(self, role: constants.ItemDataRoleStr | int, data: Any):\nif isinstance(role, str):\nrole = constants.ITEM_DATA_ROLE[role]\nsuper().setData(role, data)\ndef get_data(self, role: constants.ItemDataRoleStr | int) -&gt; Any:\nif isinstance(role, str):\nrole = constants.ITEM_DATA_ROLE[role]\nreturn super().data(role)\ndef set_tooltip(\nself,\ntooltip: str | datatypes.PathType,\nsize: datatypes.SizeType | None = None,\nrich_text: bool = False,\n):\nif isinstance(tooltip, os.PathLike):\npath = os.fspath(tooltip)\nif size is None:\ntooltip = f\"&lt;img src={path!r}&gt;\"\nelse:\nif isinstance(size, QtCore.QSize):\nsize = (size.width(), size.height())\ntooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\nif rich_text:\ntooltip = f\"&lt;html&gt;{html.escape(tooltip)}&lt;/html&gt;\"\nsuper().setToolTip(tooltip)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.get_checkstate","title":"<code>get_checkstate() -&gt; constants.CheckStateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.CheckStateStr</code> <p>checkstate</p> Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>def get_checkstate(self) -&gt; constants.CheckStateStr:\n\"\"\"Return checkstate.\n    Returns:\n        checkstate\n    \"\"\"\nreturn constants.CHECK_STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_checkstate","title":"<code>set_checkstate(state: constants.CheckStateStr | constants.CheckState)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.CheckStateStr | constants.CheckState</code> <p>checkstate to use</p> required Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>def set_checkstate(self, state: constants.CheckStateStr | constants.CheckState):\n\"\"\"Set checkstate of the checkbox.\n    Args:\n        state: checkstate to use\n    \"\"\"\nself.setCheckState(constants.CHECK_STATE.get_enum_value(state))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_editable","title":"<code>set_editable(editable: bool)</code>","text":"<p>Set whether this item is user-editable.</p> Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>def set_editable(self, editable: bool):\n\"\"\"Set whether this item is user-editable.\"\"\"\nself.set_flag(\"editable\", editable)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_flag","title":"<code>set_flag(flag_name: constants.ItemFlagStr | constants.ItemFlag, value: bool)</code>","text":"<p>Set a flag based on str name.</p> Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>def set_flag(\nself, flag_name: constants.ItemFlagStr | constants.ItemFlag, value: bool\n):\n\"\"\"Set a flag based on str name.\"\"\"\nflag = constants.ITEM_FLAG.get_enum_value(flag_name)\nif value:\nself.setFlags(self.flags() | flag)\nelse:\nself.setFlags(self.flags() &amp; ~flag)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n    Args:\n        icon: icon to use\n    \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_text_alignment","title":"<code>set_text_alignment(horizontal: constants.HorizontalAlignmentStr | constants.AlignmentFlag | None = None, vertical: constants.VerticalAlignmentStr | constants.AlignmentFlag | None = None)</code>","text":"<p>Set text alignment of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>horizontal</code> <code>constants.HorizontalAlignmentStr | constants.AlignmentFlag | None</code> <p>horizontal text alignment to use</p> <code>None</code> <code>vertical</code> <code>constants.VerticalAlignmentStr | constants.AlignmentFlag | None</code> <p>vertical text alignment to use</p> <code>None</code> Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>def set_text_alignment(\nself,\nhorizontal: constants.HorizontalAlignmentStr\n| constants.AlignmentFlag\n| None = None,\nvertical: constants.VerticalAlignmentStr | constants.AlignmentFlag | None = None,\n):\n\"\"\"Set text alignment of the checkbox.\n    Args:\n        horizontal: horizontal text alignment to use\n        vertical: vertical text alignment to use\n    \"\"\"\nmatch horizontal, vertical:\ncase None, None:\nreturn\ncase None, _:\nflag = constants.V_ALIGNMENT.get_enum_value(vertical)\ncase _, None:\nflag = constants.H_ALIGNMENT.get_enum_value(horizontal)\ncase _, _:\nflag = constants.V_ALIGNMENT.get_enum_value(\nvertical\n) | constants.H_ALIGNMENT.get_enum_value(horizontal)\nself.setTextAlignment(flag)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.TextEditMixin","title":"<code>TextEditMixin</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code></p> Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>class TextEditMixin(widgets.AbstractScrollAreaMixin):\nvalue_changed = core.Signal(str)\ndef __init__(self, *args, **kwargs) -&gt; None:\nsuper().__init__(*args, **kwargs)\nself.textChanged.connect(self.on_value_change)\nself.selecter = texteditselecter.TextEditSelecter(self)\ndef __add__(self, other: str) -&gt; TextEdit:\nself.append_text(other)\nreturn self\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"autoFormatting\": AUTO_FORMATTING,\n\"lineWrapMode\": LINE_WRAP_MODE,\n\"wordWrapMode\": gui.textoption.WORD_WRAP_MODE,\n}\nreturn maps\ndef on_value_change(self) -&gt; None:\nself.value_changed.emit(self.text())\ndef set_text(self, text: str) -&gt; None:\nself.setPlainText(text)\ndef append_text(\nself,\ntext: str,\nnewline: bool = True,\nensure_visible: Literal[\"always\", \"when_bottom\", \"never\"] = \"always\",\n):\nscrollbar = self.verticalScrollBar()\nat_bottom = scrollbar.value() &gt;= (scrollbar.maximum() - 4)\nprev_val = scrollbar.value()\nif newline:\nself.append(text)\nelse:\nself.selecter.move_cursor(\"end\")\nself.insertHtml(text)\nself.selecter.move_cursor(\"end\")\nmatch ensure_visible:\ncase \"always\":\nself.ensureCursorVisible()\ncase \"when_bottom\":\nif at_bottom:\nself.ensureCursorVisible()\ncase \"never\":\nscrollbar.setValue(prev_val)\ndef text(self) -&gt; str:\nreturn self.toPlainText()\ndef set_read_only(self, value: bool = True) -&gt; None:\nself.setReadOnly(value)\ndef set_text_color(self, color: datatypes.ColorType) -&gt; None:\ncolor = colors.get_color(color)\nself.setTextColor(color)\ndef set_line_wrap_mode(\nself, mode: LineWrapModeStr | QtWidgets.QTextEdit.LineWrapMode\n):\n\"\"\"Set line wrap mode.\n        Args:\n            mode: line wrap mode to use\n        \"\"\"\nself.setLineWrapMode(LINE_WRAP_MODE.get_enum_value(mode))\ndef get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n        Returns:\n            Wrap mode\n        \"\"\"\nreturn LINE_WRAP_MODE.inverse[self.lineWrapMode()]\ndef set_auto_formatting(\nself, mode: AutoFormattingStr | QtWidgets.QTextEdit.AutoFormattingFlag\n):\n\"\"\"Set auto formatting mode.\n        Args:\n            mode: auto formatting mode to use\n        \"\"\"\nself.setAutoFormatting(AUTO_FORMATTING.get_enum_value(mode))\ndef get_auto_formatting(self) -&gt; AutoFormattingStr:\n\"\"\"Get the current auto formatting mode.\n        Returns:\n            Auto formatting mode\n        \"\"\"\nreturn AUTO_FORMATTING.inverse[self.autoFormatting()]\ndef set_word_wrap_mode(\nself, mode: gui.textoption.WordWrapModeStr | gui.QTextOption.WrapMode\n):\n\"\"\"Set word wrap mode.\n        Args:\n            mode: word wrap mode to use\n        \"\"\"\nself.setWordWrapMode(gui.textoption.WORD_WRAP_MODE.get_enum_value(mode))\ndef get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n        Returns:\n            Word wrap mode\n        \"\"\"\nreturn gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.get_auto_formatting","title":"<code>get_auto_formatting() -&gt; AutoFormattingStr</code>","text":"<p>Get the current auto formatting mode.</p> <p>Returns:</p> Type Description <code>AutoFormattingStr</code> <p>Auto formatting mode</p> Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def get_auto_formatting(self) -&gt; AutoFormattingStr:\n\"\"\"Get the current auto formatting mode.\n    Returns:\n        Auto formatting mode\n    \"\"\"\nreturn AUTO_FORMATTING.inverse[self.autoFormatting()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.get_line_wrap_mode","title":"<code>get_line_wrap_mode() -&gt; LineWrapModeStr</code>","text":"<p>Get the current wrap mode.</p> <p>Returns:</p> Type Description <code>LineWrapModeStr</code> <p>Wrap mode</p> Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n    Returns:\n        Wrap mode\n    \"\"\"\nreturn LINE_WRAP_MODE.inverse[self.lineWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.get_word_wrap_mode","title":"<code>get_word_wrap_mode() -&gt; gui.textoption.WordWrapModeStr</code>","text":"<p>Get the current word wrap mode.</p> <p>Returns:</p> Type Description <code>gui.textoption.WordWrapModeStr</code> <p>Word wrap mode</p> Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n    Returns:\n        Word wrap mode\n    \"\"\"\nreturn gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.set_auto_formatting","title":"<code>set_auto_formatting(mode: AutoFormattingStr | QtWidgets.QTextEdit.AutoFormattingFlag)</code>","text":"<p>Set auto formatting mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>AutoFormattingStr | QtWidgets.QTextEdit.AutoFormattingFlag</code> <p>auto formatting mode to use</p> required Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def set_auto_formatting(\nself, mode: AutoFormattingStr | QtWidgets.QTextEdit.AutoFormattingFlag\n):\n\"\"\"Set auto formatting mode.\n    Args:\n        mode: auto formatting mode to use\n    \"\"\"\nself.setAutoFormatting(AUTO_FORMATTING.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.set_line_wrap_mode","title":"<code>set_line_wrap_mode(mode: LineWrapModeStr | QtWidgets.QTextEdit.LineWrapMode)</code>","text":"<p>Set line wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>LineWrapModeStr | QtWidgets.QTextEdit.LineWrapMode</code> <p>line wrap mode to use</p> required Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def set_line_wrap_mode(\nself, mode: LineWrapModeStr | QtWidgets.QTextEdit.LineWrapMode\n):\n\"\"\"Set line wrap mode.\n    Args:\n        mode: line wrap mode to use\n    \"\"\"\nself.setLineWrapMode(LINE_WRAP_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.set_word_wrap_mode","title":"<code>set_word_wrap_mode(mode: gui.textoption.WordWrapModeStr | gui.QTextOption.WrapMode)</code>","text":"<p>Set word wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>gui.textoption.WordWrapModeStr | gui.QTextOption.WrapMode</code> <p>word wrap mode to use</p> required Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def set_word_wrap_mode(\nself, mode: gui.textoption.WordWrapModeStr | gui.QTextOption.WrapMode\n):\n\"\"\"Set word wrap mode.\n    Args:\n        mode: word wrap mode to use\n    \"\"\"\nself.setWordWrapMode(gui.textoption.WORD_WRAP_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ToolButton","title":"<code>ToolButton</code>","text":"<p>         Bases: <code>widgets.AbstractButtonMixin</code>, <code>QtWidgets.QToolButton</code></p> Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>class ToolButton(widgets.AbstractButtonMixin, QtWidgets.QToolButton):\ndef __getitem__(self, item: str) -&gt; QtGui.QAction:\nmenu = self.menu()\nreturn menu[item]\n# def set_menu(self, menu: QtWidgets.QMenu):\n#     menu.setParent(self)\n#     self.setMenu(menu)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"toolButtonStyle\": constants.TOOLBUTTON_STYLE,\n\"arrowType\": constants.ARROW_TYPE,\n\"popupMode\": POPUP_MODE,\n}\nreturn maps\n@classmethod\ndef for_menu(cls, menu: QtWidgets.QMenu, icon: datatypes.IconType = None) -&gt; Self:\nbtn = cls()\nbtn.setMenu(menu)\n# btn.set_title(menu.title())\nbtn.set_popup_mode(\"instant\")\nbtn.set_icon(icon)\nreturn btn\ndef set_default_action(self, action: QtGui.QAction):\nself.setDefaultAction(action)\ndef set_popup_mode(\nself, mode: PopupModeStr | QtWidgets.QToolButton.ToolButtonPopupMode\n):\n\"\"\"Set the popup mode of the toolbutton.\n        Args:\n            mode: popup mode to use\n        \"\"\"\nself.setPopupMode(POPUP_MODE.get_enum_value(mode))\ndef get_popup_mode(self) -&gt; PopupModeStr:\n\"\"\"Return popup mode.\n        Returns:\n            popup mode\n        \"\"\"\nreturn POPUP_MODE.inverse[self.popupMode()]\ndef set_arrow_type(self, mode: constants.ArrowTypeStr | constants.ArrowType):\n\"\"\"Set the arrow type of the toolbutton.\n        Args:\n            mode: arrow type to use\n        \"\"\"\nself.setArrowType(constants.ARROW_TYPE.get_enum_value(mode))\ndef get_arrow_type(self) -&gt; constants.ArrowTypeStr:\n\"\"\"Return arrow type.\n        Returns:\n            arrow type\n        \"\"\"\nreturn constants.ARROW_TYPE.inverse[self.arrowType()]\ndef set_style(self, style: constants.ToolButtonStyleStr | constants.ToolButtonStyle):\n\"\"\"Set the toolbutton style.\n        Args:\n            style: style to use\n        \"\"\"\nself.setToolButtonStyle(constants.TOOLBUTTON_STYLE.get_enum_value(style))\ndef get_style(self) -&gt; constants.ToolButtonStyleStr:\n\"\"\"Return toolbutton style.\n        Returns:\n            toolbutton style\n        \"\"\"\nreturn constants.TOOLBUTTON_STYLE.inverse[self.toolButtonStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_arrow_type","title":"<code>get_arrow_type() -&gt; constants.ArrowTypeStr</code>","text":"<p>Return arrow type.</p> <p>Returns:</p> Type Description <code>constants.ArrowTypeStr</code> <p>arrow type</p> Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def get_arrow_type(self) -&gt; constants.ArrowTypeStr:\n\"\"\"Return arrow type.\n    Returns:\n        arrow type\n    \"\"\"\nreturn constants.ARROW_TYPE.inverse[self.arrowType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_popup_mode","title":"<code>get_popup_mode() -&gt; PopupModeStr</code>","text":"<p>Return popup mode.</p> <p>Returns:</p> Type Description <code>PopupModeStr</code> <p>popup mode</p> Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def get_popup_mode(self) -&gt; PopupModeStr:\n\"\"\"Return popup mode.\n    Returns:\n        popup mode\n    \"\"\"\nreturn POPUP_MODE.inverse[self.popupMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_style","title":"<code>get_style() -&gt; constants.ToolButtonStyleStr</code>","text":"<p>Return toolbutton style.</p> <p>Returns:</p> Type Description <code>constants.ToolButtonStyleStr</code> <p>toolbutton style</p> Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def get_style(self) -&gt; constants.ToolButtonStyleStr:\n\"\"\"Return toolbutton style.\n    Returns:\n        toolbutton style\n    \"\"\"\nreturn constants.TOOLBUTTON_STYLE.inverse[self.toolButtonStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_arrow_type","title":"<code>set_arrow_type(mode: constants.ArrowTypeStr | constants.ArrowType)</code>","text":"<p>Set the arrow type of the toolbutton.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ArrowTypeStr | constants.ArrowType</code> <p>arrow type to use</p> required Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def set_arrow_type(self, mode: constants.ArrowTypeStr | constants.ArrowType):\n\"\"\"Set the arrow type of the toolbutton.\n    Args:\n        mode: arrow type to use\n    \"\"\"\nself.setArrowType(constants.ARROW_TYPE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_popup_mode","title":"<code>set_popup_mode(mode: PopupModeStr | QtWidgets.QToolButton.ToolButtonPopupMode)</code>","text":"<p>Set the popup mode of the toolbutton.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>PopupModeStr | QtWidgets.QToolButton.ToolButtonPopupMode</code> <p>popup mode to use</p> required Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def set_popup_mode(\nself, mode: PopupModeStr | QtWidgets.QToolButton.ToolButtonPopupMode\n):\n\"\"\"Set the popup mode of the toolbutton.\n    Args:\n        mode: popup mode to use\n    \"\"\"\nself.setPopupMode(POPUP_MODE.get_enum_value(mode))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_style","title":"<code>set_style(style: constants.ToolButtonStyleStr | constants.ToolButtonStyle)</code>","text":"<p>Set the toolbutton style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.ToolButtonStyleStr | constants.ToolButtonStyle</code> <p>style to use</p> required Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def set_style(self, style: constants.ToolButtonStyleStr | constants.ToolButtonStyle):\n\"\"\"Set the toolbutton style.\n    Args:\n        style: style to use\n    \"\"\"\nself.setToolButtonStyle(constants.TOOLBUTTON_STYLE.get_enum_value(style))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.TreeViewMixin","title":"<code>TreeViewMixin</code>","text":"<p>         Bases: <code>widgets.AbstractItemViewMixin</code></p> Source code in <code>prettyqt\\widgets\\treeview.py</code> <pre><code>class TreeViewMixin(widgets.AbstractItemViewMixin):\ndef __init__(\nself,\n*args,\nroot_is_decorated: bool = True,\nall_columns_show_focus: bool = True,\nuniform_row_heights: bool = True,\nalternating_row_colors: bool = True,\nselection_mode: str = \"extended\",\n**kwargs,\n):\nsuper().__init__(\n*args,\nroot_is_decorated=root_is_decorated,\nall_columns_show_focus=all_columns_show_focus,\nuniform_row_heights=uniform_row_heights,\nalternating_row_colors=alternating_row_colors,\nselection_mode=selection_mode,\n**kwargs,\n)\nclass_name = type(self).__name__\nself.set_id(class_name)\n# misc\nself.h_header = widgets.HeaderView(\"horizontal\", parent=self)\n@property\ndef h_header(self):\nreturn self.header()\n@h_header.setter\ndef h_header(self, header):\nself.setHeader(header)\ndef show_root(self, value: bool):\nself.setRootIndex(core.QModelIndex())\nif not value:\nself.setRootIndex(self.model().index(0, 0))\ndef set_expanded(\nself, index: core.ModelIndex | Iterable[core.ModelIndex], expanded: bool = True\n):\n\"\"\"Set expaned state of an index or an Iterable of indexes.\"\"\"\nmatch index:\ncase Iterable():\nfor idx in index:\nself.setExpanded(idx, expanded)\ncase _:\nself.setExpanded(index, expanded)\ndef expand_all(self, depth: int | None = None):\nif depth is None:\nsuper().expandAll()\nelse:\nfor idx in self.model().iter_tree(root_index=self.rootIndex(), depth=depth):\nself.setExpanded(idx, True)\ndef set_sorting_enabled(self, enabled: bool, do_sort: bool = False):\n\"\"\"Hack to avoid direct sort when setting sorting enabled.\"\"\"\nmodel = self.model()\nif not do_sort and model is not None:\nbackup = model.sort\nmodel.sort = lambda x, y: None\nself.setSortingEnabled(enabled)\nif not do_sort and model is not None:\nmodel.sort = backup\ndef set_indentation(self, indentation: int):\nself.setIndentation(indentation)\ndef setup_list_style(self):\nself.setSelectionBehavior(self.SelectionBehavior.SelectRows)\nself.h_header.setStretchLastSection(True)\ndef adapt_sizes(self):\nmodel = self.model()\nif model is not None and (model.rowCount() * model.columnCount()) &lt; 1000:\nself.h_header.resizeSections(self.h_header.ResizeMode.ResizeToContents)\nelse:\nself.h_header.resize_sections(\"interactive\")\ndef sort_by_column(self, column: int | None, ascending: bool = True):\ncolumn = -1 if column is None else column\norder = constants.ASCENDING if ascending else constants.DESCENDING\nself.sortByColumn(column, order)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treeview.TreeViewMixin.set_expanded","title":"<code>set_expanded(index: core.ModelIndex | Iterable[core.ModelIndex], expanded: bool = True)</code>","text":"<p>Set expaned state of an index or an Iterable of indexes.</p> Source code in <code>prettyqt\\widgets\\treeview.py</code> <pre><code>def set_expanded(\nself, index: core.ModelIndex | Iterable[core.ModelIndex], expanded: bool = True\n):\n\"\"\"Set expaned state of an index or an Iterable of indexes.\"\"\"\nmatch index:\ncase Iterable():\nfor idx in index:\nself.setExpanded(idx, expanded)\ncase _:\nself.setExpanded(index, expanded)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treeview.TreeViewMixin.set_sorting_enabled","title":"<code>set_sorting_enabled(enabled: bool, do_sort: bool = False)</code>","text":"<p>Hack to avoid direct sort when setting sorting enabled.</p> Source code in <code>prettyqt\\widgets\\treeview.py</code> <pre><code>def set_sorting_enabled(self, enabled: bool, do_sort: bool = False):\n\"\"\"Hack to avoid direct sort when setting sorting enabled.\"\"\"\nmodel = self.model()\nif not do_sort and model is not None:\nbackup = model.sort\nmodel.sort = lambda x, y: None\nself.setSortingEnabled(enabled)\nif not do_sort and model is not None:\nmodel.sort = backup\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.TreeWidgetItem","title":"<code>TreeWidgetItem</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtWidgets.QTreeWidgetItem</code></p> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>class TreeWidgetItem(serializemixin.SerializeMixin, QtWidgets.QTreeWidgetItem):\ndef __repr__(self):\nreturn get_repr(self)\ndef serialize_fields(self):\ndata = [\nself.data(i, constants.USER_ROLE)  # type: ignore\nfor i in range(self.columnCount())\n]\nreturn dict(\ntext=[self.text(i) for i in range(self.columnCount())],\ntool_tip=[self.toolTip(i) for i in range(self.columnCount())],\nstatus_tip=[self.statusTip(i) for i in range(self.columnCount())],\ncheckstate=[self.get_checkstate(i) for i in range(self.columnCount())],\nicon=[self.get_icon(i) for i in range(self.columnCount())],\ndata=data,\n)\ndef __iter__(self) -&gt; Iterator[QtWidgets.QTreeWidgetItem]:\nreturn iter(self.child(i) for i in range(self.childCount()))\ndef __len__(self):\nreturn self.childCount()\ndef __getitem__(\nself, index: int | slice\n) -&gt; (\nQtWidgets.QTreeWidgetItem\n| listdelegators.BaseListDelegator[QtWidgets.QTreeWidgetItem]\n):\nmatch index:\ncase int():\nitem = self.child(index)\nif item is None:\nraise KeyError(index)\nreturn item\ncase slice():\ncount = self.childCount() if index.stop is None else index.stop\nvalues = list(range(count)[index])\nls = [self.child(i) for i in values]\nreturn listdelegators.BaseListDelegator(ls)\ncase _:\nraise TypeError(index)\ndef __delitem__(self, index: int):\nself.takeChild(index)\ndef __add__(self, other: QtWidgets.QTreeWidgetItem) -&gt; TreeWidgetItem:\nself.addChild(other)\nreturn self\ndef setChecked(self, column: int, checked: bool):\nself.setCheckState(\ncolumn,\nconstants.CheckState.Checked if checked else constants.CheckState.Unchecked,\n)\ndef isChecked(self, col: int) -&gt; bool:\nreturn self.checkState(col) == constants.CheckState.Checked\ndef get_children(\nself, recursive: bool = False\n) -&gt; listdelegators.BaseListDelegator[QtWidgets.QTreeWidgetItem]:\n\"\"\"Get children of this item.\n        recursive option is written iteratively to also support original QTreeWidgetItems.\n        \"\"\"\nif not recursive:\nreturn [self.child(i) for i in range(self.childCount())]\nresults = []\nnodes = [self]\nwhile nodes:\nitems = []\nfor node in nodes:\nresults.append(node)\nitems.extend(node.child(i) for i in range(node.childCount()))\nnodes = items\nreturn listdelegators.BaseListDelegator(results[1:])\ndef get_top_level_items(\nself,\n) -&gt; listdelegators.BaseListDelegator[QtWidgets.QTreeWidgetItem]:\nitems = [self.topLevelItem(i) for i in range(self.topLevelItemCount())]\nreturn listdelegators.BaseListDelegator(items)\ndef collapse(self, recursive: bool = False):\nif recursive:\nfor i in range(self.childCount()):\nself.child(i).collapse(True)\nself.setExpanded(False)\ndef expand(self, recursive: bool = False):\nself.setExpanded(True)\nif recursive:\nfor i in range(self.childCount()):\nself.child(i).expand(True)\ndef set_size_hint(self, hint: datatypes.SizeType, column: int = 0):\nself.setSizeHint(column, datatypes.to_size(hint))\ndef sort_children(self, column: int, descending: bool = False):\norder = constants.DESCENDING if descending else constants.ASCENDING\nself.sortChildren(column, order)\ndef set_data(\nself, data: Any, role: constants.ItemDataRoleStr | constants.ItemDataRole | int\n):\nif not isinstance(role, int):\nrole = constants.ITEM_DATA_ROLE.get_enum_value(role)\nsuper().setData(data, role)\ndef get_data(\nself, role: constants.ItemDataRoleStr | constants.ItemDataRole | int\n) -&gt; Any:\nif not isinstance(role, int):\nrole = constants.ITEM_DATA_ROLE.get_enum_value(role)\nreturn super().data(role)\ndef set_icon(self, icon: datatypes.IconType, column: int = 0):\n\"\"\"Set the icon for the action.\n        Args:\n            icon: icon to use\n            column: column\n        \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(column, icon)\ndef get_background(self, column: int = 0) -&gt; gui.Brush:\nreturn gui.Brush(self.background(column))\ndef get_foreground(self, column: int = 0) -&gt; gui.Brush:\nreturn gui.Brush(self.foreground(column))\ndef get_font(self, column: int = 0) -&gt; gui.Font:\nreturn gui.Font(self.font(column))\ndef get_icon(self, column: int = 0) -&gt; gui.Icon | None:\nreturn None if (icon := self.icon(column)).isNull() else gui.Icon(icon)\ndef set_checkstate(\nself, state: constants.CheckStateStr | constants.CheckState, column: int = 0\n):\n\"\"\"Set checkstate of the checkbox.\n        Args:\n            state: checkstate to use\n            column: column\n        \"\"\"\nself.setCheckState(column, constants.CHECK_STATE.get_enum_value(state))\ndef get_checkstate(self, column: int = 0) -&gt; constants.CheckStateStr:\n\"\"\"Return checkstate.\n        Args:\n            column: column\n        Returns:\n            checkstate\n        \"\"\"\nreturn constants.CHECK_STATE.inverse[self.checkState(column)]\ndef set_child_indicator_policy(\nself, policy: ChildIndicatorPolicyStr | mod.ChildIndicatorPolicy\n):\n\"\"\"Set the child indicator policy.\n        Args:\n            policy: child indicator policy\n        \"\"\"\nself.setChildIndicatorPolicy(CHILD_INDICATOR_POLICY.get_enum_value(policy))\ndef get_child_indicator_policy(self) -&gt; ChildIndicatorPolicyStr:\n\"\"\"Return current child indicator policy.\n        Returns:\n            child indicator policy\n        \"\"\"\nreturn CHILD_INDICATOR_POLICY.inverse[self.childIndicatorPolicy()]\ndef get_text_alignment(self, column: int) -&gt; constants.AlignmentStr:\nreturn constants.ALIGNMENTS.inverse[self.textAlignment(column)]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_checkstate","title":"<code>get_checkstate(column: int = 0) -&gt; constants.CheckStateStr</code>","text":"<p>Return checkstate.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>int</code> <p>column</p> <code>0</code> <p>Returns:</p> Type Description <code>constants.CheckStateStr</code> <p>checkstate</p> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>def get_checkstate(self, column: int = 0) -&gt; constants.CheckStateStr:\n\"\"\"Return checkstate.\n    Args:\n        column: column\n    Returns:\n        checkstate\n    \"\"\"\nreturn constants.CHECK_STATE.inverse[self.checkState(column)]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_child_indicator_policy","title":"<code>get_child_indicator_policy() -&gt; ChildIndicatorPolicyStr</code>","text":"<p>Return current child indicator policy.</p> <p>Returns:</p> Type Description <code>ChildIndicatorPolicyStr</code> <p>child indicator policy</p> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>def get_child_indicator_policy(self) -&gt; ChildIndicatorPolicyStr:\n\"\"\"Return current child indicator policy.\n    Returns:\n        child indicator policy\n    \"\"\"\nreturn CHILD_INDICATOR_POLICY.inverse[self.childIndicatorPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_children","title":"<code>get_children(recursive: bool = False) -&gt; listdelegators.BaseListDelegator[QtWidgets.QTreeWidgetItem]</code>","text":"<p>Get children of this item.</p> <p>recursive option is written iteratively to also support original QTreeWidgetItems.</p> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>def get_children(\nself, recursive: bool = False\n) -&gt; listdelegators.BaseListDelegator[QtWidgets.QTreeWidgetItem]:\n\"\"\"Get children of this item.\n    recursive option is written iteratively to also support original QTreeWidgetItems.\n    \"\"\"\nif not recursive:\nreturn [self.child(i) for i in range(self.childCount())]\nresults = []\nnodes = [self]\nwhile nodes:\nitems = []\nfor node in nodes:\nresults.append(node)\nitems.extend(node.child(i) for i in range(node.childCount()))\nnodes = items\nreturn listdelegators.BaseListDelegator(results[1:])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_checkstate","title":"<code>set_checkstate(state: constants.CheckStateStr | constants.CheckState, column: int = 0)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.CheckStateStr | constants.CheckState</code> <p>checkstate to use</p> required <code>column</code> <code>int</code> <p>column</p> <code>0</code> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>def set_checkstate(\nself, state: constants.CheckStateStr | constants.CheckState, column: int = 0\n):\n\"\"\"Set checkstate of the checkbox.\n    Args:\n        state: checkstate to use\n        column: column\n    \"\"\"\nself.setCheckState(column, constants.CHECK_STATE.get_enum_value(state))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_child_indicator_policy","title":"<code>set_child_indicator_policy(policy: ChildIndicatorPolicyStr | mod.ChildIndicatorPolicy)</code>","text":"<p>Set the child indicator policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>ChildIndicatorPolicyStr | mod.ChildIndicatorPolicy</code> <p>child indicator policy</p> required Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>def set_child_indicator_policy(\nself, policy: ChildIndicatorPolicyStr | mod.ChildIndicatorPolicy\n):\n\"\"\"Set the child indicator policy.\n    Args:\n        policy: child indicator policy\n    \"\"\"\nself.setChildIndicatorPolicy(CHILD_INDICATOR_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_icon","title":"<code>set_icon(icon: datatypes.IconType, column: int = 0)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required <code>column</code> <code>int</code> <p>column</p> <code>0</code> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType, column: int = 0):\n\"\"\"Set the icon for the action.\n    Args:\n        icon: icon to use\n        column: column\n    \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setIcon(column, icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.UndoView","title":"<code>UndoView</code>","text":"<p>         Bases: <code>widgets.ListViewMixin</code>, <code>QtWidgets.QUndoView</code></p> Source code in <code>prettyqt\\widgets\\undoview.py</code> <pre><code>class UndoView(widgets.ListViewMixin, QtWidgets.QUndoView):\ndef __getitem__(self, index: int) -&gt; QtGui.QUndoCommand:\nreturn self.stack().command(index)\ndef set_clean_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the clean button.\n        Args:\n            icon: icon to use\n        \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setCleanIcon(icon)\ndef set_value(self, value: QtGui.QUndoGroup | QtGui.QUndoStack):\nif isinstance(value, QtGui.QUndoGroup):\nself.setGroup(value)\nelse:\nself.setStack(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView.set_clean_icon","title":"<code>set_clean_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the clean button.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\undoview.py</code> <pre><code>def set_clean_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the clean button.\n    Args:\n        icon: icon to use\n    \"\"\"\nicon = iconprovider.get_icon(icon)\nself.setCleanIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.WidgetMixin","title":"<code>WidgetMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>class WidgetMixin(core.ObjectMixin):\ndef __init__(self, *args, margin: int | None = None, **kwargs):\nsuper().__init__(*args, **kwargs)\nself.fx = fx.Fx(self)\nif margin is not None:\nself.set_margin(margin)\ndef _get_map(self):\nmaps = super()._get_map()\nmaps |= {\n\"contextMenuPolicy\": constants.CONTEXT_POLICY,\n\"focusPolicy\": constants.FOCUS_POLICY,\n\"layoutDirection\": constants.LAYOUT_DIRECTION,\n\"windowModality\": constants.WINDOW_MODALITY,\n}\nreturn maps\ndef add_shortcut(\nself,\nkeysequence: datatypes.KeyCombinationType,\ncallback: Callable | None = None,\ncontext: constants.ShortcutContextStr = \"window\",\n) -&gt; gui.Shortcut:\n\"\"\"Add shortcut to widget.\n        Adds as shortcut for given callback and context to this widget.\n        Args:\n            keysequence: Key sequence\n            callback: Callback for the shortcut\n            context: context for this shortcut\n        Returns:\n            shortcut object\n        \"\"\"\nreturn gui.Shortcut(\ndatatypes.to_keysequence(keysequence),\nself,\ncallback,\ncontext=constants.SHORTCUT_CONTEXT.get_enum_value(context),\n)\ndef get_win_id(self) -&gt; int:\nreturn int(self.winId())\ndef resize(self, *size):\nif isinstance(size[0], tuple):\nsuper().resize(*size[0])\nelse:\nsuper().resize(*size)\ndef set_enabled(self, enabled: bool = True) -&gt; None:\nself.setEnabled(enabled)\ndef set_disabled(self) -&gt; None:\nself.setEnabled(False)\ndef insertAction(\nself, position_or_action: int | QtGui.QAction, action: QtGui.QAction\n):\n\"\"\"Extend insertAction to also allow int index.\"\"\"\nif isinstance(position_or_action, int):\nactions = self.actions()\nif len(actions) == 0 or position_or_action &gt;= len(actions):\n# Insert as the first action or the last action.\nreturn super().addAction(action)\nposition_or_action = actions[position_or_action]\nsuper().insertAction(position_or_action, action)\ndef add_action(\nself,\ntext: str | gui.Action,\nparent: QtWidgets.QWidget | None = None,\ndata: Any = None,\n**kwargs,\n) -&gt; gui.Action:\n\"\"\"Add an action to the menu.\n        Args:\n            text: Label for the action\n            parent: parent\n            data: data for the Action\n            kwargs: kwargs passed to action ctor\n        Returns:\n            Action added to menu\n        \"\"\"\nif isinstance(text, str):\naction = gui.Action(parent=parent or self, text=text, **kwargs)\nelse:\naction = text\naction.setParent(self)\nself.addAction(action)\naction.setData(data)\nreturn action\ndef add_actions(self, actions: Sequence[QtGui.QAction]):\nfor i in actions:\ni.setParent(self)\nself.addActions(actions)\ndef toggle_fullscreen(self) -&gt; bool:\n\"\"\"Toggle between fullscreen and regular size.\"\"\"\nif self.isFullScreen():\nself.showNormal()\nreturn False\nelse:\nself.showFullScreen()\nreturn True\ndef toggle_maximized(self) -&gt; bool:\n\"\"\"Toggle between maximized and regular size.\"\"\"\nif self.isMaximized():\nself.showNormal()\nreturn False\nelse:\nself.showMaximized()\nreturn True\ndef map_to(\nself,\nwidget: QtWidgets.QWidget | Literal[\"global\", \"parent\", \"window\"],\npos_or_rect,\n) -&gt; QtCore.QRect | QtCore.QRectF | QtCore.QPoint | QtCore.QPointF:\n\"\"\"Map a point or rect to a widget, global position or parent.\"\"\"\nmatch pos_or_rect:\ncase int(), int():\npos_or_rect = QtCore.QPoint(*pos_or_rect)\ncase float(), float():\npos_or_rect = QtCore.QPointF(*pos_or_rect)\ncase int(), int(), int(), int():\npos_or_rect = QtCore.QRect(*pos_or_rect)\ncase float(), float(), float(), float():\npos_or_rect = QtCore.QRectF(*pos_or_rect)\nmatch pos_or_rect, widget:\ncase QtCore.QRect() | QtCore.QRectF(), QtWidgets.QWidget():\ntop_left = super().mapTo(widget, pos_or_rect.topLeft())\nbottom_right = super().mapTo(widget, pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), QtWidgets.QWidget():\nreturn super().mapTo(widget, pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"parent\":\ntop_left = super().mapToParent(pos_or_rect.topLeft())\nbottom_right = super().mapToParent(pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"parent\":\nreturn super().mapToParent(pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"window\":\ntop_left = super().mapTo(self.window(), pos_or_rect.topLeft())\nbottom_right = super().mapTo(self.window(), pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"window\":\nreturn super().mapTo(self.window(), pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"global\":\ntop_left = super().mapToGlobal(pos_or_rect.topLeft())\nbottom_right = super().mapToGlobal(pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"global\":\nreturn super().mapToGlobal(pos_or_rect)\ncase _:\nraise ValueError(pos_or_rect)\ndef map_from(\nself,\nwidget: QtWidgets.QWidget | Literal[\"global\", \"parent\", \"window\"],\npos_or_rect,\n) -&gt; QtCore.QRect | QtCore.QRectF | QtCore.QPoint | QtCore.QPointF:\n\"\"\"Map a point or rect from a widget, global position or parent.\"\"\"\nmatch pos_or_rect:\ncase int(), int():\npos_or_rect = QtCore.QPoint(*pos_or_rect)\ncase float(), float():\npos_or_rect = QtCore.QPointF(*pos_or_rect)\ncase int(), int(), int(), int():\npos_or_rect = QtCore.QRect(*pos_or_rect)\ncase float(), float(), float(), float():\npos_or_rect = QtCore.QRectF(*pos_or_rect)\nmatch pos_or_rect, widget:\ncase QtCore.QRect() | QtCore.QRectF(), QtWidgets.QWidget():\ntop_left = super().mapFrom(widget, pos_or_rect.topLeft())\nbottom_right = super().mapFrom(widget, pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), QtWidgets.QWidget():\nreturn super().mapFrom(widget, pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"parent\":\ntop_left = super().mapFromParent(pos_or_rect.topLeft())\nbottom_right = super().mapFromParent(pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"parent\":\nreturn super().mapFromParent(pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"window\":\ntop_left = super().mapFrom(self.window(), pos_or_rect.topLeft())\nbottom_right = super().mapFrom(self.window(), pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"window\":\nreturn super().mapFrom(self.window(), pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"global\":\ntop_left = super().mapFromGlobal(pos_or_rect.topLeft())\nbottom_right = super().mapFromGlobal(pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"global\":\nreturn super().mapFromGlobal(pos_or_rect)\ncase _:\nraise ValueError(pos_or_rect)\ndef raise_to_top(self):\n\"\"\"Brings a widget to top with all means available.\"\"\"\nif sys.platform.startswith(\"win\"):\nfrom prettyqt.utils.platforms.windows import misc\nmisc.raise_to_top()\n# state = (self.windowState() &amp; ~Qt.WindowMinimized) | Qt.WindowActive\n# self.setWindowState(state)\nself.raise_()\nself.show()\nself.activateWindow()\ndef set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the window icon.\n        Args:\n            icon: icon to use\n        \"\"\"\nicon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\nsuper().setWindowIcon(icon)\nsetWindowIcon = set_icon\ndef get_icon(self) -&gt; gui.Icon | None:\n\"\"\"Get the window icon (returns None if not existing).\"\"\"\nicon = super().windowIcon()\nreturn None if icon.isNull() else gui.Icon(icon)\ndef show_tooltip(self, duration: int | None = None):\n\"\"\"Show the tooltip of this widget for given time.\n        When no duration is given, it will get calculated based on length.\n        \"\"\"\nif duration is None:\nduration = -1  # automatic\npos = self.map_to(\"global\", (0, 0))\nwidgets.ToolTip.showText(pos, self.toolTip(), msecShowTime=duration)\n# lets be gentle and allow all reasonable signatures for the size setters.\n# tuples as well as passing two args is possible.\n@functools.singledispatchmethod\ndef set_min_size(self, size: QtCore.QSize | tuple[int | None, int | None]):\nmatch size:\ncase int() | None as x, int() | None as y:\nsuper().setMinimumSize(x or 0, y or 0)\ncase QtCore.QSize():\nsuper().setMinimumSize(size)\ncase _:\nraise TypeError(size)\nsetMinimumSize = set_min_size\n@set_min_size.register\ndef _(self, x: int, y: int | None):\nself.set_min_size((x, y))\n@set_min_size.register  # these can be merged when min py version is 3.11\ndef _(self, x: None, y: int | None):\nself.set_min_size((x, y))\n@functools.singledispatchmethod\ndef set_max_size(self, size: QtCore.QSize | tuple[int | None, int | None]):\nmatch size:\ncase int() | None as x, int() | None as y:\nx = QWIDGETSIZE_MAX if x is None else x\ny = QWIDGETSIZE_MAX if y is None else y\nsuper().setMaximumSize(x, y)\ncase _:\nsuper().setMaximumSize(size)\nsetMaximumSize = set_min_size\n@set_max_size.register\ndef _(self, x: int, y: int | None):\nself.set_max_size((x, y))\n@set_max_size.register  # these can be merged when min py version is 3.11\ndef _(self, x: None, y: int | None):\nself.set_max_size((x, y))\ndef set_min_width(self, width: int | None):\nsuper().setMinimumWidth(width or 0)\nsetMinimumWidth = set_min_width\ndef set_max_width(self, width: int | None):\nif width is None:\nwidth = QWIDGETSIZE_MAX\nsuper().setMaximumWidth(width)\nsetMaximumWidth = set_max_width\ndef set_min_height(self, height: int | None):\nsuper().setMinimumHeight(height or 0)\nsetMinimumHeight = set_min_height\ndef set_max_height(self, height: int | None):\nif height is None:\nheight = QWIDGETSIZE_MAX\nsuper().setMaximumHeight(height)\nsetMaximumHeight = set_max_height\ndef setWindowTitle(self, title: str):\nif not self.objectName() and widgets.app().is_debug():\nself.setObjectName(title)\nsuper().setWindowTitle(title)\ndef set_title(self, title: str):\nself.setWindowTitle(title)\ndef get_title(self) -&gt; str:\nreturn self.windowTitle()\ndef set_tooltip(\nself,\ntooltip: str | datatypes.PathType,\nsize: datatypes.SizeType | None = None,\nrich_text: bool = False,\n):\n\"\"\"Set a tooltip for this widget.\n        In image can get displayed by passing a PathLike object.\n        \"\"\"\nif isinstance(tooltip, os.PathLike):\npath = os.fspath(tooltip)\nif size is None:\ntooltip = f\"&lt;img src={path!r}&gt;\"\nelse:\nif isinstance(size, QtCore.QSize):\nsize = (size.width(), size.height())\ntooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\ntooltip = tooltip.replace(\"\\n\", \"&lt;br/&gt;\")\nif rich_text:\ntooltip = f\"&lt;html&gt;{html.escape(tooltip)}&lt;/html&gt;\"\nsuper().setToolTip(tooltip)\ndef set_font(\nself,\nfont_name: QtGui.QFont | str | None = None,\nfont_size: int | None = None,\nweight: int | None = None,\nitalic: bool = False,\n) -&gt; QtGui.QFont:\n\"\"\"Set the font for this widget.\"\"\"\nif isinstance(font_name, QtGui.QFont):\nsuper().setFont(font_name)\nreturn font_name\nif font_size is None:\nfont_size = -1\nif weight is None:\nweight = -1\nif font_name is None:\nfont_name = self.font().family()\nfont = gui.Font(font_name, font_size, weight, italic)\nsuper().setFont(font)\nreturn font\ndef get_font(self) -&gt; gui.Font:\nreturn gui.Font(self.font())\ndef get_foreground_role(self) -&gt; gui.palette.RoleStr:\n\"\"\"Set foreground role for this widget.\"\"\"\nreturn gui.palette.ROLE.inverse[self.foregroundRole()]\ndef set_foreground_role(self, role: gui.palette.RoleStr | gui.Palette.ColorRole):\n\"\"\"Set foreground role for this widget.\"\"\"\nself.setForegroundRole(gui.palette.ROLE.get_enum_value(role))\ndef get_background_role(self) -&gt; gui.palette.RoleStr:\n\"\"\"Get background role for this widget.\"\"\"\nreturn gui.palette.ROLE.inverse[self.backgroundRole()]\ndef set_background_role(self, role: gui.palette.RoleStr | gui.Palette.ColorRole):\n\"\"\"Get foreground role for this widget.\"\"\"\nself.setBackgroundRole(gui.palette.ROLE.get_enum_value(role))\ndef set_window_flags(self, *flags: constants.WindowTypeStr, append: bool = False):\nresult = constants.WINDOW_TYPE.merge_flags(flags)\nif append:\nresult = result | self.windowFlags()\nself.setWindowFlags(result)\ndef set_flags(\nself,\nminimize: bool | None = None,\nmaximize: bool | None = None,\nclose: bool | None = None,\nstay_on_top: bool | None = None,\nframeless: bool | None = None,\nwindow: bool | None = None,\ndialog: bool | None = None,\ntooltip: bool | None = None,\ntool: bool | None = None,\ncustomize: bool | None = None,\nwindow_title: bool | None = None,\n):\nflags = {\nminimize: constants.WindowType.WindowMinimizeButtonHint,\nmaximize: constants.WindowType.WindowMaximizeButtonHint,\nclose: constants.WindowType.WindowCloseButtonHint,\nstay_on_top: constants.WindowType.WindowStaysOnTopHint,\nframeless: constants.WindowType.FramelessWindowHint,\nwindow: constants.WindowType.Window,\ndialog: constants.WindowType.Dialog,\ntooltip: constants.WindowType.ToolTip,\ntool: constants.WindowType.Tool,\ncustomize: constants.WindowType.CustomizeWindowHint,\nwindow_title: constants.WindowType.WindowTitleHint,\n}\nfor k, v in flags.items():\nif k is not None:\nself.setWindowFlag(v, k)\ndef set_attribute(\nself,\nattribute: constants.WidgetAttributeStr | constants.WidgetAttribute,\nstate: bool = True,\n):\nself.setAttribute(constants.WIDGET_ATTRIBUTE.get_enum_value(attribute), state)\ndef set_attributes(self, **kwargs: bool):\nfor attr, state in kwargs.items():\nself.setAttribute(constants.WIDGET_ATTRIBUTE.get_enum_value(attr), state)\ndef set_modality(\nself, modality: constants.WindowModalityStr | constants.WindowModality\n):\n\"\"\"Set modality for the dialog.\n        Args:\n            modality: modality for the main window\n        \"\"\"\nself.setWindowModality(constants.WINDOW_MODALITY.get_enum_value(modality))\ndef get_modality(self) -&gt; constants.WindowModalityStr:\n\"\"\"Get the current modality modes as a string.\n        Returns:\n            modality mode\n        \"\"\"\nreturn constants.WINDOW_MODALITY.inverse[self.windowModality()]\ndef set_size_policy(\nself,\nhorizontal: widgets.sizepolicy.SizePolicyStr\n| widgets.QSizePolicy.Policy\n| None = None,\nvertical: widgets.sizepolicy.SizePolicyStr\n| widgets.QSizePolicy.Policy\n| None = None,\n):\n\"\"\"Set the size policy.\n        Args:\n            horizontal: horizontal size policy\n            vertical: vertical size policy\n        \"\"\"\nsp = self.get_size_policy()\nif horizontal is not None:\nsp.set_horizontal_policy(horizontal)\nif vertical is not None:\nsp.set_vertical_policy(vertical)\nself.setSizePolicy(sp)\ndef get_size_policy(self) -&gt; widgets.SizePolicy:\n\"\"\"Get size policy.\"\"\"\nqpol = self.sizePolicy()\nif isinstance(qpol, widgets.SizePolicy):\nreturn qpol\nreturn widgets.SizePolicy.clone(qpol)\ndef get_palette(self) -&gt; gui.Palette:\nreturn gui.Palette(self.palette())\ndef set_background_color(self, color: datatypes.ColorType):\ncol_str = \"\" if color is None else colors.get_color(color).name()\nwith self.edit_stylesheet() as ss:\nss.backgroundColor.setValue(col_str)\n@contextlib.contextmanager\ndef grab_mouse_events(\nself, cursor_shape: constants.CursorShapeStr | None = None\n) -&gt; Iterator[None]:\n\"\"\"Context manager to grab mouse events.\"\"\"\nif cursor_shape is not None:\nself.grabMouse(constants.CURSOR_SHAPE[cursor_shape])\nelse:\nself.grabMouse()\nyield None\nself.releaseMouse()\n@contextlib.contextmanager\ndef grab_keyboard_events(self) -&gt; Iterator[None]:\n\"\"\"Context manager to grab keyboard events.\"\"\"\nself.grabKeyboard()\nyield None\nself.releaseKeyboard()\n@contextlib.contextmanager\ndef updates_off(self) -&gt; Iterator[None]:\nupdates = self.updatesEnabled()\nself.setUpdatesEnabled(False)\nyield None\nself.setUpdatesEnabled(updates)\n@contextlib.contextmanager\ndef edit_stylesheet(self) -&gt; Iterator[qstylizer.style.StyleSheet]:\nss = self.get_stylesheet()\nyield ss\nself.set_stylesheet(ss)\ndef set_stylesheet(\nself, ss: None | str | qstylizer.style.StyleSheet | datatypes.PathType\n):\nmatch ss:\ncase None:\nss = \"\"\ncase str():\npass\ncase os.PathLike():\nss = pathlib.Path(ss).read_text()\ncase qstylizer.style.StyleSheet():\nss = str(ss)\nself.setStyleSheet(ss)\ndef get_stylesheet(self) -&gt; qstylizer.style.StyleSheet:\ntry:\nreturn qstylizer.parser.parse(self.styleSheet())\nexcept ValueError:\nreturn qstylizer.style.StyleSheet()\n@contextlib.contextmanager\ndef edit_palette(self) -&gt; Iterator[gui.Palette]:\npalette = gui.Palette(self.palette())\nyield palette\nself.setPalette(palette)\n@contextlib.contextmanager\ndef edit_font(self) -&gt; Iterator[gui.Font]:\nfont = gui.Font(self.font())\nyield font\nself.setFont(font)\ndef set_context_menu_policy(\nself, policy: constants.ContextPolicyStr | constants.ContextMenuPolicy\n):\n\"\"\"Set contextmenu policy for given item view.\n        Args:\n            policy: contextmenu policy to use\n        \"\"\"\nself.setContextMenuPolicy(constants.CONTEXT_POLICY.get_enum_value(policy))\ndef get_context_menu_policy(self) -&gt; constants.ContextPolicyStr:\n\"\"\"Return current contextmenu policy.\n        Returns:\n            contextmenu policy\n        \"\"\"\nreturn constants.CONTEXT_POLICY.inverse[self.contextMenuPolicy()]\ndef set_window_state(self, state: constants.WindowStateStr | constants.WindowState):\n\"\"\"Set window state for given item view.\n        Args:\n            state: window state to use\n        \"\"\"\nself.setWindowState(constants.WINDOW_STATES.get_enum_value(state))\ndef get_window_state(self) -&gt; constants.WindowStateStr:\n\"\"\"Return current window state.\n        Returns:\n            window state\n        \"\"\"\nreturn constants.WINDOW_STATES.inverse[self.windowState()]\ndef set_custom_menu(self, method: Callable):\nself.set_context_menu_policy(\"custom\")\nself.customContextMenuRequested.connect(method)\n@property\ndef box(self):\nreturn self.layout()\n@box.setter\ndef box(self, layout):\nself.set_layout(layout)\n@overload\ndef set_layout(\nself, layout: Literal[\"horizontal\"], margin: int | None = None, **kwargs\n) -&gt; widgets.HBoxLayout:\npass\n@overload\ndef set_layout(\nself, layout: Literal[\"vertical\"], margin: int | None = None, **kwargs\n) -&gt; widgets.VBoxLayout:\npass\n@overload\ndef set_layout(\nself, layout: Literal[\"grid\"], margin: int | None = None, **kwargs\n) -&gt; widgets.GridLayout:\npass\n@overload\ndef set_layout(\nself, layout: Literal[\"border\"], margin: int | None = None, **kwargs\n) -&gt; custom_widgets.BorderLayout:\npass\n@overload\ndef set_layout(\nself, layout: Literal[\"flow\"], margin: int | None = None, **kwargs\n) -&gt; custom_widgets.FlowLayout:\npass\n@overload\ndef set_layout(\nself, layout: Literal[\"form\"], margin: int | None = None, **kwargs\n) -&gt; widgets.FormLayout:\npass\n@overload\ndef set_layout(\nself, layout: Literal[\"stacked\"], margin: int | None = None, **kwargs\n) -&gt; widgets.StackedLayout:\npass\ndef set_layout(\nself,\nlayout: LayoutStr | QtWidgets.QLayout,\nmargin: int | None = None,\n**kwargs,\n) -&gt; QtWidgets.QLayout:\n\"\"\"Quick way to set a layout.\n        Sets layout to given layout, also allows setting margin and spacing.\n        Args:\n            layout: Layout to set\n            margin: margin to use in pixels\n            kwargs: keyword arguments passed to layout\n        Returns:\n            Layout\n        \"\"\"\nfrom prettyqt import custom_widgets\nmatch layout:\ncase \"horizontal\":\nlayout = widgets.HBoxLayout(**kwargs)\ncase \"vertical\":\nlayout = widgets.VBoxLayout(**kwargs)\ncase \"grid\":\nlayout = widgets.GridLayout(**kwargs)\ncase \"form\":\nlayout = widgets.FormLayout(**kwargs)\ncase \"stacked\":\nlayout = widgets.StackedLayout(**kwargs)\ncase \"flow\":\nlayout = custom_widgets.FlowLayout(**kwargs)\ncase \"border\":\nlayout = custom_widgets.BorderLayout(**kwargs)\ncase QtWidgets.QLayout():\nlayout = layout\ncase _:\nraise ValueError(f\"Invalid Layout {layout}\")\nself.setLayout(layout)\nif margin is not None:\nlayout.set_margin(margin)\nreturn layout\ndef position_on(\nself,\nwhere: PositionPossibilityType,\nhow: Literal[\n\"center\",\n\"top\",\n\"left\",\n\"bottom\",\n\"right\",\n\"top_left\",\n\"top_right\",\n\"bottom_left\",\n\"bottom_right\",\n] = \"center\",\nscale_ratio: int | None = None,\nx_offset: int = 0,\ny_offset: int = 0,\n):\n\"\"\"Position widget on another widget / window / screen.\n        Arguments:\n            where: where to positin on\n            how: How to align\n            scale_ratio: Resize to scale_ratio * target size\n            x_offset: additional x offset for final position\n            y_offset: additional y offset for final position\n        \"\"\"\ndo_scale = True\nmatch where:\ncase \"mouse\":\ngeom = core.Rect(gui.Cursor.pos(), gui.Cursor.pos())\ndo_scale = False\ncase QtCore.QPoint():\ngeom = core.Rect(where, where)\ndo_scale = False\ncase (int(), int()):\np = core.Point(*where)\ngeom = core.Rect(p, p)\ndo_scale = False\ncase (int(), int(), int(), int()):\ngeom = core.Rect(*where)\ncase \"parent\":\ngeom = self.parent().frameGeometry()\ncase \"window\":\ngeom = self.window().frameGeometry()\ncase QtWidgets.QWidget():\ngeom = where.frameGeometry()\ncase QtCore.QRect():\ngeom = where\ncase \"screen\":\ngeom = gui.GuiApplication.primaryScreen().geometry()\ncase _:\nraise ValueError(where)\nif scale_ratio is not None and do_scale:\nself.resize(\nint(geom.width() * scale_ratio),\nint(geom.height() * scale_ratio),\n)\nown_geo = self.frameGeometry()\nmatch how:\ncase \"center\":\nnew = geom.center()\ncase \"top\":\nnew = core.Point(geom.center().x(), geom.top() + own_geo.height() // 2)\ncase \"bottom\":\nnew = core.Point(geom.center().x(), geom.bottom() - own_geo.height() // 2)\ncase \"left\":\nnew = core.Point(geom.left() + own_geo.width() // 2, geom.center().y())\ncase \"right\":\nnew = core.Point(geom.right() - own_geo.width() // 2, geom.center().y())\ncase \"top_right\":\nnew = core.Point(\ngeom.right() - own_geo.width() // 2,\ngeom.top() + own_geo.height() // 2,\n)\ncase \"top_left\":\nnew = core.Point(\ngeom.left() + own_geo.width() // 2,\ngeom.top() + own_geo.height() // 2,\n)\ncase \"bottom_right\":\nnew = core.Point(\ngeom.right() - own_geo.width() // 2,\ngeom.bottom() - own_geo.height() // 2,\n)\ncase \"bottom_left\":\nnew = core.Point(\ngeom.left() + own_geo.width() // 2,\ngeom.bottom() - own_geo.height() // 2,\n)\ncase _:\nraise ValueError(how)\nnew = core.Point(new.x() + x_offset, new.y() + y_offset)\nown_geo.moveCenter(new)\nself.move(own_geo.topLeft())\ndef set_cursor(\nself, cursor: constants.CursorShapeStr | constants.CursorShape | QtGui.QCursor\n):\nif isinstance(cursor, QtGui.QCursor):\ncurs = cursor\nelse:\ncurs = gui.Cursor(constants.CURSOR_SHAPE.get_enum_value(cursor))\nself.setCursor(curs)\ndef set_focus_policy(self, policy: constants.FocusPolicyStr | constants.FocusPolicy):\n\"\"\"Set the way the widget accepts keyboard focus.\n        Args:\n            policy (str): Focus policy\n        \"\"\"\nself.setFocusPolicy(constants.FOCUS_POLICY.get_enum_value(policy))\ndef get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return waay the widget accepts keyboard focus.\n        Returns:\n            str: Focus policy\n        \"\"\"\nreturn constants.FOCUS_POLICY.inverse[self.focusPolicy()]\ndef set_focus(self, reason: constants.FocusReasonStr | None = None):\nif reason is None:\nself.setFocus()\nelse:\nself.setFocus(constants.FOCUS_REASONS[reason])\ndef set_font_size(self, size: int):\nfont = self.font()\nfont.setPointSize(size)\nself.setFont(font)\ndef get_font_metrics(self) -&gt; gui.FontMetrics:\nreturn gui.FontMetrics(self.fontMetrics())\ndef get_font_info(self) -&gt; gui.FontInfo:\nreturn gui.FontInfo(self.fontInfo())\ndef set_margin(self, margin: int):\nself.setContentsMargins(margin, margin, margin, margin)\ndef raise_dock(self) -&gt; bool:\nw = self.find_parent(QtWidgets.QDockWidget)\nif w is None:\nreturn False\nw.setVisible(True)\nw.raise_()\nreturn True\ndef set_mask(\nself,\narea: datatypes.RectType | QtGui.QRegion | QtGui.QBitmap | None,\ntyp: gui.region.RegionTypeStr = \"rectangle\",\n):\nmatch area:\ncase None:\nself.clearMask()\nreturn\ncase (int(), int(), int(), int()):\narea = gui.Region(*area, gui.region.REGION_TYPE[typ])\ncase QtCore.QRect():\narea = gui.Region(area, gui.region.REGION_TYPE[typ])\nself.setMask(area)\ndef set_window_file_path(self, path: datatypes.PathType):\nself.setWindowFilePath(os.fspath(path))\ndef get_window_file_path(self) -&gt; pathlib.Path | None:\npath = self.windowFilePath()\nreturn pathlib.Path(path) if path else None\ndef get_image(self) -&gt; QtGui.QPixmap:\nfrom prettyqt.qt import QtOpenGLWidgets\nimage = self.grab()\nwith gui.Painter(image) as painter:\npainter.set_composition_mode(\"source_atop\")\nfor gl_widget in self.find_children(QtOpenGLWidgets.QOpenGLWidget):\nd = gl_widget.mapToGlobal(core.Point()) - self.mapToGlobal(core.Point())\npainter.drawImage(d, gl_widget.grabFramebuffer())\nreturn image\ndef get_screen(self) -&gt; gui.Screen | None:\nwindow = self.window().windowHandle()\nreturn None if window is None else gui.Screen(window.screen())\ndef delete_children(self):\n\"\"\"Delete all children of the specified QObject.\"\"\"\nif hasattr(self, \"clear\"):\nreturn self.clear()\nlayout = self.layout()\nwhile layout.count():\nitem = layout.takeAt(0)\nif widget := item.widget():\nwidget.deleteLater()\ndef get_cursor(self) -&gt; gui.Cursor:\nreturn gui.Cursor(self.cursor())\ndef set_style(self, style: str | QtWidgets.QStyle):\nif isinstance(style, str):\nstyle = QtWidgets.QStyleFactory.create(style)\nself.setStyle(style)\ndef child_at(self, *args, typ: type[widgets.QWidget] | None = None):\n\"\"\"Get child widget at position. If type is given, search parents recursively.\"\"\"\nchild = super().childAt(*args)\nif typ is None or isinstance(child, typ):\nreturn child\nwhile child := child.parent():\nif isinstance(child, typ):\nreturn child\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.add_action","title":"<code>add_action(text: str | gui.Action, parent: QtWidgets.QWidget | None = None, data: Any = None, **kwargs: Any) -&gt; gui.Action</code>","text":"<p>Add an action to the menu.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | gui.Action</code> <p>Label for the action</p> required <code>parent</code> <code>QtWidgets.QWidget | None</code> <p>parent</p> <code>None</code> <code>data</code> <code>Any</code> <p>data for the Action</p> <code>None</code> <code>kwargs</code> <p>kwargs passed to action ctor</p> <code>{}</code> <p>Returns:</p> Type Description <code>gui.Action</code> <p>Action added to menu</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def add_action(\nself,\ntext: str | gui.Action,\nparent: QtWidgets.QWidget | None = None,\ndata: Any = None,\n**kwargs,\n) -&gt; gui.Action:\n\"\"\"Add an action to the menu.\n    Args:\n        text: Label for the action\n        parent: parent\n        data: data for the Action\n        kwargs: kwargs passed to action ctor\n    Returns:\n        Action added to menu\n    \"\"\"\nif isinstance(text, str):\naction = gui.Action(parent=parent or self, text=text, **kwargs)\nelse:\naction = text\naction.setParent(self)\nself.addAction(action)\naction.setData(data)\nreturn action\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.add_shortcut","title":"<code>add_shortcut(keysequence: datatypes.KeyCombinationType, callback: Callable | None = None, context: constants.ShortcutContextStr = 'window') -&gt; gui.Shortcut</code>","text":"<p>Add shortcut to widget.</p> <p>Adds as shortcut for given callback and context to this widget.</p> <p>Parameters:</p> Name Type Description Default <code>keysequence</code> <code>datatypes.KeyCombinationType</code> <p>Key sequence</p> required <code>callback</code> <code>Callable | None</code> <p>Callback for the shortcut</p> <code>None</code> <code>context</code> <code>constants.ShortcutContextStr</code> <p>context for this shortcut</p> <code>'window'</code> <p>Returns:</p> Type Description <code>gui.Shortcut</code> <p>shortcut object</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def add_shortcut(\nself,\nkeysequence: datatypes.KeyCombinationType,\ncallback: Callable | None = None,\ncontext: constants.ShortcutContextStr = \"window\",\n) -&gt; gui.Shortcut:\n\"\"\"Add shortcut to widget.\n    Adds as shortcut for given callback and context to this widget.\n    Args:\n        keysequence: Key sequence\n        callback: Callback for the shortcut\n        context: context for this shortcut\n    Returns:\n        shortcut object\n    \"\"\"\nreturn gui.Shortcut(\ndatatypes.to_keysequence(keysequence),\nself,\ncallback,\ncontext=constants.SHORTCUT_CONTEXT.get_enum_value(context),\n)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.child_at","title":"<code>child_at(*args, typ: type[widgets.QWidget] | None = None)</code>","text":"<p>Get child widget at position. If type is given, search parents recursively.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def child_at(self, *args, typ: type[widgets.QWidget] | None = None):\n\"\"\"Get child widget at position. If type is given, search parents recursively.\"\"\"\nchild = super().childAt(*args)\nif typ is None or isinstance(child, typ):\nreturn child\nwhile child := child.parent():\nif isinstance(child, typ):\nreturn child\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.delete_children","title":"<code>delete_children()</code>","text":"<p>Delete all children of the specified QObject.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def delete_children(self):\n\"\"\"Delete all children of the specified QObject.\"\"\"\nif hasattr(self, \"clear\"):\nreturn self.clear()\nlayout = self.layout()\nwhile layout.count():\nitem = layout.takeAt(0)\nif widget := item.widget():\nwidget.deleteLater()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_background_role","title":"<code>get_background_role() -&gt; gui.palette.RoleStr</code>","text":"<p>Get background role for this widget.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_background_role(self) -&gt; gui.palette.RoleStr:\n\"\"\"Get background role for this widget.\"\"\"\nreturn gui.palette.ROLE.inverse[self.backgroundRole()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_context_menu_policy","title":"<code>get_context_menu_policy() -&gt; constants.ContextPolicyStr</code>","text":"<p>Return current contextmenu policy.</p> <p>Returns:</p> Type Description <code>constants.ContextPolicyStr</code> <p>contextmenu policy</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_context_menu_policy(self) -&gt; constants.ContextPolicyStr:\n\"\"\"Return current contextmenu policy.\n    Returns:\n        contextmenu policy\n    \"\"\"\nreturn constants.CONTEXT_POLICY.inverse[self.contextMenuPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_focus_policy","title":"<code>get_focus_policy() -&gt; constants.FocusPolicyStr</code>","text":"<p>Return waay the widget accepts keyboard focus.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>constants.FocusPolicyStr</code> <p>Focus policy</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return waay the widget accepts keyboard focus.\n    Returns:\n        str: Focus policy\n    \"\"\"\nreturn constants.FOCUS_POLICY.inverse[self.focusPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_foreground_role","title":"<code>get_foreground_role() -&gt; gui.palette.RoleStr</code>","text":"<p>Set foreground role for this widget.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_foreground_role(self) -&gt; gui.palette.RoleStr:\n\"\"\"Set foreground role for this widget.\"\"\"\nreturn gui.palette.ROLE.inverse[self.foregroundRole()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_icon","title":"<code>get_icon() -&gt; gui.Icon | None</code>","text":"<p>Get the window icon (returns None if not existing).</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_icon(self) -&gt; gui.Icon | None:\n\"\"\"Get the window icon (returns None if not existing).\"\"\"\nicon = super().windowIcon()\nreturn None if icon.isNull() else gui.Icon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_modality","title":"<code>get_modality() -&gt; constants.WindowModalityStr</code>","text":"<p>Get the current modality modes as a string.</p> <p>Returns:</p> Type Description <code>constants.WindowModalityStr</code> <p>modality mode</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_modality(self) -&gt; constants.WindowModalityStr:\n\"\"\"Get the current modality modes as a string.\n    Returns:\n        modality mode\n    \"\"\"\nreturn constants.WINDOW_MODALITY.inverse[self.windowModality()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_size_policy","title":"<code>get_size_policy() -&gt; widgets.SizePolicy</code>","text":"<p>Get size policy.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_size_policy(self) -&gt; widgets.SizePolicy:\n\"\"\"Get size policy.\"\"\"\nqpol = self.sizePolicy()\nif isinstance(qpol, widgets.SizePolicy):\nreturn qpol\nreturn widgets.SizePolicy.clone(qpol)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_window_state","title":"<code>get_window_state() -&gt; constants.WindowStateStr</code>","text":"<p>Return current window state.</p> <p>Returns:</p> Type Description <code>constants.WindowStateStr</code> <p>window state</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_window_state(self) -&gt; constants.WindowStateStr:\n\"\"\"Return current window state.\n    Returns:\n        window state\n    \"\"\"\nreturn constants.WINDOW_STATES.inverse[self.windowState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.grab_keyboard_events","title":"<code>grab_keyboard_events() -&gt; Iterator[None]</code>","text":"<p>Context manager to grab keyboard events.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>@contextlib.contextmanager\ndef grab_keyboard_events(self) -&gt; Iterator[None]:\n\"\"\"Context manager to grab keyboard events.\"\"\"\nself.grabKeyboard()\nyield None\nself.releaseKeyboard()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.grab_mouse_events","title":"<code>grab_mouse_events(cursor_shape: constants.CursorShapeStr | None = None) -&gt; Iterator[None]</code>","text":"<p>Context manager to grab mouse events.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>@contextlib.contextmanager\ndef grab_mouse_events(\nself, cursor_shape: constants.CursorShapeStr | None = None\n) -&gt; Iterator[None]:\n\"\"\"Context manager to grab mouse events.\"\"\"\nif cursor_shape is not None:\nself.grabMouse(constants.CURSOR_SHAPE[cursor_shape])\nelse:\nself.grabMouse()\nyield None\nself.releaseMouse()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.insertAction","title":"<code>insertAction(position_or_action: int | QtGui.QAction, action: QtGui.QAction)</code>","text":"<p>Extend insertAction to also allow int index.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def insertAction(\nself, position_or_action: int | QtGui.QAction, action: QtGui.QAction\n):\n\"\"\"Extend insertAction to also allow int index.\"\"\"\nif isinstance(position_or_action, int):\nactions = self.actions()\nif len(actions) == 0 or position_or_action &gt;= len(actions):\n# Insert as the first action or the last action.\nreturn super().addAction(action)\nposition_or_action = actions[position_or_action]\nsuper().insertAction(position_or_action, action)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.map_from","title":"<code>map_from(widget: QtWidgets.QWidget | Literal['global', 'parent', 'window'], pos_or_rect: QtWidgets.QWidget | Literal['global', 'parent', 'window']) -&gt; QtCore.QRect | QtCore.QRectF | QtCore.QPoint | QtCore.QPointF</code>","text":"<p>Map a point or rect from a widget, global position or parent.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def map_from(\nself,\nwidget: QtWidgets.QWidget | Literal[\"global\", \"parent\", \"window\"],\npos_or_rect,\n) -&gt; QtCore.QRect | QtCore.QRectF | QtCore.QPoint | QtCore.QPointF:\n\"\"\"Map a point or rect from a widget, global position or parent.\"\"\"\nmatch pos_or_rect:\ncase int(), int():\npos_or_rect = QtCore.QPoint(*pos_or_rect)\ncase float(), float():\npos_or_rect = QtCore.QPointF(*pos_or_rect)\ncase int(), int(), int(), int():\npos_or_rect = QtCore.QRect(*pos_or_rect)\ncase float(), float(), float(), float():\npos_or_rect = QtCore.QRectF(*pos_or_rect)\nmatch pos_or_rect, widget:\ncase QtCore.QRect() | QtCore.QRectF(), QtWidgets.QWidget():\ntop_left = super().mapFrom(widget, pos_or_rect.topLeft())\nbottom_right = super().mapFrom(widget, pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), QtWidgets.QWidget():\nreturn super().mapFrom(widget, pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"parent\":\ntop_left = super().mapFromParent(pos_or_rect.topLeft())\nbottom_right = super().mapFromParent(pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"parent\":\nreturn super().mapFromParent(pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"window\":\ntop_left = super().mapFrom(self.window(), pos_or_rect.topLeft())\nbottom_right = super().mapFrom(self.window(), pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"window\":\nreturn super().mapFrom(self.window(), pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"global\":\ntop_left = super().mapFromGlobal(pos_or_rect.topLeft())\nbottom_right = super().mapFromGlobal(pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"global\":\nreturn super().mapFromGlobal(pos_or_rect)\ncase _:\nraise ValueError(pos_or_rect)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.map_to","title":"<code>map_to(widget: QtWidgets.QWidget | Literal['global', 'parent', 'window'], pos_or_rect: QtWidgets.QWidget | Literal['global', 'parent', 'window']) -&gt; QtCore.QRect | QtCore.QRectF | QtCore.QPoint | QtCore.QPointF</code>","text":"<p>Map a point or rect to a widget, global position or parent.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def map_to(\nself,\nwidget: QtWidgets.QWidget | Literal[\"global\", \"parent\", \"window\"],\npos_or_rect,\n) -&gt; QtCore.QRect | QtCore.QRectF | QtCore.QPoint | QtCore.QPointF:\n\"\"\"Map a point or rect to a widget, global position or parent.\"\"\"\nmatch pos_or_rect:\ncase int(), int():\npos_or_rect = QtCore.QPoint(*pos_or_rect)\ncase float(), float():\npos_or_rect = QtCore.QPointF(*pos_or_rect)\ncase int(), int(), int(), int():\npos_or_rect = QtCore.QRect(*pos_or_rect)\ncase float(), float(), float(), float():\npos_or_rect = QtCore.QRectF(*pos_or_rect)\nmatch pos_or_rect, widget:\ncase QtCore.QRect() | QtCore.QRectF(), QtWidgets.QWidget():\ntop_left = super().mapTo(widget, pos_or_rect.topLeft())\nbottom_right = super().mapTo(widget, pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), QtWidgets.QWidget():\nreturn super().mapTo(widget, pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"parent\":\ntop_left = super().mapToParent(pos_or_rect.topLeft())\nbottom_right = super().mapToParent(pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"parent\":\nreturn super().mapToParent(pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"window\":\ntop_left = super().mapTo(self.window(), pos_or_rect.topLeft())\nbottom_right = super().mapTo(self.window(), pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"window\":\nreturn super().mapTo(self.window(), pos_or_rect)\ncase QtCore.QRect() | QtCore.QRectF(), \"global\":\ntop_left = super().mapToGlobal(pos_or_rect.topLeft())\nbottom_right = super().mapToGlobal(pos_or_rect.bottomRight())\nreturn type(pos_or_rect)(top_left, bottom_right)\ncase QtCore.QPoint() | QtCore.QPointF(), \"global\":\nreturn super().mapToGlobal(pos_or_rect)\ncase _:\nraise ValueError(pos_or_rect)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.position_on","title":"<code>position_on(where: PositionPossibilityType, how: Literal['center', 'top', 'left', 'bottom', 'right', 'top_left', 'top_right', 'bottom_left', 'bottom_right'] = 'center', scale_ratio: int | None = None, x_offset: int = 0, y_offset: int = 0)</code>","text":"<p>Position widget on another widget / window / screen.</p> <p>Parameters:</p> Name Type Description Default <code>where</code> <code>PositionPossibilityType</code> <p>where to positin on</p> required <code>how</code> <code>Literal['center', 'top', 'left', 'bottom', 'right', 'top_left', 'top_right', 'bottom_left', 'bottom_right']</code> <p>How to align</p> <code>'center'</code> <code>scale_ratio</code> <code>int | None</code> <p>Resize to scale_ratio * target size</p> <code>None</code> <code>x_offset</code> <code>int</code> <p>additional x offset for final position</p> <code>0</code> <code>y_offset</code> <code>int</code> <p>additional y offset for final position</p> <code>0</code> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def position_on(\nself,\nwhere: PositionPossibilityType,\nhow: Literal[\n\"center\",\n\"top\",\n\"left\",\n\"bottom\",\n\"right\",\n\"top_left\",\n\"top_right\",\n\"bottom_left\",\n\"bottom_right\",\n] = \"center\",\nscale_ratio: int | None = None,\nx_offset: int = 0,\ny_offset: int = 0,\n):\n\"\"\"Position widget on another widget / window / screen.\n    Arguments:\n        where: where to positin on\n        how: How to align\n        scale_ratio: Resize to scale_ratio * target size\n        x_offset: additional x offset for final position\n        y_offset: additional y offset for final position\n    \"\"\"\ndo_scale = True\nmatch where:\ncase \"mouse\":\ngeom = core.Rect(gui.Cursor.pos(), gui.Cursor.pos())\ndo_scale = False\ncase QtCore.QPoint():\ngeom = core.Rect(where, where)\ndo_scale = False\ncase (int(), int()):\np = core.Point(*where)\ngeom = core.Rect(p, p)\ndo_scale = False\ncase (int(), int(), int(), int()):\ngeom = core.Rect(*where)\ncase \"parent\":\ngeom = self.parent().frameGeometry()\ncase \"window\":\ngeom = self.window().frameGeometry()\ncase QtWidgets.QWidget():\ngeom = where.frameGeometry()\ncase QtCore.QRect():\ngeom = where\ncase \"screen\":\ngeom = gui.GuiApplication.primaryScreen().geometry()\ncase _:\nraise ValueError(where)\nif scale_ratio is not None and do_scale:\nself.resize(\nint(geom.width() * scale_ratio),\nint(geom.height() * scale_ratio),\n)\nown_geo = self.frameGeometry()\nmatch how:\ncase \"center\":\nnew = geom.center()\ncase \"top\":\nnew = core.Point(geom.center().x(), geom.top() + own_geo.height() // 2)\ncase \"bottom\":\nnew = core.Point(geom.center().x(), geom.bottom() - own_geo.height() // 2)\ncase \"left\":\nnew = core.Point(geom.left() + own_geo.width() // 2, geom.center().y())\ncase \"right\":\nnew = core.Point(geom.right() - own_geo.width() // 2, geom.center().y())\ncase \"top_right\":\nnew = core.Point(\ngeom.right() - own_geo.width() // 2,\ngeom.top() + own_geo.height() // 2,\n)\ncase \"top_left\":\nnew = core.Point(\ngeom.left() + own_geo.width() // 2,\ngeom.top() + own_geo.height() // 2,\n)\ncase \"bottom_right\":\nnew = core.Point(\ngeom.right() - own_geo.width() // 2,\ngeom.bottom() - own_geo.height() // 2,\n)\ncase \"bottom_left\":\nnew = core.Point(\ngeom.left() + own_geo.width() // 2,\ngeom.bottom() - own_geo.height() // 2,\n)\ncase _:\nraise ValueError(how)\nnew = core.Point(new.x() + x_offset, new.y() + y_offset)\nown_geo.moveCenter(new)\nself.move(own_geo.topLeft())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.raise_to_top","title":"<code>raise_to_top()</code>","text":"<p>Brings a widget to top with all means available.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def raise_to_top(self):\n\"\"\"Brings a widget to top with all means available.\"\"\"\nif sys.platform.startswith(\"win\"):\nfrom prettyqt.utils.platforms.windows import misc\nmisc.raise_to_top()\n# state = (self.windowState() &amp; ~Qt.WindowMinimized) | Qt.WindowActive\n# self.setWindowState(state)\nself.raise_()\nself.show()\nself.activateWindow()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_background_role","title":"<code>set_background_role(role: gui.palette.RoleStr | gui.Palette.ColorRole)</code>","text":"<p>Get foreground role for this widget.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_background_role(self, role: gui.palette.RoleStr | gui.Palette.ColorRole):\n\"\"\"Get foreground role for this widget.\"\"\"\nself.setBackgroundRole(gui.palette.ROLE.get_enum_value(role))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_context_menu_policy","title":"<code>set_context_menu_policy(policy: constants.ContextPolicyStr | constants.ContextMenuPolicy)</code>","text":"<p>Set contextmenu policy for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>constants.ContextPolicyStr | constants.ContextMenuPolicy</code> <p>contextmenu policy to use</p> required Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_context_menu_policy(\nself, policy: constants.ContextPolicyStr | constants.ContextMenuPolicy\n):\n\"\"\"Set contextmenu policy for given item view.\n    Args:\n        policy: contextmenu policy to use\n    \"\"\"\nself.setContextMenuPolicy(constants.CONTEXT_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_focus_policy","title":"<code>set_focus_policy(policy: constants.FocusPolicyStr | constants.FocusPolicy)</code>","text":"<p>Set the way the widget accepts keyboard focus.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>str</code> <p>Focus policy</p> required Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_focus_policy(self, policy: constants.FocusPolicyStr | constants.FocusPolicy):\n\"\"\"Set the way the widget accepts keyboard focus.\n    Args:\n        policy (str): Focus policy\n    \"\"\"\nself.setFocusPolicy(constants.FOCUS_POLICY.get_enum_value(policy))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_font","title":"<code>set_font(font_name: QtGui.QFont | str | None = None, font_size: int | None = None, weight: int | None = None, italic: bool = False) -&gt; QtGui.QFont</code>","text":"<p>Set the font for this widget.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_font(\nself,\nfont_name: QtGui.QFont | str | None = None,\nfont_size: int | None = None,\nweight: int | None = None,\nitalic: bool = False,\n) -&gt; QtGui.QFont:\n\"\"\"Set the font for this widget.\"\"\"\nif isinstance(font_name, QtGui.QFont):\nsuper().setFont(font_name)\nreturn font_name\nif font_size is None:\nfont_size = -1\nif weight is None:\nweight = -1\nif font_name is None:\nfont_name = self.font().family()\nfont = gui.Font(font_name, font_size, weight, italic)\nsuper().setFont(font)\nreturn font\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_foreground_role","title":"<code>set_foreground_role(role: gui.palette.RoleStr | gui.Palette.ColorRole)</code>","text":"<p>Set foreground role for this widget.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_foreground_role(self, role: gui.palette.RoleStr | gui.Palette.ColorRole):\n\"\"\"Set foreground role for this widget.\"\"\"\nself.setForegroundRole(gui.palette.ROLE.get_enum_value(role))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the window icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the window icon.\n    Args:\n        icon: icon to use\n    \"\"\"\nicon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\nsuper().setWindowIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_layout","title":"<code>set_layout(layout: LayoutStr | QtWidgets.QLayout, margin: int | None = None, **kwargs: int | None) -&gt; QtWidgets.QLayout</code>","text":"<p>Quick way to set a layout.</p> <p>Sets layout to given layout, also allows setting margin and spacing.</p> <p>Parameters:</p> Name Type Description Default <code>layout</code> <code>LayoutStr | QtWidgets.QLayout</code> <p>Layout to set</p> required <code>margin</code> <code>int | None</code> <p>margin to use in pixels</p> <code>None</code> <code>kwargs</code> <p>keyword arguments passed to layout</p> <code>{}</code> <p>Returns:</p> Type Description <code>QtWidgets.QLayout</code> <p>Layout</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_layout(\nself,\nlayout: LayoutStr | QtWidgets.QLayout,\nmargin: int | None = None,\n**kwargs,\n) -&gt; QtWidgets.QLayout:\n\"\"\"Quick way to set a layout.\n    Sets layout to given layout, also allows setting margin and spacing.\n    Args:\n        layout: Layout to set\n        margin: margin to use in pixels\n        kwargs: keyword arguments passed to layout\n    Returns:\n        Layout\n    \"\"\"\nfrom prettyqt import custom_widgets\nmatch layout:\ncase \"horizontal\":\nlayout = widgets.HBoxLayout(**kwargs)\ncase \"vertical\":\nlayout = widgets.VBoxLayout(**kwargs)\ncase \"grid\":\nlayout = widgets.GridLayout(**kwargs)\ncase \"form\":\nlayout = widgets.FormLayout(**kwargs)\ncase \"stacked\":\nlayout = widgets.StackedLayout(**kwargs)\ncase \"flow\":\nlayout = custom_widgets.FlowLayout(**kwargs)\ncase \"border\":\nlayout = custom_widgets.BorderLayout(**kwargs)\ncase QtWidgets.QLayout():\nlayout = layout\ncase _:\nraise ValueError(f\"Invalid Layout {layout}\")\nself.setLayout(layout)\nif margin is not None:\nlayout.set_margin(margin)\nreturn layout\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_modality","title":"<code>set_modality(modality: constants.WindowModalityStr | constants.WindowModality)</code>","text":"<p>Set modality for the dialog.</p> <p>Parameters:</p> Name Type Description Default <code>modality</code> <code>constants.WindowModalityStr | constants.WindowModality</code> <p>modality for the main window</p> required Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_modality(\nself, modality: constants.WindowModalityStr | constants.WindowModality\n):\n\"\"\"Set modality for the dialog.\n    Args:\n        modality: modality for the main window\n    \"\"\"\nself.setWindowModality(constants.WINDOW_MODALITY.get_enum_value(modality))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_size_policy","title":"<code>set_size_policy(horizontal: widgets.sizepolicy.SizePolicyStr | widgets.QSizePolicy.Policy | None = None, vertical: widgets.sizepolicy.SizePolicyStr | widgets.QSizePolicy.Policy | None = None)</code>","text":"<p>Set the size policy.</p> <p>Parameters:</p> Name Type Description Default <code>horizontal</code> <code>widgets.sizepolicy.SizePolicyStr | widgets.QSizePolicy.Policy | None</code> <p>horizontal size policy</p> <code>None</code> <code>vertical</code> <code>widgets.sizepolicy.SizePolicyStr | widgets.QSizePolicy.Policy | None</code> <p>vertical size policy</p> <code>None</code> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_size_policy(\nself,\nhorizontal: widgets.sizepolicy.SizePolicyStr\n| widgets.QSizePolicy.Policy\n| None = None,\nvertical: widgets.sizepolicy.SizePolicyStr\n| widgets.QSizePolicy.Policy\n| None = None,\n):\n\"\"\"Set the size policy.\n    Args:\n        horizontal: horizontal size policy\n        vertical: vertical size policy\n    \"\"\"\nsp = self.get_size_policy()\nif horizontal is not None:\nsp.set_horizontal_policy(horizontal)\nif vertical is not None:\nsp.set_vertical_policy(vertical)\nself.setSizePolicy(sp)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_tooltip","title":"<code>set_tooltip(tooltip: str | datatypes.PathType, size: datatypes.SizeType | None = None, rich_text: bool = False)</code>","text":"<p>Set a tooltip for this widget.</p> <p>In image can get displayed by passing a PathLike object.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_tooltip(\nself,\ntooltip: str | datatypes.PathType,\nsize: datatypes.SizeType | None = None,\nrich_text: bool = False,\n):\n\"\"\"Set a tooltip for this widget.\n    In image can get displayed by passing a PathLike object.\n    \"\"\"\nif isinstance(tooltip, os.PathLike):\npath = os.fspath(tooltip)\nif size is None:\ntooltip = f\"&lt;img src={path!r}&gt;\"\nelse:\nif isinstance(size, QtCore.QSize):\nsize = (size.width(), size.height())\ntooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\ntooltip = tooltip.replace(\"\\n\", \"&lt;br/&gt;\")\nif rich_text:\ntooltip = f\"&lt;html&gt;{html.escape(tooltip)}&lt;/html&gt;\"\nsuper().setToolTip(tooltip)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_window_state","title":"<code>set_window_state(state: constants.WindowStateStr | constants.WindowState)</code>","text":"<p>Set window state for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.WindowStateStr | constants.WindowState</code> <p>window state to use</p> required Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_window_state(self, state: constants.WindowStateStr | constants.WindowState):\n\"\"\"Set window state for given item view.\n    Args:\n        state: window state to use\n    \"\"\"\nself.setWindowState(constants.WINDOW_STATES.get_enum_value(state))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.show_tooltip","title":"<code>show_tooltip(duration: int | None = None)</code>","text":"<p>Show the tooltip of this widget for given time.</p> <p>When no duration is given, it will get calculated based on length.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def show_tooltip(self, duration: int | None = None):\n\"\"\"Show the tooltip of this widget for given time.\n    When no duration is given, it will get calculated based on length.\n    \"\"\"\nif duration is None:\nduration = -1  # automatic\npos = self.map_to(\"global\", (0, 0))\nwidgets.ToolTip.showText(pos, self.toolTip(), msecShowTime=duration)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.toggle_fullscreen","title":"<code>toggle_fullscreen() -&gt; bool</code>","text":"<p>Toggle between fullscreen and regular size.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def toggle_fullscreen(self) -&gt; bool:\n\"\"\"Toggle between fullscreen and regular size.\"\"\"\nif self.isFullScreen():\nself.showNormal()\nreturn False\nelse:\nself.showFullScreen()\nreturn True\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.toggle_maximized","title":"<code>toggle_maximized() -&gt; bool</code>","text":"<p>Toggle between maximized and regular size.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def toggle_maximized(self) -&gt; bool:\n\"\"\"Toggle between maximized and regular size.\"\"\"\nif self.isMaximized():\nself.showNormal()\nreturn False\nelse:\nself.showMaximized()\nreturn True\n</code></pre>"},{"location":"features/animating.html","title":"Animating","text":"<p>PrettyQt makes it easy to animate your widgets. All animation-related methods are available via the Widget.fx attribute. Easy one-liners to bring</p>"},{"location":"features/animating.html#some-examples","title":"some Examples:","text":"<pre><code># a lot of animations depend on current geometry.\n# It\u00b4s advisable to show widget first so that it gets layouted.\nwidget = widget.Label(\"I will get animated.\")\nwidget.show()\n\n# start a general fade animation with fixed start/end\nwidget.fx[\"windowOpacity\"].animate(start=0, end=1, duration=1000)\n\n# Transition widget size from current value to (500, 500)\nwidget.fx[\"size\"].transition_to((500, 500), duration=1000)\n\n# Transition widget size from current value to (500, 500)\nwidget.fx[\"pos\"].transition_from((0, -100), duration=1000)\n\n# fade-in when widget gets clicked\nwidget.fx[\"windowOpacity\"].animate_on_event(\"mouse_button_press\", start=0, end=1)\n\n# convenience method for mentioned fade-in\nwidget.fx.fade_in(start=0, end=1, start=500)\n\n# start a zoom animation\nwidget.fx.zoom(start=1, end=1.5, duration=400)\n\n# start a slide animation 100px to the right\nwidget.fx.slide(start=(0, 0), end=(100, 0), duration=400)\n</code></pre> <p>Animating stylesheet values is also possible easily:</p> <p>TODO.</p>"},{"location":"features/delegates.html","title":"Delegates","text":"<p>Several additional delegates are supplied by PrettyQt. - HtmlItemDelegate (supports HTML for text) - IconDelegate - NoFocusDelegate (hides focus frame) - ProgressBarDelegate (displays a percentage value as a progress bar) - RadioDelegate - RenderLinkDelegate (renders a string as link and makes it clickable) - StarDelegate () - VariantDelegate (regular delegate supporting many data types) - WidgetDelegate (experimental)</p> <p>The main one is \"VariantDelegate\", which basically works like the default delegate, but supports editing a larger amount of datatypes.</p> <p>The following data types are supported:</p> <ul> <li>bool</li> <li>enum.Flag</li> <li>enum.Enum</li> <li>int</li> <li>float</li> <li>str</li> <li>range</li> <li>slice</li> <li>list of ints</li> <li>list of floats</li> <li>list of strings</li> <li>pathlib.Path</li> <li>re.Pattern</li> <li>datetime.date</li> <li>datetime.time</li> <li>datetime.datetime</li> <li>QtCore.QRegularExpression</li> <li>QtCore.QTime</li> <li>QtCore.QDate</li> <li>QtCore.QDateTime</li> <li>QtCore.QPoint</li> <li>QtCore.QPointF</li> <li>QtCore.QRect</li> <li>QtCore.QRectF</li> <li>QtCore.QRection</li> <li>QtCore.QKeyCombination</li> <li>QtCore.QLocale</li> <li>QtCore.QSize</li> <li>QtCore.QSizeF</li> <li>QtCore.QUrl</li> <li>QtGui.QFont</li> <li>QtGui.QKeySequence</li> <li>QtGui.QPalette</li> <li>QtGui.QColor</li> <li>QtGui.QCursor</li> <li>QtGui.QIcon</li> <li>QtWidgets.QSizePolicy</li> </ul> <p>If numpy is installed, the following types are supported, too:</p> <ul> <li>numpy.floating</li> <li>numpy.integer</li> <li>numpy.str_</li> <li>numpy.datetime64</li> <li>numpy.bool_</li> </ul>"},{"location":"features/layouts.html","title":"Layouts","text":""},{"location":"features/layouts.html#models-for-python-types","title":"Models for Python types","text":""},{"location":"features/layouts.html#context-manager-to-build-layouts","title":"Context manager to build layouts","text":"<pre><code>from prettyqt import widgets\n\nwidget = widgets.Widget()\nlayout = widget.set_layout(\"horizontal\")\nwith layout.get_sub_layout(\"splitter\", orientation=\"horizontal\") as layout:\n    with layout.get_sub_layout(\"flow\") as layout:\n        layout += widgets.PushButton(\"Flow 1\")\n        layout += widgets.RadioButton(\"Flow 2\")\n        layout += widgets.PushButton(\"Flow 3\")\n        layout += widgets.RadioButton(\"Flow 4\")\n    layout += widgets.PlainTextEdit(\"Splitter middle\")\n    layout += widgets.PlainTextEdit(\"Splitter right\")\n    with layout.get_sub_layout(\"splitter\", orientation=\"vertical\") as layout:\n        layout += widgets.PlainTextEdit(\"Splitter top\")\n        layout += widgets.PlainTextEdit(\"Splitter middle\")\n        with layout.get_sub_layout(\"scroll\", orientation=\"vertical\") as layout:\n            layout += widgets.PlainTextEdit(\"ScrollArea top\")\n            layout += widgets.PlainTextEdit(\"ScrollArea middle\")\n            button = layout.add(widgets.PushButton(\"ScrollArea Bottom\"))\nwith layout.get_sub_layout(\"horizontal\") as layout:\n    layout += widgets.PlainTextEdit(\"HorizontalLayout left\")\n    layout += widgets.PlainTextEdit(\"HorizontalLayout right\")\n    with layout.get_sub_layout(\"grid\") as layout:\n        layout[0, 0] = widgets.PushButton(\"Grid topleft\")\n        layout[0, 1] = widgets.RadioButton(\"Grid topright\")\n        layout[1, 0:1] = widgets.PushButton(\"Grid bottom\")\n        layout += widgets.RadioButton(\"Flow 4\")\n</code></pre>"},{"location":"features/layouts.html#setting-a-layout","title":"Setting a layout","text":"<p>Layouts can be also be set by an identifier:</p> <pre><code>layout = widget.set_layout(\"horizontal\")\n# equals\nlayout = widgets.HBoxLayout()\nwidget.set_layout(layout)\n</code></pre> <p>Available layouts:</p> <ul> <li> <p>Qt layouts:</p> <ul> <li>\"horizontal\"</li> <li>\"vertical\"</li> <li>\"grid\"</li> <li>\"form\"</li> <li>\"stacked\"</li> </ul> </li> <li> <p>custom layouts:</p> <ul> <li>\"multiline\"</li> <li>\"border\"</li> <li>\"flow\"</li> </ul> </li> </ul>"},{"location":"features/layouts.html#accessing-widgets-inside-a-layout","title":"Accessing widgets inside a layout","text":"<p>All layouts support slicing, including the possibility to apply batch operations:</p> <pre><code>widgets = layout[:4]  # take the first 4 widgets\nwidgets = layout[::2] # take every second widget\n\nwidgets[2:8:2].set_visible(False)  # hide widgets with index 2, 4, 6, 8\nsizes = widgets[5:].size()  # returns a list with the sizes of widget with index 5 and following.\n</code></pre> <p>As shown, operations on slices are forwarded to each slice member. No need to loop over the whole layout.</p> <p>The same principles also apply to splitters, toolboxes and tabwidgets.</p> <pre><code>splitter[2:5].set_font(\"Consolas\")\n</code></pre>"},{"location":"features/models.html","title":"Models","text":"<p>PrettyQt includes a range of models for Qt-based types, Python built-in types as well as some models for data structures of external libraries.</p>"},{"location":"features/models.html#models-for-following-python-types-are-included","title":"Models for following Python types are included:","text":"<p><code>list[dict]</code></p> <code>type</code>: Subclass tree, ParentClass tree) <code>importlib.metadata.distribution</code>: Tree model showing a dependency tree of given package <code>inspect.Traceback / inspect.FrameInfo</code>: Stack table <code>DataClass | Sequence[DataClass]</code>: 2 models: Sequence[dataclass] and dataclass) <code>ast.AST</code>: Tree model to show an abstract syntax tree <code>list[logging.LogRecord]</code> Table containing log information <code>list[re.Match]</code> Table do display list of regex matches <code>object</code> Tree model showing all attributes of an object. <code>xml.etree.ElementTree -&gt; custom_models.XmlModel</code> Tree view for an xml ElementTree"},{"location":"features/models.html#models-for-following-qt-types-are-included","title":"Models for following Qt types are included:","text":"<code>list[QtGui.QAction] -&gt; custom_models.ActionsModel</code> Table displaying all available info for a QAction. Supports editing QAction properties. <code>list[QtGui.QShortcut] -&gt; custom_models.ShortcutsModel</code> Table displaying a list of shortcuts. Supports editing Shortcut properties. <code>list[QtCore.QStorageInfo] -&gt; custom_models.StorageInfoModel</code> Read-only list of available drives <code>list[QtWidgets.QWidget]</code> Table displaying a list of QWidgets and their properties <p><code>list[QtCore.QModelIndex] -&gt; custom_models.ModelIndexModel</code></p> <code>QtCore.QObject -&gt;</code> Table model to display all available Properties of a QObject. Works by inspecting the MetaObject of the QObjects."},{"location":"features/models.html#models-for-following-external-libraries-are-included","title":"Models for following external libraries are included:","text":"<code>AttrsDataclass</code> Detail table containing all relevant information for each Attrs dataclass. If not frozen, values can be edited. <code>list[AttrsDataclass]</code> comparison view for a list of Pydantic models. Columns get automatically inferred based on most recent ancestor. If not frozen, values can be edited. <code>pydantic.BaseModel</code> Detail table containing all relevant information for each BaseModel field. If not frozen, values can be edited. <code>list[pydantic.BaseModel]</code> comparison view for a list of Pydantic models. Columns get automatically inferred based on most recent ancestor. If not frozen, values can be edited. <code>fsspec.FileSystem</code> Model with same interface as QFileSystemModel Can basically act as drop:in replacement Easy access to dropbox and all supported fsspec filesystems. <code>pd.DataFrame</code> Model to show complete table Model to show column categories Model for a detailed ColumnView <p>Scikit-learn</p>"},{"location":"features/pandas.html","title":"Pandas","text":"<p>Pandas is a very popular python library for working with tabular data.</p> <p>PrettyQt contains a range of tools to work with pandas data structures.</p>"},{"location":"features/pandas.html#models","title":"Models","text":"<p>PrettyQt includes multiple models to display Pandas dataframes. One of the key \"issues\" is that in contrast to QAbstractTableModels, a pandas DataFrame can have MultiIndexes. PrettyQt offers several approaches to display these MultiIndexes.</p> <p>DataTableWithHeaderModel is a very simple model which is displaying MultiIndexes by joining the multiple index levels using a separator. (the separator value is exposed as a Qt Property)</p> <p>In addition, two composed widgets are included which consist of three different tables (one for data, one for the index, one for the headers) which are synced on scrolling / resizing.</p> <p>There is also a model to get a detailed view on an index and another one to display the categories of a pandas category column.</p>"},{"location":"features/pandas.html#proxies","title":"Proxies","text":"<p>Since working with pandas often means working with tables containing several hundred thousands of rows, the default QSortFilterProxyModel does not work that well.</p> <p>PrettyQt includes several proxy models which try to improve this.</p> <p>PandasStringColumnFilterProxyModel can be used to filter a column based on a search string. Instead of looping over the cells, a filter index is built using NumPy operations. This makes filtering super fast, even with several thousands of rows. A quick benchmark showed an almost 100x (!!) performance increase compared to QSortFilterProxyModel.</p> <p>PandasEvalFilterProxyModel works in a similar way, but filtering is done by a Python statement. (example: '\"a\" &gt; 10' would show all rows where the value of column \"a\" is greater than 10.)</p> <p>To display heatmaps, PrettyQt also includes a proxy model to color the cells according to their values. That proxy model includes several modes, also including modes which dont need to pre-compute min-max values,</p>"},{"location":"features/pandas.html#eventfilters","title":"EventFilters","text":"<p>To prettify the mentioned composed widgets, an EventFilter is included which sets row / column spans on-the-fly.</p>"},{"location":"features/pandas.html#scikit-learn","title":"Scikit-learn","text":"<p>Lastly, there are also models included to display Scikit-Learn estimators and their characteristics.</p>"},{"location":"features/proxies.html","title":"proxies","text":""},{"location":"features/proxies.html#proxy-models","title":"Proxy Models","text":"<p>Every class containing the AbstractItemViewMixin (widgets.TreeView, widgets.TableView, ...) has quick access to proxy superpowers hidden behind the \"proxifier\" attribute. The following section will give an overview about the included proxies and how to apply them.</p>"},{"location":"features/proxies.html#slice-proxies","title":"Slice proxies","text":"<p>PrettyQt introduces a base proxy model which allows its subclasses to be selectively applied to the source model by using python slicing syntax. They can get quickly set up via our proxifier.</p> <p>Example:</p> <pre><code>    model = MyTableModel()\ntable = widgets.TableView()\ntable.set_model(model)\n# lets change the appearance a bit.\n# Set the font color of column 2 and 3 to red and font to Courier.\ntable.proxifier[2:4, :].style(foreground=\"red\", font=\"Courier\")\n# Cut off last column and only show last 50 lines.\ntable.proxifier[:-1, :50].filter()\n# Set first 20 lines of these 50 lines to read_only\ntable.proxifier[:, :20].change_flags(editable=False)\n# Make first column checkable and trigger callback on checkstate change.\ntable.proxifier[0, :].make_checkable(callback=my_callback)\n</code></pre> <p>Every call here basically adds another ProxyModel layer (all based on SliceIdentityProxyModel). The proxy models should all perform very well with large tables since they never need to loop over the whole column / row range.</p> <p>The proxifier attribute basically gives quick access to set up these proxies.</p> <p><pre><code>    table.proxifier[:-1, 5::2].filter()\n</code></pre> basically equals something like:</p> <pre><code>    proxy = SliceFilterProxyModel(indexer=(slice(None, -1, 1), slice(5, None, 2)))\nproxy.setSourceModel(table.model())\ntable.set_model(proxy)\n</code></pre> <p>If you want to apply a slice proxy to the whole model, use slices without start and stop values:</p> <pre><code>    table.proxifier[:, :].style(background=\"green\")\n</code></pre> <p>Here is a short overview of the included slice proxies:</p> <code>SliceAppearanceProxyModel</code> Applies styling to given slice by overriding font, color and alignment roles. <code>SliceChangeFlagsProxyModel</code> Selectively change the result of the model.flags method. (Example: Change the IsEditable Flag to make an area read-only) <code>SliceChangeIconSizeProxymodel</code> Allows to change the size of the Icon / Pixmap shown for DecorationRole. Changed icons / pixmaps are cached for performance reasons. <code>SliceChangeIconSizeProxymodel</code> Allows to change the size of the Icon / Pixmap shown for DecorationRole. Changed icons / pixmaps are cached for performance reasons. <code>SliceCheckableProxyModel</code> Makes an area of the table / tree checkable and triggers a callback on checkstate change.   With keyword argument \"tree=True\", this model also works with trees and propagates changes to its children and parents   to show the correct tristate. <code>SliceColorValuesProxyModel</code> Color an area with numerical values based on their value (Example: high numbers red, low numbers green). To color cells, this proxy needs a minimum and maximum value. Three modes are available: Let the user choose a min max value. Use min max value from currently visible table section. use min max value from \"seen\" table content. (meaning that the model adapts min max values based.) The last two modes have the advantage that nothing needs to be computed in advance, min/max values are calculated on-the fly. <code>SliceFilterProxyModel</code> Show only selected slice of given source model. <code>SliceValueTransformationProxyModel</code> Changes the values of any data role of given slice area based on a callback."},{"location":"features/proxies.html#sortfilter-proxies","title":"Sort/Filter proxies.","text":"<p>In addition to the mentioned SliceFilterProxyModel, PrettyQt also contains several proxies based on QSortFilterProxyModel. These can be more powerful than the mentioned SliceFilterProxyModel, but scale with O(1) in respect to row / column count. (meaning that things might get slower for very large tables or when several proxies are layered on top of each other.) Some of these proxies might partly overlap in functionality, but theres always a best one one for each use case to pick.</p> <code>FuzzyFilterProxyModel</code> Model to make implementing CommandPalettes a la SubimeText or VS Code super easy. A FilterProxyModel which sorts the results based on a matching score. Best matches are shown at the top. Exposes matching score via a custom UserRole if desired. Can also color the found Substring by converting the display role to an HTML representation when combined with our \"HtmlItemDelegate\", which allows to display HTML in ItemView cells. <code>ValueFilterProxymodel</code> like the original QSortFilterProxyModel, but also works with non-str values. can be used for example to filter by checkstate role, or by any custom data behind any UserRole. The properties filterKeyColumn and filterRole of the base proxy model are taken into account. <code>SubsetFilterProxyModel</code> Can filter rows / columns based on slices, index, a filter function, a list of indexes (like columns [0, 3, 7]) <p>Note</p> <p>If you only need filtering based on slices or a single column / row, the SliceFilterProxymodel should be preferred for performance reasons.</p> <code>PredicateFilterProxyModel</code> The properties filterKeyColumn and filterRole of the base proxy model are taken into account. <code>RangeFilterProxyModel</code> can filter a table based on min/max values of a numerical column. The properties filterKeyColumn and filterRole of the base proxy model are taken into account. <code>MulticolumnFilterProxyModel</code>: can take a seperate search term / value for each column, thus avoiding to layer proxy models in case you want to filter based on several columns. That way it is less demanding since filtering for all columns is done in one go. Used by FilterHeader widget."},{"location":"features/proxies.html#reshape-proxies","title":"Reshape proxies","text":"<code>TableToListProxyModel</code>: Stack all columns into one single column To stack row-wise, use a TransposeProxyModel first. <code>FlattenedTreeProxyModel</code>: Moves all rows up to the root level. Label can be changed to show the complete path. <code>MeltProxyModel</code>: Unpivot a Table from wide to long format. same as pandas.melt, just without pandas. <code>ColumnOrderProxyModel</code>: Reorder columns based on a given list containing the column positions."},{"location":"features/proxies.html#other-proxies","title":"Other Proxies","text":"<p><code>HighlightMouseProxymodel</code></p>"},{"location":"features/proxies.html#tools","title":"Tools","text":"<p><code>ProxyMapper</code></p> <p>When having a complex proxy tree like:</p> <pre><code>classDiagram\n  Shared_proxy &lt;|-- Proxy_1_1\n  Shared_proxy &lt;|-- Proxy_2_1\n  Proxy_1_1 &lt;|-- Proxy_1_2\n  Proxy_2_1 &lt;|-- Proxy_2_2\n  Root_model &lt;-- Shared_proxy\n  class Proxy_1_1{\n  }\n  class Proxy_2_1{\n  }\n  class Root_model{\n  }</code></pre> <p>then the ProxyMapper can be used to map indexes and ItemSelections easily between any of the proxies.</p> <pre><code>    mapper = ProxyMapper(proxy_1_2, proxy_2_1)\nindex = proxy_1_2.index(0, 0)\nmapped_index = mapper.map_index_from_one_to_two(index)\n</code></pre> <p>The mapper will find the closest parent (\"shared_proxy\" here), use mapToSource / mapSelectionFromSource until it gets there, and then use mapFromSource / mapSelectionFromSource to get down to 2_1.</p>"},{"location":"features/validators.html","title":"Validators","text":"<p>PrettyQt includes a range of pre-defined validators.</p> <p>The following validators are included:</p> <p><code>AlphanumericValidator</code></p> <p><code>BlacklistValidator</code></p> <p><code>ColorValidator</code></p> <p><code>CompositeValidator</code></p> <p><code>HexValidator</code></p> <p><code>IntegerValidator</code></p> <p><code>JsonValidator</code></p> <p><code>MonotonicListValidator</code></p> <p><code>NotStrictValidator</code></p> <p><code>PathValidator</code> - allows strings which represent an existing path. Can be set to either accept files, folders or both.</p> <p><code>PythonCodeValidator</code> - allows a string which can be parsed by ast.parse</p> <p><code>QssValidator</code> - allows a string which can be parsed as CSS.</p> <p><code>RegexPatternValidator</code> - allows a string which can be parsed as a regular expression.</p> <p><code>IntListValidator</code> - allows a comma separated list of integers</p> <p><code>FloatListValidator</code> - allows a comma separated list of floats</p> <p><code>ScientificIntegerValidator</code>  - for integers in scientific annotation. also allows SI unit prefix like 'M', 'n' etc.</p> <p><code>ScientificFloatValidator</code>  - for floats in scientific annotation. also allows SI unit prefix like 'M', 'n' etc.</p> <p><code>TextLengthValidator</code> - allows limiting textlength to a given minimum / maximim</p> <p><code>WhitelistValidator</code> - whitelist specific strings</p> <p><code>FunctionValidator</code> - validate string based on a Callable (Signature: Callable[[str], bool])</p> <p>Apart from LineEdits, PlainTextEdits also gained the ability to take a validator.</p> <p>The set_validator method also gained a \"strict\" keyword argument, which wraps the passed validator into a NotStrictValidator, effectively removing the \"Invalid\" state. That way there never is a situation where the user input is ignored, which might be preferred in a lot of situations.</p> <p>The acceptance of \"\" may also be overriden explicitely by setting the \"allow_empty\" keyword argument.</p> <p>Validators which inherit from gui.Validator also can be combined.</p> <p>Example:     and_val = BlackListValidator([\"Blacklisted word\"]) &amp; AlphanumericValidator()  # returns an AndValidator     or_val = AlphanumericValidator() | RegularExpressionValidator(\"some_regex\") # returns an OrValidator</p> <p>Validators can also be set by an id. Since everything is typed with Literals, the possible ids should be shown by your IDE.</p> <pre><code>lineedit.set_validator(\"float\")\n</code></pre>"},{"location":"features/widgets.html","title":"Widgets","text":"<p>Since this library is huge, I will try to give an overview about some modules and mention some of the included \"highlights\".</p> <ul> <li>All setters and getters for Enum properties have an equivalent method taking a string:</li> </ul> <p>widget = QtWidgets.QWidget() widget.setSizeAdjustPolicy(widget.SizeAdjustPolicy.AdjustToContents)</p> <p>becomes:</p> <p>widgets = widgets.Widget() widget.set_size_adjust_policy(\"adjust_to_contents\")</p> <p>Everything is fully typed with Literals, so you should get a very nice IDE experience.</p> <p>The same also applies to getters, with the rule that everything is prefixed with \"get_\" in order to avoid name collisions.</p> <p>assert widget.sizeAdjustPolicy() == widget.SizeAdjustPolicy.AdjustToContents</p> <p>becomes</p> <p>assert widget.get_size_adjust_policy() == \"adjust_to_contents\"</p> <p>Note that these new setters and getters are \"optional\" to use. The \"old\" methods are still fully accessible. As a general rule, the library tries to be 100% \"backwards-compatible\".</p> <p>Slicing:</p> <p>A lot of QObjects fully support slicing via getitem. To allow easy batch manipulation, the returned list can delegate method calls to all of its members.</p>"},{"location":"features/widgets.html#some-examples","title":"Some Examples:","text":"<pre><code>model = AVeryNiceTableModel()\n\n# get indexes of first row:\nindexes = model[:, 0]\n\n# get indexes of very second column\nindexes = model[:, ::2]\n\n# batch operations:\n# return list containing data from UserRole for given slice.\ndata = model[2:5, 1:10:2].data(constants.USER_ROLE)\n\n# now we check out the same for widgets.\n# lets say we have a HBoxLayout containing many items.\n\nlayout = widgets.HBoxLayout()\n... # populate it with many widgets.\n\n# Only show first 5 widgets.\nlayout[5:].set_visible(False)\n\n# get a list containing the width of every 2nd widget in the layout.\nwidths = layout[::2].width()\n\n# trigger a fade-in animation for first 3 widgets\nlayout[:3].fx.fade_in(duration=1000)\n</code></pre> <p>Validators:</p> <p>PrettyQt ships a large number of predefined validators.</p> <pre><code># Validators can also be combined. The resulting CompositeValidator checks if all containing validators accept the input.\n\n# set_validator also gained a non-strict mode.\n# That way the \"lowest\" result of the validator becomes \"Intermediate\", since the Qt behaviour of ignoring keypresses when state goes to invalid might not be wanted.\n</code></pre>"}]}