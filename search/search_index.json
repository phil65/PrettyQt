{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"prettyqt: Pythonic layer on top of PyQt5 / PyQt6 / PySide6","text":""},{"location":"index.html#what-is-it","title":"What is it?","text":"<p>PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt6 / PySide6.</p>"},{"location":"index.html#main-features","title":"Main Features","text":"<p>Here are just a few of the things that PrettyQt does well:</p> <ul> <li>Large parts of the Qt API are available in a PEP-8-compliant way.</li> <li>Several predefined widgets, validators, models, syntax highlighters are included.</li> <li>A regex module based on QRegularExpression with the same API as Pythons core re module.</li> </ul>"},{"location":"index.html#where-to-get-it","title":"Where to get it","text":"<p>The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt</p> <p>The latest released version are available at the Python package index.</p> <pre><code># or PyPI\npip install prettyqt\n</code></pre>"},{"location":"index.html#dependencies","title":"Dependencies","text":"<ul> <li>bidict</li> <li>orjson</li> <li>regex</li> <li>docutils</li> </ul>"},{"location":"index.html#installation-from-sources","title":"Installation from sources","text":"<p>This project uses poetry for dependency management and packaging. Install this first. In the <code>prettyqt</code> directory (same one where you found this file after cloning the git repo), execute:</p> <pre><code>poetry install\n</code></pre>"},{"location":"index.html#license","title":"License","text":"<p>MIT</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/</p>"},{"location":"index.html#contributing-to-prettyqt","title":"Contributing to prettyqt","text":"<p>All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome.</p> <p>Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!</p>"},{"location":"changelog.html","title":"Changelog","text":""},{"location":"changelog.html#v1240-2023-04-26","title":"v1.24.0 (2023-04-26)","text":""},{"location":"changelog.html#feat","title":"Feat","text":"<ul> <li>Layout: add add_widget method</li> <li>Widget: allow None values for set_min/max_size</li> <li>TextStream: add get/set_number_flags methods</li> </ul>"},{"location":"changelog.html#v1230-2023-04-25","title":"v1.23.0 (2023-04-25)","text":""},{"location":"changelog.html#feat_1","title":"Feat","text":"<ul> <li>core: Add ModelRoleData class</li> <li>add ImportlibTreeModel</li> </ul>"},{"location":"changelog.html#fix","title":"Fix","text":"<ul> <li>correctly behaving listmixin</li> </ul>"},{"location":"changelog.html#v1222-2023-04-25","title":"v1.22.2 (2023-04-25)","text":""},{"location":"changelog.html#fix_1","title":"Fix","text":"<ul> <li>NestedModel: add default value for index kwargs</li> <li>correctly behaving RegexMatchesModel</li> </ul>"},{"location":"changelog.html#v1221-2023-04-25","title":"v1.22.1 (2023-04-25)","text":""},{"location":"changelog.html#fix_2","title":"Fix","text":"<ul> <li>NestedModel: rowCount fix</li> </ul>"},{"location":"changelog.html#v1220-2023-04-25","title":"v1.22.0 (2023-04-25)","text":""},{"location":"changelog.html#feat_2","title":"Feat","text":"<ul> <li>LayoutItem: add get_expanding_directions method</li> <li>LayoutItem: add get_control_types method</li> <li>GraphicsLayoutItem: add get/set_size_policy and bool methods</li> </ul>"},{"location":"changelog.html#fix_3","title":"Fix","text":"<ul> <li>Pixmap: fix create_char method</li> </ul>"},{"location":"changelog.html#v1210-2023-04-23","title":"v1.21.0 (2023-04-23)","text":""},{"location":"changelog.html#feat_3","title":"Feat","text":"<ul> <li>NetworkRequest: support some attributes from newer qt versions</li> <li>NetworkRequest: add set_attribute(s) method</li> <li>Object: add set_properties method</li> <li>MimeData: add for_file method</li> <li>TextDocument: add get_bytes method</li> <li>MetaMethod: add get_parameters/get_return_types methods</li> <li>MetaObject: add get_class_info method</li> <li>MetaObject: add get_super_class method</li> <li>UrlQuery: add getitem and setitem methods</li> <li>TextDocumentWriter: add serialize_document method</li> <li>Widget: add toggle_maximized method</li> </ul>"},{"location":"changelog.html#fix_4","title":"Fix","text":"<ul> <li>correct isinstance check for to_json</li> <li>TextDocumentWriter: fix serialization</li> <li>SingleApplication: TextStream.setCodec gone in qt6</li> </ul>"},{"location":"changelog.html#v1200-2023-04-22","title":"v1.20.0 (2023-04-22)","text":""},{"location":"changelog.html#feat_4","title":"Feat","text":"<ul> <li>add some methods for Thread/ThreadPool 81795</li> <li>Pixmap: get rid of flags param for from_image 8fbbf</li> <li>bluetooth: add BluetoothDeviceInfo class 80482</li> </ul>"},{"location":"changelog.html#fix_5","title":"Fix","text":"<ul> <li>BluetoothDeviceDiscoveryAgent: correctly set flags for start_discovery 4f53b</li> </ul>"},{"location":"changelog.html#v1190-2023-04-22","title":"v1.19.0 (2023-04-22)","text":""},{"location":"changelog.html#feat_5","title":"Feat","text":"<ul> <li>MenuBar: add get/set_corner_widget methods a9fc0</li> <li>PdfView: add set_file method c5b79</li> </ul>"},{"location":"changelog.html#v1180-2023-04-21","title":"v1.18.0 (2023-04-21)","text":""},{"location":"changelog.html#feat_6","title":"Feat","text":"<ul> <li>ScrollerMetrics: add get_scroll_metrics method + bit dict interface 838d6</li> <li>WebEngineSettings: more dict interface 903d7</li> <li>GuiApplication: add set_badge_number method 57e9b</li> </ul>"},{"location":"changelog.html#fix_6","title":"Fix","text":"<ul> <li>make sure to correctly set parent for actions added to menus 8ea43</li> <li>HeaderView: context menu fix c71c2</li> </ul>"},{"location":"changelog.html#v1170-2023-04-21","title":"v1.17.0 (2023-04-21)","text":""},{"location":"changelog.html#feat_7","title":"Feat","text":"<ul> <li>Image: add to_ndarray method ea556</li> <li>Widget: add get_cursor method 4dc77</li> <li>Image: add convert_to_format method f36f1</li> </ul>"},{"location":"changelog.html#fix_7","title":"Fix","text":"<ul> <li>ImportlibDistributionModel: avoid duplicates in requirements d27d2</li> </ul>"},{"location":"changelog.html#v1160-2023-04-21","title":"v1.16.0 (2023-04-21)","text":""},{"location":"changelog.html#feat_8","title":"Feat","text":"<ul> <li>AbstractItemView: add get_horizontal/vertical/scroll_mode methods bf664</li> <li>AbstractItemView: added model_changed signal 79b24</li> <li>Scroller: add grabbed_gesture method c3041</li> <li>add pdf and pdfwidgets modules de15b</li> <li>MetaProperty: add get_meta_type method 9242c</li> <li>GeoPolygon: add get_hole_path / get_perimeter methods 8910a</li> </ul>"},{"location":"changelog.html#v1151-2023-04-20","title":"v1.15.1 (2023-04-20)","text":""},{"location":"changelog.html#fix_8","title":"Fix","text":"<ul> <li>IconBrowser: correctly build charmap dict 49e18</li> <li>GraphicsEllipseItem: fix get_rect type issue (got broken with qt6) 69653</li> </ul>"},{"location":"changelog.html#v1150-2023-04-20","title":"v1.15.0 (2023-04-20)","text":""},{"location":"changelog.html#feat_9","title":"Feat","text":"<ul> <li>Object: add get_properties method 2fafb</li> <li>Image: add from/to_pil methods eb342</li> <li>Object: add get_dynamic_properties method 7c82b</li> <li>PropertyAnimation: allow passing the qt property method directly for apply_to 1ca12</li> </ul>"},{"location":"changelog.html#fix_9","title":"Fix","text":"<ul> <li>MetaObject: offsets were off by 1 cecd7</li> </ul>"},{"location":"changelog.html#v1143-2023-04-20","title":"v1.14.3 (2023-04-20)","text":""},{"location":"changelog.html#fix_10","title":"Fix","text":"<ul> <li>another release fix :) af959</li> </ul>"},{"location":"changelog.html#v1142-2023-04-20","title":"v1.14.2 (2023-04-20)","text":""},{"location":"changelog.html#fix_11","title":"Fix","text":"<ul> <li>another release fix bdc10</li> </ul>"},{"location":"changelog.html#v1141-2023-04-20","title":"v1.14.1 (2023-04-20)","text":""},{"location":"changelog.html#fix_12","title":"Fix","text":"<ul> <li>release pipeline fix bcfd8</li> </ul>"},{"location":"changelog.html#v1140-2023-04-20","title":"v1.14.0 (2023-04-20)","text":""},{"location":"changelog.html#feat_10","title":"Feat","text":"<ul> <li>WaitingSpinner: register some attributes as Qt Properties d3b25</li> <li>TableWidget: also support indexes for openPersistentEditor d450d</li> </ul>"},{"location":"changelog.html#fix_13","title":"Fix","text":"<ul> <li>RadioDelegate: property doesnt accept bytes (anymore) 25a96</li> <li>Painter: fix draw_rounded_rect method bb883</li> </ul>"},{"location":"changelog.html#v1131-2023-04-20","title":"v1.13.1 (2023-04-20)","text":""},{"location":"changelog.html#fix_14","title":"Fix","text":"<ul> <li>fix tests... 58c78</li> </ul>"},{"location":"changelog.html#v1130-2023-04-20","title":"v1.13.0 (2023-04-20)","text":""},{"location":"changelog.html#feat_11","title":"Feat","text":"<ul> <li>ButtonDelegate: no need anymore to open persistent editors 78984</li> <li>AbstractTableModel: add getitem method to return indexes 0b9be</li> </ul>"},{"location":"changelog.html#v1121-2023-04-19","title":"v1.12.1 (2023-04-19)","text":""},{"location":"changelog.html#fix_15","title":"Fix","text":"<ul> <li>Widget: missing string cast for set_stylesheet e536b</li> </ul>"},{"location":"changelog.html#v1120-2023-04-19","title":"v1.12.0 (2023-04-19)","text":""},{"location":"changelog.html#feat_12","title":"Feat","text":"<ul> <li>ColumnItemModel: inherit some stuff from ListMixin</li> </ul>"},{"location":"changelog.html#v1110-2023-04-18","title":"v1.11.0 (2023-04-18)","text":""},{"location":"changelog.html#feat_13","title":"Feat","text":"<ul> <li>LineEdit: allow some special values for set_input_mask</li> <li>Locale: add get_measurement_system</li> </ul>"},{"location":"changelog.html#fix_16","title":"Fix","text":"<ul> <li>ColumntItemModel: always return correct rowCount</li> </ul>"},{"location":"changelog.html#v1100-2023-04-18","title":"v1.10.0 (2023-04-18)","text":""},{"location":"changelog.html#feat_14","title":"Feat","text":"<ul> <li>ColumnItemModel: methods for setting data</li> <li>TreeItem: add iter method</li> </ul>"},{"location":"changelog.html#fix_17","title":"Fix","text":"<ul> <li>AttributeModel: checkstate instead of text for is_attribute</li> <li>UndoStack: raise KeyError instead of returning it</li> </ul>"},{"location":"changelog.html#v192-2023-04-17","title":"v1.9.2 (2023-04-17)","text":""},{"location":"changelog.html#fix_18","title":"Fix","text":"<ul> <li>StorageInfoModel: move some stuff to baseclass</li> </ul>"},{"location":"changelog.html#v191-2023-04-17","title":"v1.9.1 (2023-04-17)","text":""},{"location":"changelog.html#fix_19","title":"Fix","text":"<ul> <li>ColumnItemModel: fix wrong value for non-listed roles in data()</li> <li>ObjectBrowser: re-add DEFAULT_ATTR_DETAILS and inspected_node_is_visible</li> </ul>"},{"location":"changelog.html#v190-2023-04-17","title":"v1.9.0 (2023-04-17)","text":""},{"location":"changelog.html#feat_15","title":"Feat","text":"<ul> <li>custom_widgets: add FileTree class</li> <li>AbstractItemModel: add update_all method</li> </ul>"},{"location":"changelog.html#fix_20","title":"Fix","text":"<ul> <li>IconDelegate: fix exception when QIcon is passed</li> </ul>"},{"location":"changelog.html#v181-2023-04-17","title":"v1.8.1 (2023-04-17)","text":""},{"location":"changelog.html#fix_21","title":"Fix","text":"<ul> <li>user_data fix</li> </ul>"},{"location":"changelog.html#v180-2023-04-17","title":"v1.8.0 (2023-04-17)","text":""},{"location":"changelog.html#feat_16","title":"Feat","text":"<ul> <li>ColumnItemModel: add user_data to ColumnItems</li> </ul>"},{"location":"changelog.html#v171-2023-04-17","title":"v1.7.1 (2023-04-17)","text":""},{"location":"changelog.html#fix_22","title":"Fix","text":"<ul> <li>fix docs generation</li> </ul>"},{"location":"changelog.html#v170-2023-04-17","title":"v1.7.0 (2023-04-17)","text":""},{"location":"changelog.html#feat_17","title":"Feat","text":"<ul> <li>ColumnItemModel: add support for sort value and tooltips</li> <li>Widget: add grab_mouse_events / grab_keyboard_events context managers</li> <li>Painter: add some convenience methods</li> </ul>"},{"location":"changelog.html#v160-2023-04-16","title":"v1.6.0 (2023-04-16)","text":""},{"location":"changelog.html#feat_18","title":"Feat","text":"<ul> <li>Widget: add delete_children method</li> <li>Url: add is_special_url and _has_explicit_scheme methods</li> <li>Application: add set_style method</li> <li>Scrollbar: add scroll_to_next/previous_row methods</li> <li>Uuid: add to_string method</li> </ul>"},{"location":"changelog.html#fix_23","title":"Fix","text":"<ul> <li>Application: correct icon colors for new Qt built in dark mode (when using Fusion theme)</li> <li>ChartView: correct cursor shape for dragging movements</li> </ul>"},{"location":"changelog.html#v150-2023-04-13","title":"v1.5.0 (2023-04-13)","text":""},{"location":"changelog.html#feat_19","title":"Feat","text":"<ul> <li>TimeZone: add get_time_spec method</li> <li>TextDocument: add get/set_meta_information methods</li> <li>ListWidgetItem: add set_text_alignment method</li> <li>DirIterator: add get_file_path / get_file_info methods</li> </ul>"},{"location":"changelog.html#fix_24","title":"Fix","text":"<ul> <li>FileSystemModel: fix yield_child_indexes method</li> </ul>"},{"location":"changelog.html#v142-2023-04-12","title":"v1.4.2 (2023-04-12)","text":""},{"location":"changelog.html#fix_25","title":"Fix","text":"<ul> <li>only run tests on linux for now</li> </ul>"},{"location":"changelog.html#v141-2023-04-12","title":"v1.4.1 (2023-04-12)","text":""},{"location":"changelog.html#fix_26","title":"Fix","text":"<ul> <li>remove codecov from deps</li> </ul>"},{"location":"changelog.html#v140-2023-04-12","title":"v1.4.0 (2023-04-12)","text":""},{"location":"changelog.html#feat_20","title":"Feat","text":"<ul> <li>Color: add convert_to method</li> <li>Color: add get_spec method</li> <li>core: add KeyCombination class</li> <li>re-add qthelp module</li> </ul>"},{"location":"changelog.html#fix_27","title":"Fix","text":"<ul> <li>fixed Color.as_qt error with Qt6.5</li> </ul>"},{"location":"changelog.html#v130-2023-04-11","title":"v1.3.0 (2023-04-11)","text":""},{"location":"changelog.html#feat_21","title":"Feat","text":"<ul> <li>add some set_origin methods</li> <li>add some set_transform methods</li> <li>Brush: add set_style method</li> </ul>"},{"location":"changelog.html#v120-2023-04-11","title":"v1.2.0 (2023-04-11)","text":""},{"location":"changelog.html#feat_22","title":"Feat","text":"<ul> <li>re-enable texttospeech module</li> <li>gui: add AbstractFileIconProvider class</li> <li>core: add MetaType class</li> <li>gui: add StyleHints class</li> </ul>"},{"location":"changelog.html#fix_28","title":"Fix","text":"<ul> <li>correct filtering for Dir.get_entry_info_list</li> <li>Dir: explicitely use kwargs for entryList/entryInfoList calls</li> <li>prevent namespace collisions with builtin locale package</li> </ul>"},{"location":"changelog.html#v112-2023-04-10","title":"v1.1.2 (2023-04-10)","text":""},{"location":"changelog.html#fix_29","title":"Fix","text":"<ul> <li>always pass sys.argv to QCoreApplication etc</li> </ul>"},{"location":"changelog.html#v111-2023-04-10","title":"v1.1.1 (2023-04-10)","text":""},{"location":"changelog.html#fix_30","title":"Fix","text":"<ul> <li>Qt6 fixes for Dialog classes</li> </ul>"},{"location":"changelog.html#v110-2023-04-10","title":"v1.1.0 (2023-04-10)","text":""},{"location":"changelog.html#feat_23","title":"Feat","text":"<ul> <li>Image: add as_bytes method</li> </ul>"},{"location":"changelog.html#v100-2023-04-07","title":"v1.0.0 (2023-04-07)","text":""},{"location":"changelog.html#feat_24","title":"Feat","text":"<ul> <li>MultimediaWidgets for Qt6</li> <li>get rid of mro fuckery</li> <li>re-add location module</li> </ul>"},{"location":"changelog.html#fix_31","title":"Fix","text":"<ul> <li>remove title property for widgets</li> </ul>"},{"location":"changelog.html#v01933-2023-04-04","title":"v0.193.3 (2023-04-04)","text":""},{"location":"changelog.html#fix_32","title":"Fix","text":"<ul> <li>get rid of sre_constants warnings</li> </ul>"},{"location":"changelog.html#v01932-2023-02-04","title":"v0.193.2 (2023-02-04)","text":""},{"location":"changelog.html#fix_33","title":"Fix","text":"<ul> <li>correctly init dataclass for py3.11</li> <li>proper QDialog exec fix</li> </ul>"},{"location":"changelog.html#v01931-2022-11-18","title":"v0.193.1 (2022-11-18)","text":""},{"location":"changelog.html#fix_34","title":"Fix","text":"<ul> <li>exec_ fix for PyQt6</li> </ul>"},{"location":"changelog.html#v01930-2022-11-12","title":"v0.193.0 (2022-11-12)","text":""},{"location":"changelog.html#feat_25","title":"Feat","text":"<ul> <li>custom_models: add BaseNestedModel class</li> </ul>"},{"location":"changelog.html#v01921-2022-11-12","title":"v0.192.1 (2022-11-12)","text":""},{"location":"changelog.html#fix_35","title":"Fix","text":"<ul> <li>disable BaseModelMixin test for now</li> </ul>"},{"location":"changelog.html#v01920-2022-11-12","title":"v0.192.0 (2022-11-12)","text":""},{"location":"changelog.html#feat_26","title":"Feat","text":"<ul> <li>custom_models: add BaseListMixin class</li> </ul>"},{"location":"changelog.html#v01910-2022-11-10","title":"v0.191.0 (2022-11-10)","text":""},{"location":"changelog.html#feat_27","title":"Feat","text":"<ul> <li>custom_models: add BaseModelMixin class</li> </ul>"},{"location":"changelog.html#v01908-2022-11-09","title":"v0.190.8 (2022-11-09)","text":""},{"location":"changelog.html#fix_36","title":"Fix","text":"<ul> <li>better check for combobox set_editable method</li> </ul>"},{"location":"changelog.html#v01907-2022-11-08","title":"v0.190.7 (2022-11-08)","text":""},{"location":"changelog.html#fix_37","title":"Fix","text":"<ul> <li>Combobox: set Completer only when calling set_editable to avoid error message</li> </ul>"},{"location":"changelog.html#v01906-2022-11-03","title":"v0.190.6 (2022-11-03)","text":""},{"location":"changelog.html#fix_38","title":"Fix","text":"<ul> <li>proper fix for restoreState</li> </ul>"},{"location":"changelog.html#v01905-2022-11-03","title":"v0.190.5 (2022-11-03)","text":""},{"location":"changelog.html#fix_39","title":"Fix","text":"<ul> <li>allow str for restoreState</li> </ul>"},{"location":"changelog.html#v01904-2022-11-03","title":"v0.190.4 (2022-11-03)","text":""},{"location":"changelog.html#fix_40","title":"Fix","text":"<ul> <li>qt compat</li> <li>some compat fixes</li> <li>qt6 flag compat</li> <li>qt6 compat</li> </ul>"},{"location":"changelog.html#v01903-2022-06-30","title":"v0.190.3 (2022-06-30)","text":""},{"location":"changelog.html#fix_41","title":"Fix","text":"<ul> <li>bump regex dep</li> </ul>"},{"location":"changelog.html#v01902-2022-04-07","title":"v0.190.2 (2022-04-07)","text":""},{"location":"changelog.html#fix_42","title":"Fix","text":"<ul> <li>scxml not available for PyQt5</li> </ul>"},{"location":"changelog.html#v01901-2022-04-06","title":"v0.190.1 (2022-04-06)","text":""},{"location":"changelog.html#fix_43","title":"Fix","text":"<ul> <li>regex fix</li> </ul>"},{"location":"changelog.html#v01900-2022-04-06","title":"v0.190.0 (2022-04-06)","text":""},{"location":"changelog.html#feat_28","title":"Feat","text":"<ul> <li>Application: add sleep method</li> <li>add scxml module</li> </ul>"},{"location":"changelog.html#v01890-2021-12-31","title":"v0.189.0 (2021-12-31)","text":""},{"location":"changelog.html#feat_29","title":"Feat","text":"<ul> <li>XmlStreamReader: add get_token_type / read_next methods</li> <li>Rect: add margins_added / margins_removed methods</li> <li>TextDocument: add show_whitespaces_and_tabs method</li> <li>Chart: add set_margins method</li> <li>core: add XmlStreamReader class</li> <li>Size/SizeF: add shrunk_by / grown_by methods</li> <li>StandardItem/ListWidgetItem/TreeWidgetItem: add set_size_hint method</li> <li>Polygon/PolygonF: add get_data_buffer method</li> <li>ListWidgetItem: add set_data method</li> <li>Window/Widget: add get_screen method</li> </ul>"},{"location":"changelog.html#fix_44","title":"Fix","text":"<ul> <li>typo for DateType</li> <li>CompletionWidget: correctly cast to int for SetY</li> </ul>"},{"location":"changelog.html#v01880-2021-12-14","title":"v0.188.0 (2021-12-14)","text":""},{"location":"changelog.html#feat_30","title":"Feat","text":"<ul> <li>add JsonModel class</li> <li>Translator: add for_system_language method</li> <li>StyleOptionToolBox: add get/set_selected_position methods</li> <li>Widget: add screen param to center method</li> <li>Url: add from_local_file method</li> <li>custom_widgets: add CompletionWidget class</li> <li>TextDocument/TextDocumentFragment: add write_to_file method</li> <li>Font: add set_family method</li> <li>gui: add TextDocumentWriter class</li> <li>TextCursor: add get_selection method</li> <li>Mimedata: add set_svg_data / set_path_data</li> <li>gui: add TextDocumentFragment class</li> <li>ListWidet: add find_items method</li> <li>SpacerItem: add get_size_policy method</li> <li>custom_validators: add IntegerValidator class</li> </ul>"},{"location":"changelog.html#v01872-2021-11-18","title":"v0.187.2 (2021-11-18)","text":""},{"location":"changelog.html#fix_45","title":"Fix","text":"<ul> <li>fix import for non-windows</li> </ul>"},{"location":"changelog.html#v01871-2021-11-18","title":"v0.187.1 (2021-11-18)","text":""},{"location":"changelog.html#fix_46","title":"Fix","text":"<ul> <li>add FramelessWindow to init.py</li> </ul>"},{"location":"changelog.html#v01870-2021-11-18","title":"v0.187.0 (2021-11-18)","text":""},{"location":"changelog.html#feat_31","title":"Feat","text":"<ul> <li>Pixmap: add get_image_data_url method</li> <li>FramelessWindow: make AeroSnap work</li> <li>custom_widgets: add JoystickButton class</li> <li>Add SvgBufferIconEngine class</li> <li>FontDatabase: keep track of font paths</li> <li>Style: add draw_control method</li> <li>Icon: add from_char method</li> <li>Pixmap: add create_char method</li> </ul>"},{"location":"changelog.html#fix_47","title":"Fix","text":"<ul> <li>fix ProgressBarDelegate orientation for Qt6</li> </ul>"},{"location":"changelog.html#v01860-2021-11-11","title":"v0.186.0 (2021-11-11)","text":""},{"location":"changelog.html#feat_32","title":"Feat","text":"<ul> <li>WebEnginePage: add some more methods</li> <li>Color: add get_name method</li> <li>iconprovider: add dir and getattr methods to iconsets</li> <li>TextDocument: add some more methods</li> <li>TextBlock: add str method</li> <li>Process: add get_process_environment method</li> <li>qml: add clear_type_registrations method</li> <li>FileIconProvider: support os.PathLike for get_icon</li> <li>custom_widgets: add SubsequenceCompleter class</li> <li>Completer: add set/is_case_sensitive methods</li> <li>custom_models: add SubsequenceSortFilterProxyModel class</li> <li>SortFilterProxyModel: add set_sort_role method</li> </ul>"},{"location":"changelog.html#v01850-2021-11-04","title":"v0.185.0 (2021-11-04)","text":""},{"location":"changelog.html#feat_33","title":"Feat","text":"<ul> <li>add QT_VERSION var to qt module</li> </ul>"},{"location":"changelog.html#fix_48","title":"Fix","text":"<ul> <li>core: dont shadow builtin libraries</li> </ul>"},{"location":"changelog.html#v01840-2021-10-30","title":"v0.184.0 (2021-10-30)","text":""},{"location":"changelog.html#feat_34","title":"Feat","text":"<ul> <li>qt: add flag_to_int method</li> <li>debugging: add is_deleted fn</li> <li>TextEdit: add get_text_cursor method</li> <li>PlainTextEdit: add get_text_cursor method</li> <li>better package support by using importlib.resources for resource files</li> <li>add qt.set_env_vars</li> <li>fallback to installed qt package in case environment var QT_API is invalid / empty</li> <li>TextBlock: add some methods related to syntax highlighting</li> <li>HeaderView: add section_resized_by_user signal</li> <li>Widget: add resized signal</li> <li>add StandardIconsWidget class</li> <li>TextCursor: add get_cursor_position method</li> <li>SyntaxHighlighter: add get_current_block / get_format</li> <li>Process: add edit_environment method</li> <li>Widget: rename get/set_context_menu_policy methods</li> <li>TextLayout: add get_text_option method</li> <li>TextDocument: add some more methods</li> <li>TextCursor: add str method</li> <li>StandardItemModel: add create_single_item_model classmethod</li> <li>ProcessEnvironment: add update() / items() methods</li> <li>Color: add drift_color classmethod</li> <li>PlaintextEdit: TextDocument by default</li> <li>PlainTextEdit: add show_whitespace_and_tabs method</li> <li>add mimetype_icon fn for FileIconProvider</li> <li>Add MenuRecentFiles class</li> <li>update iconsets</li> </ul>"},{"location":"changelog.html#fix_49","title":"Fix","text":"<ul> <li>TextCursor: correctly convert EOL in str</li> <li>qt6 flag fix</li> <li>typo in AwesomeFileIconProvider</li> </ul>"},{"location":"changelog.html#v01836-2021-10-26","title":"v0.183.6 (2021-10-26)","text":""},{"location":"changelog.html#fix_50","title":"Fix","text":"<ul> <li>more qt compat stuff</li> <li>generate docs on py3.9</li> </ul>"},{"location":"changelog.html#v01835-2021-10-12","title":"v0.183.5 (2021-10-12)","text":""},{"location":"changelog.html#fix_51","title":"Fix","text":"<ul> <li>only test on 3.9 / macos10</li> </ul>"},{"location":"changelog.html#v01834-2021-10-12","title":"v0.183.4 (2021-10-12)","text":""},{"location":"changelog.html#fix_52","title":"Fix","text":"<ul> <li>dont use poetry pre version</li> </ul>"},{"location":"changelog.html#v01833-2021-10-12","title":"v0.183.3 (2021-10-12)","text":""},{"location":"changelog.html#fix_53","title":"Fix","text":"<ul> <li>qt6 compat</li> <li>some flag fixes</li> </ul>"},{"location":"changelog.html#v01832-2021-02-05","title":"v0.183.2 (2021-02-05)","text":""},{"location":"changelog.html#fix_54","title":"Fix","text":"<ul> <li>another try to fix docs generation</li> </ul>"},{"location":"changelog.html#v01831-2021-02-05","title":"v0.183.1 (2021-02-05)","text":""},{"location":"changelog.html#fix_55","title":"Fix","text":"<ul> <li>fix docs generation</li> </ul>"},{"location":"changelog.html#v01830-2021-02-05","title":"v0.183.0 (2021-02-05)","text":""},{"location":"changelog.html#feat_35","title":"Feat","text":"<ul> <li>JSEngine: add eval method</li> <li>Pixmap: add rotated method</li> <li>ColorDialog: add replace_qcolorshowlabel</li> <li>JSValue: add call method</li> <li>PlainTextEdit: add some more methods</li> <li>core: add Slot method</li> <li>core: add Mutex/Semaphore classes</li> <li>LineEdit: add some signals</li> <li>svg: add SvgWidget class</li> </ul>"},{"location":"changelog.html#fix_56","title":"Fix","text":"<ul> <li>correctly keep state when using block_signals / updates_off context managers</li> </ul>"},{"location":"changelog.html#v01821-2021-01-26","title":"v0.182.1 (2021-01-26)","text":""},{"location":"changelog.html#fix_57","title":"Fix","text":"<ul> <li>colors fix</li> </ul>"},{"location":"changelog.html#v01820-2021-01-26","title":"v0.182.0 (2021-01-26)","text":""},{"location":"changelog.html#feat_36","title":"Feat","text":"<ul> <li>Image: add invert_pixels method</li> <li>Color: invert_alpha param for inverted method</li> <li>MetaObject: type_filter kwarg for get_methods</li> <li>core: add MetaProperty class</li> <li>MetaObject: include_super param for get_ methods</li> <li>ItemEditorFactory: add property_name kwarg to register_editor method</li> <li>TabWidget: add update_tab_bar_visibility method</li> <li>Pixmap: add from_image method</li> <li>MessageBox: add some constants</li> <li>MessageBox: add set_escape/default_button methods</li> <li>MessageBox: add get_icon_pixmap method</li> <li>svg: add SvgRenderer class</li> <li>Image: add from_ndarray method</li> </ul>"},{"location":"changelog.html#v01810-2021-01-23","title":"v0.181.0 (2021-01-23)","text":""},{"location":"changelog.html#feat_37","title":"Feat","text":"<ul> <li>Color: add is_dark and inverted methods</li> <li>Dir: add set_search_paths method</li> <li>Palette: add inverted method</li> <li>Dir: add add_search_path method</li> <li>core: add AbstractNativeEventFilter</li> </ul>"},{"location":"changelog.html#v01800-2021-01-20","title":"v0.180.0 (2021-01-20)","text":""},{"location":"changelog.html#feat_38","title":"Feat","text":"<ul> <li>TextDocument: add some methods related to default stylesheet editing</li> <li>PygmentsHighlighter: add repr method</li> <li>PygmentsHighlighter: add style kwarg</li> <li>QtCore: add QClassInfo for PyQt5/6</li> <li>colors: add interpolate_text_colors fn</li> <li>Color: add from_hsv method</li> <li>gui: add Drag class</li> <li>DataWidgetMapper: add get_mapped_property_name method</li> <li>DataWidgetMapper: add add_mapping method</li> </ul>"},{"location":"changelog.html#v01790-2021-01-18","title":"v0.179.0 (2021-01-18)","text":""},{"location":"changelog.html#fix_58","title":"Fix","text":"<ul> <li>RegexInput flags fix</li> <li>ModelTester: correctly disconnect model</li> </ul>"},{"location":"changelog.html#feat_39","title":"Feat","text":"<ul> <li>Painter: more kwargs for set_pen method</li> <li>Pen: allow custom dash pattern for set_style</li> <li>ItemEditorFactory: add register_default_editor method</li> <li>GraphicsItem: add set_scale method</li> <li>Pixmap: add create_checkerboard_pattern method</li> <li>ColorDialog: add get_qcolorshower/get_qcolorshowlabel methods</li> <li>TableWidgetItem: add set_tooltip method</li> </ul>"},{"location":"changelog.html#v01780-2021-01-14","title":"v0.178.0 (2021-01-14)","text":""},{"location":"changelog.html#feat_40","title":"Feat","text":"<ul> <li>IODevice: add len method</li> <li>EventLoop: throw exception when running twice</li> <li>Color: add to_qsscolor method</li> <li>Color: add interpolate_color method</li> <li>Locale: add get_system_locale / get_system_language methods</li> <li>use subclassed ItemEditorFactory as default factory</li> </ul>"},{"location":"changelog.html#v01771-2021-01-13","title":"v0.177.1 (2021-01-13)","text":""},{"location":"changelog.html#fix_59","title":"Fix","text":"<ul> <li>test fix</li> </ul>"},{"location":"changelog.html#v01770-2021-01-13","title":"v0.177.0 (2021-01-13)","text":""},{"location":"changelog.html#feat_41","title":"Feat","text":"<ul> <li>allow args for app() methods</li> </ul>"},{"location":"changelog.html#v01760-2021-01-13","title":"v0.176.0 (2021-01-13)","text":""},{"location":"changelog.html#feat_42","title":"Feat","text":"<ul> <li>Timer: add start_timer method</li> <li>Timer: add set_interval method</li> <li>allow os.PathLike for using images in set_tooltip methods</li> <li>Movie: add get_supported_formats method</li> <li>iconprovider: add AwesomeQuickImageProvider class</li> <li>iconprovider: add AwesomeFileIconProvider class</li> </ul>"},{"location":"changelog.html#v01750-2021-01-12","title":"v0.175.0 (2021-01-12)","text":""},{"location":"changelog.html#feat_43","title":"Feat","text":"<ul> <li>add prettyqtest</li> <li>qml: add register_qml_type method</li> <li>AbstractSlider: add set_auto_scroll_to_end method</li> <li>GuiApplication: add edit_palette context manager</li> <li>Dir: add get_entry_list method</li> </ul>"},{"location":"changelog.html#v01740-2021-01-11","title":"v0.174.0 (2021-01-11)","text":""},{"location":"changelog.html#feat_44","title":"Feat","text":"<ul> <li>core: add FileSelector class</li> <li>Dir: add get_entry_info_list method</li> <li>Resource: add set/get_file_name and register_resource methods</li> <li>Application: add get_available_themes method</li> </ul>"},{"location":"changelog.html#v01730-2021-01-10","title":"v0.173.0 (2021-01-10)","text":""},{"location":"changelog.html#fix_60","title":"Fix","text":"<ul> <li>correct icon color for dark mode</li> </ul>"},{"location":"changelog.html#feat_45","title":"Feat","text":"<ul> <li>custom_models: add StorageInfoModel class</li> <li>DataStream: add get/set_status methods</li> <li>custom_widgets: add ElidedLabel class</li> <li>Painter: add get_font_metrics method</li> <li>gui: add TextLayout class</li> <li>add SyncedProperty class</li> <li>Widget: add get/set_window_file_path methods</li> <li>widgets: add SplitterHandle class</li> </ul>"},{"location":"changelog.html#v01720-2021-01-09","title":"v0.172.0 (2021-01-09)","text":""},{"location":"changelog.html#feat_46","title":"Feat","text":"<ul> <li>Application: add set_theme method</li> <li>gui: add TextObjectInterface class</li> <li>PyQt5: import QEnum and QFlag classes</li> <li>core: add MetaMethod/MetaObject classes</li> <li>widgets: add FocusFrame class</li> <li>quick: add Quick(Async)ImageProvider classes</li> <li>QmlEngine: add some more methods</li> <li>QmlApplicationEngine: add load_file method</li> </ul>"},{"location":"changelog.html#v01711-2021-01-07","title":"v0.171.1 (2021-01-07)","text":""},{"location":"changelog.html#fix_61","title":"Fix","text":"<ul> <li>comment out some event constants</li> </ul>"},{"location":"changelog.html#v01710-2021-01-07","title":"v0.171.0 (2021-01-07)","text":""},{"location":"changelog.html#feat_47","title":"Feat","text":"<ul> <li>GraphicsItem: add get/set_cache_mode methods</li> <li>GraphicsPixmapItem: some additional methods</li> <li>custom_widgets: add BorderLayout class</li> <li>widgets: add WidgetItem class</li> <li>LayoutItem: add get_item method</li> <li>LayoutItem: add get/set_alignment methods</li> <li>Style: add draw_primitive method</li> <li>StyleOption: add based_on method</li> </ul>"},{"location":"changelog.html#fix_62","title":"Fix","text":"<ul> <li>AutoSlot: use typing.get_type_hints</li> </ul>"},{"location":"changelog.html#v01700-2021-01-05","title":"v0.170.0 (2021-01-05)","text":""},{"location":"changelog.html#feat_48","title":"Feat","text":"<ul> <li>Validators: also allow Pattern for set_regex</li> <li>add tile rule constant</li> <li>add SingleApplication class</li> <li>custom_widgets: add Notification class</li> <li>TreeWidget: add contains method</li> <li>HelpContentWidget: add index_of method</li> <li>add contains method to some widgets</li> <li>ItemEditorFactory: add register_editor method</li> <li>widgets: add ItemEditorCreatorBase / ItemEditorFactory</li> <li>types: add Variant(Type)</li> <li>VariantAnimation: add set_range method</li> <li>TextStream: add read_lines method</li> <li>TextStream: add set_codec method</li> </ul>"},{"location":"changelog.html#v01690-2021-01-04","title":"v0.169.0 (2021-01-04)","text":""},{"location":"changelog.html#feat_49","title":"Feat","text":"<ul> <li>RegularExpressionMatch: add get_match_type method</li> <li>CoreApplication: allow more types for version metadata</li> <li>Windows: add workaround for raising window</li> <li>network: add LocalSocket class</li> </ul>"},{"location":"changelog.html#fix_63","title":"Fix","text":"<ul> <li>CoreApplication: fix setting metadata</li> </ul>"},{"location":"changelog.html#v01680-2021-01-03","title":"v0.168.0 (2021-01-03)","text":""},{"location":"changelog.html#feat_50","title":"Feat","text":"<ul> <li>eventfilters: add AnimatedToolTipEventFilter class</li> <li>Widget: tooltip kwarg for set_flags method</li> <li>AbstractAnimation: add restart_animation method</li> <li>add custom_animations module</li> <li>AbstractAnimation: implement and and or</li> <li>Dir: some additional methods</li> </ul>"},{"location":"changelog.html#v01670-2021-01-02","title":"v0.167.0 (2021-01-02)","text":""},{"location":"changelog.html#feat_51","title":"Feat","text":"<ul> <li>FileSystemModel: add get_file_info and get_file_path methods</li> <li>add fspath to Dir and FileInfo classes</li> </ul>"},{"location":"changelog.html#v01661-2021-01-01","title":"v0.166.1 (2021-01-01)","text":""},{"location":"changelog.html#fix_64","title":"Fix","text":"<ul> <li>localization fixups</li> </ul>"},{"location":"changelog.html#v01660-2020-12-31","title":"v0.166.0 (2020-12-31)","text":""},{"location":"changelog.html#feat_52","title":"Feat","text":"<ul> <li>CoreApplication: add get_available_languages and load_language methods</li> </ul>"},{"location":"changelog.html#v01650-2020-12-31","title":"v0.165.0 (2020-12-31)","text":""},{"location":"changelog.html#feat_53","title":"Feat","text":"<ul> <li>WebEngineView: add register_as_browser method</li> <li>WebEngineView: ass some settings-related methods</li> <li>Translator: add load_file method</li> <li>add FramelessWindow class</li> <li>add webchannel module</li> <li>qt: add QtWebchannel module</li> <li>widgets: add FileIconProvider class</li> <li>add prettyqt.qt.QtUiTools module</li> </ul>"},{"location":"changelog.html#v01640-2020-12-29","title":"v0.164.0 (2020-12-29)","text":""},{"location":"changelog.html#feat_54","title":"Feat","text":"<ul> <li>CoreApplication: add restart method</li> </ul>"},{"location":"changelog.html#fix_65","title":"Fix","text":"<ul> <li>FontDatabase: make get_system_font a classmethod</li> <li>ObjectBrowser signal fix for Qt6</li> <li>PdfWriter: correctly inherit from Object and PagedPaintDevice</li> </ul>"},{"location":"changelog.html#v01630-2020-12-27","title":"v0.163.0 (2020-12-27)","text":""},{"location":"changelog.html#feat_55","title":"Feat","text":"<ul> <li>OperatingsystemVersion: add eq and hash methods</li> <li>VersionNumber: add hash method</li> <li>FontDatabase: add optional md5 check for add_font</li> </ul>"},{"location":"changelog.html#fix_66","title":"Fix","text":"<ul> <li>revert CharIconPainter paint method for now</li> </ul>"},{"location":"changelog.html#v01620-2020-12-27","title":"v0.162.0 (2020-12-27)","text":""},{"location":"changelog.html#feat_56","title":"Feat","text":"<ul> <li>FontDatabase: add additional check in add_font</li> <li>Painter: add offset_by and apply_transform context managers</li> </ul>"},{"location":"changelog.html#fix_67","title":"Fix","text":"<ul> <li>IconWidget: update when setting size</li> </ul>"},{"location":"changelog.html#v01610-2020-12-26","title":"v0.161.0 (2020-12-26)","text":""},{"location":"changelog.html#feat_57","title":"Feat","text":"<ul> <li>LineEdit: add add_action method</li> <li>ListView/TableView: add some more setters / getters</li> <li>Painter: add edit_pen context manager</li> <li>PolygonF: alternative ctors for diamond / star creation</li> </ul>"},{"location":"changelog.html#fix_68","title":"Fix","text":"<ul> <li>LabeledSlider: call adjust_margins on correct object</li> <li>correct IconProvider init</li> </ul>"},{"location":"changelog.html#v01600-2020-12-25","title":"v0.160.0 (2020-12-25)","text":""},{"location":"changelog.html#feat_58","title":"Feat","text":"<ul> <li>gui: add TextLine module</li> <li>Doublevalidator: add set_range method</li> <li>IntValidator: add set_range method</li> <li>Pixmap: add eq method</li> </ul>"},{"location":"changelog.html#v01590-2020-12-24","title":"v0.159.0 (2020-12-24)","text":""},{"location":"changelog.html#feat_59","title":"Feat","text":"<ul> <li>LineEdit: add set/get_cursor_move_style methods</li> </ul>"},{"location":"changelog.html#v01580-2020-12-22","title":"v0.158.0 (2020-12-22)","text":""},{"location":"changelog.html#feat_60","title":"Feat","text":"<ul> <li>iconprovider: add reset_cache method</li> <li>Widget: add set/get_foreground/background_role methods</li> <li>Application/Widget: add set/get_stylesheet methods</li> <li>Application: add edit_stylesheet context manager</li> </ul>"},{"location":"changelog.html#v01571-2020-12-22","title":"v0.157.1 (2020-12-22)","text":""},{"location":"changelog.html#fix_69","title":"Fix","text":"<ul> <li>SpanSlider fix</li> </ul>"},{"location":"changelog.html#v01570-2020-12-22","title":"v0.157.0 (2020-12-22)","text":""},{"location":"changelog.html#feat_61","title":"Feat","text":"<ul> <li>Painter: add native_mode context manager</li> <li>FontDatabase: add add_font method</li> <li>gui: add IconEngine class</li> <li>TabWidget: add set_icon_size method</li> <li>Icon: allow more types for size param</li> </ul>"},{"location":"changelog.html#v01560-2020-12-21","title":"v0.156.0 (2020-12-21)","text":""},{"location":"changelog.html#feat_62","title":"Feat","text":"<ul> <li>RegularExpressionMatch: add bool method</li> <li>custom_widgets: add ObjectBrowser class</li> <li>Timer: add restart method</li> <li>ListView: add set_grid_size method</li> <li>SortFilterProxyModel: add is/set_filter_case_sensitive methods</li> <li>AbstractItemView: add set_icon_size method</li> </ul>"},{"location":"changelog.html#v01550-2020-12-20","title":"v0.155.0 (2020-12-20)","text":""},{"location":"changelog.html#feat_63","title":"Feat","text":"<ul> <li>Label: add get_horizontal/vertical_alignment methods</li> <li>GraphicsWidget: add window_frame_section_at method</li> </ul>"},{"location":"changelog.html#v01540-2020-12-18","title":"v0.154.0 (2020-12-18)","text":""},{"location":"changelog.html#feat_64","title":"Feat","text":"<ul> <li>add QtLocation and QtHelp to qt submodule</li> <li>Dir/FileDialog: add get/set_filter methods</li> <li>InputDialog: add get/set_input_mode and get/set_text_echo_mode methods</li> </ul>"},{"location":"changelog.html#fix_70","title":"Fix","text":"<ul> <li>correct StarDelegate setModelData call</li> </ul>"},{"location":"changelog.html#v01530-2020-12-17","title":"v0.153.0 (2020-12-17)","text":""},{"location":"changelog.html#feat_65","title":"Feat","text":"<ul> <li>MediaPlayer: add get_error method</li> </ul>"},{"location":"changelog.html#v01521-2020-12-17","title":"v0.152.1 (2020-12-17)","text":""},{"location":"changelog.html#fix_71","title":"Fix","text":"<ul> <li>PySide2 workaround for non-recursive Object.findChild(ren)</li> </ul>"},{"location":"changelog.html#v01520-2020-12-16","title":"v0.152.0 (2020-12-16)","text":""},{"location":"changelog.html#feat_66","title":"Feat","text":"<ul> <li>Standarditem/StandardItemModel: add enabled and editable kwarg to add_item methods</li> <li>AbstractItemView: add get/set_drag_drop_mode methods</li> </ul>"},{"location":"changelog.html#v01510-2020-12-16","title":"v0.151.0 (2020-12-16)","text":""},{"location":"changelog.html#feat_67","title":"Feat","text":"<ul> <li>ToolBar: add add method</li> <li>Icon: add get_actual_size method</li> <li>winextras: add WinThumbnailToolButton class</li> <li>ToolButton: add set_menu method</li> <li>Uuid: add str method</li> </ul>"},{"location":"changelog.html#fix_72","title":"Fix","text":"<ul> <li>PySide2 find_child(ren) fix</li> </ul>"},{"location":"changelog.html#v01500-2020-12-15","title":"v0.150.0 (2020-12-15)","text":""},{"location":"changelog.html#feat_68","title":"Feat","text":"<ul> <li>Movie: add get_state method</li> </ul>"},{"location":"changelog.html#v01490-2020-12-15","title":"v0.149.0 (2020-12-15)","text":""},{"location":"changelog.html#feat_69","title":"Feat","text":"<ul> <li>add HoverIconEventFilter class</li> <li>positioning: add GeoPositionInfo class</li> <li>Icon: add mode and state kwarg for add/get_pixmap</li> <li>widget: add set_mask method</li> <li>core: add FileSystemWatcher class</li> <li>Palette: add get/set_color_group methods</li> <li>Brush: add some addtional methods</li> <li>Region: add some additional methods</li> <li>custom_delegates: add RenderLinkDelegate class</li> <li>TableWidgetItem: add set_text_alignment method</li> <li>Gradients: add repr and some helper methods to gradient classes</li> </ul>"},{"location":"changelog.html#fix_73","title":"Fix","text":"<ul> <li>PySide2 workaround for missing recursive param in findChild(ren)</li> <li>WebEngineHistory len fix for PySide2</li> <li>CategoryAxis len fix for PySide2</li> <li>correctly inherit LCDNumber</li> </ul>"},{"location":"changelog.html#v01480-2020-12-14","title":"v0.148.0 (2020-12-14)","text":""},{"location":"changelog.html#feat_70","title":"Feat","text":"<ul> <li>Widget: add get/set_window_state methods</li> <li>AbstractTextDocumentLayout: add tuple support for hit_test point arg</li> <li>TimeZone: add get_display_name method</li> <li>GuiApplication: add get/set_high_dpi_scale_factor_rounding_policy methods</li> <li>StandardItem: add some new methods</li> <li>AbstractButton: add get_icon method</li> <li>StandardItemModel: add add_item method</li> <li>StandardItem: add get/set_checkstate methods</li> <li>Window: add start_system_resize method</li> </ul>"},{"location":"changelog.html#v01472-2020-12-14","title":"v0.147.2 (2020-12-14)","text":""},{"location":"changelog.html#fix_74","title":"Fix","text":"<ul> <li>MacOs test fix</li> </ul>"},{"location":"changelog.html#v01471-2020-12-14","title":"v0.147.1 (2020-12-14)","text":""},{"location":"changelog.html#fix_75","title":"Fix","text":"<ul> <li>MacOs test fix</li> </ul>"},{"location":"changelog.html#v01470-2020-12-13","title":"v0.147.0 (2020-12-13)","text":""},{"location":"changelog.html#feat_71","title":"Feat","text":"<ul> <li>ToolBar: add get_allowed_areas method</li> <li>WebEnginePage: add some additional methods</li> <li>WebEngineSettings: add delitem method</li> <li>Application: add send/post_event methods</li> </ul>"},{"location":"changelog.html#v01460-2020-12-13","title":"v0.146.0 (2020-12-13)","text":""},{"location":"changelog.html#fix_76","title":"Fix","text":"<ul> <li>correctly serialize AbstractGraphicsShapeItem</li> </ul>"},{"location":"changelog.html#feat_72","title":"Feat","text":"<ul> <li>GuiApplication: add get_icon method</li> <li>PlainTextEdit: add get(_line)_wrap_mode methods</li> <li>GuiApplication: add get_application_state method</li> </ul>"},{"location":"changelog.html#v01450-2020-12-11","title":"v0.145.0 (2020-12-11)","text":""},{"location":"changelog.html#fix_77","title":"Fix","text":"<ul> <li>GraphicsGridLayout: serialize correctly</li> <li>MediaRecorder: use correct module in set_video/audio_settings</li> <li>correct constant naming</li> <li>install_exceptionhook fix</li> </ul>"},{"location":"changelog.html#feat_73","title":"Feat","text":"<ul> <li>GridLayout: add get/set_origin_corner methods</li> <li>BoxLayout: add get/set_direction methods</li> <li>NetworkCookieJar: add add and set_cookies_from_url methods</li> <li>NetworkCookie: add set_expiration_date method</li> <li>Translator: add bool method</li> <li>custom_widgets: add RoundProgressBar class</li> <li>DateTimeEdit: add some more methods related to sections</li> <li>get/set_icon_size work for some widgets</li> <li>CalendarWidget: add set_range method</li> <li>HeaderView: add generate_header_id method</li> <li>Widget: add edit_palette contextmanager and get_font method</li> <li>Palette: add brush methods</li> <li>custom_models: add ImportlibDistributionModel class</li> </ul>"},{"location":"changelog.html#v01440-2020-12-09","title":"v0.144.0 (2020-12-09)","text":""},{"location":"changelog.html#fix_78","title":"Fix","text":"<ul> <li>Settings: iter through key-value pairs</li> <li>correct inheritance for QuickItem</li> <li>ColumnItemModel: correct get_width signature</li> </ul>"},{"location":"changelog.html#feat_74","title":"Feat","text":"<ul> <li>qml: add QmlImageProviderbase class</li> <li>widgets: add TreeWidgetItemIterator class</li> <li>quick: add some more classes</li> <li>qml: add QmlParserStatus class</li> <li>Widget: add get_title method</li> <li>Painter: add get_text_rect method</li> <li>ListWidget: add add_item method</li> </ul>"},{"location":"changelog.html#v01430-2020-12-08","title":"v0.143.0 (2020-12-08)","text":""},{"location":"changelog.html#fix_79","title":"Fix","text":"<ul> <li>ObjectBrowser fix</li> </ul>"},{"location":"changelog.html#feat_75","title":"Feat","text":"<ul> <li>implement eq method for some more validator classes</li> </ul>"},{"location":"changelog.html#v01421-2020-12-07","title":"v0.142.1 (2020-12-07)","text":""},{"location":"changelog.html#fix_80","title":"Fix","text":"<ul> <li>use our own SizeF class</li> </ul>"},{"location":"changelog.html#v01420-2020-12-07","title":"v0.142.0 (2020-12-07)","text":""},{"location":"changelog.html#feat_76","title":"Feat","text":"<ul> <li>SizeF: add some methods to be on par with Size</li> <li>Size: add expanded_to method</li> <li>CompositeValidator: add some additional methods</li> <li>custom_validators: add eq method to validator classes</li> <li>TreeWidgetItem: add some more methods</li> <li>widgets: add TableWidgetSelectionRange class</li> <li>core: add Calendar class</li> <li>core: add SignalMapper class</li> <li>core: add StateMachine class</li> <li>core: add LockFile class</li> <li>core: add JsonDocument/JsonValue classes</li> <li>GeoCircle: allow tuple in ctor</li> <li>core: add SocketNotifier class</li> <li>widgets: add Shortcut class</li> </ul>"},{"location":"changelog.html#fix_81","title":"Fix","text":"<ul> <li>Correctly inherit StyleItemDelegate</li> </ul>"},{"location":"changelog.html#v01410-2020-12-03","title":"v0.141.0 (2020-12-03)","text":""},{"location":"changelog.html#feat_77","title":"Feat","text":"<ul> <li>core: add Collator(SortKey) classes</li> </ul>"},{"location":"changelog.html#fix_82","title":"Fix","text":"<ul> <li>github actions fix</li> </ul>"},{"location":"changelog.html#v01404-2020-12-02","title":"v0.140.4 (2020-12-02)","text":""},{"location":"changelog.html#fix_83","title":"Fix","text":"<ul> <li>docs build fix</li> </ul>"},{"location":"changelog.html#v01403-2020-12-02","title":"v0.140.3 (2020-12-02)","text":""},{"location":"changelog.html#fix_84","title":"Fix","text":"<ul> <li>docs deployment</li> </ul>"},{"location":"changelog.html#v01402-2020-12-02","title":"v0.140.2 (2020-12-02)","text":""},{"location":"changelog.html#fix_85","title":"Fix","text":"<ul> <li>deploy check for github actions</li> </ul>"},{"location":"changelog.html#v01401-2020-12-02","title":"v0.140.1 (2020-12-02)","text":""},{"location":"changelog.html#fix_86","title":"Fix","text":"<ul> <li>github actions: conditional deploy step</li> </ul>"},{"location":"changelog.html#v01400-2020-12-02","title":"v0.140.0 (2020-12-02)","text":""},{"location":"changelog.html#feat_78","title":"Feat","text":"<ul> <li>gui: add ColorSpace class</li> </ul>"},{"location":"changelog.html#v01390-2020-12-02","title":"v0.139.0 (2020-12-02)","text":""},{"location":"changelog.html#feat_79","title":"Feat","text":"<ul> <li>FileInfo/Dir: fallback to pathlib.Path methods</li> <li>widgets: add Proxy/CommonStyle classes</li> <li>widgets: add Gesture classes</li> <li>core: add TemporaryDir class</li> <li>widgets: add WhatsThis class</li> <li>core: add ItemSelectionRange class</li> <li>FormLayout: add some more methods</li> <li>core: add ProcessEnvironment class</li> <li>gui: add StaticText class</li> <li>core: add PauseAnimation class</li> </ul>"},{"location":"changelog.html#v01380-2020-12-01","title":"v0.138.0 (2020-12-01)","text":""},{"location":"changelog.html#feat_80","title":"Feat","text":"<ul> <li>core: add ChildEvent / TimerEvent classes</li> <li>core: add IdentityProxyModel class</li> <li>gui: add SessionManager class</li> <li>gui: add InputMethod class</li> <li>core: add AbstractEventDispatcher class</li> <li>widgets: add StackedWidget class</li> <li>widgets: add some events</li> <li>FileInfo: add some additional methods</li> <li>gui: add Vector3D class</li> <li>core: add MimeType / MimeDatabase classes</li> <li>core: add SaveFile class</li> <li>core: add SignalBlocker class</li> <li>core: add TimeLine class</li> <li>gui: add Bitmap class</li> <li>core: add RandomGenerator class</li> <li>FileDevice: add get_error method</li> <li>widgets: add Dial class</li> <li>widgets: add RubberBand class</li> <li>Wizard/WizardPage: add some more methods</li> <li>widgets: add GraphicsRotation / GraphicsScale classes</li> <li>widgets: add GraphicsTransform class</li> <li>widgets: add LCDNumber class</li> <li>widgets: add Scroller(Properties) classes</li> <li>core: add CommandLineParser/Option classes</li> <li>Pixmap: add some more methods</li> <li>gui: add Screen class</li> <li>Transform: add some more methods</li> <li>add Abstract/PlainTextTextDocumentLayout classes</li> <li>core: add BasicTimer class</li> <li>core: add Resource class</li> <li>core: add StorageInfo class</li> <li>core: add ElapsedTimer class</li> <li>core: add CryptographicHash class</li> </ul>"},{"location":"changelog.html#v01371-2020-11-27","title":"v0.137.1 (2020-11-27)","text":""},{"location":"changelog.html#fix_87","title":"Fix","text":"<ul> <li>doc build fix</li> </ul>"},{"location":"changelog.html#v01370-2020-11-27","title":"v0.137.0 (2020-11-27)","text":""},{"location":"changelog.html#feat_81","title":"Feat","text":"<ul> <li>core: add OperatingSystemVersion class</li> <li>PdfWriter: add set_page_margins method</li> <li>core: add MarginsF class</li> <li>core: Add TextStream class</li> <li>core: add ByteArrayMatcher</li> <li>AbstractItemModel: add check_index method</li> <li>PlaceManager: add search_place method</li> <li>core: add app method</li> <li>add bytes method to some classes</li> <li>utils: add Singleton metaclass</li> <li>icon: add add_pixmap method</li> <li>gui: Add PixmapCache</li> <li>Font: add some more methods</li> </ul>"},{"location":"changelog.html#v01360-2020-11-26","title":"v0.136.0 (2020-11-26)","text":""},{"location":"changelog.html#feat_82","title":"Feat","text":"<ul> <li>location: add PlaceResult class</li> <li>location: add PlaceProposedSearchResult class</li> <li>location: add clone_from method to reply classes</li> <li>Object: add has_id method</li> </ul>"},{"location":"changelog.html#fix_88","title":"Fix","text":"<ul> <li>emit inputandslider signal correctly on value change</li> <li>correct flag for constants.NO_CHILDREN</li> </ul>"},{"location":"changelog.html#v01350-2020-11-26","title":"v0.135.0 (2020-11-26)","text":""},{"location":"changelog.html#feat_83","title":"Feat","text":"<ul> <li>WebEngineHistoryItem: add get_icon_url method</li> <li>location: add PlaceMatchReply / PlaceIdReply classes</li> <li>PlaceContentReply/PlaceSearchReply: add request methods</li> <li>gui: add TextListFormat class</li> <li>gui: add TextImageFormat class</li> <li>location: add some reply/result classes</li> <li>gui: add TextTableCellFormat class</li> <li>gui: add app method</li> <li>gui: add TextFrameFormat class</li> <li>Application: add get_font method</li> <li>add qthelp module</li> <li>quick: add QuickPaintedItem class</li> <li>gui: add TextBlockGroup class</li> <li>TextCharFormat: add get/set_vertical_alignment methods</li> <li>TextBlock: add contains method</li> <li>PaintDevice: add get_metric method</li> <li>GuiApplication: add get/set_layout_direction methods</li> <li>gui: add TextObject / TextLength / TextFrame / TextFormat classes</li> <li>core: add ItemSelection class</li> <li>GraphicsLayout: add set_margin method</li> </ul>"},{"location":"changelog.html#fix_89","title":"Fix","text":"<ul> <li>correctly add items for GraphicsGridLayout</li> </ul>"},{"location":"changelog.html#v01340-2020-11-23","title":"v0.134.0 (2020-11-23)","text":""},{"location":"changelog.html#feat_84","title":"Feat","text":"<ul> <li>core: add PersistentModelIndex class</li> <li>core: add PluginLoader class</li> <li>core: add Library class</li> <li>gui: add PainterPathStroker class</li> <li>gui: add ImageWriter / ImageReader / ImageIOHandler classes</li> <li>quick: add QuickItem / QuickWindow classes</li> <li>core: add install_message_handler method</li> <li>gui: add RasterWindow / PaintDeviceWindow / OpenGLWindow classes</li> <li>svg: add SvgGenerator class</li> <li>SplashScreen: allow pixmap for ctor</li> <li>icon: add get_available_sizes method</li> <li>widget: add set_attributes method</li> <li>gui: add Vector4D / Matrix4x4 classes</li> <li>custom_widgets: add StarDelegate class</li> <li>custom_delegates: add ProgressBarDelegate class</li> <li>widgets: add missing StyleOption classes</li> <li>WidgetItems: some more methods</li> <li>Painter: add backup_state contextmanager</li> </ul>"},{"location":"changelog.html#fix_90","title":"Fix","text":"<ul> <li>KeySequenceEdit: correct repr</li> <li>correct coloring for WaitingSpinner</li> </ul>"},{"location":"changelog.html#v01331-2020-11-16","title":"v0.133.1 (2020-11-16)","text":""},{"location":"changelog.html#fix_91","title":"Fix","text":"<ul> <li>test fix</li> </ul>"},{"location":"changelog.html#v01330-2020-11-16","title":"v0.133.0 (2020-11-16)","text":""},{"location":"changelog.html#feat_85","title":"Feat","text":"<ul> <li>ComboBox: default param for add_items</li> <li>AbstractItemModel: add force_reset/force_layoutchange methods</li> <li>add location module</li> <li>gui: add FontMetricsF class</li> <li>GeoCoordinate: add bool method</li> <li>FontMetrics: add get_(tight_)bounding_rect methods</li> <li>Url: add to_string method</li> <li>network: add LocalServer / TcpServer classes</li> <li>multimediawidgets: add GraphicsVideoItem class</li> <li>mediaobject: add get_availability method</li> <li>add qt module</li> </ul>"},{"location":"changelog.html#v01321-2020-11-07","title":"v0.132.1 (2020-11-07)","text":""},{"location":"changelog.html#fix_92","title":"Fix","text":"<ul> <li>import fix</li> </ul>"},{"location":"changelog.html#v01320-2020-11-07","title":"v0.132.0 (2020-11-07)","text":""},{"location":"changelog.html#feat_86","title":"Feat","text":"<ul> <li>NetworkAccessManager: allow str for request</li> <li>network: add UdpSocket</li> <li>network: add NetworkAddressEntry / NetworkInterface classes</li> <li>add texttospeech module</li> <li>network: add NetworkDatagram class</li> <li>core: add DeadlineTimer class</li> <li>network: add HostAddress/AbstractSocket/TcpSocket classes</li> <li>network: add NetworkProxy class</li> <li>network: add HttpMultiPart class</li> <li>network: add HttpPart class</li> <li>NetworkRequest: add set/get_header methods</li> </ul>"},{"location":"changelog.html#v01310-2020-11-04","title":"v0.131.0 (2020-11-04)","text":""},{"location":"changelog.html#feat_87","title":"Feat","text":"<ul> <li>webenginecore: add WebEngineHttpRequest class</li> <li>webenginewidgets: add WebEngineContextMenuData class</li> <li>webenginewidgets: add WebEngineScriptCollection class</li> <li>multimedia: add CameraExposure/CameraImageProcessing classes</li> <li>multimedia: add CameraFocus(Zone) classes</li> <li>webenginecore: add WebEngineUrlSchemeHandler</li> </ul>"},{"location":"changelog.html#v01300-2020-11-04","title":"v0.130.0 (2020-11-04)","text":""},{"location":"changelog.html#feat_88","title":"Feat","text":"<ul> <li>WebEnginePage: add some settings methods</li> <li>webenginewidgets: add WebEngineSettings class</li> <li>add bluetooth module</li> <li>core: add Uuid class</li> <li>add quick module</li> <li>gui: add Surface and Window class</li> <li>multimedia: add ImageEncoderSettings</li> <li>multimedia: add MediaTimeRange and MediaTimeInterval classes</li> </ul>"},{"location":"changelog.html#v01291-2020-10-29","title":"v0.129.1 (2020-10-29)","text":""},{"location":"changelog.html#fix_93","title":"Fix","text":"<ul> <li>fix tests</li> <li>fix multimedia tests for Travis</li> </ul>"},{"location":"changelog.html#feat_89","title":"Feat","text":"<ul> <li>charts: add Legend class</li> <li>WebEnginePage: add get_history method</li> <li>qml: add JSValue(Iterator) class</li> <li>VideoWidget: option for fullscreen toggling via double click</li> <li>multimedia: add CameraViewFinderSettings</li> <li>multimedia: add VideoFrame class</li> <li>multimedia: add AbstractPlanarVideoBuffer class</li> <li>multimedia: add AbstractVideoBuffer class</li> <li>multimedia: add Camera class</li> <li>multimedia: add CameraInfo class</li> <li>gui: add Clipboard class</li> <li>multimedia: add AudioFormat class</li> <li>multimedia: add SoundEffect class</li> <li>charts: add PieSlice class</li> <li>charts: add BoxSet and CandlestickSet classes</li> <li>charts: add Axis-related classes</li> <li>charts: add BarSeries-related classes</li> </ul>"},{"location":"changelog.html#v01281-2020-10-25","title":"v0.128.1 (2020-10-25)","text":""},{"location":"changelog.html#fix_94","title":"Fix","text":"<ul> <li>import fix</li> </ul>"},{"location":"changelog.html#v01280-2020-10-25","title":"v0.128.0 (2020-10-25)","text":""},{"location":"changelog.html#feat_90","title":"Feat","text":"<ul> <li>custom_widgets: add ExpandableLine class</li> <li>ParallelAnimationGroup: add set_duration method</li> <li>charts: add Abstract/ValueAxis and PolarChart classes</li> <li>core: add SequentialAnimationGroup class</li> <li>AnimationGroup: allow slicing for indexing</li> <li>AnimationGroup: add add_property_animation method</li> <li>ChartView: add get/set_rubber_band methods</li> <li>Chart: add some more methods</li> <li>core: add Locale class</li> <li>core: add Margins class</li> <li>webenginewidgets: add some more modules</li> </ul>"},{"location":"changelog.html#fix_95","title":"Fix","text":"<ul> <li>Chart: properly inherit from GraphicsWidget</li> </ul>"},{"location":"changelog.html#v01271-2020-10-20","title":"v0.127.1 (2020-10-20)","text":""},{"location":"changelog.html#fix_96","title":"Fix","text":"<ul> <li>fix tests</li> </ul>"},{"location":"changelog.html#v01270-2020-10-20","title":"v0.127.0 (2020-10-20)","text":""},{"location":"changelog.html#fix_97","title":"Fix","text":"<ul> <li>always import correct bindings for winextras module</li> <li>Url: allow initializing without arg</li> </ul>"},{"location":"changelog.html#feat_91","title":"Feat","text":"<ul> <li>PainterPath: add set_fill_rule method</li> <li>PainterPath: add get_bounding_rect method</li> <li>GraphicsItem: add get_shape method</li> <li>MediaPlaylist: add get_media_url method</li> <li>start with webenginecore module</li> <li>core: add EventLoop class</li> <li>Widget: add get_font_info method</li> <li>custom_models: add PlaylistModel</li> <li>Translator: add get_file_path method</li> <li>add positioning module</li> <li>add some first QtQml classes</li> <li>core: add LibraryInfo class</li> <li>Application: add iter method</li> <li>Application: add get/set_navigation_mode methods</li> <li>Application: add get/is_effect_enabled methods</li> <li>custom_widgets: add Player class</li> </ul>"},{"location":"changelog.html#v01260-2020-10-08","title":"v0.126.0 (2020-10-08)","text":""},{"location":"changelog.html#feat_92","title":"Feat","text":"<ul> <li>core: add Process class</li> <li>DateTime: add get/set_time_spec and get_date/time methods</li> <li>core: add Time class</li> <li>DateTime: add timezone methods</li> <li>core: add TimeZone class</li> <li>Pixmap: add create_dot classmethod</li> </ul>"},{"location":"changelog.html#v01251-2020-10-07","title":"v0.125.1 (2020-10-07)","text":""},{"location":"changelog.html#fix_98","title":"Fix","text":"<ul> <li>import fix</li> </ul>"},{"location":"changelog.html#v01250-2020-10-07","title":"v0.125.0 (2020-10-07)","text":""},{"location":"changelog.html#feat_93","title":"Feat","text":"<ul> <li>widgets: add Transition classes</li> <li>core: add Transition classes</li> </ul>"},{"location":"changelog.html#fix_99","title":"Fix","text":"<ul> <li>fix Action.get_shortcut for NoneValue</li> </ul>"},{"location":"changelog.html#v01240-2020-10-05","title":"v0.124.0 (2020-10-05)","text":""},{"location":"changelog.html#feat_94","title":"Feat","text":"<ul> <li>IODevice: add get_open_mode method</li> <li>Improve repr and add str method for Date and DateTime</li> <li>core: add TemporaryFile class</li> <li>FileDevice: add set/get_file_time methods</li> <li>MainWindow: allow setting central widget to None</li> <li>AbstractButton: add get_shortcut method</li> <li>Url: add from_user_input method</li> <li>WebEngineView: add get_url method</li> <li>FileInfo: support pathlib + add proper repr</li> <li>KeySequence: allow initializing with standard keys</li> </ul>"},{"location":"changelog.html#v01231-2020-09-29","title":"v0.123.1 (2020-09-29)","text":""},{"location":"changelog.html#fix_100","title":"Fix","text":"<ul> <li>add missing State import in core module</li> </ul>"},{"location":"changelog.html#v01230-2020-09-29","title":"v0.123.0 (2020-09-29)","text":""},{"location":"changelog.html#feat_95","title":"Feat","text":"<ul> <li>core: add State classes</li> <li>core: add TextBoundaryFinder class</li> <li>ProgressBar: add get/set_orientation methods + serialize work</li> <li>Action: allow setting callback with ctor</li> <li>WebEngineView: set subclassed WebEnginePage by default</li> <li>WebEnginePage: add some more methods and constants</li> <li>AbstractSlider: add get/set_orientation methods</li> <li>core: add FileInfo class</li> <li>webenginewidgets: add WebEngineProfile class</li> </ul>"},{"location":"changelog.html#v01221-2020-09-27","title":"v0.122.1 (2020-09-27)","text":""},{"location":"changelog.html#fix_101","title":"Fix","text":"<ul> <li>use correct icon names</li> </ul>"},{"location":"changelog.html#v01220-2020-09-27","title":"v0.122.0 (2020-09-27)","text":""},{"location":"changelog.html#feat_96","title":"Feat","text":"<ul> <li>gui: add PageLayout</li> <li>gui: add Movie class</li> <li>gui: add PageSize class</li> <li>gui: add FontInfo class</li> <li>core: add UrlQuery class</li> <li>add network module</li> <li>PropertyAnimation: add get/set_property_name methods</li> <li>core: add ParallelAnimationGroup</li> <li>widgets: add SizeGrip class</li> <li>widgets: add DataWidgetMapper class</li> <li>core: add StringListModel</li> <li>VersionNumber: add get_python_version</li> <li>gui: add Transform class</li> <li>Painter: add draw_polygon method</li> <li>add core.ByteArray</li> </ul>"},{"location":"changelog.html#v01210-2020-09-10","title":"v0.121.0 (2020-09-10)","text":""},{"location":"changelog.html#feat_97","title":"Feat","text":"<ul> <li>Image: add setitem / getitem methods</li> <li>Line/LineF: add reversed and abs methods</li> <li>GraphicsScene: add get/set_item_index_method method</li> </ul>"},{"location":"changelog.html#fix_102","title":"Fix","text":"<ul> <li>serialization fixes</li> </ul>"},{"location":"changelog.html#v01200-2020-08-27","title":"v0.120.0 (2020-08-27)","text":""},{"location":"changelog.html#feat_98","title":"Feat","text":"<ul> <li>GraphicsWidget: add set_layout method</li> <li>GraphicsLayout: add some magic methods</li> <li>GraphicsScene: add add_item_group method</li> <li>widgets: add GraphicsAnchorLayout / GraphicsGridLayout / GraphicsLinearLayout</li> <li>widgets: add GraphicsItemGroup</li> <li>Layout: add delitem method</li> <li>Polygon/PolygonF: add repr and iter methods</li> <li>PainterPath: some additional methods</li> <li>GraphicsItems: add repr methods</li> <li>Line/LineF: add repr and iter</li> <li>Application: allow loading included language files via load_language_file</li> <li>widgets: add GraphicsView class</li> </ul>"},{"location":"changelog.html#refactor","title":"Refactor","text":"<ul> <li>PromptLineEdit rework</li> </ul>"},{"location":"changelog.html#v01191-2020-08-24","title":"v0.119.1 (2020-08-24)","text":""},{"location":"changelog.html#fix_103","title":"Fix","text":"<ul> <li>add missing StyleOptionComplex class</li> </ul>"},{"location":"changelog.html#v01190-2020-08-24","title":"v0.119.0 (2020-08-24)","text":""},{"location":"changelog.html#feat_99","title":"Feat","text":"<ul> <li>GraphicsScene: add some convenience methods</li> <li>widgets: add graphicsitem classes</li> <li>StylePainter: add draw_complex_control method</li> <li>gui: allow pickling some more classes</li> <li>core: add LineF class</li> <li>Widget: add get_palette() method</li> <li>widgets: add GraphicsPixmapItem / GraphicsScene</li> <li>GraphicsItem: add getitem and setitem methods</li> <li>widgets: add Blur/Colorize/DropShadowEffect</li> </ul>"},{"location":"changelog.html#fix_104","title":"Fix","text":"<ul> <li>Graphicsitem collides methods fix</li> <li>KeySequence: pickling</li> </ul>"},{"location":"changelog.html#v01182-2020-08-17","title":"v0.118.2 (2020-08-17)","text":""},{"location":"changelog.html#fix_105","title":"Fix","text":"<ul> <li>Fix tests</li> </ul>"},{"location":"changelog.html#v01181-2020-08-17","title":"v0.118.1 (2020-08-17)","text":""},{"location":"changelog.html#fix_106","title":"Fix","text":"<ul> <li>MenuBar: fix add method</li> </ul>"},{"location":"changelog.html#v01180-2020-08-17","title":"v0.118.0 (2020-08-17)","text":""},{"location":"changelog.html#refactor_1","title":"Refactor","text":"<ul> <li>MenuBar: return subclassed types instead of qt classes</li> </ul>"},{"location":"changelog.html#feat_100","title":"Feat","text":"<ul> <li>gui: add TextDocument / TextBlock / TextOption</li> <li>gui: add ConicalGradient / RadialGradient</li> <li>custom_widgets: add CollapsibleFrame</li> <li>GraphicsItem: add some more methods</li> </ul>"},{"location":"changelog.html#v01170-2020-08-16","title":"v0.117.0 (2020-08-16)","text":""},{"location":"changelog.html#feat_101","title":"Feat","text":"<ul> <li>MimeData: add dict-like interface</li> <li>Timer: add get/set_type methods</li> <li>File: add repr and str methods</li> <li>Dir: add repr and truediv methods</li> <li>Frame: set/get_frame_shape, set/get_frame_shadow</li> <li>Splitter: add setitem method, and some more typing</li> <li>Polygon/PolygonF: pythonize</li> <li>core: add Abstract/Variant/PropertyAnimation and AnimationGroup</li> <li>core: add EasingCurve</li> <li>StyleOptionSlider: add get_orientation method</li> </ul>"},{"location":"changelog.html#refactor_2","title":"Refactor","text":"<ul> <li>SpanSlider: clean up code</li> </ul>"},{"location":"changelog.html#v01160-2020-08-13","title":"v0.116.0 (2020-08-13)","text":""},{"location":"changelog.html#feat_102","title":"Feat","text":"<ul> <li>gui: add LinearGradient</li> <li>AbstractSlider: add get/set_repeat_action and trigger_action methods</li> <li>TabWidget: add get/set_tab_position methods</li> <li>Image/Pixmap: add bool method</li> <li>MenuBar: serialize stuff</li> <li>MdiArea: serialize stuff</li> <li>Brush: allow pickling + add get_texture_image method</li> <li>custom_widgets: add Timeline</li> <li>Pen: add methods for setting and getting style / join style / cap style</li> </ul>"},{"location":"changelog.html#refactor_3","title":"Refactor","text":"<ul> <li>Painter: rework set_pen / get_pen</li> </ul>"},{"location":"changelog.html#v01150-2020-08-12","title":"v0.115.0 (2020-08-12)","text":""},{"location":"changelog.html#feat_103","title":"Feat","text":"<ul> <li>Polygon: add add_points method</li> <li>Object: add store_widget_states / restore_widget_states</li> <li>Painter: add paint_on, set_transparent_background, set_brush</li> <li>PainterPath: add add_rect method</li> <li>Application: add class_getitem</li> </ul>"},{"location":"changelog.html#fix_107","title":"Fix","text":"<ul> <li>RegexEditor: correctly initialize dialog</li> </ul>"},{"location":"changelog.html#v01141-2020-08-12","title":"v0.114.1 (2020-08-12)","text":""},{"location":"changelog.html#fix_108","title":"Fix","text":"<ul> <li>HeaderView: fix saving state</li> </ul>"},{"location":"changelog.html#v01140-2020-08-12","title":"v0.114.0 (2020-08-12)","text":""},{"location":"changelog.html#refactor_4","title":"Refactor","text":"<ul> <li>use AutoSlot decorator</li> </ul>"},{"location":"changelog.html#feat_104","title":"Feat","text":"<ul> <li>add autoslot decorator</li> <li>add prettyqt.debug</li> </ul>"},{"location":"changelog.html#v01130-2020-08-10","title":"v0.113.0 (2020-08-10)","text":""},{"location":"changelog.html#feat_105","title":"Feat","text":"<ul> <li>gui: add PainterPath class</li> <li>gui: add Polygon class</li> <li>gui: palette improvements</li> <li>core: add Line class</li> <li>core: add TransposeProxyModel / ConcatenateTablesProxyModel</li> <li>add ObjectBrowser</li> <li>widgets: add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect</li> <li>Action: \"checked\" param for ctor</li> <li>gui: some magic methods + get_matches for KeySequence</li> <li>core: allow pickling VersionNumber / Size / Dir</li> <li>gui: add Gradient class</li> <li>add ColumnItemModel / ColumnItem</li> <li>Settings: add set_values method</li> <li>Widget: spacing kwarg for set_layout</li> </ul>"},{"location":"changelog.html#refactor_5","title":"Refactor","text":"<ul> <li>add serialization stuff</li> <li>improve some repr methods</li> </ul>"},{"location":"changelog.html#v01120-2020-08-04","title":"v0.112.0 (2020-08-04)","text":""},{"location":"changelog.html#feat_106","title":"Feat","text":"<ul> <li>utils: add install_exceptionhook method</li> <li>FileSystemModel: add some more shortcuts for set_root_path</li> <li>core: add VersionNumber class</li> <li>Application: add get_icon method</li> <li>MessageBox: add show_exception method</li> </ul>"},{"location":"changelog.html#refactor_6","title":"Refactor","text":"<ul> <li>improve compat with older Qt Versions</li> </ul>"},{"location":"changelog.html#fix_109","title":"Fix","text":"<ul> <li>another test fix</li> </ul>"},{"location":"changelog.html#v01111-2020-08-03","title":"v0.111.1 (2020-08-03)","text":""},{"location":"changelog.html#fix_110","title":"Fix","text":"<ul> <li>fix tests for Linux</li> </ul>"},{"location":"changelog.html#v01110-2020-08-03","title":"v0.111.0 (2020-08-03)","text":""},{"location":"changelog.html#feat_107","title":"Feat","text":"<ul> <li>widgets: add FontComboBox</li> <li>StandardPaths: add class_getitem method</li> <li>Action: some more ctor kwargs</li> <li>Action: add get/set_menu_role methods, some pickle work</li> </ul>"},{"location":"changelog.html#refactor_7","title":"Refactor","text":"<ul> <li>custom Exception for wrong params</li> </ul>"},{"location":"changelog.html#fix_111","title":"Fix","text":"<ul> <li>Menu: disable separator widgetAction</li> </ul>"},{"location":"changelog.html#v01102-2020-08-03","title":"v0.110.2 (2020-08-03)","text":""},{"location":"changelog.html#fix_112","title":"Fix","text":"<ul> <li>fix broken LogTextEdit</li> </ul>"},{"location":"changelog.html#v01101-2020-08-03","title":"v0.110.1 (2020-08-03)","text":""},{"location":"changelog.html#fix_113","title":"Fix","text":"<ul> <li>LogTextEdit: improve exception handling</li> <li>SidebarWidget: some fixes related to set_marker</li> </ul>"},{"location":"changelog.html#v01100-2020-08-02","title":"v0.110.0 (2020-08-02)","text":""},{"location":"changelog.html#refactor_8","title":"Refactor","text":"<ul> <li>improve serialization for listitems</li> <li>Validator pickle work</li> </ul>"},{"location":"changelog.html#feat_108","title":"Feat","text":"<ul> <li>Image: allow pickling</li> <li>DataStream: add create_bytearray / write_bytearray / copy_data methods</li> <li>core: add DataStream class</li> </ul>"},{"location":"changelog.html#v01090-2020-08-02","title":"v0.109.0 (2020-08-02)","text":""},{"location":"changelog.html#feat_109","title":"Feat","text":"<ul> <li>widget: add pretty method for devtools</li> <li>GridLayout: allow adding tuples/lists</li> </ul>"},{"location":"changelog.html#refactor_9","title":"Refactor","text":"<ul> <li>rework widget pickling</li> <li>move CheckboxDelegate to custom_delegates</li> <li>pickle stuff for undocommand</li> </ul>"},{"location":"changelog.html#v01080-2020-07-31","title":"v0.108.0 (2020-07-31)","text":""},{"location":"changelog.html#feat_110","title":"Feat","text":"<ul> <li>custom_delegates: add IconDelegate and NoFocusDelegate</li> <li>TableWidet: add getitem and setitem methods</li> <li>Icon: add from_image method</li> <li>allow str for layout.getitem (uses objectName)</li> <li>SidebarWidget: add set_marker method</li> </ul>"},{"location":"changelog.html#refactor_10","title":"Refactor","text":"<ul> <li>move delegates to separate module</li> </ul>"},{"location":"changelog.html#v01070-2020-07-29","title":"v0.107.0 (2020-07-29)","text":""},{"location":"changelog.html#feat_111","title":"Feat","text":"<ul> <li>GridLayout: also allow adding LayoutItems via add method</li> </ul>"},{"location":"changelog.html#v01061-2020-07-29","title":"v0.106.1 (2020-07-29)","text":""},{"location":"changelog.html#fix_114","title":"Fix","text":"<ul> <li>TabWidget: correctly close detached tabs on app close</li> <li>pickle fixes for toolbar and dockwidget</li> <li>PygmentsHighlighter: catch pygments KeyError</li> </ul>"},{"location":"changelog.html#v01060-2020-07-26","title":"v0.106.0 (2020-07-26)","text":""},{"location":"changelog.html#feat_112","title":"Feat","text":"<ul> <li>gui: add DesktopServices class</li> <li>multimedia: add AudioRecorder class</li> <li>core: add StandardPaths class</li> <li>widgets: add Undo classes</li> </ul>"},{"location":"changelog.html#v01050-2020-07-24","title":"v0.105.0 (2020-07-24)","text":""},{"location":"changelog.html#feat_113","title":"Feat","text":"<ul> <li>MediaRecorder: some new methods</li> <li>sort_by_column for tableview and treeview</li> <li>multimedia: dict-setter and getter for encodersettings</li> </ul>"},{"location":"changelog.html#refactor_11","title":"Refactor","text":"<ul> <li>improve Url-Pathlib interoperability</li> </ul>"},{"location":"changelog.html#fix_115","title":"Fix","text":"<ul> <li>PopupInfo: use PrimaryScreen geometry instead of screens[0] for positioning</li> </ul>"},{"location":"changelog.html#v01040-2020-07-23","title":"v0.104.0 (2020-07-23)","text":""},{"location":"changelog.html#feat_114","title":"Feat","text":"<ul> <li>multimedia: add MediaRecorder</li> <li>AbstractItemModel: add getitem method</li> <li>multimedia: add VideoEncoderSettings / AudioEncoderSettings</li> </ul>"},{"location":"changelog.html#refactor_12","title":"Refactor","text":"<ul> <li>use subclassed core.Size</li> </ul>"},{"location":"changelog.html#v01030-2020-07-22","title":"v0.103.0 (2020-07-22)","text":""},{"location":"changelog.html#feat_115","title":"Feat","text":"<ul> <li>ActionGroup: add getitem method</li> <li>MediaContent: add get_url method</li> <li>add multimediawidgets module</li> <li>add multimedia module</li> <li>PlainTextEdit: add allow_wheel_zoom method</li> <li>Object: name kwarg for find_parent method</li> </ul>"},{"location":"changelog.html#v01020-2020-07-21","title":"v0.102.0 (2020-07-21)","text":""},{"location":"changelog.html#refactor_13","title":"Refactor","text":"<ul> <li>move raise_dock to from Widget to Object</li> <li>SidebarWidget: some code cleanup, make settings button size configurable</li> <li>Widget: default state to True for set_attribute</li> <li>MainWindow: add return value for load_window_state</li> </ul>"},{"location":"changelog.html#feat_116","title":"Feat","text":"<ul> <li>Object: add find_parent method</li> <li>PlainTextEdit: add style kwarg to set_syntaxhighlighter</li> </ul>"},{"location":"changelog.html#v01011-2020-07-20","title":"v0.101.1 (2020-07-20)","text":""},{"location":"changelog.html#fix_116","title":"Fix","text":"<ul> <li>LogTextEdit: better integrate with custom qstylesheets</li> </ul>"},{"location":"changelog.html#v01010-2020-07-20","title":"v0.101.0 (2020-07-20)","text":""},{"location":"changelog.html#feat_117","title":"Feat","text":"<ul> <li>MessageBox: add detail_text keyword argument to message method</li> </ul>"},{"location":"changelog.html#fix_117","title":"Fix","text":"<ul> <li>correct return type for gui.icon.get_icon</li> </ul>"},{"location":"changelog.html#v01000-2020-07-20","title":"v0.100.0 (2020-07-20)","text":""},{"location":"changelog.html#feat_118","title":"Feat","text":"<ul> <li>ToolTip: add show_text method</li> <li>GuiApplication: add set_override_cursor / restore_override_cursor methods</li> <li>GuiApplication: add override_cursor context manager</li> </ul>"},{"location":"changelog.html#v0990-2020-07-18","title":"v0.99.0 (2020-07-18)","text":""},{"location":"changelog.html#refactor_14","title":"Refactor","text":"<ul> <li>FileChooserButton: typing and fixes</li> <li>Dataset: typing and fixes</li> <li>SidebarWidget: use button map instead of attaching button to widget</li> </ul>"},{"location":"changelog.html#feat_119","title":"Feat","text":"<ul> <li>AbstractItemView: add scroll_to method</li> </ul>"},{"location":"changelog.html#v0985-2020-07-17","title":"v0.98.5 (2020-07-17)","text":""},{"location":"changelog.html#perf","title":"Perf","text":"<ul> <li>add icon cache</li> </ul>"},{"location":"changelog.html#refactor_15","title":"Refactor","text":"<ul> <li>use core.Settings for windows dark mode detection</li> </ul>"},{"location":"changelog.html#v0984-2020-07-15","title":"v0.98.4 (2020-07-15)","text":""},{"location":"changelog.html#fix_118","title":"Fix","text":"<ul> <li>use qta default icon color instead of black for default</li> </ul>"},{"location":"changelog.html#v0983-2020-07-15","title":"v0.98.3 (2020-07-15)","text":""},{"location":"changelog.html#refactor_16","title":"Refactor","text":"<ul> <li>properly set stylesheets by using contextmanager</li> <li>FontDialog: do not override current_font contextmanager</li> <li>move current_font context manager to Widget class</li> </ul>"},{"location":"changelog.html#v0982-2020-07-15","title":"v0.98.2 (2020-07-15)","text":""},{"location":"changelog.html#fix_119","title":"Fix","text":"<ul> <li>package name</li> </ul>"},{"location":"changelog.html#v0981-2020-07-15","title":"v0.98.1 (2020-07-15)","text":""},{"location":"changelog.html#fix_120","title":"Fix","text":"<ul> <li>correctly reset stylesheet for widget validation background</li> </ul>"},{"location":"changelog.html#refactor_17","title":"Refactor","text":"<ul> <li>use qstylizer for stylesheet editing</li> </ul>"},{"location":"changelog.html#v0980-2020-07-15","title":"v0.98.0 (2020-07-15)","text":""},{"location":"changelog.html#feat_120","title":"Feat","text":"<ul> <li>widgets: add StyleFactory</li> </ul>"},{"location":"changelog.html#refactor_18","title":"Refactor","text":"<ul> <li>FontDatabase: make add_fonts_from_folder a classmethod</li> </ul>"},{"location":"changelog.html#v0970-2020-07-15","title":"v0.97.0 (2020-07-15)","text":""},{"location":"changelog.html#feat_121","title":"Feat","text":"<ul> <li>gui: add FontDatabase</li> <li>widgets: add Completer</li> <li>widgets: add ActionGroup</li> </ul>"},{"location":"changelog.html#v0960-2020-07-14","title":"v0.96.0 (2020-07-14)","text":""},{"location":"changelog.html#feat_122","title":"Feat","text":"<ul> <li>SelectionWidget: default keyword argument for add_custom</li> </ul>"},{"location":"changelog.html#v0950-2020-07-14","title":"v0.95.0 (2020-07-14)","text":""},{"location":"changelog.html#feat_123","title":"Feat","text":"<ul> <li>SelectionWidget: different options for custom type</li> <li>add PagedPaintDevice</li> <li>Widget: add set_margin method</li> </ul>"},{"location":"changelog.html#v0940-2020-07-14","title":"v0.94.0 (2020-07-14)","text":""},{"location":"changelog.html#feat_124","title":"Feat","text":"<ul> <li>Widget: add Widget.font_metrics()</li> <li>SpacerItem: allow strings for size policy in ctor</li> <li>allow Mapping for listwidget.add_items</li> </ul>"},{"location":"changelog.html#refactor_19","title":"Refactor","text":"<ul> <li>change to {value: label} dicts for FlagSelectionWidget.add_items</li> </ul>"},{"location":"changelog.html#v0931-2020-07-14","title":"v0.93.1 (2020-07-14)","text":""},{"location":"changelog.html#refactor_20","title":"Refactor","text":"<ul> <li>typecheck for Mapping instead of dict for combobox / selectionwidget add_items method</li> </ul>"},{"location":"changelog.html#v0930-2020-07-14","title":"v0.93.0 (2020-07-14)","text":""},{"location":"changelog.html#feat_125","title":"Feat","text":"<ul> <li>add register_extensions function to settings module</li> </ul>"},{"location":"changelog.html#refactor_21","title":"Refactor","text":"<ul> <li>Settings: do not override value method</li> </ul>"},{"location":"changelog.html#v0921-2020-07-14","title":"v0.92.1 (2020-07-14)","text":""},{"location":"changelog.html#fix_121","title":"Fix","text":"<ul> <li>winextras test fix</li> </ul>"},{"location":"changelog.html#v0920-2020-07-14","title":"v0.92.0 (2020-07-14)","text":""},{"location":"changelog.html#feat_126","title":"Feat","text":"<ul> <li>add widgets.SystemTrayIcon</li> <li>add winextras module</li> <li>Label: set_indent method</li> </ul>"},{"location":"changelog.html#v0910-2020-07-13","title":"v0.91.0 (2020-07-13)","text":""},{"location":"changelog.html#feat_127","title":"Feat","text":"<ul> <li>SidebarWidget: allow choosing layout</li> <li>MainWindow: add show_blocking method</li> </ul>"},{"location":"changelog.html#v0900-2020-07-13","title":"v0.90.0 (2020-07-13)","text":""},{"location":"changelog.html#feat_128","title":"Feat","text":"<ul> <li>Toolbar: allow combinations of allowed areas for set_allowed_areas</li> <li>SidebarWidget: add optional settings menu</li> </ul>"},{"location":"changelog.html#v0891-2020-07-13","title":"v0.89.1 (2020-07-13)","text":""},{"location":"changelog.html#refactor_22","title":"Refactor","text":"<ul> <li>SelectionWidget: switch to {data: label} dicts for add_items to be in line with RadioButton</li> </ul>"},{"location":"changelog.html#v0890-2020-07-13","title":"v0.89.0 (2020-07-13)","text":""},{"location":"changelog.html#feat_129","title":"Feat","text":"<ul> <li>SidebarWidget: make button width configurable</li> </ul>"},{"location":"changelog.html#v0881-2020-07-13","title":"v0.88.1 (2020-07-13)","text":""},{"location":"changelog.html#refactor_23","title":"Refactor","text":"<ul> <li>ComboBox: use set_data for set_value</li> </ul>"},{"location":"changelog.html#fix_122","title":"Fix","text":"<ul> <li>ComboBox: fix add_items method</li> </ul>"},{"location":"changelog.html#v0880-2020-07-13","title":"v0.88.0 (2020-07-13)","text":""},{"location":"changelog.html#feat_130","title":"Feat","text":"<ul> <li>ComboBox: set_data method</li> </ul>"},{"location":"changelog.html#v0870-2020-07-13","title":"v0.87.0 (2020-07-13)","text":""},{"location":"changelog.html#feat_131","title":"Feat","text":"<ul> <li>ComboBox: allow dict for add_items</li> </ul>"},{"location":"changelog.html#v0863-2020-07-12","title":"v0.86.3 (2020-07-12)","text":""},{"location":"changelog.html#refactor_24","title":"Refactor","text":"<ul> <li>RegexEditor: code cleanup</li> </ul>"},{"location":"changelog.html#v0862-2020-07-12","title":"v0.86.2 (2020-07-12)","text":""},{"location":"changelog.html#fix_123","title":"Fix","text":"<ul> <li>another deployment fix</li> </ul>"},{"location":"changelog.html#v0861-2020-07-12","title":"v0.86.1 (2020-07-12)","text":""},{"location":"changelog.html#fix_124","title":"Fix","text":"<ul> <li>deployment fix</li> </ul>"},{"location":"changelog.html#v0860-2020-07-12","title":"v0.86.0 (2020-07-12)","text":""},{"location":"changelog.html#feat_132","title":"Feat","text":"<ul> <li>add Scintilla CodeEditor</li> <li>PlainTextEdit: add color argument for highlight_current_line</li> </ul>"},{"location":"changelog.html#v0851-2020-07-10","title":"v0.85.1 (2020-07-10)","text":""},{"location":"changelog.html#fix_125","title":"Fix","text":"<ul> <li>add missing pygments requirement</li> </ul>"},{"location":"changelog.html#v0850-2020-07-10","title":"v0.85.0 (2020-07-10)","text":""},{"location":"changelog.html#feat_133","title":"Feat","text":"<ul> <li>dataset: add RegexPattern DataItem</li> <li>RegexEditor: use syntaxhighlighter for pattern</li> <li>RegexInput: use syntaxhighlighter for pattern</li> <li>PlainTextEdit: add set_syntaxhighlighter method</li> <li>Label: add set_color method</li> </ul>"},{"location":"changelog.html#refactor_25","title":"Refactor","text":"<ul> <li>CodeEditor: use pygments for syntax highlighting</li> </ul>"},{"location":"changelog.html#v0840-2020-07-10","title":"v0.84.0 (2020-07-10)","text":""},{"location":"changelog.html#feat_134","title":"Feat","text":"<ul> <li>sidebarwidget: allow setting tab by object id</li> <li>Object: name kwarg for Object.find_children, add Object.find_child</li> </ul>"},{"location":"changelog.html#v0831-2020-07-09","title":"v0.83.1 (2020-07-09)","text":""},{"location":"changelog.html#refactor_26","title":"Refactor","text":"<ul> <li>move set_icon from window classes to widget class</li> </ul>"},{"location":"changelog.html#v0830-2020-07-09","title":"v0.83.0 (2020-07-09)","text":""},{"location":"changelog.html#feat_135","title":"Feat","text":"<ul> <li>add Label.set_point_size</li> <li>add self for label methods to allow chaining</li> <li>Font.current_font context manager</li> </ul>"},{"location":"changelog.html#v0820-2020-07-09","title":"v0.82.0 (2020-07-09)","text":""},{"location":"changelog.html#feat_136","title":"Feat","text":"<ul> <li>add Label.set_bold / set_italic / set_weight</li> <li>added Font.set_weight</li> </ul>"},{"location":"changelog.html#v0810-2020-07-08","title":"v0.81.0 (2020-07-08)","text":""},{"location":"changelog.html#feat_137","title":"Feat","text":"<ul> <li>allow setting window icon color</li> <li>os dark mode detection</li> </ul>"},{"location":"changelog.html#v0801-2020-07-08","title":"v0.80.1 (2020-07-08)","text":""},{"location":"changelog.html#fix_126","title":"Fix","text":"<ul> <li>Settings.value() returned wrong type</li> </ul>"},{"location":"changelog.html#v0800-2020-07-08","title":"v0.80.0 (2020-07-08)","text":""},{"location":"changelog.html#feat_138","title":"Feat","text":"<ul> <li>add Widget.set_attribute</li> <li>add margin keyword argument to Widget.set_layout</li> </ul>"},{"location":"changelog.html#v0791-2020-07-08","title":"v0.79.1 (2020-07-08)","text":""},{"location":"changelog.html#fix_127","title":"Fix","text":"<ul> <li>remove Qt logger on Application exit</li> </ul>"},{"location":"changelog.html#v0790-2020-07-08","title":"v0.79.0 (2020-07-08)","text":""},{"location":"changelog.html#feat_139","title":"Feat","text":"<ul> <li>add widgets.Application.get_widget</li> </ul>"},{"location":"changelog.html#v0780-2020-07-08","title":"v0.78.0 (2020-07-08)","text":""},{"location":"changelog.html#feat_140","title":"Feat","text":"<ul> <li>allow to save/load window state recursively. Saving needs to be done explicitely now.</li> </ul>"},{"location":"changelog.html#fix_128","title":"Fix","text":"<ul> <li>some fixes for core.Settings dict interface</li> <li>properly preserve types in core.Settings</li> </ul>"},{"location":"changelog.html#v0771-2020-07-07","title":"v0.77.1 (2020-07-07)","text":""},{"location":"changelog.html#refactor_27","title":"Refactor","text":"<ul> <li>also allow qt flag for Splitter ctor</li> </ul>"},{"location":"changelog.html#fix_129","title":"Fix","text":"<ul> <li>return correct types for re.groupdict / re.groups</li> <li>Fixed an issue which prevented saving an image from chartview</li> </ul>"},{"location":"changelog.html#0770-2020-07-06","title":"0.77.0 (2020-07-06)","text":""},{"location":"changelog.html#feat_141","title":"Feat","text":"<ul> <li>allow custom icons for Messagebox</li> <li>add Icon.get_pixmap</li> <li>add Object.set_unique_id / Object.get_id</li> <li>allow None for set_max_height/width widget setters</li> <li>add checkboxdelegate</li> <li>add regexinput</li> <li>add pre-commit-hook for commit messages</li> </ul>"},{"location":"changelog.html#fix_130","title":"Fix","text":"<ul> <li>fix Messagebox.message call</li> </ul>"},{"location":"changelog.html#refactor_28","title":"Refactor","text":"<ul> <li>dont use property setter widget.id</li> <li>dont use property setter widget.title</li> <li>add child classes in re module</li> <li>radiodelegate stuff</li> <li>no props for abstractscrollarea scrollbars</li> </ul>"},{"location":"changelog.html#v0759-2020-07-05","title":"v0.75.9 (2020-07-05)","text":""},{"location":"changelog.html#v0758-2020-07-05","title":"v0.75.8 (2020-07-05)","text":""},{"location":"changelog.html#v0757-2020-07-05","title":"v0.75.7 (2020-07-05)","text":""},{"location":"changelog.html#v0756-2020-07-05","title":"v0.75.6 (2020-07-05)","text":""},{"location":"changelog.html#v0755-2020-07-05","title":"v0.75.5 (2020-07-05)","text":""},{"location":"changelog.html#v0754-2020-07-05","title":"v0.75.4 (2020-07-05)","text":""},{"location":"changelog.html#v0753-2020-07-05","title":"v0.75.3 (2020-07-05)","text":""},{"location":"changelog.html#v0752-2020-07-05","title":"v0.75.2 (2020-07-05)","text":""},{"location":"changelog.html#v0751-2020-07-05","title":"v0.75.1 (2020-07-05)","text":""},{"location":"changelog.html#v0750-2020-07-05","title":"v0.75.0 (2020-07-05)","text":""},{"location":"changelog.html#v0743-2020-07-05","title":"v0.74.3 (2020-07-05)","text":""},{"location":"changelog.html#v0742-2020-07-05","title":"v0.74.2 (2020-07-05)","text":""},{"location":"changelog.html#v0741-2020-07-05","title":"v0.74.1 (2020-07-05)","text":""},{"location":"changelog.html#v0740-2020-07-05","title":"v0.74.0 (2020-07-05)","text":""},{"location":"changelog.html#v0734-2020-07-04","title":"v0.73.4 (2020-07-04)","text":""},{"location":"changelog.html#v0733-2020-07-04","title":"v0.73.3 (2020-07-04)","text":""},{"location":"changelog.html#v0732-2020-07-04","title":"v0.73.2 (2020-07-04)","text":""},{"location":"changelog.html#v0731-2020-07-04","title":"v0.73.1 (2020-07-04)","text":""},{"location":"changelog.html#v0730-2020-07-02","title":"v0.73.0 (2020-07-02)","text":""},{"location":"changelog.html#v0723-2020-07-01","title":"v0.72.3 (2020-07-01)","text":""},{"location":"changelog.html#v0722-2020-07-01","title":"v0.72.2 (2020-07-01)","text":""},{"location":"changelog.html#v0721-2020-07-01","title":"v0.72.1 (2020-07-01)","text":""},{"location":"changelog.html#v0720-2020-07-01","title":"v0.72.0 (2020-07-01)","text":""},{"location":"changelog.html#v0710-2020-06-30","title":"v0.71.0 (2020-06-30)","text":""},{"location":"changelog.html#v0700-2020-06-30","title":"v0.70.0 (2020-06-30)","text":""},{"location":"changelog.html#v0690-2020-06-29","title":"v0.69.0 (2020-06-29)","text":""},{"location":"changelog.html#v0680-2020-06-29","title":"v0.68.0 (2020-06-29)","text":""},{"location":"changelog.html#v0671-2020-06-28","title":"v0.67.1 (2020-06-28)","text":""},{"location":"changelog.html#v0651-2020-06-24","title":"v0.65.1 (2020-06-24)","text":""},{"location":"changelog.html#v0650-2020-06-24","title":"v0.65.0 (2020-06-24)","text":""},{"location":"changelog.html#v0640-2020-06-24","title":"v0.64.0 (2020-06-24)","text":""},{"location":"changelog.html#v0630-2020-06-22","title":"v0.63.0 (2020-06-22)","text":""},{"location":"changelog.html#v0620-2020-06-21","title":"v0.62.0 (2020-06-21)","text":""},{"location":"changelog.html#v0610-2020-06-21","title":"v0.61.0 (2020-06-21)","text":""},{"location":"changelog.html#v0601-2020-06-21","title":"v0.60.1 (2020-06-21)","text":""},{"location":"changelog.html#v0600-2020-06-20","title":"v0.60.0 (2020-06-20)","text":""},{"location":"changelog.html#v0590-2020-06-20","title":"v0.59.0 (2020-06-20)","text":""},{"location":"changelog.html#v0581-2020-06-19","title":"v0.58.1 (2020-06-19)","text":""},{"location":"changelog.html#v0571-2020-06-15","title":"v0.57.1 (2020-06-15)","text":""},{"location":"changelog.html#v0570-2020-06-14","title":"v0.57.0 (2020-06-14)","text":""},{"location":"changelog.html#v0561-2020-06-10","title":"v0.56.1 (2020-06-10)","text":""},{"location":"changelog.html#v0560-2020-06-10","title":"v0.56.0 (2020-06-10)","text":""},{"location":"changelog.html#v0550-2020-06-09","title":"v0.55.0 (2020-06-09)","text":""},{"location":"changelog.html#v0540-2020-06-08","title":"v0.54.0 (2020-06-08)","text":""},{"location":"api/bluetooth.html","title":"bluetooth module","text":"<p>bluetooth module.</p> <p>contains QtBluetooth-based classes</p>"},{"location":"api/charts.html","title":"charts module","text":"<p>Charts module.</p>"},{"location":"api/charts.html#prettyqt.charts.AbstractAxisMixin","title":"<code>AbstractAxisMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\charts\\abstractaxis.py</code> <pre><code>class AbstractAxisMixin(core.ObjectMixin):\n    def get_alignment(self) -&gt; constants.SideStr | None:\n\"\"\"Return current alignment.\n\n        Returns:\n            alignment\n        \"\"\"\n        alignment = self.alignment()\n        if alignment == constants.ALIGN_NONE:\n            return None\n        return constants.SIDES.inverse[alignment]\n\n    def get_orientation(self) -&gt; constants.OrientationStr | None:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        orientation = self.orientation()\n        if orientation == constants.ORIENTATION_NONE:\n            return None\n        return constants.ORIENTATION.inverse[orientation]\n\n    def get_grid_line_color(self) -&gt; gui.Color:\n        return gui.Color(self.gridLineColor())\n\n    def get_grid_line_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.gridLinePen())\n\n    def get_line_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.linePen())\n\n    def get_line_pen_color(self) -&gt; gui.Color:\n        return gui.Color(self.linePenColor())\n\n    def get_labels_color(self) -&gt; gui.Color:\n        return gui.Color(self.labelsColor())\n\n    def get_labels_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.labelsBrush())\n\n    def get_labels_font(self) -&gt; gui.Font:\n        return gui.Font(self.labelsFont())\n\n    def get_title_font(self) -&gt; gui.Font:\n        return gui.Font(self.titleFont())\n\n    def get_title_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.titleBrush())\n\n    def get_shades_color(self) -&gt; gui.Color:\n        return gui.Color(self.shadesColor())\n\n    def get_shades_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.shadesBrush())\n\n    def get_shades_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.shadesPen())\n\n    def get_shades_border_color(self) -&gt; gui.Color:\n        return gui.Color(self.shadesBorderColor())\n\n    def get_minor_grid_line_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.minorGridLinePen())\n\n    def get_minor_grid_line_color(self) -&gt; gui.Color:\n        return gui.Color(self.minorGridLineColor())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxisMixin.get_alignment","title":"<code>get_alignment() -&gt; constants.SideStr | None</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.SideStr | None</code> <p>alignment</p> Source code in <code>prettyqt\\charts\\abstractaxis.py</code> <pre><code>def get_alignment(self) -&gt; constants.SideStr | None:\n\"\"\"Return current alignment.\n\n    Returns:\n        alignment\n    \"\"\"\n    alignment = self.alignment()\n    if alignment == constants.ALIGN_NONE:\n        return None\n    return constants.SIDES.inverse[alignment]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxisMixin.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr | None</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr | None</code> <p>orientation</p> Source code in <code>prettyqt\\charts\\abstractaxis.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr | None:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    orientation = self.orientation()\n    if orientation == constants.ORIENTATION_NONE:\n        return None\n    return constants.ORIENTATION.inverse[orientation]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.AbstractBarSeriesMixin","title":"<code>AbstractBarSeriesMixin</code>","text":"<p>         Bases: <code>charts.AbstractSeriesMixin</code></p> Source code in <code>prettyqt\\charts\\abstractbarseries.py</code> <pre><code>class AbstractBarSeriesMixin(charts.AbstractSeriesMixin):\n    def __delitem__(self, index: int):\n        barsets = self.barSets()\n        self.remove(barsets[index])\n\n    def __getitem__(self, index: int) -&gt; QtCharts.QBarSet:\n        barsets = self.barSets()\n        return barsets[index]\n\n    def set_labels_position(self, position: LabelsPositionStr):\n\"\"\"Set the labels position.\n\n        Args:\n            position: labels position\n\n        Raises:\n            InvalidParamError: labels position does not exist\n        \"\"\"\n        if position not in LABELS_POSITIONS:\n            raise InvalidParamError(position, LABELS_POSITIONS)\n        self.setLabelsPosition(LABELS_POSITIONS[position])\n\n    def get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n\n        Returns:\n            labels position\n        \"\"\"\n        return LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeriesMixin.get_labels_position","title":"<code>get_labels_position() -&gt; LabelsPositionStr</code>","text":"<p>Return current labels position.</p> <p>Returns:</p> Type Description <code>LabelsPositionStr</code> <p>labels position</p> Source code in <code>prettyqt\\charts\\abstractbarseries.py</code> <pre><code>def get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n\n    Returns:\n        labels position\n    \"\"\"\n    return LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeriesMixin.set_labels_position","title":"<code>set_labels_position(position: LabelsPositionStr)</code>","text":"<p>Set the labels position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>LabelsPositionStr</code> <p>labels position</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>labels position does not exist</p> Source code in <code>prettyqt\\charts\\abstractbarseries.py</code> <pre><code>def set_labels_position(self, position: LabelsPositionStr):\n\"\"\"Set the labels position.\n\n    Args:\n        position: labels position\n\n    Raises:\n        InvalidParamError: labels position does not exist\n    \"\"\"\n    if position not in LABELS_POSITIONS:\n        raise InvalidParamError(position, LABELS_POSITIONS)\n    self.setLabelsPosition(LABELS_POSITIONS[position])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.AbstractSeriesMixin","title":"<code>AbstractSeriesMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> <p>QAbstractSeries with some custom properties.</p> Source code in <code>prettyqt\\charts\\abstractseries.py</code> <pre><code>class AbstractSeriesMixin(core.ObjectMixin):\n\"\"\"QAbstractSeries with some custom properties.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._group = \"\"\n\n    def get_group(self):\n        return self._group\n\n    def set_group(self, value):\n        self._group = value\n\n    group = core.Property(str, get_group, set_group)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.CategoryAxis","title":"<code>CategoryAxis</code>","text":"<p>         Bases: <code>charts.ValueAxisMixin</code>, <code>QtCharts.QCategoryAxis</code></p> Source code in <code>prettyqt\\charts\\categoryaxis.py</code> <pre><code>class CategoryAxis(charts.ValueAxisMixin, QtCharts.QCategoryAxis):\n    def __delitem__(self, index: str):\n        self.remove(index)\n\n    def __getitem__(self, label: int | slice) -&gt; str | list[str]:\n        return self.categoriesLabels()[label]\n\n    def __setitem__(self, index: str, value: str):\n        self.replaceLabel(index, value)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self.categoriesLabels())\n\n    def __add__(self, other: tuple[str, int]) -&gt; CategoryAxis:\n        self.append(*other)\n        return self\n\n    def __len__(self):\n        # needed for PySide6\n        return self.count()\n\n    def set_labels_position(self, position: LabelsPositionStr):\n\"\"\"Set the labels position.\n\n        Args:\n            position: labels position\n\n        Raises:\n            InvalidParamError: labels position does not exist\n        \"\"\"\n        if position not in LABELS_POSITIONS:\n            raise InvalidParamError(position, LABELS_POSITIONS)\n        self.setLabelsPosition(LABELS_POSITIONS[position])\n\n    def get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n\n        Returns:\n            labels position\n        \"\"\"\n        return LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.get_labels_position","title":"<code>get_labels_position() -&gt; LabelsPositionStr</code>","text":"<p>Return current labels position.</p> <p>Returns:</p> Type Description <code>LabelsPositionStr</code> <p>labels position</p> Source code in <code>prettyqt\\charts\\categoryaxis.py</code> <pre><code>def get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n\n    Returns:\n        labels position\n    \"\"\"\n    return LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.set_labels_position","title":"<code>set_labels_position(position: LabelsPositionStr)</code>","text":"<p>Set the labels position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>LabelsPositionStr</code> <p>labels position</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>labels position does not exist</p> Source code in <code>prettyqt\\charts\\categoryaxis.py</code> <pre><code>def set_labels_position(self, position: LabelsPositionStr):\n\"\"\"Set the labels position.\n\n    Args:\n        position: labels position\n\n    Raises:\n        InvalidParamError: labels position does not exist\n    \"\"\"\n    if position not in LABELS_POSITIONS:\n        raise InvalidParamError(position, LABELS_POSITIONS)\n    self.setLabelsPosition(LABELS_POSITIONS[position])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.ChartMixin","title":"<code>ChartMixin</code>","text":"<p>         Bases: <code>widgets.GraphicsWidgetMixin</code></p> Source code in <code>prettyqt\\charts\\chart.py</code> <pre><code>class ChartMixin(widgets.GraphicsWidgetMixin):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.max_x = 0\n        self.max_y = 0\n        self.min_x = 0\n        self.min_y = 0\n\n    def serialize_fields(self):\n        return dict(\n            animation_duration=self.animationDuration(),\n            animation_easing_curve=self.get_animation_easing_curve(),\n            animation_options=self.get_animation_options(),\n            background_roundness=self.backgroundRoundness(),\n            background_visible=self.isBackgroundVisible(),\n            chart_type=self.get_chart_type(),\n            drop_shadow_enabled=self.isDropShadowEnabled(),\n            locale=self.get_locale(),\n            localize_numbers=self.localizeNumbers(),\n            margins=self.get_margins(),\n            plot_area=self.get_plot_area(),\n            plot_area_background_visible=self.isPlotAreaBackgroundVisible(),\n            theme=self.get_theme(),\n            title=self.title(),\n        )\n\n    def update_boundaries(self):\n\"\"\"Set new min/max values based on axis.\"\"\"\n        self.max_x = self.axisX().max()\n        self.max_y = self.axisY().max()\n        self.min_x = self.axisX().min()\n        self.min_y = self.axisY().min()\n\n    def hide_legend(self):\n        self.legend().hide()\n\n    def show_legend(self):\n        self.legend().show()\n\n    def get_legend(self) -&gt; charts.Legend:\n        return charts.Legend(self.legend())\n\n    def set_legend_alignment(self, alignment: constants.SideStr):\n        if alignment not in constants.SIDES:\n            raise InvalidParamError(alignment, constants.SIDES)\n        self.legend().setAlignment(constants.SIDES[alignment])\n\n    def set_theme(self, theme_name: ThemeStr):\n        self.setTheme(THEMES[theme_name])\n\n    def set_margins(self, margins: datatypes.MarginsType):\n        if isinstance(margins, tuple):\n            margins = QtCore.QMargins(*margins)\n        self.setMargins(margins)\n\n    def set_animation_options(self, option: AnimationOptionStr):\n        self.setAnimationOptions(ANIMATION_OPTIONS[option])\n\n    def apply_nice_numbers(self):\n\"\"\"Adjust both axis to display nice round numbers.\"\"\"\n        self.axisX().applyNiceNumbers()\n        self.axisY().applyNiceNumbers()\n\n    def zoom_by_factor(self, factor: float):\n\"\"\"Zoom in/out by factor (1.0 = no change).\n\n        Make sure that we dont zoom out too far\n        \"\"\"\n        self.zoom(factor)\n        if self.axisX().min() &lt; self.min_x:\n            self.axisX().setMin(self.min_x)\n        if self.axisX().max() &gt; self.max_x:\n            self.axisX().setMax(self.max_x)\n        if self.axisY().max() &gt; self.max_y:\n            self.axisY().setMax(self.max_y)\n\n        # always bottom-align when zooming for now. should perhaps become optional.\n        # if self.axisY().min() &lt; self.min_y:\n        self.axisY().setMin(max(0, self.min_y))\n\n    def get_chart_type(self) -&gt; ChartTypeStr:\n        return CHART_TYPES.inverse[self.chartType()]\n\n    def get_margins(self) -&gt; core.Margins:\n        return core.Margins(self.margins())\n\n    def get_plot_area(self) -&gt; core.RectF:\n        return core.RectF(self.plotArea())\n\n    def get_locale(self) -&gt; core.Locale:\n        return core.Locale(self.locale())\n\n    def get_theme(self) -&gt; ThemeStr:\n        return THEMES.inverse[self.theme()]\n\n    def get_animation_options(self) -&gt; list[AnimationOptionStr]:\n        return ANIMATION_OPTIONS.get_list(self.animationOptions())\n\n    def get_animation_easing_curve(self) -&gt; core.EasingCurve:\n        return core.EasingCurve(self.animationEasingCurve())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chart.ChartMixin.apply_nice_numbers","title":"<code>apply_nice_numbers()</code>","text":"<p>Adjust both axis to display nice round numbers.</p> Source code in <code>prettyqt\\charts\\chart.py</code> <pre><code>def apply_nice_numbers(self):\n\"\"\"Adjust both axis to display nice round numbers.\"\"\"\n    self.axisX().applyNiceNumbers()\n    self.axisY().applyNiceNumbers()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chart.ChartMixin.update_boundaries","title":"<code>update_boundaries()</code>","text":"<p>Set new min/max values based on axis.</p> Source code in <code>prettyqt\\charts\\chart.py</code> <pre><code>def update_boundaries(self):\n\"\"\"Set new min/max values based on axis.\"\"\"\n    self.max_x = self.axisX().max()\n    self.max_y = self.axisY().max()\n    self.min_x = self.axisX().min()\n    self.min_y = self.axisY().min()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chart.ChartMixin.zoom_by_factor","title":"<code>zoom_by_factor(factor: float)</code>","text":"<p>Zoom in/out by factor (1.0 = no change).</p> <p>Make sure that we dont zoom out too far</p> Source code in <code>prettyqt\\charts\\chart.py</code> <pre><code>def zoom_by_factor(self, factor: float):\n\"\"\"Zoom in/out by factor (1.0 = no change).\n\n    Make sure that we dont zoom out too far\n    \"\"\"\n    self.zoom(factor)\n    if self.axisX().min() &lt; self.min_x:\n        self.axisX().setMin(self.min_x)\n    if self.axisX().max() &gt; self.max_x:\n        self.axisX().setMax(self.max_x)\n    if self.axisY().max() &gt; self.max_y:\n        self.axisY().setMax(self.max_y)\n\n    # always bottom-align when zooming for now. should perhaps become optional.\n    # if self.axisY().min() &lt; self.min_y:\n    self.axisY().setMin(max(0, self.min_y))\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.ChartView","title":"<code>ChartView</code>","text":"<p>         Bases: <code>widgets.GraphicsViewMixin</code>, <code>QtCharts.QChartView</code></p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>class ChartView(widgets.GraphicsViewMixin, QtCharts.QChartView):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        chart = charts.Chart()\n        self.setChart(chart)\n        self.setRenderHint(gui.Painter.RenderHint.Antialiasing)\n        self.set_rubber_band(\"rectangle\")\n        # self.setDragMode(self.RubberBandDrag)\n\n    def keyPressEvent(self, event: QtGui.QKeyEvent):\n\"\"\"Handle keypress events to allow navigation via keyboard.\"\"\"\n        match event.key():\n            case QtCore.Qt.Key.Key_Escape:\n                self.chart().zoomReset()\n            case QtCore.Qt.Key.Key_Plus:\n                self.chart().zoom_by_factor(ZOOM_IN_FACTOR)\n            case QtCore.Qt.Key.Key_Minus:\n                self.chart().zoom_by_factor(ZOOM_OUT_FACTOR)\n            case QtCore.Qt.Key.Key_Left:\n                self.chart().scroll(-SCROLL_STEP_SIZE, 0)\n            case QtCore.Qt.Key.Key_Right:\n                self.chart().scroll(SCROLL_STEP_SIZE, 0)\n            case QtCore.Qt.Key.Key_Up:\n                self.chart().scroll(0, SCROLL_STEP_SIZE)\n            case QtCore.Qt.Key.Key_Down:\n                self.chart().scroll(0, -SCROLL_STEP_SIZE)\n            case QtCore.Qt.Key.Key_0:\n                self.chart().apply_nice_numbers()\n            case _:\n                super().keyPressEvent(event)\n                return\n        event.accept()\n\n    def wheelEvent(self, event: QtGui.QWheelEvent):\n\"\"\"Handle wheel event for zooming.\"\"\"\n        fct = ZOOM_IN_FACTOR if event.angleDelta().y() &gt; 0 else ZOOM_OUT_FACTOR\n        self.chart().zoom_by_factor(fct)\n\n    def mouseReleaseEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n        if event.button() == QtCore.Qt.MouseButton.RightButton:\n            widgets.Application.restoreOverrideCursor()\n            event.accept()\n            return\n        super().mouseReleaseEvent(event)\n\n    def mousePressEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n        if event.button() == QtCore.Qt.MouseButton.RightButton:\n            widgets.Application.set_override_cursor(\"size_all\")\n            self.last_mouse_pos = event.position()\n            event.accept()\n\n        super().mousePressEvent(event)\n\n    def mouseMoveEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n        # pan the chart with a middle mouse drag\n        if event.buttons() &amp; QtCore.Qt.MouseButton.RightButton:  # type: ignore\n            if not self.last_mouse_pos:\n                return\n            pos_diff = event.position() - self.last_mouse_pos\n            self.chart().scroll(-pos_diff.x(), pos_diff.y())\n\n            self.last_mouse_pos = event.position()\n            event.accept()\n\n        super().mouseMoveEvent(event)\n\n    @core.Slot()\n    def save_as_image(self):\n\"\"\"Let user choose folder and save chart as an image file.\"\"\"\n        dlg = widgets.FileDialog(mode=\"save\", caption=\"Save image\")\n        filters = {\"Bmp files\": [\".bmp\"], \"Jpeg files\": [\".jpg\"], \"Png files\": [\".png\"]}\n        dlg.set_extension_filter(filters)\n        filename = dlg.open_file()\n        if not filename:\n            return\n        self.chart().show_legend()\n        image = self.get_image()\n        image.save(str(filename[0]))\n        self.chart().hide_legend()\n\n    def set_rubber_band(self, typ: RubberBandStr):\n\"\"\"Set the rubber band type.\n\n        Args:\n            typ: rubber band type\n\n        Raises:\n            InvalidParamError: rubber band type does not exist\n        \"\"\"\n        if typ not in RUBBER_BAND:\n            raise InvalidParamError(typ, RUBBER_BAND)\n        self.setRubberBand(RUBBER_BAND[typ])\n\n    def get_rubber_band(self) -&gt; RubberBandStr:\n\"\"\"Return current rubber band type.\n\n        Returns:\n            Rubber band type\n        \"\"\"\n        return RUBBER_BAND.inverse[self.rubberBand()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.get_rubber_band","title":"<code>get_rubber_band() -&gt; RubberBandStr</code>","text":"<p>Return current rubber band type.</p> <p>Returns:</p> Type Description <code>RubberBandStr</code> <p>Rubber band type</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def get_rubber_band(self) -&gt; RubberBandStr:\n\"\"\"Return current rubber band type.\n\n    Returns:\n        Rubber band type\n    \"\"\"\n    return RUBBER_BAND.inverse[self.rubberBand()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.keyPressEvent","title":"<code>keyPressEvent(event: QtGui.QKeyEvent)</code>","text":"<p>Handle keypress events to allow navigation via keyboard.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def keyPressEvent(self, event: QtGui.QKeyEvent):\n\"\"\"Handle keypress events to allow navigation via keyboard.\"\"\"\n    match event.key():\n        case QtCore.Qt.Key.Key_Escape:\n            self.chart().zoomReset()\n        case QtCore.Qt.Key.Key_Plus:\n            self.chart().zoom_by_factor(ZOOM_IN_FACTOR)\n        case QtCore.Qt.Key.Key_Minus:\n            self.chart().zoom_by_factor(ZOOM_OUT_FACTOR)\n        case QtCore.Qt.Key.Key_Left:\n            self.chart().scroll(-SCROLL_STEP_SIZE, 0)\n        case QtCore.Qt.Key.Key_Right:\n            self.chart().scroll(SCROLL_STEP_SIZE, 0)\n        case QtCore.Qt.Key.Key_Up:\n            self.chart().scroll(0, SCROLL_STEP_SIZE)\n        case QtCore.Qt.Key.Key_Down:\n            self.chart().scroll(0, -SCROLL_STEP_SIZE)\n        case QtCore.Qt.Key.Key_0:\n            self.chart().apply_nice_numbers()\n        case _:\n            super().keyPressEvent(event)\n            return\n    event.accept()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseMoveEvent","title":"<code>mouseMoveEvent(event: QtGui.QMouseEvent)</code>","text":"<p>Override to allow dragging the chart.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def mouseMoveEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n    # pan the chart with a middle mouse drag\n    if event.buttons() &amp; QtCore.Qt.MouseButton.RightButton:  # type: ignore\n        if not self.last_mouse_pos:\n            return\n        pos_diff = event.position() - self.last_mouse_pos\n        self.chart().scroll(-pos_diff.x(), pos_diff.y())\n\n        self.last_mouse_pos = event.position()\n        event.accept()\n\n    super().mouseMoveEvent(event)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mousePressEvent","title":"<code>mousePressEvent(event: QtGui.QMouseEvent)</code>","text":"<p>Override to allow dragging the chart.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def mousePressEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n    if event.button() == QtCore.Qt.MouseButton.RightButton:\n        widgets.Application.set_override_cursor(\"size_all\")\n        self.last_mouse_pos = event.position()\n        event.accept()\n\n    super().mousePressEvent(event)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseReleaseEvent","title":"<code>mouseReleaseEvent(event: QtGui.QMouseEvent)</code>","text":"<p>Override to allow dragging the chart.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def mouseReleaseEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n    if event.button() == QtCore.Qt.MouseButton.RightButton:\n        widgets.Application.restoreOverrideCursor()\n        event.accept()\n        return\n    super().mouseReleaseEvent(event)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.save_as_image","title":"<code>save_as_image()</code>","text":"<p>Let user choose folder and save chart as an image file.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>@core.Slot()\ndef save_as_image(self):\n\"\"\"Let user choose folder and save chart as an image file.\"\"\"\n    dlg = widgets.FileDialog(mode=\"save\", caption=\"Save image\")\n    filters = {\"Bmp files\": [\".bmp\"], \"Jpeg files\": [\".jpg\"], \"Png files\": [\".png\"]}\n    dlg.set_extension_filter(filters)\n    filename = dlg.open_file()\n    if not filename:\n        return\n    self.chart().show_legend()\n    image = self.get_image()\n    image.save(str(filename[0]))\n    self.chart().hide_legend()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.set_rubber_band","title":"<code>set_rubber_band(typ: RubberBandStr)</code>","text":"<p>Set the rubber band type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>RubberBandStr</code> <p>rubber band type</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>rubber band type does not exist</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def set_rubber_band(self, typ: RubberBandStr):\n\"\"\"Set the rubber band type.\n\n    Args:\n        typ: rubber band type\n\n    Raises:\n        InvalidParamError: rubber band type does not exist\n    \"\"\"\n    if typ not in RUBBER_BAND:\n        raise InvalidParamError(typ, RUBBER_BAND)\n    self.setRubberBand(RUBBER_BAND[typ])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.wheelEvent","title":"<code>wheelEvent(event: QtGui.QWheelEvent)</code>","text":"<p>Handle wheel event for zooming.</p> Source code in <code>prettyqt\\charts\\chartview.py</code> <pre><code>def wheelEvent(self, event: QtGui.QWheelEvent):\n\"\"\"Handle wheel event for zooming.\"\"\"\n    fct = ZOOM_IN_FACTOR if event.angleDelta().y() &gt; 0 else ZOOM_OUT_FACTOR\n    self.chart().zoom_by_factor(fct)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.Legend","title":"<code>Legend</code>","text":"<p>         Bases: <code>widgets.GraphicsWidgetMixin</code></p> Source code in <code>prettyqt\\charts\\legend.py</code> <pre><code>class Legend(widgets.GraphicsWidgetMixin):\n    def __init__(self, item: QtCharts.QLegend):\n        self.item = item\n\n    def __getattr__(self, val):\n        return getattr(self.item, val)\n\n    def serialize_fields(self):\n        return dict(\n            alignment=self.get_alignment(),\n            background_visible=self.isBackgroundVisible(),\n            border_color=self.get_border_color(),\n            color=self.get_color(),\n            font=self.get_font(),\n            label_color=self.get_label_color(),\n            marker_shape=self.get_marker_shape(),\n            reverse_markers=self.reverseMarkers(),\n            show_tooltips=self.showToolTips(),\n        )\n\n    def set_alignment(self, alignment: constants.SideStr):\n\"\"\"Set the alignment of the legend.\n\n        Args:\n            alignment: alignment for the legend\n\n        Raises:\n            InvalidParamError: alignment does not exist\n        \"\"\"\n        if alignment not in constants.SIDES:\n            raise InvalidParamError(alignment, constants.SIDES)\n        self.setAlignment(constants.SIDES[alignment])\n\n    def get_alignment(self) -&gt; constants.SideStr:\n\"\"\"Return current alignment.\n\n        Returns:\n            alignment\n        \"\"\"\n        return constants.SIDES.inverse[self.alignment()]\n\n    def set_marker_shape(self, shape: MarkerShapeStr):\n\"\"\"Set the marker shape.\n\n        Args:\n            shape: marker shape\n\n        Raises:\n            InvalidParamError: marker shape does not exist\n        \"\"\"\n        if shape not in MARKER_SHAPES:\n            raise InvalidParamError(shape, MARKER_SHAPES)\n        self.setMarkerShape(MARKER_SHAPES[shape])\n\n    def get_marker_shape(self) -&gt; MarkerShapeStr:\n\"\"\"Return current marker shape.\n\n        Returns:\n            Marker shape\n        \"\"\"\n        return MARKER_SHAPES.inverse[self.markerShape()]\n\n    def get_border_color(self) -&gt; gui.Color:\n        return gui.Color(self.borderColor())\n\n    def get_color(self) -&gt; gui.Color:\n        return gui.Color(self.color())\n\n    def get_label_color(self) -&gt; gui.Color:\n        return gui.Color(self.labelColor())\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_alignment","title":"<code>get_alignment() -&gt; constants.SideStr</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.SideStr</code> <p>alignment</p> Source code in <code>prettyqt\\charts\\legend.py</code> <pre><code>def get_alignment(self) -&gt; constants.SideStr:\n\"\"\"Return current alignment.\n\n    Returns:\n        alignment\n    \"\"\"\n    return constants.SIDES.inverse[self.alignment()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_marker_shape","title":"<code>get_marker_shape() -&gt; MarkerShapeStr</code>","text":"<p>Return current marker shape.</p> <p>Returns:</p> Type Description <code>MarkerShapeStr</code> <p>Marker shape</p> Source code in <code>prettyqt\\charts\\legend.py</code> <pre><code>def get_marker_shape(self) -&gt; MarkerShapeStr:\n\"\"\"Return current marker shape.\n\n    Returns:\n        Marker shape\n    \"\"\"\n    return MARKER_SHAPES.inverse[self.markerShape()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_alignment","title":"<code>set_alignment(alignment: constants.SideStr)</code>","text":"<p>Set the alignment of the legend.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.SideStr</code> <p>alignment for the legend</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>alignment does not exist</p> Source code in <code>prettyqt\\charts\\legend.py</code> <pre><code>def set_alignment(self, alignment: constants.SideStr):\n\"\"\"Set the alignment of the legend.\n\n    Args:\n        alignment: alignment for the legend\n\n    Raises:\n        InvalidParamError: alignment does not exist\n    \"\"\"\n    if alignment not in constants.SIDES:\n        raise InvalidParamError(alignment, constants.SIDES)\n    self.setAlignment(constants.SIDES[alignment])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_marker_shape","title":"<code>set_marker_shape(shape: MarkerShapeStr)</code>","text":"<p>Set the marker shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>MarkerShapeStr</code> <p>marker shape</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>marker shape does not exist</p> Source code in <code>prettyqt\\charts\\legend.py</code> <pre><code>def set_marker_shape(self, shape: MarkerShapeStr):\n\"\"\"Set the marker shape.\n\n    Args:\n        shape: marker shape\n\n    Raises:\n        InvalidParamError: marker shape does not exist\n    \"\"\"\n    if shape not in MARKER_SHAPES:\n        raise InvalidParamError(shape, MARKER_SHAPES)\n    self.setMarkerShape(MARKER_SHAPES[shape])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.LineSeries","title":"<code>LineSeries</code>","text":"<p>         Bases: <code>charts.XYSeriesMixin</code>, <code>QtCharts.QLineSeries</code></p> <p>QLineSeries with some custom properties.</p> Source code in <code>prettyqt\\charts\\lineseries.py</code> <pre><code>class LineSeries(charts.XYSeriesMixin, QtCharts.QLineSeries):\n\"\"\"QLineSeries with some custom properties.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._process_name = \"\"\n\n    def get_process_name(self):\n        return self._process_name\n\n    def set_process_name(self, value):\n        self._process_name = value\n\n    process_name = core.Property(str, get_process_name, set_process_name)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.PieSlice","title":"<code>PieSlice</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtCharts.QPieSlice</code></p> Source code in <code>prettyqt\\charts\\pieslice.py</code> <pre><code>class PieSlice(core.ObjectMixin, QtCharts.QPieSlice):\n    def __repr__(self):\n        return get_repr(self, self.label(), self.value())\n\n    def set_label_position(self, position: LabelPositionStr):\n\"\"\"Set the label position.\n\n        Args:\n            position: label position\n\n        Raises:\n            InvalidParamError: label position does not exist\n        \"\"\"\n        if position not in LABEL_POSITION:\n            raise InvalidParamError(position, LABEL_POSITION)\n        self.setLabelPosition(LABEL_POSITION[position])\n\n    def get_label_position(self) -&gt; LabelPositionStr:\n\"\"\"Return current label position.\n\n        Returns:\n            label position\n        \"\"\"\n        return LABEL_POSITION.inverse[self.labelPosition()]\n\n    def get_label_font(self) -&gt; gui.Font:\n        return gui.Font(self.labelFont())\n\n    def get_label_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.labelBrush())\n\n    def get_label_color(self) -&gt; gui.Color:\n        return gui.Color(self.labelColor())\n\n    def get_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.pen())\n\n    def get_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.brush())\n\n    def get_color(self) -&gt; gui.Color:\n        return gui.Color(self.color())\n\n    def get_border_color(self) -&gt; gui.Color:\n        return gui.Color(self.borderColor())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.get_label_position","title":"<code>get_label_position() -&gt; LabelPositionStr</code>","text":"<p>Return current label position.</p> <p>Returns:</p> Type Description <code>LabelPositionStr</code> <p>label position</p> Source code in <code>prettyqt\\charts\\pieslice.py</code> <pre><code>def get_label_position(self) -&gt; LabelPositionStr:\n\"\"\"Return current label position.\n\n    Returns:\n        label position\n    \"\"\"\n    return LABEL_POSITION.inverse[self.labelPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.set_label_position","title":"<code>set_label_position(position: LabelPositionStr)</code>","text":"<p>Set the label position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>LabelPositionStr</code> <p>label position</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>label position does not exist</p> Source code in <code>prettyqt\\charts\\pieslice.py</code> <pre><code>def set_label_position(self, position: LabelPositionStr):\n\"\"\"Set the label position.\n\n    Args:\n        position: label position\n\n    Raises:\n        InvalidParamError: label position does not exist\n    \"\"\"\n    if position not in LABEL_POSITION:\n        raise InvalidParamError(position, LABEL_POSITION)\n    self.setLabelPosition(LABEL_POSITION[position])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.ValueAxisMixin","title":"<code>ValueAxisMixin</code>","text":"<p>         Bases: <code>charts.AbstractAxisMixin</code></p> Source code in <code>prettyqt\\charts\\valueaxis.py</code> <pre><code>class ValueAxisMixin(charts.AbstractAxisMixin):\n    def set_tick_type(self, tick_type: TickTypeStr):\n\"\"\"Set the tick type of the legend.\n\n        Args:\n            tick_type: tick type for the legend\n\n        Raises:\n            InvalidParamError: tick type does not exist\n        \"\"\"\n        if tick_type not in TICK_TYPES:\n            raise InvalidParamError(tick_type, TICK_TYPES)\n        self.setTickType(TICK_TYPES[tick_type])\n\n    def get_tick_type(self) -&gt; TickTypeStr:\n\"\"\"Return current tick type.\n\n        Returns:\n            tick_type\n        \"\"\"\n        return TICK_TYPES.inverse[self.tickType()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxisMixin.get_tick_type","title":"<code>get_tick_type() -&gt; TickTypeStr</code>","text":"<p>Return current tick type.</p> <p>Returns:</p> Type Description <code>TickTypeStr</code> <p>tick_type</p> Source code in <code>prettyqt\\charts\\valueaxis.py</code> <pre><code>def get_tick_type(self) -&gt; TickTypeStr:\n\"\"\"Return current tick type.\n\n    Returns:\n        tick_type\n    \"\"\"\n    return TICK_TYPES.inverse[self.tickType()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxisMixin.set_tick_type","title":"<code>set_tick_type(tick_type: TickTypeStr)</code>","text":"<p>Set the tick type of the legend.</p> <p>Parameters:</p> Name Type Description Default <code>tick_type</code> <code>TickTypeStr</code> <p>tick type for the legend</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>tick type does not exist</p> Source code in <code>prettyqt\\charts\\valueaxis.py</code> <pre><code>def set_tick_type(self, tick_type: TickTypeStr):\n\"\"\"Set the tick type of the legend.\n\n    Args:\n        tick_type: tick type for the legend\n\n    Raises:\n        InvalidParamError: tick type does not exist\n    \"\"\"\n    if tick_type not in TICK_TYPES:\n        raise InvalidParamError(tick_type, TICK_TYPES)\n    self.setTickType(TICK_TYPES[tick_type])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.XYSeriesMixin","title":"<code>XYSeriesMixin</code>","text":"<p>         Bases: <code>charts.AbstractSeriesMixin</code></p> <p>QXYSeries with some custom properties.</p> Source code in <code>prettyqt\\charts\\xyseries.py</code> <pre><code>class XYSeriesMixin(charts.AbstractSeriesMixin):\n\"\"\"QXYSeries with some custom properties.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # self._process_name = \"\"\n        self.setUseOpenGL()\n\n    def __setitem__(self, index: int, val: QtCore.QPointF):\n        self.replace(index, val)\n\n    def __delitem__(self, index: int):\n        self.remove(index)\n\n    # def __setstate__(self, state):\n    #     self.append(state[\"points\"])\n\n    # def __reduce__(self):\n    #     return type(self), (), self.__getstate__()\n\n    def __add__(self, other: QtCore.QPointF) -&gt; XYSeries:\n        self.append(other)\n        return self\n\n    def serialize_fields(self):\n        if prettyqt.qt.API == \"pyqt6\":\n            points = [self.at(i) for i in range(self.count())]\n        else:\n            points = self.points()\n        return dict(points=points)\n\n    def get_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.pen())\n\n    def get_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.brush())\n</code></pre>"},{"location":"api/constants.html","title":"constants module","text":"<p>Constants module.</p>"},{"location":"api/core.html","title":"core module","text":"<p>Core module.</p> <p>Contains QtCore-based classes</p>"},{"location":"api/core.html#prettyqt.core.AbstractAnimationMixin","title":"<code>AbstractAnimationMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>class AbstractAnimationMixin(core.ObjectMixin):\n    def __len__(self):\n        return self.duration()\n\n    def __and__(self, other: QtCore.QAbstractAnimation) -&gt; core.SequentialAnimationGroup:\n        group = core.SequentialAnimationGroup()\n        group.addAnimation(self)\n        group.addAnimation(other)\n        return group\n\n    def __or__(self, other: QtCore.QAbstractAnimation) -&gt; core.ParallelAnimationGroup:\n        group = core.ParallelAnimationGroup()\n        group.addAnimation(self)\n        group.addAnimation(other)\n        return group\n\n    def serialize_fields(self):\n        return dict(\n            duration=self.duration(),\n            direction=self.get_direction(),\n            loop_count=self.loopCount(),\n            current_time=self.currentTime(),\n        )\n\n    def set_direction(self, direction: DirectionStr):\n\"\"\"Set animation direction.\n\n        Args:\n            direction: animation direction\n\n        Raises:\n            InvalidParamError: animation direction does not exist\n        \"\"\"\n        if direction not in DIRECTION:\n            raise InvalidParamError(direction, DIRECTION)\n        self.setDirection(DIRECTION[direction])\n\n    def get_direction(self) -&gt; DirectionStr:\n\"\"\"Get the current animation direction.\n\n        Returns:\n            animation direction\n        \"\"\"\n        return DIRECTION.inverse[self.direction()]\n\n    def get_state(self) -&gt; StateStr:\n\"\"\"Get the current animation state.\n\n        Returns:\n            animation state\n        \"\"\"\n        return STATE.inverse[self.state()]\n\n    def start_animation(self, policy: DeletionPolicyStr = \"keep\"):\n\"\"\"Start the animation.\n\n        Args:\n            policy: animation policy\n\n        Raises:\n            InvalidParamError: animation policy does not exist\n        \"\"\"\n        if policy not in DELETION_POLICY:\n            raise InvalidParamError(policy, DELETION_POLICY)\n        self.start(DELETION_POLICY[policy])\n\n    def restart_animation(self, policy: DeletionPolicyStr = \"keep\"):\n\"\"\"Restart the animation.\n\n        Args:\n            policy: animation policy\n\n        Raises:\n            InvalidParamError: animation policy does not exist\n        \"\"\"\n        self.stop()\n        self.start_animation(policy)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.get_direction","title":"<code>get_direction() -&gt; DirectionStr</code>","text":"<p>Get the current animation direction.</p> <p>Returns:</p> Type Description <code>DirectionStr</code> <p>animation direction</p> Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>def get_direction(self) -&gt; DirectionStr:\n\"\"\"Get the current animation direction.\n\n    Returns:\n        animation direction\n    \"\"\"\n    return DIRECTION.inverse[self.direction()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.get_state","title":"<code>get_state() -&gt; StateStr</code>","text":"<p>Get the current animation state.</p> <p>Returns:</p> Type Description <code>StateStr</code> <p>animation state</p> Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>def get_state(self) -&gt; StateStr:\n\"\"\"Get the current animation state.\n\n    Returns:\n        animation state\n    \"\"\"\n    return STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.restart_animation","title":"<code>restart_animation(policy: DeletionPolicyStr = 'keep')</code>","text":"<p>Restart the animation.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>DeletionPolicyStr</code> <p>animation policy</p> <code>'keep'</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>animation policy does not exist</p> Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>def restart_animation(self, policy: DeletionPolicyStr = \"keep\"):\n\"\"\"Restart the animation.\n\n    Args:\n        policy: animation policy\n\n    Raises:\n        InvalidParamError: animation policy does not exist\n    \"\"\"\n    self.stop()\n    self.start_animation(policy)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.set_direction","title":"<code>set_direction(direction: DirectionStr)</code>","text":"<p>Set animation direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>DirectionStr</code> <p>animation direction</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>animation direction does not exist</p> Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>def set_direction(self, direction: DirectionStr):\n\"\"\"Set animation direction.\n\n    Args:\n        direction: animation direction\n\n    Raises:\n        InvalidParamError: animation direction does not exist\n    \"\"\"\n    if direction not in DIRECTION:\n        raise InvalidParamError(direction, DIRECTION)\n    self.setDirection(DIRECTION[direction])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.start_animation","title":"<code>start_animation(policy: DeletionPolicyStr = 'keep')</code>","text":"<p>Start the animation.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>DeletionPolicyStr</code> <p>animation policy</p> <code>'keep'</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>animation policy does not exist</p> Source code in <code>prettyqt\\core\\abstractanimation.py</code> <pre><code>def start_animation(self, policy: DeletionPolicyStr = \"keep\"):\n\"\"\"Start the animation.\n\n    Args:\n        policy: animation policy\n\n    Raises:\n        InvalidParamError: animation policy does not exist\n    \"\"\"\n    if policy not in DELETION_POLICY:\n        raise InvalidParamError(policy, DELETION_POLICY)\n    self.start(DELETION_POLICY[policy])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.AbstractItemModelMixin","title":"<code>AbstractItemModelMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>class AbstractItemModelMixin(core.ObjectMixin):\n    def __repr__(self):\n        return f\"{type(self).__name__}: {self.rowCount()} rows\"\n\n    def __len__(self) -&gt; int:\n\"\"\"Return amount of rows.\"\"\"\n        return self.rowCount()\n\n    @classmethod\n    def ci(\n        cls,\n        index_is_valid: bool = False,\n        do_not_use_parent: bool = False,\n        parent_is_invalid: bool = False,\n    ):\n        def inner(method):\n            def wrapper(\n                ref: AbstractItemModelMixin, index: QtCore.QModelIndex, *args, **kwargs\n            ):\n                if ref.check_index(\n                    index, index_is_valid, do_not_use_parent, parent_is_invalid\n                ):\n                    return method(ref, index, *args, **kwargs)\n                else:\n                    raise TypeError(\"Invalid index\")\n\n            return wrapper\n\n        return inner\n\n    def check_index(\n        self,\n        index: QtCore.QModelIndex,\n        index_is_valid: bool = False,\n        do_not_use_parent: bool = False,\n        parent_is_invalid: bool = False,\n    ) -&gt; bool:\n        flag = QtCore.QAbstractItemModel.CheckIndexOption.NoOption\n        if index_is_valid:\n            flag |= CHECK_INDEX_OPTIONS[\"index_is_valid\"]  # type: ignore\n        if do_not_use_parent:\n            flag |= CHECK_INDEX_OPTIONS[\"do_not_use_parent\"]  # type: ignore\n        if parent_is_invalid:\n            flag |= CHECK_INDEX_OPTIONS[\"parent_is_invalid\"]  # type: ignore\n        check_flag = QtCore.QAbstractItemModel.CheckIndexOption(0) | flag  # type: ignore\n        return self.checkIndex(index, check_flag)  # type: ignore\n\n    @contextlib.contextmanager\n    def change_layout(self):\n\"\"\"Context manager to change the layout.\n\n        wraps calls with correct signals\n        emitted at beginning: layoutAboutToBeChanged\n        emitted at end: layoutChanged\n\n        \"\"\"\n        self.layoutAboutToBeChanged.emit()\n        yield None\n        self.layoutChanged.emit()\n\n    @contextlib.contextmanager\n    def reset_model(self):\n\"\"\"Context manager to reset the model.\n\n        wraps calls with correct signals\n        emitted at beginning: beginResetModel\n        emitted at end: endResetModel\n\n        \"\"\"\n        self.beginResetModel()\n        yield None\n        self.endResetModel()\n\n    def update_row(self, row: int):\n        start_index = self.index(row, 0)\n        end_index = self.index(row, self.columnCount() - 1)\n        self.dataChanged.emit(start_index, end_index)\n\n    def update_all(self):\n        top_left = self.index(0, 0)\n        bottom_right = self.index(self.rowCount() - 1, self.columnCount() - 1)\n        self.dataChanged.emit(top_left, bottom_right)\n\n    @contextlib.contextmanager\n    def remove_rows(\n        self,\n        first: int | None = None,\n        last: int | None = None,\n        parent: QtCore.QModelIndex | None = None,\n    ):\n        parent = QtCore.QModelIndex() if parent is None else parent\n        first = first if first is not None else 0\n        last = last if last is not None else self.rowCount()\n        self.beginRemoveRows(parent, first, last)\n        yield None\n        self.endRemoveRows()\n\n    @contextlib.contextmanager\n    def remove_columns(\n        self,\n        first: int | None = None,\n        last: int | None = None,\n        parent: QtCore.QModelIndex | None = None,\n    ):\n        parent = QtCore.QModelIndex() if parent is None else parent\n        first = first if first is not None else 0\n        last = last if last is not None else self.rowCount()\n        self.beginRemoveColumns(parent, first, last)\n        yield None\n        self.endRemoveColumns()\n\n    @contextlib.contextmanager\n    def insert_rows(\n        self,\n        first: int | None = None,\n        last: int | None = None,\n        parent: QtCore.QModelIndex | None = None,\n    ):\n        parent = QtCore.QModelIndex() if parent is None else parent\n        first = first if first is not None else 0\n        last = last if last is not None else self.rowCount()\n        self.beginInsertRows(parent, first, last)\n        yield None\n        self.endInsertRows()\n\n    @contextlib.contextmanager\n    def append_rows(self, num_rows: int, parent: QtCore.QModelIndex | None = None):\n        parent = QtCore.QModelIndex() if parent is None else parent\n        row_count = self.rowCount()\n        self.beginInsertRows(parent, row_count, row_count + num_rows - 1)\n        yield None\n        self.endInsertRows()\n\n    @contextlib.contextmanager\n    def insert_columns(\n        self,\n        first: int | None = None,\n        last: int | None = None,\n        parent: QtCore.QModelIndex | None = None,\n    ):\n        parent = QtCore.QModelIndex() if parent is None else parent\n        first = first if first is not None else 0\n        last = last if last is not None else self.rowCount()\n        self.beginInsertColumns(parent, first, last)\n        yield None\n        self.endInsertColumns()\n\n    def force_reset(self):\n        self.beginResetModel()\n        self.endResetModel()\n\n    def force_layoutchange(self):\n        self.layoutAboutToBeChanged.emit()\n        self.layoutChanged.emit()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>Return amount of rows.</p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Return amount of rows.\"\"\"\n    return self.rowCount()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.change_layout","title":"<code>change_layout()</code>","text":"<p>Context manager to change the layout.</p> <p>wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged</p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>@contextlib.contextmanager\ndef change_layout(self):\n\"\"\"Context manager to change the layout.\n\n    wraps calls with correct signals\n    emitted at beginning: layoutAboutToBeChanged\n    emitted at end: layoutChanged\n\n    \"\"\"\n    self.layoutAboutToBeChanged.emit()\n    yield None\n    self.layoutChanged.emit()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.reset_model","title":"<code>reset_model()</code>","text":"<p>Context manager to reset the model.</p> <p>wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel</p> Source code in <code>prettyqt\\core\\abstractitemmodel.py</code> <pre><code>@contextlib.contextmanager\ndef reset_model(self):\n\"\"\"Context manager to reset the model.\n\n    wraps calls with correct signals\n    emitted at beginning: beginResetModel\n    emitted at end: endResetModel\n\n    \"\"\"\n    self.beginResetModel()\n    yield None\n    self.endResetModel()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.AbstractProxyModelMixin","title":"<code>AbstractProxyModelMixin</code>","text":"<p>         Bases: <code>core.AbstractItemModelMixin</code></p> Source code in <code>prettyqt\\core\\abstractproxymodel.py</code> <pre><code>class AbstractProxyModelMixin(core.AbstractItemModelMixin):\n    def first_item_index(self) -&gt; core.ModelIndex:\n\"\"\"Return the first child of the root item.\"\"\"\n        # We cannot just call the same function of the source model because the first node\n        # there may be hidden.\n        proxy_root_index = self.mapFromSource(core.ModelIndex())\n        return self.index(0, 0, proxy_root_index)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractproxymodel.AbstractProxyModelMixin.first_item_index","title":"<code>first_item_index() -&gt; core.ModelIndex</code>","text":"<p>Return the first child of the root item.</p> Source code in <code>prettyqt\\core\\abstractproxymodel.py</code> <pre><code>def first_item_index(self) -&gt; core.ModelIndex:\n\"\"\"Return the first child of the root item.\"\"\"\n    # We cannot just call the same function of the source model because the first node\n    # there may be hidden.\n    proxy_root_index = self.mapFromSource(core.ModelIndex())\n    return self.index(0, 0, proxy_root_index)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.Collator","title":"<code>Collator</code>","text":"<p>         Bases: <code>QtCore.QCollator</code></p> Source code in <code>prettyqt\\core\\collator.py</code> <pre><code>class Collator(QtCore.QCollator):\n    def __repr__(self):\n        return get_repr(self, self.get_locale())\n\n    def get_locale(self) -&gt; core.Locale:\n        return core.Locale(self.locale())\n\n    def set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n\n        Args:\n            state: case sensitive\n\n        \"\"\"\n        sensitivity = (\n            QtCore.Qt.CaseSensitivity.CaseSensitive\n            if state\n            else QtCore.Qt.CaseSensitivity.CaseInsensitive\n        )\n        self.setCaseSensitivity(sensitivity)\n\n    def is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n\n        Returns:\n            case sensitivity\n        \"\"\"\n        return bool(self.caseSensitivity())\n\n    def get_sort_key(self, string: str) -&gt; core.CollatorSortKey:\n        return core.CollatorSortKey(self.sortKey(string))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.collator.Collator.is_case_sensitive","title":"<code>is_case_sensitive() -&gt; bool</code>","text":"<p>Return case sensitivity.</p> <p>Returns:</p> Type Description <code>bool</code> <p>case sensitivity</p> Source code in <code>prettyqt\\core\\collator.py</code> <pre><code>def is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n\n    Returns:\n        case sensitivity\n    \"\"\"\n    return bool(self.caseSensitivity())\n</code></pre>"},{"location":"api/core.html#prettyqt.core.collator.Collator.set_case_sensitive","title":"<code>set_case_sensitive(state: bool)</code>","text":"<p>Set case sensitivity.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>case sensitive</p> required Source code in <code>prettyqt\\core\\collator.py</code> <pre><code>def set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n\n    Args:\n        state: case sensitive\n\n    \"\"\"\n    sensitivity = (\n        QtCore.Qt.CaseSensitivity.CaseSensitive\n        if state\n        else QtCore.Qt.CaseSensitivity.CaseInsensitive\n    )\n    self.setCaseSensitivity(sensitivity)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.CommandLineParser","title":"<code>CommandLineParser</code>","text":"<p>         Bases: <code>QtCore.QCommandLineParser</code></p> Source code in <code>prettyqt\\core\\commandlineparser.py</code> <pre><code>class CommandLineParser(QtCore.QCommandLineParser):\n    def set_single_dash_word_option_mode(self, mode: SingleDashWordStr):\n\"\"\"Set the single dash word option mode.\n\n        Args:\n            mode: single dash word option mode\n\n        Raises:\n            InvalidParamError: single dash word option mode does not exist\n        \"\"\"\n        if mode not in SINGLE_DASH_WORD:\n            raise InvalidParamError(mode, SINGLE_DASH_WORD)\n        self.setSingleDashWordOptionMode(SINGLE_DASH_WORD[mode])\n\n    def set_options_after_positional_arguments_mode(self, mode: SingleDashWordStr):\n\"\"\"Set the options after positional arguments mode.\n\n        Args:\n            mode: options after positional arguments mode\n\n        Raises:\n            InvalidParamError: options after positional arguments mode does not exist\n        \"\"\"\n        if mode not in OPTIONS_AFTER_POS_ARG:\n            raise InvalidParamError(mode, OPTIONS_AFTER_POS_ARG)\n        self.setOptionsAfterPositionalArgumentsMode(OPTIONS_AFTER_POS_ARG[mode])\n\n    def add_option(\n        self,\n        name: str,\n        description: str | None = None,\n        value_name: str | None = None,\n        default_value: str | None = None,\n    ) -&gt; core.CommandLineOption:\n        if description is None:\n            description = \"\"\n        if value_name is None:\n            value_name = \"\"\n        if default_value is None:\n            default_value = \"\"\n        option = core.CommandLineOption(name, description, value_name, default_value)\n        self.addOption(option)\n        return option\n</code></pre>"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_options_after_positional_arguments_mode","title":"<code>set_options_after_positional_arguments_mode(mode: SingleDashWordStr)</code>","text":"<p>Set the options after positional arguments mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SingleDashWordStr</code> <p>options after positional arguments mode</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>options after positional arguments mode does not exist</p> Source code in <code>prettyqt\\core\\commandlineparser.py</code> <pre><code>def set_options_after_positional_arguments_mode(self, mode: SingleDashWordStr):\n\"\"\"Set the options after positional arguments mode.\n\n    Args:\n        mode: options after positional arguments mode\n\n    Raises:\n        InvalidParamError: options after positional arguments mode does not exist\n    \"\"\"\n    if mode not in OPTIONS_AFTER_POS_ARG:\n        raise InvalidParamError(mode, OPTIONS_AFTER_POS_ARG)\n    self.setOptionsAfterPositionalArgumentsMode(OPTIONS_AFTER_POS_ARG[mode])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_single_dash_word_option_mode","title":"<code>set_single_dash_word_option_mode(mode: SingleDashWordStr)</code>","text":"<p>Set the single dash word option mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SingleDashWordStr</code> <p>single dash word option mode</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>single dash word option mode does not exist</p> Source code in <code>prettyqt\\core\\commandlineparser.py</code> <pre><code>def set_single_dash_word_option_mode(self, mode: SingleDashWordStr):\n\"\"\"Set the single dash word option mode.\n\n    Args:\n        mode: single dash word option mode\n\n    Raises:\n        InvalidParamError: single dash word option mode does not exist\n    \"\"\"\n    if mode not in SINGLE_DASH_WORD:\n        raise InvalidParamError(mode, SINGLE_DASH_WORD)\n    self.setSingleDashWordOptionMode(SINGLE_DASH_WORD[mode])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.DataStream","title":"<code>DataStream</code>","text":"<p>         Bases: <code>QtCore.QDataStream</code></p> Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>class DataStream(QtCore.QDataStream):\n    def set_byte_order(self, order: ByteOrderStr):\n\"\"\"Set byte order.\n\n        Args:\n            order: byte order to use\n\n        Raises:\n            InvalidParamError: invalid order\n        \"\"\"\n        if order not in BYTE_ORDER:\n            raise InvalidParamError(order, BYTE_ORDER)\n        self.setByteOrder(BYTE_ORDER[order])\n\n    def get_byte_order(self) -&gt; ByteOrderStr:\n\"\"\"Return byte order.\n\n        Returns:\n            byte order\n        \"\"\"\n        return BYTE_ORDER.inverse[self.byteOrder()]\n\n    def set_status(self, status: StatusStr):\n\"\"\"Set status.\n\n        Args:\n            status: status to use\n\n        Raises:\n            InvalidParamError: invalid status\n        \"\"\"\n        if status not in STATUS:\n            raise InvalidParamError(status, STATUS)\n        self.setStatus(STATUS[status])\n\n    def get_status(self) -&gt; StatusStr:\n\"\"\"Return status.\n\n        Returns:\n            status\n        \"\"\"\n        return STATUS.inverse[self.status()]\n\n    def set_floating_point_precision(self, precision: FloatingPointPrecisionStr):\n\"\"\"Set floating point precision.\n\n        Args:\n            precision: floating point precision\n\n        Raises:\n            InvalidParamError: invalid precision\n        \"\"\"\n        if precision not in FLOATING_POINT_PRECISION:\n            raise InvalidParamError(precision, FLOATING_POINT_PRECISION)\n        self.setFloatingPointPrecision(FLOATING_POINT_PRECISION[precision])\n\n    def get_floating_point_precision(self) -&gt; FloatingPointPrecisionStr:\n\"\"\"Return floating point precision.\n\n        Returns:\n            floating point precision\n        \"\"\"\n        return FLOATING_POINT_PRECISION.inverse[self.floatingPointPrecision()]\n\n    @classmethod\n    def create_bytearray(cls, data: datatypes.QtSerializableType) -&gt; QtCore.QByteArray:\n        ba = QtCore.QByteArray()\n        stream = cls(ba, QtCore.QIODeviceBase.OpenModeFlag.WriteOnly)\n        stream &lt;&lt; data\n        return ba\n\n    @classmethod\n    def write_bytearray(\n        cls, ba: datatypes.ByteArrayType, write_to: datatypes.QtSerializableType\n    ):\n        if isinstance(ba, str):\n            ba = ba.encode()\n        if not isinstance(ba, QtCore.QByteArray):\n            ba = QtCore.QByteArray(ba)\n        stream = cls(ba, QtCore.QIODeviceBase.OpenModeFlag.ReadOnly)\n        stream &gt;&gt; write_to\n\n    @classmethod\n    def copy_data(\n        cls, source: datatypes.QtSerializableType, dest: datatypes.QtSerializableType\n    ):\n        ba = cls.create_bytearray(source)\n        cls.write_bytearray(ba, dest)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_byte_order","title":"<code>get_byte_order() -&gt; ByteOrderStr</code>","text":"<p>Return byte order.</p> <p>Returns:</p> Type Description <code>ByteOrderStr</code> <p>byte order</p> Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def get_byte_order(self) -&gt; ByteOrderStr:\n\"\"\"Return byte order.\n\n    Returns:\n        byte order\n    \"\"\"\n    return BYTE_ORDER.inverse[self.byteOrder()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_floating_point_precision","title":"<code>get_floating_point_precision() -&gt; FloatingPointPrecisionStr</code>","text":"<p>Return floating point precision.</p> <p>Returns:</p> Type Description <code>FloatingPointPrecisionStr</code> <p>floating point precision</p> Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def get_floating_point_precision(self) -&gt; FloatingPointPrecisionStr:\n\"\"\"Return floating point precision.\n\n    Returns:\n        floating point precision\n    \"\"\"\n    return FLOATING_POINT_PRECISION.inverse[self.floatingPointPrecision()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_status","title":"<code>get_status() -&gt; StatusStr</code>","text":"<p>Return status.</p> <p>Returns:</p> Type Description <code>StatusStr</code> <p>status</p> Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def get_status(self) -&gt; StatusStr:\n\"\"\"Return status.\n\n    Returns:\n        status\n    \"\"\"\n    return STATUS.inverse[self.status()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_byte_order","title":"<code>set_byte_order(order: ByteOrderStr)</code>","text":"<p>Set byte order.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>ByteOrderStr</code> <p>byte order to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid order</p> Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def set_byte_order(self, order: ByteOrderStr):\n\"\"\"Set byte order.\n\n    Args:\n        order: byte order to use\n\n    Raises:\n        InvalidParamError: invalid order\n    \"\"\"\n    if order not in BYTE_ORDER:\n        raise InvalidParamError(order, BYTE_ORDER)\n    self.setByteOrder(BYTE_ORDER[order])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_floating_point_precision","title":"<code>set_floating_point_precision(precision: FloatingPointPrecisionStr)</code>","text":"<p>Set floating point precision.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>FloatingPointPrecisionStr</code> <p>floating point precision</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid precision</p> Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def set_floating_point_precision(self, precision: FloatingPointPrecisionStr):\n\"\"\"Set floating point precision.\n\n    Args:\n        precision: floating point precision\n\n    Raises:\n        InvalidParamError: invalid precision\n    \"\"\"\n    if precision not in FLOATING_POINT_PRECISION:\n        raise InvalidParamError(precision, FLOATING_POINT_PRECISION)\n    self.setFloatingPointPrecision(FLOATING_POINT_PRECISION[precision])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_status","title":"<code>set_status(status: StatusStr)</code>","text":"<p>Set status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>StatusStr</code> <p>status to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid status</p> Source code in <code>prettyqt\\core\\datastream.py</code> <pre><code>def set_status(self, status: StatusStr):\n\"\"\"Set status.\n\n    Args:\n        status: status to use\n\n    Raises:\n        InvalidParamError: invalid status\n    \"\"\"\n    if status not in STATUS:\n        raise InvalidParamError(status, STATUS)\n    self.setStatus(STATUS[status])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.DateTime","title":"<code>DateTime</code>","text":"<p>         Bases: <code>QtCore.QDateTime</code></p> Source code in <code>prettyqt\\core\\_datetime.py</code> <pre><code>class DateTime(QtCore.QDateTime):\n    def __repr__(self):\n        template = super().__repr__().split(\"(\")[1]\n        return f\"{type(self).__name__}({template}\"\n\n    def __str__(self):\n        return self.toString(\"yyyy-MM-dd hh:mm:ss.zzzzzz\")\n\n    def __reduce__(self):\n        return type(self), (self.date(), self.time(), self.get_timezone())\n\n    def get_value(self) -&gt; datetime.datetime:\n        return self.toPython()\n\n    def get_date(self) -&gt; core.Date:\n        return core.Date(self.date())\n\n    def get_time(self) -&gt; core.Time:\n        return core.Time(self.time())\n\n    def get_timezone(self) -&gt; core.TimeZone:\n        return core.TimeZone(self.timeZone())\n\n    def set_timezone(self, zone: str | QtCore.QTimeZone):\n        if isinstance(zone, str):\n            self.setTimeZone(core.TimeZone(zone))\n        else:\n            self.setTimeZone(zone)\n\n    def set_time_spec(self, spec: constants.TimeSpecStr):\n\"\"\"Set the time specification.\n\n        Args:\n            spec: time specification to use\n\n        Raises:\n            InvalidParamError: time specification does not exist\n        \"\"\"\n        if spec not in constants.TIME_SPEC:\n            raise InvalidParamError(spec, constants.TIME_SPEC)\n        self.setTimeSpec(constants.TIME_SPEC[spec])\n\n    def get_time_spec(self) -&gt; constants.TimeSpecStr:\n\"\"\"Return current time specification.\n\n        Returns:\n            time specification\n        \"\"\"\n        return constants.TIME_SPEC.inverse[self.timeSpec()]\n\n    def to_format(self, fmt: constants.DateFormatStr):\n        return self.toString(constants.DATE_FORMAT[fmt])\n</code></pre>"},{"location":"api/core.html#prettyqt.core._datetime.DateTime.get_time_spec","title":"<code>get_time_spec() -&gt; constants.TimeSpecStr</code>","text":"<p>Return current time specification.</p> <p>Returns:</p> Type Description <code>constants.TimeSpecStr</code> <p>time specification</p> Source code in <code>prettyqt\\core\\_datetime.py</code> <pre><code>def get_time_spec(self) -&gt; constants.TimeSpecStr:\n\"\"\"Return current time specification.\n\n    Returns:\n        time specification\n    \"\"\"\n    return constants.TIME_SPEC.inverse[self.timeSpec()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core._datetime.DateTime.set_time_spec","title":"<code>set_time_spec(spec: constants.TimeSpecStr)</code>","text":"<p>Set the time specification.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>constants.TimeSpecStr</code> <p>time specification to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>time specification does not exist</p> Source code in <code>prettyqt\\core\\_datetime.py</code> <pre><code>def set_time_spec(self, spec: constants.TimeSpecStr):\n\"\"\"Set the time specification.\n\n    Args:\n        spec: time specification to use\n\n    Raises:\n        InvalidParamError: time specification does not exist\n    \"\"\"\n    if spec not in constants.TIME_SPEC:\n        raise InvalidParamError(spec, constants.TIME_SPEC)\n    self.setTimeSpec(constants.TIME_SPEC[spec])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.DeadlineTimer","title":"<code>DeadlineTimer</code>","text":"<p>         Bases: <code>QtCore.QDeadlineTimer</code></p> Source code in <code>prettyqt\\core\\deadlinetimer.py</code> <pre><code>class DeadlineTimer(QtCore.QDeadlineTimer):\n    def set_type(self, typ: constants.TimerTypeStr):\n\"\"\"Set the timer type.\n\n        Args:\n            typ: timer type\n\n        Raises:\n            InvalidParamError: timer type does not exist\n        \"\"\"\n        if typ not in constants.TIMER_TYPE:\n            raise InvalidParamError(typ, constants.TIMER_TYPE)\n        self.setTimerType(constants.TIMER_TYPE[typ])\n\n    def get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n\n        Returns:\n            timer type\n        \"\"\"\n        return constants.TIMER_TYPE.inverse[self.timerType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.get_type","title":"<code>get_type() -&gt; constants.TimerTypeStr</code>","text":"<p>Return current timer type.</p> <p>Returns:</p> Type Description <code>constants.TimerTypeStr</code> <p>timer type</p> Source code in <code>prettyqt\\core\\deadlinetimer.py</code> <pre><code>def get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n\n    Returns:\n        timer type\n    \"\"\"\n    return constants.TIMER_TYPE.inverse[self.timerType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.set_type","title":"<code>set_type(typ: constants.TimerTypeStr)</code>","text":"<p>Set the timer type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>constants.TimerTypeStr</code> <p>timer type</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>timer type does not exist</p> Source code in <code>prettyqt\\core\\deadlinetimer.py</code> <pre><code>def set_type(self, typ: constants.TimerTypeStr):\n\"\"\"Set the timer type.\n\n    Args:\n        typ: timer type\n\n    Raises:\n        InvalidParamError: timer type does not exist\n    \"\"\"\n    if typ not in constants.TIMER_TYPE:\n        raise InvalidParamError(typ, constants.TIMER_TYPE)\n    self.setTimerType(constants.TIMER_TYPE[typ])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.EasingCurve","title":"<code>EasingCurve</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtCore.QEasingCurve</code></p> Source code in <code>prettyqt\\core\\easingcurve.py</code> <pre><code>class EasingCurve(serializemixin.SerializeMixin, QtCore.QEasingCurve):\n    def __init__(self, other_or_type: TypeStr | int | QtCore.QEasingCurve = \"linear\"):\n        if isinstance(other_or_type, str) and other_or_type in TYPE:\n            typ = TYPE[other_or_type]\n        else:\n            typ = other_or_type\n        super().__init__(typ)\n\n    def __getitem__(self, value: float) -&gt; float:\n        return self.valueForProgress(value)\n\n    def __repr__(self):\n        return get_repr(self, self.get_type())\n\n    def set_custom_type(self, method: CurveMethod):\n        self.setCustomType(method)\n\n    def get_custom_type(self) -&gt; CurveMethod:\n        return self.customType()  # type: ignore\n\n    def set_type(self, typ: TypeStr):\n\"\"\"Set easing curve type.\n\n        Args:\n            typ: easing curve type\n\n        Raises:\n            InvalidParamError: easing curve type does not exist\n        \"\"\"\n        if typ not in TYPE:\n            raise InvalidParamError(typ, TYPE)\n        self.setType(TYPE[typ])\n\n    def get_type(self) -&gt; TypeStr:\n\"\"\"Get the current easing curve type.\n\n        Returns:\n            easing curve type\n        \"\"\"\n        return TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.get_type","title":"<code>get_type() -&gt; TypeStr</code>","text":"<p>Get the current easing curve type.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>easing curve type</p> Source code in <code>prettyqt\\core\\easingcurve.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Get the current easing curve type.\n\n    Returns:\n        easing curve type\n    \"\"\"\n    return TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.set_type","title":"<code>set_type(typ: TypeStr)</code>","text":"<p>Set easing curve type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TypeStr</code> <p>easing curve type</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>easing curve type does not exist</p> Source code in <code>prettyqt\\core\\easingcurve.py</code> <pre><code>def set_type(self, typ: TypeStr):\n\"\"\"Set easing curve type.\n\n    Args:\n        typ: easing curve type\n\n    Raises:\n        InvalidParamError: easing curve type does not exist\n    \"\"\"\n    if typ not in TYPE:\n        raise InvalidParamError(typ, TYPE)\n    self.setType(TYPE[typ])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.ElapsedTimer","title":"<code>ElapsedTimer</code>","text":"<p>         Bases: <code>QtCore.QElapsedTimer</code></p> Source code in <code>prettyqt\\core\\elapsedtimer.py</code> <pre><code>class ElapsedTimer(QtCore.QElapsedTimer):\n    def __bool__(self):\n        return self.isValid()\n\n    def get_clock_type(self) -&gt; ClockTypeStr:\n\"\"\"Return current clock type.\n\n        Returns:\n            clock type\n        \"\"\"\n        return CLOCK_TYPE.inverse[self.clockType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.elapsedtimer.ElapsedTimer.get_clock_type","title":"<code>get_clock_type() -&gt; ClockTypeStr</code>","text":"<p>Return current clock type.</p> <p>Returns:</p> Type Description <code>ClockTypeStr</code> <p>clock type</p> Source code in <code>prettyqt\\core\\elapsedtimer.py</code> <pre><code>def get_clock_type(self) -&gt; ClockTypeStr:\n\"\"\"Return current clock type.\n\n    Returns:\n        clock type\n    \"\"\"\n    return CLOCK_TYPE.inverse[self.clockType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.FileDeviceMixin","title":"<code>FileDeviceMixin</code>","text":"<p>         Bases: <code>core.IODeviceMixin</code></p> Source code in <code>prettyqt\\core\\filedevice.py</code> <pre><code>class FileDeviceMixin(core.IODeviceMixin):\n    def __repr__(self):\n        return get_repr(self, self.fileName())\n\n    def __str__(self):\n        return self.fileName()\n\n    def set_file_time(self, file_time: datatypes.DateTimeType, typ: FileTimeStr) -&gt; bool:\n\"\"\"Set file time.\n\n        Args:\n            file_time: file time to set\n            typ: file time type\n\n        Raises:\n            InvalidParamError: file time does not exist\n        \"\"\"\n        if isinstance(file_time, str):\n            file_time = dateutil.parser.parse(file_time)\n        if typ not in FILE_TIME:\n            raise InvalidParamError(typ, FILE_TIME)\n        return self.setFileTime(file_time, FILE_TIME[typ])  # type: ignore\n\n    def get_file_time(self, typ: FileTimeStr) -&gt; datetime.datetime | None:\n\"\"\"Return current file time.\n\n        Returns:\n            file time\n        \"\"\"\n        if typ not in FILE_TIME:\n            raise InvalidParamError(typ, FILE_TIME)\n        if date := self.fileTime(FILE_TIME[typ]):\n            return date.toPython()  # type: ignore\n\n    def get_error(self) -&gt; FileErrorStr:\n\"\"\"Return file error status.\n\n        Returns:\n            file error status\n        \"\"\"\n        return FILE_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.filedevice.FileDeviceMixin.get_error","title":"<code>get_error() -&gt; FileErrorStr</code>","text":"<p>Return file error status.</p> <p>Returns:</p> Type Description <code>FileErrorStr</code> <p>file error status</p> Source code in <code>prettyqt\\core\\filedevice.py</code> <pre><code>def get_error(self) -&gt; FileErrorStr:\n\"\"\"Return file error status.\n\n    Returns:\n        file error status\n    \"\"\"\n    return FILE_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.filedevice.FileDeviceMixin.get_file_time","title":"<code>get_file_time(typ: FileTimeStr) -&gt; datetime.datetime | None</code>","text":"<p>Return current file time.</p> <p>Returns:</p> Type Description <code>datetime.datetime | None</code> <p>file time</p> Source code in <code>prettyqt\\core\\filedevice.py</code> <pre><code>def get_file_time(self, typ: FileTimeStr) -&gt; datetime.datetime | None:\n\"\"\"Return current file time.\n\n    Returns:\n        file time\n    \"\"\"\n    if typ not in FILE_TIME:\n        raise InvalidParamError(typ, FILE_TIME)\n    if date := self.fileTime(FILE_TIME[typ]):\n        return date.toPython()  # type: ignore\n</code></pre>"},{"location":"api/core.html#prettyqt.core.filedevice.FileDeviceMixin.set_file_time","title":"<code>set_file_time(file_time: datatypes.DateTimeType, typ: FileTimeStr) -&gt; bool</code>","text":"<p>Set file time.</p> <p>Parameters:</p> Name Type Description Default <code>file_time</code> <code>datatypes.DateTimeType</code> <p>file time to set</p> required <code>typ</code> <code>FileTimeStr</code> <p>file time type</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>file time does not exist</p> Source code in <code>prettyqt\\core\\filedevice.py</code> <pre><code>def set_file_time(self, file_time: datatypes.DateTimeType, typ: FileTimeStr) -&gt; bool:\n\"\"\"Set file time.\n\n    Args:\n        file_time: file time to set\n        typ: file time type\n\n    Raises:\n        InvalidParamError: file time does not exist\n    \"\"\"\n    if isinstance(file_time, str):\n        file_time = dateutil.parser.parse(file_time)\n    if typ not in FILE_TIME:\n        raise InvalidParamError(typ, FILE_TIME)\n    return self.setFileTime(file_time, FILE_TIME[typ])  # type: ignore\n</code></pre>"},{"location":"api/core.html#prettyqt.core.OperatingSystemVersion","title":"<code>OperatingSystemVersion</code>","text":"<p>         Bases: <code>QtCore.QOperatingSystemVersion</code></p> Source code in <code>prettyqt\\core\\operatingsystemversion.py</code> <pre><code>class OperatingSystemVersion(QtCore.QOperatingSystemVersion):\n    def __init__(\n        self,\n        typ: QtCore.QOperatingSystemVersion.OSType | str,\n        major: int,\n        minor: int | None = None,\n        micro: int | None = None,\n    ):\n        os_type = OS_TYPE[typ] if isinstance(typ, str) else typ\n        if minor is None:\n            minor = -1\n        if micro is None:\n            micro = -1\n        super().__init__(os_type, major, minor, micro)\n\n    def __repr__(self):\n        return get_repr(\n            self,\n            self.get_type(),\n            self.majorVersion(),\n            self.minorVersion(),\n            self.microVersion(),\n        )\n\n    def __reduce__(self):\n        return (\n            type(self),\n            (\n                self.get_type(),\n                self.majorVersion(),\n                self.minorVersion(),\n                self.microVersion(),\n            ),\n        )\n\n    def __eq__(self, other):\n        return (\n            (\n                self.get_type() == other.get_type()\n                and self.get_versionnumber() == other.get_versionnumber()\n            )\n            if isinstance(other, OperatingSystemVersion)\n            else False\n        )\n\n    def __hash__(self):\n        return hash(\n            (\n                self.get_type(),\n                self.majorVersion(),\n                self.minorVersion(),\n                self.microVersion(),\n            )\n        )\n\n    def get_type(self) -&gt; OsTypeStr:\n\"\"\"Get current os type.\n\n        Returns:\n            current os type\n        \"\"\"\n        return OS_TYPE.inverse[self.type()]\n\n    def get_versionnumber(self) -&gt; core.VersionNumber:\n        return core.VersionNumber(\n            self.majorVersion(), self.minorVersion(), self.microVersion()\n        )\n</code></pre>"},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion.get_type","title":"<code>get_type() -&gt; OsTypeStr</code>","text":"<p>Get current os type.</p> <p>Returns:</p> Type Description <code>OsTypeStr</code> <p>current os type</p> Source code in <code>prettyqt\\core\\operatingsystemversion.py</code> <pre><code>def get_type(self) -&gt; OsTypeStr:\n\"\"\"Get current os type.\n\n    Returns:\n        current os type\n    \"\"\"\n    return OS_TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.Process","title":"<code>Process</code>","text":"<p>         Bases: <code>core.IODeviceMixin</code>, <code>QtCore.QProcess</code></p> Source code in <code>prettyqt\\core\\process.py</code> <pre><code>class Process(core.IODeviceMixin, QtCore.QProcess):\n    def set_read_channel(self, channel: ProcessChannelStr):\n\"\"\"Set the input channel channel.\n\n        Args:\n            channel: channel to set\n\n        Raises:\n            InvalidParamError: invalid channel\n        \"\"\"\n        if channel not in PROCESS_CHANNELS:\n            raise InvalidParamError(channel, PROCESS_CHANNELS)\n        self.setReadChannel(PROCESS_CHANNELS[channel])\n\n    def get_read_channel(self) -&gt; ProcessChannelStr:\n        return PROCESS_CHANNELS.inverse[self.readChannel()]\n\n    def close_read_channel(self, channel: ProcessChannelStr):\n        self.closeReadChannel(PROCESS_CHANNELS[channel])\n\n    def set_input_channel_mode(self, mode: InputChannelModeStr):\n\"\"\"Set the input channel mode.\n\n        Args:\n            mode: mode to set\n\n        Raises:\n            InvalidParamError: invalid mode\n        \"\"\"\n        if mode not in INPUT_CHANNEL_MODES:\n            raise InvalidParamError(mode, INPUT_CHANNEL_MODES)\n        self.setInputChannelMode(INPUT_CHANNEL_MODES[mode])\n\n    def get_input_channel_mode(self) -&gt; InputChannelModeStr:\n        return INPUT_CHANNEL_MODES.inverse[self.inputChannelMode()]\n\n    def set_process_channel_mode(self, mode: ProcessChannelModeStr):\n\"\"\"Set the process channel mode.\n\n        Args:\n            mode: mode to set\n\n        Raises:\n            InvalidParamError: invalid mode\n        \"\"\"\n        if mode not in PROCESS_CHANNEL_MODES:\n            raise InvalidParamError(mode, PROCESS_CHANNEL_MODES)\n        self.setProcessChannelMode(PROCESS_CHANNEL_MODES[mode])\n\n    def get_process_channel_mode(self) -&gt; ProcessChannelModeStr:\n        return PROCESS_CHANNEL_MODES.inverse[self.processChannelMode()]\n\n    def set_state(self, state: ProcessStateStr):\n\"\"\"Set the process state.\n\n        Args:\n            state: state to set\n\n        Raises:\n            InvalidParamError: invalid state\n        \"\"\"\n        if state not in PROCESS_STATES:\n            raise InvalidParamError(state, PROCESS_STATES)\n        self.setProcessState(PROCESS_STATES[state])\n\n    def get_state(self) -&gt; ProcessStateStr:\n        return PROCESS_STATES.inverse[self.state()]\n\n    def get_error(self) -&gt; ProcessErrorStr:\n        return PROCESS_ERRORS.inverse[self.error()]\n\n    def get_exit_status(self) -&gt; ExitStatusStr:\n        return EXIT_STATUS.inverse[self.exitStatus()]\n\n    def get_process_environment(self) -&gt; core.ProcessEnvironment:\n        return core.ProcessEnvironment(self.processEnvironment())\n\n    @contextlib.contextmanager\n    def edit_process_environment(self):\n        env = self.get_process_environment()\n        yield env\n        self.setProcessEnvironment(env)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_input_channel_mode","title":"<code>set_input_channel_mode(mode: InputChannelModeStr)</code>","text":"<p>Set the input channel mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>InputChannelModeStr</code> <p>mode to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid mode</p> Source code in <code>prettyqt\\core\\process.py</code> <pre><code>def set_input_channel_mode(self, mode: InputChannelModeStr):\n\"\"\"Set the input channel mode.\n\n    Args:\n        mode: mode to set\n\n    Raises:\n        InvalidParamError: invalid mode\n    \"\"\"\n    if mode not in INPUT_CHANNEL_MODES:\n        raise InvalidParamError(mode, INPUT_CHANNEL_MODES)\n    self.setInputChannelMode(INPUT_CHANNEL_MODES[mode])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_process_channel_mode","title":"<code>set_process_channel_mode(mode: ProcessChannelModeStr)</code>","text":"<p>Set the process channel mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ProcessChannelModeStr</code> <p>mode to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid mode</p> Source code in <code>prettyqt\\core\\process.py</code> <pre><code>def set_process_channel_mode(self, mode: ProcessChannelModeStr):\n\"\"\"Set the process channel mode.\n\n    Args:\n        mode: mode to set\n\n    Raises:\n        InvalidParamError: invalid mode\n    \"\"\"\n    if mode not in PROCESS_CHANNEL_MODES:\n        raise InvalidParamError(mode, PROCESS_CHANNEL_MODES)\n    self.setProcessChannelMode(PROCESS_CHANNEL_MODES[mode])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_read_channel","title":"<code>set_read_channel(channel: ProcessChannelStr)</code>","text":"<p>Set the input channel channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>ProcessChannelStr</code> <p>channel to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid channel</p> Source code in <code>prettyqt\\core\\process.py</code> <pre><code>def set_read_channel(self, channel: ProcessChannelStr):\n\"\"\"Set the input channel channel.\n\n    Args:\n        channel: channel to set\n\n    Raises:\n        InvalidParamError: invalid channel\n    \"\"\"\n    if channel not in PROCESS_CHANNELS:\n        raise InvalidParamError(channel, PROCESS_CHANNELS)\n    self.setReadChannel(PROCESS_CHANNELS[channel])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_state","title":"<code>set_state(state: ProcessStateStr)</code>","text":"<p>Set the process state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>ProcessStateStr</code> <p>state to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid state</p> Source code in <code>prettyqt\\core\\process.py</code> <pre><code>def set_state(self, state: ProcessStateStr):\n\"\"\"Set the process state.\n\n    Args:\n        state: state to set\n\n    Raises:\n        InvalidParamError: invalid state\n    \"\"\"\n    if state not in PROCESS_STATES:\n        raise InvalidParamError(state, PROCESS_STATES)\n    self.setProcessState(PROCESS_STATES[state])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.Settings","title":"<code>Settings</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtCore.QSettings</code></p> Source code in <code>prettyqt\\core\\settings.py</code> <pre><code>class Settings(core.ObjectMixin, QtCore.QSettings):\n    def __init__(self, *args, settings_id: str | None = None):\n        super().__init__(*args)\n        self.settings_id = settings_id\n\n    def __repr__(self):\n        return f\"{type(self).__name__}: {self.as_dict()}\"\n\n    def __contains__(self, key: str) -&gt; bool:\n        return self.contains(key)\n\n    def __enter__(self):\n        if self.settings_id:\n            self.beginGroup(self.settings_id)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if self.settings_id:\n            self.endGroup()\n\n    def __getitem__(self, index: str):\n        return self.get_value(index)\n\n    def __setitem__(self, name: str, value):\n        return self.set_value(name, value)\n\n    def __delitem__(self, key: str):\n        if not self.contains(key):\n            raise KeyError(key)\n        return self.remove(key)\n\n    def __iter__(self) -&gt; Iterator[tuple[str, Any]]:\n        return iter(self.items())\n\n    def __len__(self) -&gt; int:\n        return len(self.allKeys())\n\n    @classmethod\n    def build_from_dict(cls, dct: dict[str, Any]):\n        settings = cls()\n        for k, v in dct.items():\n            settings.set_value(k, v)\n        return settings\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        return dict(self.items())\n\n    def set_value(self, key: str, value):\n        if not self.applicationName():\n            raise RuntimeError(\"no app name defined\")\n        self.setValue(key, dict(value=value))\n\n    def set_values(self, dct: dict[str, Any]):\n        for k, v in dct.items():\n            self.set_value(k, v)\n\n    def get_value(self, key: str, default=None):\n        if not self.contains(key):\n            return default\n        val = self.value(key)\n        # this is for migration\n        if not isinstance(val, dict) or \"value\" not in val:\n            self.set_value(key, val)\n            return val\n        return val[\"value\"]\n\n    @classmethod\n    def set_default_format(cls, fmt: FormatStr):\n\"\"\"Set the default format.\n\n        Args:\n            fmt: the default format to use\n\n        Raises:\n            InvalidParamError: invalid format\n        \"\"\"\n        if fmt not in FORMAT:\n            raise InvalidParamError(fmt, FORMAT)\n        cls.setDefaultFormat(FORMAT[fmt])\n\n    @classmethod\n    def get_default_format(cls) -&gt; FormatStr:\n\"\"\"Return default settings format.\n\n        Returns:\n            default settings format\n        \"\"\"\n        return FORMAT.inverse[cls.defaultFormat()]\n\n    def get_scope(self) -&gt; ScopeStr:\n\"\"\"Return scope.\n\n        Returns:\n            scope\n        \"\"\"\n        return SCOPE.inverse[self.scope()]\n\n    @classmethod\n    def set_path(cls, fmt: FormatStr, scope: ScopeStr, path: datatypes.PathType):\n\"\"\"Set the path to the settings file.\n\n        Args:\n            fmt: the default format to use\n            scope: the scope to use\n            path: the path to set\n\n        Raises:\n            InvalidParamError: invalid format or scope\n        \"\"\"\n        if fmt not in FORMAT:\n            raise InvalidParamError(fmt, FORMAT)\n        if scope not in SCOPE:\n            raise InvalidParamError(scope, SCOPE)\n        cls.setPath(FORMAT[fmt], SCOPE[scope], os.fspath(path))\n\n    @contextlib.contextmanager\n    def edit_group(self, prefix: str):\n\"\"\"Context manager for setting groups.\n\n        Args:\n            prefix: setting prefix for group\n        \"\"\"\n        self.beginGroup(prefix)\n        yield None\n        self.endGroup()\n\n    @contextlib.contextmanager\n    def write_array(self, prefix: str, size: int | None = None):\n\"\"\"Context manager for writing arrays.\n\n        Args:\n            prefix: prefix for settings array\n            size: size of settings array\n        \"\"\"\n        if size is None:\n            size = -1\n        self.beginWriteArray(prefix, size)\n        yield None\n        self.endArray()\n\n    @contextlib.contextmanager\n    def read_array(self, prefix: str):\n\"\"\"Context manager for reading arrays.\n\n        Args:\n            prefix: prefix for settings array\n        \"\"\"\n        self.beginReadArray(prefix)\n        yield None\n        self.endArray()\n\n    # Dictionary interface\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.get_value(key, default)\n\n    def setdefault(self, key: str, default: Any = None) -&gt; Any:\n        if not self.contains(key):\n            self.set_value(key, default)\n            return default\n        return self.get_value(key)\n\n    def keys(self) -&gt; list[str]:\n        return self.allKeys()\n\n    def values(self) -&gt; Iterator[Any]:\n        return (self.get_value(key) for key in self.allKeys())\n\n    def items(self):\n        return zip(self.keys(), self.values())\n\n    def pop(self, key: str):\n        if self.contains(key):\n            return self.get_value(key)\n        raise KeyError(key)\n\n    def popitem(self) -&gt; tuple[str, Any]:\n        key = self.keys()[0]\n        return (key, self.get_value(key))\n\n    def update(self, other: Mapping[str, Any]):\n        for k, v in other.items():\n            self.set_value(k, v)\n\n    @classmethod\n    def register_extensions(\n        cls,\n        *exts: str,\n        app_name: str | None = None,\n        app_path: None | datatypes.PathType = None,\n    ):\n        logger.debug(f\"assigning extensions {exts} to {app_name}\")\n        s = cls(\"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Classes\", Settings.Format.NativeFormat)\n        if app_path is None:\n            app_path = str(core.CoreApplication.get_application_file_path())\n        app_path = os.fspath(app_path)\n        if app_name is None:\n            app_name = core.CoreApplication.applicationName()\n        for ext in exts:\n            s.setValue(f\"{ext}/DefaultIcon/.\", app_path)  # perhaps ,0 after app_path\n            s.setValue(f\"{ext}/.\", app_name)\n        s.setValue(f\"{app_name}/shell/open/command/.\", f\"{app_path} %1\")\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.edit_group","title":"<code>edit_group(prefix: str)</code>","text":"<p>Context manager for setting groups.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>setting prefix for group</p> required Source code in <code>prettyqt\\core\\settings.py</code> <pre><code>@contextlib.contextmanager\ndef edit_group(self, prefix: str):\n\"\"\"Context manager for setting groups.\n\n    Args:\n        prefix: setting prefix for group\n    \"\"\"\n    self.beginGroup(prefix)\n    yield None\n    self.endGroup()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_default_format","title":"<code>get_default_format() -&gt; FormatStr</code>  <code>classmethod</code>","text":"<p>Return default settings format.</p> <p>Returns:</p> Type Description <code>FormatStr</code> <p>default settings format</p> Source code in <code>prettyqt\\core\\settings.py</code> <pre><code>@classmethod\ndef get_default_format(cls) -&gt; FormatStr:\n\"\"\"Return default settings format.\n\n    Returns:\n        default settings format\n    \"\"\"\n    return FORMAT.inverse[cls.defaultFormat()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_scope","title":"<code>get_scope() -&gt; ScopeStr</code>","text":"<p>Return scope.</p> <p>Returns:</p> Type Description <code>ScopeStr</code> <p>scope</p> Source code in <code>prettyqt\\core\\settings.py</code> <pre><code>def get_scope(self) -&gt; ScopeStr:\n\"\"\"Return scope.\n\n    Returns:\n        scope\n    \"\"\"\n    return SCOPE.inverse[self.scope()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.read_array","title":"<code>read_array(prefix: str)</code>","text":"<p>Context manager for reading arrays.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix for settings array</p> required Source code in <code>prettyqt\\core\\settings.py</code> <pre><code>@contextlib.contextmanager\ndef read_array(self, prefix: str):\n\"\"\"Context manager for reading arrays.\n\n    Args:\n        prefix: prefix for settings array\n    \"\"\"\n    self.beginReadArray(prefix)\n    yield None\n    self.endArray()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_default_format","title":"<code>set_default_format(fmt: FormatStr)</code>  <code>classmethod</code>","text":"<p>Set the default format.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>FormatStr</code> <p>the default format to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid format</p> Source code in <code>prettyqt\\core\\settings.py</code> <pre><code>@classmethod\ndef set_default_format(cls, fmt: FormatStr):\n\"\"\"Set the default format.\n\n    Args:\n        fmt: the default format to use\n\n    Raises:\n        InvalidParamError: invalid format\n    \"\"\"\n    if fmt not in FORMAT:\n        raise InvalidParamError(fmt, FORMAT)\n    cls.setDefaultFormat(FORMAT[fmt])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_path","title":"<code>set_path(fmt: FormatStr, scope: ScopeStr, path: datatypes.PathType)</code>  <code>classmethod</code>","text":"<p>Set the path to the settings file.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>FormatStr</code> <p>the default format to use</p> required <code>scope</code> <code>ScopeStr</code> <p>the scope to use</p> required <code>path</code> <code>datatypes.PathType</code> <p>the path to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid format or scope</p> Source code in <code>prettyqt\\core\\settings.py</code> <pre><code>@classmethod\ndef set_path(cls, fmt: FormatStr, scope: ScopeStr, path: datatypes.PathType):\n\"\"\"Set the path to the settings file.\n\n    Args:\n        fmt: the default format to use\n        scope: the scope to use\n        path: the path to set\n\n    Raises:\n        InvalidParamError: invalid format or scope\n    \"\"\"\n    if fmt not in FORMAT:\n        raise InvalidParamError(fmt, FORMAT)\n    if scope not in SCOPE:\n        raise InvalidParamError(scope, SCOPE)\n    cls.setPath(FORMAT[fmt], SCOPE[scope], os.fspath(path))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.write_array","title":"<code>write_array(prefix: str, size: int | None = None)</code>","text":"<p>Context manager for writing arrays.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix for settings array</p> required <code>size</code> <code>int | None</code> <p>size of settings array</p> <code>None</code> Source code in <code>prettyqt\\core\\settings.py</code> <pre><code>@contextlib.contextmanager\ndef write_array(self, prefix: str, size: int | None = None):\n\"\"\"Context manager for writing arrays.\n\n    Args:\n        prefix: prefix for settings array\n        size: size of settings array\n    \"\"\"\n    if size is None:\n        size = -1\n    self.beginWriteArray(prefix, size)\n    yield None\n    self.endArray()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.SocketNotifier","title":"<code>SocketNotifier</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtCore.QSocketNotifier</code></p> Source code in <code>prettyqt\\core\\socketnotifier.py</code> <pre><code>class SocketNotifier(core.ObjectMixin, QtCore.QSocketNotifier):\n    # def __repr__(self):\n    #     return f\"{type(self).__name__}({self.socket()}, {self.type()})\"\n\n    def get_type(self) -&gt; TypeStr:\n\"\"\"Return socket event type.\n\n        Returns:\n            socket event type\n        \"\"\"\n        return TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.socketnotifier.SocketNotifier.get_type","title":"<code>get_type() -&gt; TypeStr</code>","text":"<p>Return socket event type.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>socket event type</p> Source code in <code>prettyqt\\core\\socketnotifier.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return socket event type.\n\n    Returns:\n        socket event type\n    \"\"\"\n    return TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.TextStream","title":"<code>TextStream</code>","text":"<p>         Bases: <code>QtCore.QTextStream</code></p> Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>class TextStream(QtCore.QTextStream):\n    def set_field_alignment(self, alignment: FieldAlignmentStr):\n\"\"\"Set the field alignment.\n\n        Args:\n            alignment: field alignment\n\n        Raises:\n            InvalidParamError: invalid field alignment\n        \"\"\"\n        if alignment not in FIELD_ALIGNMENT:\n            raise InvalidParamError(alignment, FIELD_ALIGNMENT)\n        self.setFieldAlignment(FIELD_ALIGNMENT[alignment])\n\n    def get_field_alignment(self) -&gt; FieldAlignmentStr:\n\"\"\"Get current field alignment.\n\n        Returns:\n            current field alignment\n        \"\"\"\n        return FIELD_ALIGNMENT.inverse[self.fieldAlignment()]\n\n    def set_status(self, status: StatusStr):\n\"\"\"Set the status.\n\n        Args:\n            status: status\n\n        Raises:\n            InvalidParamError: invalid status\n        \"\"\"\n        if status not in STATUS:\n            raise InvalidParamError(status, STATUS)\n        self.setStatus(STATUS[status])\n\n    def get_status(self) -&gt; StatusStr:\n\"\"\"Get current status.\n\n        Returns:\n            current status\n        \"\"\"\n        return STATUS.inverse[self.status()]\n\n    def set_real_number_notation(self, notation: RealNumberNotationStr):\n\"\"\"Set the real number notation.\n\n        Args:\n            notation: real number notation\n\n        Raises:\n            InvalidParamError: invalid real number notation\n        \"\"\"\n        if notation not in REAL_NUMBER_NOTATION:\n            raise InvalidParamError(notation, REAL_NUMBER_NOTATION)\n        self.setRealNumberNotation(REAL_NUMBER_NOTATION[notation])\n\n    def get_real_number_notation(self) -&gt; RealNumberNotationStr:\n\"\"\"Get current real number notation.\n\n        Returns:\n            current real number notation\n        \"\"\"\n        return REAL_NUMBER_NOTATION.inverse[self.realNumberNotation()]\n\n    def read_lines(self) -&gt; Iterator[str]:\n        while True:\n            if msg := self.readLine():\n                yield msg\n            else:\n                return\n\n    def get_number_flags(self) -&gt; list[NumberFlagStr]:\n        return NUMBER_FLAGS.get_list(self.numberFlags())\n\n    def set_number_flags(self, *flags: NumberFlagStr):\n        for item in flags:\n            if item not in NUMBER_FLAGS:\n                raise InvalidParamError(item, NUMBER_FLAGS)\n        flags = helpers.merge_flags(flags, NUMBER_FLAGS)\n        self.setNumberFlags(flags)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_field_alignment","title":"<code>get_field_alignment() -&gt; FieldAlignmentStr</code>","text":"<p>Get current field alignment.</p> <p>Returns:</p> Type Description <code>FieldAlignmentStr</code> <p>current field alignment</p> Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def get_field_alignment(self) -&gt; FieldAlignmentStr:\n\"\"\"Get current field alignment.\n\n    Returns:\n        current field alignment\n    \"\"\"\n    return FIELD_ALIGNMENT.inverse[self.fieldAlignment()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_real_number_notation","title":"<code>get_real_number_notation() -&gt; RealNumberNotationStr</code>","text":"<p>Get current real number notation.</p> <p>Returns:</p> Type Description <code>RealNumberNotationStr</code> <p>current real number notation</p> Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def get_real_number_notation(self) -&gt; RealNumberNotationStr:\n\"\"\"Get current real number notation.\n\n    Returns:\n        current real number notation\n    \"\"\"\n    return REAL_NUMBER_NOTATION.inverse[self.realNumberNotation()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_status","title":"<code>get_status() -&gt; StatusStr</code>","text":"<p>Get current status.</p> <p>Returns:</p> Type Description <code>StatusStr</code> <p>current status</p> Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def get_status(self) -&gt; StatusStr:\n\"\"\"Get current status.\n\n    Returns:\n        current status\n    \"\"\"\n    return STATUS.inverse[self.status()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_field_alignment","title":"<code>set_field_alignment(alignment: FieldAlignmentStr)</code>","text":"<p>Set the field alignment.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>FieldAlignmentStr</code> <p>field alignment</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid field alignment</p> Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def set_field_alignment(self, alignment: FieldAlignmentStr):\n\"\"\"Set the field alignment.\n\n    Args:\n        alignment: field alignment\n\n    Raises:\n        InvalidParamError: invalid field alignment\n    \"\"\"\n    if alignment not in FIELD_ALIGNMENT:\n        raise InvalidParamError(alignment, FIELD_ALIGNMENT)\n    self.setFieldAlignment(FIELD_ALIGNMENT[alignment])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_real_number_notation","title":"<code>set_real_number_notation(notation: RealNumberNotationStr)</code>","text":"<p>Set the real number notation.</p> <p>Parameters:</p> Name Type Description Default <code>notation</code> <code>RealNumberNotationStr</code> <p>real number notation</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid real number notation</p> Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def set_real_number_notation(self, notation: RealNumberNotationStr):\n\"\"\"Set the real number notation.\n\n    Args:\n        notation: real number notation\n\n    Raises:\n        InvalidParamError: invalid real number notation\n    \"\"\"\n    if notation not in REAL_NUMBER_NOTATION:\n        raise InvalidParamError(notation, REAL_NUMBER_NOTATION)\n    self.setRealNumberNotation(REAL_NUMBER_NOTATION[notation])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_status","title":"<code>set_status(status: StatusStr)</code>","text":"<p>Set the status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>StatusStr</code> <p>status</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid status</p> Source code in <code>prettyqt\\core\\textstream.py</code> <pre><code>def set_status(self, status: StatusStr):\n\"\"\"Set the status.\n\n    Args:\n        status: status\n\n    Raises:\n        InvalidParamError: invalid status\n    \"\"\"\n    if status not in STATUS:\n        raise InvalidParamError(status, STATUS)\n    self.setStatus(STATUS[status])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.TimeLine","title":"<code>TimeLine</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtCore.QTimeLine</code></p> Source code in <code>prettyqt\\core\\timeline.py</code> <pre><code>class TimeLine(core.ObjectMixin, QtCore.QTimeLine):\n    def serialize_fields(self):\n        return dict(\n            current_time=self.currentTime(),\n            direction=self.get_direction(),\n            duration=self.duration(),\n            easing_curve=self.easingCurve(),\n            loop_count=self.loopCount(),\n            update_interval=self.updateInterval(),\n        )\n\n    def set_direction(self, direction: DirectionStr):\n\"\"\"Set the direction.\n\n        Args:\n            direction: direction\n\n        Raises:\n            InvalidParamError: direction does not exist\n        \"\"\"\n        if direction not in DIRECTION:\n            raise InvalidParamError(direction, DIRECTION)\n        self.setDirection(DIRECTION[direction])\n\n    def get_direction(self) -&gt; DirectionStr:\n\"\"\"Return current direction.\n\n        Returns:\n            direction\n        \"\"\"\n        return DIRECTION.inverse[self.direction()]\n\n    def get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n\n        Returns:\n            state\n        \"\"\"\n        return STATE.inverse[self.state()]\n\n    def set_easing(\n        self, easing_type: core.easingcurve.TypeStr | Callable[[float], float]\n    ) -&gt; core.EasingCurve:\n        curve = core.EasingCurve()\n        if isinstance(easing_type, str):\n            curve.set_type(easing_type)\n        else:\n            curve.set_custom_type(easing_type)\n        self.setEasingCurve(curve)\n        return curve\n\n    def get_easing(self) -&gt; core.easingcurve.TypeStr | Callable[[float], float]:\n        curve = core.EasingCurve(self.easingCurve())\n        typ = curve.get_type()\n        return curve.get_custom_type() if typ == \"custom\" else typ\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_direction","title":"<code>get_direction() -&gt; DirectionStr</code>","text":"<p>Return current direction.</p> <p>Returns:</p> Type Description <code>DirectionStr</code> <p>direction</p> Source code in <code>prettyqt\\core\\timeline.py</code> <pre><code>def get_direction(self) -&gt; DirectionStr:\n\"\"\"Return current direction.\n\n    Returns:\n        direction\n    \"\"\"\n    return DIRECTION.inverse[self.direction()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_state","title":"<code>get_state() -&gt; StateStr</code>","text":"<p>Return current state.</p> <p>Returns:</p> Type Description <code>StateStr</code> <p>state</p> Source code in <code>prettyqt\\core\\timeline.py</code> <pre><code>def get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n\n    Returns:\n        state\n    \"\"\"\n    return STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.set_direction","title":"<code>set_direction(direction: DirectionStr)</code>","text":"<p>Set the direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>DirectionStr</code> <p>direction</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>direction does not exist</p> Source code in <code>prettyqt\\core\\timeline.py</code> <pre><code>def set_direction(self, direction: DirectionStr):\n\"\"\"Set the direction.\n\n    Args:\n        direction: direction\n\n    Raises:\n        InvalidParamError: direction does not exist\n    \"\"\"\n    if direction not in DIRECTION:\n        raise InvalidParamError(direction, DIRECTION)\n    self.setDirection(DIRECTION[direction])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.Timer","title":"<code>Timer</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtCore.QTimer</code></p> Source code in <code>prettyqt\\core\\timer.py</code> <pre><code>class Timer(core.ObjectMixin, QtCore.QTimer):\n    def serialize_fields(self):\n        return dict(\n            interval=self.interval(),\n            single_shot=self.isSingleShot(),\n            timer_type=self.get_type(),\n        )\n\n    @classmethod\n    def single_shot(cls, callback: Callable) -&gt; Timer:\n        timer = cls()\n        timer.timeout.connect(callback)\n        timer.setSingleShot(True)\n        return timer\n\n    def set_type(self, typ: constants.TimerTypeStr):\n\"\"\"Set the timer type.\n\n        Args:\n            typ: timer type\n\n        Raises:\n            InvalidParamError: timer type does not exist\n        \"\"\"\n        if typ not in constants.TIMER_TYPE:\n            raise InvalidParamError(typ, constants.TIMER_TYPE)\n        self.setTimerType(constants.TIMER_TYPE[typ])\n\n    def get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n\n        Returns:\n            timer type\n        \"\"\"\n        return constants.TIMER_TYPE.inverse[self.timerType()]\n\n    def set_interval(self, interval: int | str):\n        if isinstance(interval, str):\n            interval = helpers.parse_time(interval)\n        self.setInterval(interval)\n\n    def start_timer(self, interval: None | int | str = None):\n        if isinstance(interval, str):\n            interval = helpers.parse_time(interval)\n        if interval is None:\n            self.start()\n        else:\n            self.start(interval)\n\n    def restart(self):\n        self.stop()\n        self.start()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timer.Timer.get_type","title":"<code>get_type() -&gt; constants.TimerTypeStr</code>","text":"<p>Return current timer type.</p> <p>Returns:</p> Type Description <code>constants.TimerTypeStr</code> <p>timer type</p> Source code in <code>prettyqt\\core\\timer.py</code> <pre><code>def get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n\n    Returns:\n        timer type\n    \"\"\"\n    return constants.TIMER_TYPE.inverse[self.timerType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timer.Timer.set_type","title":"<code>set_type(typ: constants.TimerTypeStr)</code>","text":"<p>Set the timer type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>constants.TimerTypeStr</code> <p>timer type</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>timer type does not exist</p> Source code in <code>prettyqt\\core\\timer.py</code> <pre><code>def set_type(self, typ: constants.TimerTypeStr):\n\"\"\"Set the timer type.\n\n    Args:\n        typ: timer type\n\n    Raises:\n        InvalidParamError: timer type does not exist\n    \"\"\"\n    if typ not in constants.TIMER_TYPE:\n        raise InvalidParamError(typ, constants.TIMER_TYPE)\n    self.setTimerType(constants.TIMER_TYPE[typ])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.Url","title":"<code>Url</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtCore.QUrl</code></p> Source code in <code>prettyqt\\core\\url.py</code> <pre><code>class Url(serializemixin.SerializeMixin, QtCore.QUrl):\n    def __init__(self, path: datatypes.UrlType | datatypes.PathType | None = None):\n        if path is None:\n            super().__init__()\n        else:\n            if isinstance(path, QtCore.QUrl):\n                super().__init__(path)\n            else:\n                super().__init__(os.fspath(path))\n            if isinstance(path, os.PathLike):\n                self.setScheme(\"file\")\n\n    # def __str__(self):\n    #     return self.absolutePath()\n\n    def __repr__(self):\n        return get_repr(self, self.toString())\n\n    def __str__(self):\n        return self.toString()\n\n    def serialize_fields(self):\n        return dict(path=self.toString())\n\n    def serialize(self) -&gt; dict[str, Any]:\n        return self.serialize_fields()\n\n    def to_string(self) -&gt; str:\n        return self.toString()\n\n    def to_path(self) -&gt; pathlib.Path:\n\"\"\"Get pathlib object from the URL.\n\n        Returns:\n            Path\n        \"\"\"\n        return pathlib.Path(str(self))\n\n    def is_local_file(self) -&gt; bool:\n        return self.isLocalFile()\n\n    @classmethod\n    def from_user_input(cls, url: str, working_dir: str | None = None) -&gt; Url:\n        if working_dir is None:\n            working_dir = \"\"\n        return cls(cls.fromUserInput(url, working_dir))\n\n    @classmethod\n    def from_local_file(cls, path: datatypes.PathType) -&gt; Url:\n        url = cls.fromLocalFile(os.fspath(path))\n        return cls(url)\n\n    def _has_explicit_scheme(self) -&gt; bool:\n\"\"\"Check if a url has an explicit scheme given.\"\"\"\n        return bool(\n            self.isValid()\n            and self.scheme()\n            and (self.host() or self.path())\n            and not self.path().startswith(\":\")\n        )\n\n    def is_special_url(self) -&gt; bool:\n\"\"\"Return True if url is an about:... or other special URL.\"\"\"\n        return self.scheme() in (\"about\", \"file\") if self.isValid() else False\n</code></pre>"},{"location":"api/core.html#prettyqt.core.url.Url.is_special_url","title":"<code>is_special_url() -&gt; bool</code>","text":"<p>Return True if url is an about:... or other special URL.</p> Source code in <code>prettyqt\\core\\url.py</code> <pre><code>def is_special_url(self) -&gt; bool:\n\"\"\"Return True if url is an about:... or other special URL.\"\"\"\n    return self.scheme() in (\"about\", \"file\") if self.isValid() else False\n</code></pre>"},{"location":"api/core.html#prettyqt.core.url.Url.to_path","title":"<code>to_path() -&gt; pathlib.Path</code>","text":"<p>Get pathlib object from the URL.</p> <p>Returns:</p> Type Description <code>pathlib.Path</code> <p>Path</p> Source code in <code>prettyqt\\core\\url.py</code> <pre><code>def to_path(self) -&gt; pathlib.Path:\n\"\"\"Get pathlib object from the URL.\n\n    Returns:\n        Path\n    \"\"\"\n    return pathlib.Path(str(self))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.UuidMixin","title":"<code>UuidMixin</code>","text":"Source code in <code>prettyqt\\core\\uuid.py</code> <pre><code>class UuidMixin:\n    def __repr__(self):\n        return get_repr(self, self.toString())\n\n    def __str__(self):\n        return self.toString()\n\n    def __bool__(self):\n        return not self.isNull()\n\n    def __reduce__(self):\n        return type(self), (self.toString(),)\n\n    def get_variant(self) -&gt; VariantStr:\n        return VARIANTS.inverse[self.variant()]\n\n    def get_version(self) -&gt; VersionStr:\n        return VERSION.inverse[self.version()]\n\n    @classmethod\n    def create_uuid(cls) -&gt; Uuid:\n        # workaround for PySide2, not able to clone in ctor\n        return cls(cls.createUuid().toString())\n\n    def to_string(self, fmt: StringFormatStr = \"with_braces\") -&gt; str:\n\"\"\"Return string representation of the Uuid.\n\n        Allowed values are \"with_braces\", \"without_braces\", \"id_128\"\n\n        Args:\n            fmt: Uuid format to use\n\n        Raises:\n            InvalidParamError: Uuid format does not exist\n        \"\"\"\n        if fmt not in STRING_FORMATS:\n            raise InvalidParamError(fmt, STRING_FORMATS)\n        return self.toString(STRING_FORMATS[fmt])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.uuid.UuidMixin.to_string","title":"<code>to_string(fmt: StringFormatStr = 'with_braces') -&gt; str</code>","text":"<p>Return string representation of the Uuid.</p> <p>Allowed values are \"with_braces\", \"without_braces\", \"id_128\"</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>StringFormatStr</code> <p>Uuid format to use</p> <code>'with_braces'</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>Uuid format does not exist</p> Source code in <code>prettyqt\\core\\uuid.py</code> <pre><code>def to_string(self, fmt: StringFormatStr = \"with_braces\") -&gt; str:\n\"\"\"Return string representation of the Uuid.\n\n    Allowed values are \"with_braces\", \"without_braces\", \"id_128\"\n\n    Args:\n        fmt: Uuid format to use\n\n    Raises:\n        InvalidParamError: Uuid format does not exist\n    \"\"\"\n    if fmt not in STRING_FORMATS:\n        raise InvalidParamError(fmt, STRING_FORMATS)\n    return self.toString(STRING_FORMATS[fmt])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.VersionNumber","title":"<code>VersionNumber</code>","text":"<p>         Bases: <code>QtCore.QVersionNumber</code></p> Source code in <code>prettyqt\\core\\versionnumber.py</code> <pre><code>class VersionNumber(QtCore.QVersionNumber):\n    def __init__(self, *args, **kwargs):\n        if len(args) == 1:\n            if isinstance(args[0], str):\n                args = tuple(int(i) for i in args[0].split(\".\"))\n            elif isinstance(args[0], tuple):\n                args = args[0]\n            # PySide6 Workaround:\n            elif isinstance(args[0], QtCore.QVersionNumber):\n                args = (\n                    args[0].majorVersion(),\n                    args[0].minorVersion(),\n                    args[0].microVersion(),\n                )\n        super().__init__(*args, **kwargs)\n\n    def __repr__(self):\n        return get_repr(self, self.major(), self.minor(), self.micro())\n\n    def __reduce__(self):\n        return type(self), (self.major(), self.minor(), self.micro())\n\n    def __str__(self):\n        return self.toString()\n\n    def __eq__(self, other):\n        if isinstance(other, str | tuple):\n            other = VersionNumber(other)\n        return super().__eq__(other)\n\n    def __hash__(self):\n        return hash((self.major(), self.minor(), self.micro()))\n\n    def __gt__(self, other: datatypes.SemanticVersionType):\n        if isinstance(other, str | tuple):\n            other = VersionNumber(other)\n        return super().__gt__(other)\n\n    def __ge__(self, other: datatypes.SemanticVersionType):\n        if isinstance(other, str | tuple):\n            other = VersionNumber(other)\n        return super().__ge__(other)\n\n    def __lt__(self, other: datatypes.SemanticVersionType):\n        if isinstance(other, str | tuple):\n            other = VersionNumber(other)\n        return super().__lt__(other)\n\n    def __le__(self, other: datatypes.SemanticVersionType):\n        if isinstance(other, str | tuple):\n            other = VersionNumber(other)\n        return super().__le__(other)\n\n    @classmethod\n    def get_qt_version(cls) -&gt; VersionNumber:\n        return cls(*[int(i) for i in QtCore.__version__.split(\".\")])\n\n    @classmethod\n    def get_python_version(cls) -&gt; VersionNumber:\n        return cls(*sys.version_info[:3])\n\n    def major(self) -&gt; int:\n\"\"\"An integer representing the major version.\"\"\"\n        return self.majorVersion()\n\n    def minor(self) -&gt; int:\n\"\"\"An integer representing the minor version.\"\"\"\n        return self.minorVersion()\n\n    def micro(self) -&gt; int:\n\"\"\"An integer representing the micro version.\"\"\"\n        return self.microVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.major","title":"<code>major() -&gt; int</code>","text":"<p>An integer representing the major version.</p> Source code in <code>prettyqt\\core\\versionnumber.py</code> <pre><code>def major(self) -&gt; int:\n\"\"\"An integer representing the major version.\"\"\"\n    return self.majorVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.micro","title":"<code>micro() -&gt; int</code>","text":"<p>An integer representing the micro version.</p> Source code in <code>prettyqt\\core\\versionnumber.py</code> <pre><code>def micro(self) -&gt; int:\n\"\"\"An integer representing the micro version.\"\"\"\n    return self.microVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.minor","title":"<code>minor() -&gt; int</code>","text":"<p>An integer representing the minor version.</p> Source code in <code>prettyqt\\core\\versionnumber.py</code> <pre><code>def minor(self) -&gt; int:\n\"\"\"An integer representing the minor version.\"\"\"\n    return self.minorVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.XmlStreamReader","title":"<code>XmlStreamReader</code>","text":"<p>         Bases: <code>QtCore.QXmlStreamReader</code></p> Source code in <code>prettyqt\\core\\xmlstreamreader.py</code> <pre><code>class XmlStreamReader(QtCore.QXmlStreamReader):\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        while not self.atEnd():\n            self.readNext()\n            if self.hasError():\n                raise RuntimeError(self.get_error())\n            return self\n        raise StopIteration\n\n    def get_error(self) -&gt; FileErrorStr:\n\"\"\"Return file error status.\n\n        Returns:\n            file error status\n        \"\"\"\n        return ERROR.inverse[self.error()]\n\n    def get_token_type(self) -&gt; TokenTypeStr:\n\"\"\"Get the current token type.\n\n        Returns:\n            token type\n        \"\"\"\n        return TOKEN_TYPE.inverse[self.tokenType()]\n\n    def read_next(self) -&gt; TokenTypeStr:\n\"\"\"Read the next token and returns its type.\n\n        Returns:\n            token type\n        \"\"\"\n        return TOKEN_TYPE.inverse[self.readNext()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.get_error","title":"<code>get_error() -&gt; FileErrorStr</code>","text":"<p>Return file error status.</p> <p>Returns:</p> Type Description <code>FileErrorStr</code> <p>file error status</p> Source code in <code>prettyqt\\core\\xmlstreamreader.py</code> <pre><code>def get_error(self) -&gt; FileErrorStr:\n\"\"\"Return file error status.\n\n    Returns:\n        file error status\n    \"\"\"\n    return ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.get_token_type","title":"<code>get_token_type() -&gt; TokenTypeStr</code>","text":"<p>Get the current token type.</p> <p>Returns:</p> Type Description <code>TokenTypeStr</code> <p>token type</p> Source code in <code>prettyqt\\core\\xmlstreamreader.py</code> <pre><code>def get_token_type(self) -&gt; TokenTypeStr:\n\"\"\"Get the current token type.\n\n    Returns:\n        token type\n    \"\"\"\n    return TOKEN_TYPE.inverse[self.tokenType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.read_next","title":"<code>read_next() -&gt; TokenTypeStr</code>","text":"<p>Read the next token and returns its type.</p> <p>Returns:</p> Type Description <code>TokenTypeStr</code> <p>token type</p> Source code in <code>prettyqt\\core\\xmlstreamreader.py</code> <pre><code>def read_next(self) -&gt; TokenTypeStr:\n\"\"\"Read the next token and returns its type.\n\n    Returns:\n        token type\n    \"\"\"\n    return TOKEN_TYPE.inverse[self.readNext()]\n</code></pre>"},{"location":"api/custom_delegates.html","title":"custom_delegates module","text":"<p>Module containing custom delegate classes.</p>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.IconDelegate","title":"<code>IconDelegate</code>","text":"<p>         Bases: <code>widgets.StyledItemDelegate</code></p> Source code in <code>prettyqt\\custom_delegates\\icondelegate.py</code> <pre><code>class IconDelegate(widgets.StyledItemDelegate):\n    def paint(\n        self,\n        painter: QtGui.QPainter,\n        option: QtWidgets.QStyleOptionViewItem,\n        index: QtCore.QModelIndex,\n    ):\n\"\"\"Override to paint an icon based on given Pixmap / Color / Icon.\n\n        Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000'\n\n        Args:\n            painter (QtGui.QPainter): painter to paint the icon\n            option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed\n            index (QtCore.QModelIndex): index which gets decorated\n        \"\"\"\n        super().paint(painter, option, index)\n        value = index.data(ICON_ROLE)\n        if not value:\n            return\n        margin = 10\n        mode = gui.Icon.Mode.Normal\n\n        if not (option.state &amp; widgets.Style.StateFlag.State_Enabled):\n            mode = gui.Icon.Mode.Disabled\n        elif option.state &amp; widgets.Style.StateFlag.State_Selected:\n            mode = gui.Icon.Mode.Selected\n        match value:\n            case QtGui.QPixmap():\n                icon = QtGui.QIcon(value)\n                option.decorationSize = int(value.size() / value.devicePixelRatio())\n\n            case QtGui.QColor():\n                pixmap = QtGui.QPixmap(option.decorationSize)\n                pixmap.fill(value)\n                icon = QtGui.QIcon(pixmap)\n\n            case QtGui.QImage():\n                icon = QtGui.QIcon(QtGui.QPixmap.fromImage(value))\n                option.decorationSize = int(value.size() / value.devicePixelRatio())\n\n            case QtGui.QIcon():\n                icon = value\n                is_on = option.state &amp; widgets.Style.StateFlag.State_Open\n                state = gui.Icon.State.On if is_on else gui.Icon.State.Off\n                actual_size = option.icon.actualSize(option.decorationSize, mode, state)\n                option.decorationSize &amp;= actual_size\n            case _:\n                raise ValueError(value)\n        r = core.Rect(core.Point(), option.decorationSize)\n        r.moveCenter(option.rect.center())\n        r.setRight(option.rect.right() - margin)\n        state = (\n            gui.Icon.State.On\n            if option.state &amp; widgets.Style.StateFlag.State_Open\n            else gui.Icon.State.Off\n        )\n        alignment = constants.ALIGN_RIGHT | constants.ALIGN_V_CENTER  # type: ignore\n        icon.paint(painter, r, alignment, mode, state)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate.paint","title":"<code>paint(painter: QtGui.QPainter, option: QtWidgets.QStyleOptionViewItem, index: QtCore.QModelIndex)</code>","text":"<p>Override to paint an icon based on given Pixmap / Color / Icon.</p> <p>Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000'</p> <p>Parameters:</p> Name Type Description Default <code>painter</code> <code>QtGui.QPainter</code> <p>painter to paint the icon</p> required <code>option</code> <code>QtWidgets.QStyleOptionViewItem</code> <p>state of the item to be displayed</p> required <code>index</code> <code>QtCore.QModelIndex</code> <p>index which gets decorated</p> required Source code in <code>prettyqt\\custom_delegates\\icondelegate.py</code> <pre><code>def paint(\n    self,\n    painter: QtGui.QPainter,\n    option: QtWidgets.QStyleOptionViewItem,\n    index: QtCore.QModelIndex,\n):\n\"\"\"Override to paint an icon based on given Pixmap / Color / Icon.\n\n    Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000'\n\n    Args:\n        painter (QtGui.QPainter): painter to paint the icon\n        option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed\n        index (QtCore.QModelIndex): index which gets decorated\n    \"\"\"\n    super().paint(painter, option, index)\n    value = index.data(ICON_ROLE)\n    if not value:\n        return\n    margin = 10\n    mode = gui.Icon.Mode.Normal\n\n    if not (option.state &amp; widgets.Style.StateFlag.State_Enabled):\n        mode = gui.Icon.Mode.Disabled\n    elif option.state &amp; widgets.Style.StateFlag.State_Selected:\n        mode = gui.Icon.Mode.Selected\n    match value:\n        case QtGui.QPixmap():\n            icon = QtGui.QIcon(value)\n            option.decorationSize = int(value.size() / value.devicePixelRatio())\n\n        case QtGui.QColor():\n            pixmap = QtGui.QPixmap(option.decorationSize)\n            pixmap.fill(value)\n            icon = QtGui.QIcon(pixmap)\n\n        case QtGui.QImage():\n            icon = QtGui.QIcon(QtGui.QPixmap.fromImage(value))\n            option.decorationSize = int(value.size() / value.devicePixelRatio())\n\n        case QtGui.QIcon():\n            icon = value\n            is_on = option.state &amp; widgets.Style.StateFlag.State_Open\n            state = gui.Icon.State.On if is_on else gui.Icon.State.Off\n            actual_size = option.icon.actualSize(option.decorationSize, mode, state)\n            option.decorationSize &amp;= actual_size\n        case _:\n            raise ValueError(value)\n    r = core.Rect(core.Point(), option.decorationSize)\n    r.moveCenter(option.rect.center())\n    r.setRight(option.rect.right() - margin)\n    state = (\n        gui.Icon.State.On\n        if option.state &amp; widgets.Style.StateFlag.State_Open\n        else gui.Icon.State.Off\n    )\n    alignment = constants.ALIGN_RIGHT | constants.ALIGN_V_CENTER  # type: ignore\n    icon.paint(painter, r, alignment, mode, state)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.StarDelegate","title":"<code>StarDelegate</code>","text":"<p>         Bases: <code>widgets.StyledItemDelegate</code></p> <p>A delegate class that allows us to render our star ratings.</p> Source code in <code>prettyqt\\custom_delegates\\stardelegate.py</code> <pre><code>class StarDelegate(widgets.StyledItemDelegate):\n\"\"\"A delegate class that allows us to render our star ratings.\"\"\"\n\n    def paint(self, painter, option, index):\n        star_rating = StarRating(index.data())\n\n        # If the row is currently selected, we need to make sure we\n        # paint the background accordingly.\n        if option.state &amp; widgets.Style.StateFlag.State_Selected:\n            # The original C++ example used option.palette.foreground() to\n            # get the brush for painting, but there are a couple of\n            # problems with that:\n            #   - foreground() is obsolete now, use windowText() instead\n            #   - more importantly, windowText() just returns a brush\n            #     containing a flat color, where sometimes the style\n            #     would have a nice subtle gradient or something.\n            # Here we just use the brush of the painter object that's\n            # passed in to us, which keeps the row highlighting nice\n            # and consistent.\n            painter.fillRect(option.rect, painter.brush())\n\n        # Now that we've painted the background, call star_rating.paint()\n        # to paint the stars.\n        star_rating.paint(painter, option.rect, option.palette)\n\n    def sizeHint(self, option, index):\n\"\"\"Return the size needed to display the item in a QSize object.\"\"\"\n        star_rating = StarRating(index.data())\n        return star_rating.sizeHint()\n\n    # The next 4 methods handle the custom editing that we need to do.\n    # If this were just a display delegate, paint() and sizeHint() would\n    # be all we needed.\n\n    def createEditor(self, parent, option, index):\n\"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\"\n        editor = StarEditor(parent)\n        editor.editing_finished.connect(self.commitAndCloseEditor)\n        return editor\n\n    def setEditorData(self, editor, index):\n\"\"\"Set the data to be displayed and edited by our custom editor.\"\"\"\n        editor.set_star_rating(index.data())\n\n    def setModelData(self, editor, model, index):\n\"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\"\n        model.setData(index, editor.star_rating.star_count)\n\n    def commitAndCloseEditor(self):\n        editor = self.sender()\n\n        # The commitData signal must be emitted when we've finished editing\n        # and need to write our changed back to the model.\n        self.commitData.emit(editor)\n        self.closeEditor.emit(editor, self.EndEditHint.NoHint)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.createEditor","title":"<code>createEditor(parent, option, index)</code>","text":"<p>Create and return the StarEditor object we'll use to edit the StarRating.</p> Source code in <code>prettyqt\\custom_delegates\\stardelegate.py</code> <pre><code>def createEditor(self, parent, option, index):\n\"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\"\n    editor = StarEditor(parent)\n    editor.editing_finished.connect(self.commitAndCloseEditor)\n    return editor\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setEditorData","title":"<code>setEditorData(editor, index)</code>","text":"<p>Set the data to be displayed and edited by our custom editor.</p> Source code in <code>prettyqt\\custom_delegates\\stardelegate.py</code> <pre><code>def setEditorData(self, editor, index):\n\"\"\"Set the data to be displayed and edited by our custom editor.\"\"\"\n    editor.set_star_rating(index.data())\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setModelData","title":"<code>setModelData(editor, model, index)</code>","text":"<p>Get the data from our custom editor and stuffs it into the model.</p> Source code in <code>prettyqt\\custom_delegates\\stardelegate.py</code> <pre><code>def setModelData(self, editor, model, index):\n\"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\"\n    model.setData(index, editor.star_rating.star_count)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.sizeHint","title":"<code>sizeHint(option, index)</code>","text":"<p>Return the size needed to display the item in a QSize object.</p> Source code in <code>prettyqt\\custom_delegates\\stardelegate.py</code> <pre><code>def sizeHint(self, option, index):\n\"\"\"Return the size needed to display the item in a QSize object.\"\"\"\n    star_rating = StarRating(index.data())\n    return star_rating.sizeHint()\n</code></pre>"},{"location":"api/custom_models.html","title":"custom_models module","text":"<p>Custom_models module.</p> <p>Contains custom models</p>"},{"location":"api/custom_models.html#prettyqt.custom_models.ColumnItem","title":"<code>ColumnItem</code>  <code>dataclass</code>","text":"<p>Determines how an object attribute is shown.</p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>@dataclass(frozen=True)\nclass ColumnItem:\n\"\"\"Determines how an object attribute is shown.\"\"\"\n\n    name: str\n    label: Callable[[treeitem.TreeItem], str] | None\n    checkstate: Callable[\n        [treeitem.TreeItem], constants.StateStr | QtCore.Qt.CheckState | bool\n    ] | None = None\n    sort_value: Callable[[treeitem.TreeItem], str | float] | None = None\n    tooltip: Callable[[treeitem.TreeItem], str] | None = None\n    doc: str = \"&lt;no help available&gt;\"\n    col_visible: bool = True\n    width: int | str = SMALL_COL_WIDTH\n    alignment: Callable | int | constants.AlignmentStr | None = None\n    line_wrap: gui.textoption.WordWrapModeStr = \"none\"\n    foreground_color: Callable | str | None = None\n    background_color: Callable | str | None = None\n    decoration: Callable | QtGui.QIcon | None = None\n    font: Callable | QtGui.QFont | None = None\n    selectable: bool = True\n    enabled: bool = True\n    editable: bool = False\n    checkable: bool = False\n    tristate: bool = False\n    set_edit: Callable | None = None\n    set_checkstate: Callable | None = None\n    user_data: dict | Callable | None = None\n\n    # def __post_init__(self):\n    #     super().__init__()\n\n    def get_name(self) -&gt; str:\n        return self.name\n\n    def get_flag(self, tree_item):\n        flag = constants.NO_FLAGS\n        if self.selectable:\n            flag |= constants.IS_SELECTABLE  # type: ignore\n        if self.enabled:\n            flag |= constants.IS_ENABLED  # type: ignore\n        if self.editable:\n            flag |= constants.IS_EDITABLE  # type: ignore\n        if self.checkable:\n            flag |= constants.IS_CHECKABLE  # type: ignore\n        if self.tristate:\n            flag |= constants.IS_USER_TRISTATE  # type: ignore\n        return flag\n\n    def get_label(self, tree_item) -&gt; str:\n        if self.label is None:\n            return \"\"\n        elif callable(self.label):\n            return self.label(tree_item)\n        return self.label\n\n    def get_sort_value(self, tree_item) -&gt; str | int:\n        if self.sort_value is None:\n            return self.get_label()\n        elif callable(self.sort_value):\n            return self.sort_value(tree_item)\n        return self.sort_value\n\n    def get_user_data(self, tree_item, role):\n        if self.user_data is None:\n            return \"\"\n        elif callable(self.user_data):\n            return self.user_data(tree_item, role)\n        return self.user_data[role](tree_item)\n\n    def get_tooltip(self, tree_item) -&gt; str:\n        if self.tooltip is None:\n            return \"\"\n        elif callable(self.tooltip):\n            return self.tooltip(tree_item)\n        return self.tooltip\n\n    def get_checkstate(self, tree_item) -&gt; bool | QtCore.Qt.CheckState | None:\n        if self.checkstate is None:\n            return None\n        elif callable(self.checkstate):\n            result = self.checkstate(tree_item)\n            if isinstance(result, str):\n                result = constants.STATE[result]\n            return result\n        return self.checkstate\n\n    def set_checkstate_value(\n        self, tree_item, value: bool | QtCore.Qt.CheckState | constants.StateStr | None\n    ):\n        if self.set_checkstate is None:\n            return None\n        if isinstance(value, str):\n            value = constants.STATE[value]\n        if callable(self.set_checkstate):\n            self.set_checkstate(tree_item, value)\n        else:\n            raise ValueError(self.set_checkstate)\n\n    def set_edit_value(self, tree_item, value: str):\n        if self.set_edit is None:\n            return None\n        if callable(self.set_edit):\n            self.set_edit(tree_item, value)\n        else:\n            raise ValueError(self.set_edit)\n\n    def get_font(self, tree_item) -&gt; QtGui.QFont | None:\n        if self.font is None:\n            return None\n        elif callable(self.font):\n            return self.font(tree_item)\n        return self.font\n\n    def get_foreground_color(self, tree_item) -&gt; QtGui.QColor | None:\n        if self.foreground_color is None:\n            return None\n        elif callable(self.foreground_color):\n            return self.foreground_color(tree_item)\n        return self.foreground_color\n\n    def get_background_color(self, tree_item) -&gt; QtGui.QColor | None:\n        if self.background_color is None:\n            return None\n        elif callable(self.background_color):\n            return self.background_color(tree_item)\n        return self.background_color\n\n    def get_decoration(\n        self, tree_item\n    ) -&gt; QtGui.QColor | QtGui.QPixmap | QtGui.QIcon | None:\n        if self.decoration is None:\n            return None\n        elif callable(self.decoration):\n            return self.decoration(tree_item)\n        return self.decoration\n\n    def get_alignment(self, tree_item) -&gt; int:\n        if self.alignment is None:\n            return constants.ALIGN_LEFT  # type: ignore\n        elif callable(self.alignment):\n            return self.alignment(tree_item)\n        elif isinstance(self.alignment, str):\n            return constants.ALIGNMENTS[self.alignment]\n        return self.alignment\n\n    def get_width(self) -&gt; int:\n        match self.width:\n            case \"small\":\n                return SMALL_COL_WIDTH\n            case \"medium\":\n                return MEDIUM_COL_WIDTH\n            case int():\n                return self.width\n            case _:\n                raise ValueError(self.width)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ColumnItemModel","title":"<code>ColumnItemModel</code>","text":"<p>         Bases: <code>ColumnItemModelMixin</code>, <code>core.AbstractItemModel</code></p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>class ColumnItemModel(ColumnItemModelMixin, core.AbstractItemModel):\n    def __init__(self, *args, **kwargs):\n        self._root_item = core.ModelIndex()\n        super().__init__(*args, **kwargs)\n\n    def root_index(self) -&gt; core.ModelIndex:  # TODO: needed?\n\"\"\"Return the index that returns the root element (same as an invalid index).\"\"\"\n        return core.ModelIndex()\n\n    @property\n    def root_item(self) -&gt; treeitem.TreeItem:\n\"\"\"Return the root ObjectBrowserTreeItem.\"\"\"\n        return self._root_item\n\n    def tree_item(self, index: core.ModelIndex) -&gt; treeitem.TreeItem:\n        return index.internalPointer() if index.isValid() else self.root_item\n\n    def index(\n        self, row: int, column: int, parent: core.ModelIndex | None = None\n    ) -&gt; core.ModelIndex:\n        if parent is None:\n            logger.debug(\"parent is None\")\n            parent = core.ModelIndex()\n\n        parent_item = self.tree_item(parent)\n\n        if not self.hasIndex(row, column, parent):\n            return core.ModelIndex()\n\n        if child_item := parent_item.child(row):\n            return self.createIndex(row, column, child_item)\n        return core.ModelIndex()\n\n    def parent(self, index: core.ModelIndex) -&gt; core.ModelIndex:  # type:ignore\n        if not index.isValid():\n            return core.ModelIndex()\n\n        child_item = index.internalPointer()\n        parent_item = child_item.parent()  # type: ignore\n\n        if parent_item is None or parent_item == self.root_item:\n            return core.ModelIndex()\n\n        return self.createIndex(parent_item.row(), 0, parent_item)\n\n    def rowCount(self, parent: core.ModelIndex | None = None):\n        parent = core.ModelIndex() if parent is None else parent\n        return 0 if parent.column() &gt; 0 else self.tree_item(parent).child_count()\n\n    def columnCount(self, parent=None):\n        return len(self._attr_cols)\n\n    def hasChildren(self, parent: core.ModelIndex | None = None):\n        parent = core.ModelIndex() if parent is None else parent\n        return 0 if parent.column() &gt; 0 else self.tree_item(parent).has_children\n\n    def canFetchMore(self, parent: core.ModelIndex | None = None):\n        parent = core.ModelIndex() if parent is None else parent\n        if parent.column() &gt; 0:\n            return 0\n        else:\n            return not self.tree_item(parent).children_fetched\n\n    def fetchMore(self, parent: core.ModelIndex | None = None):\n\"\"\"Fetch the children given the model index of a parent node.\n\n        Adds the children to the parent.\n        \"\"\"\n        parent = core.ModelIndex() if parent is None else parent\n        if parent.column() &gt; 0:\n            return\n\n        parent_item = self.tree_item(parent)\n        if parent_item.children_fetched:\n            return\n\n        tree_items = self._fetch_object_children(parent_item)\n\n        with self.insert_rows(0, len(tree_items) - 1, parent):\n            for tree_item in tree_items:\n                parent_item.append_child(tree_item)\n            parent_item.children_fetched = True\n\n    def _fetch_object_children(self, treeitem) -&gt; list:\n        return NotImplemented\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.root_item","title":"<code>root_item: treeitem.TreeItem</code>  <code>property</code>","text":"<p>Return the root ObjectBrowserTreeItem.</p>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.fetchMore","title":"<code>fetchMore(parent: core.ModelIndex | None = None)</code>","text":"<p>Fetch the children given the model index of a parent node.</p> <p>Adds the children to the parent.</p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>def fetchMore(self, parent: core.ModelIndex | None = None):\n\"\"\"Fetch the children given the model index of a parent node.\n\n    Adds the children to the parent.\n    \"\"\"\n    parent = core.ModelIndex() if parent is None else parent\n    if parent.column() &gt; 0:\n        return\n\n    parent_item = self.tree_item(parent)\n    if parent_item.children_fetched:\n        return\n\n    tree_items = self._fetch_object_children(parent_item)\n\n    with self.insert_rows(0, len(tree_items) - 1, parent):\n        for tree_item in tree_items:\n            parent_item.append_child(tree_item)\n        parent_item.children_fetched = True\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.root_index","title":"<code>root_index() -&gt; core.ModelIndex</code>","text":"<p>Return the index that returns the root element (same as an invalid index).</p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>def root_index(self) -&gt; core.ModelIndex:  # TODO: needed?\n\"\"\"Return the index that returns the root element (same as an invalid index).\"\"\"\n    return core.ModelIndex()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ColumnTableModel","title":"<code>ColumnTableModel</code>","text":"<p>         Bases: <code>ColumnItemModelMixin</code>, <code>core.AbstractTableModel</code></p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>class ColumnTableModel(ColumnItemModelMixin, core.AbstractTableModel):\n    def __init__(\n        self,\n        items: list,\n        columns: list[ColumnItem],\n        mime_type: str | None = None,\n        parent: QtCore.QObject | None = None,\n    ):\n        super().__init__(columns, parent)\n        self.items = items\n        self.mime_type = mime_type\n\n    def rowCount(self, parent=None):\n        parent = parent or core.ModelIndex()\n        if parent.isValid():\n            return 0\n        return len(self.items)\n\n    def columnCount(self, parent=None):\n        parent = parent or core.ModelIndex()\n        if parent.isValid():\n            return 0\n        return len(self._attr_cols)\n\n    def tree_item(self, index: core.ModelIndex):\n        return self.items[index.row()]\n\n    def setData(self, index, value, role):\n        if role == constants.USER_ROLE:\n            self.items[index.row()] = value\n            self.update_row(index.row())\n            return True\n        return super().setData(index, value, role)  # type: ignore\n\n    def removeRows(self, row: int, count: int, parent):\n        end_row = row + count - 1\n        with self.remove_rows(row, end_row, parent):\n            for i in range(end_row, row - 1, -1):\n                self.items.pop(i)\n        return True\n\n    def dropMimeData(self, mime_data, action, row, column, parent_index):\n        if not mime_data.hasFormat(self.mime_type):\n            return False\n        # Since we only drop in between items, parent_index must be invalid,\n        # and we use the row arg to know where the drop took place.\n        if parent_index.isValid():\n            return False\n        indexes = mime_data.get_json_data(self.mime_type)\n        pos = row if row &lt; len(self.items) and row != -1 else len(self.items)\n        rem_offset = sum(i &lt;= pos for i in indexes)\n        new = [self.items[i] for i in indexes]\n        with self.change_layout():\n            for i in sorted(indexes, reverse=True):\n                self.items.pop(i)\n            for item in reversed(new):\n                self.items.insert(pos - rem_offset, item)\n        return False\n\n    def sort(self, ncol: int, order):\n\"\"\"Sort table by given column number.\"\"\"\n        is_asc = order == constants.ASCENDING\n        if sorter := self._attr_cols[ncol].label:\n            with self.change_layout():\n                self.items.sort(key=sorter, reverse=is_asc)\n\n    def add(self, item: Any, position: int | None = None):\n\"\"\"Append provided item to the list.\"\"\"\n        self.add_items(items=[item], position=position)\n        return item\n\n    def add_items(self, items: Iterable[Any], position: int | None = None):\n\"\"\"Append a list of items to the list.\"\"\"\n        if position is None:\n            position = len(self.items)\n        items = list(items)\n        with self.insert_rows(position, position + len(items) - 1):\n            for i in range(len(items)):\n                self.items.insert(i + position, items[i])\n            # self.items.extend(items)\n        return items\n\n    def remove_items(self, offsets: Iterable[int]):\n        for offset in sorted(offsets, reverse=True):\n            self.removeRow(offset)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnTableModel.add","title":"<code>add(item: Any, position: int | None = None)</code>","text":"<p>Append provided item to the list.</p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>def add(self, item: Any, position: int | None = None):\n\"\"\"Append provided item to the list.\"\"\"\n    self.add_items(items=[item], position=position)\n    return item\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnTableModel.add_items","title":"<code>add_items(items: Iterable[Any], position: int | None = None)</code>","text":"<p>Append a list of items to the list.</p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>def add_items(self, items: Iterable[Any], position: int | None = None):\n\"\"\"Append a list of items to the list.\"\"\"\n    if position is None:\n        position = len(self.items)\n    items = list(items)\n    with self.insert_rows(position, position + len(items) - 1):\n        for i in range(len(items)):\n            self.items.insert(i + position, items[i])\n        # self.items.extend(items)\n    return items\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnTableModel.sort","title":"<code>sort(ncol: int, order)</code>","text":"<p>Sort table by given column number.</p> Source code in <code>prettyqt\\custom_models\\columnitemmodel.py</code> <pre><code>def sort(self, ncol: int, order):\n\"\"\"Sort table by given column number.\"\"\"\n    is_asc = order == constants.ASCENDING\n    if sorter := self._attr_cols[ncol].label:\n        with self.change_layout():\n            self.items.sort(key=sorter, reverse=is_asc)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.JsonModel","title":"<code>JsonModel</code>","text":"<p>         Bases: <code>custom_models.NestedModel</code></p> Source code in <code>prettyqt\\custom_models\\jsonmodel.py</code> <pre><code>class JsonModel(custom_models.NestedModel):\n    HEADER = [\"Key\", \"Value\", \"Type\"]\n\n    def __init__(self, parent: QtCore.QObject | None = None):\n        super().__init__(parent=parent)\n        self.root = JsonTreeItem()  # type: ignore\n        self.items = self.root.children\n\n    def __repr__(self):\n        return str(self.root.as_json())  # type: ignore\n\n    def load(self, document: dict | list | tuple):\n\"\"\"Load from JSON object.\n\n        Arguments:\n            document: JSON-compatible object\n\n        \"\"\"\n        with self.reset_model():\n            self.root = JsonTreeItem.load(document)\n            self.root.type = type(document)  # type: ignore\n            self.items = self.root.children\n\n    def data(self, index, role):\n        if not index.isValid():\n            return None\n\n        item = index.internalPointer()\n        match role, index.column():\n            case constants.DISPLAY_ROLE | constants.EDIT_ROLE, 0:\n                return repr(item.key)\n            case constants.DISPLAY_ROLE, 1:\n                return \"\" if item.type in (dict, list, tuple) else repr(item.value)\n            case constants.EDIT_ROLE, 1:\n                return \"\" if item.type in (dict, list, tuple) else item.value\n            case constants.DISPLAY_ROLE | constants.EDIT_ROLE, 2:\n                return item.type.__name__\n\n    def setData(self, index, value, role):\n        if role == constants.EDIT_ROLE and index.column() == 1:\n            item = index.internalPointer()\n            item.value = str(value)\n            self.update_row(index.row())\n            return True\n        return False\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.jsonmodel.JsonModel.load","title":"<code>load(document: dict | list | tuple)</code>","text":"<p>Load from JSON object.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>dict | list | tuple</code> <p>JSON-compatible object</p> required Source code in <code>prettyqt\\custom_models\\jsonmodel.py</code> <pre><code>def load(self, document: dict | list | tuple):\n\"\"\"Load from JSON object.\n\n    Arguments:\n        document: JSON-compatible object\n\n    \"\"\"\n    with self.reset_model():\n        self.root = JsonTreeItem.load(document)\n        self.root.type = type(document)  # type: ignore\n        self.items = self.root.children\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ListMixin","title":"<code>ListMixin</code>","text":"Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>class ListMixin:\n    remove_rows: Callable\n    SORT_METHODS: dict[int, Callable]\n    change_layout: Callable\n    insert_rows: Callable\n    removeRow: Callable\n    # setData: Callable\n    update_row: Callable\n    MIME_TYPE: str\n    DATA_ROLE = constants.USER_ROLE\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)  # type: ignore\n        self.items = []\n\n    def setData(self, index, value, role):\n        if role == self.DATA_ROLE:\n            self.items[index.row()] = value\n            self.update_row(index.row())\n            return True\n        return super().setData(index, value, role)  # type: ignore\n\n    def removeRows(self, row: int, count: int, parent):\n        end_row = row + count - 1\n        with self.remove_rows(row, end_row, parent):\n            for i in range(end_row, row - 1, -1):\n                self.items.pop(i)\n        return True\n\n    def rowCount(self, parent=None):\n\"\"\"Required override for AbstractitemModels.\"\"\"\n        parent = parent or core.ModelIndex()\n        if parent.column() &gt; 0 or parent.isValid():\n            return 0\n        return len(self.items)\n\n    def data_by_index(self, index):\n        return self.items[index.row()]\n\n    def dropMimeData(self, mime_data, action, row, column, parent_index):\n        if not mime_data.hasFormat(self.MIME_TYPE):\n            return False\n        # Since we only drop in between items, parent_index must be invalid,\n        # and we use the row arg to know where the drop took place.\n        if parent_index.isValid():\n            return False\n        indexes = mime_data.get_json_data(self.MIME_TYPE)\n        pos = row if row &lt; len(self.items) and row != -1 else len(self.items)\n        rem_offset = sum(i &lt;= pos for i in indexes)\n        new = [self.items[i] for i in indexes]\n        with self.change_layout():\n            for i in sorted(indexes, reverse=True):\n                self.items.pop(i)\n            for item in reversed(new):\n                self.items.insert(pos - rem_offset, item)\n        return False\n\n    def sort(self, ncol: int, order):\n\"\"\"Sort table by given column number.\"\"\"\n        is_asc = order == constants.ASCENDING\n        if sorter := self.SORT_METHODS.get(ncol):\n            with self.change_layout():\n                self.items.sort(key=sorter, reverse=is_asc)\n\n    def add(self, item: Any, position: int | None = None):\n\"\"\"Append provided item to the list.\"\"\"\n        self.add_items(items=[item], position=position)\n        return item\n\n    def add_items(self, items: Iterable[Any], position: int | None = None):\n\"\"\"Append a list of items to the list.\"\"\"\n        if position is None:\n            position = len(self.items)\n        items = list(items)\n        with self.insert_rows(position, position + len(items) - 1):\n            for i in range(len(items)):\n                self.items.insert(i + position, items[i])\n            # self.items.extend(items)\n        return items\n\n    def remove_items(self, offsets: Iterable[int]):\n        for offset in sorted(offsets, reverse=True):\n            self.removeRow(offset)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.add","title":"<code>add(item: Any, position: int | None = None)</code>","text":"<p>Append provided item to the list.</p> Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>def add(self, item: Any, position: int | None = None):\n\"\"\"Append provided item to the list.\"\"\"\n    self.add_items(items=[item], position=position)\n    return item\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.add_items","title":"<code>add_items(items: Iterable[Any], position: int | None = None)</code>","text":"<p>Append a list of items to the list.</p> Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>def add_items(self, items: Iterable[Any], position: int | None = None):\n\"\"\"Append a list of items to the list.\"\"\"\n    if position is None:\n        position = len(self.items)\n    items = list(items)\n    with self.insert_rows(position, position + len(items) - 1):\n        for i in range(len(items)):\n            self.items.insert(i + position, items[i])\n        # self.items.extend(items)\n    return items\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.rowCount","title":"<code>rowCount(parent = None)</code>","text":"<p>Required override for AbstractitemModels.</p> Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>def rowCount(self, parent=None):\n\"\"\"Required override for AbstractitemModels.\"\"\"\n    parent = parent or core.ModelIndex()\n    if parent.column() &gt; 0 or parent.isValid():\n        return 0\n    return len(self.items)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.sort","title":"<code>sort(ncol: int, order)</code>","text":"<p>Sort table by given column number.</p> Source code in <code>prettyqt\\custom_models\\listmixin.py</code> <pre><code>def sort(self, ncol: int, order):\n\"\"\"Sort table by given column number.\"\"\"\n    is_asc = order == constants.ASCENDING\n    if sorter := self.SORT_METHODS.get(ncol):\n        with self.change_layout():\n            self.items.sort(key=sorter, reverse=is_asc)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.ModelMixin","title":"<code>ModelMixin</code>","text":"Source code in <code>prettyqt\\custom_models\\modelmixin.py</code> <pre><code>class ModelMixin:\n    DATA_ROLE = constants.USER_ROLE\n    DTYPE_ROLE = constants.USER_ROLE + 1  # type: ignore\n    NAME_ROLE = constants.USER_ROLE + 2  # type: ignore\n    SORT_ROLE = constants.USER_ROLE + 3  # type: ignore\n    MAX_ROWS = 1_000_000\n    HEADER = [\"Name\"]\n    DEFAULT_FLAGS = (\n        constants.DRAG_ENABLED  # type: ignore\n        | constants.IS_ENABLED\n        | constants.IS_SELECTABLE\n        | constants.NO_CHILDREN\n    )\n    LABELS: dict = {}\n    CHECKSTATE: dict = {}\n    TOOLTIPS: dict = {}\n    DECORATIONS: dict = {}\n    SET_DATA: dict = {}\n    content_type = \"\"\n    data_by_index: Callable\n    update_row: Callable\n\n    def headerData(self, offset: int, orientation, role):\n        match orientation, role:\n            case constants.HORIZONTAL, constants.DISPLAY_ROLE:\n                return self.HEADER[offset]\n\n    def columnCount(self, parent=None):\n        return len(self.HEADER)\n\n    def flags(self, index):\n\"\"\"Override for AbstractitemModel base method.\n\n        returns corresponding flags for cell of supplied index\n        \"\"\"\n        if not index.isValid():\n            return constants.DROP_ENABLED\n        if index.column() in self.SET_DATA:\n            return self.DEFAULT_FLAGS | constants.IS_EDITABLE\n        return self.DEFAULT_FLAGS\n\n    def data(self, index, role=constants.DISPLAY_ROLE):\n        if not index.isValid():\n            return None\n        item = self.data_by_index(index)\n        match role:\n            case constants.DECORATION_ROLE:\n                if fn := self.DECORATIONS.get(index.column()):\n                    return fn(item)\n            case constants.DISPLAY_ROLE | constants.EDIT_ROLE:\n                if fn := self.LABELS.get(index.column()):\n                    return fn(item)\n            case constants.TOOLTIP_ROLE:\n                if fn := self.TOOLTIPS.get(index.column()):\n                    return fn(item)\n            case constants.CHECKSTATE_ROLE:\n                if fn := self.CHECKSTATE.get(index.column()):\n                    return fn(item)\n            case self.DATA_ROLE:\n                return item\n            case _:\n                return None\n\n    def setData(self, index, value, role):\n        if role == constants.EDIT_ROLE:\n            if not value:\n                return False\n            item = self.data_by_index(index)\n            if fn := self.SET_DATA.get(index.column()):\n                fn(item, value)\n                self.update_row(index.row())\n                return True\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.modelmixin.ModelMixin.flags","title":"<code>flags(index)</code>","text":"<p>Override for AbstractitemModel base method.</p> <p>returns corresponding flags for cell of supplied index</p> Source code in <code>prettyqt\\custom_models\\modelmixin.py</code> <pre><code>def flags(self, index):\n\"\"\"Override for AbstractitemModel base method.\n\n    returns corresponding flags for cell of supplied index\n    \"\"\"\n    if not index.isValid():\n        return constants.DROP_ENABLED\n    if index.column() in self.SET_DATA:\n        return self.DEFAULT_FLAGS | constants.IS_EDITABLE\n    return self.DEFAULT_FLAGS\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.NestedItem","title":"<code>NestedItem</code>","text":"<p>         Bases: <code>Generic[T]</code></p> Source code in <code>prettyqt\\custom_models\\nesteditem.py</code> <pre><code>class NestedItem(Generic[T]):\n    item_name = \"not_defined\"\n\n    def __init__(\n        self,\n        parent: T | None = None,\n        dynamic_name: str | None = None,\n        count: int | None = None,\n        children: list[T] | None = None,\n    ):\n        self.parent = parent\n        self.dynamic_name = dynamic_name or self.item_name\n        self.count = count\n        # self.timestamp = kwargs.pop(\"timestamp\", time.time())\n        self.children: list[T] = []\n        if children:\n            self.add_children(children)\n\n    def __iter__(self) -&gt; Iterator[NestedItem]:\n        return iter(self.children)\n\n    def add_children(self, children: Iterable[T]):\n        for child in children:\n            child.parent = self\n        self.children.extend(children)\n\n    def append_child(self, item: T):\n        self.children.append(item)\n\n    def insert_children(self, idx: int, items: Sequence[T]):\n        self.children[idx:idx] = items\n        for item in items:\n            item.parent_item = self\n\n    def child(self, row: int) -&gt; T:\n        return self.children[row]\n\n    def row(self) -&gt; int:\n\"\"\"Return row number.\n\n        returns row position of item inside parent`s children\n        returns 0 if no parent available\n\n        Returns:\n            row number\n        \"\"\"\n        return self.parent.children.index(self) if self.parent else 0\n\n    def iter_tree(\n        self,\n        name: str | None = None,\n        yield_self: bool = True,\n        recursive: bool = True,\n        level: int = 0,\n        count: int = 0,\n        assign_names: bool = True,\n    ):\n\"\"\"Yield children from bottom to top, yield self at end.\n\n        assigns dynamic vars count, level and dynamic name\n        \"\"\"\n        if name is None:\n            name = self.item_name\n        for i, c in enumerate(self.children, start=1):\n            count += 1\n            level += 1\n            with_suffix = f\"{name}_{i}\" if len(self.children) &gt; 1 else name\n            if recursive:\n                yield from c.iter_tree(\n                    with_suffix, yield_self=False, level=level, count=count\n                )\n            if assign_names:\n                c.dynamic_name, c.count = with_suffix, count\n            yield c\n            level -= 1\n        if yield_self:\n            if assign_names:\n                self.dynamic_name, self.count = name, 0\n            yield self\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem.NestedItem.iter_tree","title":"<code>iter_tree(name: str | None = None, yield_self: bool = True, recursive: bool = True, level: int = 0, count: int = 0, assign_names: bool = True)</code>","text":"<p>Yield children from bottom to top, yield self at end.</p> <p>assigns dynamic vars count, level and dynamic name</p> Source code in <code>prettyqt\\custom_models\\nesteditem.py</code> <pre><code>def iter_tree(\n    self,\n    name: str | None = None,\n    yield_self: bool = True,\n    recursive: bool = True,\n    level: int = 0,\n    count: int = 0,\n    assign_names: bool = True,\n):\n\"\"\"Yield children from bottom to top, yield self at end.\n\n    assigns dynamic vars count, level and dynamic name\n    \"\"\"\n    if name is None:\n        name = self.item_name\n    for i, c in enumerate(self.children, start=1):\n        count += 1\n        level += 1\n        with_suffix = f\"{name}_{i}\" if len(self.children) &gt; 1 else name\n        if recursive:\n            yield from c.iter_tree(\n                with_suffix, yield_self=False, level=level, count=count\n            )\n        if assign_names:\n            c.dynamic_name, c.count = with_suffix, count\n        yield c\n        level -= 1\n    if yield_self:\n        if assign_names:\n            self.dynamic_name, self.count = name, 0\n        yield self\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem.NestedItem.row","title":"<code>row() -&gt; int</code>","text":"<p>Return row number.</p> <p>returns row position of item inside parent`s children returns 0 if no parent available</p> <p>Returns:</p> Type Description <code>int</code> <p>row number</p> Source code in <code>prettyqt\\custom_models\\nesteditem.py</code> <pre><code>def row(self) -&gt; int:\n\"\"\"Return row number.\n\n    returns row position of item inside parent`s children\n    returns 0 if no parent available\n\n    Returns:\n        row number\n    \"\"\"\n    return self.parent.children.index(self) if self.parent else 0\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.NestedModel","title":"<code>NestedModel</code>","text":"<p>         Bases: <code>custom_models.ListMixin</code>, <code>custom_models.ModelMixin</code>, <code>core.AbstractItemModel</code></p> Source code in <code>prettyqt\\custom_models\\nestedmodel.py</code> <pre><code>class NestedModel(  # type: ignore\n    custom_models.ListMixin, custom_models.ModelMixin, core.AbstractItemModel\n):\n    DEFAULT_FLAGS = (\n        constants.DRAG_ENABLED  # type: ignore\n        | constants.IS_ENABLED\n        | constants.IS_SELECTABLE\n    )\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.root = Root()\n        self.items = self.root.children\n\n    def flags(self, index=None):\n        index = index or core.ModelIndex()\n        if not index.isValid():\n            return constants.NO_FLAGS\n        if index.column() in self.SET_DATA:\n            return self.DEFAULT_FLAGS | constants.IS_EDITABLE\n        return self.DEFAULT_FLAGS\n\n    def rowCount(self, parent=None) -&gt; int:\n        parent = parent or core.ModelIndex()\n        if parent.column() &gt; 0:\n            return 0\n        return (\n            len(parent.internalPointer().children)\n            if parent.isValid()\n            else len(self.items)\n        )\n\n    def index(self, row, column, parent=None):\n        parent = parent or core.ModelIndex()\n        if not self.hasIndex(row, column, parent):\n            return core.ModelIndex()\n\n        parent_item = parent.internalPointer()\n        if not parent_item:\n            parent_item = self.root\n\n        return self.createIndex(row, column, parent_item.children[row])\n\n    def parent(self, index=None):\n        index = index or core.ModelIndex()\n        if not index.isValid():\n            return core.ModelIndex()\n\n        if item := index.internalPointer():\n            return (\n                core.ModelIndex()\n                if item.parent in [self.root, None]\n                else self.createIndex(item.parent.row(), 0, item.parent)\n            )\n        else:\n            return core.ModelIndex()\n\n    def data_by_index(self, index):\n        return index.internalPointer()\n\n    def json(self, root=None) -&gt; dict:\n\"\"\"Serialise model as JSON-compliant dictionary.\n\n        Arguments:\n            root (JsonTreeItem, optional): Serialise from here\n                defaults to the the top-level item\n\n        Returns:\n            model as dict\n        \"\"\"\n        root = root or self.root\n        return root.as_json()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.json","title":"<code>json(root = None) -&gt; dict</code>","text":"<p>Serialise model as JSON-compliant dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>JsonTreeItem</code> <p>Serialise from here defaults to the the top-level item</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>model as dict</p> Source code in <code>prettyqt\\custom_models\\nestedmodel.py</code> <pre><code>def json(self, root=None) -&gt; dict:\n\"\"\"Serialise model as JSON-compliant dictionary.\n\n    Arguments:\n        root (JsonTreeItem, optional): Serialise from here\n            defaults to the the top-level item\n\n    Returns:\n        model as dict\n    \"\"\"\n    root = root or self.root\n    return root.as_json()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.RegexMatchesModel","title":"<code>RegexMatchesModel</code>","text":"<p>         Bases: <code>core.AbstractTableModel</code></p> Source code in <code>prettyqt\\custom_models\\regexmatchesmodel.py</code> <pre><code>class RegexMatchesModel(core.AbstractTableModel):\n    HEADER = [\"Start\", \"End\", \"Value\", \"Groups\"]\n\n    def __init__(self, matches: list | None = None, parent: QtCore.QObject | None = None):\n        super().__init__(parent=parent)\n        self.matches = matches or []\n\n    def columnCount(self, parent=None):\n        return len(self.HEADER)\n\n    def headerData(  # type: ignore\n        self, section: int, orientation: QtCore.Qt.Orientation, role: int\n    ) -&gt; str | None:\n        match orientation, role:\n            case constants.HORIZONTAL, constants.DISPLAY_ROLE:\n                return self.HEADER[section]\n\n    def data(self, index, role):\n        if not index.isValid():\n            return None\n        item = self.matches[index.row()]\n        match role, index.column():\n            case constants.DISPLAY_ROLE, 0:\n                return str(item.span()[0])\n            case constants.DISPLAY_ROLE, 1:\n                return str(item.span()[1])\n            case constants.DISPLAY_ROLE, 2:\n                return repr(item.group())\n            case constants.DISPLAY_ROLE, 3:\n                return str(len(item.groups()))\n            case constants.USER_ROLE, _:\n                return item.span()\n\n    def rowCount(self, parent=None):\n\"\"\"Override for AbstractitemModel base method.\"\"\"\n        parent = parent or core.ModelIndex()\n        if parent.column() &gt; 0:\n            return 0\n        return len(self.matches) if not parent.isValid() else 0\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.rowCount","title":"<code>rowCount(parent = None)</code>","text":"<p>Override for AbstractitemModel base method.</p> Source code in <code>prettyqt\\custom_models\\regexmatchesmodel.py</code> <pre><code>def rowCount(self, parent=None):\n\"\"\"Override for AbstractitemModel base method.\"\"\"\n    parent = parent or core.ModelIndex()\n    if parent.column() &gt; 0:\n        return 0\n    return len(self.matches) if not parent.isValid() else 0\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.SubsequenceSortFilterProxyModel","title":"<code>SubsequenceSortFilterProxyModel</code>","text":"<p>         Bases: <code>core.SortFilterProxyModel</code></p> <p>Performs subsequence matching/sorting.</p> Source code in <code>prettyqt\\custom_models\\subsequencesortfilterproxymodel.py</code> <pre><code>class SubsequenceSortFilterProxyModel(core.SortFilterProxyModel):\n\"\"\"Performs subsequence matching/sorting.\"\"\"\n\n    def __init__(self, case_sensitivity: bool, parent=None):\n        super().__init__(parent)\n        self.case_sensitivity = case_sensitivity\n\n    def set_prefix(self, prefix: str):\n        self.filter_patterns = []\n        self.filter_patterns_case_sensitive = []\n        self.sort_patterns = []\n        flags = re.IGNORECASE if self.case_sensitivity is False else 0\n        for i in reversed(range(1, len(prefix) + 1)):\n            ptrn = f\".*{prefix[:i]}.*{prefix[i:]}\"\n            try:\n                self.filter_patterns.append(re.compile(ptrn, flags))\n                self.filter_patterns_case_sensitive.append(re.compile(ptrn, 0))\n                ptrn = f\"{prefix[:i]}.*{prefix[i:]}\"\n                self.sort_patterns.append(re.compile(ptrn, flags))\n            except Exception:\n                continue\n        self.prefix = prefix\n\n    def filterAcceptsRow(self, row, _):\n        completion = self.sourceModel().data(self.sourceModel().index(row, 0))\n        if completion is None or self.prefix is None:\n            return False\n        if len(completion) &lt; len(self.prefix):\n            return False\n        if len(self.prefix) == 1:\n            try:\n                prefix = self.prefix\n                if self.case_sensitivity is False:\n                    completion = completion.lower()\n                    prefix = self.prefix.lower()\n                rank = completion.index(prefix)\n                idx = self.sourceModel().index(row, 0)\n                self.sourceModel().setData(idx, rank, USER_ROLE)  # type: ignore\n                return prefix in completion\n            except ValueError:\n                return False\n        for i, patterns in enumerate(\n            zip(\n                self.filter_patterns,\n                self.filter_patterns_case_sensitive,\n                self.sort_patterns,\n            )\n        ):\n            pattern, pattern_case, sort_pattern = patterns\n            if re.match(pattern, completion):\n                # compute rank, the lowest rank the closer it is from the\n                # completion\n                start = MAX_SIZE\n                for m in sort_pattern.finditer(completion):\n                    start, end = m.span()\n                rank = start + i * 10\n                if re.match(pattern_case, completion):\n                    # favorise completions where case is matched\n                    rank -= 10\n                self.sourceModel().setData(idx, rank, USER_ROLE)  # type: ignore\n                return True\n        return len(self.prefix) == 0\n</code></pre>"},{"location":"api/custom_validators.html","title":"custom_validators module","text":"<p>Custom_validators module.</p> <p>Contains custom validators</p>"},{"location":"api/custom_widgets.html","title":"custom_widgets module","text":"<p>Module containing custom widget classes.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.BorderLayout","title":"<code>BorderLayout</code>","text":"<p>         Bases: <code>widgets.Layout</code></p> Source code in <code>prettyqt\\custom_widgets\\borderlayout.py</code> <pre><code>class BorderLayout(widgets.Layout):\n    class Position(enum.IntEnum):\n\"\"\"Item position.\"\"\"\n\n        West = 0\n        North = 1\n        South = 2\n        East = 3\n        Center = 4\n\n    core.Enum(Position)\n\n    def __init__(\n        self,\n        parent: QtWidgets.QWidget | None = None,\n        margin: int = 0,\n        spacing: int | None = None,\n    ):\n        super().__init__(parent)  # type: ignore\n        self.set_margin(margin)\n        self.setSpacing(spacing if spacing is not None else -1)\n        self.items: list[ItemWrapper] = []\n\n    def __del__(self):\n        item = self.takeAt(0)\n        while item:\n            item = self.takeAt(0)\n\n    def addItem(self, item: QtWidgets.QWidgetItem):\n        self.add_widgetitem(item, BorderLayout.Position.West)\n\n    def addWidget(\n        self,\n        widget: QtWidgets.QWidget,\n        position: Position = Position.West,\n    ):\n        self.add_widgetitem(widgets.WidgetItem(widget), position)\n\n    def expandingDirections(self):\n        return constants.HORIZONTAL | constants.VERTICAL  # type: ignore\n\n    def hasHeightForWidth(self) -&gt; bool:\n        return False\n\n    def count(self) -&gt; int:\n        return len(self.items)\n\n    def itemAt(self, index: int) -&gt; QtWidgets.QWidgetItem | None:  # type: ignore\n        return self.items[index].item if index &lt; len(self.items) else None\n\n    def minimumSize(self):\n        return self.calculate_size(\"minimum\")\n\n    def setGeometry(self, rect: QtCore.QRect):\n        center = None\n        east_width = 0\n        west_width = 0\n        north_height = 0\n        south_height = 0\n\n        super().setGeometry(rect)\n\n        for wrapper in self.items:\n            item = wrapper.item\n            match wrapper.position:\n                case BorderLayout.Position.North:\n                    geom = core.Rect(\n                        rect.x(), north_height, rect.width(), item.sizeHint().height()\n                    )\n                    item.setGeometry(geom)\n\n                    north_height += item.geometry().height() + self.spacing()\n\n                case BorderLayout.Position.South:\n                    geom = core.Rect(\n                        item.geometry().x(),\n                        item.geometry().y(),\n                        rect.width(),\n                        item.sizeHint().height(),\n                    )\n                    item.setGeometry(geom)\n\n                    south_height += item.geometry().height() + self.spacing()\n                    geom = core.Rect(\n                        rect.x(),\n                        rect.y() + rect.height() - south_height + self.spacing(),\n                        item.geometry().width(),\n                        item.geometry().height(),\n                    )\n                    item.setGeometry(geom)\n\n                case BorderLayout.Position.Center:\n                    center = wrapper\n\n        center_height = rect.height() - north_height - south_height\n\n        for wrapper in self.items:\n            item = wrapper.item\n            match wrapper.position:\n                case BorderLayout.Position.West:\n                    geom = core.Rect(\n                        rect.x() + west_width,\n                        north_height,\n                        item.sizeHint().width(),\n                        center_height,\n                    )\n                    item.setGeometry(geom)\n\n                    west_width += item.geometry().width() + self.spacing()\n\n                case BorderLayout.Position.East:\n                    geom = core.Rect(\n                        item.geometry().x(),\n                        item.geometry().y(),\n                        item.sizeHint().width(),\n                        center_height,\n                    )\n                    item.setGeometry(geom)\n\n                    east_width += item.geometry().width() + self.spacing()\n\n                    geom = core.Rect(\n                        rect.x() + rect.width() - east_width + self.spacing(),\n                        north_height,\n                        item.geometry().width(),\n                        item.geometry().height(),\n                    )\n                    item.setGeometry(geom)\n\n        if center:\n            rect = core.Rect(\n                west_width,\n                north_height,\n                rect.width() - east_width - west_width,\n                center_height,\n            )\n            center.item.setGeometry(rect)\n\n    def sizeHint(self) -&gt; core.Size:\n        return self.calculate_size(\"size_hint\")\n\n    def takeAt(self, index: int) -&gt; QtWidgets.QWidgetItem | None:  # type: ignore\n        if 0 &lt;= index &lt; len(self.items):\n            layout_struct = self.items.pop(index)\n            return layout_struct.item\n\n        return None\n\n    def add_widgetitem(self, item: QtWidgets.QWidgetItem, position: Position):\n        self.items.append(ItemWrapper(item, position))\n\n    def calculate_size(self, size_type: Literal[\"minimum\", \"size_hint\"]) -&gt; core.Size:\n        total_size = core.Size()\n\n        for wrapper in self.items:\n            position = wrapper.position\n            if size_type == \"minimum\":\n                item_size = wrapper.item.minimumSize()\n            else:  # size_type == \"size_hint\"\n                item_size = wrapper.item.sizeHint()\n\n            if position in (\n                BorderLayout.Position.North,\n                BorderLayout.Position.South,\n                BorderLayout.Position.Center,\n            ):\n                total_size.setHeight(total_size.height() + item_size.height())\n\n            if position in (\n                BorderLayout.Position.West,\n                BorderLayout.Position.East,\n                BorderLayout.Position.Center,\n            ):\n                total_size.setWidth(total_size.width() + item_size.width())\n\n        return total_size\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.Position","title":"<code>Position</code>","text":"<p>         Bases: <code>enum.IntEnum</code></p> <p>Item position.</p> Source code in <code>prettyqt\\custom_widgets\\borderlayout.py</code> <pre><code>class Position(enum.IntEnum):\n\"\"\"Item position.\"\"\"\n\n    West = 0\n    North = 1\n    South = 2\n    East = 3\n    Center = 4\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.CompletionWidget","title":"<code>CompletionWidget</code>","text":"<p>         Bases: <code>widgets.ListWidget</code></p> Source code in <code>prettyqt\\custom_widgets\\completionwidget.py</code> <pre><code>class CompletionWidget(widgets.ListWidget):\n    def __init__(self, textedit: QtWidgets.QTextEdit | QtWidgets.QPlainTextEdit):\n        super().__init__(parent=textedit)\n\n        self._text_edit = textedit\n        self.set_edit_triggers(\"none\")\n        self.set_selection_behaviour(\"rows\")\n        self.set_selection_mode(\"single\")\n\n        # We need Popup style to ensure correct mouse interaction\n        # (dialog would dissappear on mouse click with ToolTip style)\n        self.setWindowFlags(QtCore.Qt.WindowType.Popup)  # type: ignore\n\n        self.setAttribute(QtCore.Qt.WidgetAttribute.WA_StaticContents)\n        original_policy = self._text_edit.focusPolicy()\n\n        self.set_focus_policy(\"none\")\n        self._text_edit.setFocusPolicy(original_policy)\n\n        # Ensure that the text edit keeps focus when widget is displayed.\n        self.setFocusProxy(self._text_edit)\n\n        self.set_frame_shadow(\"plain\")\n        self.set_frame_shape(\"styled_panel\")\n\n        self.itemActivated.connect(self._complete_current)\n\n    def eventFilter(self, obj, event):\n\"\"\"Handle mouse input and to auto-hide when losing focus.\"\"\"\n        if obj is self and event.type() == QtCore.QEvent.Type.MouseButtonPress:\n            pos = self.mapToGlobal(event.pos())\n            target = QtWidgets.QApplication.widgetAt(pos)\n            if target and self.isAncestorOf(target) or target is self:\n                return False\n            else:\n                self.cancel_completion()\n\n        return super().eventFilter(obj, event)\n\n    def keyPressEvent(self, event):\n        match event.key():\n            case (\n                QtCore.Qt.Key.Key_Return | QtCore.Qt.Key.Key_Enter | QtCore.Qt.Key.Key_Tab\n            ):\n                self._complete_current()\n            case QtCore.Qt.Key.Key_Escape:\n                self.hide()\n            case (\n                QtCore.Qt.Key.Key_Up\n                | QtCore.Qt.Key.Key_Down\n                | QtCore.Qt.Key.Key_PageUp\n                | QtCore.Qt.Key.Key_PageDown\n                | QtCore.Qt.Key.Key_Home\n                | QtCore.Qt.Key.Key_End\n            ):\n                return super().keyPressEvent(event)\n            case _:\n                QtWidgets.QApplication.sendEvent(self._text_edit, event)\n\n    # 'QWidget' interface\n\n    def hideEvent(self, event):\n\"\"\"Disconnect signal handlers and event filter.\"\"\"\n        super().hideEvent(event)\n        with contextlib.suppress(TypeError):\n            self._text_edit.cursorPositionChanged.disconnect(self._update_current)\n\n        self.removeEventFilter(self)\n\n    def showEvent(self, event):\n\"\"\"Connect signal handlers and event filter.\"\"\"\n        super().showEvent(event)\n        self._text_edit.cursorPositionChanged.connect(self._update_current)\n        self.installEventFilter(self)\n\n    # 'CompletionWidget' interface\n\n    def show_items(self, cursor, items: list[str], prefix_length: int = 0):\n\"\"\"Show the widget with 'items' at the position specified by 'cursor'.\"\"\"\n        point = self._get_top_left_position(cursor)\n        self.clear()\n        path_items = []\n        for item in items:\n            # Check if the item could refer to a file or dir. The replacing\n            # of '\"' is needed for items on Windows\n            path = os.path.abspath(item.replace('\"', \"\"))\n            if os.path.isfile(path) or os.path.isdir(path):\n                path_items.append(item.replace('\"', \"\"))\n            else:\n                list_item = widgets.ListWidgetItem()\n                list_item.setData(QtCore.Qt.ItemDataRole.UserRole, item)  # type: ignore\n                # Need to split to only show last element of a dot completion\n                list_item.setText(item.split(\".\")[-1])\n                self.addItem(list_item)\n\n        common_prefix = os.path.dirname(os.path.commonprefix(path_items))\n        for path_item in path_items:\n            list_item = widgets.ListWidgetItem()\n            list_item.setData(QtCore.Qt.ItemDataRole.UserRole, path_item)  # type: ignore\n            text = path_item.split(common_prefix)[-1] if common_prefix else path_item\n            list_item.setText(text)\n            self.addItem(list_item)\n\n        height = self.sizeHint().height()\n        screen = self.get_screen()\n        if screen is None:\n            return\n        screen_rect = self.availableGeometry()\n        if screen_rect.size().height() + screen_rect.y() - point.y() - height &lt; 0:\n            point = self._text_edit.mapToGlobal(self._text_edit.cursorRect().topRight())\n            point.setY(int(point.y() - height))\n        scrollbar_width = self.verticalScrollBar().sizeHint().width()\n        w = self.sizeHintForColumn(0) + scrollbar_width + 2 * self.frameWidth()\n        self.setGeometry(point.x(), point.y(), w, height)\n\n        # Move cursor to start of the prefix to replace it\n        # when a item is selected\n        cursor.movePosition(QtGui.QTextCursor.MoveOperation.Left, n=prefix_length)\n        self._start_position = cursor.position()\n        self.setCurrentRow(0)\n        self.raise_()\n        self.show()\n\n    # Protected interface\n\n    def _get_top_left_position(self, cursor: QtGui.QTextCursor) -&gt; QtCore.QPoint:\n\"\"\"Get top left position for this widget.\"\"\"\n        point = self._text_edit.cursorRect(cursor).center()\n        point_size = self._text_edit.font().pointSize()\n        factor = 1.05 if os.name == \"nt\" else 0.98\n        delta = int((point_size * 1.20) ** factor)\n        y = delta - (point_size // 2)\n        point.setY(int(point.y() + y))\n        point = self._text_edit.mapToGlobal(point)\n        return point\n\n    def _complete_current(self):\n\"\"\"Perform the completion with the currently selected item.\"\"\"\n        text = self.currentItem().data(QtCore.Qt.ItemDataRole.UserRole)  # type: ignore\n        self._current_text_cursor().insertText(text)\n        self.hide()\n\n    def _current_text_cursor(self) -&gt; QtGui.QTextCursor:\n\"\"\"Return a cursor with text between the start  and currentposition selected.\"\"\"\n        cursor = self._text_edit.textCursor()\n        if cursor.position() &gt;= self._start_position:\n            cursor.setPosition(self._start_position, gui.TextCursor.MoveMode.KeepAnchor)\n        return cursor\n\n    def _update_current(self):\n\"\"\"Update the current item based on the current text and the widget position.\"\"\"\n        # Update widget position\n        cursor = self._text_edit.textCursor()\n        point = self._get_top_left_position(cursor)\n        self.move(point)\n\n        if prefix := self._current_text_cursor().selection().toPlainText():\n            flags = (\n                QtCore.Qt.MatchFlag.MatchStartsWith  # type: ignore\n                | QtCore.Qt.MatchFlag.MatchCaseSensitive\n            )\n            if items := self.findItems(prefix, flags):\n                self.setCurrentItem(items[0])\n            else:\n                self.hide()\n        else:\n            self.hide()\n\n    def cancel_completion(self):\n        self.hide()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.eventFilter","title":"<code>eventFilter(obj, event)</code>","text":"<p>Handle mouse input and to auto-hide when losing focus.</p> Source code in <code>prettyqt\\custom_widgets\\completionwidget.py</code> <pre><code>def eventFilter(self, obj, event):\n\"\"\"Handle mouse input and to auto-hide when losing focus.\"\"\"\n    if obj is self and event.type() == QtCore.QEvent.Type.MouseButtonPress:\n        pos = self.mapToGlobal(event.pos())\n        target = QtWidgets.QApplication.widgetAt(pos)\n        if target and self.isAncestorOf(target) or target is self:\n            return False\n        else:\n            self.cancel_completion()\n\n    return super().eventFilter(obj, event)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.hideEvent","title":"<code>hideEvent(event)</code>","text":"<p>Disconnect signal handlers and event filter.</p> Source code in <code>prettyqt\\custom_widgets\\completionwidget.py</code> <pre><code>def hideEvent(self, event):\n\"\"\"Disconnect signal handlers and event filter.\"\"\"\n    super().hideEvent(event)\n    with contextlib.suppress(TypeError):\n        self._text_edit.cursorPositionChanged.disconnect(self._update_current)\n\n    self.removeEventFilter(self)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.showEvent","title":"<code>showEvent(event)</code>","text":"<p>Connect signal handlers and event filter.</p> Source code in <code>prettyqt\\custom_widgets\\completionwidget.py</code> <pre><code>def showEvent(self, event):\n\"\"\"Connect signal handlers and event filter.\"\"\"\n    super().showEvent(event)\n    self._text_edit.cursorPositionChanged.connect(self._update_current)\n    self.installEventFilter(self)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.show_items","title":"<code>show_items(cursor, items: list[str], prefix_length: int = 0)</code>","text":"<p>Show the widget with 'items' at the position specified by 'cursor'.</p> Source code in <code>prettyqt\\custom_widgets\\completionwidget.py</code> <pre><code>def show_items(self, cursor, items: list[str], prefix_length: int = 0):\n\"\"\"Show the widget with 'items' at the position specified by 'cursor'.\"\"\"\n    point = self._get_top_left_position(cursor)\n    self.clear()\n    path_items = []\n    for item in items:\n        # Check if the item could refer to a file or dir. The replacing\n        # of '\"' is needed for items on Windows\n        path = os.path.abspath(item.replace('\"', \"\"))\n        if os.path.isfile(path) or os.path.isdir(path):\n            path_items.append(item.replace('\"', \"\"))\n        else:\n            list_item = widgets.ListWidgetItem()\n            list_item.setData(QtCore.Qt.ItemDataRole.UserRole, item)  # type: ignore\n            # Need to split to only show last element of a dot completion\n            list_item.setText(item.split(\".\")[-1])\n            self.addItem(list_item)\n\n    common_prefix = os.path.dirname(os.path.commonprefix(path_items))\n    for path_item in path_items:\n        list_item = widgets.ListWidgetItem()\n        list_item.setData(QtCore.Qt.ItemDataRole.UserRole, path_item)  # type: ignore\n        text = path_item.split(common_prefix)[-1] if common_prefix else path_item\n        list_item.setText(text)\n        self.addItem(list_item)\n\n    height = self.sizeHint().height()\n    screen = self.get_screen()\n    if screen is None:\n        return\n    screen_rect = self.availableGeometry()\n    if screen_rect.size().height() + screen_rect.y() - point.y() - height &lt; 0:\n        point = self._text_edit.mapToGlobal(self._text_edit.cursorRect().topRight())\n        point.setY(int(point.y() - height))\n    scrollbar_width = self.verticalScrollBar().sizeHint().width()\n    w = self.sizeHintForColumn(0) + scrollbar_width + 2 * self.frameWidth()\n    self.setGeometry(point.x(), point.y(), w, height)\n\n    # Move cursor to start of the prefix to replace it\n    # when a item is selected\n    cursor.movePosition(QtGui.QTextCursor.MoveOperation.Left, n=prefix_length)\n    self._start_position = cursor.position()\n    self.setCurrentRow(0)\n    self.raise_()\n    self.show()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.FileChooserButton","title":"<code>FileChooserButton</code>","text":"<p>         Bases: <code>widgets.Widget</code></p> Source code in <code>prettyqt\\custom_widgets\\filechooserbutton.py</code> <pre><code>class FileChooserButton(widgets.Widget):\n    value_changed = core.Signal(pathlib.Path)\n\n    def __init__(\n        self,\n        extensions: dict[str, list[str]] | None = None,\n        mode: widgets.filedialog.AcceptModeStr = \"save\",\n        file_mode: widgets.filedialog.FileModeStr = \"existing_files\",\n        root: None | str | pathlib.Path = None,\n        parent: QtWidgets.QWidget | None = None,\n    ):\n\"\"\"Initialize FileChooserButton.\n\n        Args:\n            extensions: dict allowed extensions\n                        form: \"'name': ['.ext1', '.ext2']\"\n            mode: Accept mode (\"save\" or \"load\")\n            file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\",\n                                  or \"directory\")\n            root: Root path\n            parent: parent widget\n        \"\"\"\n        super().__init__(parent)\n        self._path: pathlib.Path | None = None\n        self._extensions = extensions or []\n        self.mode: widgets.filedialog.AcceptModeStr = mode\n        self.file_mode: widgets.filedialog.FileModeStr = file_mode\n        self.root = root\n        layout = widgets.BoxLayout(\"horizontal\", self)\n        layout.set_margin(0)\n        self.lineedit = widgets.LineEdit()\n        self.lineedit.set_read_only()\n        layout.add(self.lineedit)\n        action = widgets.Action()\n        if self.file_mode == \"directory\":\n            action.set_icon(\"mdi.folder-outline\")\n        else:\n            action.set_icon(\"mdi.file-outline\")\n        action.triggered.connect(self.open_file)\n\n        self.button = widgets.ToolButton()\n        self.button.setDefaultAction(action)\n        layout.add(self.button)\n\n    @core.Slot()\n    def open_file(self):\n        dialog = widgets.FileDialog(\n            parent=self,\n            path_id=\"file_path\",\n            mode=self.mode,\n            path=self.root,\n            file_mode=self.file_mode,\n        )\n        if self._extensions:\n            dialog.set_extension_filter(self._extensions)\n        if not dialog.choose():\n            return\n        self.set_path(dialog.selected_file())\n        self.value_changed.emit(self._path)\n\n    def set_path(self, path: datatypes.PathType | None):\n        if path is None:\n            self._path = None\n            self.lineedit.set_text(\"\")\n        else:\n            self._path = pathlib.Path(path)\n            self.lineedit.set_text(os.fspath(path))\n\n    def get_value(self) -&gt; pathlib.Path | None:\n        return self._path\n\n    def set_value(self, value: datatypes.PathType | None):\n        self.set_path(value)\n\n    def get_extensions(self) -&gt; list[str]:\n        return self._extensions\n\n    def set_extensions(self, extensions: list[str]):\n        self._extensions = extensions\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton.__init__","title":"<code>__init__(extensions: dict[str, list[str]] | None = None, mode: widgets.filedialog.AcceptModeStr = 'save', file_mode: widgets.filedialog.FileModeStr = 'existing_files', root: None | str | pathlib.Path = None, parent: QtWidgets.QWidget | None = None)</code>","text":"<p>Initialize FileChooserButton.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>dict[str, list[str]] | None</code> <p>dict allowed extensions         form: \"'name': ['.ext1', '.ext2']\"</p> <code>None</code> <code>mode</code> <code>widgets.filedialog.AcceptModeStr</code> <p>Accept mode (\"save\" or \"load\")</p> <code>'save'</code> <code>file_mode</code> <code>widgets.filedialog.FileModeStr</code> <p>File mode (\"existing_files\", \"existing_file\", \"any_file\",                   or \"directory\")</p> <code>'existing_files'</code> <code>root</code> <code>None | str | pathlib.Path</code> <p>Root path</p> <code>None</code> <code>parent</code> <code>QtWidgets.QWidget | None</code> <p>parent widget</p> <code>None</code> Source code in <code>prettyqt\\custom_widgets\\filechooserbutton.py</code> <pre><code>def __init__(\n    self,\n    extensions: dict[str, list[str]] | None = None,\n    mode: widgets.filedialog.AcceptModeStr = \"save\",\n    file_mode: widgets.filedialog.FileModeStr = \"existing_files\",\n    root: None | str | pathlib.Path = None,\n    parent: QtWidgets.QWidget | None = None,\n):\n\"\"\"Initialize FileChooserButton.\n\n    Args:\n        extensions: dict allowed extensions\n                    form: \"'name': ['.ext1', '.ext2']\"\n        mode: Accept mode (\"save\" or \"load\")\n        file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\",\n                              or \"directory\")\n        root: Root path\n        parent: parent widget\n    \"\"\"\n    super().__init__(parent)\n    self._path: pathlib.Path | None = None\n    self._extensions = extensions or []\n    self.mode: widgets.filedialog.AcceptModeStr = mode\n    self.file_mode: widgets.filedialog.FileModeStr = file_mode\n    self.root = root\n    layout = widgets.BoxLayout(\"horizontal\", self)\n    layout.set_margin(0)\n    self.lineedit = widgets.LineEdit()\n    self.lineedit.set_read_only()\n    layout.add(self.lineedit)\n    action = widgets.Action()\n    if self.file_mode == \"directory\":\n        action.set_icon(\"mdi.folder-outline\")\n    else:\n        action.set_icon(\"mdi.file-outline\")\n    action.triggered.connect(self.open_file)\n\n    self.button = widgets.ToolButton()\n    self.button.setDefaultAction(action)\n    layout.add(self.button)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.IconWidget","title":"<code>IconWidget</code>","text":"<p>         Bases: <code>widgets.Label</code></p> <p>IconWidget gives the ability to display an icon as a widget.</p> <p>if supports the same arguments as icon() for example music_icon = qta.IconWidget('fa5s.music',                             color='blue',                             color_active='orange')</p> <p>it also have setIcon() and setIconSize() functions</p> Source code in <code>prettyqt\\custom_widgets\\iconwidget.py</code> <pre><code>class IconWidget(widgets.Label):\n\"\"\"IconWidget gives the ability to display an icon as a widget.\n\n    if supports the same arguments as icon()\n    for example\n    music_icon = qta.IconWidget('fa5s.music',\n                                color='blue',\n                                color_active='orange')\n\n    it also have setIcon() and setIconSize() functions\n    \"\"\"\n\n    def __init__(self, *names, parent: QtWidgets.QWidget | None = None, **kwargs):\n        super().__init__(parent=parent)\n        self._icon: QtGui.QIcon | None = None\n        self._size = core.Size(16, 16)\n        self.set_icon(iconprovider._icon(*names, **kwargs))\n\n    def set_icon(self, _icon: datatypes.IconType):\n\"\"\"Set a new icon().\n\n        Parameters\n        ----------\n        _icon: qtawesome.icon\n            icon to set\n        \"\"\"\n        self._icon = iconprovider.get_icon(_icon)\n        self.setPixmap(self._icon.pixmap(self._size))\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n        if isinstance(size, tuple):\n            size = QtCore.QSize(*size)\n        elif isinstance(size, int):\n            size = QtCore.QSize(size, size)\n        self._size = size\n        self.update()\n\n    def update(self, *args, **kwargs):\n        if self._icon:\n            self.setPixmap(self._icon.pixmap(self._size))\n        return super().update(*args, **kwargs)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.set_icon","title":"<code>set_icon(_icon: datatypes.IconType)</code>","text":"<p>Set a new icon().</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.set_icon--parameters","title":"Parameters","text":"qtawesome.icon <p>icon to set</p> Source code in <code>prettyqt\\custom_widgets\\iconwidget.py</code> <pre><code>def set_icon(self, _icon: datatypes.IconType):\n\"\"\"Set a new icon().\n\n    Parameters\n    ----------\n    _icon: qtawesome.icon\n        icon to set\n    \"\"\"\n    self._icon = iconprovider.get_icon(_icon)\n    self.setPixmap(self._icon.pixmap(self._size))\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.PopupInfo","title":"<code>PopupInfo</code>","text":"<p>         Bases: <code>widgets.Dialog</code></p> <p>Dialog overlay to show some info to user.</p> Source code in <code>prettyqt\\custom_widgets\\popupinfo.py</code> <pre><code>class PopupInfo(widgets.Dialog):\n\"\"\"Dialog overlay to show some info to user.\"\"\"\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None, text: str | None = None):\n        super().__init__(parent=parent)\n        self.timer = core.Timer.single_shot(callback=self.close)\n        self.label = widgets.Label()\n        self.set_flags(stay_on_top=True, frameless=True, tool=True)\n        layout = widgets.BoxLayout(\"vertical\")\n        layout.set_margin(20)\n        self.set_layout(layout)\n        self.set_background_color(\"black\")\n        self.label.set_color(\"white\")\n        layout.add(self.label)\n        # signals.signals.popup_info.connect(self.popup)\n\n    def show(self):\n        self.hide()\n        screen_geo = gui.GuiApplication.primaryScreen().geometry()\n        size = self.label.sizeHint()\n        x = (screen_geo.width() - size.width()) // 2\n        y = (screen_geo.height() - size.height()) // 2\n        self.move(x, y - 200)\n        super().show()\n        self.timer.start(2500)\n\n    def show_popup(self, text: str):\n        self.label.setText(text)\n        self.show()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.SidebarWidget","title":"<code>SidebarWidget</code>","text":"<p>         Bases: <code>widgets.MainWindow</code></p> Source code in <code>prettyqt\\custom_widgets\\sidebarwidget.py</code> <pre><code>class SidebarWidget(widgets.MainWindow):\n    SETTINGS_BUTTON_HEIGHT = 28\n\n    def __init__(\n        self,\n        parent: QtWidgets.QWidget | None = None,\n        show_settings: bool = False,\n        main_layout: widgets.widget.LayoutStr | QtWidgets.QLayout = \"vertical\",\n    ):\n        super().__init__(parent=parent)\n        self._button_width = 100\n        self._style: constants.ToolButtonStyleStr = \"text_below_icon\"\n        self.button_map: dict[QtWidgets.QWidget, QtWidgets.QToolButton] = {}\n        self.icon_map: dict[QtWidgets.QWidget, gui.Icon] = {}\n        self.sidebar = widgets.ToolBar()\n        self.sidebar.set_id(\"SidebarWidget\")\n        self.sidebar.set_title(\"Sidebar\")\n        self.sidebar.set_style(self._style)\n        self.sidebar.set_context_menu_policy(\"prevent\")\n        self.sidebar.setFloatable(False)\n        self.sidebar.set_allowed_areas(\"all\")\n        self.settings_menu = widgets.Menu()\n        self.sidebar.set_icon_size(int(self._button_width * 0.7))\n        if show_settings:\n            self.settings_btn = self.sidebar.add_menu_button(\n                \"\", icon=\"mdi.wrench\", menu=self.settings_menu\n            )\n            self.settings_btn.setFixedSize(\n                self._button_width, self.SETTINGS_BUTTON_HEIGHT\n            )\n            self.settings_btn.set_style(\"icon\")\n            self.sidebar.orientationChanged.connect(self._on_orientation_change)\n            self.sidebar.add_separator()\n        self.spacer_action = self.sidebar.add_spacer()\n        self.add_toolbar(self.sidebar, \"left\")\n        self.area = widgets.Widget()\n        self.area.set_layout(\"stacked\")\n        w = widgets.Widget()\n        w.set_layout(main_layout)\n        self.main_layout = w.box\n        self.main_layout.set_margin(0)\n        self.main_layout += self.area\n        self.setCentralWidget(w)\n\n    def _on_orientation_change(self, orientation: QtCore.Qt.Orientation):\n        if orientation == constants.HORIZONTAL:\n            self.settings_btn.setFixedSize(34, 34)\n        else:\n            self.settings_btn.setFixedSize(\n                self._button_width, self.SETTINGS_BUTTON_HEIGHT\n            )\n\n    def add_tab(\n        self,\n        item: QtWidgets.QWidget,\n        title: str,\n        icon: datatypes.IconType | None = None,\n        show: bool = False,\n        shortcut: str | None = None,\n        area: AreaStr = \"top\",\n    ):\n        self.area.box.add(item)\n        act = widgets.Action(\n            text=title,\n            icon=icon,\n            shortcut=shortcut,\n            parent=self.sidebar,\n            checkable=True,\n            callback=lambda: self.set_tab(item),\n        )\n        button = widgets.ToolButton(self.sidebar)\n        button.setDefaultAction(act)\n        button.setFixedWidth(self._button_width)\n        button.set_style(self._style)\n        if area == \"top\":\n            self.sidebar.insertWidget(self.spacer_action, button)\n        else:\n            self.sidebar.addWidget(button)\n        if len(self.area.box) == 1:\n            button.setChecked(True)\n        self.button_map[item] = button\n        self.icon_map[item] = iconprovider.get_icon(icon)\n        if show:\n            self.area.box.setCurrentWidget(item)\n\n    def set_marker(\n        self, item: str | int | widgets.Widget, color: datatypes.ColorType = \"red\"\n    ):\n        widget = self._get_widget(item)\n        if widget == self._get_current_widget():\n            return\n        template = self.icon_map[widget]\n        px = template.pixmap(100, 100)\n        with gui.Painter(px) as painter:\n            dot = gui.Pixmap.create_dot(color)\n            painter.drawPixmap(0, 0, dot)\n        icon = gui.Icon(px)\n        self.button_map[widget].setIcon(icon)\n\n    def _get_widget(self, item: str | int | widgets.Widget):\n\"\"\"Returns widget page specified by name, offset or content.\"\"\"\n        if isinstance(item, int):\n            return self.area.box[item]\n        elif isinstance(item, str):\n            item = self.area.find_child(QtWidgets.QWidget, name=item, recursive=False)\n            if item not in self.area.box:\n                raise ValueError(\"Layout does not contain the chosen widget\")\n        return item\n\n    def _get_current_widget(self) -&gt; QtWidgets.QWidget:\n\"\"\"Returns the currently selected widget page.\"\"\"\n        for k, v in self.button_map.items():\n            if v.isChecked():\n                return k\n        raise RuntimeError(\"no page activated.\")\n\n    def set_tab(self, item: str | int | widgets.Widget):\n        widget = self._get_widget(item)\n        current = self.area.box.currentWidget()\n        self.button_map[current].setChecked(False)\n        self.area.box.setCurrentWidget(widget)\n        self.button_map[widget].setChecked(True)\n\n    def add_spacer(self) -&gt; widgets.Widget:\n        return self.sidebar.add_spacer()\n\n    def add_separator(self, text: str | None = None, area: AreaStr = \"top\"):\n        if area == \"top\":\n            self.sidebar.add_separator(text, before=self.spacer_action)\n        else:\n            self.sidebar.add_separator(text)\n\n    def add_action(\n        self,\n        title: str,\n        icon: datatypes.IconType | None = None,\n        callback: Callable | None = None,\n        checkable: bool = False,\n        shortcut: str | None = None,\n        area: AreaStr = \"top\",\n    ):\n        act = widgets.Action(\n            text=title,\n            icon=icon,\n            shortcut=shortcut,\n            checkable=checkable,\n            callback=callback,\n        )\n        button = widgets.ToolButton(self.sidebar)\n        button.setDefaultAction(act)\n        button.setFixedWidth(self._button_width)\n        button.set_style(self._style)\n        if area == \"top\":\n            self.sidebar.insertWidget(self.spacer_action, button)\n        else:\n            self.sidebar.addWidget(button)\n        return act\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.SpanSlider","title":"<code>SpanSlider</code>","text":"<p>         Bases: <code>widgets.Slider</code></p> Source code in <code>prettyqt\\custom_widgets\\spanslider.py</code> <pre><code>class SpanSlider(widgets.Slider):\n    value_changed = core.Signal(object)\n    lower_pos_changed = core.Signal(float)\n    upper_pos_changed = core.Signal(float)\n    slider_pressed = core.Signal(object)\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(\"horizontal\", parent)\n        self.rangeChanged.connect(self.update_range)\n        self.sliderReleased.connect(self._move_pressed_handle)\n\n        self.lower_val = 0.0\n        self.upper_val = 0.0\n        self.lower_pos = 0.0\n        self.upper_pos = 0.0\n        self.offset = 0\n        self.position = 0.0\n        self.last_pressed: str | None = None\n        self.upper_pressed = widgets.Style.SubControl.SC_None\n        self.lower_pressed = widgets.Style.SubControl.SC_None\n        self.movement: MovementModeStr = \"no_crossing\"\n        self._main_control: Literal[\"lower\", \"upper\"] = \"lower\"\n        self._first_movement = False\n        self._block_tracking = False\n        dark_color = self.palette().color(gui.Palette.ColorRole.Dark)\n        self.gradient_left = dark_color.lighter(110)\n        self.gradient_right = dark_color.lighter(110)\n\n    def mousePressEvent(self, event):\n        if self.minimum() == self.maximum() or event.buttons() ^ event.button():\n            event.ignore()\n            return\n\n        self.upper_pressed = self._handle_mouse_press(\n            event.position(), self.upper_pressed, self.upper_val, \"upper\"\n        )\n        if self.upper_pressed != HANDLE_STYLE:\n            self.lower_pressed = self._handle_mouse_press(\n                event.position(), self.lower_pressed, self.lower_val, \"lower\"\n            )\n\n        self._first_movement = True\n        event.accept()\n\n    def mouseMoveEvent(self, event):\n        if self.lower_pressed != HANDLE_STYLE and self.upper_pressed != HANDLE_STYLE:\n            event.ignore()\n            return\n\n        opt = widgets.StyleOptionSlider()\n        self.initStyleOption(opt)\n        m = self.style().pixelMetric(\n            widgets.Style.PixelMetric.PM_MaximumDragDistance, opt, self\n        )\n        pixel_pos = self.pick(event.position()) - self.offset\n        new_pos = float(self._pixel_pos_to_value(pixel_pos))\n        if m &gt;= 0:\n            r = self.rect().adjusted(-m, -m, m, m)\n            if not r.contains(event.position().toPoint()):\n                new_pos = self.position\n\n        # pick the preferred handle on the first movement\n        if self._first_movement:\n            if self.lower_val == self.upper_val:\n                if new_pos &lt; self.lower_value:\n                    self._swap_controls()\n                    self._first_movement = False\n            else:\n                self._first_movement = False\n\n        match HANDLE_STYLE, self.movement:\n            case self.lower_pressed, \"no_crossing\":\n                new_pos = min(new_pos, self.upper_val)\n                self.set_lower_pos(new_pos)\n            case self.lower_pressed, \"no_overlap\":\n                new_pos = min(new_pos, self.upper_val - 1)\n                self.set_lower_pos(new_pos)\n            case self.lower_pressed, \"free\" if new_pos &gt; self.upper_val:\n                self._swap_controls()\n                self.set_upper_pos(new_pos)\n            case self.upper_pressed, \"no_crossing\":\n                new_pos = max(new_pos, self.lower_value)\n                self.set_upper_pos(new_pos)\n            case self.upper_pressed, \"no_overlap\":\n                new_pos = max(new_pos, self.lower_value + 1)\n                self.set_upper_pos(new_pos)\n            case self.upper_pressed, \"free\" if new_pos &lt; self.lower_val:\n                self._swap_controls()\n                self.set_lower_pos(new_pos)\n        event.accept()\n\n    def mouseReleaseEvent(self, event):\n        super().mouseReleaseEvent(event)\n        self.setSliderDown(False)\n        self.lower_pressed = self.upper_pressed = widgets.Style.SubControl.SC_None\n        self.update()\n\n    def paintEvent(self, event):\n        painter = widgets.StylePainter(self)\n\n        # ticks\n        opt = widgets.StyleOptionSlider()\n        self.initStyleOption(opt)\n        opt.subControls = widgets.Style.SubControl.SC_SliderTickmarks\n        painter.draw_complex_control(\"slider\", opt)\n\n        # groove\n        opt.sliderPosition = 20\n        opt.sliderValue = 0\n        opt.subControls = GROOVE_STYLE\n        painter.draw_complex_control(\"slider\", opt)\n\n        # handle rects\n        opt.sliderPosition = self.lower_pos\n        lr = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\n        lrv = self.pick(lr.center())\n        opt.sliderPosition = self.upper_pos\n        ur = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\n        urv = self.pick(ur.center())\n\n        # span\n        minv = min(lrv, urv)\n        maxv = max(lrv, urv)\n        c = self.style().subControlRect(SLIDER_STYLE, opt, GROOVE_STYLE, self).center()\n        if self.is_horizontal():\n            rect = core.Rect(core.Point(minv, c.y() - 2), core.Point(maxv, c.y() + 1))\n        else:\n            rect = core.Rect(core.Point(c.x() - 2, minv), core.Point(c.x() + 1, maxv))\n        self._draw_span(painter, rect)\n\n        # handles\n        if self.last_pressed == \"lower\":\n            self.draw_handle(painter, \"upper\")\n            self.draw_handle(painter, \"lower\")\n        else:\n            self.draw_handle(painter, \"lower\")\n            self.draw_handle(painter, \"upper\")\n\n    @core.Property(float)\n    def lower_value(self) -&gt; float:\n        return min(self.lower_val, self.upper_val)\n\n    def set_lower_value(self, lower: float):\n        self.set_span(lower, self.upper_val)\n\n    @core.Property(float)\n    def upper_value(self) -&gt; float:\n        return max(self.lower_val, self.upper_val)\n\n    def set_upper_value(self, upper: float):\n        self.set_span(self.lower_val, upper)\n\n    def on_value_change(self):\n        self.value_changed.emit((self.lower_val, self.upper_val))\n\n    def get_value(self) -&gt; tuple[float, float]:\n        return (self.lower_val, self.upper_val)\n\n    def set_value(self, value: tuple[float, float]):\n        self.set_lower_value(value[0])\n        self.set_upper_value(value[1])\n\n    def get_movement_mode(self) -&gt; MovementModeStr:\n        return self.movement\n\n    def set_movement_mode(self, mode: MovementModeStr):\n\"\"\"Set movement mode.\n\n        Args:\n            mode: movement mode for the main window\n\n        Raises:\n            ValueError: movement mode type does not exist\n        \"\"\"\n        if mode not in MOVEMENT_MODE:\n            raise ValueError(\"Invalid movement mode\")\n        self.movement = mode\n\n    def set_span(self, lower: float, upper: float):\n        low = clamp(min(lower, upper), self.minimum(), self.maximum())\n        upp = clamp(max(lower, upper), self.minimum(), self.maximum())\n        changed = False\n        if low != self.lower_val:\n            self.lower_val = low\n            self.lower_pos = low\n            changed = True\n        if upp != self.upper_val:\n            self.upper_val = upp\n            self.upper_pos = upp\n            changed = True\n        if changed:\n            self.on_value_change()\n            self.update()\n\n    def set_lower_pos(self, lower: float):\n        if self.lower_pos == lower:\n            return\n        self.lower_pos = lower\n        if not self.hasTracking():\n            self.update()\n        if self.isSliderDown():\n            self.lower_pos_changed.emit(lower)\n        if self.hasTracking() and not self._block_tracking:\n            main = self._main_control == \"lower\"\n            self.trigger_action(\"move\", main)\n\n    def set_upper_pos(self, upper: float):\n        if self.upper_pos == upper:\n            return\n        self.upper_pos = upper\n        if not self.hasTracking():\n            self.update()\n        if self.isSliderDown():\n            self.upper_pos_changed.emit(upper)\n        if self.hasTracking() and not self._block_tracking:\n            main = self._main_control == \"upper\"\n            self.trigger_action(\"move\", main)\n\n    def set_left_color(self, color: datatypes.ColorType):\n        self.gradient_left = colors.get_color(color)\n        self.update()\n\n    def set_right_color(self, color: datatypes.ColorType):\n        self.gradient_right = colors.get_color(color)\n        self.update()\n\n    def _move_pressed_handle(self):\n        if self.last_pressed == \"lower\":\n            if self.lower_pos != self.lower_val:\n                main = self._main_control == \"lower\"\n                self.trigger_action(\"move\", main)\n        elif self.last_pressed == \"upper\" and self.upper_pos != self.upper_val:\n            main = self._main_control == \"upper\"\n            self.trigger_action(\"move\", main)\n\n    def pick(self, p: datatypes.PointType) -&gt; int:\n        if isinstance(p, tuple):\n            return p[0] if self.is_horizontal() else p[1]\n        else:\n            return p.x() if self.is_horizontal() else p.y()\n\n    def trigger_action(self, action: ActionStr, main: bool):\n        value = 0.0\n        no = False\n        up = False\n        my_min = self.minimum()\n        my_max = self.maximum()\n        self._block_tracking = True\n        main_control = main and self._main_control == \"upper\"\n        alt_control = not main and self._main_control == \"lower\"\n        is_upper_handle = main_control or alt_control\n        val = self.upper_val if is_upper_handle else self.lower_val\n        match action:\n            case \"single_step_add\":\n                up = is_upper_handle\n                value = clamp(val + self.singleStep(), my_min, my_max)\n            case \"single_step_sub\":\n                up = is_upper_handle\n                value = clamp(val - self.singleStep(), my_min, my_max)\n            case \"to_minimum\":\n                up = is_upper_handle\n                value = my_min\n            case \"to_maximum\":\n                up = is_upper_handle\n                value = my_max\n            case \"move\":\n                up = is_upper_handle\n                no = True\n            case \"none\":\n                no = True\n\n        if not no and not up:\n            match self.movement:\n                case \"no_crossing\":\n                    value = min(value, self.upper_val)\n                case \"no_overlap\":\n                    value = min(value, self.upper_val - 1)\n\n                case \"free\" if value &gt; self.upper_val:\n                    self._swap_controls()\n                    self.set_upper_pos(value)\n                case \"free\":\n                    self.set_lower_pos(value)\n        elif not no:\n            match self.movement:\n                case \"no_crossing\":\n                    value = max(value, self.lower_val)\n                case \"no_overlap\":\n                    value = max(value, self.lower_val + 1)\n\n                case \"free\" if value &lt; self.lower_val:\n                    self._swap_controls()\n                    self.set_lower_pos(value)\n                case \"free\":\n                    self.set_upper_pos(value)\n\n        self._block_tracking = False\n        self.set_lower_value(self.lower_pos)\n        self.set_upper_value(self.upper_pos)\n\n    def _swap_controls(self):\n        self.lower_val, self.upper_val = self.upper_val, self.lower_val\n        self.lower_pressed, self.upper_pressed = self.upper_pressed, self.lower_pressed\n        self.last_pressed = \"upper\" if self.last_pressed == \"lower\" else \"lower\"\n        self._main_control = \"upper\" if self._main_control == \"lower\" else \"lower\"\n\n    def update_range(self, min_, max_):\n        # set_span() takes care of keeping span in range\n        self.set_span(self.lower_val, self.upper_val)\n\n    def _setup_painter(\n        self,\n        painter: widgets.StylePainter,\n        orientation: Literal[\"horizontal\", \"vertical\"],\n        x1: int,\n        y1: int,\n        x2: int,\n        y2: int,\n    ):\n        highlight = self.palette().color(gui.Palette.ColorRole.Highlight)\n        gradient = gui.LinearGradient(x1, y1, x2, y2)\n        gradient[0] = highlight.darker(120)\n        gradient[1] = highlight.lighter(108)\n        painter.setBrush(gradient)\n\n        val = 130 if orientation == \"horizontal\" else 150\n        painter.set_pen(color=highlight.darker(val), width=0)\n\n    def _draw_span(self, painter: widgets.StylePainter, rect: core.Rect):\n        opt = widgets.StyleOptionSlider()\n        self.initStyleOption(opt)\n        painter.set_pen(color=self.gradient_left, width=0)\n        groove = self.style().subControlRect(SLIDER_STYLE, opt, GROOVE_STYLE, self)\n        if opt.is_horizontal():\n            groove.adjust(0, 0, -1, 0)\n            self._setup_painter(\n                painter,\n                opt.get_orientation(),\n                groove.center().x(),\n                groove.top(),\n                groove.center().x(),\n                groove.bottom(),\n            )\n        else:\n            groove.adjust(0, 0, 0, -1)\n            self._setup_painter(\n                painter,\n                opt.get_orientation(),\n                groove.left(),\n                groove.center().y(),\n                groove.right(),\n                groove.center().y(),\n            )\n\n        # draw groove\n        intersected = core.RectF(rect.intersected(groove))\n        gradient = gui.LinearGradient(intersected.topLeft(), intersected.topRight())\n        gradient[0] = self.gradient_left\n        gradient[1] = self.gradient_right\n        painter.fillRect(intersected, gradient)\n\n    def draw_handle(self, painter: widgets.StylePainter, handle: HandleStr):\n        opt = self.get_style_option(handle)\n        opt.subControls = HANDLE_STYLE\n        pressed = self.lower_pressed if handle == \"lower\" else self.upper_pressed\n        if pressed == HANDLE_STYLE:\n            opt.activeSubControls = pressed\n            opt.state |= widgets.Style.StateFlag.State_Sunken\n        painter.draw_complex_control(\"slider\", opt)\n\n    def get_style_option(self, handle: HandleStr) -&gt; widgets.StyleOptionSlider:\n        option = widgets.StyleOptionSlider()\n        self.initStyleOption(option)\n        if handle == \"lower\":\n            option.sliderPosition = self.lower_pos\n            option.sliderValue = self.lower_val\n        else:\n            option.sliderPosition = self.upper_pos\n            option.sliderValue = self.upper_val\n        return option\n\n    def _handle_mouse_press(\n        self, pos: QtCore.QPointF, control, value: float, handle: HandleStr\n    ):\n        opt = self.get_style_option(handle)\n        old_control = control\n        control = self.style().hitTestComplexControl(\n            SLIDER_STYLE, opt, pos.toPoint(), self\n        )\n        sr = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\n        if control == HANDLE_STYLE:\n            self.position = value\n            self.offset = self.pick(pos - sr.topLeft())\n            self.last_pressed = handle\n            self.setSliderDown(True)\n            self.slider_pressed.emit(handle)\n        if control != old_control:\n            self.update(sr)\n        return control\n\n    def _pixel_pos_to_value(self, pos: int) -&gt; int:\n        opt = widgets.StyleOptionSlider()\n        self.initStyleOption(opt)\n        gr = self.style().subControlRect(SLIDER_STYLE, opt, GROOVE_STYLE, self)\n        sr = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\n        if self.is_horizontal():\n            len_slider = sr.width()\n            slider_min = gr.x()\n            slider_end = gr.right()\n        else:\n            len_slider = sr.height()\n            slider_min = gr.y()\n            slider_end = gr.bottom()\n\n        return widgets.Style.sliderValueFromPosition(\n            self.minimum(),\n            self.maximum(),\n            pos - slider_min,\n            slider_end - len_slider + 1 - slider_min,\n            opt.upsideDown,\n        )\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.set_movement_mode","title":"<code>set_movement_mode(mode: MovementModeStr)</code>","text":"<p>Set movement mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>MovementModeStr</code> <p>movement mode for the main window</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>movement mode type does not exist</p> Source code in <code>prettyqt\\custom_widgets\\spanslider.py</code> <pre><code>def set_movement_mode(self, mode: MovementModeStr):\n\"\"\"Set movement mode.\n\n    Args:\n        mode: movement mode for the main window\n\n    Raises:\n        ValueError: movement mode type does not exist\n    \"\"\"\n    if mode not in MOVEMENT_MODE:\n        raise ValueError(\"Invalid movement mode\")\n    self.movement = mode\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.StandardIconsWidget","title":"<code>StandardIconsWidget</code>","text":"<p>         Bases: <code>widgets.Widget</code></p> <p>Dialog showing standard icons.</p> Source code in <code>prettyqt\\custom_widgets\\standardiconswidget.py</code> <pre><code>class StandardIconsWidget(widgets.Widget):\n\"\"\"Dialog showing standard icons.\"\"\"\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(parent)\n        layout = widgets.BoxLayout(\"horizontal\")\n        row_nb = 14\n        cindex = 0\n        for k in widgets.style.STANDARD_PIXMAP:\n            if cindex == 0:\n                col_layout = widgets.BoxLayout(\"vertical\")\n            icon_layout = widgets.BoxLayout(\"horizontal\")\n            icon = widgets.Application.get_style_icon(k)\n            label = widgets.Label()\n            label.setPixmap(icon.pixmap(32, 32))\n            icon_layout.addWidget(label)\n            icon_layout.addWidget(widgets.LineEdit(k))\n            col_layout.addLayout(icon_layout)\n            cindex = (cindex + 1) % row_nb\n            if cindex == 0:\n                layout.addLayout(col_layout)\n        self.set_layout(layout)\n        self.set_title(\"Standard Platform Icons\")\n        icon = widgets.Application.get_style_icon(\"titlebar_menu_button\")\n        self.set_icon(icon)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.SubsequenceCompleter","title":"<code>SubsequenceCompleter</code>","text":"<p>         Bases: <code>widgets.Completer</code></p> <p>QCompleter specialised for subsequence matching.</p> Source code in <code>prettyqt\\custom_widgets\\subsequencecompleter.py</code> <pre><code>class SubsequenceCompleter(widgets.Completer):\n\"\"\"QCompleter specialised for subsequence matching.\"\"\"\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        self.local_completion_prefix = \"\"\n        self.source_model = None\n        self.proxy_model = custom_models.SubsequenceSortFilterProxyModel(\n            self.is_case_sensitive(), parent=self\n        )\n        self.proxy_model.set_sort_role(\"user\")\n        self._force_next_update = True\n\n    def setModel(self, model: QtCore.QAbstractItemModel):\n        self.source_model = model\n        self.proxy_model = custom_models.SubsequenceSortFilterProxyModel(\n            self.is_case_sensitive(), parent=self\n        )\n        self.proxy_model.set_sort_role(\"user\")\n        self.proxy_model.set_prefix(self.local_completion_prefix)\n        self.proxy_model.setSourceModel(self.source_model)\n        super().setModel(self.proxy_model)\n        self.proxy_model.invalidate()\n        self.proxy_model.sort(0)\n        self._force_next_update = True\n\n    def update_model(self):\n        count = self.completionCount()\n        if count or len(self.local_completion_prefix) &lt;= 1 or self._force_next_update:\n            self.proxy_model.set_prefix(self.local_completion_prefix)\n            self.proxy_model.invalidate()  # force sorting/filtering\n        if count &gt; 1:\n            self.proxy_model.sort(0)\n        self._force_next_update = False\n\n    def splitPath(self, path: str) -&gt; list[str]:\n        self.local_completion_prefix = path\n        self.update_model()\n        return [\"\"]\n</code></pre>"},{"location":"api/gui.html","title":"gui module","text":"<p>Gui module.</p> <p>Contains QtGui-based classes</p>"},{"location":"api/gui.html#prettyqt.gui.Color","title":"<code>Color</code>","text":"<p>         Bases: <code>QtGui.QColor</code></p> Source code in <code>prettyqt\\gui\\color.py</code> <pre><code>class Color(QtGui.QColor):\n    def __init__(self, *args):\n        # PySide2 workaround\n        if len(args) == 1:\n            if isinstance(args[0], QtGui.QColor):\n                super().__init__(args[0].name())\n            elif isinstance(args[0], str):\n                super().__init__()\n                self.set_color(args[0])\n            else:\n                super().__init__(*args)\n        else:\n            super().__init__(*args)\n\n    def __repr__(self):\n        return get_repr(self, self.red(), self.green(), self.blue(), self.alpha())\n\n    def __str__(self):\n        return self.name() if self.alpha() == 255 else self.name(self.NameFormat.HexArgb)\n\n    def __reduce__(self):\n        return type(self), (self.red(), self.green(), self.blue(), self.alpha())\n\n    def serialize_fields(self):\n        return dict(color=self.toString())\n\n    def serialize(self) -&gt; dict[str, Any]:\n        return self.serialize_fields()\n\n    def set_color(self, color: str | tuple):\n        if isinstance(color, str):\n            self.setNamedColor(color)\n        else:\n            self.setRgb(*color)\n\n    @classmethod\n    def from_text(cls, text: str) -&gt; Color:\n\"\"\"Create a QColor from specified string.\"\"\"\n        color = cls()\n        if text.startswith(\"#\") and len(text) == 7:\n            correct = \"#0123456789abcdef\"\n            for char in text:\n                if char.lower() not in correct:\n                    return color\n        elif text not in list(cls.colorNames()):\n            return color\n        color.setNamedColor(text)\n        return color\n\n    @classmethod\n    def from_cmyk(cls, c: float, m: float, y: float, k: float, a: float = 1.0) -&gt; Color:\n        return cls(cls.fromCmykF(c, m, y, k, a))\n\n    @classmethod\n    def from_hsv(cls, h: float, s: float, v: float, a: float = 1.0) -&gt; Color:\n        return cls(cls.fromHsvF(h, s, v, a))\n\n    @classmethod\n    def interpolate_color(\n        cls,\n        start: QtGui.QColor,\n        end: QtGui.QColor,\n        percent: int,\n        colorspace: SpecStr | None = \"rgb\",\n    ) -&gt; Color:\n\"\"\"Get an interpolated color value.\n\n        Args:\n            start: The start color.\n            end: The end color.\n            percent: Which value to get (0 - 100)\n            colorspace: The desired interpolation color system,\n                        QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum)\n                        If None, start is used except when percent is 100.\n\n        Return:\n            The interpolated QColor, with the same spec as the given start color.\n        \"\"\"\n        if colorspace is None:\n            return cls(*end.getRgb()) if percent == 100 else cls(*start.getRgb())\n        if colorspace not in SPEC:\n            raise InvalidParamError(colorspace, SPEC)\n        out = cls()\n        match colorspace:\n            case \"rgb\":\n                components = helpers.get_color_percentage(\n                    start.getRgb(), end.getRgb(), percent  # type: ignore\n                )\n                out.setRgb(*components)\n            case \"hsv\":\n                components = helpers.get_color_percentage(\n                    start.getHsv(), end.getHsv(), percent  # type: ignore\n                )\n                out.setHsv(*components)\n            case \"hsl\":\n                components = helpers.get_color_percentage(\n                    start.getHsl(), end.getHsl(), percent  # type: ignore\n                )\n                out.setHsl(*components)\n            case _:\n                raise ValueError(\"Invalid colorspace!\")\n        return out.convertTo(start.spec())\n\n    def is_dark(self) -&gt; bool:\n\"\"\"Check whether a color is 'dark'.\"\"\"\n        return self.lightness() &lt; 128\n\n    def get_spec(self) -&gt; SpecStr:\n        return SPEC.inverse[self.spec()]\n\n    def convert_to(self, spec: SpecStr) -&gt; Color:\n        # return Color(self.convertTo(SPEC[spec]))\n        color = Color()\n        match spec:\n            case \"rgb\":\n                rgb = self.getRgb()\n                color.setRgb(*rgb)\n            case \"hsv\":\n                hsv = self.getHsv()\n                color.setHsv(*hsv)\n            case \"cmyk\":\n                cmyk = self.getCmyk()\n                color.setCmyk(*cmyk)\n            case \"hsl\":\n                hsl = self.getHsl()\n                color.setHsl(*hsl)\n            case \"extended_rgb\":\n                ergb = self.getRgbF()\n                color.setRgbF(*ergb)\n        return color\n\n    def get_name(self, name_format: NameStr = \"hex_argb\") -&gt; str:\n        match name_format:\n            case \"svg_rgb\" | \"svg_argb\" if not self.isValid():\n                return 'fill=\"\"'\n            case \"svg_rgb\":\n                return f'fill=\"rgb({self.red()}, {self.green()}, {self.blue()})\"'\n            case \"svg_argb\":\n                fill_str = f\"rgb({self.red()}, {self.green()}, {self.blue()})\"\n                return f'fill=\"{fill_str}\" fill-opacity=\"{self.alpha()}\"'\n            case \"qcss_argb\":\n                return (\n                    f\"rgba({self.red()}, {self.green()}, {self.blue()}, {self.alpha()})\"\n                )\n            case \"qcss_rgb\":\n                return f\"rgb({self.red()}, {self.green()}, {self.blue()})\"\n            case _:\n                return self.name(NAME_FORMAT[name_format])\n\n    @deprecated(reason=\"This method is deprecated, use Color.get_name instead.\")\n    def to_qsscolor(self) -&gt; str:\n\"\"\"Convert Color to a string that can be used in a QStyleSheet.\"\"\"\n        return f\"rgba({self.red()}, {self.green()}, {self.blue()}, {self.alpha()})\"\n\n    def as_qt(self) -&gt; QtGui.QColor:\n        return self.convertTo(self.spec())\n\n    def inverted(self, invert_alpha: bool = False) -&gt; Color:\n        return Color(\n            255 - self.red(),\n            255 - self.green(),\n            255 - self.blue(),\n            255 - self.alpha() if invert_alpha else self.alpha(),\n        )\n\n    @classmethod\n    def drift_color(cls, color: datatypes.ColorAndBrushType, factor: int = 110):\n\"\"\"Return color that is lighter or darker than the base color.\n\n        If base_color.lightness is higher than 128, the returned color is darker\n        otherwise is is lighter.\n        :param base_color: The base color to drift from\n        ;:param factor: drift factor (%)\n        :return A lighter or darker color.\n        \"\"\"\n        base_color = cls(color)\n        if base_color.lightness() &gt; 128:\n            return base_color.darker(factor)\n        if base_color == Color(\"#000000\"):\n            return cls.drift_color(cls(\"#101010\"), factor + 20)\n        else:\n            return base_color.lighter(factor + 10)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.drift_color","title":"<code>drift_color(color: datatypes.ColorAndBrushType, factor: int = 110)</code>  <code>classmethod</code>","text":"<p>Return color that is lighter or darker than the base color.</p> <p>If base_color.lightness is higher than 128, the returned color is darker otherwise is is lighter. :param base_color: The base color to drift from ;:param factor: drift factor (%) :return A lighter or darker color.</p> Source code in <code>prettyqt\\gui\\color.py</code> <pre><code>@classmethod\ndef drift_color(cls, color: datatypes.ColorAndBrushType, factor: int = 110):\n\"\"\"Return color that is lighter or darker than the base color.\n\n    If base_color.lightness is higher than 128, the returned color is darker\n    otherwise is is lighter.\n    :param base_color: The base color to drift from\n    ;:param factor: drift factor (%)\n    :return A lighter or darker color.\n    \"\"\"\n    base_color = cls(color)\n    if base_color.lightness() &gt; 128:\n        return base_color.darker(factor)\n    if base_color == Color(\"#000000\"):\n        return cls.drift_color(cls(\"#101010\"), factor + 20)\n    else:\n        return base_color.lighter(factor + 10)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.from_text","title":"<code>from_text(text: str) -&gt; Color</code>  <code>classmethod</code>","text":"<p>Create a QColor from specified string.</p> Source code in <code>prettyqt\\gui\\color.py</code> <pre><code>@classmethod\ndef from_text(cls, text: str) -&gt; Color:\n\"\"\"Create a QColor from specified string.\"\"\"\n    color = cls()\n    if text.startswith(\"#\") and len(text) == 7:\n        correct = \"#0123456789abcdef\"\n        for char in text:\n            if char.lower() not in correct:\n                return color\n    elif text not in list(cls.colorNames()):\n        return color\n    color.setNamedColor(text)\n    return color\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.interpolate_color","title":"<code>interpolate_color(start: QtGui.QColor, end: QtGui.QColor, percent: int, colorspace: SpecStr | None = 'rgb') -&gt; Color</code>  <code>classmethod</code>","text":"<p>Get an interpolated color value.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>QtGui.QColor</code> <p>The start color.</p> required <code>end</code> <code>QtGui.QColor</code> <p>The end color.</p> required <code>percent</code> <code>int</code> <p>Which value to get (0 - 100)</p> required <code>colorspace</code> <code>SpecStr | None</code> <p>The desired interpolation color system,         QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum)         If None, start is used except when percent is 100.</p> <code>'rgb'</code> Return <p>The interpolated QColor, with the same spec as the given start color.</p> Source code in <code>prettyqt\\gui\\color.py</code> <pre><code>@classmethod\ndef interpolate_color(\n    cls,\n    start: QtGui.QColor,\n    end: QtGui.QColor,\n    percent: int,\n    colorspace: SpecStr | None = \"rgb\",\n) -&gt; Color:\n\"\"\"Get an interpolated color value.\n\n    Args:\n        start: The start color.\n        end: The end color.\n        percent: Which value to get (0 - 100)\n        colorspace: The desired interpolation color system,\n                    QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum)\n                    If None, start is used except when percent is 100.\n\n    Return:\n        The interpolated QColor, with the same spec as the given start color.\n    \"\"\"\n    if colorspace is None:\n        return cls(*end.getRgb()) if percent == 100 else cls(*start.getRgb())\n    if colorspace not in SPEC:\n        raise InvalidParamError(colorspace, SPEC)\n    out = cls()\n    match colorspace:\n        case \"rgb\":\n            components = helpers.get_color_percentage(\n                start.getRgb(), end.getRgb(), percent  # type: ignore\n            )\n            out.setRgb(*components)\n        case \"hsv\":\n            components = helpers.get_color_percentage(\n                start.getHsv(), end.getHsv(), percent  # type: ignore\n            )\n            out.setHsv(*components)\n        case \"hsl\":\n            components = helpers.get_color_percentage(\n                start.getHsl(), end.getHsl(), percent  # type: ignore\n            )\n            out.setHsl(*components)\n        case _:\n            raise ValueError(\"Invalid colorspace!\")\n    return out.convertTo(start.spec())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.is_dark","title":"<code>is_dark() -&gt; bool</code>","text":"<p>Check whether a color is 'dark'.</p> Source code in <code>prettyqt\\gui\\color.py</code> <pre><code>def is_dark(self) -&gt; bool:\n\"\"\"Check whether a color is 'dark'.\"\"\"\n    return self.lightness() &lt; 128\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.to_qsscolor","title":"<code>to_qsscolor() -&gt; str</code>","text":"<p>Convert Color to a string that can be used in a QStyleSheet.</p> Source code in <code>prettyqt\\gui\\color.py</code> <pre><code>@deprecated(reason=\"This method is deprecated, use Color.get_name instead.\")\ndef to_qsscolor(self) -&gt; str:\n\"\"\"Convert Color to a string that can be used in a QStyleSheet.\"\"\"\n    return f\"rgba({self.red()}, {self.green()}, {self.blue()}, {self.alpha()})\"\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.ColorSpace","title":"<code>ColorSpace</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QColorSpace</code></p> Source code in <code>prettyqt\\gui\\colorspace.py</code> <pre><code>class ColorSpace(serializemixin.SerializeMixin, QtGui.QColorSpace):\n    def __bool__(self):\n        return self.isValid()\n\n    def set_primaries(self, primaries: PrimariesStr):\n\"\"\"Set primaries.\n\n        Args:\n            primaries: primaries to use\n\n        Raises:\n            InvalidParamError: primaries do not exist\n        \"\"\"\n        if primaries not in PRIMARIES:\n            raise InvalidParamError(primaries, PRIMARIES)\n        self.setPrimaries(PRIMARIES[primaries])\n\n    def get_primaries(self) -&gt; PrimariesStr:\n\"\"\"Return current primaries.\n\n        Returns:\n            primaries\n        \"\"\"\n        return PRIMARIES.inverse[self.primaries()]\n\n    def set_transfer_function(self, fn: TransformFunctionStr, gamma: float = 0.0):\n\"\"\"Set transfer function.\n\n        Args:\n            fn: transfer function to use\n            gamma: gamma value\n\n        Raises:\n            InvalidParamError: transfer function do not exist\n        \"\"\"\n        if fn not in TRANSFER_FUNCTION:\n            raise InvalidParamError(fn, TRANSFER_FUNCTION)\n        self.setTransferFunction(TRANSFER_FUNCTION[fn], gamma)\n\n    def get_transfer_function(self) -&gt; TransformFunctionStr:\n\"\"\"Return current transfer function.\n\n        Returns:\n            transfer function\n        \"\"\"\n        return TRANSFER_FUNCTION.inverse[self.transferFunction()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_primaries","title":"<code>get_primaries() -&gt; PrimariesStr</code>","text":"<p>Return current primaries.</p> <p>Returns:</p> Type Description <code>PrimariesStr</code> <p>primaries</p> Source code in <code>prettyqt\\gui\\colorspace.py</code> <pre><code>def get_primaries(self) -&gt; PrimariesStr:\n\"\"\"Return current primaries.\n\n    Returns:\n        primaries\n    \"\"\"\n    return PRIMARIES.inverse[self.primaries()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_transfer_function","title":"<code>get_transfer_function() -&gt; TransformFunctionStr</code>","text":"<p>Return current transfer function.</p> <p>Returns:</p> Type Description <code>TransformFunctionStr</code> <p>transfer function</p> Source code in <code>prettyqt\\gui\\colorspace.py</code> <pre><code>def get_transfer_function(self) -&gt; TransformFunctionStr:\n\"\"\"Return current transfer function.\n\n    Returns:\n        transfer function\n    \"\"\"\n    return TRANSFER_FUNCTION.inverse[self.transferFunction()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_primaries","title":"<code>set_primaries(primaries: PrimariesStr)</code>","text":"<p>Set primaries.</p> <p>Parameters:</p> Name Type Description Default <code>primaries</code> <code>PrimariesStr</code> <p>primaries to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>primaries do not exist</p> Source code in <code>prettyqt\\gui\\colorspace.py</code> <pre><code>def set_primaries(self, primaries: PrimariesStr):\n\"\"\"Set primaries.\n\n    Args:\n        primaries: primaries to use\n\n    Raises:\n        InvalidParamError: primaries do not exist\n    \"\"\"\n    if primaries not in PRIMARIES:\n        raise InvalidParamError(primaries, PRIMARIES)\n    self.setPrimaries(PRIMARIES[primaries])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_transfer_function","title":"<code>set_transfer_function(fn: TransformFunctionStr, gamma: float = 0.0)</code>","text":"<p>Set transfer function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>TransformFunctionStr</code> <p>transfer function to use</p> required <code>gamma</code> <code>float</code> <p>gamma value</p> <code>0.0</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>transfer function do not exist</p> Source code in <code>prettyqt\\gui\\colorspace.py</code> <pre><code>def set_transfer_function(self, fn: TransformFunctionStr, gamma: float = 0.0):\n\"\"\"Set transfer function.\n\n    Args:\n        fn: transfer function to use\n        gamma: gamma value\n\n    Raises:\n        InvalidParamError: transfer function do not exist\n    \"\"\"\n    if fn not in TRANSFER_FUNCTION:\n        raise InvalidParamError(fn, TRANSFER_FUNCTION)\n    self.setTransferFunction(TRANSFER_FUNCTION[fn], gamma)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Cursor","title":"<code>Cursor</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QCursor</code></p> Source code in <code>prettyqt\\gui\\cursor.py</code> <pre><code>class Cursor(serializemixin.SerializeMixin, QtGui.QCursor):\n    def set_shape(self, shape: constants.CursorShapeStr):\n\"\"\"Set cursor shape.\n\n        Args:\n            shape: shape to use\n\n        Raises:\n            InvalidParamError: shape does not exist\n        \"\"\"\n        if shape not in constants.CURSOR_SHAPE:\n            raise InvalidParamError(shape, constants.CURSOR_SHAPE)\n        self.setShape(constants.CURSOR_SHAPE[shape])\n\n    def get_shape(self) -&gt; constants.CursorShapeStr:\n\"\"\"Return current cursor shape.\n\n        Returns:\n            cursor shape\n        \"\"\"\n        return constants.CURSOR_SHAPE.inverse[self.shape()]\n\n    @classmethod\n    def get_position(cls) -&gt; core.Point:\n        return core.Point(cls.pos())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.get_shape","title":"<code>get_shape() -&gt; constants.CursorShapeStr</code>","text":"<p>Return current cursor shape.</p> <p>Returns:</p> Type Description <code>constants.CursorShapeStr</code> <p>cursor shape</p> Source code in <code>prettyqt\\gui\\cursor.py</code> <pre><code>def get_shape(self) -&gt; constants.CursorShapeStr:\n\"\"\"Return current cursor shape.\n\n    Returns:\n        cursor shape\n    \"\"\"\n    return constants.CURSOR_SHAPE.inverse[self.shape()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.set_shape","title":"<code>set_shape(shape: constants.CursorShapeStr)</code>","text":"<p>Set cursor shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>constants.CursorShapeStr</code> <p>shape to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>shape does not exist</p> Source code in <code>prettyqt\\gui\\cursor.py</code> <pre><code>def set_shape(self, shape: constants.CursorShapeStr):\n\"\"\"Set cursor shape.\n\n    Args:\n        shape: shape to use\n\n    Raises:\n        InvalidParamError: shape does not exist\n    \"\"\"\n    if shape not in constants.CURSOR_SHAPE:\n        raise InvalidParamError(shape, constants.CURSOR_SHAPE)\n    self.setShape(constants.CURSOR_SHAPE[shape])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Font","title":"<code>Font</code>","text":"<p>         Bases: <code>prettyprinter.PrettyPrinter</code>, <code>QtGui.QFont</code></p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>class Font(prettyprinter.PrettyPrinter, QtGui.QFont):\n    def __repr__(self):\n        return get_repr(\n            self, self.family(), self.pointSize(), self.weight(), self.italic()\n        )\n\n    def __getstate__(self):\n        return dict(\n            family=self.family(),\n            pointsize=self.pointSize(),\n            weight=self.weight(),\n            italic=self.italic(),\n        )\n\n    def __setstate__(self, state):\n        self.setFamily(state[\"family\"])\n        if state[\"pointsize\"] &gt; -1:\n            self.setPointSize(state[\"pointsize\"])\n        self.setWeight(state[\"weight\"])\n        self.setItalic(state[\"italic\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def serialize(self) -&gt; dict[str, Any]:\n        return self.__getstate__()\n\n    @property\n    def metrics(self):\n        return gui.FontMetrics(self)\n\n    def set_size(self, size: int):\n        self.setPointSize(size)\n\n    @classmethod\n    def mono(cls, size=8):\n        return cls(\"Consolas\", size)\n        # font.setStyleHint()\n\n    def set_style_hint(self, hint: StyleHintStr):\n\"\"\"Set the style hint.\n\n        Args:\n            hint: style hint\n\n        Raises:\n            InvalidParamError: invalid style hint\n        \"\"\"\n        if hint not in STYLE_HINTS:\n            raise InvalidParamError(hint, STYLE_HINTS)\n        self.setStyleHint(STYLE_HINTS[hint])\n\n    def set_weight(self, weight: WeightStr):\n\"\"\"Set the font weight.\n\n        Args:\n            weight: font weight\n\n        Raises:\n            InvalidParamError: invalid font weight\n        \"\"\"\n        if weight not in WEIGHT:\n            raise InvalidParamError(weight, WEIGHT)\n        self.setWeight(WEIGHT[weight])\n\n    def get_weight(self) -&gt; WeightStr:\n\"\"\"Get current font weight.\n\n        Returns:\n            current font weight\n        \"\"\"\n        return WEIGHT.inverse[self.weight()]\n\n    def set_capitalization(self, capitalization: CapitalizationStr):\n\"\"\"Set the font capitalization.\n\n        Args:\n            capitalization: font capitalization\n\n        Raises:\n            InvalidParamError: invalid font capitalization\n        \"\"\"\n        if capitalization not in CAPITALIZATION:\n            raise InvalidParamError(capitalization, CAPITALIZATION)\n        self.setCapitalization(CAPITALIZATION[capitalization])\n\n    def get_capitalization(self) -&gt; CapitalizationStr:\n\"\"\"Get current font capitalization.\n\n        Returns:\n            current font capitalization\n        \"\"\"\n        return CAPITALIZATION.inverse[self.capitalization()]\n\n    def set_hinting_preference(self, preference: HintingPreferenceStr):\n\"\"\"Set the hinting preference.\n\n        Args:\n            preference: hinting preference\n\n        Raises:\n            InvalidParamError: invalid hinting preference\n        \"\"\"\n        if preference not in HINTING_PREFERENCE:\n            raise InvalidParamError(preference, HINTING_PREFERENCE)\n        self.setHintingPreference(HINTING_PREFERENCE[preference])\n\n    def get_hinting_preference(self) -&gt; HintingPreferenceStr:\n\"\"\"Get current hinting preference.\n\n        Returns:\n            current hinting preference\n        \"\"\"\n        return HINTING_PREFERENCE.inverse[self.hintingPreference()]\n\n    def set_letter_spacing(self, typ: SpacingTypeStr, spacing: float):\n\"\"\"Set the letter spacing.\n\n        Args:\n            typ: letter spacing type\n            spacing: spacing\n\n        Raises:\n            InvalidParamError: invalid letter spacing type\n        \"\"\"\n        if typ not in SPACING_TYPE:\n            raise InvalidParamError(typ, SPACING_TYPE)\n        self.setLetterSpacing(SPACING_TYPE[typ], spacing)\n\n    def get_letter_spacing_type(self) -&gt; SpacingTypeStr:\n\"\"\"Get current letter spacing type.\n\n        Returns:\n            current letter spacing type\n        \"\"\"\n        return SPACING_TYPE.inverse[self.letterSpacingType()]\n\n    def set_style(self, style: StyleStr):\n\"\"\"Set the font style.\n\n        Args:\n            style: font style\n\n        Raises:\n            InvalidParamError: invalid font style\n        \"\"\"\n        if style not in STYLE:\n            raise InvalidParamError(style, STYLE)\n        self.setStyle(STYLE[style])\n\n    def get_style(self) -&gt; StyleStr:\n\"\"\"Get current font style.\n\n        Returns:\n            current font style\n        \"\"\"\n        return STYLE.inverse[self.style()]\n\n    def set_family(self, family: str, fallback: str | None = None):\n\"\"\"Set the font family.\n\n        Args:\n            family: font family\n            fallback: fallback font family\n        \"\"\"\n        self.setFamily(family)\n        font_info = gui.FontInfo(self)\n        if fallback is not None and font_info.family() != family:\n            self.setFamily(fallback)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_capitalization","title":"<code>get_capitalization() -&gt; CapitalizationStr</code>","text":"<p>Get current font capitalization.</p> <p>Returns:</p> Type Description <code>CapitalizationStr</code> <p>current font capitalization</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def get_capitalization(self) -&gt; CapitalizationStr:\n\"\"\"Get current font capitalization.\n\n    Returns:\n        current font capitalization\n    \"\"\"\n    return CAPITALIZATION.inverse[self.capitalization()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_hinting_preference","title":"<code>get_hinting_preference() -&gt; HintingPreferenceStr</code>","text":"<p>Get current hinting preference.</p> <p>Returns:</p> Type Description <code>HintingPreferenceStr</code> <p>current hinting preference</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def get_hinting_preference(self) -&gt; HintingPreferenceStr:\n\"\"\"Get current hinting preference.\n\n    Returns:\n        current hinting preference\n    \"\"\"\n    return HINTING_PREFERENCE.inverse[self.hintingPreference()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_letter_spacing_type","title":"<code>get_letter_spacing_type() -&gt; SpacingTypeStr</code>","text":"<p>Get current letter spacing type.</p> <p>Returns:</p> Type Description <code>SpacingTypeStr</code> <p>current letter spacing type</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def get_letter_spacing_type(self) -&gt; SpacingTypeStr:\n\"\"\"Get current letter spacing type.\n\n    Returns:\n        current letter spacing type\n    \"\"\"\n    return SPACING_TYPE.inverse[self.letterSpacingType()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_style","title":"<code>get_style() -&gt; StyleStr</code>","text":"<p>Get current font style.</p> <p>Returns:</p> Type Description <code>StyleStr</code> <p>current font style</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def get_style(self) -&gt; StyleStr:\n\"\"\"Get current font style.\n\n    Returns:\n        current font style\n    \"\"\"\n    return STYLE.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_weight","title":"<code>get_weight() -&gt; WeightStr</code>","text":"<p>Get current font weight.</p> <p>Returns:</p> Type Description <code>WeightStr</code> <p>current font weight</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def get_weight(self) -&gt; WeightStr:\n\"\"\"Get current font weight.\n\n    Returns:\n        current font weight\n    \"\"\"\n    return WEIGHT.inverse[self.weight()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_capitalization","title":"<code>set_capitalization(capitalization: CapitalizationStr)</code>","text":"<p>Set the font capitalization.</p> <p>Parameters:</p> Name Type Description Default <code>capitalization</code> <code>CapitalizationStr</code> <p>font capitalization</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid font capitalization</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_capitalization(self, capitalization: CapitalizationStr):\n\"\"\"Set the font capitalization.\n\n    Args:\n        capitalization: font capitalization\n\n    Raises:\n        InvalidParamError: invalid font capitalization\n    \"\"\"\n    if capitalization not in CAPITALIZATION:\n        raise InvalidParamError(capitalization, CAPITALIZATION)\n    self.setCapitalization(CAPITALIZATION[capitalization])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_family","title":"<code>set_family(family: str, fallback: str | None = None)</code>","text":"<p>Set the font family.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <code>str</code> <p>font family</p> required <code>fallback</code> <code>str | None</code> <p>fallback font family</p> <code>None</code> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_family(self, family: str, fallback: str | None = None):\n\"\"\"Set the font family.\n\n    Args:\n        family: font family\n        fallback: fallback font family\n    \"\"\"\n    self.setFamily(family)\n    font_info = gui.FontInfo(self)\n    if fallback is not None and font_info.family() != family:\n        self.setFamily(fallback)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_hinting_preference","title":"<code>set_hinting_preference(preference: HintingPreferenceStr)</code>","text":"<p>Set the hinting preference.</p> <p>Parameters:</p> Name Type Description Default <code>preference</code> <code>HintingPreferenceStr</code> <p>hinting preference</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid hinting preference</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_hinting_preference(self, preference: HintingPreferenceStr):\n\"\"\"Set the hinting preference.\n\n    Args:\n        preference: hinting preference\n\n    Raises:\n        InvalidParamError: invalid hinting preference\n    \"\"\"\n    if preference not in HINTING_PREFERENCE:\n        raise InvalidParamError(preference, HINTING_PREFERENCE)\n    self.setHintingPreference(HINTING_PREFERENCE[preference])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_letter_spacing","title":"<code>set_letter_spacing(typ: SpacingTypeStr, spacing: float)</code>","text":"<p>Set the letter spacing.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>SpacingTypeStr</code> <p>letter spacing type</p> required <code>spacing</code> <code>float</code> <p>spacing</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid letter spacing type</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_letter_spacing(self, typ: SpacingTypeStr, spacing: float):\n\"\"\"Set the letter spacing.\n\n    Args:\n        typ: letter spacing type\n        spacing: spacing\n\n    Raises:\n        InvalidParamError: invalid letter spacing type\n    \"\"\"\n    if typ not in SPACING_TYPE:\n        raise InvalidParamError(typ, SPACING_TYPE)\n    self.setLetterSpacing(SPACING_TYPE[typ], spacing)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style","title":"<code>set_style(style: StyleStr)</code>","text":"<p>Set the font style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>StyleStr</code> <p>font style</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid font style</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_style(self, style: StyleStr):\n\"\"\"Set the font style.\n\n    Args:\n        style: font style\n\n    Raises:\n        InvalidParamError: invalid font style\n    \"\"\"\n    if style not in STYLE:\n        raise InvalidParamError(style, STYLE)\n    self.setStyle(STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style_hint","title":"<code>set_style_hint(hint: StyleHintStr)</code>","text":"<p>Set the style hint.</p> <p>Parameters:</p> Name Type Description Default <code>hint</code> <code>StyleHintStr</code> <p>style hint</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid style hint</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_style_hint(self, hint: StyleHintStr):\n\"\"\"Set the style hint.\n\n    Args:\n        hint: style hint\n\n    Raises:\n        InvalidParamError: invalid style hint\n    \"\"\"\n    if hint not in STYLE_HINTS:\n        raise InvalidParamError(hint, STYLE_HINTS)\n    self.setStyleHint(STYLE_HINTS[hint])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_weight","title":"<code>set_weight(weight: WeightStr)</code>","text":"<p>Set the font weight.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>WeightStr</code> <p>font weight</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid font weight</p> Source code in <code>prettyqt\\gui\\font.py</code> <pre><code>def set_weight(self, weight: WeightStr):\n\"\"\"Set the font weight.\n\n    Args:\n        weight: font weight\n\n    Raises:\n        InvalidParamError: invalid font weight\n    \"\"\"\n    if weight not in WEIGHT:\n        raise InvalidParamError(weight, WEIGHT)\n    self.setWeight(WEIGHT[weight])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.GradientMixin","title":"<code>GradientMixin</code>","text":"Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>class GradientMixin:\n    def __setitem__(self, key: float, value):\n        self.setColorAt(key, value)\n\n    def serialize(self) -&gt; dict[str, Any]:\n        return dict(\n            coordinate_mode=self.get_coordinate_mode(),\n            spread=self.get_spread(),\n            stops=self.get_stops(),\n        )\n\n    def set_coordinate_mode(self, mode: CoordinateModeStr):\n\"\"\"Set the coordinate mode.\n\n        Args:\n            mode: coordinate mode\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in COORDINATE_MODE:\n            raise InvalidParamError(mode, COORDINATE_MODE)\n        self.setCoordinateMode(COORDINATE_MODE[mode])\n\n    def get_coordinate_mode(self) -&gt; CoordinateModeStr:\n\"\"\"Return current coordinate mode.\n\n        Returns:\n            coordinate mode\n        \"\"\"\n        return COORDINATE_MODE.inverse[self.coordinateMode()]\n\n    def set_spread(self, method: SpreadStr):\n\"\"\"Set the spread method.\n\n        Args:\n            method: spread method\n\n        Raises:\n            InvalidParamError: method does not exist\n        \"\"\"\n        if method not in SPREAD:\n            raise InvalidParamError(method, SPREAD)\n        self.setSpread(SPREAD[method])\n\n    def get_spread(self) -&gt; SpreadStr:\n\"\"\"Return current spread method.\n\n        Returns:\n            spread method\n        \"\"\"\n        return SPREAD.inverse[self.spread()]\n\n    def get_type(self) -&gt; TypeStr:\n\"\"\"Return current gradient type.\n\n        Returns:\n            gradient type\n        \"\"\"\n        return TYPE.inverse[self.type()]\n\n    def get_stops(self) -&gt; list[tuple[float, gui.Color]]:\n        return [(i, gui.Color(j)) for (i, j) in self.stops()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.get_coordinate_mode","title":"<code>get_coordinate_mode() -&gt; CoordinateModeStr</code>","text":"<p>Return current coordinate mode.</p> <p>Returns:</p> Type Description <code>CoordinateModeStr</code> <p>coordinate mode</p> Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>def get_coordinate_mode(self) -&gt; CoordinateModeStr:\n\"\"\"Return current coordinate mode.\n\n    Returns:\n        coordinate mode\n    \"\"\"\n    return COORDINATE_MODE.inverse[self.coordinateMode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.get_spread","title":"<code>get_spread() -&gt; SpreadStr</code>","text":"<p>Return current spread method.</p> <p>Returns:</p> Type Description <code>SpreadStr</code> <p>spread method</p> Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>def get_spread(self) -&gt; SpreadStr:\n\"\"\"Return current spread method.\n\n    Returns:\n        spread method\n    \"\"\"\n    return SPREAD.inverse[self.spread()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.get_type","title":"<code>get_type() -&gt; TypeStr</code>","text":"<p>Return current gradient type.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>gradient type</p> Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return current gradient type.\n\n    Returns:\n        gradient type\n    \"\"\"\n    return TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.set_coordinate_mode","title":"<code>set_coordinate_mode(mode: CoordinateModeStr)</code>","text":"<p>Set the coordinate mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CoordinateModeStr</code> <p>coordinate mode</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>def set_coordinate_mode(self, mode: CoordinateModeStr):\n\"\"\"Set the coordinate mode.\n\n    Args:\n        mode: coordinate mode\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in COORDINATE_MODE:\n        raise InvalidParamError(mode, COORDINATE_MODE)\n    self.setCoordinateMode(COORDINATE_MODE[mode])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.set_spread","title":"<code>set_spread(method: SpreadStr)</code>","text":"<p>Set the spread method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>SpreadStr</code> <p>spread method</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>method does not exist</p> Source code in <code>prettyqt\\gui\\gradient.py</code> <pre><code>def set_spread(self, method: SpreadStr):\n\"\"\"Set the spread method.\n\n    Args:\n        method: spread method\n\n    Raises:\n        InvalidParamError: method does not exist\n    \"\"\"\n    if method not in SPREAD:\n        raise InvalidParamError(method, SPREAD)\n    self.setSpread(SPREAD[method])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.GuiApplicationMixin","title":"<code>GuiApplicationMixin</code>","text":"<p>         Bases: <code>core.CoreApplicationMixin</code></p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>class GuiApplicationMixin(core.CoreApplicationMixin):\n    def serialize_fields(self):\n        return dict(icon=self.get_icon())\n\n    @classmethod\n    @contextlib.contextmanager\n    def override_cursor(cls, cursor: constants.CursorShapeStr):\n        cls.set_override_cursor(cursor)\n        yield cursor\n        cls.restore_override_cursor()\n\n    @classmethod\n    def set_override_cursor(cls, cursor: constants.CursorShapeStr):\n        crs = gui.Cursor(constants.CURSOR_SHAPE[cursor])\n        cls.setOverrideCursor(crs)\n\n    @classmethod\n    def restore_override_cursor(cls):\n        cls.restoreOverrideCursor()\n\n    @classmethod\n    def get_clipboard(cls) -&gt; gui.Clipboard:\n        return gui.Clipboard(cls.clipboard())\n\n    @classmethod\n    @contextlib.contextmanager\n    def edit_palette(cls) -&gt; Iterator[gui.Palette]:\n        palette = gui.Palette(cls.palette())\n        yield palette\n        cls.setPalette(palette)\n\n    def set_layout_direction(self, direction: constants.LayoutDirectionStr):\n\"\"\"Set layout direction.\n\n        Args:\n            direction: layout direction\n\n        Raises:\n            InvalidParamError: layout direction does not exist\n        \"\"\"\n        if direction not in constants.LAYOUT_DIRECTION:\n            raise InvalidParamError(direction, constants.LAYOUT_DIRECTION)\n        self.setLayoutDirection(constants.LAYOUT_DIRECTION[direction])\n\n    def get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n\n        Returns:\n            layout direction\n        \"\"\"\n        return constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\n\n    @classmethod\n    def set_high_dpi_scale_factor_rounding_policy(\n        cls, policy: constants.HighDpiScaleFactorRoundingPolicyStr\n    ):\n\"\"\"Set high dpi scale factor rounding policy.\n\n        Args:\n            policy: rounding policy\n\n        Raises:\n            InvalidParamError: rounding policy does not exist\n        \"\"\"\n        if policy not in constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY:\n            raise InvalidParamError(\n                policy, constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY\n            )\n        cls.setHighDpiScaleFactorRoundingPolicy(\n            constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY[policy]\n        )\n\n    @classmethod\n    def get_high_dpi_scale_factor_rounding_policy(\n        cls,\n    ) -&gt; constants.HighDpiScaleFactorRoundingPolicyStr:\n\"\"\"Get the current high dpi scale factor rounding policy.\n\n        Returns:\n            rounding policy\n        \"\"\"\n        return constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY.inverse[\n            cls.highDpiScaleFactorRoundingPolicy()\n        ]\n\n    @classmethod\n    def get_application_state(cls) -&gt; list[constants.ApplicationStateStr]:\n\"\"\"Get the current application state.\n\n        Returns:\n            application state\n        \"\"\"\n        return [\n            k\n            for k, v in constants.APPLICATION_STATES.items()\n            if v &amp; cls.applicationState()  # type: ignore\n        ]\n\n    def get_primary_screen(self) -&gt; gui.Screen:\n        return gui.Screen(self.primaryScreen())\n\n    def get_screen_at(self, point: datatypes.PointType) -&gt; gui.Screen:\n        if isinstance(point, tuple):\n            point = QtCore.QPoint(*point)\n        return gui.Screen(self.screenAt(point))\n\n    def get_screens(self) -&gt; list[gui.Screen]:\n        return [gui.Screen(i) for i in self.screens()]\n\n    @classmethod\n    def get_input_method(cls) -&gt; gui.InputMethod:\n        return gui.InputMethod(cls.inputMethod())\n\n    @classmethod\n    def copy_to_clipboard(cls, text: str):\n\"\"\"Sets clipboard to supplied text.\"\"\"\n        cb = cls.clipboard()\n        cb.clear(mode=cb.Mode.Clipboard)\n        cb.setText(text, mode=cb.Mode.Clipboard)\n\n    @classmethod\n    def get_font(cls) -&gt; gui.Font:\n        return gui.Font(cls.font())\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the default window icon.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\n        self.setWindowIcon(icon)\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.windowIcon()\n        return None if icon.isNull() else gui.Icon(self.windowIcon())\n\n    @classmethod\n    def set_palette(cls, palette: constants.ThemeStr | QtGui.QPalette):\n        if palette == \"default\":\n            pal = gui.Palette()\n        elif palette == \"dark\":\n            pal = gui.Palette.create_dark_palette()\n        else:\n            pal = palette\n        cls.setPalette(pal)\n\n    @classmethod\n    def get_palette(cls) -&gt; gui.Palette:\n        return gui.Palette(cls.palette())\n\n    def set_badge_number(self, number: int | None):\n        self.setBadgeNumber(number or 0)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.copy_to_clipboard","title":"<code>copy_to_clipboard(text: str)</code>  <code>classmethod</code>","text":"<p>Sets clipboard to supplied text.</p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>@classmethod\ndef copy_to_clipboard(cls, text: str):\n\"\"\"Sets clipboard to supplied text.\"\"\"\n    cb = cls.clipboard()\n    cb.clear(mode=cb.Mode.Clipboard)\n    cb.setText(text, mode=cb.Mode.Clipboard)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.get_application_state","title":"<code>get_application_state() -&gt; list[constants.ApplicationStateStr]</code>  <code>classmethod</code>","text":"<p>Get the current application state.</p> <p>Returns:</p> Type Description <code>list[constants.ApplicationStateStr]</code> <p>application state</p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>@classmethod\ndef get_application_state(cls) -&gt; list[constants.ApplicationStateStr]:\n\"\"\"Get the current application state.\n\n    Returns:\n        application state\n    \"\"\"\n    return [\n        k\n        for k, v in constants.APPLICATION_STATES.items()\n        if v &amp; cls.applicationState()  # type: ignore\n    ]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.get_high_dpi_scale_factor_rounding_policy","title":"<code>get_high_dpi_scale_factor_rounding_policy() -&gt; constants.HighDpiScaleFactorRoundingPolicyStr</code>  <code>classmethod</code>","text":"<p>Get the current high dpi scale factor rounding policy.</p> <p>Returns:</p> Type Description <code>constants.HighDpiScaleFactorRoundingPolicyStr</code> <p>rounding policy</p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>@classmethod\ndef get_high_dpi_scale_factor_rounding_policy(\n    cls,\n) -&gt; constants.HighDpiScaleFactorRoundingPolicyStr:\n\"\"\"Get the current high dpi scale factor rounding policy.\n\n    Returns:\n        rounding policy\n    \"\"\"\n    return constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY.inverse[\n        cls.highDpiScaleFactorRoundingPolicy()\n    ]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.get_layout_direction","title":"<code>get_layout_direction() -&gt; constants.LayoutDirectionStr</code>","text":"<p>Get the current layout direction.</p> <p>Returns:</p> Type Description <code>constants.LayoutDirectionStr</code> <p>layout direction</p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>def get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n\n    Returns:\n        layout direction\n    \"\"\"\n    return constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.set_high_dpi_scale_factor_rounding_policy","title":"<code>set_high_dpi_scale_factor_rounding_policy(policy: constants.HighDpiScaleFactorRoundingPolicyStr)</code>  <code>classmethod</code>","text":"<p>Set high dpi scale factor rounding policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>constants.HighDpiScaleFactorRoundingPolicyStr</code> <p>rounding policy</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>rounding policy does not exist</p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>@classmethod\ndef set_high_dpi_scale_factor_rounding_policy(\n    cls, policy: constants.HighDpiScaleFactorRoundingPolicyStr\n):\n\"\"\"Set high dpi scale factor rounding policy.\n\n    Args:\n        policy: rounding policy\n\n    Raises:\n        InvalidParamError: rounding policy does not exist\n    \"\"\"\n    if policy not in constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY:\n        raise InvalidParamError(\n            policy, constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY\n        )\n    cls.setHighDpiScaleFactorRoundingPolicy(\n        constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY[policy]\n    )\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the default window icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the default window icon.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\n    self.setWindowIcon(icon)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.set_layout_direction","title":"<code>set_layout_direction(direction: constants.LayoutDirectionStr)</code>","text":"<p>Set layout direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>constants.LayoutDirectionStr</code> <p>layout direction</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>layout direction does not exist</p> Source code in <code>prettyqt\\gui\\guiapplication.py</code> <pre><code>def set_layout_direction(self, direction: constants.LayoutDirectionStr):\n\"\"\"Set layout direction.\n\n    Args:\n        direction: layout direction\n\n    Raises:\n        InvalidParamError: layout direction does not exist\n    \"\"\"\n    if direction not in constants.LAYOUT_DIRECTION:\n        raise InvalidParamError(direction, constants.LAYOUT_DIRECTION)\n    self.setLayoutDirection(constants.LAYOUT_DIRECTION[direction])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Icon","title":"<code>Icon</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QIcon</code></p> Source code in <code>prettyqt\\gui\\icon.py</code> <pre><code>class Icon(serializemixin.SerializeMixin, QtGui.QIcon):\n    def __repr__(self):\n        return get_repr(self)\n\n    def __bool__(self):\n        return not self.isNull()\n\n    def __getstate__(self):\n        pixmap = self.pixmap(256, 256)\n        return bytes(gui.Pixmap(pixmap))\n\n    def __setstate__(self, ba):\n        px = gui.Pixmap()\n        px.__setstate__(ba)\n        self.add_pixmap(px)\n\n    @classmethod\n    def for_color(cls, color_str: str) -&gt; Icon:\n        color = gui.Color.from_text(color_str)\n        if not color.isValid():\n            raise TypeError()\n        bitmap = gui.Pixmap(16, 16)\n        bitmap.fill(color)\n        return cls(bitmap)\n\n    @classmethod\n    def from_char(cls, char: str, background=\"black\", color=\"white\") -&gt; Icon:\n\"\"\"Create a QIcon with a given character.\"\"\"\n        icon = cls()\n        for size in (16, 32, 64):\n            px = gui.Pixmap.create_char(\n                char, background=background, color=color, size=size\n            )\n            icon.addPixmap(px)\n        return icon\n\n    @classmethod\n    def from_image(cls, image: QtGui.QImage) -&gt; Icon:\n        return cls(gui.Pixmap.fromImage(image))\n\n    def get_available_sizes(\n        self, mode: ModeStr = \"normal\", state: StateStr = \"off\"\n    ) -&gt; list[core.Size]:\n        if mode not in MODE:\n            raise InvalidParamError(mode, MODE)\n        if state not in STATE:\n            raise InvalidParamError(state, STATE)\n        return [core.Size(i) for i in self.availableSizes(MODE[mode], STATE[state])]\n\n    def add_pixmap(\n        self,\n        data: QtCore.QByteArray | QtGui.QPixmap | bytes,\n        mode: ModeStr = \"normal\",\n        state: StateStr = \"off\",\n    ):\n        if mode not in MODE:\n            raise InvalidParamError(mode, MODE)\n        if state not in STATE:\n            raise InvalidParamError(state, STATE)\n        if isinstance(data, bytes):\n            data = QtCore.QByteArray(data)\n        if isinstance(data, QtCore.QByteArray):\n            pixmap = QtGui.QPixmap()\n            pixmap.loadFromData(data)\n        else:\n            pixmap = data\n        self.addPixmap(pixmap, MODE[mode], STATE[state])\n\n    def get_pixmap(\n        self,\n        size: datatypes.SizeType | int,\n        mode: ModeStr = \"normal\",\n        state: StateStr = \"off\",\n    ) -&gt; QtGui.QPixmap:\n        if mode not in MODE:\n            raise InvalidParamError(mode, MODE)\n        if state not in STATE:\n            raise InvalidParamError(state, STATE)\n        if isinstance(size, tuple):\n            size = core.Size(*size)\n        elif isinstance(size, int):\n            size = core.Size(size, size)\n        return self.pixmap(size, MODE[mode], STATE[state])\n\n    def get_actual_size(\n        self,\n        size: datatypes.SizeType | int,\n        mode: ModeStr = \"normal\",\n        state: StateStr = \"off\",\n    ) -&gt; core.Size:\n        if mode not in MODE:\n            raise InvalidParamError(mode, MODE)\n        if state not in STATE:\n            raise InvalidParamError(state, STATE)\n        if isinstance(size, tuple):\n            size = core.Size(*size)\n        elif isinstance(size, int):\n            size = core.Size(size, size)\n        return core.Size(self.actualSize(size, MODE[mode], STATE[state]))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.icon.Icon.from_char","title":"<code>from_char(char: str, background = 'black', color = 'white') -&gt; Icon</code>  <code>classmethod</code>","text":"<p>Create a QIcon with a given character.</p> Source code in <code>prettyqt\\gui\\icon.py</code> <pre><code>@classmethod\ndef from_char(cls, char: str, background=\"black\", color=\"white\") -&gt; Icon:\n\"\"\"Create a QIcon with a given character.\"\"\"\n    icon = cls()\n    for size in (16, 32, 64):\n        px = gui.Pixmap.create_char(\n            char, background=background, color=color, size=size\n        )\n        icon.addPixmap(px)\n    return icon\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.ImageIOHandler","title":"<code>ImageIOHandler</code>","text":"<p>         Bases: <code>mod</code></p> Source code in <code>prettyqt\\gui\\imageiohandler.py</code> <pre><code>class ImageIOHandler(mod):\n    def __getitem__(self, key: ImageOptionStr) -&gt; datatypes.Variant:\n        return self.get_option(key)\n\n    def __setitem__(self, key: ImageOptionStr, value: datatypes.Variant):\n        self.set_option(key, value)\n\n    def get_format(self) -&gt; str:\n        return self.format().data().decode()\n\n    def set_option(self, option: ImageOptionStr, value: datatypes.Variant):\n\"\"\"Set option to given value.\n\n        Args:\n            option: option to use\n            value: value to set\n\n        Raises:\n            InvalidParamError: option does not exist\n        \"\"\"\n        if option not in IMAGE_OPTION:\n            raise InvalidParamError(option, IMAGE_OPTION)\n        self.setOption(IMAGE_OPTION[option], value)\n\n    def get_option(self, option: ImageOptionStr) -&gt; datatypes.Variant:\n\"\"\"Return the value assigned to option.\n\n        Args:\n            option: option to get\n\n        Returns:\n            option\n        \"\"\"\n        if option not in IMAGE_OPTION:\n            raise InvalidParamError(option, IMAGE_OPTION)\n        return self.option(IMAGE_OPTION[option])\n\n    def supports_option(self, option: ImageOptionStr) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n\n        Args:\n            option: option to check\n\n        Returns:\n            option\n        \"\"\"\n        if option not in IMAGE_OPTION:\n            raise InvalidParamError(option, IMAGE_OPTION)\n        return self.supportsOption(IMAGE_OPTION[option])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.get_option","title":"<code>get_option(option: ImageOptionStr) -&gt; datatypes.Variant</code>","text":"<p>Return the value assigned to option.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>ImageOptionStr</code> <p>option to get</p> required <p>Returns:</p> Type Description <code>datatypes.Variant</code> <p>option</p> Source code in <code>prettyqt\\gui\\imageiohandler.py</code> <pre><code>def get_option(self, option: ImageOptionStr) -&gt; datatypes.Variant:\n\"\"\"Return the value assigned to option.\n\n    Args:\n        option: option to get\n\n    Returns:\n        option\n    \"\"\"\n    if option not in IMAGE_OPTION:\n        raise InvalidParamError(option, IMAGE_OPTION)\n    return self.option(IMAGE_OPTION[option])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.set_option","title":"<code>set_option(option: ImageOptionStr, value: datatypes.Variant)</code>","text":"<p>Set option to given value.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>ImageOptionStr</code> <p>option to use</p> required <code>value</code> <code>datatypes.Variant</code> <p>value to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>option does not exist</p> Source code in <code>prettyqt\\gui\\imageiohandler.py</code> <pre><code>def set_option(self, option: ImageOptionStr, value: datatypes.Variant):\n\"\"\"Set option to given value.\n\n    Args:\n        option: option to use\n        value: value to set\n\n    Raises:\n        InvalidParamError: option does not exist\n    \"\"\"\n    if option not in IMAGE_OPTION:\n        raise InvalidParamError(option, IMAGE_OPTION)\n    self.setOption(IMAGE_OPTION[option], value)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.supports_option","title":"<code>supports_option(option: ImageOptionStr) -&gt; bool</code>","text":"<p>Return whether the image handler supports given option.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>ImageOptionStr</code> <p>option to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>option</p> Source code in <code>prettyqt\\gui\\imageiohandler.py</code> <pre><code>def supports_option(self, option: ImageOptionStr) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n\n    Args:\n        option: option to check\n\n    Returns:\n        option\n    \"\"\"\n    if option not in IMAGE_OPTION:\n        raise InvalidParamError(option, IMAGE_OPTION)\n    return self.supportsOption(IMAGE_OPTION[option])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.ImageReader","title":"<code>ImageReader</code>","text":"<p>         Bases: <code>QtGui.QImageReader</code></p> Source code in <code>prettyqt\\gui\\imagereader.py</code> <pre><code>class ImageReader(QtGui.QImageReader):\n    def __getitem__(self, key: str) -&gt; str:\n        return self.text(key)\n\n    def get_error(self) -&gt; ImageReaderErrorStr:\n\"\"\"Return error type.\n\n        Returns:\n            error type\n        \"\"\"\n        return IMAGE_READER_ERROR.inverse[self.error()]\n\n    def get_background_color(self) -&gt; gui.Color:\n        return gui.Color(self.backgroundColor())\n\n    def get_clip_rect(self) -&gt; core.Rect:\n        return core.Rect(self.clipRect())\n\n    def get_current_image_rect(self) -&gt; core.Rect:\n        return core.Rect(self.currentImageRect())\n\n    def get_scaled_clip_rect(self) -&gt; core.Rect:\n        return core.Rect(self.scaledClipRect())\n\n    def get_size(self) -&gt; core.Size:\n        return core.Size(self.size())\n\n    def get_scaled_size(self) -&gt; core.Size:\n        return core.Size(self.scaledSize())\n\n    def get_format(self) -&gt; str:\n        return self.format().data().decode()\n\n    def get_subtype(self) -&gt; str:\n        return self.subType().data().decode()\n\n    def get_supported_subtypes(self) -&gt; list[str]:\n        return [i.data().decode() for i in self.supportedSubTypes()]\n\n    def set_format(self, fmt: datatypes.ByteArrayType):\n        if isinstance(fmt, str):\n            fmt = fmt.encode()\n        if isinstance(fmt, bytes):\n            fmt = QtCore.QByteArray(fmt)\n        self.setFormat(fmt)\n\n    def get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n\n        Returns:\n            transformation\n        \"\"\"\n        return gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\n\n    def read_image(self) -&gt; gui.Image:\n        return gui.Image(self.read())\n\n    def supports_option(self, option: gui.imageiohandler.ImageOptionStr) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n\n        Args:\n            option: option to check\n\n        Returns:\n            option\n        \"\"\"\n        if option not in gui.imageiohandler.IMAGE_OPTION:\n            raise InvalidParamError(option, gui.imageiohandler.IMAGE_OPTION)\n        return self.supportsOption(gui.imageiohandler.IMAGE_OPTION[option])\n\n    @staticmethod\n    def get_image_format(obj: str | QtCore.QIODevice) -&gt; str:\n        return ImageReader.imageFormat(obj).data().decode()\n\n    @staticmethod\n    def get_supported_image_formats() -&gt; list[str]:\n        return [i.data().decode() for i in ImageReader.supportedImageFormats()]\n\n    @staticmethod\n    def get_supported_mime_types() -&gt; list[str]:\n        return [i.data().decode() for i in ImageReader.supportedMimeTypes()]\n\n    @staticmethod\n    def get_image_formats_for_mime_type(typ: datatypes.ByteArrayType) -&gt; list[str]:\n        if isinstance(typ, str):\n            typ = typ.encode()\n        if isinstance(typ, bytes):\n            typ = QtCore.QByteArray(typ)\n        return [i.data().decode() for i in ImageReader.imageFormatsForMimeType(typ)]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_error","title":"<code>get_error() -&gt; ImageReaderErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ImageReaderErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\gui\\imagereader.py</code> <pre><code>def get_error(self) -&gt; ImageReaderErrorStr:\n\"\"\"Return error type.\n\n    Returns:\n        error type\n    \"\"\"\n    return IMAGE_READER_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_transformation","title":"<code>get_transformation() -&gt; gui.imageiohandler.TransformationStr</code>","text":"<p>Return the transformation and orientation the image has been set to.</p> <p>Returns:</p> Type Description <code>gui.imageiohandler.TransformationStr</code> <p>transformation</p> Source code in <code>prettyqt\\gui\\imagereader.py</code> <pre><code>def get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n\n    Returns:\n        transformation\n    \"\"\"\n    return gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.supports_option","title":"<code>supports_option(option: gui.imageiohandler.ImageOptionStr) -&gt; bool</code>","text":"<p>Return whether the image handler supports given option.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>gui.imageiohandler.ImageOptionStr</code> <p>option to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>option</p> Source code in <code>prettyqt\\gui\\imagereader.py</code> <pre><code>def supports_option(self, option: gui.imageiohandler.ImageOptionStr) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n\n    Args:\n        option: option to check\n\n    Returns:\n        option\n    \"\"\"\n    if option not in gui.imageiohandler.IMAGE_OPTION:\n        raise InvalidParamError(option, gui.imageiohandler.IMAGE_OPTION)\n    return self.supportsOption(gui.imageiohandler.IMAGE_OPTION[option])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.ImageWriter","title":"<code>ImageWriter</code>","text":"<p>         Bases: <code>QtGui.QImageWriter</code></p> Source code in <code>prettyqt\\gui\\imagewriter.py</code> <pre><code>class ImageWriter(QtGui.QImageWriter):\n    def __setitem__(self, key: str, val: str):\n        self.setText(key, val)\n\n    def get_error(self) -&gt; ImageWriterErrorStr:\n\"\"\"Return error type.\n\n        Returns:\n            error type\n        \"\"\"\n        return IMAGE_WRITER_ERROR.inverse[self.error()]\n\n    def get_format(self) -&gt; str:\n        return self.format().data().decode()\n\n    def get_subtype(self) -&gt; str:\n        return self.subType().data().decode()\n\n    def get_supported_image_formats(self) -&gt; list[str]:\n        return [i.data().decode() for i in self.supportedImageFormats()]\n\n    def get_supported_subtypes(self) -&gt; list[str]:\n        return [i.data().decode() for i in self.supportedSubTypes()]\n\n    def set_subtype(self, subtype: datatypes.ByteArrayType):\n        if isinstance(subtype, str):\n            subtype = subtype.encode()\n        if isinstance(subtype, bytes):\n            subtype = QtCore.QByteArray(subtype)\n        self.setSubType(subtype)\n\n    def set_format(self, fmt: datatypes.ByteArrayType):\n        if isinstance(fmt, str):\n            fmt = fmt.encode()\n        if isinstance(fmt, bytes):\n            fmt = QtCore.QByteArray(fmt)\n        self.setFormat(fmt)\n\n    def set_transformation(self, origin: gui.imageiohandler.TransformationStr):\n\"\"\"Set the image transformations metadata including orientation.\n\n        Args:\n            origin: transformation to use\n\n        Raises:\n            InvalidParamError: transformation does not exist\n        \"\"\"\n        if origin not in gui.imageiohandler.TRANSFORMATION:\n            raise InvalidParamError(origin, gui.imageiohandler.TRANSFORMATION)\n        self.setTransformation(gui.imageiohandler.TRANSFORMATION[origin])\n\n    def get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n\n        Returns:\n            transformation\n        \"\"\"\n        return gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_error","title":"<code>get_error() -&gt; ImageWriterErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ImageWriterErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\gui\\imagewriter.py</code> <pre><code>def get_error(self) -&gt; ImageWriterErrorStr:\n\"\"\"Return error type.\n\n    Returns:\n        error type\n    \"\"\"\n    return IMAGE_WRITER_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_transformation","title":"<code>get_transformation() -&gt; gui.imageiohandler.TransformationStr</code>","text":"<p>Return the transformation and orientation the image has been set to.</p> <p>Returns:</p> Type Description <code>gui.imageiohandler.TransformationStr</code> <p>transformation</p> Source code in <code>prettyqt\\gui\\imagewriter.py</code> <pre><code>def get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n\n    Returns:\n        transformation\n    \"\"\"\n    return gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.set_transformation","title":"<code>set_transformation(origin: gui.imageiohandler.TransformationStr)</code>","text":"<p>Set the image transformations metadata including orientation.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>gui.imageiohandler.TransformationStr</code> <p>transformation to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>transformation does not exist</p> Source code in <code>prettyqt\\gui\\imagewriter.py</code> <pre><code>def set_transformation(self, origin: gui.imageiohandler.TransformationStr):\n\"\"\"Set the image transformations metadata including orientation.\n\n    Args:\n        origin: transformation to use\n\n    Raises:\n        InvalidParamError: transformation does not exist\n    \"\"\"\n    if origin not in gui.imageiohandler.TRANSFORMATION:\n        raise InvalidParamError(origin, gui.imageiohandler.TRANSFORMATION)\n    self.setTransformation(gui.imageiohandler.TRANSFORMATION[origin])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Movie","title":"<code>Movie</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtGui.QMovie</code></p> Source code in <code>prettyqt\\gui\\movie.py</code> <pre><code>class Movie(core.ObjectMixin, QtGui.QMovie):\n    def __repr__(self):\n        return get_repr(self, self.fileName(), self.get_format())\n\n    def serialize_fields(self):\n        return dict(\n            speed=self.speed(),\n            cache_mode=self.get_cache_mode(),\n            scaled_size=self.scaledSize(),\n            background_color=self.backgroundColor(),\n        )\n\n    def set_cache_mode(self, mode: CacheModeStr):\n\"\"\"Set cache mode.\n\n        Args:\n            mode: cache mode\n\n        Raises:\n            InvalidParamError: cache mode does not exist\n        \"\"\"\n        if mode not in CACHE_MODE:\n            raise InvalidParamError(mode, CACHE_MODE)\n        self.setCacheMode(CACHE_MODE[mode])\n\n    def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current cache mode.\n\n        Returns:\n            cache mode\n        \"\"\"\n        return CACHE_MODE.inverse[self.cacheMode()]\n\n    def get_state(self) -&gt; MovieStateStr:\n\"\"\"Get the current state.\n\n        Returns:\n            state\n        \"\"\"\n        return MOVIE_STATE.inverse[self.state()]\n\n    def get_format(self) -&gt; str:\n        return self.format().data().decode()\n\n    @classmethod\n    def get_supported_formats(cls) -&gt; list[str]:\n        return [i.data().decode() for i in cls.supportedFormats()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_cache_mode","title":"<code>get_cache_mode() -&gt; CacheModeStr</code>","text":"<p>Get the current cache mode.</p> <p>Returns:</p> Type Description <code>CacheModeStr</code> <p>cache mode</p> Source code in <code>prettyqt\\gui\\movie.py</code> <pre><code>def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current cache mode.\n\n    Returns:\n        cache mode\n    \"\"\"\n    return CACHE_MODE.inverse[self.cacheMode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_state","title":"<code>get_state() -&gt; MovieStateStr</code>","text":"<p>Get the current state.</p> <p>Returns:</p> Type Description <code>MovieStateStr</code> <p>state</p> Source code in <code>prettyqt\\gui\\movie.py</code> <pre><code>def get_state(self) -&gt; MovieStateStr:\n\"\"\"Get the current state.\n\n    Returns:\n        state\n    \"\"\"\n    return MOVIE_STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.set_cache_mode","title":"<code>set_cache_mode(mode: CacheModeStr)</code>","text":"<p>Set cache mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CacheModeStr</code> <p>cache mode</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>cache mode does not exist</p> Source code in <code>prettyqt\\gui\\movie.py</code> <pre><code>def set_cache_mode(self, mode: CacheModeStr):\n\"\"\"Set cache mode.\n\n    Args:\n        mode: cache mode\n\n    Raises:\n        InvalidParamError: cache mode does not exist\n    \"\"\"\n    if mode not in CACHE_MODE:\n        raise InvalidParamError(mode, CACHE_MODE)\n    self.setCacheMode(CACHE_MODE[mode])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PageLayout","title":"<code>PageLayout</code>","text":"<p>         Bases: <code>QtGui.QPageLayout</code></p> Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>class PageLayout(QtGui.QPageLayout):\n    def __repr__(self):\n        return get_repr(self)\n\n    def serialize_fields(self):\n        return dict(\n            margins=self.margins(),\n            minimum_margins=self.minimumMargins(),\n            mode=self.get_mode(),\n            orientation=self.get_orientation(),\n            page_size=self.get_page_size(),\n            units=self.get_units(),\n        )\n\n    def set_units(self, unit: UnitStr):\n\"\"\"Set unit.\n\n        Args:\n            unit: unit\n\n        Raises:\n            InvalidParamError: unit does not exist\n        \"\"\"\n        if unit not in UNITS:\n            raise InvalidParamError(unit, UNITS)\n        self.setUnits(UNITS[unit])\n\n    def get_units(self) -&gt; UnitStr:\n\"\"\"Get the current unit.\n\n        Returns:\n            unit\n        \"\"\"\n        return UNITS.inverse[self.units()]\n\n    def set_mode(self, mode: ModeStr):\n\"\"\"Set mode.\n\n        Args:\n            mode: mode\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in MODES:\n            raise InvalidParamError(mode, MODES)\n        self.setMode(MODES[mode])\n\n    def get_mode(self) -&gt; ModeStr:\n\"\"\"Get the current mode.\n\n        Returns:\n            mode\n        \"\"\"\n        return MODES.inverse[self.mode()]\n\n    def set_orientation(self, orientation: OrientationStr):\n\"\"\"Set orientation.\n\n        Args:\n            orientation: orientation\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in ORIENTATIONS:\n            raise InvalidParamError(orientation, ORIENTATIONS)\n        self.setOrientation(ORIENTATIONS[orientation])\n\n    def get_orientation(self) -&gt; OrientationStr:\n\"\"\"Get the current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return ORIENTATIONS.inverse[self.orientation()]\n\n    def get_page_size(self) -&gt; gui.PageSize:\n        return gui.PageSize(self.pageSize())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_mode","title":"<code>get_mode() -&gt; ModeStr</code>","text":"<p>Get the current mode.</p> <p>Returns:</p> Type Description <code>ModeStr</code> <p>mode</p> Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def get_mode(self) -&gt; ModeStr:\n\"\"\"Get the current mode.\n\n    Returns:\n        mode\n    \"\"\"\n    return MODES.inverse[self.mode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_orientation","title":"<code>get_orientation() -&gt; OrientationStr</code>","text":"<p>Get the current orientation.</p> <p>Returns:</p> Type Description <code>OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def get_orientation(self) -&gt; OrientationStr:\n\"\"\"Get the current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return ORIENTATIONS.inverse[self.orientation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_units","title":"<code>get_units() -&gt; UnitStr</code>","text":"<p>Get the current unit.</p> <p>Returns:</p> Type Description <code>UnitStr</code> <p>unit</p> Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def get_units(self) -&gt; UnitStr:\n\"\"\"Get the current unit.\n\n    Returns:\n        unit\n    \"\"\"\n    return UNITS.inverse[self.units()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_mode","title":"<code>set_mode(mode: ModeStr)</code>","text":"<p>Set mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ModeStr</code> <p>mode</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def set_mode(self, mode: ModeStr):\n\"\"\"Set mode.\n\n    Args:\n        mode: mode\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in MODES:\n        raise InvalidParamError(mode, MODES)\n    self.setMode(MODES[mode])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_orientation","title":"<code>set_orientation(orientation: OrientationStr)</code>","text":"<p>Set orientation.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>OrientationStr</code> <p>orientation</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def set_orientation(self, orientation: OrientationStr):\n\"\"\"Set orientation.\n\n    Args:\n        orientation: orientation\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in ORIENTATIONS:\n        raise InvalidParamError(orientation, ORIENTATIONS)\n    self.setOrientation(ORIENTATIONS[orientation])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_units","title":"<code>set_units(unit: UnitStr)</code>","text":"<p>Set unit.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>UnitStr</code> <p>unit</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>unit does not exist</p> Source code in <code>prettyqt\\gui\\pagelayout.py</code> <pre><code>def set_units(self, unit: UnitStr):\n\"\"\"Set unit.\n\n    Args:\n        unit: unit\n\n    Raises:\n        InvalidParamError: unit does not exist\n    \"\"\"\n    if unit not in UNITS:\n        raise InvalidParamError(unit, UNITS)\n    self.setUnits(UNITS[unit])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PageSize","title":"<code>PageSize</code>","text":"<p>         Bases: <code>QtGui.QPageSize</code></p> Source code in <code>prettyqt\\gui\\pagesize.py</code> <pre><code>class PageSize(QtGui.QPageSize):\n    def __repr__(self):\n        return get_repr(self, self.get_id())\n\n    def __reduce__(self):\n        return type(self), (self.id(),)\n\n    def get_definition_units(self) -&gt; UnitStr:\n\"\"\"Get the definition unit.\n\n        Returns:\n            unit\n        \"\"\"\n        units = self.definitionUnits()\n        if units.value == -1:\n            raise ValueError(\"Invalid page size\")\n        return UNITS.inverse[units]\n\n    def get_id(self) -&gt; str:\n\"\"\"Get the standard page size id.\n\n        Returns:\n            page size id\n        \"\"\"\n        return PAGE_SIZE_ID.inverse[self.id()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_definition_units","title":"<code>get_definition_units() -&gt; UnitStr</code>","text":"<p>Get the definition unit.</p> <p>Returns:</p> Type Description <code>UnitStr</code> <p>unit</p> Source code in <code>prettyqt\\gui\\pagesize.py</code> <pre><code>def get_definition_units(self) -&gt; UnitStr:\n\"\"\"Get the definition unit.\n\n    Returns:\n        unit\n    \"\"\"\n    units = self.definitionUnits()\n    if units.value == -1:\n        raise ValueError(\"Invalid page size\")\n    return UNITS.inverse[units]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_id","title":"<code>get_id() -&gt; str</code>","text":"<p>Get the standard page size id.</p> <p>Returns:</p> Type Description <code>str</code> <p>page size id</p> Source code in <code>prettyqt\\gui\\pagesize.py</code> <pre><code>def get_id(self) -&gt; str:\n\"\"\"Get the standard page size id.\n\n    Returns:\n        page size id\n    \"\"\"\n    return PAGE_SIZE_ID.inverse[self.id()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PaintDeviceMixin","title":"<code>PaintDeviceMixin</code>","text":"Source code in <code>prettyqt\\gui\\paintdevice.py</code> <pre><code>class PaintDeviceMixin:\n    def get_metric(self, metric: MetricStr) -&gt; int:\n\"\"\"Return metric information.\n\n        Args:\n            metric: metric information to get\n\n        Returns:\n            metric information\n        \"\"\"\n        if metric not in METRICS:\n            raise InvalidParamError(metric, METRICS)\n        return self.metric(METRICS[metric])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.paintdevice.PaintDeviceMixin.get_metric","title":"<code>get_metric(metric: MetricStr) -&gt; int</code>","text":"<p>Return metric information.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>MetricStr</code> <p>metric information to get</p> required <p>Returns:</p> Type Description <code>int</code> <p>metric information</p> Source code in <code>prettyqt\\gui\\paintdevice.py</code> <pre><code>def get_metric(self, metric: MetricStr) -&gt; int:\n\"\"\"Return metric information.\n\n    Args:\n        metric: metric information to get\n\n    Returns:\n        metric information\n    \"\"\"\n    if metric not in METRICS:\n        raise InvalidParamError(metric, METRICS)\n    return self.metric(METRICS[metric])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PainterMixin","title":"<code>PainterMixin</code>","text":"Source code in <code>prettyqt\\gui\\painter.py</code> <pre><code>class PainterMixin:\n    def __enter__(self):\n        return self\n\n    def __exit__(self, typ, value, traceback):\n        self.end()\n\n    @contextlib.contextmanager\n    def paint_on(self, obj) -&gt; Iterator[Painter]:\n        self.begin(obj)\n        yield self\n        self.end()\n\n    @contextlib.contextmanager\n    def backup_state(self) -&gt; Iterator[Painter]:\n        self.save()\n        yield self\n        self.restore()\n\n    @contextlib.contextmanager\n    def native_mode(self) -&gt; Iterator[Painter]:\n        self.beginNativePainting()\n        yield self\n        self.endNativePainting()\n\n    @contextlib.contextmanager\n    def edit_pen(self) -&gt; Iterator[gui.Pen]:\n        pen = gui.Pen(self.pen())\n        yield pen\n        self.setPen(pen)\n\n    @contextlib.contextmanager\n    def edit_font(self) -&gt; Iterator[gui.Font]:\n        font = gui.Font(self.font())\n        yield font\n        self.setFont(font)\n\n    def draw_text(\n        self,\n        position: datatypes.PointType | datatypes.RectType | datatypes.RectFType,\n        text: str,\n        alignment: constants.AlignmentStr = \"center\",\n    ):\n        match position:\n            case (_, _):\n                position = core.Point(*position)\n            case (_, _, _, _):\n                position = core.RectF(*position)\n        self.drawText(position, text, constants.ALIGNMENTS[alignment])\n\n    def draw_image(\n        self,\n        target: QtCore.QPoint | QtCore.QPointF | QtCore.QRect | QtCore.QRectF,\n        frame_buffer: QtGui.QImage,\n    ):\n        self.set_composition_mode(\"source_atop\")\n        self.drawImage(target, frame_buffer)\n\n    def draw_polygon(\n        self,\n        points: (\n            QtGui.QPolygon | QtGui.QPolygonF | list[QtCore.QPoint] | list[QtCore.QPointF]\n        ),\n        fill_rule: constants.FillRuleStr = \"odd_even\",\n    ):\n        if fill_rule not in constants.FILL_RULE:\n            raise InvalidParamError(fill_rule, constants.FILL_RULE)\n        self.drawPolygon(points, fillRule=constants.FILL_RULE[fill_rule])  # type: ignore\n\n    def draw_rounded_rect(\n        self,\n        rect: datatypes.RectType | datatypes.RectFType,\n        x_radius: float,\n        y_radius: float,\n        relative: bool = False,\n    ):\n        flag = (\n            QtCore.Qt.SizeMode.RelativeSize\n            if relative\n            else QtCore.Qt.SizeMode.AbsoluteSize\n        )\n        if isinstance(rect, tuple):\n            rect = QtCore.QRectF(*rect)\n        self.drawRoundedRect(rect, x_radius, y_radius, flag)\n\n    def use_antialiasing(self):\n        self.setRenderHint(self.RenderHint.Antialiasing, True)\n\n    def fill_rect(\n        self,\n        rect: datatypes.RectType | datatypes.RectFType,\n        color: datatypes.ColorType,\n        pattern: constants.BrushStyleStr = \"solid\",\n    ):\n        if pattern not in constants.BRUSH_STYLE:\n            raise InvalidParamError(pattern, constants.BRUSH_STYLE)\n        if isinstance(rect, tuple):\n            rect = core.RectF(*rect)\n        color = colors.get_color(color)\n        if pattern != \"solid\":\n            color = gui.Brush(color, constants.BRUSH_STYLE[pattern])\n        self.fillRect(rect, color)\n\n    def set_pen(\n        self,\n        style: constants.PenStyleStr | None = \"solid\",\n        width: float = 1.0,\n        color: datatypes.ColorType = \"black\",\n        brush: QtGui.QBrush | None = None,\n        miter_limit: float = 2.0,\n        join_style: constants.JoinStyleStr = \"bevel\",\n        cap_style: constants.CapStyleStr = \"square\",\n    ) -&gt; gui.Pen:\n\"\"\"Set pen to use.\n\n        Args:\n            style: pen style\n            width: pen width\n            color: pen color\n            brush: pen brush\n            miter_limit: miter limit\n            join_style: pen join style\n            cap_style: pen cap style\n        \"\"\"\n        pen = gui.Pen()\n        pen.set_style(style)\n        if style in [\"none\", None]:\n            self.setPen(pen)\n            return pen\n        pen.set_cap_style(cap_style)\n        pen.set_join_style(join_style)\n        pen.setMiterLimit(miter_limit)\n        pen.setWidthF(width)\n        if brush is not None:\n            pen.setBrush(brush)\n        pen.set_color(color)\n        self.setPen(pen)\n        return pen\n\n    def get_pen(self) -&gt; gui.Pen:\n\"\"\"Return current pen.\n\n        Returns:\n            current pen\n        \"\"\"\n        return gui.Pen(self.pen())\n\n    def set_color(self, color: datatypes.ColorType):\n        color = colors.get_color(color)\n        self.setPen(color)\n\n    def set_brush(self, brush: QtGui.QBrush | datatypes.ColorType):\n        if not isinstance(brush, QtGui.QBrush):\n            brush = colors.get_color(brush)\n        self.setBrush(brush)\n\n    def set_transparent_background(self, transparent: bool = True):\n        mode = (\n            QtCore.Qt.BGMode.TransparentMode\n            if transparent\n            else QtCore.Qt.BGMode.OpaqueMode\n        )\n        self.setBackgroundMode(mode)\n\n    def set_composition_mode(self, mode: CompositionModeStr):\n\"\"\"Set the current composition mode.\n\n        Raises:\n            InvalidParamError: composition mode does not exist\n        \"\"\"\n        if mode not in COMPOSITION_MODE:\n            raise InvalidParamError(mode, COMPOSITION_MODE)\n        self.setCompositionMode(COMPOSITION_MODE[mode])\n\n    def get_composition_mode(self) -&gt; CompositionModeStr:\n\"\"\"Get the current composition mode.\n\n        Returns:\n            composition mode\n        \"\"\"\n        return COMPOSITION_MODE.inverse[self.compositionMode()]\n\n    def set_transform(self, transform: datatypes.TransformType, combine: bool = False):\n        if isinstance(transform, tuple):\n            transform = gui.Transform(*transform)\n        self.setTransform(transform, combine)\n\n    def get_font_metrics(self) -&gt; gui.FontMetrics:\n        return gui.FontMetrics(self.fontMetrics())\n\n    def set_clip_path(\n        self, path: QtGui.QPainterPath, operation: constants.ClipOperationStr = \"replace\"\n    ):\n        if operation not in constants.CLIP_OPERATION:\n            raise InvalidParamError(operation, constants.CLIP_OPERATION)\n        self.setClipPath(path, constants.CLIP_OPERATION[operation])\n\n    def get_text_rect(self, text: str) -&gt; core.Rect:\n        return self.drawText(\n            core.Rect(), QtCore.Qt.TextFlag.TextDontPrint, text\n        )  # type: ignore\n\n    @contextlib.contextmanager\n    def clip_path(\n        self, operation: constants.ClipOperationStr = \"replace\"\n    ) -&gt; Iterator[gui.PainterPath]:\n        path = gui.PainterPath()\n        yield path\n        self.set_clip_path(path, operation)\n\n    @contextlib.contextmanager\n    def apply_transform(self, combine: bool = True) -&gt; Iterator[gui.Transform]:\n        transform = gui.Transform()\n        yield transform\n        self.setTransform(transform, combine)\n\n    @contextlib.contextmanager\n    def offset_by(self, x: int = 0, y: int = 0) -&gt; Iterator[Painter]:\n        self.translate(x, y)\n        yield self\n        self.translate(-x, -y)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.get_composition_mode","title":"<code>get_composition_mode() -&gt; CompositionModeStr</code>","text":"<p>Get the current composition mode.</p> <p>Returns:</p> Type Description <code>CompositionModeStr</code> <p>composition mode</p> Source code in <code>prettyqt\\gui\\painter.py</code> <pre><code>def get_composition_mode(self) -&gt; CompositionModeStr:\n\"\"\"Get the current composition mode.\n\n    Returns:\n        composition mode\n    \"\"\"\n    return COMPOSITION_MODE.inverse[self.compositionMode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.get_pen","title":"<code>get_pen() -&gt; gui.Pen</code>","text":"<p>Return current pen.</p> <p>Returns:</p> Type Description <code>gui.Pen</code> <p>current pen</p> Source code in <code>prettyqt\\gui\\painter.py</code> <pre><code>def get_pen(self) -&gt; gui.Pen:\n\"\"\"Return current pen.\n\n    Returns:\n        current pen\n    \"\"\"\n    return gui.Pen(self.pen())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.set_composition_mode","title":"<code>set_composition_mode(mode: CompositionModeStr)</code>","text":"<p>Set the current composition mode.</p> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>composition mode does not exist</p> Source code in <code>prettyqt\\gui\\painter.py</code> <pre><code>def set_composition_mode(self, mode: CompositionModeStr):\n\"\"\"Set the current composition mode.\n\n    Raises:\n        InvalidParamError: composition mode does not exist\n    \"\"\"\n    if mode not in COMPOSITION_MODE:\n        raise InvalidParamError(mode, COMPOSITION_MODE)\n    self.setCompositionMode(COMPOSITION_MODE[mode])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.set_pen","title":"<code>set_pen(style: constants.PenStyleStr | None = 'solid', width: float = 1.0, color: datatypes.ColorType = 'black', brush: QtGui.QBrush | None = None, miter_limit: float = 2.0, join_style: constants.JoinStyleStr = 'bevel', cap_style: constants.CapStyleStr = 'square') -&gt; gui.Pen</code>","text":"<p>Set pen to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.PenStyleStr | None</code> <p>pen style</p> <code>'solid'</code> <code>width</code> <code>float</code> <p>pen width</p> <code>1.0</code> <code>color</code> <code>datatypes.ColorType</code> <p>pen color</p> <code>'black'</code> <code>brush</code> <code>QtGui.QBrush | None</code> <p>pen brush</p> <code>None</code> <code>miter_limit</code> <code>float</code> <p>miter limit</p> <code>2.0</code> <code>join_style</code> <code>constants.JoinStyleStr</code> <p>pen join style</p> <code>'bevel'</code> <code>cap_style</code> <code>constants.CapStyleStr</code> <p>pen cap style</p> <code>'square'</code> Source code in <code>prettyqt\\gui\\painter.py</code> <pre><code>def set_pen(\n    self,\n    style: constants.PenStyleStr | None = \"solid\",\n    width: float = 1.0,\n    color: datatypes.ColorType = \"black\",\n    brush: QtGui.QBrush | None = None,\n    miter_limit: float = 2.0,\n    join_style: constants.JoinStyleStr = \"bevel\",\n    cap_style: constants.CapStyleStr = \"square\",\n) -&gt; gui.Pen:\n\"\"\"Set pen to use.\n\n    Args:\n        style: pen style\n        width: pen width\n        color: pen color\n        brush: pen brush\n        miter_limit: miter limit\n        join_style: pen join style\n        cap_style: pen cap style\n    \"\"\"\n    pen = gui.Pen()\n    pen.set_style(style)\n    if style in [\"none\", None]:\n        self.setPen(pen)\n        return pen\n    pen.set_cap_style(cap_style)\n    pen.set_join_style(join_style)\n    pen.setMiterLimit(miter_limit)\n    pen.setWidthF(width)\n    if brush is not None:\n        pen.setBrush(brush)\n    pen.set_color(color)\n    self.setPen(pen)\n    return pen\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PainterPath","title":"<code>PainterPath</code>","text":"<p>         Bases: <code>QtGui.QPainterPath</code></p> Source code in <code>prettyqt\\gui\\painterpath.py</code> <pre><code>class PainterPath(QtGui.QPainterPath):\n    def serialize_fields(self):\n        return dict(fill_rule=self.get_fill_rule(), elements=list(self))\n\n    def __len__(self):\n        return self.elementCount()\n\n    def __getitem__(self, index: int) -&gt; QtGui.QPainterPath.Element:\n        return self.elementAt(index)\n\n    def __iter__(self) -&gt; Iterator[QtGui.QPainterPath.Element]:\n        return iter(self.elementAt(i) for i in range(self.elementCount()))\n\n    def __setitem__(self, index: int, value: tuple[int, int]):\n        self.setElementPositionAt(index, *value)\n\n    def __bool__(self):\n        return not self.isEmpty()\n\n    def __contains__(self, item: QtCore.QPointF | QtCore.QRectF | QtGui.QPainterPath):\n        return self.contains(item)\n\n    def add_rect(self, rect: datatypes.RectType | datatypes.RectFType):\n        if isinstance(rect, QtCore.QRect):\n            rect = QtCore.QRectF(rect)\n        elif isinstance(rect, tuple):\n            rect = QtCore.QRectF(*rect)\n        self.addRect(rect)\n\n    def set_fill_rule(self, rule: constants.FillRuleStr):\n\"\"\"Set fill rule.\n\n        Args:\n            rule: fill rule to use\n\n        Raises:\n            InvalidParamError: fill rule does not exist\n        \"\"\"\n        if rule not in constants.FILL_RULE:\n            raise InvalidParamError(rule, constants.FILL_RULE)\n        self.setFillRule(constants.FILL_RULE[rule])\n\n    def get_fill_rule(self) -&gt; constants.FillRuleStr:\n\"\"\"Return current fill rule.\n\n        Returns:\n            fill rule\n        \"\"\"\n        return constants.FILL_RULE.inverse[self.fillRule()]\n\n    def get_bounding_rect(self) -&gt; core.RectF:\n        return core.RectF(self.boundingRect())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.get_fill_rule","title":"<code>get_fill_rule() -&gt; constants.FillRuleStr</code>","text":"<p>Return current fill rule.</p> <p>Returns:</p> Type Description <code>constants.FillRuleStr</code> <p>fill rule</p> Source code in <code>prettyqt\\gui\\painterpath.py</code> <pre><code>def get_fill_rule(self) -&gt; constants.FillRuleStr:\n\"\"\"Return current fill rule.\n\n    Returns:\n        fill rule\n    \"\"\"\n    return constants.FILL_RULE.inverse[self.fillRule()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.set_fill_rule","title":"<code>set_fill_rule(rule: constants.FillRuleStr)</code>","text":"<p>Set fill rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>constants.FillRuleStr</code> <p>fill rule to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>fill rule does not exist</p> Source code in <code>prettyqt\\gui\\painterpath.py</code> <pre><code>def set_fill_rule(self, rule: constants.FillRuleStr):\n\"\"\"Set fill rule.\n\n    Args:\n        rule: fill rule to use\n\n    Raises:\n        InvalidParamError: fill rule does not exist\n    \"\"\"\n    if rule not in constants.FILL_RULE:\n        raise InvalidParamError(rule, constants.FILL_RULE)\n    self.setFillRule(constants.FILL_RULE[rule])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PainterPathStroker","title":"<code>PainterPathStroker</code>","text":"<p>         Bases: <code>QtGui.QPainterPathStroker</code></p> Source code in <code>prettyqt\\gui\\painterpathstroker.py</code> <pre><code>class PainterPathStroker(QtGui.QPainterPathStroker):\n    def set_cap_style(self, style: constants.CapStyleStr):\n\"\"\"Set cap style to use.\n\n        Args:\n            style: cap style to use\n\n        Raises:\n            InvalidParamError: cap style does not exist\n        \"\"\"\n        if style not in constants.CAP_STYLE:\n            raise InvalidParamError(style, constants.CAP_STYLE)\n        self.setCapStyle(constants.CAP_STYLE[style])\n\n    def get_cap_style(self) -&gt; constants.CapStyleStr:\n\"\"\"Return current cap style.\n\n        Returns:\n            cap style\n        \"\"\"\n        return constants.CAP_STYLE.inverse[self.capStyle()]\n\n    def set_join_style(self, style: constants.JoinStyleStr):\n\"\"\"Set join style to use.\n\n        Args:\n            style: join style to use\n\n        Raises:\n            InvalidParamError: join style does not exist\n        \"\"\"\n        if style not in constants.JOIN_STYLE:\n            raise InvalidParamError(style, constants.JOIN_STYLE)\n        self.setJoinStyle(constants.JOIN_STYLE[style])\n\n    def get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n\n        Returns:\n            join style\n        \"\"\"\n        return constants.JOIN_STYLE.inverse[self.joinStyle()]\n\n    def create_stroke(self, path: QtGui.QPainterPath) -&gt; gui.PainterPath:\n        return gui.PainterPath(self.createStroke(path))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_cap_style","title":"<code>get_cap_style() -&gt; constants.CapStyleStr</code>","text":"<p>Return current cap style.</p> <p>Returns:</p> Type Description <code>constants.CapStyleStr</code> <p>cap style</p> Source code in <code>prettyqt\\gui\\painterpathstroker.py</code> <pre><code>def get_cap_style(self) -&gt; constants.CapStyleStr:\n\"\"\"Return current cap style.\n\n    Returns:\n        cap style\n    \"\"\"\n    return constants.CAP_STYLE.inverse[self.capStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_join_style","title":"<code>get_join_style() -&gt; constants.JoinStyleStr</code>","text":"<p>Return current join style.</p> <p>Returns:</p> Type Description <code>constants.JoinStyleStr</code> <p>join style</p> Source code in <code>prettyqt\\gui\\painterpathstroker.py</code> <pre><code>def get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n\n    Returns:\n        join style\n    \"\"\"\n    return constants.JOIN_STYLE.inverse[self.joinStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_cap_style","title":"<code>set_cap_style(style: constants.CapStyleStr)</code>","text":"<p>Set cap style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.CapStyleStr</code> <p>cap style to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>cap style does not exist</p> Source code in <code>prettyqt\\gui\\painterpathstroker.py</code> <pre><code>def set_cap_style(self, style: constants.CapStyleStr):\n\"\"\"Set cap style to use.\n\n    Args:\n        style: cap style to use\n\n    Raises:\n        InvalidParamError: cap style does not exist\n    \"\"\"\n    if style not in constants.CAP_STYLE:\n        raise InvalidParamError(style, constants.CAP_STYLE)\n    self.setCapStyle(constants.CAP_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_join_style","title":"<code>set_join_style(style: constants.JoinStyleStr)</code>","text":"<p>Set join style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.JoinStyleStr</code> <p>join style to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>join style does not exist</p> Source code in <code>prettyqt\\gui\\painterpathstroker.py</code> <pre><code>def set_join_style(self, style: constants.JoinStyleStr):\n\"\"\"Set join style to use.\n\n    Args:\n        style: join style to use\n\n    Raises:\n        InvalidParamError: join style does not exist\n    \"\"\"\n    if style not in constants.JOIN_STYLE:\n        raise InvalidParamError(style, constants.JOIN_STYLE)\n    self.setJoinStyle(constants.JOIN_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Palette","title":"<code>Palette</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QPalette</code></p> Source code in <code>prettyqt\\gui\\palette.py</code> <pre><code>class Palette(serializemixin.SerializeMixin, QtGui.QPalette):\n    def __getitem__(self, index: RoleStr) -&gt; gui.Color:\n        return self.get_color(index)\n\n    def __setitem__(self, index: RoleStr, value: datatypes.ColorType):\n        self.set_color(index, value)\n\n    def __repr__(self):\n        return get_repr(self, self.get_color(\"button\"), self.get_color(\"window\"))\n\n    def highlight_inactive(self):\n        color = self.color(self.ColorGroup.Active, self.ColorRole.Highlight)\n        self.setColor(self.ColorGroup.Inactive, self.ColorRole.Highlight, color)\n\n    def set_color(\n        self, role: RoleStr, color: datatypes.ColorType, group: GroupStr = \"active\"\n    ):\n        color = colors.get_color(color)\n        self.setColor(GROUP[group], ROLE[role], color)\n\n    def get_colors(self, group: GroupStr = \"active\") -&gt; dict[str, gui.Color]:\n        return {k: self.get_color(k, group) for k in ROLE}\n\n    def get_color(self, role: RoleStr, group: GroupStr = \"active\") -&gt; gui.Color:\n        return gui.Color(self.color(GROUP[group], ROLE[role]))\n\n    def set_brush(\n        self,\n        role: RoleStr,\n        brush: datatypes.ColorAndBrushType,\n        group: GroupStr = \"active\",\n    ):\n        if not isinstance(brush, QtGui.QBrush):\n            brush = gui.Brush(colors.get_color(brush))\n        self.setBrush(GROUP[group], ROLE[role], brush)\n\n    def get_brushes(self, group: GroupStr = \"active\") -&gt; dict[str, gui.Brush]:\n        return {k: self.get_brush(k, group) for k in ROLE}\n\n    def get_brush(self, role: RoleStr, group: GroupStr = \"active\") -&gt; gui.Brush:\n        return gui.Brush(self.brush(GROUP[group], ROLE[role]))\n\n    def set_color_group(self, group: GroupStr, **kwargs: QtGui.QBrush):\n\"\"\"Set the color group.\n\n        Args:\n            group: color group to use\n            kwargs: keyword arguments passed to setColorGroup\n\n        Raises:\n            InvalidParamError: invalid color group\n        \"\"\"\n        if group not in GROUP:\n            raise InvalidParamError(group, GROUP)\n        self.setColorGroup(GROUP[group], **kwargs)\n\n    def get_color_group(self) -&gt; GroupStr:\n\"\"\"Return color group.\n\n        Returns:\n            color group\n        \"\"\"\n        return GROUP.inverse[self.colorGroup()]\n\n    def inverted(self) -&gt; Palette:\n        pal = Palette()\n        for group in GROUP:\n            for role in ROLE:\n                color = self.get_color(role, group)\n                pal.set_color(role, color.inverted(), group)\n        return pal\n\n    @classmethod\n    def create_dark_palette(cls) -&gt; Palette:\n        pal = cls()\n        pal.set_color(\"window\", gui.Color(53, 53, 53))\n        pal.set_color(\"window_text\", \"white\")\n        pal.set_color(\"window_text\", \"grey\", group=\"disabled\")\n        pal.set_color(\"base\", gui.Color(25, 25, 25))\n        pal.set_color(\"alternate_base\", gui.Color(53, 53, 53))\n        pal.set_color(\"tool_tip_base\", \"slategrey\")\n        pal.set_color(\"tool_tip_base\", \"slategrey\", group=\"inactive\")\n        pal.set_color(\"tool_tip_text\", \"white\")\n        pal.set_color(\"tool_tip_text\", \"white\", group=\"inactive\")\n        pal.set_color(\"text\", \"white\")\n        pal.set_color(\"text\", \"grey\", group=\"disabled\")\n        pal.set_color(\"button\", gui.Color(53, 53, 53))\n        pal.set_color(\"button_text\", \"white\")\n        pal.set_color(\"button_text\", \"grey\", group=\"disabled\")\n        pal.set_color(\"bright_text\", \"red\")\n        pal.set_color(\"link\", \"dodgerblue\")\n        pal.set_color(\"highlight\", \"dodgerblue\")\n        pal.set_color(\"highlight\", gui.Color(80, 80, 80), group=\"disabled\")\n        pal.set_color(\"highlighted_text\", \"black\")\n        pal.set_color(\"highlighted_text\", \"grey\", group=\"disabled\")\n        return pal\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.palette.Palette.get_color_group","title":"<code>get_color_group() -&gt; GroupStr</code>","text":"<p>Return color group.</p> <p>Returns:</p> Type Description <code>GroupStr</code> <p>color group</p> Source code in <code>prettyqt\\gui\\palette.py</code> <pre><code>def get_color_group(self) -&gt; GroupStr:\n\"\"\"Return color group.\n\n    Returns:\n        color group\n    \"\"\"\n    return GROUP.inverse[self.colorGroup()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.palette.Palette.set_color_group","title":"<code>set_color_group(group: GroupStr, **kwargs: QtGui.QBrush)</code>","text":"<p>Set the color group.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>GroupStr</code> <p>color group to use</p> required <code>kwargs</code> <code>QtGui.QBrush</code> <p>keyword arguments passed to setColorGroup</p> <code>{}</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid color group</p> Source code in <code>prettyqt\\gui\\palette.py</code> <pre><code>def set_color_group(self, group: GroupStr, **kwargs: QtGui.QBrush):\n\"\"\"Set the color group.\n\n    Args:\n        group: color group to use\n        kwargs: keyword arguments passed to setColorGroup\n\n    Raises:\n        InvalidParamError: invalid color group\n    \"\"\"\n    if group not in GROUP:\n        raise InvalidParamError(group, GROUP)\n    self.setColorGroup(GROUP[group], **kwargs)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.Pen","title":"<code>Pen</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QPen</code></p> Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>class Pen(serializemixin.SerializeMixin, QtGui.QPen):\n    def __repr__(self):\n        return get_repr(self, self.get_color())\n\n    def set_color(self, color: datatypes.ColorType):\n        color = colors.get_color(color)\n        self.setColor(color)\n\n    def get_color(self) -&gt; gui.Color:\n        return gui.Color(self.color())\n\n    def get_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.brush())\n\n    def set_cap_style(self, style: constants.CapStyleStr):\n\"\"\"Set cap style to use.\n\n        Args:\n            style: cap style to use\n\n        Raises:\n            InvalidParamError: cap style does not exist\n        \"\"\"\n        if style not in constants.CAP_STYLE:\n            raise InvalidParamError(style, constants.CAP_STYLE)\n        self.setCapStyle(constants.CAP_STYLE[style])\n\n    def get_cap_style(self) -&gt; constants.CapStyleStr:\n\"\"\"Return current cap style.\n\n        Returns:\n            cap style\n        \"\"\"\n        return constants.CAP_STYLE.inverse[self.capStyle()]\n\n    def set_join_style(self, style: constants.JoinStyleStr):\n\"\"\"Set join style to use.\n\n        Args:\n            style: join style to use\n\n        Raises:\n            InvalidParamError: join style does not exist\n        \"\"\"\n        if style not in constants.JOIN_STYLE:\n            raise InvalidParamError(style, constants.JOIN_STYLE)\n        self.setJoinStyle(constants.JOIN_STYLE[style])\n\n    def get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n\n        Returns:\n            join style\n        \"\"\"\n        return constants.JOIN_STYLE.inverse[self.joinStyle()]\n\n    def set_style(self, style: constants.PenStyleStr | list[float] | None):\n\"\"\"Set pen style to use.\n\n        Args:\n            style: pen style to use\n\n        Raises:\n            InvalidParamError: pen style does not exist\n        \"\"\"\n        if isinstance(style, list):\n            self.setDashPattern(style)\n        else:\n            if style is None:\n                style = \"none\"\n            if style not in constants.PEN_STYLE:\n                raise InvalidParamError(style, constants.PEN_STYLE)\n            self.setStyle(constants.PEN_STYLE[style])\n\n    def get_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return current pen style.\n\n        Returns:\n            pen style\n        \"\"\"\n        return constants.PEN_STYLE.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_cap_style","title":"<code>get_cap_style() -&gt; constants.CapStyleStr</code>","text":"<p>Return current cap style.</p> <p>Returns:</p> Type Description <code>constants.CapStyleStr</code> <p>cap style</p> Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def get_cap_style(self) -&gt; constants.CapStyleStr:\n\"\"\"Return current cap style.\n\n    Returns:\n        cap style\n    \"\"\"\n    return constants.CAP_STYLE.inverse[self.capStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_join_style","title":"<code>get_join_style() -&gt; constants.JoinStyleStr</code>","text":"<p>Return current join style.</p> <p>Returns:</p> Type Description <code>constants.JoinStyleStr</code> <p>join style</p> Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n\n    Returns:\n        join style\n    \"\"\"\n    return constants.JOIN_STYLE.inverse[self.joinStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_style","title":"<code>get_style() -&gt; constants.PenStyleStr</code>","text":"<p>Return current pen style.</p> <p>Returns:</p> Type Description <code>constants.PenStyleStr</code> <p>pen style</p> Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def get_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return current pen style.\n\n    Returns:\n        pen style\n    \"\"\"\n    return constants.PEN_STYLE.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_cap_style","title":"<code>set_cap_style(style: constants.CapStyleStr)</code>","text":"<p>Set cap style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.CapStyleStr</code> <p>cap style to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>cap style does not exist</p> Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def set_cap_style(self, style: constants.CapStyleStr):\n\"\"\"Set cap style to use.\n\n    Args:\n        style: cap style to use\n\n    Raises:\n        InvalidParamError: cap style does not exist\n    \"\"\"\n    if style not in constants.CAP_STYLE:\n        raise InvalidParamError(style, constants.CAP_STYLE)\n    self.setCapStyle(constants.CAP_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_join_style","title":"<code>set_join_style(style: constants.JoinStyleStr)</code>","text":"<p>Set join style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.JoinStyleStr</code> <p>join style to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>join style does not exist</p> Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def set_join_style(self, style: constants.JoinStyleStr):\n\"\"\"Set join style to use.\n\n    Args:\n        style: join style to use\n\n    Raises:\n        InvalidParamError: join style does not exist\n    \"\"\"\n    if style not in constants.JOIN_STYLE:\n        raise InvalidParamError(style, constants.JOIN_STYLE)\n    self.setJoinStyle(constants.JOIN_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_style","title":"<code>set_style(style: constants.PenStyleStr | list[float] | None)</code>","text":"<p>Set pen style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.PenStyleStr | list[float] | None</code> <p>pen style to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>pen style does not exist</p> Source code in <code>prettyqt\\gui\\pen.py</code> <pre><code>def set_style(self, style: constants.PenStyleStr | list[float] | None):\n\"\"\"Set pen style to use.\n\n    Args:\n        style: pen style to use\n\n    Raises:\n        InvalidParamError: pen style does not exist\n    \"\"\"\n    if isinstance(style, list):\n        self.setDashPattern(style)\n    else:\n        if style is None:\n            style = \"none\"\n        if style not in constants.PEN_STYLE:\n            raise InvalidParamError(style, constants.PEN_STYLE)\n        self.setStyle(constants.PEN_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.PixmapMixin","title":"<code>PixmapMixin</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>gui.PaintDeviceMixin</code></p> Source code in <code>prettyqt\\gui\\pixmap.py</code> <pre><code>class PixmapMixin(serializemixin.SerializeMixin, gui.PaintDeviceMixin):\n    def __bool__(self):\n        return not self.isNull()\n\n    def __eq__(self, other):\n        return self.toImage() == other.toImage() if isinstance(other, Pixmap) else False\n\n    def __hash__(self):\n        return self.cacheKey()\n\n    @classmethod\n    def from_file(cls, path: datatypes.PathType) -&gt; Pixmap:\n        path = pathlib.Path(path)\n        with path.open(mode=\"rb\") as f:\n            data = f.read()\n        # Create widget\n        pixmap = cls()\n        pixmap.loadFromData(QtCore.QByteArray(data))\n        return pixmap\n\n    @classmethod\n    def from_image(\n        cls,\n        img: QtGui.QImage,\n        color_preference: constants.ColorPreferenceStr = \"auto\",\n        dithering: constants.DitherPreferenceStr = \"diffuse\",\n        alpha_dithering: constants.AlphaDitherPreferenceStr = \"threshold\",\n        mode_preference: constants.ModePreferenceStr = \"auto\",\n    ) -&gt; Pixmap:\n        flag = QtCore.Qt.ImageConversionFlag(0)\n        flag |= constants.COLOR_PREFERENCE.inverse[color_preference]\n        flag |= constants.DITHER_PREFERENCE.inverse[dithering]\n        flag |= constants.ALPHA_DITHER_PREFERENCE.inverse[alpha_dithering]\n        flag |= constants.MODE_PREFERENCE.inverse[mode_preference]\n        return cls(cls.fromImage(img, flag))\n\n    def get_size(self) -&gt; core.Size:\n        return core.Size(self.size())\n\n    def get_rect(self) -&gt; core.Rect:\n        return core.Rect(self.rect())\n\n    def to_image(self) -&gt; gui.Image:\n        return gui.Image(self.toImage())\n\n    def rotated(self, rotation: int) -&gt; Pixmap:\n        w, h = self.width(), self.height()\n        pixmap = self.transformed(gui.Transform().rotate(rotation))\n        return pixmap.copy((pixmap.width() - w) // 2, (pixmap.height() - h) // 2, w, h)\n\n    def get_image_data_url(self) -&gt; str:\n\"\"\"Render the contents of the pixmap as a data URL (RFC-2397).\n\n        Returns:\n            datauri : str\n        \"\"\"\n        device = core.Buffer()\n        assert device.open_file(\"read_write\")\n        self.save(device, b\"png\")\n        device.close()\n        data = bytes(device.data())\n        payload = base64.b64encode(data).decode(\"ascii\")\n        return f\"data:image/png;base64,{payload}\"\n\n    @classmethod\n    def create_dot(cls, color: datatypes.ColorType = \"black\", size: int = 16) -&gt; Pixmap:\n        col = colors.get_color(color)\n        px = cls(size, size)\n        px.fill(QtCore.Qt.GlobalColor.transparent)  # type: ignore\n        px_size = px.rect().adjusted(1, 1, -1, -1)\n        with gui.Painter(px) as painter:\n            painter.use_antialiasing()\n            painter.setBrush(col)\n            pen_color = gui.Color(15, 15, 15)\n            painter.set_pen(color=pen_color, width=1)\n            painter.drawEllipse(px_size)\n        return px\n\n    @classmethod\n    def create_checkerboard_pattern(\n        cls, n: int, color_1: datatypes.ColorType, color_2: datatypes.ColorType\n    ):\n\"\"\"Construct tileable checkerboard pattern for paint events.\"\"\"\n        # Brush will be an nxn checkerboard pattern\n        pat = gui.Pixmap(2 * n, 2 * n)\n        bg0 = colors.get_color(color_1)\n        bg1 = colors.get_color(color_2)\n        with gui.Painter(pat) as p:\n            p.setPen(QtCore.Qt.PenStyle.NoPen)\n            # Paint a checkerboard pattern for the color to be overlaid on\n            p.fillRect(pat.rect(), bg0)\n            p.fillRect(0, 0, n, n, bg1)\n            p.fillRect(n, n, 2 * n, 2 * n, bg1)\n        return pat\n\n    @classmethod\n    def create_char(\n        cls,\n        char: str,\n        size: int,\n        background: datatypes.ColorType = \"black\",\n        color: datatypes.ColorType = \"white\",\n    ):\n        pixmap = cls(size, size)\n        pixmap.fill(QtCore.Qt.GlobalColor.transparent)\n        with gui.Painter(pixmap) as painter:\n            painter.setRenderHints(\n                painter.RenderHint.Antialiasing\n                | painter.RenderHint.TextAntialiasing\n                | painter.RenderHint.SmoothPixmapTransform\n            )\n            painter.set_pen(color=background)\n            painter.set_brush(background)\n            margin = 1 + size // 16\n            text_margin = size // 20\n            w = size - 2 * margin\n            rect = core.Rect(margin, margin, w, w)\n            painter.draw_rounded_rect(rect, 30, 30, relative=True)\n            painter.set_pen(color=color)\n            with painter.edit_font() as font:  # type: QtGui.QFont\n                font.setPixelSize(size - 2 * margin - 2 * text_margin)\n            painter.draw_text(rect, char, alignment=\"center\")\n        return pixmap\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pixmap.PixmapMixin.create_checkerboard_pattern","title":"<code>create_checkerboard_pattern(n: int, color_1: datatypes.ColorType, color_2: datatypes.ColorType)</code>  <code>classmethod</code>","text":"<p>Construct tileable checkerboard pattern for paint events.</p> Source code in <code>prettyqt\\gui\\pixmap.py</code> <pre><code>@classmethod\ndef create_checkerboard_pattern(\n    cls, n: int, color_1: datatypes.ColorType, color_2: datatypes.ColorType\n):\n\"\"\"Construct tileable checkerboard pattern for paint events.\"\"\"\n    # Brush will be an nxn checkerboard pattern\n    pat = gui.Pixmap(2 * n, 2 * n)\n    bg0 = colors.get_color(color_1)\n    bg1 = colors.get_color(color_2)\n    with gui.Painter(pat) as p:\n        p.setPen(QtCore.Qt.PenStyle.NoPen)\n        # Paint a checkerboard pattern for the color to be overlaid on\n        p.fillRect(pat.rect(), bg0)\n        p.fillRect(0, 0, n, n, bg1)\n        p.fillRect(n, n, 2 * n, 2 * n, bg1)\n    return pat\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pixmap.PixmapMixin.get_image_data_url","title":"<code>get_image_data_url() -&gt; str</code>","text":"<p>Render the contents of the pixmap as a data URL (RFC-2397).</p> <p>Returns:</p> Name Type Description <code>datauri</code> <code>str</code> <p>str</p> Source code in <code>prettyqt\\gui\\pixmap.py</code> <pre><code>def get_image_data_url(self) -&gt; str:\n\"\"\"Render the contents of the pixmap as a data URL (RFC-2397).\n\n    Returns:\n        datauri : str\n    \"\"\"\n    device = core.Buffer()\n    assert device.open_file(\"read_write\")\n    self.save(device, b\"png\")\n    device.close()\n    data = bytes(device.data())\n    payload = base64.b64encode(data).decode(\"ascii\")\n    return f\"data:image/png;base64,{payload}\"\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.SessionManager","title":"<code>SessionManager</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\gui\\sessionmanager.py</code> <pre><code>class SessionManager(core.ObjectMixin):\n    def __init__(self, item: QtGui.QSessionManager):\n        self.item = item\n\n    def __getattr__(self, val):\n        return getattr(self.item, val)\n\n    def set_restart_hint(self, style: RestartHintStr):\n\"\"\"Set the restart hint.\n\n        Args:\n            style: restart hint\n\n        Raises:\n            InvalidParamError: restart hint does not exist\n        \"\"\"\n        if style not in RESTART_HINT:\n            raise InvalidParamError(style, RESTART_HINT)\n        self.setRestartHint(RESTART_HINT[style])\n\n    def get_restart_hint(self) -&gt; RestartHintStr:\n\"\"\"Return current restart hint.\n\n        Returns:\n            restart hint\n        \"\"\"\n        return RESTART_HINT.inverse[self.restartHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.get_restart_hint","title":"<code>get_restart_hint() -&gt; RestartHintStr</code>","text":"<p>Return current restart hint.</p> <p>Returns:</p> Type Description <code>RestartHintStr</code> <p>restart hint</p> Source code in <code>prettyqt\\gui\\sessionmanager.py</code> <pre><code>def get_restart_hint(self) -&gt; RestartHintStr:\n\"\"\"Return current restart hint.\n\n    Returns:\n        restart hint\n    \"\"\"\n    return RESTART_HINT.inverse[self.restartHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.set_restart_hint","title":"<code>set_restart_hint(style: RestartHintStr)</code>","text":"<p>Set the restart hint.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>RestartHintStr</code> <p>restart hint</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>restart hint does not exist</p> Source code in <code>prettyqt\\gui\\sessionmanager.py</code> <pre><code>def set_restart_hint(self, style: RestartHintStr):\n\"\"\"Set the restart hint.\n\n    Args:\n        style: restart hint\n\n    Raises:\n        InvalidParamError: restart hint does not exist\n    \"\"\"\n    if style not in RESTART_HINT:\n        raise InvalidParamError(style, RESTART_HINT)\n    self.setRestartHint(RESTART_HINT[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.StandardItem","title":"<code>StandardItem</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtGui.QStandardItem</code></p> Source code in <code>prettyqt\\gui\\standarditem.py</code> <pre><code>class StandardItem(serializemixin.SerializeMixin, QtGui.QStandardItem):\n    def __repr__(self):\n        return get_repr(self, self.get_icon(), self.text())\n\n    def serialize_fields(self):\n        return dict(\n            text=self.text(),\n            tool_tip=self.toolTip(),\n            status_tip=self.statusTip(),\n            icon=self.get_icon(),\n            data=self.data(),\n        )\n\n    def __getitem__(\n        self, index: int | tuple[int, int] | QtCore.QModelIndex\n    ) -&gt; QtGui.QStandardItem:\n        match index:\n            case int():\n                return self.child(index)\n            case tuple():\n                return self.child(*index)\n            case _:\n                raise KeyError(index)\n\n    def __delitem__(self, index: int | tuple[int, int]):\n        item = self.takeRow(index) if isinstance(index, int) else self.takeChild(*index)\n        if item is None:\n            raise KeyError(index)\n        return item\n\n    def __iter__(self) -&gt; Iterator[QtGui.QStandardItem]:\n        return iter(self.get_children())\n\n    def __add__(self, other: str | QtGui.QStandardItem) -&gt; StandardItem:\n        if isinstance(other, QtGui.QStandardItem | str):\n            self.add(other)\n            return self\n        raise TypeError(\"wrong type for addition\")\n\n    def get_children(self) -&gt; list[QtGui.QStandardItem]:\n        return [self.child(index) for index in range(self.rowCount())]\n\n    def add(self, *item: str | QtGui.QStandardItem):\n        for i in item:\n            if isinstance(i, str):\n                i = gui.StandardItem(i)\n            self.appendRow([i])\n\n    def clone(self):\n        item = type(self)()\n        core.DataStream.copy_data(self, item)\n        assert type(item) == StandardItem\n        return item\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n        Args:\n            state: checkstate to use\n\n        Raises:\n            InvalidParamError: invalid checkstate\n        \"\"\"\n        if state not in constants.STATE:\n            raise InvalidParamError(state, constants.STATE)\n        self.setCheckState(constants.STATE[state])\n\n    def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n        Returns:\n            checkstate\n        \"\"\"\n        return constants.STATE.inverse[self.checkState()]\n\n    def get_background(self) -&gt; gui.Brush:\n        return gui.Brush(self.background())\n\n    def get_foreground(self) -&gt; gui.Brush:\n        return gui.Brush(self.foreground())\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        return None if icon.isNull() else gui.Icon(icon)\n\n    def set_tooltip(\n        self,\n        tooltip: str | datatypes.PathType,\n        size: datatypes.SizeType | None = None,\n    ):\n        if isinstance(tooltip, os.PathLike):\n            path = os.fspath(tooltip)\n            if size is None:\n                tooltip = f\"&lt;img src={path!r}&gt;\"\n            else:\n                if isinstance(size, QtCore.QSize):\n                    size = (size.width(), size.height())\n                tooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\n        self.setToolTip(tooltip)\n\n    def set_size_hint(self, hint: datatypes.SizeType):\n        if isinstance(hint, tuple):\n            hint = QtCore.QSize(*hint)\n        self.setSizeHint(hint)\n\n    def add_item(\n        self,\n        name: str = \"\",\n        icon: datatypes.IconType = None,\n        data: dict | None = None,\n        foreground: QtGui.QBrush | None = None,\n        background: QtGui.QBrush | None = None,\n        font: QtGui.QFont | None = None,\n        selectable: bool = True,\n        enabled: bool = True,\n        editable: bool = False,\n        status_tip: str | None = None,\n        tool_tip: str | None = None,\n        whats_this: str | None = None,\n        # text_alignment: Optional[str] = None,\n        checkstate: constants.StateStr | None = None,\n        flags: QtCore.Qt.ItemFlag | None = None,\n        size_hint: datatypes.SizeType | None = None,\n        is_user_type: bool = False,\n    ) -&gt; StandardItem:\n        item = StandardItem(name)\n        if icon is not None:\n            icon = iconprovider.get_icon(icon)\n            item.setIcon(icon)\n        if data is not None:\n            for k, v in data.items():\n                item.setData(v, k)\n        if foreground is not None:\n            item.setForeground(foreground)\n        if background is not None:\n            item.setBackground(background)\n        if font is not None:\n            item.setFont(font)\n        if flags is not None:\n            item.setFlags(flags)\n        if enabled:\n            item.setEnabled(enabled)\n        if editable:\n            item.setEditable(editable)\n        if selectable:\n            item.setSelectable(selectable)\n        if status_tip:\n            item.setStatusTip(status_tip)\n        if tool_tip:\n            item.setToolTip(tool_tip)\n        if whats_this:\n            item.setWhatsThis(whats_this)\n        if size_hint is not None:\n            item.set_size_hint(size_hint)\n        if checkstate is not None:\n            item.set_checkstate(checkstate)\n        self.appendRow([item])\n        return item\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.get_checkstate","title":"<code>get_checkstate() -&gt; constants.StateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.StateStr</code> <p>checkstate</p> Source code in <code>prettyqt\\gui\\standarditem.py</code> <pre><code>def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n    Returns:\n        checkstate\n    \"\"\"\n    return constants.STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_checkstate","title":"<code>set_checkstate(state: constants.StateStr)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.StateStr</code> <p>checkstate to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid checkstate</p> Source code in <code>prettyqt\\gui\\standarditem.py</code> <pre><code>def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n    Args:\n        state: checkstate to use\n\n    Raises:\n        InvalidParamError: invalid checkstate\n    \"\"\"\n    if state not in constants.STATE:\n        raise InvalidParamError(state, constants.STATE)\n    self.setCheckState(constants.STATE[state])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\gui\\standarditem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.StaticText","title":"<code>StaticText</code>","text":"<p>         Bases: <code>QtGui.QStaticText</code></p> Source code in <code>prettyqt\\gui\\statictext.py</code> <pre><code>class StaticText(QtGui.QStaticText):\n    def __repr__(self):\n        return get_repr(self, self.text())\n\n    def __str__(self):\n        return self.text()\n\n    def get_size(self) -&gt; core.SizeF:\n        return core.SizeF(self.size())\n\n    def set_text_format(self, text_format: str):\n\"\"\"Set the text format.\n\n        Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"\n\n        Args:\n            text_format: text format to use\n\n        Raises:\n            InvalidParamError: text format does not exist\n        \"\"\"\n        if text_format not in TEXT_FORMAT:\n            raise InvalidParamError(text_format, TEXT_FORMAT)\n        self.setTextFormat(TEXT_FORMAT[text_format])\n\n    def get_text_format(self) -&gt; str:\n\"\"\"Return current text format.\n\n        Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"\n\n        Returns:\n            text format\n        \"\"\"\n        return TEXT_FORMAT.inverse[self.textFormat()]\n\n    def set_performance_hint(self, hint: PerformanceHintStr):\n\"\"\"Set the performance hint.\n\n        Args:\n            hint: performance hint to use\n\n        Raises:\n            InvalidParamError: performance hint does not exist\n        \"\"\"\n        if hint not in PERFORMANCE_HINT:\n            raise InvalidParamError(hint, PERFORMANCE_HINT)\n        self.setPerformanceHint(PERFORMANCE_HINT[hint])\n\n    def get_performance_hint(self) -&gt; PerformanceHintStr:\n\"\"\"Return current performance hint.\n\n        Returns:\n            performance hint\n        \"\"\"\n        return PERFORMANCE_HINT.inverse[self.performanceHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_performance_hint","title":"<code>get_performance_hint() -&gt; PerformanceHintStr</code>","text":"<p>Return current performance hint.</p> <p>Returns:</p> Type Description <code>PerformanceHintStr</code> <p>performance hint</p> Source code in <code>prettyqt\\gui\\statictext.py</code> <pre><code>def get_performance_hint(self) -&gt; PerformanceHintStr:\n\"\"\"Return current performance hint.\n\n    Returns:\n        performance hint\n    \"\"\"\n    return PERFORMANCE_HINT.inverse[self.performanceHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_text_format","title":"<code>get_text_format() -&gt; str</code>","text":"<p>Return current text format.</p> <p>Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"</p> <p>Returns:</p> Type Description <code>str</code> <p>text format</p> Source code in <code>prettyqt\\gui\\statictext.py</code> <pre><code>def get_text_format(self) -&gt; str:\n\"\"\"Return current text format.\n\n    Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"\n\n    Returns:\n        text format\n    \"\"\"\n    return TEXT_FORMAT.inverse[self.textFormat()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_performance_hint","title":"<code>set_performance_hint(hint: PerformanceHintStr)</code>","text":"<p>Set the performance hint.</p> <p>Parameters:</p> Name Type Description Default <code>hint</code> <code>PerformanceHintStr</code> <p>performance hint to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>performance hint does not exist</p> Source code in <code>prettyqt\\gui\\statictext.py</code> <pre><code>def set_performance_hint(self, hint: PerformanceHintStr):\n\"\"\"Set the performance hint.\n\n    Args:\n        hint: performance hint to use\n\n    Raises:\n        InvalidParamError: performance hint does not exist\n    \"\"\"\n    if hint not in PERFORMANCE_HINT:\n        raise InvalidParamError(hint, PERFORMANCE_HINT)\n    self.setPerformanceHint(PERFORMANCE_HINT[hint])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_text_format","title":"<code>set_text_format(text_format: str)</code>","text":"<p>Set the text format.</p> <p>Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"</p> <p>Parameters:</p> Name Type Description Default <code>text_format</code> <code>str</code> <p>text format to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>text format does not exist</p> Source code in <code>prettyqt\\gui\\statictext.py</code> <pre><code>def set_text_format(self, text_format: str):\n\"\"\"Set the text format.\n\n    Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"\n\n    Args:\n        text_format: text format to use\n\n    Raises:\n        InvalidParamError: text format does not exist\n    \"\"\"\n    if text_format not in TEXT_FORMAT:\n        raise InvalidParamError(text_format, TEXT_FORMAT)\n    self.setTextFormat(TEXT_FORMAT[text_format])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.SurfaceMixin","title":"<code>SurfaceMixin</code>","text":"Source code in <code>prettyqt\\gui\\surface.py</code> <pre><code>class SurfaceMixin:\n    def __repr__(self):\n        return get_repr(self)\n\n    def get_surface_class(self) -&gt; SurfaceClassStr:\n\"\"\"Get the current surface class.\n\n        Returns:\n            surface class\n        \"\"\"\n        return SURFACE_CLASS.inverse[self.surfaceClass()]\n\n    def get_surface_type(self) -&gt; SurfaceTypeStr:\n\"\"\"Get the current surface type.\n\n        Returns:\n            surface type\n        \"\"\"\n        return SURFACE_TYPES.inverse[self.surfaceType()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.surface.SurfaceMixin.get_surface_class","title":"<code>get_surface_class() -&gt; SurfaceClassStr</code>","text":"<p>Get the current surface class.</p> <p>Returns:</p> Type Description <code>SurfaceClassStr</code> <p>surface class</p> Source code in <code>prettyqt\\gui\\surface.py</code> <pre><code>def get_surface_class(self) -&gt; SurfaceClassStr:\n\"\"\"Get the current surface class.\n\n    Returns:\n        surface class\n    \"\"\"\n    return SURFACE_CLASS.inverse[self.surfaceClass()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.surface.SurfaceMixin.get_surface_type","title":"<code>get_surface_type() -&gt; SurfaceTypeStr</code>","text":"<p>Get the current surface type.</p> <p>Returns:</p> Type Description <code>SurfaceTypeStr</code> <p>surface type</p> Source code in <code>prettyqt\\gui\\surface.py</code> <pre><code>def get_surface_type(self) -&gt; SurfaceTypeStr:\n\"\"\"Get the current surface type.\n\n    Returns:\n        surface type\n    \"\"\"\n    return SURFACE_TYPES.inverse[self.surfaceType()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextBlock","title":"<code>TextBlock</code>","text":"<p>         Bases: <code>QtGui.QTextBlock</code></p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>class TextBlock(QtGui.QTextBlock):\n    def __repr__(self):\n        return get_repr(self, self.text())\n\n    def __contains__(self, position: int):\n        return self.contains(position)\n\n    def __bool__(self):\n        return self.isValid()\n\n    def __str__(self):\n        return self.text()\n\n    def get_previous(self) -&gt; TextBlock:\n        return TextBlock(self.previous())\n\n    def get_next(self) -&gt; TextBlock:\n        return TextBlock(self.next())\n\n    def get_text_direction(self) -&gt; constants.LayoutDirectionStr:\n        return constants.LAYOUT_DIRECTION.inverse[self.textDirection()]\n\n    def set_user_data(self, data):\n        if isinstance(data, QtGui.QTextBlockUserData):\n            self.setUserData(data)\n            return None\n        user_data = UserData(data)\n        self.setUserData(user_data)\n\n    def get_user_data(self):\n        user_data = self.userData()\n        return user_data.data if isinstance(user_data, UserData) else user_data\n\n    @contextlib.contextmanager\n    def edit_user_state(self):\n        state = self.userState()\n        yield state\n        self.setUserState(state)\n\n    def get_state(self) -&gt; int:\n\"\"\"Get the user state, generally used for syntax highlighting.\n\n        :return: The block state\n        \"\"\"\n        state = self.userState()\n        return state if state == -1 else state &amp; 0x0000FFFF\n\n    def set_state(self, state: int):\n\"\"\"Set the user state, generally used for syntax highlighting.\n\n        :param state: new state value.\n        \"\"\"\n        user_state = self.userState()\n        if user_state == -1:\n            user_state = 0\n        higher_part = user_state &amp; 0x7FFF0000\n        state &amp;= 0x0000FFFF\n        state |= higher_part\n        self.setUserState(state)\n\n    def get_fold_level(self) -&gt; int:\n\"\"\"Get the block fold level.\n\n        :return: The block fold level\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        return (state &amp; 0x03FF0000) &gt;&gt; 16\n\n    def set_fold_level(self, val: int):\n\"\"\"Set the block fold level.\n\n        :param val: The new fold level [0-7]\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        val = min(val, 0x3FF)\n        state &amp;= 0x7C00FFFF\n        state |= val &lt;&lt; 16\n        self.setUserState(state)\n\n    def is_fold_trigger(self) -&gt; bool:\n\"\"\"Check if the block is a fold trigger.\n\n        :return: True if the block is a fold trigger (represented as a node in\n            the fold panel)\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        return bool(state &amp; 0x04000000)\n\n    def set_fold_trigger(self, val: int):\n\"\"\"Set the block fold trigger flag (True means the block is a fold trigger).\n\n        :param val: value to set\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        state &amp;= 0x7BFFFFFF\n        state |= val &lt;&lt; 26\n        self.setUserState(state)\n\n    def is_collapsed(self) -&gt; bool:\n\"\"\"Check if the block is expanded or collased.\n\n        :return: False for an open trigger, True for for closed trigger\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        return bool(state &amp; 0x08000000)\n\n    def set_collapsed(self, val: int):\n\"\"\"Set the fold trigger state (collapsed or expanded).\n\n        :param val: The new trigger state (True=collapsed, False=expanded)\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        state &amp;= 0x77FFFFFF\n        state |= val &lt;&lt; 27\n        self.setUserState(state)\n\n    def find_parent_scope(self, limit: int = 5000) -&gt; TextBlock | None:\n\"\"\"Find parent scope, if the block is not a fold trigger.\"\"\"\n        # if we moved up for more than n lines, just give up otherwise this\n        # would take too much time.\n        counter = 0\n        original = TextBlock(self)\n        start = TextBlock(self)\n        if not self.is_fold_trigger():\n            # search level of next non blank line\n            while start.text().strip() == \"\" and start.isValid():\n                start = start.next()\n            ref_level = self.get_fold_level() - 1\n            start = original\n            while (\n                start.blockNumber()\n                and counter &lt; limit\n                and (not self.is_fold_trigger() or self.get_fold_level() &gt; ref_level)\n            ):\n                counter += 1\n                start = start.previous()\n        return TextBlock(start) if counter &lt; limit else None\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.find_parent_scope","title":"<code>find_parent_scope(limit: int = 5000) -&gt; TextBlock | None</code>","text":"<p>Find parent scope, if the block is not a fold trigger.</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def find_parent_scope(self, limit: int = 5000) -&gt; TextBlock | None:\n\"\"\"Find parent scope, if the block is not a fold trigger.\"\"\"\n    # if we moved up for more than n lines, just give up otherwise this\n    # would take too much time.\n    counter = 0\n    original = TextBlock(self)\n    start = TextBlock(self)\n    if not self.is_fold_trigger():\n        # search level of next non blank line\n        while start.text().strip() == \"\" and start.isValid():\n            start = start.next()\n        ref_level = self.get_fold_level() - 1\n        start = original\n        while (\n            start.blockNumber()\n            and counter &lt; limit\n            and (not self.is_fold_trigger() or self.get_fold_level() &gt; ref_level)\n        ):\n            counter += 1\n            start = start.previous()\n    return TextBlock(start) if counter &lt; limit else None\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.get_fold_level","title":"<code>get_fold_level() -&gt; int</code>","text":"<p>Get the block fold level.</p> <p>:return: The block fold level</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def get_fold_level(self) -&gt; int:\n\"\"\"Get the block fold level.\n\n    :return: The block fold level\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    return (state &amp; 0x03FF0000) &gt;&gt; 16\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.get_state","title":"<code>get_state() -&gt; int</code>","text":"<p>Get the user state, generally used for syntax highlighting.</p> <p>:return: The block state</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def get_state(self) -&gt; int:\n\"\"\"Get the user state, generally used for syntax highlighting.\n\n    :return: The block state\n    \"\"\"\n    state = self.userState()\n    return state if state == -1 else state &amp; 0x0000FFFF\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.is_collapsed","title":"<code>is_collapsed() -&gt; bool</code>","text":"<p>Check if the block is expanded or collased.</p> <p>:return: False for an open trigger, True for for closed trigger</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def is_collapsed(self) -&gt; bool:\n\"\"\"Check if the block is expanded or collased.\n\n    :return: False for an open trigger, True for for closed trigger\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    return bool(state &amp; 0x08000000)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.is_fold_trigger","title":"<code>is_fold_trigger() -&gt; bool</code>","text":"<p>Check if the block is a fold trigger.</p> <p>:return: True if the block is a fold trigger (represented as a node in     the fold panel)</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def is_fold_trigger(self) -&gt; bool:\n\"\"\"Check if the block is a fold trigger.\n\n    :return: True if the block is a fold trigger (represented as a node in\n        the fold panel)\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    return bool(state &amp; 0x04000000)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_collapsed","title":"<code>set_collapsed(val: int)</code>","text":"<p>Set the fold trigger state (collapsed or expanded).</p> <p>:param val: The new trigger state (True=collapsed, False=expanded)</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def set_collapsed(self, val: int):\n\"\"\"Set the fold trigger state (collapsed or expanded).\n\n    :param val: The new trigger state (True=collapsed, False=expanded)\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    state &amp;= 0x77FFFFFF\n    state |= val &lt;&lt; 27\n    self.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_fold_level","title":"<code>set_fold_level(val: int)</code>","text":"<p>Set the block fold level.</p> <p>:param val: The new fold level [0-7]</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def set_fold_level(self, val: int):\n\"\"\"Set the block fold level.\n\n    :param val: The new fold level [0-7]\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    val = min(val, 0x3FF)\n    state &amp;= 0x7C00FFFF\n    state |= val &lt;&lt; 16\n    self.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_fold_trigger","title":"<code>set_fold_trigger(val: int)</code>","text":"<p>Set the block fold trigger flag (True means the block is a fold trigger).</p> <p>:param val: value to set</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def set_fold_trigger(self, val: int):\n\"\"\"Set the block fold trigger flag (True means the block is a fold trigger).\n\n    :param val: value to set\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    state &amp;= 0x7BFFFFFF\n    state |= val &lt;&lt; 26\n    self.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_state","title":"<code>set_state(state: int)</code>","text":"<p>Set the user state, generally used for syntax highlighting.</p> <p>:param state: new state value.</p> Source code in <code>prettyqt\\gui\\textblock.py</code> <pre><code>def set_state(self, state: int):\n\"\"\"Set the user state, generally used for syntax highlighting.\n\n    :param state: new state value.\n    \"\"\"\n    user_state = self.userState()\n    if user_state == -1:\n        user_state = 0\n    higher_part = user_state &amp; 0x7FFF0000\n    state &amp;= 0x0000FFFF\n    state |= higher_part\n    self.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextBlockUserData","title":"<code>TextBlockUserData</code>","text":"<p>         Bases: <code>QtGui.QTextBlockUserData</code></p> <p>Storage for the user data associated with each line.</p> Source code in <code>prettyqt\\gui\\textblockuserdata.py</code> <pre><code>class TextBlockUserData(QtGui.QTextBlockUserData):\n\"\"\"Storage for the user data associated with each line.\"\"\"\n\n    def __init__(self, **kwds):\n        for key, value in kwds.items():\n            setattr(self, key, value)\n        super().__init__()\n\n    def __repr__(self):\n        kwargs = {i: getattr(self, i) for i in dir(self) if not i.startswith(\"__\")}\n        return get_repr(self, **kwargs)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextCharFormatMixin","title":"<code>TextCharFormatMixin</code>","text":"<p>         Bases: <code>gui.TextFormatMixin</code></p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>class TextCharFormatMixin(gui.TextFormatMixin):\n    def __init__(\n        self,\n        text_color: datatypes.ColorType | QtGui.QBrush = None,\n        bold: bool = False,\n        italic: bool = False,\n    ):\n        super().__init__()\n        if text_color is not None:\n            self.set_foreground_color(text_color)\n        if bold:\n            self.set_font_weight(\"bold\")\n        self.setFontItalic(italic)\n\n    def set_foreground_color(self, color: datatypes.ColorType | QtGui.QBrush):\n        if not isinstance(color, QtGui.QBrush):\n            color = colors.get_color(color)\n        self.setForeground(color)\n\n    def set_background_color(self, color: datatypes.ColorType | QtGui.QBrush):\n        if not isinstance(color, QtGui.QBrush):\n            color = colors.get_color(color)\n        self.setBackground(color)\n\n    def set_font_weight(self, weight: gui.font.WeightStr):\n\"\"\"Set the font weight.\n\n        Args:\n            weight: font weight\n\n        Raises:\n            InvalidParamError: invalid font weight\n        \"\"\"\n        if weight not in gui.font.WEIGHT:\n            raise InvalidParamError(weight, gui.font.WEIGHT)\n        self.setFontWeight(gui.font.WEIGHT[weight])\n\n    def get_font_weight(self) -&gt; gui.font.WeightStr:\n\"\"\"Get current font weight.\n\n        Returns:\n            current font weight\n        \"\"\"\n        return gui.font.WEIGHT.inverse[self.fontWeight()]\n\n    def set_underline_style(self, style: UnderlineStyleStr):\n\"\"\"Set the underline style.\n\n        Args:\n            style: underline style\n\n        Raises:\n            InvalidParamError: invalid underline style\n        \"\"\"\n        if style not in UNDERLINE_STYLE:\n            raise InvalidParamError(style, UNDERLINE_STYLE)\n        self.setUnderlineStyle(UNDERLINE_STYLE[style])\n\n    def get_underline_style(self) -&gt; UnderlineStyleStr:\n\"\"\"Get current underline style.\n\n        Returns:\n            current underline style\n        \"\"\"\n        return UNDERLINE_STYLE.inverse[self.underlineStyle()]\n\n    def set_vertical_alignment(self, alignment: VerticalAlignmentStr):\n\"\"\"Set the vertical alignment.\n\n        Args:\n            alignment: vertical alignment\n\n        Raises:\n            InvalidParamError: invalid vertical alignment\n        \"\"\"\n        if alignment not in VERTICAL_ALIGNMENT:\n            raise InvalidParamError(alignment, VERTICAL_ALIGNMENT)\n        self.setVerticalAlignment(VERTICAL_ALIGNMENT[alignment])\n\n    def get_vertical_alignment(self) -&gt; VerticalAlignmentStr:\n\"\"\"Get current vertical alignment.\n\n        Returns:\n            current vertical alignment\n        \"\"\"\n        return VERTICAL_ALIGNMENT.inverse[self.verticalAlignment()]\n\n    def set_font_style_hint(self, hint: gui.font.StyleHintStr):\n\"\"\"Set the font style hint.\n\n        Args:\n            hint: font style hint\n\n        Raises:\n            InvalidParamError: invalid font style hint\n        \"\"\"\n        if hint not in gui.font.STYLE_HINTS:\n            raise InvalidParamError(hint, gui.font.STYLE_HINTS)\n        self.setFontStyleHint(gui.font.STYLE_HINTS[hint])\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.get_font_weight","title":"<code>get_font_weight() -&gt; gui.font.WeightStr</code>","text":"<p>Get current font weight.</p> <p>Returns:</p> Type Description <code>gui.font.WeightStr</code> <p>current font weight</p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def get_font_weight(self) -&gt; gui.font.WeightStr:\n\"\"\"Get current font weight.\n\n    Returns:\n        current font weight\n    \"\"\"\n    return gui.font.WEIGHT.inverse[self.fontWeight()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.get_underline_style","title":"<code>get_underline_style() -&gt; UnderlineStyleStr</code>","text":"<p>Get current underline style.</p> <p>Returns:</p> Type Description <code>UnderlineStyleStr</code> <p>current underline style</p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def get_underline_style(self) -&gt; UnderlineStyleStr:\n\"\"\"Get current underline style.\n\n    Returns:\n        current underline style\n    \"\"\"\n    return UNDERLINE_STYLE.inverse[self.underlineStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.get_vertical_alignment","title":"<code>get_vertical_alignment() -&gt; VerticalAlignmentStr</code>","text":"<p>Get current vertical alignment.</p> <p>Returns:</p> Type Description <code>VerticalAlignmentStr</code> <p>current vertical alignment</p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def get_vertical_alignment(self) -&gt; VerticalAlignmentStr:\n\"\"\"Get current vertical alignment.\n\n    Returns:\n        current vertical alignment\n    \"\"\"\n    return VERTICAL_ALIGNMENT.inverse[self.verticalAlignment()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_font_style_hint","title":"<code>set_font_style_hint(hint: gui.font.StyleHintStr)</code>","text":"<p>Set the font style hint.</p> <p>Parameters:</p> Name Type Description Default <code>hint</code> <code>gui.font.StyleHintStr</code> <p>font style hint</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid font style hint</p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def set_font_style_hint(self, hint: gui.font.StyleHintStr):\n\"\"\"Set the font style hint.\n\n    Args:\n        hint: font style hint\n\n    Raises:\n        InvalidParamError: invalid font style hint\n    \"\"\"\n    if hint not in gui.font.STYLE_HINTS:\n        raise InvalidParamError(hint, gui.font.STYLE_HINTS)\n    self.setFontStyleHint(gui.font.STYLE_HINTS[hint])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_font_weight","title":"<code>set_font_weight(weight: gui.font.WeightStr)</code>","text":"<p>Set the font weight.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>gui.font.WeightStr</code> <p>font weight</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid font weight</p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def set_font_weight(self, weight: gui.font.WeightStr):\n\"\"\"Set the font weight.\n\n    Args:\n        weight: font weight\n\n    Raises:\n        InvalidParamError: invalid font weight\n    \"\"\"\n    if weight not in gui.font.WEIGHT:\n        raise InvalidParamError(weight, gui.font.WEIGHT)\n    self.setFontWeight(gui.font.WEIGHT[weight])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_underline_style","title":"<code>set_underline_style(style: UnderlineStyleStr)</code>","text":"<p>Set the underline style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>UnderlineStyleStr</code> <p>underline style</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid underline style</p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def set_underline_style(self, style: UnderlineStyleStr):\n\"\"\"Set the underline style.\n\n    Args:\n        style: underline style\n\n    Raises:\n        InvalidParamError: invalid underline style\n    \"\"\"\n    if style not in UNDERLINE_STYLE:\n        raise InvalidParamError(style, UNDERLINE_STYLE)\n    self.setUnderlineStyle(UNDERLINE_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_vertical_alignment","title":"<code>set_vertical_alignment(alignment: VerticalAlignmentStr)</code>","text":"<p>Set the vertical alignment.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>VerticalAlignmentStr</code> <p>vertical alignment</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid vertical alignment</p> Source code in <code>prettyqt\\gui\\textcharformat.py</code> <pre><code>def set_vertical_alignment(self, alignment: VerticalAlignmentStr):\n\"\"\"Set the vertical alignment.\n\n    Args:\n        alignment: vertical alignment\n\n    Raises:\n        InvalidParamError: invalid vertical alignment\n    \"\"\"\n    if alignment not in VERTICAL_ALIGNMENT:\n        raise InvalidParamError(alignment, VERTICAL_ALIGNMENT)\n    self.setVerticalAlignment(VERTICAL_ALIGNMENT[alignment])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextCursor","title":"<code>TextCursor</code>","text":"<p>         Bases: <code>QtGui.QTextCursor</code></p> Source code in <code>prettyqt\\gui\\textcursor.py</code> <pre><code>class TextCursor(QtGui.QTextCursor):\n    def __str__(self):\n        return self.selectedText().replace(\"\\u2029\", \"\\n\")\n\n    def move_position(\n        self, operation: MoveOperationStr, mode: MoveModeStr = \"move\", n: int = 1\n    ) -&gt; bool:\n        return self.movePosition(MOVE_OPERATION[operation], MOVE_MODE[mode], n)\n\n    def set_position(self, pos: int, mode: MoveModeStr = \"move\"):\n\"\"\"Set cursor to given position.\n\n        Args:\n            pos: Cursor position\n            mode: Move mode\n        \"\"\"\n        self.setPosition(pos, MOVE_MODE[mode])\n\n    def select(self, selection: SelectionTypeStr | QtGui.QTextCursor.SelectionType):\n        if isinstance(selection, QtGui.QTextCursor.SelectionType):\n            sel = selection\n        else:\n            sel = SELECTION_TYPE[selection]\n        super().select(sel)\n\n    def span(self) -&gt; tuple[int, int]:\n        return (self.anchor(), self.position())\n\n    def get_cursor_position(self) -&gt; tuple[int, int]:\n\"\"\"Return the QTextCursor position.\n\n        The position is a tuple made up of\n        the line number (0 based) and the column number (0 based).\n        :return: tuple(line, column)\n        \"\"\"\n        return (self.blockNumber(), self.columnNumber())\n\n    def get_selection(self) -&gt; gui.TextDocumentFragment:\n        return gui.TextDocumentFragment(self.selection())\n\n    def select_text(\n        self,\n        start_pos: int | MoveOperationStr,\n        end_pos: int | MoveOperationStr,\n    ) -&gt; str:\n\"\"\"Select text from start position to end position.\n\n        Positions can be either an integer index or a move operation\n\n        Args:\n            start_pos: Start position\n            end_pos: End position\n        \"\"\"\n        if isinstance(start_pos, int):\n            self.set_position(start_pos)\n        else:\n            self.move_position(start_pos)\n        if isinstance(end_pos, int):\n            self.set_position(end_pos, mode=\"keep\")\n        else:\n            self.move_position(end_pos, mode=\"keep\")\n        return self.selectedText()\n\n    def replace_text(\n        self,\n        start_pos: int,\n        end_pos: MoveOperationStr | int,\n        to_replace: str,\n    ):\n        self.set_position(start_pos)\n        if isinstance(end_pos, int):\n            self.set_position(end_pos, mode=\"keep\")\n        else:\n            self.move_position(end_pos, mode=\"keep\")\n        self.insertText(to_replace)\n        self.select_text(start_pos, start_pos + len(to_replace))\n\n    @contextlib.contextmanager\n    def edit_block(self):\n\"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\"\n        self.beginEditBlock()\n        yield\n        self.endEditBlock()\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.edit_block","title":"<code>edit_block()</code>","text":"<p>Context manager for edit blocks. Can be used for undo actions.</p> Source code in <code>prettyqt\\gui\\textcursor.py</code> <pre><code>@contextlib.contextmanager\ndef edit_block(self):\n\"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\"\n    self.beginEditBlock()\n    yield\n    self.endEditBlock()\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.get_cursor_position","title":"<code>get_cursor_position() -&gt; tuple[int, int]</code>","text":"<p>Return the QTextCursor position.</p> <p>The position is a tuple made up of the line number (0 based) and the column number (0 based). :return: tuple(line, column)</p> Source code in <code>prettyqt\\gui\\textcursor.py</code> <pre><code>def get_cursor_position(self) -&gt; tuple[int, int]:\n\"\"\"Return the QTextCursor position.\n\n    The position is a tuple made up of\n    the line number (0 based) and the column number (0 based).\n    :return: tuple(line, column)\n    \"\"\"\n    return (self.blockNumber(), self.columnNumber())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select_text","title":"<code>select_text(start_pos: int | MoveOperationStr, end_pos: int | MoveOperationStr) -&gt; str</code>","text":"<p>Select text from start position to end position.</p> <p>Positions can be either an integer index or a move operation</p> <p>Parameters:</p> Name Type Description Default <code>start_pos</code> <code>int | MoveOperationStr</code> <p>Start position</p> required <code>end_pos</code> <code>int | MoveOperationStr</code> <p>End position</p> required Source code in <code>prettyqt\\gui\\textcursor.py</code> <pre><code>def select_text(\n    self,\n    start_pos: int | MoveOperationStr,\n    end_pos: int | MoveOperationStr,\n) -&gt; str:\n\"\"\"Select text from start position to end position.\n\n    Positions can be either an integer index or a move operation\n\n    Args:\n        start_pos: Start position\n        end_pos: End position\n    \"\"\"\n    if isinstance(start_pos, int):\n        self.set_position(start_pos)\n    else:\n        self.move_position(start_pos)\n    if isinstance(end_pos, int):\n        self.set_position(end_pos, mode=\"keep\")\n    else:\n        self.move_position(end_pos, mode=\"keep\")\n    return self.selectedText()\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.set_position","title":"<code>set_position(pos: int, mode: MoveModeStr = 'move')</code>","text":"<p>Set cursor to given position.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>int</code> <p>Cursor position</p> required <code>mode</code> <code>MoveModeStr</code> <p>Move mode</p> <code>'move'</code> Source code in <code>prettyqt\\gui\\textcursor.py</code> <pre><code>def set_position(self, pos: int, mode: MoveModeStr = \"move\"):\n\"\"\"Set cursor to given position.\n\n    Args:\n        pos: Cursor position\n        mode: Move mode\n    \"\"\"\n    self.setPosition(pos, MOVE_MODE[mode])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextFormatMixin","title":"<code>TextFormatMixin</code>","text":"Source code in <code>prettyqt\\gui\\textformat.py</code> <pre><code>class TextFormatMixin:\n    def __getitem__(self, key: int):\n        return self.property(key)\n\n    def __setitem__(self, key: int, value):\n        self.setProperty(key, value)\n\n    def __contains__(self, key: int):\n        return self.hasProperty(key)\n\n    def __bool__(self):\n        return self.isValid()\n\n    def __repr__(self):\n        return get_repr(self, self.type())\n\n    def get_background(self) -&gt; gui.Brush:\n        return gui.Brush(self.background())\n\n    def get_foreground(self) -&gt; gui.Brush:\n        return gui.Brush(self.foreground())\n\n    def get_brush_property(self, property_id: int) -&gt; gui.Brush:\n        return gui.Brush(self.brushProperty(property_id))\n\n    def get_color_property(self, property_id: int) -&gt; gui.Color:\n        return gui.Color(self.colorProperty(property_id))\n\n    def get_pen_property(self, property_id: int) -&gt; gui.Pen:\n        return gui.Pen(self.penProperty(property_id))\n\n    def set_layout_direction(self, direction: constants.LayoutDirectionStr):\n\"\"\"Set layout direction.\n\n        Args:\n            direction: layout direction\n\n        Raises:\n            InvalidParamError: layout direction does not exist\n        \"\"\"\n        if direction not in constants.LAYOUT_DIRECTION:\n            raise InvalidParamError(direction, constants.LAYOUT_DIRECTION)\n        self.setLayoutDirection(constants.LAYOUT_DIRECTION[direction])\n\n    def get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n\n        Returns:\n            layout direction\n        \"\"\"\n        return constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\n\n    def select_full_width(self, value: bool = True):\n        prop = QtGui.QTextFormat.Property.FullWidthSelection\n        self.setProperty(prop, value)  # type: ignore\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormatMixin.get_layout_direction","title":"<code>get_layout_direction() -&gt; constants.LayoutDirectionStr</code>","text":"<p>Get the current layout direction.</p> <p>Returns:</p> Type Description <code>constants.LayoutDirectionStr</code> <p>layout direction</p> Source code in <code>prettyqt\\gui\\textformat.py</code> <pre><code>def get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n\n    Returns:\n        layout direction\n    \"\"\"\n    return constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormatMixin.set_layout_direction","title":"<code>set_layout_direction(direction: constants.LayoutDirectionStr)</code>","text":"<p>Set layout direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>constants.LayoutDirectionStr</code> <p>layout direction</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>layout direction does not exist</p> Source code in <code>prettyqt\\gui\\textformat.py</code> <pre><code>def set_layout_direction(self, direction: constants.LayoutDirectionStr):\n\"\"\"Set layout direction.\n\n    Args:\n        direction: layout direction\n\n    Raises:\n        InvalidParamError: layout direction does not exist\n    \"\"\"\n    if direction not in constants.LAYOUT_DIRECTION:\n        raise InvalidParamError(direction, constants.LAYOUT_DIRECTION)\n    self.setLayoutDirection(constants.LAYOUT_DIRECTION[direction])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextFrameFormat","title":"<code>TextFrameFormat</code>","text":"<p>         Bases: <code>gui.TextFormatMixin</code>, <code>QtGui.QTextFrameFormat</code></p> Source code in <code>prettyqt\\gui\\textframeformat.py</code> <pre><code>class TextFrameFormat(gui.TextFormatMixin, QtGui.QTextFrameFormat):\n    def get_height(self) -&gt; gui.TextLength:\n        length = self.height()\n        return gui.TextLength(length.type(), length.rawValue())\n\n    def get_width(self) -&gt; gui.TextLength:\n        length = self.width()\n        return gui.TextLength(length.type(), length.rawValue())\n\n    def get_border_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.borderBrush())\n\n    def set_border_style(self, style: BorderStyleStr):\n\"\"\"Set border style.\n\n        Args:\n            style: border style\n\n        Raises:\n            InvalidParamError: border style does not exist\n        \"\"\"\n        if style not in BORDER_STYLES:\n            raise InvalidParamError(style, BORDER_STYLES)\n        self.setBorderStyle(BORDER_STYLES[style])\n\n    def get_border_style(self) -&gt; BorderStyleStr:\n\"\"\"Get the current border style.\n\n        Returns:\n            border style\n        \"\"\"\n        return BORDER_STYLES.inverse[self.borderStyle()]\n\n    def set_page_break_policy(self, policy: gui.textformat.PageBreakFlagStr):\n\"\"\"Set page break policy.\n\n        Args:\n            policy: page break policy\n\n        Raises:\n            InvalidParamError: page break policy does not exist\n        \"\"\"\n        if policy not in gui.textformat.PAGE_BREAK_FLAG:\n            raise InvalidParamError(policy, gui.textformat.PAGE_BREAK_FLAG)\n        self.setPageBreakPolicy(gui.textformat.PAGE_BREAK_FLAG[policy])\n\n    def get_page_break_policy(self) -&gt; gui.textformat.PageBreakFlagStr:\n\"\"\"Get the current page break policy.\n\n        Returns:\n            page break policy\n        \"\"\"\n        return gui.textformat.PAGE_BREAK_FLAG.inverse[self.pageBreakPolicy()]\n\n    def set_position(self, position: PositionStr):\n\"\"\"Set position.\n\n        Args:\n            position: position\n\n        Raises:\n            InvalidParamError: position does not exist\n        \"\"\"\n        if position not in POSITIONS:\n            raise InvalidParamError(position, POSITIONS)\n        self.setPosition(POSITIONS[position])\n\n    def get_position(self) -&gt; PositionStr:\n\"\"\"Get the current position.\n\n        Returns:\n            position\n        \"\"\"\n        return POSITIONS.inverse[self.position()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_border_style","title":"<code>get_border_style() -&gt; BorderStyleStr</code>","text":"<p>Get the current border style.</p> <p>Returns:</p> Type Description <code>BorderStyleStr</code> <p>border style</p> Source code in <code>prettyqt\\gui\\textframeformat.py</code> <pre><code>def get_border_style(self) -&gt; BorderStyleStr:\n\"\"\"Get the current border style.\n\n    Returns:\n        border style\n    \"\"\"\n    return BORDER_STYLES.inverse[self.borderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_page_break_policy","title":"<code>get_page_break_policy() -&gt; gui.textformat.PageBreakFlagStr</code>","text":"<p>Get the current page break policy.</p> <p>Returns:</p> Type Description <code>gui.textformat.PageBreakFlagStr</code> <p>page break policy</p> Source code in <code>prettyqt\\gui\\textframeformat.py</code> <pre><code>def get_page_break_policy(self) -&gt; gui.textformat.PageBreakFlagStr:\n\"\"\"Get the current page break policy.\n\n    Returns:\n        page break policy\n    \"\"\"\n    return gui.textformat.PAGE_BREAK_FLAG.inverse[self.pageBreakPolicy()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_position","title":"<code>get_position() -&gt; PositionStr</code>","text":"<p>Get the current position.</p> <p>Returns:</p> Type Description <code>PositionStr</code> <p>position</p> Source code in <code>prettyqt\\gui\\textframeformat.py</code> <pre><code>def get_position(self) -&gt; PositionStr:\n\"\"\"Get the current position.\n\n    Returns:\n        position\n    \"\"\"\n    return POSITIONS.inverse[self.position()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_border_style","title":"<code>set_border_style(style: BorderStyleStr)</code>","text":"<p>Set border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>BorderStyleStr</code> <p>border style</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>border style does not exist</p> Source code in <code>prettyqt\\gui\\textframeformat.py</code> <pre><code>def set_border_style(self, style: BorderStyleStr):\n\"\"\"Set border style.\n\n    Args:\n        style: border style\n\n    Raises:\n        InvalidParamError: border style does not exist\n    \"\"\"\n    if style not in BORDER_STYLES:\n        raise InvalidParamError(style, BORDER_STYLES)\n    self.setBorderStyle(BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_page_break_policy","title":"<code>set_page_break_policy(policy: gui.textformat.PageBreakFlagStr)</code>","text":"<p>Set page break policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>gui.textformat.PageBreakFlagStr</code> <p>page break policy</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>page break policy does not exist</p> Source code in <code>prettyqt\\gui\\textframeformat.py</code> <pre><code>def set_page_break_policy(self, policy: gui.textformat.PageBreakFlagStr):\n\"\"\"Set page break policy.\n\n    Args:\n        policy: page break policy\n\n    Raises:\n        InvalidParamError: page break policy does not exist\n    \"\"\"\n    if policy not in gui.textformat.PAGE_BREAK_FLAG:\n        raise InvalidParamError(policy, gui.textformat.PAGE_BREAK_FLAG)\n    self.setPageBreakPolicy(gui.textformat.PAGE_BREAK_FLAG[policy])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_position","title":"<code>set_position(position: PositionStr)</code>","text":"<p>Set position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>PositionStr</code> <p>position</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>position does not exist</p> Source code in <code>prettyqt\\gui\\textframeformat.py</code> <pre><code>def set_position(self, position: PositionStr):\n\"\"\"Set position.\n\n    Args:\n        position: position\n\n    Raises:\n        InvalidParamError: position does not exist\n    \"\"\"\n    if position not in POSITIONS:\n        raise InvalidParamError(position, POSITIONS)\n    self.setPosition(POSITIONS[position])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextLength","title":"<code>TextLength</code>","text":"<p>         Bases: <code>QtGui.QTextLength</code></p> Source code in <code>prettyqt\\gui\\textlength.py</code> <pre><code>class TextLength(QtGui.QTextLength):\n    def __repr__(self):\n        return get_repr(self, self.type(), self.rawValue())\n\n    def get_type(self) -&gt; TypeStr:\n\"\"\"Return type of this length object.\n\n        Returns:\n            timer type\n        \"\"\"\n        return TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textlength.TextLength.get_type","title":"<code>get_type() -&gt; TypeStr</code>","text":"<p>Return type of this length object.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>timer type</p> Source code in <code>prettyqt\\gui\\textlength.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return type of this length object.\n\n    Returns:\n        timer type\n    \"\"\"\n    return TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextListFormat","title":"<code>TextListFormat</code>","text":"<p>         Bases: <code>gui.TextFormatMixin</code>, <code>QtGui.QTextListFormat</code></p> Source code in <code>prettyqt\\gui\\textlistformat.py</code> <pre><code>class TextListFormat(gui.TextFormatMixin, QtGui.QTextListFormat):\n    def set_style(self, style: StyleStr):\n\"\"\"Set the style.\n\n        Args:\n            style: style\n\n        Raises:\n            InvalidParamError: invalid style\n        \"\"\"\n        if style not in STYLES:\n            raise InvalidParamError(style, STYLES)\n        self.setStyle(STYLES[style])\n\n    def get_style(self) -&gt; StyleStr:\n\"\"\"Get current style.\n\n        Returns:\n            current style\n        \"\"\"\n        return STYLES.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.get_style","title":"<code>get_style() -&gt; StyleStr</code>","text":"<p>Get current style.</p> <p>Returns:</p> Type Description <code>StyleStr</code> <p>current style</p> Source code in <code>prettyqt\\gui\\textlistformat.py</code> <pre><code>def get_style(self) -&gt; StyleStr:\n\"\"\"Get current style.\n\n    Returns:\n        current style\n    \"\"\"\n    return STYLES.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.set_style","title":"<code>set_style(style: StyleStr)</code>","text":"<p>Set the style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>StyleStr</code> <p>style</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid style</p> Source code in <code>prettyqt\\gui\\textlistformat.py</code> <pre><code>def set_style(self, style: StyleStr):\n\"\"\"Set the style.\n\n    Args:\n        style: style\n\n    Raises:\n        InvalidParamError: invalid style\n    \"\"\"\n    if style not in STYLES:\n        raise InvalidParamError(style, STYLES)\n    self.setStyle(STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.TextTableCellFormat","title":"<code>TextTableCellFormat</code>","text":"<p>         Bases: <code>gui.TextCharFormatMixin</code>, <code>QtGui.QTextTableCellFormat</code></p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>class TextTableCellFormat(gui.TextCharFormatMixin, QtGui.QTextTableCellFormat):\n    def get_bottom_border_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.bottomBorderBrush())\n\n    def set_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set border style.\n\n        Args:\n            style: border style\n\n        Raises:\n            InvalidParamError: border style does not exist\n        \"\"\"\n        if style not in gui.textframeformat.BORDER_STYLES:\n            raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n        self.setBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n\n    def set_bottom_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set bottom border style.\n\n        Args:\n            style: bottom border style\n\n        Raises:\n            InvalidParamError: bottom border style does not exist\n        \"\"\"\n        if style not in gui.textframeformat.BORDER_STYLES:\n            raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n        self.setBottomBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n\n    def get_bottom_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current bottom border style.\n\n        Returns:\n            bottom border style\n        \"\"\"\n        return gui.textframeformat.BORDER_STYLES.inverse[self.bottomBorderStyle()]\n\n    def get_left_border_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.leftBorderBrush())\n\n    def set_left_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set left border style.\n\n        Args:\n            style: left border style\n\n        Raises:\n            InvalidParamError: left border style does not exist\n        \"\"\"\n        if style not in gui.textframeformat.BORDER_STYLES:\n            raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n        self.setLeftBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n\n    def get_left_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current left border style.\n\n        Returns:\n            left border style\n        \"\"\"\n        return gui.textframeformat.BORDER_STYLES.inverse[self.leftBorderStyle()]\n\n    def get_right_border_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.rightBorderBrush())\n\n    def set_right_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set right border style.\n\n        Args:\n            style: right border style\n\n        Raises:\n            InvalidParamError: right border style does not exist\n        \"\"\"\n        if style not in gui.textframeformat.BORDER_STYLES:\n            raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n        self.setRightBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n\n    def get_right_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current right border style.\n\n        Returns:\n            right border style\n        \"\"\"\n        return gui.textframeformat.BORDER_STYLES.inverse[self.rightBorderStyle()]\n\n    def get_top_border_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.topBorderBrush())\n\n    def set_top_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set top border style.\n\n        Args:\n            style: top border style\n\n        Raises:\n            InvalidParamError: top border style does not exist\n        \"\"\"\n        if style not in gui.textframeformat.BORDER_STYLES:\n            raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n        self.setTopBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n\n    def get_top_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current top border style.\n\n        Returns:\n            top border style\n        \"\"\"\n        return gui.textframeformat.BORDER_STYLES.inverse[self.topBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_bottom_border_style","title":"<code>get_bottom_border_style() -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current bottom border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>bottom border style</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def get_bottom_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current bottom border style.\n\n    Returns:\n        bottom border style\n    \"\"\"\n    return gui.textframeformat.BORDER_STYLES.inverse[self.bottomBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_left_border_style","title":"<code>get_left_border_style() -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current left border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>left border style</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def get_left_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current left border style.\n\n    Returns:\n        left border style\n    \"\"\"\n    return gui.textframeformat.BORDER_STYLES.inverse[self.leftBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_right_border_style","title":"<code>get_right_border_style() -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current right border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>right border style</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def get_right_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current right border style.\n\n    Returns:\n        right border style\n    \"\"\"\n    return gui.textframeformat.BORDER_STYLES.inverse[self.rightBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_top_border_style","title":"<code>get_top_border_style() -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current top border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>top border style</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def get_top_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current top border style.\n\n    Returns:\n        top border style\n    \"\"\"\n    return gui.textframeformat.BORDER_STYLES.inverse[self.topBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_border_style","title":"<code>set_border_style(style: gui.textframeformat.BorderStyleStr)</code>","text":"<p>Set border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr</code> <p>border style</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>border style does not exist</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def set_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set border style.\n\n    Args:\n        style: border style\n\n    Raises:\n        InvalidParamError: border style does not exist\n    \"\"\"\n    if style not in gui.textframeformat.BORDER_STYLES:\n        raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n    self.setBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_bottom_border_style","title":"<code>set_bottom_border_style(style: gui.textframeformat.BorderStyleStr)</code>","text":"<p>Set bottom border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr</code> <p>bottom border style</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>bottom border style does not exist</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def set_bottom_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set bottom border style.\n\n    Args:\n        style: bottom border style\n\n    Raises:\n        InvalidParamError: bottom border style does not exist\n    \"\"\"\n    if style not in gui.textframeformat.BORDER_STYLES:\n        raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n    self.setBottomBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_left_border_style","title":"<code>set_left_border_style(style: gui.textframeformat.BorderStyleStr)</code>","text":"<p>Set left border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr</code> <p>left border style</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>left border style does not exist</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def set_left_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set left border style.\n\n    Args:\n        style: left border style\n\n    Raises:\n        InvalidParamError: left border style does not exist\n    \"\"\"\n    if style not in gui.textframeformat.BORDER_STYLES:\n        raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n    self.setLeftBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_right_border_style","title":"<code>set_right_border_style(style: gui.textframeformat.BorderStyleStr)</code>","text":"<p>Set right border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr</code> <p>right border style</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>right border style does not exist</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def set_right_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set right border style.\n\n    Args:\n        style: right border style\n\n    Raises:\n        InvalidParamError: right border style does not exist\n    \"\"\"\n    if style not in gui.textframeformat.BORDER_STYLES:\n        raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n    self.setRightBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_top_border_style","title":"<code>set_top_border_style(style: gui.textframeformat.BorderStyleStr)</code>","text":"<p>Set top border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr</code> <p>top border style</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>top border style does not exist</p> Source code in <code>prettyqt\\gui\\texttablecellformat.py</code> <pre><code>def set_top_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set top border style.\n\n    Args:\n        style: top border style\n\n    Raises:\n        InvalidParamError: top border style does not exist\n    \"\"\"\n    if style not in gui.textframeformat.BORDER_STYLES:\n        raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n    self.setTopBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.ValidatorMixin","title":"<code>ValidatorMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\gui\\validator.py</code> <pre><code>class ValidatorMixin(core.ObjectMixin):\n    def __repr__(self):\n        return get_repr(self)\n\n    def __add__(self, other: Validator):\n        from prettyqt import custom_validators\n\n        return custom_validators.CompositeValidator([self, other])\n\n    def __radd__(self, other: QtGui.QValidator):\n\"\"\"Needed for sum().\"\"\"\n        return self.__add__(other)\n\n    def is_valid_value(self, value: str, pos: int = 0) -&gt; bool:\n        val = self.validate(value, pos)\n        return val[0] == self.State.Acceptable  # type: ignore\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.validator.ValidatorMixin.__radd__","title":"<code>__radd__(other: QtGui.QValidator)</code>","text":"<p>Needed for sum().</p> Source code in <code>prettyqt\\gui\\validator.py</code> <pre><code>def __radd__(self, other: QtGui.QValidator):\n\"\"\"Needed for sum().\"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.WindowMixin","title":"<code>WindowMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>gui.SurfaceMixin</code></p> Source code in <code>prettyqt\\gui\\window.py</code> <pre><code>class WindowMixin(core.ObjectMixin, gui.SurfaceMixin):\n    def __repr__(self):\n        return get_repr(self)\n\n    # def serialize_fields(self):\n    #     return dict(\n    #         speed=self.speed(),\n    #         visibility=self.get_visibility(),\n    #         scaled_size=self.scaledSize(),\n    #         background_color=self.backgroundColor(),\n    #     )\n\n    def set_visibility(self, visibility: VisibilityStr):\n\"\"\"Set window visibility.\n\n        Args:\n            visibility: window visibility\n\n        Raises:\n            InvalidParamError: window visibility does not exist\n        \"\"\"\n        if visibility not in VISIBILITY:\n            raise InvalidParamError(visibility, VISIBILITY)\n        self.setVisibility(VISIBILITY[visibility])\n\n    def get_visibility(self) -&gt; VisibilityStr:\n\"\"\"Get the current window visibility.\n\n        Returns:\n            window visibility\n        \"\"\"\n        return VISIBILITY.inverse[self.visibility()]\n\n    def start_system_resize(self, edge: constants.EdgeStr) -&gt; bool:\n\"\"\"Start system resize.\n\n        Args:\n            edge: edge to resize\n\n        Raises:\n            InvalidParamError: edge does not exist\n        \"\"\"\n        if edge not in constants.EDGES:\n            raise InvalidParamError(edge, constants.EDGES)\n        return self.startSystemResize(constants.EDGES[edge])\n\n    def get_screen(self) -&gt; gui.Screen:\n        return gui.Screen(self.screen())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.window.WindowMixin.get_visibility","title":"<code>get_visibility() -&gt; VisibilityStr</code>","text":"<p>Get the current window visibility.</p> <p>Returns:</p> Type Description <code>VisibilityStr</code> <p>window visibility</p> Source code in <code>prettyqt\\gui\\window.py</code> <pre><code>def get_visibility(self) -&gt; VisibilityStr:\n\"\"\"Get the current window visibility.\n\n    Returns:\n        window visibility\n    \"\"\"\n    return VISIBILITY.inverse[self.visibility()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.window.WindowMixin.set_visibility","title":"<code>set_visibility(visibility: VisibilityStr)</code>","text":"<p>Set window visibility.</p> <p>Parameters:</p> Name Type Description Default <code>visibility</code> <code>VisibilityStr</code> <p>window visibility</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>window visibility does not exist</p> Source code in <code>prettyqt\\gui\\window.py</code> <pre><code>def set_visibility(self, visibility: VisibilityStr):\n\"\"\"Set window visibility.\n\n    Args:\n        visibility: window visibility\n\n    Raises:\n        InvalidParamError: window visibility does not exist\n    \"\"\"\n    if visibility not in VISIBILITY:\n        raise InvalidParamError(visibility, VISIBILITY)\n    self.setVisibility(VISIBILITY[visibility])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.window.WindowMixin.start_system_resize","title":"<code>start_system_resize(edge: constants.EdgeStr) -&gt; bool</code>","text":"<p>Start system resize.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>constants.EdgeStr</code> <p>edge to resize</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>edge does not exist</p> Source code in <code>prettyqt\\gui\\window.py</code> <pre><code>def start_system_resize(self, edge: constants.EdgeStr) -&gt; bool:\n\"\"\"Start system resize.\n\n    Args:\n        edge: edge to resize\n\n    Raises:\n        InvalidParamError: edge does not exist\n    \"\"\"\n    if edge not in constants.EDGES:\n        raise InvalidParamError(edge, constants.EDGES)\n    return self.startSystemResize(constants.EDGES[edge])\n</code></pre>"},{"location":"api/network.html","title":"network module","text":"<p>Network module.</p> <p>Contains QtNetWork-based classes</p>"},{"location":"api/network.html#prettyqt.network.AbstractSocketMixin","title":"<code>AbstractSocketMixin</code>","text":"<p>         Bases: <code>core.IODeviceMixin</code></p> Source code in <code>prettyqt\\network\\abstractsocket.py</code> <pre><code>class AbstractSocketMixin(core.IODeviceMixin):\n    def __repr__(self):\n        return get_repr(self)\n\n    def bind_to(\n        self,\n        address: str | QtNetwork.QHostAddress,\n        port: int = 0,\n        bind_mode: (\n            QtNetwork.QAbstractSocket.BindFlag | BindModeStr\n        ) = \"default_for_platform\",\n    ) -&gt; bool:\n        if isinstance(address, str):\n            address = QtNetwork.QHostAddress(address)\n        mode = BIND_MODE[bind_mode] if bind_mode in BIND_MODE else bind_mode\n        return self.bind(address, port, mode)\n\n    def connect_to_host(\n        self,\n        hostname: str,\n        port: int,\n        open_mode: (QtCore.QIODevice.OpenMode | core.iodevice.OpenModeStr) = \"read_write\",\n        protocol: (\n            QtNetwork.QAbstractSocket.NetworkLayerProtocol | NetworkLayerProtocolStr\n        ) = \"any_ip\",\n    ):\n        if isinstance(open_mode, QtCore.QIODeviceBase.OpenMode):\n            mode = open_mode\n        else:\n            mode = core.iodevice.OPEN_MODES[open_mode]\n        if isinstance(protocol, QtNetwork.QAbstractSocket.NetworkLayerProtocol):\n            prot = protocol\n        else:\n            prot = NETWORK_LAYER_PROTOCOL[protocol]\n        self.connectToHost(hostname, port, mode, prot)\n\n    def get_error(self) -&gt; SocketErrorStr:\n        return SOCKET_ERROR.inverse[self.error()]\n\n    def set_pause_mode(self, mode: PauseModeStr):\n\"\"\"Set pause mode.\n\n        Args:\n            mode: pause mode\n\n        Raises:\n            InvalidParamError: pause mode does not exist\n        \"\"\"\n        if mode not in PAUSE_MODES:\n            raise InvalidParamError(mode, PAUSE_MODES)\n        self.setPauseMode(PAUSE_MODES[mode])\n\n    def get_pause_mode(self) -&gt; PauseModeStr:\n        return PAUSE_MODES.inverse[self.pauseMode()]\n\n    def get_proxy(self) -&gt; network.NetworkProxy:\n        return network.NetworkProxy(self.proxy())\n\n    # def set_socket_option(self, name: str, value):\n    #     if name not in SOCKET_OPTION:\n    #         raise InvalidParamError(name, SOCKET_OPTION)\n    #     self.setSocketOption(SOCKET_OPTION[name], value)\n\n    # def get_socket_option(self, name: str):\n    #     return self.socketOption(SOCKET_OPTION[name])\n\n    # def set_type_of_service(self, typ: str):\n    #     if typ not in TYPE_OF_SERVICE:\n    #         raise InvalidParamError(typ, TYPE_OF_SERVICE)\n    #     self.set_socket_option(\"type_of_service\", TYPE_OF_SERVICE[typ])\n\n    # def get_type_of_service(self):\n    #     opt = self.get_socket_option(\"type_of_service\")\n    #     return TYPE_OF_SERVICE.inverse[opt]\n\n    def get_socket_type(self) -&gt; SocketTypeStr:\n        return SOCKET_TYPE.inverse[self.socketType()]\n\n    def get_state(self) -&gt; SocketStateStr:\n        return SOCKET_STATE.inverse[self.state()]\n\n    def get_local_address(self) -&gt; network.HostAddress:\n        return network.HostAddress(self.localAddress())\n</code></pre>"},{"location":"api/network.html#prettyqt.network.abstractsocket.AbstractSocketMixin.set_pause_mode","title":"<code>set_pause_mode(mode: PauseModeStr)</code>","text":"<p>Set pause mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>PauseModeStr</code> <p>pause mode</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>pause mode does not exist</p> Source code in <code>prettyqt\\network\\abstractsocket.py</code> <pre><code>def set_pause_mode(self, mode: PauseModeStr):\n\"\"\"Set pause mode.\n\n    Args:\n        mode: pause mode\n\n    Raises:\n        InvalidParamError: pause mode does not exist\n    \"\"\"\n    if mode not in PAUSE_MODES:\n        raise InvalidParamError(mode, PAUSE_MODES)\n    self.setPauseMode(PAUSE_MODES[mode])\n</code></pre>"},{"location":"api/network.html#prettyqt.network.HttpMultiPart","title":"<code>HttpMultiPart</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtNetwork.QHttpMultiPart</code></p> Source code in <code>prettyqt\\network\\httpmultipart.py</code> <pre><code>class HttpMultiPart(core.ObjectMixin, QtNetwork.QHttpMultiPart):\n    def __add__(self, other: QtNetwork.QHttpPart):\n        self.append(other)\n        return self\n\n    def set_content_type(self, typ: ContentTypeStr):\n\"\"\"Set content type.\n\n        Args:\n            typ: content type\n\n        Raises:\n            InvalidParamError: content type does not exist\n        \"\"\"\n        if typ not in CONTENT_TYPES:\n            raise InvalidParamError(typ, CONTENT_TYPES)\n        self.setContentType(CONTENT_TYPES[typ])\n\n    def set_boundary(self, boundary: datatypes.ByteArrayType):\n        if isinstance(boundary, str):\n            boundary = boundary.encode()\n        if isinstance(boundary, bytes):\n            boundary = QtCore.QByteArray(boundary)\n        self.setBoundary(boundary)\n\n    def get_boundary(self) -&gt; str:\n        return self.boundary().data().decode()\n</code></pre>"},{"location":"api/network.html#prettyqt.network.httpmultipart.HttpMultiPart.set_content_type","title":"<code>set_content_type(typ: ContentTypeStr)</code>","text":"<p>Set content type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>ContentTypeStr</code> <p>content type</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>content type does not exist</p> Source code in <code>prettyqt\\network\\httpmultipart.py</code> <pre><code>def set_content_type(self, typ: ContentTypeStr):\n\"\"\"Set content type.\n\n    Args:\n        typ: content type\n\n    Raises:\n        InvalidParamError: content type does not exist\n    \"\"\"\n    if typ not in CONTENT_TYPES:\n        raise InvalidParamError(typ, CONTENT_TYPES)\n    self.setContentType(CONTENT_TYPES[typ])\n</code></pre>"},{"location":"api/network.html#prettyqt.network.NetworkAccessManager","title":"<code>NetworkAccessManager</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtNetwork.QNetworkAccessManager</code></p> Source code in <code>prettyqt\\network\\networkaccessmanager.py</code> <pre><code>class NetworkAccessManager(core.ObjectMixin, QtNetwork.QNetworkAccessManager):\n    # def request(\n    #     self,\n    #     method,\n    #     url,\n    #     headers=None,\n    #     cookies=None,\n    #     files=None,\n    #     auth=None,\n    #     timeout=None,\n    #     allow_redirects=True,\n    # ):\n    #     req = network.NetworkRequest()\n    #     if allow_redirects:\n    #         pass\n\n    def get(self, request: datatypes.UrlType | QtNetwork.QNetworkRequest):\n        if isinstance(request, str):\n            request = core.Url(request)\n        request = network.NetworkRequest(request)\n        return super().get(request)\n\n    # def post(self, url, data=None, json=None):\n    #     pass\n\n    # def put(self, url, data=None, json=None):\n    #     pass\n\n    # def patch(self, url, data=None):\n    #     pass\n\n    # def delete(self, url):\n    #     pass\n\n    def set_redirect_policy(self, policy: network.networkrequest.RedirectPolicyStr):\n\"\"\"Set redirect policy.\n\n        Args:\n            policy: redirect policy\n\n        Raises:\n            InvalidParamError: redirect policy does not exist\n        \"\"\"\n        if policy not in network.networkrequest.REDIRECT_POLICIES:\n            raise InvalidParamError(policy, network.networkrequest.REDIRECT_POLICIES)\n        self.setRedirectPolicy(network.networkrequest.REDIRECT_POLICIES[policy])\n\n    def get_redirect_policy(self) -&gt; network.networkrequest.RedirectPolicyStr:\n\"\"\"Get the current redirect policy.\n\n        Returns:\n            redirect policy\n        \"\"\"\n        return network.networkrequest.REDIRECT_POLICIES.inverse[self.redirectPolicy()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.get_redirect_policy","title":"<code>get_redirect_policy() -&gt; network.networkrequest.RedirectPolicyStr</code>","text":"<p>Get the current redirect policy.</p> <p>Returns:</p> Type Description <code>network.networkrequest.RedirectPolicyStr</code> <p>redirect policy</p> Source code in <code>prettyqt\\network\\networkaccessmanager.py</code> <pre><code>def get_redirect_policy(self) -&gt; network.networkrequest.RedirectPolicyStr:\n\"\"\"Get the current redirect policy.\n\n    Returns:\n        redirect policy\n    \"\"\"\n    return network.networkrequest.REDIRECT_POLICIES.inverse[self.redirectPolicy()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.set_redirect_policy","title":"<code>set_redirect_policy(policy: network.networkrequest.RedirectPolicyStr)</code>","text":"<p>Set redirect policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>network.networkrequest.RedirectPolicyStr</code> <p>redirect policy</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>redirect policy does not exist</p> Source code in <code>prettyqt\\network\\networkaccessmanager.py</code> <pre><code>def set_redirect_policy(self, policy: network.networkrequest.RedirectPolicyStr):\n\"\"\"Set redirect policy.\n\n    Args:\n        policy: redirect policy\n\n    Raises:\n        InvalidParamError: redirect policy does not exist\n    \"\"\"\n    if policy not in network.networkrequest.REDIRECT_POLICIES:\n        raise InvalidParamError(policy, network.networkrequest.REDIRECT_POLICIES)\n    self.setRedirectPolicy(network.networkrequest.REDIRECT_POLICIES[policy])\n</code></pre>"},{"location":"api/network.html#prettyqt.network.NetworkAddressEntry","title":"<code>NetworkAddressEntry</code>","text":"<p>         Bases: <code>QtNetwork.QNetworkAddressEntry</code></p> Source code in <code>prettyqt\\network\\networkaddressentry.py</code> <pre><code>class NetworkAddressEntry(QtNetwork.QNetworkAddressEntry):\n    def get_dns_eligibility(self) -&gt; DnsEligibilityStatusStr:\n\"\"\"Return whether this address is eligible for publication in the DNS.\n\n        Returns:\n            DNS eligibility\n        \"\"\"\n        return DNS_ELIGIBILITY_STATUS.inverse[self.dnsEligibility()]\n\n    def set_dns_eligibility(self, status: DnsEligibilityStatusStr):\n\"\"\"Set the DNS eligibility flag for this address to status.\n\n        Args:\n            status: DNS eligibility status\n\n        Raises:\n            InvalidParamError: dns eligibility status does not exist\n        \"\"\"\n        if status not in DNS_ELIGIBILITY_STATUS:\n            raise InvalidParamError(status, DNS_ELIGIBILITY_STATUS)\n        self.setDnsEligibility(DNS_ELIGIBILITY_STATUS[status])\n\n    def get_ip(self) -&gt; network.HostAddress:\n        return network.HostAddress(self.ip())\n\n    def set_ip(self, ip: QtNetwork.QHostAddress | str):\n        self.setIp(network.HostAddress(ip))\n\n    def get_netmask(self) -&gt; network.HostAddress:\n        return network.HostAddress(self.netmask())\n\n    def set_netmask(self, netmask: QtNetwork.QHostAddress | str):\n        self.setNetmask(network.HostAddress(netmask))\n\n    def get_preferred_lifetime(self) -&gt; core.DeadlineTimer:\n        return core.DeadlineTimer(self.preferredLifetime())\n\n    def get_validity_lifetime(self) -&gt; core.DeadlineTimer:\n        return core.DeadlineTimer(self.validityLifetime())\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.get_dns_eligibility","title":"<code>get_dns_eligibility() -&gt; DnsEligibilityStatusStr</code>","text":"<p>Return whether this address is eligible for publication in the DNS.</p> <p>Returns:</p> Type Description <code>DnsEligibilityStatusStr</code> <p>DNS eligibility</p> Source code in <code>prettyqt\\network\\networkaddressentry.py</code> <pre><code>def get_dns_eligibility(self) -&gt; DnsEligibilityStatusStr:\n\"\"\"Return whether this address is eligible for publication in the DNS.\n\n    Returns:\n        DNS eligibility\n    \"\"\"\n    return DNS_ELIGIBILITY_STATUS.inverse[self.dnsEligibility()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.set_dns_eligibility","title":"<code>set_dns_eligibility(status: DnsEligibilityStatusStr)</code>","text":"<p>Set the DNS eligibility flag for this address to status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>DnsEligibilityStatusStr</code> <p>DNS eligibility status</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>dns eligibility status does not exist</p> Source code in <code>prettyqt\\network\\networkaddressentry.py</code> <pre><code>def set_dns_eligibility(self, status: DnsEligibilityStatusStr):\n\"\"\"Set the DNS eligibility flag for this address to status.\n\n    Args:\n        status: DNS eligibility status\n\n    Raises:\n        InvalidParamError: dns eligibility status does not exist\n    \"\"\"\n    if status not in DNS_ELIGIBILITY_STATUS:\n        raise InvalidParamError(status, DNS_ELIGIBILITY_STATUS)\n    self.setDnsEligibility(DNS_ELIGIBILITY_STATUS[status])\n</code></pre>"},{"location":"api/network.html#prettyqt.network.NetworkInterface","title":"<code>NetworkInterface</code>","text":"<p>         Bases: <code>QtNetwork.QNetworkInterface</code></p> Source code in <code>prettyqt\\network\\networkinterface.py</code> <pre><code>class NetworkInterface(QtNetwork.QNetworkInterface):\n    # def __bool__(self):\n    #     return self.isValid()\n\n    def get_type(self) -&gt; InterfaceTypeStr:\n\"\"\"Get the interface type.\n\n        Returns:\n            interface type\n        \"\"\"\n        return INTERFACE_TYPE.inverse[self.type()]\n\n    def get_address_entries(self) -&gt; list[network.NetworkAddressEntry]:\n        return [network.NetworkAddressEntry(i) for i in self.addressEntries()]\n\n    @staticmethod\n    def get_all_addresses() -&gt; list[network.HostAddress]:\n        return [network.HostAddress(i) for i in NetworkInterface.allAddresses()]\n\n    @staticmethod\n    def get_all_interfaces() -&gt; list[network.HostAddress]:\n        return [network.NetworkInterface(i) for i in NetworkInterface.allInterfaces()]\n\n    @staticmethod\n    def get_interface_from_name(name: str) -&gt; NetworkInterface:\n        interface = NetworkInterface.interfaceFromName(name)\n        # if not interface:\n        #     return None\n        return NetworkInterface(interface)\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkinterface.NetworkInterface.get_type","title":"<code>get_type() -&gt; InterfaceTypeStr</code>","text":"<p>Get the interface type.</p> <p>Returns:</p> Type Description <code>InterfaceTypeStr</code> <p>interface type</p> Source code in <code>prettyqt\\network\\networkinterface.py</code> <pre><code>def get_type(self) -&gt; InterfaceTypeStr:\n\"\"\"Get the interface type.\n\n    Returns:\n        interface type\n    \"\"\"\n    return INTERFACE_TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.NetworkProxy","title":"<code>NetworkProxy</code>","text":"<p>         Bases: <code>QtNetwork.QNetworkProxy</code></p> Source code in <code>prettyqt\\network\\networkproxy.py</code> <pre><code>class NetworkProxy(QtNetwork.QNetworkProxy):\n    def get_capabilities(self) -&gt; list[CapabilityStr]:\n        return CAPABILITIES.get_list(self.capabilities())\n\n    def set_capabilities(self, *capability: CapabilityStr):\n        for item in capability:\n            if item not in CAPABILITIES:\n                raise InvalidParamError(item, CAPABILITIES)\n        flags = helpers.merge_flags(capability, CAPABILITIES)\n        self.setCapabilities(flags)\n\n    def get_header(self, name: network.networkrequest.KnownHeaderStr) -&gt; str:\n        if name not in network.networkrequest.KNOWN_HEADER:\n            raise InvalidParamError(name, network.networkrequest.KNOWN_HEADER)\n        return self.header(network.networkrequest.KNOWN_HEADER[name])\n\n    def set_header(self, name: network.networkrequest.KnownHeaderStr, value: str):\n        if name not in network.networkrequest.KNOWN_HEADER:\n            raise InvalidParamError(name, network.networkrequest.KNOWN_HEADER)\n        self.setHeader(network.networkrequest.KNOWN_HEADER[name], value)\n\n    def get_headers(self) -&gt; dict[str, str]:\n        return {\n            h.data().decode(): self.rawHeader(h).data().decode()\n            for h in self.rawHeaderList()\n        }\n\n    def set_headers(self, headers: dict[str, str]):\n        for k, v in headers.items():\n            self.setRawHeader(\n                QtCore.QByteArray(k.encode()), QtCore.QByteArray(v.encode())\n            )\n\n    def set_type(self, typ: ProxyTypeStr):\n\"\"\"Set proxy type.\n\n        Args:\n            typ: proxy type\n\n        Raises:\n            InvalidParamError: proxy type does not exist\n        \"\"\"\n        if typ not in PROXY_TYPES:\n            raise InvalidParamError(typ, PROXY_TYPES)\n        self.setType(PROXY_TYPES[typ])\n\n    def get_type(self) -&gt; ProxyTypeStr:\n\"\"\"Get the proxy type.\n\n        Returns:\n            type\n        \"\"\"\n        return PROXY_TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.get_type","title":"<code>get_type() -&gt; ProxyTypeStr</code>","text":"<p>Get the proxy type.</p> <p>Returns:</p> Type Description <code>ProxyTypeStr</code> <p>type</p> Source code in <code>prettyqt\\network\\networkproxy.py</code> <pre><code>def get_type(self) -&gt; ProxyTypeStr:\n\"\"\"Get the proxy type.\n\n    Returns:\n        type\n    \"\"\"\n    return PROXY_TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.set_type","title":"<code>set_type(typ: ProxyTypeStr)</code>","text":"<p>Set proxy type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>ProxyTypeStr</code> <p>proxy type</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>proxy type does not exist</p> Source code in <code>prettyqt\\network\\networkproxy.py</code> <pre><code>def set_type(self, typ: ProxyTypeStr):\n\"\"\"Set proxy type.\n\n    Args:\n        typ: proxy type\n\n    Raises:\n        InvalidParamError: proxy type does not exist\n    \"\"\"\n    if typ not in PROXY_TYPES:\n        raise InvalidParamError(typ, PROXY_TYPES)\n    self.setType(PROXY_TYPES[typ])\n</code></pre>"},{"location":"api/network.html#prettyqt.network.NetworkRequest","title":"<code>NetworkRequest</code>","text":"<p>         Bases: <code>QtNetwork.QNetworkRequest</code></p> Source code in <code>prettyqt\\network\\networkrequest.py</code> <pre><code>class NetworkRequest(QtNetwork.QNetworkRequest):\n    def __init__(self, obj: datatypes.UrlType | QtNetwork.QNetworkRequest | None = None):\n        if isinstance(obj, QtNetwork.QNetworkRequest):\n            super().__init__(obj)\n        else:\n            super().__init__()\n            if obj is not None:\n                self.set_url(obj)\n\n    def __repr__(self):\n        return get_repr(self, self.get_url())\n\n    def set_header(self, name: KnownHeaderStr, value: str):\n        if name not in KNOWN_HEADER:\n            raise InvalidParamError(name, KNOWN_HEADER)\n        self.setHeader(KNOWN_HEADER[name], value)\n\n    def get_header(self, name: KnownHeaderStr) -&gt; str:\n        if name not in KNOWN_HEADER:\n            raise InvalidParamError(name, KNOWN_HEADER)\n        return self.header(KNOWN_HEADER[name])\n\n    def set_headers(self, headers: dict[str, str]):\n        for k, v in headers.items():\n            self.setRawHeader(\n                QtCore.QByteArray(k.encode()), QtCore.QByteArray(v.encode())\n            )\n\n    def get_headers(self) -&gt; dict[str, str]:\n        return {\n            h.data().decode(): self.rawHeader(h).data().decode()\n            for h in self.rawHeaderList()\n        }\n\n    def set_url(self, url: str | QtCore.QUrl):\n        url = core.Url(url)\n        self.setUrl(url)\n\n    def get_url(self) -&gt; core.Url:\n        return core.Url(self.url())\n\n    def set_priority(self, priority: PriorityStr):\n\"\"\"Set priority.\n\n        Args:\n            priority: priority\n\n        Raises:\n            InvalidParamError: priority does not exist\n        \"\"\"\n        if priority not in PRIORITY:\n            raise InvalidParamError(priority, PRIORITY)\n        self.setPriority(PRIORITY[priority])\n\n    def get_priority(self) -&gt; PriorityStr:\n\"\"\"Get the current priority.\n\n        Returns:\n            priority\n        \"\"\"\n        return PRIORITY.inverse[self.priority()]\n\n    def set_attribute(self, attribute: AttributeStr, value: datatypes.Variant):\n        self.setAttribute(ATTRIBUTE[attribute], value)\n\n    def set_attributes(self, **kwargs):\n        for k, v in kwargs.items():\n            self.set_attribute(k, v)\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.get_priority","title":"<code>get_priority() -&gt; PriorityStr</code>","text":"<p>Get the current priority.</p> <p>Returns:</p> Type Description <code>PriorityStr</code> <p>priority</p> Source code in <code>prettyqt\\network\\networkrequest.py</code> <pre><code>def get_priority(self) -&gt; PriorityStr:\n\"\"\"Get the current priority.\n\n    Returns:\n        priority\n    \"\"\"\n    return PRIORITY.inverse[self.priority()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.set_priority","title":"<code>set_priority(priority: PriorityStr)</code>","text":"<p>Set priority.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>PriorityStr</code> <p>priority</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>priority does not exist</p> Source code in <code>prettyqt\\network\\networkrequest.py</code> <pre><code>def set_priority(self, priority: PriorityStr):\n\"\"\"Set priority.\n\n    Args:\n        priority: priority\n\n    Raises:\n        InvalidParamError: priority does not exist\n    \"\"\"\n    if priority not in PRIORITY:\n        raise InvalidParamError(priority, PRIORITY)\n    self.setPriority(PRIORITY[priority])\n</code></pre>"},{"location":"api/objbrowser.html","title":"objbrowser module","text":"<p>Objbrowser package.</p>"},{"location":"api/pdf.html","title":"pdf module","text":"<p>Pdf module.</p>"},{"location":"api/pdf.html#prettyqt.pdf.PdfDocument","title":"<code>PdfDocument</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtPdf.QPdfDocument</code></p> Source code in <code>prettyqt\\pdf\\pdfdocument.py</code> <pre><code>class PdfDocument(core.ObjectMixin, QtPdf.QPdfDocument):\n    def get_error(self) -&gt; ErrorStr:\n\"\"\"Return current error.\n\n        Returns:\n            page mode\n        \"\"\"\n        return ERROR.inverse[self.error()]\n\n    def get_status(self) -&gt; StatusStr:\n\"\"\"Return current status.\n\n        Returns:\n            zoom mode\n        \"\"\"\n        return STATUS.inverse[self.status()]\n</code></pre>"},{"location":"api/pdf.html#prettyqt.pdf.pdfdocument.PdfDocument.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return current error.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>page mode</p> Source code in <code>prettyqt\\pdf\\pdfdocument.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return current error.\n\n    Returns:\n        page mode\n    \"\"\"\n    return ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/pdf.html#prettyqt.pdf.pdfdocument.PdfDocument.get_status","title":"<code>get_status() -&gt; StatusStr</code>","text":"<p>Return current status.</p> <p>Returns:</p> Type Description <code>StatusStr</code> <p>zoom mode</p> Source code in <code>prettyqt\\pdf\\pdfdocument.py</code> <pre><code>def get_status(self) -&gt; StatusStr:\n\"\"\"Return current status.\n\n    Returns:\n        zoom mode\n    \"\"\"\n    return STATUS.inverse[self.status()]\n</code></pre>"},{"location":"api/pdfwidgets.html","title":"pdfwidgets module","text":"<p>Pdfwidgets module.</p>"},{"location":"api/pdfwidgets.html#prettyqt.pdfwidgets.PdfView","title":"<code>PdfView</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code>, <code>QtPdfWidgets.QPdfView</code></p> Source code in <code>prettyqt\\pdfwidgets\\pdfview.py</code> <pre><code>class PdfView(widgets.AbstractScrollAreaMixin, QtPdfWidgets.QPdfView):\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(parent)\n        self.setDocument(pdf.PdfDocument(self))\n\n    def get_document_margins(self) -&gt; core.Margins:\n        return core.Margins(self.documentMargins())\n\n    def set_file(self, path: datatypes.PathType):\n        doc = pdf.PdfDocument(self)\n        doc.load(os.fspath(path))\n        self.setDocument(doc)\n\n    def set_page_mode(self, mode: PageModeStr):\n\"\"\"Set the page mode.\n\n        Args:\n            mode: page mode\n\n        Raises:\n            InvalidParamError: page mode does not exist\n        \"\"\"\n        if mode not in PAGE_MODE:\n            raise InvalidParamError(mode, PAGE_MODE)\n        self.setPageMode(PAGE_MODE[mode])\n\n    def get_page_mode(self) -&gt; PageModeStr:\n\"\"\"Return current page mode.\n\n        Returns:\n            page mode\n        \"\"\"\n        return PAGE_MODE.inverse[self.pageMode()]\n\n    def set_zoom_mode(self, mode: ZoomModeStr):\n\"\"\"Set the zoom mode.\n\n        Args:\n            mode: zoom mode\n\n        Raises:\n            InvalidParamError: zoom mode does not exist\n        \"\"\"\n        if mode not in ZOOM_MODE:\n            raise InvalidParamError(mode, ZOOM_MODE)\n        self.setZoomMode(ZOOM_MODE[mode])\n\n    def get_zoom_mode(self) -&gt; ZoomModeStr:\n\"\"\"Return current zoom mode.\n\n        Returns:\n            zoom mode\n        \"\"\"\n        return ZOOM_MODE.inverse[self.zoomMode()]\n</code></pre>"},{"location":"api/pdfwidgets.html#prettyqt.pdfwidgets.pdfview.PdfView.get_page_mode","title":"<code>get_page_mode() -&gt; PageModeStr</code>","text":"<p>Return current page mode.</p> <p>Returns:</p> Type Description <code>PageModeStr</code> <p>page mode</p> Source code in <code>prettyqt\\pdfwidgets\\pdfview.py</code> <pre><code>def get_page_mode(self) -&gt; PageModeStr:\n\"\"\"Return current page mode.\n\n    Returns:\n        page mode\n    \"\"\"\n    return PAGE_MODE.inverse[self.pageMode()]\n</code></pre>"},{"location":"api/pdfwidgets.html#prettyqt.pdfwidgets.pdfview.PdfView.get_zoom_mode","title":"<code>get_zoom_mode() -&gt; ZoomModeStr</code>","text":"<p>Return current zoom mode.</p> <p>Returns:</p> Type Description <code>ZoomModeStr</code> <p>zoom mode</p> Source code in <code>prettyqt\\pdfwidgets\\pdfview.py</code> <pre><code>def get_zoom_mode(self) -&gt; ZoomModeStr:\n\"\"\"Return current zoom mode.\n\n    Returns:\n        zoom mode\n    \"\"\"\n    return ZOOM_MODE.inverse[self.zoomMode()]\n</code></pre>"},{"location":"api/pdfwidgets.html#prettyqt.pdfwidgets.pdfview.PdfView.set_page_mode","title":"<code>set_page_mode(mode: PageModeStr)</code>","text":"<p>Set the page mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>PageModeStr</code> <p>page mode</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>page mode does not exist</p> Source code in <code>prettyqt\\pdfwidgets\\pdfview.py</code> <pre><code>def set_page_mode(self, mode: PageModeStr):\n\"\"\"Set the page mode.\n\n    Args:\n        mode: page mode\n\n    Raises:\n        InvalidParamError: page mode does not exist\n    \"\"\"\n    if mode not in PAGE_MODE:\n        raise InvalidParamError(mode, PAGE_MODE)\n    self.setPageMode(PAGE_MODE[mode])\n</code></pre>"},{"location":"api/pdfwidgets.html#prettyqt.pdfwidgets.pdfview.PdfView.set_zoom_mode","title":"<code>set_zoom_mode(mode: ZoomModeStr)</code>","text":"<p>Set the zoom mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ZoomModeStr</code> <p>zoom mode</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>zoom mode does not exist</p> Source code in <code>prettyqt\\pdfwidgets\\pdfview.py</code> <pre><code>def set_zoom_mode(self, mode: ZoomModeStr):\n\"\"\"Set the zoom mode.\n\n    Args:\n        mode: zoom mode\n\n    Raises:\n        InvalidParamError: zoom mode does not exist\n    \"\"\"\n    if mode not in ZOOM_MODE:\n        raise InvalidParamError(mode, ZOOM_MODE)\n    self.setZoomMode(ZOOM_MODE[mode])\n</code></pre>"},{"location":"api/positioning.html","title":"positioning module","text":"<p>Positioning module.</p> <p>Contains QtPositioning-based classes</p>"},{"location":"api/positioning.html#prettyqt.positioning.GeoAreaMonitorSource","title":"<code>GeoAreaMonitorSource</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtPositioning.QGeoAreaMonitorSource</code></p> Source code in <code>prettyqt\\positioning\\geoareamonitorsource.py</code> <pre><code>class GeoAreaMonitorSource(core.ObjectMixin, QtPositioning.QGeoAreaMonitorSource):\n    def __str__(self):\n        return self.sourceName()\n\n    def __repr__(self):\n        return get_repr(self, self.name())\n\n    def get_error(self) -&gt; AreaMonitorFeatureStr:\n\"\"\"Return error type.\n\n        Returns:\n            error type\n        \"\"\"\n        return ERRORS.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource.GeoAreaMonitorSource.get_error","title":"<code>get_error() -&gt; AreaMonitorFeatureStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>AreaMonitorFeatureStr</code> <p>error type</p> Source code in <code>prettyqt\\positioning\\geoareamonitorsource.py</code> <pre><code>def get_error(self) -&gt; AreaMonitorFeatureStr:\n\"\"\"Return error type.\n\n    Returns:\n        error type\n    \"\"\"\n    return ERRORS.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.GeoPositionInfoSourceMixin","title":"<code>GeoPositionInfoSourceMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\positioning\\geopositioninfosource.py</code> <pre><code>class GeoPositionInfoSourceMixin(core.ObjectMixin):\n    def serialize_fields(self):\n        return dict(\n            minimum_update_interval=self.minimumUpdateInterval(),\n            source_name=self.sourceName(),\n            update_interval=self.updateInterval(),\n        )\n\n    def __str__(self):\n        return self.sourceName()\n\n    def __repr__(self):\n        return get_repr(self)\n\n    def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n\n        Returns:\n            error type\n        \"\"\"\n        return ERRORS.inverse[self.error()]\n\n    def set_preferred_positioning_methods(self, *methods: PositioningMethodStr):\n\"\"\"Set preferred positioning methods.\n\n        Args:\n            methods: positioning methods to use\n\n        Raises:\n            InvalidParamError: invalid positioning methods\n        \"\"\"\n        for item in methods:\n            if item not in POSITIONING_METHODS:\n                raise InvalidParamError(item, POSITIONING_METHODS)\n        flags = helpers.merge_flags(methods, POSITIONING_METHODS)\n        self.setPreferredPositioningMethods(flags)\n\n    def get_preferred_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of preferred positioning methods.\n\n        Returns:\n            list of preferred positioning methods\n        \"\"\"\n        return POSITIONING_METHODS.get_list(self.preferredPositioningMethods())\n\n    def get_supported_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of supported positioning methods.\n\n        Returns:\n            list of supported positioning methods\n        \"\"\"\n        return POSITIONING_METHODS.get_list(self.supportedPositioningMethods())\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\positioning\\geopositioninfosource.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n\n    Returns:\n        error type\n    \"\"\"\n    return ERRORS.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.get_preferred_positioning_methods","title":"<code>get_preferred_positioning_methods() -&gt; list[PositioningMethodStr]</code>","text":"<p>Return list of preferred positioning methods.</p> <p>Returns:</p> Type Description <code>list[PositioningMethodStr]</code> <p>list of preferred positioning methods</p> Source code in <code>prettyqt\\positioning\\geopositioninfosource.py</code> <pre><code>def get_preferred_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of preferred positioning methods.\n\n    Returns:\n        list of preferred positioning methods\n    \"\"\"\n    return POSITIONING_METHODS.get_list(self.preferredPositioningMethods())\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.get_supported_positioning_methods","title":"<code>get_supported_positioning_methods() -&gt; list[PositioningMethodStr]</code>","text":"<p>Return list of supported positioning methods.</p> <p>Returns:</p> Type Description <code>list[PositioningMethodStr]</code> <p>list of supported positioning methods</p> Source code in <code>prettyqt\\positioning\\geopositioninfosource.py</code> <pre><code>def get_supported_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of supported positioning methods.\n\n    Returns:\n        list of supported positioning methods\n    \"\"\"\n    return POSITIONING_METHODS.get_list(self.supportedPositioningMethods())\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.set_preferred_positioning_methods","title":"<code>set_preferred_positioning_methods(*methods: PositioningMethodStr)</code>","text":"<p>Set preferred positioning methods.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>PositioningMethodStr</code> <p>positioning methods to use</p> <code>()</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid positioning methods</p> Source code in <code>prettyqt\\positioning\\geopositioninfosource.py</code> <pre><code>def set_preferred_positioning_methods(self, *methods: PositioningMethodStr):\n\"\"\"Set preferred positioning methods.\n\n    Args:\n        methods: positioning methods to use\n\n    Raises:\n        InvalidParamError: invalid positioning methods\n    \"\"\"\n    for item in methods:\n        if item not in POSITIONING_METHODS:\n            raise InvalidParamError(item, POSITIONING_METHODS)\n    flags = helpers.merge_flags(methods, POSITIONING_METHODS)\n    self.setPreferredPositioningMethods(flags)\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.GeoSatelliteInfo","title":"<code>GeoSatelliteInfo</code>","text":"<p>         Bases: <code>QtPositioning.QGeoSatelliteInfo</code></p> Source code in <code>prettyqt\\positioning\\geosatelliteinfo.py</code> <pre><code>class GeoSatelliteInfo(QtPositioning.QGeoSatelliteInfo):\n    def __getitem__(self, index: AttributeStr):\n        return self.attribute(ATTRIBUTE[index])\n\n    def __setitem__(self, index: AttributeStr, value: float):\n        self.setAttribute(ATTRIBUTE[index], value)\n\n    def __delitem__(self, index: AttributeStr):\n        self.removeAttribute(ATTRIBUTE[index])\n\n    def __contains__(self, value: AttributeStr):\n        return self.hasAttribute(ATTRIBUTE[value])\n\n    def __int__(self):\n        return self.satelliteIdentifier()\n\n    def set_satellite_system(self, system: SatelliteSystemStr):\n\"\"\"Set satellite system.\n\n        Args:\n            system: satellite system to use\n\n        Raises:\n            InvalidParamError: invalid system\n        \"\"\"\n        if system not in SATELLITE_SYSTEMS:\n            raise InvalidParamError(system, SATELLITE_SYSTEMS)\n        self.setSatelliteSystem(SATELLITE_SYSTEMS[system])\n\n    def get_satellite_system(self) -&gt; SatelliteSystemStr:\n\"\"\"Return satellite system.\n\n        Returns:\n            satellite system\n        \"\"\"\n        return SATELLITE_SYSTEMS.inverse[self.satelliteSystem()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.get_satellite_system","title":"<code>get_satellite_system() -&gt; SatelliteSystemStr</code>","text":"<p>Return satellite system.</p> <p>Returns:</p> Type Description <code>SatelliteSystemStr</code> <p>satellite system</p> Source code in <code>prettyqt\\positioning\\geosatelliteinfo.py</code> <pre><code>def get_satellite_system(self) -&gt; SatelliteSystemStr:\n\"\"\"Return satellite system.\n\n    Returns:\n        satellite system\n    \"\"\"\n    return SATELLITE_SYSTEMS.inverse[self.satelliteSystem()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.set_satellite_system","title":"<code>set_satellite_system(system: SatelliteSystemStr)</code>","text":"<p>Set satellite system.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>SatelliteSystemStr</code> <p>satellite system to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid system</p> Source code in <code>prettyqt\\positioning\\geosatelliteinfo.py</code> <pre><code>def set_satellite_system(self, system: SatelliteSystemStr):\n\"\"\"Set satellite system.\n\n    Args:\n        system: satellite system to use\n\n    Raises:\n        InvalidParamError: invalid system\n    \"\"\"\n    if system not in SATELLITE_SYSTEMS:\n        raise InvalidParamError(system, SATELLITE_SYSTEMS)\n    self.setSatelliteSystem(SATELLITE_SYSTEMS[system])\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.GeoSatelliteInfoSource","title":"<code>GeoSatelliteInfoSource</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtPositioning.QGeoSatelliteInfoSource</code></p> Source code in <code>prettyqt\\positioning\\geosatelliteinfosource.py</code> <pre><code>class GeoSatelliteInfoSource(core.ObjectMixin, QtPositioning.QGeoSatelliteInfoSource):\n    def serialize_fields(self):\n        return dict(\n            minimum_update_interval=self.minimumUpdateInterval(),\n            update_interval=self.updateInterval(),\n        )\n\n    def __str__(self):\n        return self.sourceName()\n\n    def __repr__(self):\n        return get_repr(self)\n\n    def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n\n        Returns:\n            error type\n        \"\"\"\n        return ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource.GeoSatelliteInfoSource.get_error","title":"<code>get_error() -&gt; ErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>error type</p> Source code in <code>prettyqt\\positioning\\geosatelliteinfosource.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n\n    Returns:\n        error type\n    \"\"\"\n    return ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/qml.html","title":"qml module","text":"<p>Qml module.</p> <p>Contains QtQml-based classes</p>"},{"location":"api/qml.html#prettyqt.qml.JSValue","title":"<code>JSValue</code>","text":"<p>         Bases: <code>QtQml.QJSValue</code></p> Source code in <code>prettyqt\\qml\\jsvalue.py</code> <pre><code>class JSValue(QtQml.QJSValue):\n    def __repr__(self):\n        return get_repr(self, self.toVariant())\n\n    def __len__(self):\n        return self.property(\"length\").toVariant()\n\n    def __getitem__(self, index: int | str):\n        return self.property(index).toVariant()\n\n    def __delitem__(self, index: str):\n        self.deleteProperty(index)\n\n    def __setitem__(self, index: int | str, value):\n        self.setProperty(index, value)\n\n    def __iter__(self):\n        iterator = qml.JSValueIterator(self)\n        return iter(list(iterator))\n\n    def __contains__(self, index: str):\n        return self.hasProperty(index)\n\n    def __call__(self, *args) -&gt; JSValue:\n        result = self.call(args)\n        return JSValue(result)\n\n    def get_value(self):\n        return self.toVariant()\n\n    def get_error_type(self) -&gt; ErrorTypeStr | None:\n        error_type = self.errorType()\n        return ERROR_TYPES.inverse.get(error_type)\n\n    @classmethod\n    def from_object(cls, obj, jsengine: QtQml.QJSEngine) -&gt; JSValue:\n\"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\"\n        match obj:\n            case None:\n                return cls()\n            case list() | tuple():\n                length = len(obj)\n                array = JSValue(jsengine.newArray(length))\n                for i, v in enumerate(obj):\n                    array.setProperty(i, cls.from_object(v, jsengine))\n                return array\n            case dict():\n                array = JSValue(jsengine.newArray())\n                for k, v in obj.items():\n                    array.setProperty(k, cls.from_object(v, jsengine))\n                return array\n            case _:\n                try:\n                    return cls(obj)\n                except TypeError:\n                    logger.debug(f\"unknown type: {str(obj)}\")\n                    return cls()\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.jsvalue.JSValue.from_object","title":"<code>from_object(obj, jsengine: QtQml.QJSEngine) -&gt; JSValue</code>  <code>classmethod</code>","text":"<p>Convert any python object into a QJSValue (must happen in GUI thread).</p> Source code in <code>prettyqt\\qml\\jsvalue.py</code> <pre><code>@classmethod\ndef from_object(cls, obj, jsengine: QtQml.QJSEngine) -&gt; JSValue:\n\"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\"\n    match obj:\n        case None:\n            return cls()\n        case list() | tuple():\n            length = len(obj)\n            array = JSValue(jsengine.newArray(length))\n            for i, v in enumerate(obj):\n                array.setProperty(i, cls.from_object(v, jsengine))\n            return array\n        case dict():\n            array = JSValue(jsengine.newArray())\n            for k, v in obj.items():\n                array.setProperty(k, cls.from_object(v, jsengine))\n            return array\n        case _:\n            try:\n                return cls(obj)\n            except TypeError:\n                logger.debug(f\"unknown type: {str(obj)}\")\n                return cls()\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.QmlEngineMixin","title":"<code>QmlEngineMixin</code>","text":"<p>         Bases: <code>qml.JSEngineMixin</code></p> Source code in <code>prettyqt\\qml\\qmlengine.py</code> <pre><code>class QmlEngineMixin(qml.JSEngineMixin):\n    def set_object_ownership(self, obj: QtCore.QObject, mode: ObjectOwnershipStr):\n\"\"\"Set the object ownership.\n\n        Args:\n            obj: object to set ownership for\n            mode: object ownership to use\n\n        Raises:\n            InvalidParamError: invalid object ownership\n        \"\"\"\n        if mode not in OBJECT_OWNERSHIP:\n            raise InvalidParamError(mode, OBJECT_OWNERSHIP)\n        self.setObjectOwnership(obj, OBJECT_OWNERSHIP[mode])\n\n    def get_object_ownership(self, obj: QtCore.QObject) -&gt; ObjectOwnershipStr:\n\"\"\"Return object ownership.\n\n        Returns:\n            object ownership\n        \"\"\"\n        return OBJECT_OWNERSHIP.inverse[self.objectOwnership(obj)]\n\n    def add_import_path(self, path: datatypes.PathType):\n        self.addImportPath(os.fspath(path))\n\n    def add_plugin_path(self, path: datatypes.PathType):\n        self.addPluginPath(os.fspath(path))\n\n    def get_plugin_paths(self) -&gt; list[pathlib.Path]:\n        return [pathlib.Path(p) for p in self.pluginPathList()]\n\n    def get_import_paths(self) -&gt; list[pathlib.Path]:\n        return [pathlib.Path(p) for p in self.importPathList()]\n\n    def set_base_url(self, url: str | QtCore.QUrl):\n        if isinstance(url, str):\n            url = QtCore.QUrl(url)\n        self.setBaseUrl(url)\n\n    def get_base_url(self) -&gt; core.Url:\n        return core.Url(self.baseUrl())\n\n    def set_offline_storage_path(self, path: datatypes.PathType):\n        self.setOfflineStoragePath(os.fspath(path))\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngineMixin.get_object_ownership","title":"<code>get_object_ownership(obj: QtCore.QObject) -&gt; ObjectOwnershipStr</code>","text":"<p>Return object ownership.</p> <p>Returns:</p> Type Description <code>ObjectOwnershipStr</code> <p>object ownership</p> Source code in <code>prettyqt\\qml\\qmlengine.py</code> <pre><code>def get_object_ownership(self, obj: QtCore.QObject) -&gt; ObjectOwnershipStr:\n\"\"\"Return object ownership.\n\n    Returns:\n        object ownership\n    \"\"\"\n    return OBJECT_OWNERSHIP.inverse[self.objectOwnership(obj)]\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngineMixin.set_object_ownership","title":"<code>set_object_ownership(obj: QtCore.QObject, mode: ObjectOwnershipStr)</code>","text":"<p>Set the object ownership.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>QtCore.QObject</code> <p>object to set ownership for</p> required <code>mode</code> <code>ObjectOwnershipStr</code> <p>object ownership to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid object ownership</p> Source code in <code>prettyqt\\qml\\qmlengine.py</code> <pre><code>def set_object_ownership(self, obj: QtCore.QObject, mode: ObjectOwnershipStr):\n\"\"\"Set the object ownership.\n\n    Args:\n        obj: object to set ownership for\n        mode: object ownership to use\n\n    Raises:\n        InvalidParamError: invalid object ownership\n    \"\"\"\n    if mode not in OBJECT_OWNERSHIP:\n        raise InvalidParamError(mode, OBJECT_OWNERSHIP)\n    self.setObjectOwnership(obj, OBJECT_OWNERSHIP[mode])\n</code></pre>"},{"location":"api/qthelp.html","title":"qthelp module","text":"<p>qthelp module.</p> <p>contains QtHelp-based classes</p>"},{"location":"api/quick.html","title":"quick module","text":"<p>quick module.</p> <p>contains QtQuick-based classes</p>"},{"location":"api/quick.html#prettyqt.quick.QuickItemMixin","title":"<code>QuickItemMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>qml.QmlParserStatusMixin</code></p> Source code in <code>prettyqt\\quick\\quickitem.py</code> <pre><code>class QuickItemMixin(core.ObjectMixin, qml.QmlParserStatusMixin):\n    def get_children_rect(self) -&gt; core.RectF:\n        return core.RectF(self.childrenRect())\n\n    def get_cursor(self) -&gt; gui.Cursor:\n        return gui.Cursor(self.cursor())\n\n    def get_flags(self):\n        pass\n\n    def set_transform_origin(self, origin: TransformOriginStr):\n\"\"\"Set the origin point around which scale and rotation transform.\n\n        The default is \"center\".\n\n        Args:\n            origin: transform origin to use\n\n        Raises:\n            InvalidParamError: transform origin does not exist\n        \"\"\"\n        if origin not in TRANSFORM_ORIGIN:\n            raise InvalidParamError(origin, TRANSFORM_ORIGIN)\n        self.setTransformOrigin(TRANSFORM_ORIGIN[origin])\n\n    def get_transform_origin(self) -&gt; TransformOriginStr:\n\"\"\"Return the render type of text-like elements in Qt Quick.\n\n        Returns:\n            transform origin\n        \"\"\"\n        return TRANSFORM_ORIGIN.inverse[self.transformOrigin()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItemMixin.get_transform_origin","title":"<code>get_transform_origin() -&gt; TransformOriginStr</code>","text":"<p>Return the render type of text-like elements in Qt Quick.</p> <p>Returns:</p> Type Description <code>TransformOriginStr</code> <p>transform origin</p> Source code in <code>prettyqt\\quick\\quickitem.py</code> <pre><code>def get_transform_origin(self) -&gt; TransformOriginStr:\n\"\"\"Return the render type of text-like elements in Qt Quick.\n\n    Returns:\n        transform origin\n    \"\"\"\n    return TRANSFORM_ORIGIN.inverse[self.transformOrigin()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItemMixin.set_transform_origin","title":"<code>set_transform_origin(origin: TransformOriginStr)</code>","text":"<p>Set the origin point around which scale and rotation transform.</p> <p>The default is \"center\".</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>TransformOriginStr</code> <p>transform origin to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>transform origin does not exist</p> Source code in <code>prettyqt\\quick\\quickitem.py</code> <pre><code>def set_transform_origin(self, origin: TransformOriginStr):\n\"\"\"Set the origin point around which scale and rotation transform.\n\n    The default is \"center\".\n\n    Args:\n        origin: transform origin to use\n\n    Raises:\n        InvalidParamError: transform origin does not exist\n    \"\"\"\n    if origin not in TRANSFORM_ORIGIN:\n        raise InvalidParamError(origin, TRANSFORM_ORIGIN)\n    self.setTransformOrigin(TRANSFORM_ORIGIN[origin])\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.QuickPaintedItem","title":"<code>QuickPaintedItem</code>","text":"<p>         Bases: <code>quick.QuickItemMixin</code>, <code>QtQuick.QQuickPaintedItem</code></p> Source code in <code>prettyqt\\quick\\quickpainteditem.py</code> <pre><code>class QuickPaintedItem(quick.QuickItemMixin, QtQuick.QQuickPaintedItem):\n    def get_fill_color(self) -&gt; gui.Color:\n        return gui.Color(self.fillColor())\n\n    def get_texture_size(self) -&gt; core.Size:\n        return core.Size(self.textureSize())\n\n    def set_render_target(self, target: RenderTargetStr):\n\"\"\"Set the render target.\n\n        Args:\n            target: render target to use\n\n        Raises:\n            InvalidParamError: render target does not exist\n        \"\"\"\n        if target not in RENDER_TARGET:\n            raise InvalidParamError(target, RENDER_TARGET)\n        self.setRenderTarget(RENDER_TARGET[target])\n\n    def get_render_target(self) -&gt; RenderTargetStr:\n\"\"\"Return the render target.\n\n        Returns:\n            render target\n        \"\"\"\n        return RENDER_TARGET.inverse[self.renderTarget()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.get_render_target","title":"<code>get_render_target() -&gt; RenderTargetStr</code>","text":"<p>Return the render target.</p> <p>Returns:</p> Type Description <code>RenderTargetStr</code> <p>render target</p> Source code in <code>prettyqt\\quick\\quickpainteditem.py</code> <pre><code>def get_render_target(self) -&gt; RenderTargetStr:\n\"\"\"Return the render target.\n\n    Returns:\n        render target\n    \"\"\"\n    return RENDER_TARGET.inverse[self.renderTarget()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.set_render_target","title":"<code>set_render_target(target: RenderTargetStr)</code>","text":"<p>Set the render target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>RenderTargetStr</code> <p>render target to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>render target does not exist</p> Source code in <code>prettyqt\\quick\\quickpainteditem.py</code> <pre><code>def set_render_target(self, target: RenderTargetStr):\n\"\"\"Set the render target.\n\n    Args:\n        target: render target to use\n\n    Raises:\n        InvalidParamError: render target does not exist\n    \"\"\"\n    if target not in RENDER_TARGET:\n        raise InvalidParamError(target, RENDER_TARGET)\n    self.setRenderTarget(RENDER_TARGET[target])\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.QuickWindow","title":"<code>QuickWindow</code>","text":"<p>         Bases: <code>gui.WindowMixin</code>, <code>QtQuick.QQuickWindow</code></p> Source code in <code>prettyqt\\quick\\quickwindow.py</code> <pre><code>class QuickWindow(gui.WindowMixin, QtQuick.QQuickWindow):\n    def create_texture_from_image(self, image: QtGui.QImage, **kwargs):\n        flag = self.CreateTextureOption(0)\n        for key, val in kwargs.items():\n            if val is True:\n                v = CREATE_TEXTURE_OPTION[key]\n                flag |= v\n        return self.createTextureFromImage(image, flag)  # type: ignore\n\n    def grab_window(self) -&gt; gui.Image:\n        return gui.Image(self.grabWindow())\n\n    def get_color(self) -&gt; gui.Color:\n        return gui.Color(self.color())\n\n    @staticmethod\n    def set_text_render_type(typ: TextRenderTypeStr):\n\"\"\"Set the default render type of text-like elements in Qt Quick.\n\n        Note: setting the render type will only affect elements created afterwards;\n        the render type of existing elements will not be modified.\n\n        Args:\n            typ: text render type to use\n\n        Raises:\n            InvalidParamError: text render type does not exist\n        \"\"\"\n        if typ not in TEXT_RENDER_TYPE:\n            raise InvalidParamError(typ, TEXT_RENDER_TYPE)\n        QuickWindow.setTextRenderType(TEXT_RENDER_TYPE[typ])\n\n    @staticmethod\n    def get_text_render_type() -&gt; TextRenderTypeStr:\n\"\"\"Return the render type of text-like elements in Qt Quick.\n\n        Returns:\n            text render type\n        \"\"\"\n        return TEXT_RENDER_TYPE.inverse[QuickWindow.textRenderType()]\n\n    @contextlib.contextmanager\n    def external_commands(self):\n        self.beginExternalCommands()\n        yield self\n        self.endExternalCommands()\n\n    def schedule_render_job(self, job: QtCore.QRunnable, render_stage: RenderStageStr):\n        if render_stage not in RENDER_STAGE:\n            raise InvalidParamError(render_stage, RENDER_STAGE)\n        self.scheduleRenderJob(job, RENDER_STAGE[render_stage])\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow.get_text_render_type","title":"<code>get_text_render_type() -&gt; TextRenderTypeStr</code>  <code>staticmethod</code>","text":"<p>Return the render type of text-like elements in Qt Quick.</p> <p>Returns:</p> Type Description <code>TextRenderTypeStr</code> <p>text render type</p> Source code in <code>prettyqt\\quick\\quickwindow.py</code> <pre><code>@staticmethod\ndef get_text_render_type() -&gt; TextRenderTypeStr:\n\"\"\"Return the render type of text-like elements in Qt Quick.\n\n    Returns:\n        text render type\n    \"\"\"\n    return TEXT_RENDER_TYPE.inverse[QuickWindow.textRenderType()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow.set_text_render_type","title":"<code>set_text_render_type(typ: TextRenderTypeStr)</code>  <code>staticmethod</code>","text":"<p>Set the default render type of text-like elements in Qt Quick.</p> <p>Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TextRenderTypeStr</code> <p>text render type to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>text render type does not exist</p> Source code in <code>prettyqt\\quick\\quickwindow.py</code> <pre><code>@staticmethod\ndef set_text_render_type(typ: TextRenderTypeStr):\n\"\"\"Set the default render type of text-like elements in Qt Quick.\n\n    Note: setting the render type will only affect elements created afterwards;\n    the render type of existing elements will not be modified.\n\n    Args:\n        typ: text render type to use\n\n    Raises:\n        InvalidParamError: text render type does not exist\n    \"\"\"\n    if typ not in TEXT_RENDER_TYPE:\n        raise InvalidParamError(typ, TEXT_RENDER_TYPE)\n    QuickWindow.setTextRenderType(TEXT_RENDER_TYPE[typ])\n</code></pre>"},{"location":"api/svg.html","title":"svg module","text":"<p>svg module.</p> <p>contains QtSvg-based classes</p>"},{"location":"api/svg.html#prettyqt.svg.SvgRenderer","title":"<code>SvgRenderer</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtSvg.QSvgRenderer</code></p> Source code in <code>prettyqt\\svg\\svgrenderer.py</code> <pre><code>class SvgRenderer(core.ObjectMixin, QtSvg.QSvgRenderer):\n    def load_file(self, path: datatypes.PathType):\n        result = self.load(os.fspath(path))\n        if not result:\n            raise ValueError(\"invalid path\")\n\n    def set_aspect_ratio_mode(self, mode: constants.AspectRatioModeStr):\n\"\"\"Set the aspect ratio mode.\n\n        Args:\n            mode: aspect ratio mode\n\n        Raises:\n            InvalidParamError: aspect ratio mode does not exist\n        \"\"\"\n        if mode not in constants.ASPECT_RATIO_MODE:\n            raise InvalidParamError(mode, constants.ASPECT_RATIO_MODE)\n        self.setAspectRatioMode(constants.ASPECT_RATIO_MODE[mode])\n\n    def get_aspect_ratio_mode(self) -&gt; constants.AspectRatioModeStr:\n\"\"\"Return current aspect ratio mode.\n\n        Returns:\n            aspect ratio mode\n        \"\"\"\n        return constants.ASPECT_RATIO_MODE.inverse[self.aspectRatioMode()]\n</code></pre>"},{"location":"api/svg.html#prettyqt.svg.svgrenderer.SvgRenderer.get_aspect_ratio_mode","title":"<code>get_aspect_ratio_mode() -&gt; constants.AspectRatioModeStr</code>","text":"<p>Return current aspect ratio mode.</p> <p>Returns:</p> Type Description <code>constants.AspectRatioModeStr</code> <p>aspect ratio mode</p> Source code in <code>prettyqt\\svg\\svgrenderer.py</code> <pre><code>def get_aspect_ratio_mode(self) -&gt; constants.AspectRatioModeStr:\n\"\"\"Return current aspect ratio mode.\n\n    Returns:\n        aspect ratio mode\n    \"\"\"\n    return constants.ASPECT_RATIO_MODE.inverse[self.aspectRatioMode()]\n</code></pre>"},{"location":"api/svg.html#prettyqt.svg.svgrenderer.SvgRenderer.set_aspect_ratio_mode","title":"<code>set_aspect_ratio_mode(mode: constants.AspectRatioModeStr)</code>","text":"<p>Set the aspect ratio mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.AspectRatioModeStr</code> <p>aspect ratio mode</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>aspect ratio mode does not exist</p> Source code in <code>prettyqt\\svg\\svgrenderer.py</code> <pre><code>def set_aspect_ratio_mode(self, mode: constants.AspectRatioModeStr):\n\"\"\"Set the aspect ratio mode.\n\n    Args:\n        mode: aspect ratio mode\n\n    Raises:\n        InvalidParamError: aspect ratio mode does not exist\n    \"\"\"\n    if mode not in constants.ASPECT_RATIO_MODE:\n        raise InvalidParamError(mode, constants.ASPECT_RATIO_MODE)\n    self.setAspectRatioMode(constants.ASPECT_RATIO_MODE[mode])\n</code></pre>"},{"location":"api/syntaxhighlighters.html","title":"syntaxhighlighters module","text":"<p>syntaxhighlighters module.</p> <p>contains some custom syntax highlighers</p>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.JsonHighlighter","title":"<code>JsonHighlighter</code>","text":"<p>         Bases: <code>gui.SyntaxHighlighter</code></p> Source code in <code>prettyqt\\syntaxhighlighters\\jsonhighlighter.py</code> <pre><code>class JsonHighlighter(gui.SyntaxHighlighter):\n    def highlightBlock(self, text: str):\n\"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\"\n        for m in BRACKETS.finditer(text):\n            self.setFormat(m.span()[0], m.span()[1] - m.span()[0], SYMBOL_FORMAT)\n\n        text.replace('\\\\\"', \"  \")\n        for m in REGEXP1.finditer(text):\n            self.setFormat(m.span()[0], m.span()[1] - m.span()[0], NAME_FORMAT)\n        for m in REGEXP2.finditer(text):\n            self.setFormat(m.span()[0], m.span()[1] - m.span()[0], VALUE_FORMAT)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter.highlightBlock","title":"<code>highlightBlock(text: str)</code>","text":"<p>Highlight a block of code using the rules outlined in the Constructor.</p> Source code in <code>prettyqt\\syntaxhighlighters\\jsonhighlighter.py</code> <pre><code>def highlightBlock(self, text: str):\n\"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\"\n    for m in BRACKETS.finditer(text):\n        self.setFormat(m.span()[0], m.span()[1] - m.span()[0], SYMBOL_FORMAT)\n\n    text.replace('\\\\\"', \"  \")\n    for m in REGEXP1.finditer(text):\n        self.setFormat(m.span()[0], m.span()[1] - m.span()[0], NAME_FORMAT)\n    for m in REGEXP2.finditer(text):\n        self.setFormat(m.span()[0], m.span()[1] - m.span()[0], VALUE_FORMAT)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.PygmentsHighlighter","title":"<code>PygmentsHighlighter</code>","text":"<p>         Bases: <code>gui.SyntaxHighlighter</code></p> <p>Syntax highlighter that uses Pygments for parsing.</p> Source code in <code>prettyqt\\syntaxhighlighters\\pygmentshighlighter.py</code> <pre><code>class PygmentsHighlighter(gui.SyntaxHighlighter):\n\"\"\"Syntax highlighter that uses Pygments for parsing.\"\"\"\n\n    # ---------------------------------------------------------------------------\n    #  \"QSyntaxHighlighter\" interface\n    # ---------------------------------------------------------------------------\n\n    def __init__(\n        self,\n        parent: QtGui.QTextDocument,\n        lexer: str,\n        style: None | StyleStr | styles.Style = None,\n    ):\n        super().__init__(parent)\n        self._document = self.document()\n        self._formatter = html.HtmlFormatter(nowrap=True)\n        self.set_style(style)\n        if lexer == \"regex\":\n            self._lexer = lexers.load_lexer_from_file(str(paths.RE_LEXER_PATH))\n        else:\n            self._lexer = lexers.get_lexer_by_name(lexer)\n\n    def __repr__(self):\n        return get_repr(self, lexer=self._lexer.aliases[0])\n\n    def highlightBlock(self, string):\n\"\"\"Highlight a block of text.\"\"\"\n        prev_data = self.currentBlock().previous().userData()\n        if prev_data is not None:\n            self._lexer._saved_state_stack = prev_data.syntax_stack\n        elif hasattr(self._lexer, \"_saved_state_stack\"):\n            del self._lexer._saved_state_stack\n\n        # Lex the text using Pygments\n        index = 0\n        for token, text in self._lexer.get_tokens(string):\n            length = qstring_length(text)\n            self.setFormat(index, length, self._get_format(token))\n            index += length\n\n        if hasattr(self._lexer, \"_saved_state_stack\"):\n            data = gui.TextBlockUserData(syntax_stack=self._lexer._saved_state_stack)\n            self.currentBlock().setUserData(data)\n            # Clean up for the next go-round.\n            del self._lexer._saved_state_stack\n\n    # ---------------------------------------------------------------------------\n    # \"PygmentsHighlighter\" interface\n    # ---------------------------------------------------------------------------\n\n    def set_style(self, style: None | StyleStr | styles.Style):\n        if style is None:\n            style = styles.get_style_by_name(\"default\")\n        elif isinstance(style, str):\n            style = styles.get_style_by_name(style)\n        self._style = style\n        self._clear_caches()\n\n    def set_style_sheet(self, stylesheet: str):\n\"\"\"Sets a CSS stylesheet.\n\n        The classes in the stylesheet should correspond to those generated by:\n\n            pygmentize -S &lt;style&gt; -f html\n\n        Note that \"set_style\" and \"set_style_sheet\" completely override each\n        other, i.e. they cannot be used in conjunction.\n        \"\"\"\n        self._document.setDefaultStyleSheet(stylesheet)\n        self._style = None\n        self._clear_caches()\n\n    # ---------------------------------------------------------------------------\n    # Protected interface\n    # ---------------------------------------------------------------------------\n\n    def _clear_caches(self):\n\"\"\"Clear caches for brushes and formats.\"\"\"\n        _get_brush.cache_clear()\n        self._get_format.cache_clear()\n\n    @functools.cache  # noqa: B019\n    def _get_format(self, token: str) -&gt; QtGui.QTextCharFormat:\n\"\"\"Returns a QTextCharFormat for token or None.\"\"\"\n        if self._style is None:\n            return self._get_format_from_document(token, self._document)\n        else:\n            return _get_format_from_style(token, self._style)\n\n    def _get_format_from_document(\n        self, token: str, document: QtGui.QTextDocument\n    ) -&gt; QtGui.QTextCharFormat:\n\"\"\"Return a QTextCharFormat for token from document.\"\"\"\n        code, html = next(self._formatter._format_lines([(token, \"dummy\")]))\n        document.setHtml(html)\n        return gui.TextCursor(document).charFormat()\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.highlightBlock","title":"<code>highlightBlock(string)</code>","text":"<p>Highlight a block of text.</p> Source code in <code>prettyqt\\syntaxhighlighters\\pygmentshighlighter.py</code> <pre><code>def highlightBlock(self, string):\n\"\"\"Highlight a block of text.\"\"\"\n    prev_data = self.currentBlock().previous().userData()\n    if prev_data is not None:\n        self._lexer._saved_state_stack = prev_data.syntax_stack\n    elif hasattr(self._lexer, \"_saved_state_stack\"):\n        del self._lexer._saved_state_stack\n\n    # Lex the text using Pygments\n    index = 0\n    for token, text in self._lexer.get_tokens(string):\n        length = qstring_length(text)\n        self.setFormat(index, length, self._get_format(token))\n        index += length\n\n    if hasattr(self._lexer, \"_saved_state_stack\"):\n        data = gui.TextBlockUserData(syntax_stack=self._lexer._saved_state_stack)\n        self.currentBlock().setUserData(data)\n        # Clean up for the next go-round.\n        del self._lexer._saved_state_stack\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style_sheet","title":"<code>set_style_sheet(stylesheet: str)</code>","text":"<p>Sets a CSS stylesheet.</p> The classes in the stylesheet should correspond to those generated by <p>pygmentize -S"},{"location":"api/webenginecore.html","title":"webenginecore module","text":"<p>Webenginewidgets module.</p> <p>contains QtWebEngineCore-based classes</p>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineDownloadRequest","title":"<code>WebEngineDownloadRequest</code>","text":"Source code in <code>prettyqt\\webenginecore\\webenginedownloadrequest.py</code> <pre><code>class WebEngineDownloadRequest:\n    def __init__(self, item: QtWebEngineCore.QWebEngineDownloadRequest):\n        self.item = item\n\n    def __getattr__(self, val):\n        return getattr(self.item, val)\n\n    def get_interrupt_reason(self) -&gt; DownloadInterruptReasonStr:\n        return DOWNLOAD_INTERRUPT_REASONS.inverse[self.item.interruptReason()]\n\n    def get_state(self) -&gt; DownloadStateStr:\n        return DOWNLOAD_STATE.inverse[self.item.state()]\n\n    def set_save_page_format(self, fmt: SavePageFormatStr):\n\"\"\"Set the save page format.\n\n        Args:\n            fmt: save page format for the layout\n\n        Raises:\n            InvalidParamError: save page format does not exist\n        \"\"\"\n        if fmt not in SAVE_PAGE_FORMAT:\n            raise InvalidParamError(fmt, SAVE_PAGE_FORMAT)\n        self.item.setSavePageFormat(SAVE_PAGE_FORMAT[fmt])\n\n    def get_save_page_format(self) -&gt; SavePageFormatStr:\n\"\"\"Return current save page format.\n\n        Returns:\n            Save page format\n        \"\"\"\n        return SAVE_PAGE_FORMAT.inverse[self.item.savePageFormat()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest.get_save_page_format","title":"<code>get_save_page_format() -&gt; SavePageFormatStr</code>","text":"<p>Return current save page format.</p> <p>Returns:</p> Type Description <code>SavePageFormatStr</code> <p>Save page format</p> Source code in <code>prettyqt\\webenginecore\\webenginedownloadrequest.py</code> <pre><code>def get_save_page_format(self) -&gt; SavePageFormatStr:\n\"\"\"Return current save page format.\n\n    Returns:\n        Save page format\n    \"\"\"\n    return SAVE_PAGE_FORMAT.inverse[self.item.savePageFormat()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest.set_save_page_format","title":"<code>set_save_page_format(fmt: SavePageFormatStr)</code>","text":"<p>Set the save page format.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>SavePageFormatStr</code> <p>save page format for the layout</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>save page format does not exist</p> Source code in <code>prettyqt\\webenginecore\\webenginedownloadrequest.py</code> <pre><code>def set_save_page_format(self, fmt: SavePageFormatStr):\n\"\"\"Set the save page format.\n\n    Args:\n        fmt: save page format for the layout\n\n    Raises:\n        InvalidParamError: save page format does not exist\n    \"\"\"\n    if fmt not in SAVE_PAGE_FORMAT:\n        raise InvalidParamError(fmt, SAVE_PAGE_FORMAT)\n    self.item.setSavePageFormat(SAVE_PAGE_FORMAT[fmt])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineHttpRequest","title":"<code>WebEngineHttpRequest</code>","text":"<p>         Bases: <code>QtWebEngineCore.QWebEngineHttpRequest</code></p> Source code in <code>prettyqt\\webenginecore\\webenginehttprequest.py</code> <pre><code>class WebEngineHttpRequest(QtWebEngineCore.QWebEngineHttpRequest):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.get_url()})\"\n\n    def set_headers(self, headers: dict[str, str]):\n        for k, v in headers.items():\n            self.setHeader(QtCore.QByteArray(k.encode()), QtCore.QByteArray(v.encode()))\n\n    def get_headers(self) -&gt; dict[str, str]:\n        return {h.data().decode(): self.header(h).data().decode() for h in self.headers()}\n\n    def set_url(self, url: datatypes.UrlType):\n        url = core.Url(url)\n        self.setUrl(url)\n\n    def get_url(self) -&gt; core.Url:\n        return core.Url(self.url())\n\n    def get_post_data(self) -&gt; str:\n        return self.postData().data().decode()\n\n    def set_method(self, method: MethodStr):\n\"\"\"Set method this WebEngine request is using.\n\n        Args:\n            method: method\n\n        Raises:\n            InvalidParamError: method does not exist\n        \"\"\"\n        if method not in METHODS:\n            raise InvalidParamError(method, METHODS)\n        self.setMethod(METHODS[method])\n\n    def get_method(self) -&gt; MethodStr:\n\"\"\"Get the method this WebEngine request is using.\n\n        Returns:\n            method\n        \"\"\"\n        return METHODS.inverse[self.method()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.get_method","title":"<code>get_method() -&gt; MethodStr</code>","text":"<p>Get the method this WebEngine request is using.</p> <p>Returns:</p> Type Description <code>MethodStr</code> <p>method</p> Source code in <code>prettyqt\\webenginecore\\webenginehttprequest.py</code> <pre><code>def get_method(self) -&gt; MethodStr:\n\"\"\"Get the method this WebEngine request is using.\n\n    Returns:\n        method\n    \"\"\"\n    return METHODS.inverse[self.method()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.set_method","title":"<code>set_method(method: MethodStr)</code>","text":"<p>Set method this WebEngine request is using.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>MethodStr</code> <p>method</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>method does not exist</p> Source code in <code>prettyqt\\webenginecore\\webenginehttprequest.py</code> <pre><code>def set_method(self, method: MethodStr):\n\"\"\"Set method this WebEngine request is using.\n\n    Args:\n        method: method\n\n    Raises:\n        InvalidParamError: method does not exist\n    \"\"\"\n    if method not in METHODS:\n        raise InvalidParamError(method, METHODS)\n    self.setMethod(METHODS[method])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEnginePage","title":"<code>WebEnginePage</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtWebEngineCore.QWebEnginePage</code></p> <p>A web engine page holds the HTML document contents, link history + actions.</p> Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>class WebEnginePage(core.ObjectMixin, QtWebEngineCore.QWebEnginePage):\n\"\"\"A web engine page holds the HTML document contents, link history + actions.\"\"\"\n\n    def serialize_fields(self):\n        return dict(\n            audio_muted=self.isAudioMuted(),\n            background_color=self.backgroundColor(),\n            # has_selection=self.hasSelection(),\n            lifecycle_state=self.get_lifecycle_state(),\n            # scroll_position=self.scrollPosition(),\n            url=core.Url(self.url()),\n            visible=self.isVisible(),\n            history=core.DataStream.create_bytearray(self.history()),\n            zoom_factor=self.zoomFactor(),\n        )\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        return None if icon.isNull() else gui.Icon(icon)\n\n    def set_url(self, url: datatypes.PathType | datatypes.UrlType):\n\"\"\"Set the url of the WebEnginePage.\n\n        Clears the Page and loads the URL.\n\n        Args:\n            url: URL to set\n        \"\"\"\n        if isinstance(url, os.PathLike):\n            url = core.Url.fromLocalFile(os.fspath(url))\n        elif isinstance(url, str):\n            url = core.Url(url)\n        self.setUrl(url)\n\n    def get_url(self) -&gt; core.Url:\n        return core.Url(self.url())\n\n    def get_icon_url(self) -&gt; core.Url:\n        return core.Url(self.iconUrl())\n\n    def get_requested_url(self) -&gt; core.Url:\n        return core.Url(self.requestedUrl())\n\n    def get_scroll_position(self) -&gt; core.PointF:\n        return core.PointF(self.scrollPosition())\n\n    def get_contents_size(self) -&gt; core.SizeF:\n        return core.SizeF(self.contentsSize())\n\n    def load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n\n        Loads the specified url and displays it.\n\n        Note: The Page remains the same until enough data has arrived\n        to display the new URL.\n\n        Args:\n            url: URL to load\n        \"\"\"\n        if isinstance(url, os.PathLike):\n            url = core.Url.fromLocalFile(os.fspath(url))\n        elif isinstance(url, str):\n            url = core.Url(url)\n        self.load(url)\n\n    def set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the Page.\n\n        Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n\n        Args:\n            zoom: Zoom factor\n        \"\"\"\n        self.setZoomFactor(zoom)\n\n    def find_text(\n        self,\n        string: str,\n        backward: bool = False,\n        case_sensitive: bool = False,\n        callback: Callable[[bool], None] | None = None,\n    ):\n\"\"\"Find text in the current page.\n\n        Finds the specified string, subString, in the page, using the given options.\n        The findTextFinished() signal is emitted when a string search is completed.\n\n        To clear the search highlight, just pass an empty string.\n\n        The resultCallback must take a boolean parameter.\n        It will be called with a value of true if the subString was found;\n        otherwise the callback value will be false.\n\n        Warning: It is guaranteed that the callback is always called,\n        but it might be done during page destruction. When WebEnginePage is deleted,\n        the callback is triggered with an invalid value and it is not safe to use\n        the corresponding QWebEnginePage or QWebEnginePage instance inside it.\n\n        Args:\n            string: string to search for\n            backward: search backwards\n            case_sensitive: case-sensitive search\n            callback: result callback\n        \"\"\"\n        if callback is None:\n\n            def do_nothing(x):\n                pass\n\n            callback = do_nothing\n        flag = QtWebEngineCore.QWebEnginePage.FindFlag(0)\n        if case_sensitive:\n            flag |= self.FindFlag.FindCaseSensitively\n        if backward:\n            flag |= self.FindFlag.FindBackward\n        self.findText(string, flag, callback)\n\n    def set_lifecycle_state(self, state: LifecycleStateStr):\n\"\"\"Set lifecycle state.\n\n        Args:\n            state: lifecycle state\n\n        Raises:\n            InvalidParamError: lifecycle state does not exist\n        \"\"\"\n        if state not in LIFECYCLE_STATE:\n            raise InvalidParamError(state, LIFECYCLE_STATE)\n        self.setLifecycleState(LIFECYCLE_STATE[state])\n\n    def get_lifecycle_state(self) -&gt; LifecycleStateStr:\n\"\"\"Get the current lifecycle state.\n\n        Returns:\n            lifecycle state\n        \"\"\"\n        return LIFECYCLE_STATE.inverse[self.lifecycleState()]\n\n    def trigger_action(self, action: WebActionStr, checked: bool = False):\n        self.triggerAction(WEB_ACTION[action], checked)\n\n    def set_feature_permission(\n        self,\n        url: datatypes.UrlType,\n        feature: FeatureStr,\n        policy: PermissionPolicyStr,\n    ):\n        url = core.Url(url)\n        self.setFeaturePermission(url, FEATURE[feature], PERMISSION_POLICY[policy])\n\n    def get_history(self) -&gt; webenginecore.WebEngineHistory:\n        hist = self.history()\n        return webenginecore.WebEngineHistory(hist)\n\n    def get_settings(self) -&gt; webenginecore.WebEngineSettings:\n        settings = self.settings()\n        return webenginecore.WebEngineSettings(settings)\n\n    def set_setting(\n        self,\n        setting_name: webenginecore.webenginesettings.WebAttributeStr,\n        value: bool,\n    ):\n        self.get_settings()[setting_name] = value\n\n    def get_setting(\n        self, setting_name: webenginecore.webenginesettings.WebAttributeStr\n    ) -&gt; bool:\n        return self.get_settings()[setting_name]\n\n    def get_scripts(self) -&gt; webenginecore.WebEngineScriptCollection:\n        return webenginecore.WebEngineScriptCollection(self.scripts())\n\n    def open_in_browser(self):\n        try:\n            webbrowser.open(self.getUrl().toString())\n        except ValueError as e:\n            logger.exception(e)\n\n    # def choose_files(\n    #     self,\n    #     mode: FileSelectionModeStr,\n    #     old_files: List[str],\n    #     mimetypes: List[str],\n    # ) -&gt; List[str]:\n    #     if mode not in FILE_SELECTION_MODE:\n    #         raise InvalidParamError(mode, FILE_SELECTION_MODE)\n    #     return self.chooseFiles(FILE_SELECTION_MODE[mode], old_files, mimetypes)\n\n    def mousedown(self, selector: str, btn: int = 0):\n\"\"\"Simulate a mousedown event on the targeted element.\n\n        :param selector: A CSS3 selector to targeted element.\n        :param btn: The number of mouse button.\n            0 - left button,\n            1 - middle button,\n            2 - right button\n        \"\"\"\n        return self.runJavaScript(\n            f\"\"\"\n            (function () {{\n                var element = document.querySelector({selector!r});\n                var evt = document.createEvent(\"MouseEvents\");\n                evt.initMouseEvent(\"mousedown\", true, true, window,\n                                   1, 1, 1, 1, 1, false, false, false, false,\n{btn!r}, element);\n                return element.dispatchEvent(evt);\n}})();\n        \"\"\"\n        )\n\n    def set_input_value(self, selector: str, value):\n\"\"\"Set the value of the input matched by given selector.\"\"\"\n        script = f'document.querySelector({selector!r}).setAttribute(\"value\", \"{value}\")'\n        self.runJavaScript(script)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.find_text","title":"<code>find_text(string: str, backward: bool = False, case_sensitive: bool = False, callback: Callable[[bool], None] | None = None)</code>","text":"<p>Find text in the current page.</p> <p>Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed.</p> <p>To clear the search highlight, just pass an empty string.</p> <p>The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false.</p> <p>Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>string to search for</p> required <code>backward</code> <code>bool</code> <p>search backwards</p> <code>False</code> <code>case_sensitive</code> <code>bool</code> <p>case-sensitive search</p> <code>False</code> <code>callback</code> <code>Callable[[bool], None] | None</code> <p>result callback</p> <code>None</code> Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def find_text(\n    self,\n    string: str,\n    backward: bool = False,\n    case_sensitive: bool = False,\n    callback: Callable[[bool], None] | None = None,\n):\n\"\"\"Find text in the current page.\n\n    Finds the specified string, subString, in the page, using the given options.\n    The findTextFinished() signal is emitted when a string search is completed.\n\n    To clear the search highlight, just pass an empty string.\n\n    The resultCallback must take a boolean parameter.\n    It will be called with a value of true if the subString was found;\n    otherwise the callback value will be false.\n\n    Warning: It is guaranteed that the callback is always called,\n    but it might be done during page destruction. When WebEnginePage is deleted,\n    the callback is triggered with an invalid value and it is not safe to use\n    the corresponding QWebEnginePage or QWebEnginePage instance inside it.\n\n    Args:\n        string: string to search for\n        backward: search backwards\n        case_sensitive: case-sensitive search\n        callback: result callback\n    \"\"\"\n    if callback is None:\n\n        def do_nothing(x):\n            pass\n\n        callback = do_nothing\n    flag = QtWebEngineCore.QWebEnginePage.FindFlag(0)\n    if case_sensitive:\n        flag |= self.FindFlag.FindCaseSensitively\n    if backward:\n        flag |= self.FindFlag.FindBackward\n    self.findText(string, flag, callback)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.get_lifecycle_state","title":"<code>get_lifecycle_state() -&gt; LifecycleStateStr</code>","text":"<p>Get the current lifecycle state.</p> <p>Returns:</p> Type Description <code>LifecycleStateStr</code> <p>lifecycle state</p> Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def get_lifecycle_state(self) -&gt; LifecycleStateStr:\n\"\"\"Get the current lifecycle state.\n\n    Returns:\n        lifecycle state\n    \"\"\"\n    return LIFECYCLE_STATE.inverse[self.lifecycleState()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.load_url","title":"<code>load_url(url: datatypes.UrlType | datatypes.PathType)</code>","text":"<p>Load the URL.</p> <p>Loads the specified url and displays it.</p> <p>Note: The Page remains the same until enough data has arrived to display the new URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.UrlType | datatypes.PathType</code> <p>URL to load</p> required Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n\n    Loads the specified url and displays it.\n\n    Note: The Page remains the same until enough data has arrived\n    to display the new URL.\n\n    Args:\n        url: URL to load\n    \"\"\"\n    if isinstance(url, os.PathLike):\n        url = core.Url.fromLocalFile(os.fspath(url))\n    elif isinstance(url, str):\n        url = core.Url(url)\n    self.load(url)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.mousedown","title":"<code>mousedown(selector: str, btn: int = 0)</code>","text":"<p>Simulate a mousedown event on the targeted element.</p> <p>:param selector: A CSS3 selector to targeted element. :param btn: The number of mouse button.     0 - left button,     1 - middle button,     2 - right button</p> Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def mousedown(self, selector: str, btn: int = 0):\n\"\"\"Simulate a mousedown event on the targeted element.\n\n    :param selector: A CSS3 selector to targeted element.\n    :param btn: The number of mouse button.\n        0 - left button,\n        1 - middle button,\n        2 - right button\n    \"\"\"\n    return self.runJavaScript(\n        f\"\"\"\n        (function () {{\n            var element = document.querySelector({selector!r});\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"mousedown\", true, true, window,\n                               1, 1, 1, 1, 1, false, false, false, false,\n{btn!r}, element);\n            return element.dispatchEvent(evt);\n}})();\n    \"\"\"\n    )\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_input_value","title":"<code>set_input_value(selector: str, value)</code>","text":"<p>Set the value of the input matched by given selector.</p> Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def set_input_value(self, selector: str, value):\n\"\"\"Set the value of the input matched by given selector.\"\"\"\n    script = f'document.querySelector({selector!r}).setAttribute(\"value\", \"{value}\")'\n    self.runJavaScript(script)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_lifecycle_state","title":"<code>set_lifecycle_state(state: LifecycleStateStr)</code>","text":"<p>Set lifecycle state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>LifecycleStateStr</code> <p>lifecycle state</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>lifecycle state does not exist</p> Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def set_lifecycle_state(self, state: LifecycleStateStr):\n\"\"\"Set lifecycle state.\n\n    Args:\n        state: lifecycle state\n\n    Raises:\n        InvalidParamError: lifecycle state does not exist\n    \"\"\"\n    if state not in LIFECYCLE_STATE:\n        raise InvalidParamError(state, LIFECYCLE_STATE)\n    self.setLifecycleState(LIFECYCLE_STATE[state])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_url","title":"<code>set_url(url: datatypes.PathType | datatypes.UrlType)</code>","text":"<p>Set the url of the WebEnginePage.</p> <p>Clears the Page and loads the URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.PathType | datatypes.UrlType</code> <p>URL to set</p> required Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def set_url(self, url: datatypes.PathType | datatypes.UrlType):\n\"\"\"Set the url of the WebEnginePage.\n\n    Clears the Page and loads the URL.\n\n    Args:\n        url: URL to set\n    \"\"\"\n    if isinstance(url, os.PathLike):\n        url = core.Url.fromLocalFile(os.fspath(url))\n    elif isinstance(url, str):\n        url = core.Url(url)\n    self.setUrl(url)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_zoom","title":"<code>set_zoom(zoom: float)</code>","text":"<p>Set the zoom factor for the Page.</p> <p>Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom factor</p> required Source code in <code>prettyqt\\webenginecore\\webenginepage.py</code> <pre><code>def set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the Page.\n\n    Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n\n    Args:\n        zoom: Zoom factor\n    \"\"\"\n    self.setZoomFactor(zoom)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineProfile","title":"<code>WebEngineProfile</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtWebEngineCore.QWebEngineProfile</code></p> Source code in <code>prettyqt\\webenginecore\\webengineprofile.py</code> <pre><code>class WebEngineProfile(core.ObjectMixin, QtWebEngineCore.QWebEngineProfile):\n    def set_persistent_cookie_policy(self, policy: PersistentCookiePolicyStr):\n\"\"\"Set the persistent cookie policy.\n\n        Args:\n            policy: persistent cookie policy\n\n        Raises:\n            InvalidParamError: Policy does not exist\n        \"\"\"\n        if policy not in PERSISTENT_COOKIE_POLICY:\n            raise InvalidParamError(policy, PERSISTENT_COOKIE_POLICY)\n        self.setPersistentCookiesPolicy(PERSISTENT_COOKIE_POLICY[policy])\n\n    def get_persistent_cookie_policy(self) -&gt; PersistentCookiePolicyStr:\n\"\"\"Return current persistent cookie policy.\n\n        Returns:\n            Persistent cookie policy\n        \"\"\"\n        return PERSISTENT_COOKIE_POLICY.inverse[self.persistentCookiesPolicy()]\n\n    def set_http_cache_type(self, typ: HttpCacheTypeStr):\n\"\"\"Set the http cache type.\n\n        Args:\n            typ: http cache type\n\n        Raises:\n            InvalidParamError: Cache type does not exist\n        \"\"\"\n        if typ not in HTTP_CACHE_TYPE:\n            raise InvalidParamError(typ, HTTP_CACHE_TYPE)\n        self.setHttpCacheType(HTTP_CACHE_TYPE[typ])\n\n    def get_http_cache_type(self) -&gt; HttpCacheTypeStr:\n\"\"\"Return current http cache type.\n\n        Returns:\n            Http cache type\n        \"\"\"\n        return HTTP_CACHE_TYPE.inverse[self.httpCacheType()]\n\n    def get_scripts(self) -&gt; webenginecore.WebEngineScriptCollection:\n        return webenginecore.WebEngineScriptCollection(self.scripts())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.get_http_cache_type","title":"<code>get_http_cache_type() -&gt; HttpCacheTypeStr</code>","text":"<p>Return current http cache type.</p> <p>Returns:</p> Type Description <code>HttpCacheTypeStr</code> <p>Http cache type</p> Source code in <code>prettyqt\\webenginecore\\webengineprofile.py</code> <pre><code>def get_http_cache_type(self) -&gt; HttpCacheTypeStr:\n\"\"\"Return current http cache type.\n\n    Returns:\n        Http cache type\n    \"\"\"\n    return HTTP_CACHE_TYPE.inverse[self.httpCacheType()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.get_persistent_cookie_policy","title":"<code>get_persistent_cookie_policy() -&gt; PersistentCookiePolicyStr</code>","text":"<p>Return current persistent cookie policy.</p> <p>Returns:</p> Type Description <code>PersistentCookiePolicyStr</code> <p>Persistent cookie policy</p> Source code in <code>prettyqt\\webenginecore\\webengineprofile.py</code> <pre><code>def get_persistent_cookie_policy(self) -&gt; PersistentCookiePolicyStr:\n\"\"\"Return current persistent cookie policy.\n\n    Returns:\n        Persistent cookie policy\n    \"\"\"\n    return PERSISTENT_COOKIE_POLICY.inverse[self.persistentCookiesPolicy()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.set_http_cache_type","title":"<code>set_http_cache_type(typ: HttpCacheTypeStr)</code>","text":"<p>Set the http cache type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>HttpCacheTypeStr</code> <p>http cache type</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>Cache type does not exist</p> Source code in <code>prettyqt\\webenginecore\\webengineprofile.py</code> <pre><code>def set_http_cache_type(self, typ: HttpCacheTypeStr):\n\"\"\"Set the http cache type.\n\n    Args:\n        typ: http cache type\n\n    Raises:\n        InvalidParamError: Cache type does not exist\n    \"\"\"\n    if typ not in HTTP_CACHE_TYPE:\n        raise InvalidParamError(typ, HTTP_CACHE_TYPE)\n    self.setHttpCacheType(HTTP_CACHE_TYPE[typ])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.set_persistent_cookie_policy","title":"<code>set_persistent_cookie_policy(policy: PersistentCookiePolicyStr)</code>","text":"<p>Set the persistent cookie policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>PersistentCookiePolicyStr</code> <p>persistent cookie policy</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>Policy does not exist</p> Source code in <code>prettyqt\\webenginecore\\webengineprofile.py</code> <pre><code>def set_persistent_cookie_policy(self, policy: PersistentCookiePolicyStr):\n\"\"\"Set the persistent cookie policy.\n\n    Args:\n        policy: persistent cookie policy\n\n    Raises:\n        InvalidParamError: Policy does not exist\n    \"\"\"\n    if policy not in PERSISTENT_COOKIE_POLICY:\n        raise InvalidParamError(policy, PERSISTENT_COOKIE_POLICY)\n    self.setPersistentCookiesPolicy(PERSISTENT_COOKIE_POLICY[policy])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineScript","title":"<code>WebEngineScript</code>","text":"<p>         Bases: <code>QtWebEngineCore.QWebEngineScript</code></p> Source code in <code>prettyqt\\webenginecore\\webenginescript.py</code> <pre><code>class WebEngineScript(QtWebEngineCore.QWebEngineScript):\n    def set_injection_point(self, point: InjectionPointStr):\n\"\"\"Set injection point.\n\n        Args:\n            point: injection point to use\n\n        Raises:\n            InvalidParamError: injection point does not exist\n        \"\"\"\n        if point not in INJECTION_POINT:\n            raise InvalidParamError(point, INJECTION_POINT)\n        self.setInjectionPoint(INJECTION_POINT[point])\n\n    def get_injection_point(self) -&gt; InjectionPointStr:\n\"\"\"Return injection point.\n\n        Returns:\n            injection point\n        \"\"\"\n        return INJECTION_POINT.inverse[self.injectionPoint()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript.WebEngineScript.get_injection_point","title":"<code>get_injection_point() -&gt; InjectionPointStr</code>","text":"<p>Return injection point.</p> <p>Returns:</p> Type Description <code>InjectionPointStr</code> <p>injection point</p> Source code in <code>prettyqt\\webenginecore\\webenginescript.py</code> <pre><code>def get_injection_point(self) -&gt; InjectionPointStr:\n\"\"\"Return injection point.\n\n    Returns:\n        injection point\n    \"\"\"\n    return INJECTION_POINT.inverse[self.injectionPoint()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript.WebEngineScript.set_injection_point","title":"<code>set_injection_point(point: InjectionPointStr)</code>","text":"<p>Set injection point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>InjectionPointStr</code> <p>injection point to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>injection point does not exist</p> Source code in <code>prettyqt\\webenginecore\\webenginescript.py</code> <pre><code>def set_injection_point(self, point: InjectionPointStr):\n\"\"\"Set injection point.\n\n    Args:\n        point: injection point to use\n\n    Raises:\n        InvalidParamError: injection point does not exist\n    \"\"\"\n    if point not in INJECTION_POINT:\n        raise InvalidParamError(point, INJECTION_POINT)\n    self.setInjectionPoint(INJECTION_POINT[point])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineSettings","title":"<code>WebEngineSettings</code>","text":"Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>class WebEngineSettings:\n    def __init__(self, item: QtWebEngineCore.QWebEngineSettings):\n        self.item = item\n\n    def __getattr__(self, val):\n        return getattr(self.item, val)\n\n    def __setitem__(self, index: WebAttributeStr, value: bool):\n        self.item.setAttribute(WEB_ATTRIBUTES[index], value)\n\n    def __getitem__(self, index: WebAttributeStr) -&gt; bool:\n        return self.item.testAttribute(WEB_ATTRIBUTES[index])\n\n    def __delitem__(self, index: WebAttributeStr):\n        return self.item.resetAttribute(WEB_ATTRIBUTES[index])\n\n    def __iter__(self):\n        return iter(self.keys())\n\n    def keys(self):\n        return WEB_ATTRIBUTES.keys()\n\n    def set_unknown_url_scheme_policy(self, policy: UnknownUrlSchemePolicyStr):\n\"\"\"Set the unknown url scheme policy.\n\n        Args:\n            policy: unknown url scheme policy\n\n        Raises:\n            InvalidParamError: Policy does not exist\n        \"\"\"\n        if policy not in UNKNOWN_URL_SCHEME_POLICY:\n            raise InvalidParamError(policy, UNKNOWN_URL_SCHEME_POLICY)\n        self.item.setUnknownUrlSchemePolicy(UNKNOWN_URL_SCHEME_POLICY[policy])\n\n    def get_unknown_url_scheme_policy(self) -&gt; UnknownUrlSchemePolicyStr:\n\"\"\"Return current unknown url scheme policy.\n\n        Returns:\n            Unknown url scheme policy\n        \"\"\"\n        return UNKNOWN_URL_SCHEME_POLICY.inverse[self.item.unknownUrlSchemePolicy()]\n\n    def set_font_family(self, which: FontFamilyStr, family: str):\n\"\"\"Set the actual font family to family for the specified generic family, which.\n\n        Args:\n            which: family to set\n            family: generic family\n\n        Raises:\n            InvalidParamError: Font family does not exist\n        \"\"\"\n        if which not in FONT_FAMILY:\n            raise InvalidParamError(which, FONT_FAMILY)\n        self.item.setFontFamily(FONT_FAMILY[which], family)\n\n    def get_font_family(self, family: FontFamilyStr) -&gt; str:\n\"\"\"Return the actual font family for the specified generic font family.\n\n        Args:\n            family: generic font family\n\n        Returns:\n            Font family\n        \"\"\"\n        return self.item.fontFamily(FONT_FAMILY[family])\n\n    def set_font_size(self, typ: FontSizeStr, size: int):\n\"\"\"Set the font size for type to size in pixels.\n\n        Args:\n            typ: font size type\n            size: size in pixels\n\n        Raises:\n            InvalidParamError: Font size does not exist\n        \"\"\"\n        if typ not in FONT_SIZE:\n            raise InvalidParamError(typ, FONT_SIZE)\n        self.item.setFontSize(FONT_SIZE[typ], size)\n\n    def get_font_size(self, typ: FontSizeStr) -&gt; int:\n\"\"\"Return the default font size for type in pixels.\n\n        Args:\n            typ: font size type\n\n        Returns:\n            Font size\n        \"\"\"\n        return self.item.fontSize(FONT_SIZE[typ])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_font_family","title":"<code>get_font_family(family: FontFamilyStr) -&gt; str</code>","text":"<p>Return the actual font family for the specified generic font family.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <code>FontFamilyStr</code> <p>generic font family</p> required <p>Returns:</p> Type Description <code>str</code> <p>Font family</p> Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def get_font_family(self, family: FontFamilyStr) -&gt; str:\n\"\"\"Return the actual font family for the specified generic font family.\n\n    Args:\n        family: generic font family\n\n    Returns:\n        Font family\n    \"\"\"\n    return self.item.fontFamily(FONT_FAMILY[family])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_font_size","title":"<code>get_font_size(typ: FontSizeStr) -&gt; int</code>","text":"<p>Return the default font size for type in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>FontSizeStr</code> <p>font size type</p> required <p>Returns:</p> Type Description <code>int</code> <p>Font size</p> Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def get_font_size(self, typ: FontSizeStr) -&gt; int:\n\"\"\"Return the default font size for type in pixels.\n\n    Args:\n        typ: font size type\n\n    Returns:\n        Font size\n    \"\"\"\n    return self.item.fontSize(FONT_SIZE[typ])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_unknown_url_scheme_policy","title":"<code>get_unknown_url_scheme_policy() -&gt; UnknownUrlSchemePolicyStr</code>","text":"<p>Return current unknown url scheme policy.</p> <p>Returns:</p> Type Description <code>UnknownUrlSchemePolicyStr</code> <p>Unknown url scheme policy</p> Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def get_unknown_url_scheme_policy(self) -&gt; UnknownUrlSchemePolicyStr:\n\"\"\"Return current unknown url scheme policy.\n\n    Returns:\n        Unknown url scheme policy\n    \"\"\"\n    return UNKNOWN_URL_SCHEME_POLICY.inverse[self.item.unknownUrlSchemePolicy()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_font_family","title":"<code>set_font_family(which: FontFamilyStr, family: str)</code>","text":"<p>Set the actual font family to family for the specified generic family, which.</p> <p>Parameters:</p> Name Type Description Default <code>which</code> <code>FontFamilyStr</code> <p>family to set</p> required <code>family</code> <code>str</code> <p>generic family</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>Font family does not exist</p> Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def set_font_family(self, which: FontFamilyStr, family: str):\n\"\"\"Set the actual font family to family for the specified generic family, which.\n\n    Args:\n        which: family to set\n        family: generic family\n\n    Raises:\n        InvalidParamError: Font family does not exist\n    \"\"\"\n    if which not in FONT_FAMILY:\n        raise InvalidParamError(which, FONT_FAMILY)\n    self.item.setFontFamily(FONT_FAMILY[which], family)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_font_size","title":"<code>set_font_size(typ: FontSizeStr, size: int)</code>","text":"<p>Set the font size for type to size in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>FontSizeStr</code> <p>font size type</p> required <code>size</code> <code>int</code> <p>size in pixels</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>Font size does not exist</p> Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def set_font_size(self, typ: FontSizeStr, size: int):\n\"\"\"Set the font size for type to size in pixels.\n\n    Args:\n        typ: font size type\n        size: size in pixels\n\n    Raises:\n        InvalidParamError: Font size does not exist\n    \"\"\"\n    if typ not in FONT_SIZE:\n        raise InvalidParamError(typ, FONT_SIZE)\n    self.item.setFontSize(FONT_SIZE[typ], size)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_unknown_url_scheme_policy","title":"<code>set_unknown_url_scheme_policy(policy: UnknownUrlSchemePolicyStr)</code>","text":"<p>Set the unknown url scheme policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>UnknownUrlSchemePolicyStr</code> <p>unknown url scheme policy</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>Policy does not exist</p> Source code in <code>prettyqt\\webenginecore\\webenginesettings.py</code> <pre><code>def set_unknown_url_scheme_policy(self, policy: UnknownUrlSchemePolicyStr):\n\"\"\"Set the unknown url scheme policy.\n\n    Args:\n        policy: unknown url scheme policy\n\n    Raises:\n        InvalidParamError: Policy does not exist\n    \"\"\"\n    if policy not in UNKNOWN_URL_SCHEME_POLICY:\n        raise InvalidParamError(policy, UNKNOWN_URL_SCHEME_POLICY)\n    self.item.setUnknownUrlSchemePolicy(UNKNOWN_URL_SCHEME_POLICY[policy])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.WebEngineUrlScheme","title":"<code>WebEngineUrlScheme</code>","text":"<p>         Bases: <code>QtWebEngineCore.QWebEngineUrlScheme</code></p> Source code in <code>prettyqt\\webenginecore\\webengineurlscheme.py</code> <pre><code>class WebEngineUrlScheme(QtWebEngineCore.QWebEngineUrlScheme):\n    def get_name(self) -&gt; str:\n        return self.name().data().decode()\n\n    @classmethod\n    def get_scheme_by_name(cls, name: str) -&gt; WebEngineUrlScheme:\n        scheme = cls.schemeByName(QtCore.QByteArray(name.encode()))\n        return cls(scheme)\n\n    def set_name(self, name: str):\n        self.setName(QtCore.QByteArray(name.encode()))\n\n    def set_syntax(self, syntax: SyntaxStr):\n\"\"\"Set syntax.\n\n        Args:\n            syntax: syntax to use\n\n        Raises:\n            InvalidParamError: syntax does not exist\n        \"\"\"\n        if syntax not in SYNTAX:\n            raise InvalidParamError(syntax, SYNTAX)\n        self.setSyntax(SYNTAX[syntax])\n\n    def get_syntax(self) -&gt; SyntaxStr:\n\"\"\"Return syntax.\n\n        Returns:\n            syntax\n        \"\"\"\n        return SYNTAX.inverse[self.syntax()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.get_syntax","title":"<code>get_syntax() -&gt; SyntaxStr</code>","text":"<p>Return syntax.</p> <p>Returns:</p> Type Description <code>SyntaxStr</code> <p>syntax</p> Source code in <code>prettyqt\\webenginecore\\webengineurlscheme.py</code> <pre><code>def get_syntax(self) -&gt; SyntaxStr:\n\"\"\"Return syntax.\n\n    Returns:\n        syntax\n    \"\"\"\n    return SYNTAX.inverse[self.syntax()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.set_syntax","title":"<code>set_syntax(syntax: SyntaxStr)</code>","text":"<p>Set syntax.</p> <p>Parameters:</p> Name Type Description Default <code>syntax</code> <code>SyntaxStr</code> <p>syntax to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>syntax does not exist</p> Source code in <code>prettyqt\\webenginecore\\webengineurlscheme.py</code> <pre><code>def set_syntax(self, syntax: SyntaxStr):\n\"\"\"Set syntax.\n\n    Args:\n        syntax: syntax to use\n\n    Raises:\n        InvalidParamError: syntax does not exist\n    \"\"\"\n    if syntax not in SYNTAX:\n        raise InvalidParamError(syntax, SYNTAX)\n    self.setSyntax(SYNTAX[syntax])\n</code></pre>"},{"location":"api/webenginewidgets.html","title":"webenginewidgets module","text":"<p>Webenginewidgets module.</p> <p>contains QtWebEngineWidgets-based classes</p>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.WebEngineView","title":"<code>WebEngineView</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWebEngineWidgets.QWebEngineView</code></p> Source code in <code>prettyqt\\webenginewidgets\\webengineview.py</code> <pre><code>class WebEngineView(widgets.WidgetMixin, QtWebEngineWidgets.QWebEngineView):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.setPage(webenginecore.WebEnginePage(self))\n\n    def set_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Set the url of the WebEngineView.\n\n        Clears the view and loads the URL.\n\n        Args:\n            url: URL to set\n        \"\"\"\n        if isinstance(url, os.PathLike):\n            url = core.Url.fromLocalFile(os.fspath(url))\n        elif isinstance(url, str):\n            url = core.Url(url)\n        self.setUrl(url)\n\n    def get_url(self) -&gt; core.Url:\n        return core.Url(self.url())\n\n    def load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n\n        Loads the specified url and displays it.\n\n        Note: The view remains the same until enough data has arrived\n        to display the new URL.\n\n        Args:\n            url: URL to load\n        \"\"\"\n        if isinstance(url, os.PathLike):\n            url = core.Url.fromLocalFile(os.fspath(url))\n        elif isinstance(url, str):\n            url = core.Url(url)\n        self.load(url)\n\n    def set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the view.\n\n        Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n\n        Args:\n            zoom: Zoom factor\n        \"\"\"\n        self.setZoomFactor(zoom)\n\n    def find_text(\n        self,\n        string: str,\n        backward: bool = False,\n        case_sensitive: bool = False,\n        callback: Callable[[bool], None] | None = None,\n    ):\n\"\"\"Find text in the current page.\n\n        Finds the specified string, subString, in the page, using the given options.\n        The findTextFinished() signal is emitted when a string search is completed.\n\n        To clear the search highlight, just pass an empty string.\n\n        The resultCallback must take a boolean parameter.\n        It will be called with a value of true if the subString was found;\n        otherwise the callback value will be false.\n\n        Warning: It is guaranteed that the callback is always called,\n        but it might be done during page destruction. When WebEnginePage is deleted,\n        the callback is triggered with an invalid value and it is not safe to use\n        the corresponding QWebEnginePage or QWebEngineView instance inside it.\n\n        Args:\n            string: string to search for\n            backward: search backwards\n            case_sensitive: case-sensitive search\n            callback: result callback\n        \"\"\"\n        if callback is None:\n\n            def do_nothing(x):\n                pass\n\n            callback = do_nothing\n        flag = webenginecore.WebEnginePage.FindFlag(0)\n        if case_sensitive:\n            flag |= webenginecore.WebEnginePage.FindFlag.FindCaseSensitively\n        if backward:\n            flag |= webenginecore.WebEnginePage.FindFlag.FindBackward\n        self.findText(string, flag, callback)\n\n    def get_settings(self) -&gt; webenginecore.WebEngineSettings:\n        settings = self.settings()\n        return webenginecore.WebEngineSettings(settings)\n\n    def set_setting(\n        self,\n        setting_name: webenginecore.webenginesettings.WebAttributeStr,\n        value: bool,\n    ):\n        self.get_settings()[setting_name] = value\n\n    def get_setting(\n        self, setting_name: webenginecore.webenginesettings.WebAttributeStr\n    ) -&gt; bool:\n        return self.get_settings()[setting_name]\n\n    @classmethod\n    def register_as_browser(cls, tabwidget: widgets.TabWidget):\n        class BuiltInBrowser(webbrowser.BaseBrowser):\n            def open(self, url: str, new: int = 0, autoraise: bool = True):\n                # logger.info(f\"opening {url} with builtin browser..\")\n                webview = cls()\n                webview.load_url(url)\n                if new == 1:\n                    webview.show()\n                else:\n                    tabwidget.add_tab(webview, url, show=autoraise)\n\n        webbrowser.register(\"BuiltInBrowser\", BuiltInBrowser)\n\n    def last_context_menu_request(\n        self,\n    ) -&gt; webenginecore.WebEngineContextMenuRequest | None:\n        req = self.lastContextMenuRequest()\n        return webenginecore.WebEngineContextMenuRequest(req) if req else None\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.find_text","title":"<code>find_text(string: str, backward: bool = False, case_sensitive: bool = False, callback: Callable[[bool], None] | None = None)</code>","text":"<p>Find text in the current page.</p> <p>Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed.</p> <p>To clear the search highlight, just pass an empty string.</p> <p>The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false.</p> <p>Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>string to search for</p> required <code>backward</code> <code>bool</code> <p>search backwards</p> <code>False</code> <code>case_sensitive</code> <code>bool</code> <p>case-sensitive search</p> <code>False</code> <code>callback</code> <code>Callable[[bool], None] | None</code> <p>result callback</p> <code>None</code> Source code in <code>prettyqt\\webenginewidgets\\webengineview.py</code> <pre><code>def find_text(\n    self,\n    string: str,\n    backward: bool = False,\n    case_sensitive: bool = False,\n    callback: Callable[[bool], None] | None = None,\n):\n\"\"\"Find text in the current page.\n\n    Finds the specified string, subString, in the page, using the given options.\n    The findTextFinished() signal is emitted when a string search is completed.\n\n    To clear the search highlight, just pass an empty string.\n\n    The resultCallback must take a boolean parameter.\n    It will be called with a value of true if the subString was found;\n    otherwise the callback value will be false.\n\n    Warning: It is guaranteed that the callback is always called,\n    but it might be done during page destruction. When WebEnginePage is deleted,\n    the callback is triggered with an invalid value and it is not safe to use\n    the corresponding QWebEnginePage or QWebEngineView instance inside it.\n\n    Args:\n        string: string to search for\n        backward: search backwards\n        case_sensitive: case-sensitive search\n        callback: result callback\n    \"\"\"\n    if callback is None:\n\n        def do_nothing(x):\n            pass\n\n        callback = do_nothing\n    flag = webenginecore.WebEnginePage.FindFlag(0)\n    if case_sensitive:\n        flag |= webenginecore.WebEnginePage.FindFlag.FindCaseSensitively\n    if backward:\n        flag |= webenginecore.WebEnginePage.FindFlag.FindBackward\n    self.findText(string, flag, callback)\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.load_url","title":"<code>load_url(url: datatypes.UrlType | datatypes.PathType)</code>","text":"<p>Load the URL.</p> <p>Loads the specified url and displays it.</p> <p>Note: The view remains the same until enough data has arrived to display the new URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.UrlType | datatypes.PathType</code> <p>URL to load</p> required Source code in <code>prettyqt\\webenginewidgets\\webengineview.py</code> <pre><code>def load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n\n    Loads the specified url and displays it.\n\n    Note: The view remains the same until enough data has arrived\n    to display the new URL.\n\n    Args:\n        url: URL to load\n    \"\"\"\n    if isinstance(url, os.PathLike):\n        url = core.Url.fromLocalFile(os.fspath(url))\n    elif isinstance(url, str):\n        url = core.Url(url)\n    self.load(url)\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_url","title":"<code>set_url(url: datatypes.UrlType | datatypes.PathType)</code>","text":"<p>Set the url of the WebEngineView.</p> <p>Clears the view and loads the URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.UrlType | datatypes.PathType</code> <p>URL to set</p> required Source code in <code>prettyqt\\webenginewidgets\\webengineview.py</code> <pre><code>def set_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Set the url of the WebEngineView.\n\n    Clears the view and loads the URL.\n\n    Args:\n        url: URL to set\n    \"\"\"\n    if isinstance(url, os.PathLike):\n        url = core.Url.fromLocalFile(os.fspath(url))\n    elif isinstance(url, str):\n        url = core.Url(url)\n    self.setUrl(url)\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_zoom","title":"<code>set_zoom(zoom: float)</code>","text":"<p>Set the zoom factor for the view.</p> <p>Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom factor</p> required Source code in <code>prettyqt\\webenginewidgets\\webengineview.py</code> <pre><code>def set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the view.\n\n    Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n\n    Args:\n        zoom: Zoom factor\n    \"\"\"\n    self.setZoomFactor(zoom)\n</code></pre>"},{"location":"api/widgets.html","title":"widgets module","text":"<p>widgets module.</p> <p>contains QtWidgets-based classes</p>"},{"location":"api/widgets.html#prettyqt.widgets.AbstractButtonMixin","title":"<code>AbstractButtonMixin</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code></p> Source code in <code>prettyqt\\widgets\\abstractbutton.py</code> <pre><code>class AbstractButtonMixin(widgets.WidgetMixin):\n    def __bool__(self):\n        return self.isChecked()\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the button.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        return None if icon.isNull() else gui.Icon(icon)\n\n    def set_style_icon(self, icon: widgets.style.StandardPixmapStr, size: int = 15):\n\"\"\"Set theme icon for the button.\n\n        Args:\n            icon: icon to use\n            size: icon size\n        \"\"\"\n        if icon not in widgets.style.STANDARD_PIXMAP:\n            raise InvalidParamError(icon, widgets.style.STANDARD_PIXMAP)\n        qicon = self.style().standardIcon(widgets.style.STANDARD_PIXMAP[icon], None, self)\n        self.set_icon(qicon)\n        self.setIconSize(core.Size(size, size))\n\n    def set_shortcut(self, shortcut: None | QtGui.QKeySequence | str):\n        if shortcut is None:\n            shortcut = \"\"\n        if isinstance(shortcut, str):\n            shortcut = gui.KeySequence(\n                shortcut, gui.KeySequence.SequenceFormat.PortableText\n            )\n        self.setShortcut(shortcut)\n\n    def get_shortcut(self) -&gt; gui.KeySequence:\n        return gui.KeySequence(\n            self.shortcut().toString(), gui.KeySequence.SequenceFormat.PortableText\n        )\n\n    def set_text(self, text: str):\n        self.setText(text)\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icon.\"\"\"\n        if isinstance(size, int):\n            size = core.Size(size, size)\n        elif isinstance(size, tuple):\n            size = core.Size(*size)\n        self.setIconSize(size)\n\n    def get_icon_size(self) -&gt; core.Size:\n        return core.Size(self.iconSize())\n\n    def get_value(self) -&gt; bool:\n        return self.isChecked()\n\n    def set_value(self, value: bool):\n        self.setChecked(value)\n\n    @property\n    def is_on(self) -&gt; bool:\n        return self.isChecked()\n\n    @is_on.setter\n    def is_on(self, state: bool):\n        self.setChecked(state)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButtonMixin.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the button.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\abstractbutton.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the button.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButtonMixin.set_icon_size","title":"<code>set_icon_size(size: int | datatypes.SizeType)</code>","text":"<p>Set size of the icon.</p> Source code in <code>prettyqt\\widgets\\abstractbutton.py</code> <pre><code>def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icon.\"\"\"\n    if isinstance(size, int):\n        size = core.Size(size, size)\n    elif isinstance(size, tuple):\n        size = core.Size(*size)\n    self.setIconSize(size)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButtonMixin.set_style_icon","title":"<code>set_style_icon(icon: widgets.style.StandardPixmapStr, size: int = 15)</code>","text":"<p>Set theme icon for the button.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>widgets.style.StandardPixmapStr</code> <p>icon to use</p> required <code>size</code> <code>int</code> <p>icon size</p> <code>15</code> Source code in <code>prettyqt\\widgets\\abstractbutton.py</code> <pre><code>def set_style_icon(self, icon: widgets.style.StandardPixmapStr, size: int = 15):\n\"\"\"Set theme icon for the button.\n\n    Args:\n        icon: icon to use\n        size: icon size\n    \"\"\"\n    if icon not in widgets.style.STANDARD_PIXMAP:\n        raise InvalidParamError(icon, widgets.style.STANDARD_PIXMAP)\n    qicon = self.style().standardIcon(widgets.style.STANDARD_PIXMAP[icon], None, self)\n    self.set_icon(qicon)\n    self.setIconSize(core.Size(size, size))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.AbstractItemViewMixin","title":"<code>AbstractItemViewMixin</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code></p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>class AbstractItemViewMixin(widgets.AbstractScrollAreaMixin):\n    model_changed = core.Signal(QtCore.QAbstractItemModel)\n\n    def __len__(self) -&gt; int:\n        return model.rowCount() if (model := self.model()) is not None else 0\n\n    def selectAll(self):\n\"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\"\n        if self.model() is None:\n            return\n        if self.model().rowCount() * self.model().columnCount() &gt; 1_000_000:\n            logger.warning(\"Too many cells to select.\")\n            return\n        super().selectAll()\n\n    def set_model(self, model: QtCore.QAbstractItemModel | None):\n\"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\"\n        old_model = self.model()\n        old_sel_model = self.selectionModel()\n        if old_model is not None or model is not None:\n            self.setModel(model)  # type: ignore\n            self.model_changed.emit(model)\n        # if old_model:\n        #     old_model.deleteLater()\n        #     del old_model\n        if old_sel_model:\n            old_sel_model.deleteLater()\n            del old_sel_model\n\n    def set_delegate(\n        self,\n        delegate: QtWidgets.QAbstractItemDelegate,\n        column: int | None = None,\n        row: int | None = None,\n        persistent: bool = False,\n    ):\n        if column is not None:\n            self.setItemDelegateForColumn(column, delegate)\n            if persistent:\n                model = self.model()\n                for i in range(model.rowCount()):\n                    index = model.index(i, column)\n                    self.openPersistentEditor(index)\n        elif row is not None:\n            self.setItemDelegateForRow(row, delegate)\n            if persistent:\n                model = self.model()\n                for i in range(model.columnCount()):\n                    self.openPersistentEditor(model.index(row, i))\n        else:\n            self.setItemDelegate(delegate)\n\n    def toggle_select_all(self):\n\"\"\"Select all items from list (deselect when all selected).\"\"\"\n        if self.selectionModel() is None:\n            return\n        if self.selectionModel().hasSelection():\n            self.clearSelection()\n        else:\n            self.selectAll()\n\n    def set_table_color(self, color: str):\n        with self.edit_stylesheet() as ss:\n            ss.QHeaderView.section.backgroundColor.setValue(color)\n\n    def current_index(self) -&gt; QtCore.QModelIndex | None:\n        if (model := self.selectionModel()) is not None:\n            return model.currentIndex()\n\n    def current_data(self):\n        if (model := self.selectionModel()) is not None:\n            idx = model.currentIndex()\n            return idx.data(constants.USER_ROLE)  # type: ignore\n\n    def current_row(self) -&gt; int | None:\n        if (model := self.selectionModel()) is not None:\n            return model.currentIndex().row()\n\n    def current_column(self) -&gt; int | None:\n        if (model := self.selectionModel()) is not None:\n            return model.currentIndex().column()\n\n    def selected_indexes(self) -&gt; list[QtCore.QModelIndex]:\n\"\"\"Return list of selected indexes in first row.\"\"\"\n        indexes = (x for x in self.selectedIndexes() if x.column() == 0)  # type: ignore\n        return sorted(indexes, key=lambda x: x.row())  # type: ignore\n\n    def selected_names(self) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding item names.\"\"\"\n        return (x.data(constants.NAME_ROLE) for x in self.selected_indexes())\n\n    def selected_rows(self) -&gt; Generator[int, None, None]:\n\"\"\"Return generator yielding row nums.\"\"\"\n        return (x.row() for x in self.selected_indexes())\n\n    def selected_data(self) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding selected userData.\"\"\"\n        return (\n            x.data(constants.USER_ROLE) for x in self.selected_indexes()  # type: ignore\n        )\n\n    def setup_dragdrop_move(self):\n        self.setDragEnabled(True)\n        self.setAcceptDrops(True)\n        self.setDragDropMode(self.DragDropMode.DragDrop)\n        self.setDefaultDropAction(constants.MOVE_ACTION)\n        self.setDropIndicatorShown(True)\n\n    def set_edit_triggers(self, *triggers: EditTriggerStr | None):\n        items = [\"none\" if t is None else t for t in triggers]\n        for item in items:\n            if item not in EDIT_TRIGGERS:\n                raise InvalidParamError(item, EDIT_TRIGGERS)\n        flags = helpers.merge_flags(items, EDIT_TRIGGERS)\n        self.setEditTriggers(flags)\n\n    def get_edit_triggers(self) -&gt; list[EditTriggerStr]:\n        return EDIT_TRIGGERS.get_list(self.editTriggers())\n\n    def set_selection_behaviour(self, behaviour: SelectionBehaviourStr):\n\"\"\"Set selection behaviour for given item view.\n\n        Args:\n            behaviour: selection behaviour to use\n\n        Raises:\n            InvalidParamError: behaviour does not exist\n        \"\"\"\n        if behaviour not in SELECTION_BEHAVIOUR:\n            raise InvalidParamError(behaviour, SELECTION_BEHAVIOUR)\n        self.setSelectionBehavior(SELECTION_BEHAVIOUR[behaviour])\n\n    def get_selection_behaviour(self) -&gt; SelectionBehaviourStr:\n\"\"\"Return current selection behaviour.\n\n        Returns:\n            selection behaviour\n        \"\"\"\n        return SELECTION_BEHAVIOUR.inverse[self.selectionBehavior()]\n\n    def set_drag_drop_mode(self, mode: DragDropModeStr):\n\"\"\"Set drag-drop mode for given item view.\n\n        Args:\n            mode: drag-drop mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in DRAG_DROP_MODE:\n            raise InvalidParamError(mode, DRAG_DROP_MODE)\n        self.setDragDropMode(DRAG_DROP_MODE[mode])\n\n    def get_drag_drop_mode(self) -&gt; DragDropModeStr:\n\"\"\"Return current drag-drop mode.\n\n        Returns:\n            drag-drop mode\n        \"\"\"\n        return DRAG_DROP_MODE.inverse[self.dragDropMode()]\n\n    def set_selection_mode(self, mode: SelectionModeStr | None):\n\"\"\"Set selection mode for given item view.\n\n        Args:\n            mode: selection mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode is None:\n            mode = \"none\"\n        if mode not in SELECTION_MODE:\n            raise InvalidParamError(mode, SELECTION_MODE)\n        self.setSelectionMode(SELECTION_MODE[mode])\n\n    def get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n\n        Returns:\n            selection mode\n        \"\"\"\n        return SELECTION_MODE.inverse[self.selectionMode()]\n\n    def set_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the scroll mode for both directions.\n\n        Args:\n            mode: mode to set\n\n        Raises:\n            InvalidParamError: invalid scroll mode\n        \"\"\"\n        if mode not in SCROLL_MODE:\n            raise InvalidParamError(mode, SCROLL_MODE)\n        self.setHorizontalScrollMode(SCROLL_MODE[mode])\n        self.setVerticalScrollMode(SCROLL_MODE[mode])\n\n    def set_horizontal_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the horizontal scroll mode.\n\n        Args:\n            mode: mode to set\n\n        Raises:\n            InvalidParamError: invalid scroll mode\n        \"\"\"\n        if mode not in SCROLL_MODE:\n            raise InvalidParamError(mode, SCROLL_MODE)\n        self.setHorizontalScrollMode(SCROLL_MODE[mode])\n\n    def get_horizontal_scroll_mode(self) -&gt; ScrollModeStr:\n\"\"\"Return current horizontal scroll mode.\n\n        Returns:\n            horizontal scroll mode\n        \"\"\"\n        return SCROLL_MODE.inverse[self.horizontalScrollMode()]\n\n    def set_vertical_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the vertical scroll mode.\n\n        Args:\n            mode: mode to set\n\n        Raises:\n            InvalidParamError: invalid scroll mode\n        \"\"\"\n        if mode not in SCROLL_MODE:\n            raise InvalidParamError(mode, SCROLL_MODE)\n        self.setVerticalScrollMode(SCROLL_MODE[mode])\n\n    def get_vertical_scroll_mode(self) -&gt; ScrollModeStr:\n\"\"\"Return current vertical scroll mode.\n\n        Returns:\n            vertical scroll mode\n        \"\"\"\n        return SCROLL_MODE.inverse[self.verticalScrollMode()]\n\n    def num_selected(self) -&gt; int:\n\"\"\"Return amount of selected rows.\n\n        Returns:\n            amount of selected rows\n        \"\"\"\n        if (model := self.selectionModel()) is not None:\n            return len(model.selectedRows())\n        return 0\n\n    def jump_to_column(self, col_num: int):\n\"\"\"Make sure column at given index is visible.\n\n        scrolls to column at given index\n\n        Args:\n            col_num: column to scroll to\n        \"\"\"\n        if (model := self.model()) is not None:\n            idx = model.index(0, col_num)\n            self.scrollTo(idx)\n\n    def scroll_to_top(self):\n\"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\"\n        self.scrollToTop()\n\n    def scroll_to_bottom(self):\n\"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\"\n        self.scrollToBottom()\n\n    def select_last_row(self):\n        idx = self.model().createIndex(self.model().rowCount() - 1, 0)\n        self.setCurrentIndex(idx)\n\n    def scroll_to(self, index, mode: ScrollHintStr = \"ensure_visible\"):\n        if mode not in SCROLL_HINT:\n            raise InvalidParamError(mode, SCROLL_HINT)\n        self.scrollTo(index, SCROLL_HINT[mode])\n\n    def highlight_when_inactive(self):\n\"\"\"Highlight items when widget does not have focus.\"\"\"\n        p = gui.Palette()\n        p.highlight_inactive()\n        self.setPalette(p)\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n        if isinstance(size, tuple):\n            size = QtCore.QSize(*size)\n        elif isinstance(size, int):\n            size = QtCore.QSize(size, size)\n        self.setIconSize(size)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_drag_drop_mode","title":"<code>get_drag_drop_mode() -&gt; DragDropModeStr</code>","text":"<p>Return current drag-drop mode.</p> <p>Returns:</p> Type Description <code>DragDropModeStr</code> <p>drag-drop mode</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_drag_drop_mode(self) -&gt; DragDropModeStr:\n\"\"\"Return current drag-drop mode.\n\n    Returns:\n        drag-drop mode\n    \"\"\"\n    return DRAG_DROP_MODE.inverse[self.dragDropMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_horizontal_scroll_mode","title":"<code>get_horizontal_scroll_mode() -&gt; ScrollModeStr</code>","text":"<p>Return current horizontal scroll mode.</p> <p>Returns:</p> Type Description <code>ScrollModeStr</code> <p>horizontal scroll mode</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_horizontal_scroll_mode(self) -&gt; ScrollModeStr:\n\"\"\"Return current horizontal scroll mode.\n\n    Returns:\n        horizontal scroll mode\n    \"\"\"\n    return SCROLL_MODE.inverse[self.horizontalScrollMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_selection_behaviour","title":"<code>get_selection_behaviour() -&gt; SelectionBehaviourStr</code>","text":"<p>Return current selection behaviour.</p> <p>Returns:</p> Type Description <code>SelectionBehaviourStr</code> <p>selection behaviour</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_selection_behaviour(self) -&gt; SelectionBehaviourStr:\n\"\"\"Return current selection behaviour.\n\n    Returns:\n        selection behaviour\n    \"\"\"\n    return SELECTION_BEHAVIOUR.inverse[self.selectionBehavior()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_selection_mode","title":"<code>get_selection_mode() -&gt; SelectionModeStr</code>","text":"<p>Return current selection mode.</p> <p>Returns:</p> Type Description <code>SelectionModeStr</code> <p>selection mode</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n\n    Returns:\n        selection mode\n    \"\"\"\n    return SELECTION_MODE.inverse[self.selectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_vertical_scroll_mode","title":"<code>get_vertical_scroll_mode() -&gt; ScrollModeStr</code>","text":"<p>Return current vertical scroll mode.</p> <p>Returns:</p> Type Description <code>ScrollModeStr</code> <p>vertical scroll mode</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def get_vertical_scroll_mode(self) -&gt; ScrollModeStr:\n\"\"\"Return current vertical scroll mode.\n\n    Returns:\n        vertical scroll mode\n    \"\"\"\n    return SCROLL_MODE.inverse[self.verticalScrollMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.highlight_when_inactive","title":"<code>highlight_when_inactive()</code>","text":"<p>Highlight items when widget does not have focus.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def highlight_when_inactive(self):\n\"\"\"Highlight items when widget does not have focus.\"\"\"\n    p = gui.Palette()\n    p.highlight_inactive()\n    self.setPalette(p)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.jump_to_column","title":"<code>jump_to_column(col_num: int)</code>","text":"<p>Make sure column at given index is visible.</p> <p>scrolls to column at given index</p> <p>Parameters:</p> Name Type Description Default <code>col_num</code> <code>int</code> <p>column to scroll to</p> required Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def jump_to_column(self, col_num: int):\n\"\"\"Make sure column at given index is visible.\n\n    scrolls to column at given index\n\n    Args:\n        col_num: column to scroll to\n    \"\"\"\n    if (model := self.model()) is not None:\n        idx = model.index(0, col_num)\n        self.scrollTo(idx)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.num_selected","title":"<code>num_selected() -&gt; int</code>","text":"<p>Return amount of selected rows.</p> <p>Returns:</p> Type Description <code>int</code> <p>amount of selected rows</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def num_selected(self) -&gt; int:\n\"\"\"Return amount of selected rows.\n\n    Returns:\n        amount of selected rows\n    \"\"\"\n    if (model := self.selectionModel()) is not None:\n        return len(model.selectedRows())\n    return 0\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.scroll_to_bottom","title":"<code>scroll_to_bottom()</code>","text":"<p>Override to use abstractitemview-way of scrolling to bottom.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def scroll_to_bottom(self):\n\"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\"\n    self.scrollToBottom()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.scroll_to_top","title":"<code>scroll_to_top()</code>","text":"<p>Override to use abstractitemview-way of scrolling to top.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def scroll_to_top(self):\n\"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\"\n    self.scrollToTop()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selectAll","title":"<code>selectAll()</code>","text":"<p>Override, we dont want to selectAll for too many items bc of performance.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def selectAll(self):\n\"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\"\n    if self.model() is None:\n        return\n    if self.model().rowCount() * self.model().columnCount() &gt; 1_000_000:\n        logger.warning(\"Too many cells to select.\")\n        return\n    super().selectAll()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_data","title":"<code>selected_data() -&gt; Generator[Any, None, None]</code>","text":"<p>Return generator yielding selected userData.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def selected_data(self) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding selected userData.\"\"\"\n    return (\n        x.data(constants.USER_ROLE) for x in self.selected_indexes()  # type: ignore\n    )\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_indexes","title":"<code>selected_indexes() -&gt; list[QtCore.QModelIndex]</code>","text":"<p>Return list of selected indexes in first row.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def selected_indexes(self) -&gt; list[QtCore.QModelIndex]:\n\"\"\"Return list of selected indexes in first row.\"\"\"\n    indexes = (x for x in self.selectedIndexes() if x.column() == 0)  # type: ignore\n    return sorted(indexes, key=lambda x: x.row())  # type: ignore\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_names","title":"<code>selected_names() -&gt; Generator[Any, None, None]</code>","text":"<p>Return generator yielding item names.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def selected_names(self) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding item names.\"\"\"\n    return (x.data(constants.NAME_ROLE) for x in self.selected_indexes())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_rows","title":"<code>selected_rows() -&gt; Generator[int, None, None]</code>","text":"<p>Return generator yielding row nums.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def selected_rows(self) -&gt; Generator[int, None, None]:\n\"\"\"Return generator yielding row nums.\"\"\"\n    return (x.row() for x in self.selected_indexes())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_drag_drop_mode","title":"<code>set_drag_drop_mode(mode: DragDropModeStr)</code>","text":"<p>Set drag-drop mode for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>DragDropModeStr</code> <p>drag-drop mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_drag_drop_mode(self, mode: DragDropModeStr):\n\"\"\"Set drag-drop mode for given item view.\n\n    Args:\n        mode: drag-drop mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in DRAG_DROP_MODE:\n        raise InvalidParamError(mode, DRAG_DROP_MODE)\n    self.setDragDropMode(DRAG_DROP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_horizontal_scroll_mode","title":"<code>set_horizontal_scroll_mode(mode: ScrollModeStr)</code>","text":"<p>Set the horizontal scroll mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ScrollModeStr</code> <p>mode to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid scroll mode</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_horizontal_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the horizontal scroll mode.\n\n    Args:\n        mode: mode to set\n\n    Raises:\n        InvalidParamError: invalid scroll mode\n    \"\"\"\n    if mode not in SCROLL_MODE:\n        raise InvalidParamError(mode, SCROLL_MODE)\n    self.setHorizontalScrollMode(SCROLL_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_model","title":"<code>set_model(model: QtCore.QAbstractItemModel | None)</code>","text":"<p>Delete old selection model explicitely, seems to help with memory usage.</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_model(self, model: QtCore.QAbstractItemModel | None):\n\"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\"\n    old_model = self.model()\n    old_sel_model = self.selectionModel()\n    if old_model is not None or model is not None:\n        self.setModel(model)  # type: ignore\n        self.model_changed.emit(model)\n    # if old_model:\n    #     old_model.deleteLater()\n    #     del old_model\n    if old_sel_model:\n        old_sel_model.deleteLater()\n        del old_sel_model\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_scroll_mode","title":"<code>set_scroll_mode(mode: ScrollModeStr)</code>","text":"<p>Set the scroll mode for both directions.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ScrollModeStr</code> <p>mode to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid scroll mode</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the scroll mode for both directions.\n\n    Args:\n        mode: mode to set\n\n    Raises:\n        InvalidParamError: invalid scroll mode\n    \"\"\"\n    if mode not in SCROLL_MODE:\n        raise InvalidParamError(mode, SCROLL_MODE)\n    self.setHorizontalScrollMode(SCROLL_MODE[mode])\n    self.setVerticalScrollMode(SCROLL_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_selection_behaviour","title":"<code>set_selection_behaviour(behaviour: SelectionBehaviourStr)</code>","text":"<p>Set selection behaviour for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>behaviour</code> <code>SelectionBehaviourStr</code> <p>selection behaviour to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>behaviour does not exist</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_selection_behaviour(self, behaviour: SelectionBehaviourStr):\n\"\"\"Set selection behaviour for given item view.\n\n    Args:\n        behaviour: selection behaviour to use\n\n    Raises:\n        InvalidParamError: behaviour does not exist\n    \"\"\"\n    if behaviour not in SELECTION_BEHAVIOUR:\n        raise InvalidParamError(behaviour, SELECTION_BEHAVIOUR)\n    self.setSelectionBehavior(SELECTION_BEHAVIOUR[behaviour])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_selection_mode","title":"<code>set_selection_mode(mode: SelectionModeStr | None)</code>","text":"<p>Set selection mode for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SelectionModeStr | None</code> <p>selection mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_selection_mode(self, mode: SelectionModeStr | None):\n\"\"\"Set selection mode for given item view.\n\n    Args:\n        mode: selection mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode is None:\n        mode = \"none\"\n    if mode not in SELECTION_MODE:\n        raise InvalidParamError(mode, SELECTION_MODE)\n    self.setSelectionMode(SELECTION_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_vertical_scroll_mode","title":"<code>set_vertical_scroll_mode(mode: ScrollModeStr)</code>","text":"<p>Set the vertical scroll mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ScrollModeStr</code> <p>mode to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid scroll mode</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def set_vertical_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the vertical scroll mode.\n\n    Args:\n        mode: mode to set\n\n    Raises:\n        InvalidParamError: invalid scroll mode\n    \"\"\"\n    if mode not in SCROLL_MODE:\n        raise InvalidParamError(mode, SCROLL_MODE)\n    self.setVerticalScrollMode(SCROLL_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.toggle_select_all","title":"<code>toggle_select_all()</code>","text":"<p>Select all items from list (deselect when all selected).</p> Source code in <code>prettyqt\\widgets\\abstractitemview.py</code> <pre><code>def toggle_select_all(self):\n\"\"\"Select all items from list (deselect when all selected).\"\"\"\n    if self.selectionModel() is None:\n        return\n    if self.selectionModel().hasSelection():\n        self.clearSelection()\n    else:\n        self.selectAll()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.AbstractScrollAreaMixin","title":"<code>AbstractScrollAreaMixin</code>","text":"<p>         Bases: <code>widgets.FrameMixin</code></p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>class AbstractScrollAreaMixin(widgets.FrameMixin):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.setHorizontalScrollBar(widgets.ScrollBar(parent=self))\n        self.setVerticalScrollBar(widgets.ScrollBar(parent=self))\n\n    @property\n    def h_scrollbar(self):\n        return self.horizontalScrollBar()\n\n    @h_scrollbar.setter\n    def h_scrollbar(self, scrollbar):\n        self.setHorizontalScrollBar(scrollbar)\n\n    @property\n    def v_scrollbar(self):\n        return self.verticalScrollBar()\n\n    @v_scrollbar.setter\n    def v_scrollbar(self, scrollbar):\n        self.setVerticalScrollBar(scrollbar)\n\n    def set_size_adjust_policy(self, policy: SizePolicyStr):\n\"\"\"Set size adjust policy.\n\n        Args:\n            policy: size adjust policy to use\n\n        Raises:\n            InvalidParamError: invalid size adjust policy\n        \"\"\"\n        if policy not in SIZE_POLICY:\n            raise InvalidParamError(policy, SIZE_POLICY)\n        self.setSizeAdjustPolicy(SIZE_POLICY[policy])\n\n    def get_size_adjust_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size adjust policy.\n\n        Returns:\n            size adjust policy\n        \"\"\"\n        return SIZE_POLICY.inverse[self.sizeAdjustPolicy()]\n\n    def set_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the policy for both scrollbars.\n\n        Args:\n            mode: visibilty to set\n\n        Raises:\n            InvalidParamError: invalid scrollbar policy\n        \"\"\"\n        if mode not in constants.SCROLLBAR_POLICY:\n            raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n        self.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n        self.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n\n    def set_horizontal_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the horizontal scrollbar visibility.\n\n        Args:\n            mode: visibilty to set\n\n        Raises:\n            InvalidParamError: invalid scrollbar policy\n        \"\"\"\n        if mode not in constants.SCROLLBAR_POLICY:\n            raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n        self.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n\n    def get_horizontal_scrollbar_policy(self):\n        return constants.SCROLLBAR_POLICY.inverse[self.horizontalScrollBarPolicy()]\n\n    def set_vertical_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the vertical scrollbar visibility.\n\n        Args:\n            mode: visibilty to set\n\n        Raises:\n            InvalidParamError: invalid scrollbar policy\n        \"\"\"\n        if mode not in constants.SCROLLBAR_POLICY:\n            raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n        self.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n\n    def get_vertical_scrollbar_policy(self):\n        return constants.SCROLLBAR_POLICY.inverse[self.verticalScrollBarPolicy()]\n\n    def set_scrollbar_width(self, width: int):\n\"\"\"Set the width for both scrollbars.\n\n        Args:\n            width: width in pixels\n        \"\"\"\n        self.set_horizontal_scrollbar_width(width)\n        self.set_vertical_scrollbar_width(width)\n\n    def set_horizontal_scrollbar_width(self, width: int):\n\"\"\"Set the horizontal scrollbar width.\n\n        Args:\n            width: width in pixels\n        \"\"\"\n        with self.h_scrollbar.edit_stylesheet() as ss:\n            ss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\n\n    def set_vertical_scrollbar_width(self, width: int):\n\"\"\"Set the vertical scrollbar width.\n\n        Args:\n            width: width in pixels\n        \"\"\"\n        with self.v_scrollbar.edit_stylesheet() as ss:\n            ss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\n\n    def scroll_to_top(self):\n\"\"\"Scroll to the top of the scroll area.\"\"\"\n        self.verticalScrollBar().scroll_to_min()\n\n    def scroll_to_bottom(self):\n\"\"\"Scroll to the bottom of the scroll area.\"\"\"\n        self.verticalScrollBar().scroll_to_max()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.get_size_adjust_policy","title":"<code>get_size_adjust_policy() -&gt; SizePolicyStr</code>","text":"<p>Return size adjust policy.</p> <p>Returns:</p> Type Description <code>SizePolicyStr</code> <p>size adjust policy</p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def get_size_adjust_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size adjust policy.\n\n    Returns:\n        size adjust policy\n    \"\"\"\n    return SIZE_POLICY.inverse[self.sizeAdjustPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.scroll_to_bottom","title":"<code>scroll_to_bottom()</code>","text":"<p>Scroll to the bottom of the scroll area.</p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def scroll_to_bottom(self):\n\"\"\"Scroll to the bottom of the scroll area.\"\"\"\n    self.verticalScrollBar().scroll_to_max()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.scroll_to_top","title":"<code>scroll_to_top()</code>","text":"<p>Scroll to the top of the scroll area.</p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def scroll_to_top(self):\n\"\"\"Scroll to the top of the scroll area.\"\"\"\n    self.verticalScrollBar().scroll_to_min()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_horizontal_scrollbar_policy","title":"<code>set_horizontal_scrollbar_policy(mode: constants.ScrollBarPolicyStr)</code>","text":"<p>Set the horizontal scrollbar visibility.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ScrollBarPolicyStr</code> <p>visibilty to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid scrollbar policy</p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_horizontal_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the horizontal scrollbar visibility.\n\n    Args:\n        mode: visibilty to set\n\n    Raises:\n        InvalidParamError: invalid scrollbar policy\n    \"\"\"\n    if mode not in constants.SCROLLBAR_POLICY:\n        raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n    self.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_horizontal_scrollbar_width","title":"<code>set_horizontal_scrollbar_width(width: int)</code>","text":"<p>Set the horizontal scrollbar width.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>width in pixels</p> required Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_horizontal_scrollbar_width(self, width: int):\n\"\"\"Set the horizontal scrollbar width.\n\n    Args:\n        width: width in pixels\n    \"\"\"\n    with self.h_scrollbar.edit_stylesheet() as ss:\n        ss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_scrollbar_policy","title":"<code>set_scrollbar_policy(mode: constants.ScrollBarPolicyStr)</code>","text":"<p>Set the policy for both scrollbars.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ScrollBarPolicyStr</code> <p>visibilty to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid scrollbar policy</p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the policy for both scrollbars.\n\n    Args:\n        mode: visibilty to set\n\n    Raises:\n        InvalidParamError: invalid scrollbar policy\n    \"\"\"\n    if mode not in constants.SCROLLBAR_POLICY:\n        raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n    self.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n    self.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_scrollbar_width","title":"<code>set_scrollbar_width(width: int)</code>","text":"<p>Set the width for both scrollbars.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>width in pixels</p> required Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_scrollbar_width(self, width: int):\n\"\"\"Set the width for both scrollbars.\n\n    Args:\n        width: width in pixels\n    \"\"\"\n    self.set_horizontal_scrollbar_width(width)\n    self.set_vertical_scrollbar_width(width)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_size_adjust_policy","title":"<code>set_size_adjust_policy(policy: SizePolicyStr)</code>","text":"<p>Set size adjust policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizePolicyStr</code> <p>size adjust policy to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid size adjust policy</p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_size_adjust_policy(self, policy: SizePolicyStr):\n\"\"\"Set size adjust policy.\n\n    Args:\n        policy: size adjust policy to use\n\n    Raises:\n        InvalidParamError: invalid size adjust policy\n    \"\"\"\n    if policy not in SIZE_POLICY:\n        raise InvalidParamError(policy, SIZE_POLICY)\n    self.setSizeAdjustPolicy(SIZE_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_vertical_scrollbar_policy","title":"<code>set_vertical_scrollbar_policy(mode: constants.ScrollBarPolicyStr)</code>","text":"<p>Set the vertical scrollbar visibility.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ScrollBarPolicyStr</code> <p>visibilty to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid scrollbar policy</p> Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_vertical_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the vertical scrollbar visibility.\n\n    Args:\n        mode: visibilty to set\n\n    Raises:\n        InvalidParamError: invalid scrollbar policy\n    \"\"\"\n    if mode not in constants.SCROLLBAR_POLICY:\n        raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n    self.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_vertical_scrollbar_width","title":"<code>set_vertical_scrollbar_width(width: int)</code>","text":"<p>Set the vertical scrollbar width.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>width in pixels</p> required Source code in <code>prettyqt\\widgets\\abstractscrollarea.py</code> <pre><code>def set_vertical_scrollbar_width(self, width: int):\n\"\"\"Set the vertical scrollbar width.\n\n    Args:\n        width: width in pixels\n    \"\"\"\n    with self.v_scrollbar.edit_stylesheet() as ss:\n        ss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.AbstractSliderMixin","title":"<code>AbstractSliderMixin</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code></p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>class AbstractSliderMixin(widgets.WidgetMixin):\n    value_changed = core.Signal(int)\n\n    def on_value_change(self):\n        self.value_changed.emit(self.value())\n\n    def is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n\n        Returns:\n            True if horizontal, else False\n        \"\"\"\n        return self.orientation() == constants.HORIZONTAL\n\n    def is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n\n        Returns:\n            True if vertical, else False\n        \"\"\"\n        return self.orientation() == constants.VERTICAL\n\n    def set_horizontal(self):\n\"\"\"Set slider orientation to horizontal.\"\"\"\n        self.setOrientation(constants.HORIZONTAL)\n\n    def set_vertical(self):\n\"\"\"Set slider orientation to vertical.\"\"\"\n        self.setOrientation(constants.VERTICAL)\n\n    def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the slider.\n\n        Args:\n            orientation: orientation for the slider\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in constants.ORIENTATION:\n            raise InvalidParamError(orientation, constants.ORIENTATION)\n        self.setOrientation(constants.ORIENTATION[orientation])\n\n    def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return constants.ORIENTATION.inverse[self.orientation()]\n\n    def scroll_to_min(self):\n\"\"\"Scroll to the minimum value of the slider.\"\"\"\n        self.setValue(self.minimum())\n\n    def scroll_to_max(self):\n\"\"\"Scroll to the maximum value of the slider.\"\"\"\n        self.setValue(self.maximum())\n\n    def set_range(self, min_val: int, max_val: int):\n        self.setRange(min_val, max_val)\n\n    def set_step_size(self, step_size: int):\n        self.setSingleStep(step_size)\n\n    def set_repeat_action(\n        self, action: SliderActionStr, threshold: int = 500, repeat_time: int = 50\n    ):\n\"\"\"Set the repeat action.\n\n        Args:\n            action: repeat action\n            threshold: initial delay in ms\n            repeat_time: repeat time in ms\n\n        Raises:\n            InvalidParamError: invalid repeat action\n        \"\"\"\n        if action not in SLIDER_ACTION:\n            raise InvalidParamError(action, SLIDER_ACTION)\n        self.setRepeatAction(SLIDER_ACTION[action], threshold, repeat_time)\n\n    def get_repeat_action(self) -&gt; SliderActionStr:\n\"\"\"Get current repeat action.\n\n        Returns:\n            current repeat action\n        \"\"\"\n        return SLIDER_ACTION.inverse[self.repeatAction()]\n\n    def trigger_action(self, action: SliderActionStr):\n\"\"\"Trigger slider action.\"\"\"\n        if action not in SLIDER_ACTION:\n            raise InvalidParamError(action, SLIDER_ACTION)\n        self.triggerAction(SLIDER_ACTION[action])\n\n    def get_value(self):\n        return self.value()\n\n    def set_value(self, value: int):\n        self.setValue(value)\n\n    def on_scrollbar_range_changed(self, minval, maxval):\n        if self.value() &gt;= self.maximum() - 1:\n            self.setValue(maxval)\n\n    def set_auto_scroll_to_end(self, scroll: bool = True):\n\"\"\"Set to always scroll to the end when range changes.\"\"\"\n        if scroll:\n            self.rangeChanged.connect(self.on_scrollbar_range_changed)\n        else:\n            self.rangeChanged.disconnect(self.on_scrollbar_range_changed)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.get_repeat_action","title":"<code>get_repeat_action() -&gt; SliderActionStr</code>","text":"<p>Get current repeat action.</p> <p>Returns:</p> Type Description <code>SliderActionStr</code> <p>current repeat action</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def get_repeat_action(self) -&gt; SliderActionStr:\n\"\"\"Get current repeat action.\n\n    Returns:\n        current repeat action\n    \"\"\"\n    return SLIDER_ACTION.inverse[self.repeatAction()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.is_horizontal","title":"<code>is_horizontal() -&gt; bool</code>","text":"<p>Check if silder is horizontal.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if horizontal, else False</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n\n    Returns:\n        True if horizontal, else False\n    \"\"\"\n    return self.orientation() == constants.HORIZONTAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.is_vertical","title":"<code>is_vertical() -&gt; bool</code>","text":"<p>Check if silder is vertical.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if vertical, else False</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n\n    Returns:\n        True if vertical, else False\n    \"\"\"\n    return self.orientation() == constants.VERTICAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.scroll_to_max","title":"<code>scroll_to_max()</code>","text":"<p>Scroll to the maximum value of the slider.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def scroll_to_max(self):\n\"\"\"Scroll to the maximum value of the slider.\"\"\"\n    self.setValue(self.maximum())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.scroll_to_min","title":"<code>scroll_to_min()</code>","text":"<p>Scroll to the minimum value of the slider.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def scroll_to_min(self):\n\"\"\"Scroll to the minimum value of the slider.\"\"\"\n    self.setValue(self.minimum())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_auto_scroll_to_end","title":"<code>set_auto_scroll_to_end(scroll: bool = True)</code>","text":"<p>Set to always scroll to the end when range changes.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def set_auto_scroll_to_end(self, scroll: bool = True):\n\"\"\"Set to always scroll to the end when range changes.\"\"\"\n    if scroll:\n        self.rangeChanged.connect(self.on_scrollbar_range_changed)\n    else:\n        self.rangeChanged.disconnect(self.on_scrollbar_range_changed)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_horizontal","title":"<code>set_horizontal()</code>","text":"<p>Set slider orientation to horizontal.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def set_horizontal(self):\n\"\"\"Set slider orientation to horizontal.\"\"\"\n    self.setOrientation(constants.HORIZONTAL)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_orientation","title":"<code>set_orientation(orientation: constants.OrientationStr)</code>","text":"<p>Set the orientation of the slider.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr</code> <p>orientation for the slider</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the slider.\n\n    Args:\n        orientation: orientation for the slider\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in constants.ORIENTATION:\n        raise InvalidParamError(orientation, constants.ORIENTATION)\n    self.setOrientation(constants.ORIENTATION[orientation])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_repeat_action","title":"<code>set_repeat_action(action: SliderActionStr, threshold: int = 500, repeat_time: int = 50)</code>","text":"<p>Set the repeat action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>SliderActionStr</code> <p>repeat action</p> required <code>threshold</code> <code>int</code> <p>initial delay in ms</p> <code>500</code> <code>repeat_time</code> <code>int</code> <p>repeat time in ms</p> <code>50</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid repeat action</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def set_repeat_action(\n    self, action: SliderActionStr, threshold: int = 500, repeat_time: int = 50\n):\n\"\"\"Set the repeat action.\n\n    Args:\n        action: repeat action\n        threshold: initial delay in ms\n        repeat_time: repeat time in ms\n\n    Raises:\n        InvalidParamError: invalid repeat action\n    \"\"\"\n    if action not in SLIDER_ACTION:\n        raise InvalidParamError(action, SLIDER_ACTION)\n    self.setRepeatAction(SLIDER_ACTION[action], threshold, repeat_time)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_vertical","title":"<code>set_vertical()</code>","text":"<p>Set slider orientation to vertical.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def set_vertical(self):\n\"\"\"Set slider orientation to vertical.\"\"\"\n    self.setOrientation(constants.VERTICAL)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.trigger_action","title":"<code>trigger_action(action: SliderActionStr)</code>","text":"<p>Trigger slider action.</p> Source code in <code>prettyqt\\widgets\\abstractslider.py</code> <pre><code>def trigger_action(self, action: SliderActionStr):\n\"\"\"Trigger slider action.\"\"\"\n    if action not in SLIDER_ACTION:\n        raise InvalidParamError(action, SLIDER_ACTION)\n    self.triggerAction(SLIDER_ACTION[action])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.AbstractSpinBoxMixin","title":"<code>AbstractSpinBoxMixin</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code></p> Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>class AbstractSpinBoxMixin(widgets.WidgetMixin):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.setLineEdit(widgets.LineEdit())\n        self.setGroupSeparatorShown(True)\n\n    def is_valid(self) -&gt; bool:\n        return self.hasAcceptableInput()\n\n    def set_validator(self, validator: gui.Validator):\n        self.lineEdit().setValidator(validator)\n\n    def get_button_symbols(self) -&gt; SymbolStr:\n\"\"\"Return button symbol type.\n\n        Returns:\n            button symbol type\n        \"\"\"\n        return SYMBOLS.inverse[self.buttonSymbols()]\n\n    def set_button_symbols(self, mode: SymbolStr):\n\"\"\"Set button symbol type.\n\n        Args:\n            mode: button symbol type to use\n\n        Raises:\n            InvalidParamError: invalid button symbol type\n        \"\"\"\n        if mode not in SYMBOLS:\n            raise InvalidParamError(mode, SYMBOLS)\n        self.setButtonSymbols(SYMBOLS[mode])\n\n    def set_correction_mode(self, mode: CorrectionModeStr):\n\"\"\"Set correction mode.\n\n        Args:\n            mode: correction mode to use\n\n        Raises:\n            InvalidParamError: invalid correction mode\n        \"\"\"\n        if mode not in CORRECTION_MODES:\n            raise InvalidParamError(mode, CORRECTION_MODES)\n        self.setCorrectionMode(CORRECTION_MODES[mode])\n\n    def get_correction_mode(self) -&gt; CorrectionModeStr:\n\"\"\"Return correction mode.\n\n        Returns:\n            correction mode\n        \"\"\"\n        return CORRECTION_MODES.inverse[self.correctionMode()]\n\n    def set_step_type(self, mode: StepTypeStr):\n\"\"\"Set step type.\n\n        Args:\n            mode: step type to use\n\n        Raises:\n            InvalidParamError: invalid step type\n        \"\"\"\n        if mode not in STEP_TYPES:\n            raise InvalidParamError(mode, STEP_TYPES)\n        self.setStepType(STEP_TYPES[mode])\n\n    def get_step_type(self) -&gt; StepTypeStr:\n\"\"\"Return step type.\n\n        Returns:\n            step type\n        \"\"\"\n        return STEP_TYPES.inverse[self.stepType()]\n\n    def set_special_value(self, value: str):\n        self.setSpecialValueText(value)\n\n    def get_value(self) -&gt; int:\n        return self.value()\n\n    def set_value(self, value: int | float):\n        self.setValue(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.get_button_symbols","title":"<code>get_button_symbols() -&gt; SymbolStr</code>","text":"<p>Return button symbol type.</p> <p>Returns:</p> Type Description <code>SymbolStr</code> <p>button symbol type</p> Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def get_button_symbols(self) -&gt; SymbolStr:\n\"\"\"Return button symbol type.\n\n    Returns:\n        button symbol type\n    \"\"\"\n    return SYMBOLS.inverse[self.buttonSymbols()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.get_correction_mode","title":"<code>get_correction_mode() -&gt; CorrectionModeStr</code>","text":"<p>Return correction mode.</p> <p>Returns:</p> Type Description <code>CorrectionModeStr</code> <p>correction mode</p> Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def get_correction_mode(self) -&gt; CorrectionModeStr:\n\"\"\"Return correction mode.\n\n    Returns:\n        correction mode\n    \"\"\"\n    return CORRECTION_MODES.inverse[self.correctionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.get_step_type","title":"<code>get_step_type() -&gt; StepTypeStr</code>","text":"<p>Return step type.</p> <p>Returns:</p> Type Description <code>StepTypeStr</code> <p>step type</p> Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def get_step_type(self) -&gt; StepTypeStr:\n\"\"\"Return step type.\n\n    Returns:\n        step type\n    \"\"\"\n    return STEP_TYPES.inverse[self.stepType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.set_button_symbols","title":"<code>set_button_symbols(mode: SymbolStr)</code>","text":"<p>Set button symbol type.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SymbolStr</code> <p>button symbol type to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid button symbol type</p> Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def set_button_symbols(self, mode: SymbolStr):\n\"\"\"Set button symbol type.\n\n    Args:\n        mode: button symbol type to use\n\n    Raises:\n        InvalidParamError: invalid button symbol type\n    \"\"\"\n    if mode not in SYMBOLS:\n        raise InvalidParamError(mode, SYMBOLS)\n    self.setButtonSymbols(SYMBOLS[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.set_correction_mode","title":"<code>set_correction_mode(mode: CorrectionModeStr)</code>","text":"<p>Set correction mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CorrectionModeStr</code> <p>correction mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid correction mode</p> Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def set_correction_mode(self, mode: CorrectionModeStr):\n\"\"\"Set correction mode.\n\n    Args:\n        mode: correction mode to use\n\n    Raises:\n        InvalidParamError: invalid correction mode\n    \"\"\"\n    if mode not in CORRECTION_MODES:\n        raise InvalidParamError(mode, CORRECTION_MODES)\n    self.setCorrectionMode(CORRECTION_MODES[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.set_step_type","title":"<code>set_step_type(mode: StepTypeStr)</code>","text":"<p>Set step type.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>StepTypeStr</code> <p>step type to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid step type</p> Source code in <code>prettyqt\\widgets\\abstractspinbox.py</code> <pre><code>def set_step_type(self, mode: StepTypeStr):\n\"\"\"Set step type.\n\n    Args:\n        mode: step type to use\n\n    Raises:\n        InvalidParamError: invalid step type\n    \"\"\"\n    if mode not in STEP_TYPES:\n        raise InvalidParamError(mode, STEP_TYPES)\n    self.setStepType(STEP_TYPES[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ActionGroup","title":"<code>ActionGroup</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtWidgets.QActionGroup</code></p> Source code in <code>prettyqt\\widgets\\actiongroup.py</code> <pre><code>class ActionGroup(core.ObjectMixin, QtWidgets.QActionGroup):\n    def __init__(self, parent: QtCore.QObject | None = None):\n        super().__init__(parent)  # type: ignore\n\n    def __len__(self) -&gt; int:\n        return len(self.actions())\n\n    def __getitem__(self, item: int) -&gt; QtWidgets.QAction:\n        return self.actions()[item]\n\n    def set_exclusion_policy(self, policy: ExclusionPolicyStr | None):\n\"\"\"Set exclusion policy to use.\n\n        Args:\n            policy: exclusion policy to use\n\n        Raises:\n            InvalidParamError: exclusion policy does not exist\n        \"\"\"\n        if policy is None:\n            policy = \"none\"\n        if policy not in POLICIES:\n            raise InvalidParamError(policy, POLICIES)\n        self.setExclusionPolicy(POLICIES[policy])\n\n    def get_exclusion_policy(self) -&gt; ExclusionPolicyStr:\n\"\"\"Return current exclusion policy.\n\n        Returns:\n            exclusion policy\n        \"\"\"\n        return POLICIES.inverse[self.exclusionPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.get_exclusion_policy","title":"<code>get_exclusion_policy() -&gt; ExclusionPolicyStr</code>","text":"<p>Return current exclusion policy.</p> <p>Returns:</p> Type Description <code>ExclusionPolicyStr</code> <p>exclusion policy</p> Source code in <code>prettyqt\\widgets\\actiongroup.py</code> <pre><code>def get_exclusion_policy(self) -&gt; ExclusionPolicyStr:\n\"\"\"Return current exclusion policy.\n\n    Returns:\n        exclusion policy\n    \"\"\"\n    return POLICIES.inverse[self.exclusionPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.set_exclusion_policy","title":"<code>set_exclusion_policy(policy: ExclusionPolicyStr | None)</code>","text":"<p>Set exclusion policy to use.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>ExclusionPolicyStr | None</code> <p>exclusion policy to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>exclusion policy does not exist</p> Source code in <code>prettyqt\\widgets\\actiongroup.py</code> <pre><code>def set_exclusion_policy(self, policy: ExclusionPolicyStr | None):\n\"\"\"Set exclusion policy to use.\n\n    Args:\n        policy: exclusion policy to use\n\n    Raises:\n        InvalidParamError: exclusion policy does not exist\n    \"\"\"\n    if policy is None:\n        policy = \"none\"\n    if policy not in POLICIES:\n        raise InvalidParamError(policy, POLICIES)\n    self.setExclusionPolicy(POLICIES[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ActionMixin","title":"<code>ActionMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\widgets\\action.py</code> <pre><code>class ActionMixin(core.ObjectMixin):\n    def __init__(\n        self,\n        parent: QtCore.QObject | None = None,\n        text: str = \"\",\n        icon: datatypes.IconType = None,\n        shortcut: str | None = None,\n        tooltip: str = \"\",\n        checkable: bool = False,\n        checked: bool = False,\n        statustip: str = \"\",\n        enabled: bool = True,\n        callback: Callable | None = None,\n    ):\n        super().__init__(parent)\n        self._menu = None\n        self.set_text(text)\n        self.set_icon(icon)\n        self.set_shortcut(shortcut)\n        self.set_tooltip(tooltip)\n        self.set_checkable(checkable)\n        self.set_checked(checked)\n        self.set_statustip(statustip)\n        self.set_enabled(enabled)\n        if callback is not None:\n            self.triggered.connect(callback)\n\n    def __repr__(self) -&gt; str:\n        return get_repr(self, self.text())\n\n    def set_text(self, text: str):\n        self.setText(text)\n\n    def set_enabled(self, enabled: bool = True):\n        self.setEnabled(enabled)\n\n    def set_disabled(self):\n        self.setEnabled(False)\n\n    def set_tooltip(\n        self,\n        tooltip: str | datatypes.PathType,\n        size: datatypes.SizeType | None = None,\n    ):\n        if isinstance(tooltip, os.PathLike):\n            path = os.fspath(tooltip)\n            if size is None:\n                tooltip = f\"&lt;img src={path!r}&gt;\"\n            else:\n                if isinstance(size, QtCore.QSize):\n                    size = (size.width(), size.height())\n                tooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\n        self.setToolTip(tooltip)\n\n    def set_statustip(self, text: str):\n        self.setStatusTip(text)\n\n    def set_checked(self, value: bool):\n        self.setChecked(value)\n\n    def set_checkable(self, value: bool):\n        self.setCheckable(value)\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        return None if icon.isNull() else gui.Icon(icon)\n\n    def set_shortcut(self, shortcut: None | QtGui.QKeySequence | str):\n        if shortcut is None:\n            shortcut = \"\"\n        if isinstance(shortcut, str):\n            shortcut = gui.KeySequence(\n                shortcut, gui.KeySequence.SequenceFormat.PortableText\n            )\n        self.setShortcut(shortcut)\n\n    def get_shortcut(self) -&gt; gui.KeySequence | None:\n        shortcut = self.shortcut()\n        return (\n            gui.KeySequence(\n                shortcut.toString(), gui.KeySequence.SequenceFormat.PortableText\n            )\n            if shortcut\n            else None\n        )\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def set_menu(self, menu):\n        try:\n            self.setMenu(menu)\n        except AttributeError:\n            self.triggered.connect(menu.exec)\n            self._menu = menu\n\n    def menu(self):\n        return self._menu\n\n    def set_priority(self, priority: PriorityStr):\n\"\"\"Set priority of the action.\n\n        Args:\n            priority: priority for the action\n\n        Raises:\n            InvalidParamError: priority does not exist\n        \"\"\"\n        if priority not in PRIORITIES:\n            raise InvalidParamError(priority, PRIORITIES)\n        self.setPriority(PRIORITIES[priority])\n\n    def get_priority(self) -&gt; PriorityStr:\n\"\"\"Return current priority.\n\n        Returns:\n            priority\n        \"\"\"\n        return PRIORITIES.inverse[self.priority()]\n\n    def set_shortcut_context(self, context: constants.ContextStr):\n\"\"\"Set shortcut context.\n\n        Args:\n            context: shortcut context\n\n        Raises:\n            InvalidParamError: shortcut context does not exist\n        \"\"\"\n        if context not in constants.CONTEXT:\n            raise InvalidParamError(context, constants.CONTEXT)\n        self.setShortcutContext(constants.CONTEXT[context])\n\n    def get_shortcut_context(self) -&gt; constants.ContextStr:\n\"\"\"Return shortcut context.\n\n        Returns:\n            shortcut context\n        \"\"\"\n        return constants.CONTEXT.inverse[self.shortcutContext()]\n\n    def set_menu_role(self, role: RoleStr):\n\"\"\"Set menu role.\n\n        Args:\n            role: menu role\n\n        Raises:\n            InvalidParamError: menu role does not exist\n        \"\"\"\n        if role not in ROLES:\n            raise InvalidParamError(role, ROLES)\n        self.setMenuRole(ROLES[role])\n\n    def get_menu_role(self) -&gt; RoleStr:\n\"\"\"Return menu role.\n\n        Returns:\n            menu role\n        \"\"\"\n        return ROLES.inverse[self.menuRole()]\n\n    def show_shortcut_in_contextmenu(self, state: bool = True):\n        self.setShortcutVisibleInContextMenu(state)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.get_menu_role","title":"<code>get_menu_role() -&gt; RoleStr</code>","text":"<p>Return menu role.</p> <p>Returns:</p> Type Description <code>RoleStr</code> <p>menu role</p> Source code in <code>prettyqt\\widgets\\action.py</code> <pre><code>def get_menu_role(self) -&gt; RoleStr:\n\"\"\"Return menu role.\n\n    Returns:\n        menu role\n    \"\"\"\n    return ROLES.inverse[self.menuRole()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.get_priority","title":"<code>get_priority() -&gt; PriorityStr</code>","text":"<p>Return current priority.</p> <p>Returns:</p> Type Description <code>PriorityStr</code> <p>priority</p> Source code in <code>prettyqt\\widgets\\action.py</code> <pre><code>def get_priority(self) -&gt; PriorityStr:\n\"\"\"Return current priority.\n\n    Returns:\n        priority\n    \"\"\"\n    return PRIORITIES.inverse[self.priority()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.get_shortcut_context","title":"<code>get_shortcut_context() -&gt; constants.ContextStr</code>","text":"<p>Return shortcut context.</p> <p>Returns:</p> Type Description <code>constants.ContextStr</code> <p>shortcut context</p> Source code in <code>prettyqt\\widgets\\action.py</code> <pre><code>def get_shortcut_context(self) -&gt; constants.ContextStr:\n\"\"\"Return shortcut context.\n\n    Returns:\n        shortcut context\n    \"\"\"\n    return constants.CONTEXT.inverse[self.shortcutContext()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\action.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.set_menu_role","title":"<code>set_menu_role(role: RoleStr)</code>","text":"<p>Set menu role.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>RoleStr</code> <p>menu role</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>menu role does not exist</p> Source code in <code>prettyqt\\widgets\\action.py</code> <pre><code>def set_menu_role(self, role: RoleStr):\n\"\"\"Set menu role.\n\n    Args:\n        role: menu role\n\n    Raises:\n        InvalidParamError: menu role does not exist\n    \"\"\"\n    if role not in ROLES:\n        raise InvalidParamError(role, ROLES)\n    self.setMenuRole(ROLES[role])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.set_priority","title":"<code>set_priority(priority: PriorityStr)</code>","text":"<p>Set priority of the action.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>PriorityStr</code> <p>priority for the action</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>priority does not exist</p> Source code in <code>prettyqt\\widgets\\action.py</code> <pre><code>def set_priority(self, priority: PriorityStr):\n\"\"\"Set priority of the action.\n\n    Args:\n        priority: priority for the action\n\n    Raises:\n        InvalidParamError: priority does not exist\n    \"\"\"\n    if priority not in PRIORITIES:\n        raise InvalidParamError(priority, PRIORITIES)\n    self.setPriority(PRIORITIES[priority])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.set_shortcut_context","title":"<code>set_shortcut_context(context: constants.ContextStr)</code>","text":"<p>Set shortcut context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>constants.ContextStr</code> <p>shortcut context</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>shortcut context does not exist</p> Source code in <code>prettyqt\\widgets\\action.py</code> <pre><code>def set_shortcut_context(self, context: constants.ContextStr):\n\"\"\"Set shortcut context.\n\n    Args:\n        context: shortcut context\n\n    Raises:\n        InvalidParamError: shortcut context does not exist\n    \"\"\"\n    if context not in constants.CONTEXT:\n        raise InvalidParamError(context, constants.CONTEXT)\n    self.setShortcutContext(constants.CONTEXT[context])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.CalendarWidget","title":"<code>CalendarWidget</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QCalendarWidget</code></p> Source code in <code>prettyqt\\widgets\\calendarwidget.py</code> <pre><code>class CalendarWidget(widgets.WidgetMixin, QtWidgets.QCalendarWidget):\n    def get_date(self) -&gt; datetime.date:\n        return self.selectedDate().toPython()  # type: ignore\n\n    def get_value(self) -&gt; datetime.date:\n        return self.get_date()\n\n    def set_value(self, value: datatypes.DateType):\n        if isinstance(value, str):\n            value = QtCore.QDate.fromString(value)\n        self.setSelectedDate(value)  # type: ignore\n\n    def set_range(\n        self,\n        lower: datatypes.DateType,\n        upper: datatypes.DateType,\n    ):\n        if isinstance(lower, str):\n            lower = QtCore.QDate.fromString(lower)\n        if isinstance(upper, str):\n            upper = QtCore.QDate.fromString(upper)\n        self.setMinimumDate(lower)  # type: ignore\n        self.setMaximumDate(upper)  # type: ignore\n\n    def set_selection_mode(self, mode: SelectionModeStr | None):\n\"\"\"Set selection mode for given calendar widget.\n\n        Args:\n            mode: selection mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode is None:\n            mode = \"none\"\n        if mode not in SELECTION_MODE:\n            raise InvalidParamError(mode, SELECTION_MODE)\n        self.setSelectionMode(SELECTION_MODE[mode])\n\n    def get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n\n        Returns:\n            selection mode\n        \"\"\"\n        return SELECTION_MODE.inverse[self.selectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.get_selection_mode","title":"<code>get_selection_mode() -&gt; SelectionModeStr</code>","text":"<p>Return current selection mode.</p> <p>Returns:</p> Type Description <code>SelectionModeStr</code> <p>selection mode</p> Source code in <code>prettyqt\\widgets\\calendarwidget.py</code> <pre><code>def get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n\n    Returns:\n        selection mode\n    \"\"\"\n    return SELECTION_MODE.inverse[self.selectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.set_selection_mode","title":"<code>set_selection_mode(mode: SelectionModeStr | None)</code>","text":"<p>Set selection mode for given calendar widget.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SelectionModeStr | None</code> <p>selection mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\widgets\\calendarwidget.py</code> <pre><code>def set_selection_mode(self, mode: SelectionModeStr | None):\n\"\"\"Set selection mode for given calendar widget.\n\n    Args:\n        mode: selection mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode is None:\n        mode = \"none\"\n    if mode not in SELECTION_MODE:\n        raise InvalidParamError(mode, SELECTION_MODE)\n    self.setSelectionMode(SELECTION_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.CheckBox","title":"<code>CheckBox</code>","text":"<p>         Bases: <code>widgets.AbstractButtonMixin</code>, <code>QtWidgets.QCheckBox</code></p> Source code in <code>prettyqt\\widgets\\checkbox.py</code> <pre><code>class CheckBox(widgets.AbstractButtonMixin, QtWidgets.QCheckBox):\n    value_changed = core.Signal(int)\n\n    def __init__(\n        self,\n        label: str = \"\",\n        parent: QtWidgets.QWidget | None = None,\n        checked: bool = False,\n    ):\n        super().__init__(label, parent)\n        self.stateChanged.connect(self.value_changed)\n        self.setChecked(checked)\n\n    def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n        Args:\n            state: checkstate to use\n\n        Raises:\n            InvalidParamError: invalid checkstate\n        \"\"\"\n        if state not in constants.STATE:\n            raise InvalidParamError(state, constants.STATE)\n        self.setCheckState(constants.STATE[state])\n\n    def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n        Returns:\n            checkstate\n        \"\"\"\n        return constants.STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.get_checkstate","title":"<code>get_checkstate() -&gt; constants.StateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.StateStr</code> <p>checkstate</p> Source code in <code>prettyqt\\widgets\\checkbox.py</code> <pre><code>def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n    Returns:\n        checkstate\n    \"\"\"\n    return constants.STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.set_checkstate","title":"<code>set_checkstate(state: constants.StateStr)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.StateStr</code> <p>checkstate to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid checkstate</p> Source code in <code>prettyqt\\widgets\\checkbox.py</code> <pre><code>def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n    Args:\n        state: checkstate to use\n\n    Raises:\n        InvalidParamError: invalid checkstate\n    \"\"\"\n    if state not in constants.STATE:\n        raise InvalidParamError(state, constants.STATE)\n    self.setCheckState(constants.STATE[state])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ComboBoxMixin","title":"<code>ComboBoxMixin</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code></p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>class ComboBoxMixin(widgets.WidgetMixin):\n    value_changed = core.Signal(object)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.currentIndexChanged.connect(self.index_changed)\n\n    # def serialize_fields(self):\n    #     items = [\n    #         (self.itemText(i), self.itemData(i), self.item_icon(i))\n    #         for i in range(self.count())\n    #     ]\n    #     return dict(\n    #         index=self.currentIndex(),\n    #         editable=self.isEditable(),\n    #         max_count=self.maxCount(),\n    #         has_frame=self.hasFrame(),\n    #         icon_size=self.iconSize(),\n    #         insert_policy=self.insertPolicy(),\n    #         model_column=self.modelColumn(),\n    #         max_visible_items=self.maxVisibleItems(),\n    #         size_adjust_policy=self.get_size_adjust_policy(),\n    #         duplicates_enabled=self.duplicatesEnabled(),\n    #         min_contents_length=self.minimumContentsLength(),\n    #         placeholder_text=self.placeholderText(),\n    #         items=items,\n    #     )\n\n    # def __setstate__(self, state):\n    #     super().__setstate__(state)\n    #     for label, data, icon in state[\"items\"]:\n    #         self.add(label, data, icon=icon)\n    #     self.setCurrentIndex(state[\"index\"])\n    #     self.setEditable(state[\"editable\"])\n    #     self.setMaxCount(state[\"max_count\"])\n    #     self.setMaxVisibleItems(state[\"max_visible_items\"])\n    #     self.setMinimumContentsLength(state[\"min_contents_length\"])\n    #     self.setDuplicatesEnabled(state[\"duplicates_enabled\"])\n    #     self.setFrame(state[\"has_frame\"])\n\n    # def __reduce__(self):\n    #     return type(self), (), self.__getstate__()\n\n    def __len__(self) -&gt; int:\n        return self.count()\n\n    def index_changed(self, index: int):\n        data = self.itemData(index)\n        self.value_changed.emit(data)\n\n    def add_items(self, items: Iterable | Mapping, default=NoData):\n        if isinstance(items, Mapping):\n            for k, v in items.items():\n                self.addItem(v, userData=k)\n        else:\n            for i in items:\n                if isinstance(i, tuple | list):\n                    self.add(*i)\n                else:\n                    self.addItem(i, i)\n        if default is not NoData:\n            self.set_value(default)\n\n    def add(self, label: str, data=NoData, icon: datatypes.IconType = None):\n        if data is NoData:\n            data = label\n        if icon is not None:\n            icon = iconprovider.get_icon(icon)\n            self.addItem(gui.Icon(icon), label, userData=data)\n        else:\n            self.addItem(label, userData=data)\n\n    def item_icon(self, index: int) -&gt; gui.Icon | None:\n        icon = self.itemIcon(index)\n        return None if icon.isNull() else gui.Icon(icon)\n\n    def set_editable(self, editable: bool):\n        self.setEditable(editable)\n        if self.completer() is None and editable:\n            self.setCompleter(widgets.Completer(self))\n\n    def set_insert_policy(self, policy: InsertPolicyStr):\n\"\"\"Set insert policy.\n\n        Args:\n            policy: insert policy to use\n\n        Raises:\n            InvalidParamError: invalid insert policy\n        \"\"\"\n        if policy not in INSERT_POLICY:\n            raise InvalidParamError(policy, INSERT_POLICY)\n        self.setInsertPolicy(INSERT_POLICY[policy])\n\n    def get_insert_policy(self) -&gt; InsertPolicyStr:\n\"\"\"Return insert policy.\n\n        Returns:\n            insert policy\n        \"\"\"\n        return INSERT_POLICY.inverse[self.insertPolicy()]\n\n    def set_size_adjust_policy(self, policy: SizeAdjustPolicyStr):\n\"\"\"Set size adjust policy.\n\n        Args:\n            policy: size adjust policy to use\n\n        Raises:\n            InvalidParamError: invalid size adjust policy\n        \"\"\"\n        if policy not in SIZE_ADJUST_POLICY:\n            raise InvalidParamError(policy, SIZE_ADJUST_POLICY)\n        self.setSizeAdjustPolicy(SIZE_ADJUST_POLICY[policy])\n\n    def get_size_adjust_policy(self) -&gt; SizeAdjustPolicyStr:\n\"\"\"Return size adjust policy.\n\n        Returns:\n            size adjust policy\n        \"\"\"\n        return SIZE_ADJUST_POLICY.inverse[self.sizeAdjustPolicy()]\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n        if isinstance(size, int):\n            size = core.Size(size, size)\n        elif isinstance(size, tuple):\n            size = core.Size(*size)\n        self.setIconSize(size)\n\n    def get_icon_size(self) -&gt; core.Size:\n        return core.Size(self.iconSize())\n\n    def set_min_char_length(self, chars: int):\n        self.setMinimumContentsLength(chars)\n\n    def get_value(self) -&gt; Any:\n        # if all(self.itemData(i) is None for i in range(self.count())):\n        #     return self.currentText()\n        # else:\n        #     return self.currentData()\n        return self.currentData()\n\n    def set_value(self, value: Any):\n        self.set_data(value)\n\n    def set_text(self, text: str):\n        self.setCurrentText(text)\n\n    def set_data(self, data: Any):\n        idx = self.findData(data)\n        if idx == -1:\n            raise ValueError(\"invalid data\")\n        self.setCurrentIndex(idx)\n\n    def text(self) -&gt; str:\n        return self.currentText()\n\n    def hide_completer(self):\n\"\"\"Hides the completion widget.\"\"\"\n        completer = widgets.Completer(self)\n        self.setCompleter(completer)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.get_insert_policy","title":"<code>get_insert_policy() -&gt; InsertPolicyStr</code>","text":"<p>Return insert policy.</p> <p>Returns:</p> Type Description <code>InsertPolicyStr</code> <p>insert policy</p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def get_insert_policy(self) -&gt; InsertPolicyStr:\n\"\"\"Return insert policy.\n\n    Returns:\n        insert policy\n    \"\"\"\n    return INSERT_POLICY.inverse[self.insertPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.get_size_adjust_policy","title":"<code>get_size_adjust_policy() -&gt; SizeAdjustPolicyStr</code>","text":"<p>Return size adjust policy.</p> <p>Returns:</p> Type Description <code>SizeAdjustPolicyStr</code> <p>size adjust policy</p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def get_size_adjust_policy(self) -&gt; SizeAdjustPolicyStr:\n\"\"\"Return size adjust policy.\n\n    Returns:\n        size adjust policy\n    \"\"\"\n    return SIZE_ADJUST_POLICY.inverse[self.sizeAdjustPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.hide_completer","title":"<code>hide_completer()</code>","text":"<p>Hides the completion widget.</p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def hide_completer(self):\n\"\"\"Hides the completion widget.\"\"\"\n    completer = widgets.Completer(self)\n    self.setCompleter(completer)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.set_icon_size","title":"<code>set_icon_size(size: int | datatypes.SizeType)</code>","text":"<p>Set size of the icons.</p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n    if isinstance(size, int):\n        size = core.Size(size, size)\n    elif isinstance(size, tuple):\n        size = core.Size(*size)\n    self.setIconSize(size)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.set_insert_policy","title":"<code>set_insert_policy(policy: InsertPolicyStr)</code>","text":"<p>Set insert policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>InsertPolicyStr</code> <p>insert policy to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid insert policy</p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def set_insert_policy(self, policy: InsertPolicyStr):\n\"\"\"Set insert policy.\n\n    Args:\n        policy: insert policy to use\n\n    Raises:\n        InvalidParamError: invalid insert policy\n    \"\"\"\n    if policy not in INSERT_POLICY:\n        raise InvalidParamError(policy, INSERT_POLICY)\n    self.setInsertPolicy(INSERT_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.set_size_adjust_policy","title":"<code>set_size_adjust_policy(policy: SizeAdjustPolicyStr)</code>","text":"<p>Set size adjust policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizeAdjustPolicyStr</code> <p>size adjust policy to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid size adjust policy</p> Source code in <code>prettyqt\\widgets\\combobox.py</code> <pre><code>def set_size_adjust_policy(self, policy: SizeAdjustPolicyStr):\n\"\"\"Set size adjust policy.\n\n    Args:\n        policy: size adjust policy to use\n\n    Raises:\n        InvalidParamError: invalid size adjust policy\n    \"\"\"\n    if policy not in SIZE_ADJUST_POLICY:\n        raise InvalidParamError(policy, SIZE_ADJUST_POLICY)\n    self.setSizeAdjustPolicy(SIZE_ADJUST_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.Completer","title":"<code>Completer</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtWidgets.QCompleter</code></p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>class Completer(core.ObjectMixin, QtWidgets.QCompleter):\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(parent)\n\n    def set_sort_mode(self, mode: SortModeStr | None):\n\"\"\"Set sort mode to use.\n\n        Args:\n            mode: sort mode to use\n\n        Raises:\n            InvalidParamError: sort mode does not exist\n        \"\"\"\n        if mode is None:\n            mode = \"unsorted\"\n        if mode not in SORT_MODE:\n            raise InvalidParamError(mode, SORT_MODE)\n        self.setModelSorting(SORT_MODE[mode])\n\n    def get_sort_mode(self) -&gt; SortModeStr:\n\"\"\"Return current sort mode.\n\n        Returns:\n            sort mode\n        \"\"\"\n        return SORT_MODE.inverse[self.modelSorting()]\n\n    def set_completion_mode(self, mode: CompletionModeStr):\n\"\"\"Set completion mode to use.\n\n        Args:\n            mode: completion mode to use\n\n        Raises:\n            InvalidParamError: completion mode does not exist\n        \"\"\"\n        if mode not in COMPLETION_MODE:\n            raise InvalidParamError(mode, COMPLETION_MODE)\n        self.setCompletionMode(COMPLETION_MODE[mode])\n\n    def get_completion_mode(self) -&gt; CompletionModeStr:\n\"\"\"Return current completion mode.\n\n        Returns:\n            completion mode\n        \"\"\"\n        return COMPLETION_MODE.inverse[self.completionMode()]\n\n    def set_filter_mode(self, mode: constants.FilterModeStr):\n\"\"\"Set filter mode to use.\n\n        Args:\n            mode: filter mode to use\n\n        Raises:\n            InvalidParamError: filter mode does not exist\n        \"\"\"\n        if mode not in constants.FILTER_MODES:\n            raise InvalidParamError(mode, constants.FILTER_MODES)\n        self.setFilterMode(constants.FILTER_MODES[mode])\n\n    def get_filter_mode(self) -&gt; constants.FilterModeStr:\n\"\"\"Return current filter mode.\n\n        Returns:\n            filter mode\n        \"\"\"\n        return constants.FILTER_MODES.inverse[self.filterMode()]\n\n    def set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n\n        Args:\n            state: case sensitive\n\n        \"\"\"\n        sensitivity = (\n            QtCore.Qt.CaseSensitivity.CaseSensitive\n            if state\n            else QtCore.Qt.CaseSensitivity.CaseInsensitive\n        )\n        self.setCaseSensitivity(sensitivity)\n\n    def is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n\n        Returns:\n            case sensitivity\n        \"\"\"\n        return bool(self.caseSensitivity())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_completion_mode","title":"<code>get_completion_mode() -&gt; CompletionModeStr</code>","text":"<p>Return current completion mode.</p> <p>Returns:</p> Type Description <code>CompletionModeStr</code> <p>completion mode</p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def get_completion_mode(self) -&gt; CompletionModeStr:\n\"\"\"Return current completion mode.\n\n    Returns:\n        completion mode\n    \"\"\"\n    return COMPLETION_MODE.inverse[self.completionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_filter_mode","title":"<code>get_filter_mode() -&gt; constants.FilterModeStr</code>","text":"<p>Return current filter mode.</p> <p>Returns:</p> Type Description <code>constants.FilterModeStr</code> <p>filter mode</p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def get_filter_mode(self) -&gt; constants.FilterModeStr:\n\"\"\"Return current filter mode.\n\n    Returns:\n        filter mode\n    \"\"\"\n    return constants.FILTER_MODES.inverse[self.filterMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_sort_mode","title":"<code>get_sort_mode() -&gt; SortModeStr</code>","text":"<p>Return current sort mode.</p> <p>Returns:</p> Type Description <code>SortModeStr</code> <p>sort mode</p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def get_sort_mode(self) -&gt; SortModeStr:\n\"\"\"Return current sort mode.\n\n    Returns:\n        sort mode\n    \"\"\"\n    return SORT_MODE.inverse[self.modelSorting()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.is_case_sensitive","title":"<code>is_case_sensitive() -&gt; bool</code>","text":"<p>Return case sensitivity.</p> <p>Returns:</p> Type Description <code>bool</code> <p>case sensitivity</p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n\n    Returns:\n        case sensitivity\n    \"\"\"\n    return bool(self.caseSensitivity())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_case_sensitive","title":"<code>set_case_sensitive(state: bool)</code>","text":"<p>Set case sensitivity.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>case sensitive</p> required Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n\n    Args:\n        state: case sensitive\n\n    \"\"\"\n    sensitivity = (\n        QtCore.Qt.CaseSensitivity.CaseSensitive\n        if state\n        else QtCore.Qt.CaseSensitivity.CaseInsensitive\n    )\n    self.setCaseSensitivity(sensitivity)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_completion_mode","title":"<code>set_completion_mode(mode: CompletionModeStr)</code>","text":"<p>Set completion mode to use.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CompletionModeStr</code> <p>completion mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>completion mode does not exist</p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def set_completion_mode(self, mode: CompletionModeStr):\n\"\"\"Set completion mode to use.\n\n    Args:\n        mode: completion mode to use\n\n    Raises:\n        InvalidParamError: completion mode does not exist\n    \"\"\"\n    if mode not in COMPLETION_MODE:\n        raise InvalidParamError(mode, COMPLETION_MODE)\n    self.setCompletionMode(COMPLETION_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_filter_mode","title":"<code>set_filter_mode(mode: constants.FilterModeStr)</code>","text":"<p>Set filter mode to use.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.FilterModeStr</code> <p>filter mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>filter mode does not exist</p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def set_filter_mode(self, mode: constants.FilterModeStr):\n\"\"\"Set filter mode to use.\n\n    Args:\n        mode: filter mode to use\n\n    Raises:\n        InvalidParamError: filter mode does not exist\n    \"\"\"\n    if mode not in constants.FILTER_MODES:\n        raise InvalidParamError(mode, constants.FILTER_MODES)\n    self.setFilterMode(constants.FILTER_MODES[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_sort_mode","title":"<code>set_sort_mode(mode: SortModeStr | None)</code>","text":"<p>Set sort mode to use.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SortModeStr | None</code> <p>sort mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>sort mode does not exist</p> Source code in <code>prettyqt\\widgets\\completer.py</code> <pre><code>def set_sort_mode(self, mode: SortModeStr | None):\n\"\"\"Set sort mode to use.\n\n    Args:\n        mode: sort mode to use\n\n    Raises:\n        InvalidParamError: sort mode does not exist\n    \"\"\"\n    if mode is None:\n        mode = \"unsorted\"\n    if mode not in SORT_MODE:\n        raise InvalidParamError(mode, SORT_MODE)\n    self.setModelSorting(SORT_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.DataWidgetMapper","title":"<code>DataWidgetMapper</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtWidgets.QDataWidgetMapper</code></p> Source code in <code>prettyqt\\widgets\\datawidgetmapper.py</code> <pre><code>class DataWidgetMapper(core.ObjectMixin, QtWidgets.QDataWidgetMapper):\n    def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the data widget mapper.\n\n        Args:\n            orientation: orientation for the data widget mapper\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in constants.ORIENTATION:\n            raise InvalidParamError(orientation, constants.ORIENTATION)\n        self.setOrientation(constants.ORIENTATION[orientation])\n\n    def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return constants.ORIENTATION.inverse[self.orientation()]\n\n    def set_submit_policy(self, policy: SubmitPolicyStr):\n\"\"\"Set the submit policy of the mapper.\n\n        Args:\n            policy: submit_policy for the data widget mapper\n\n        Raises:\n            InvalidParamError: submit_policy does not exist\n        \"\"\"\n        if policy not in SUBMIT_POLICY:\n            raise InvalidParamError(policy, SUBMIT_POLICY)\n        self.setSubmitPolicy(SUBMIT_POLICY[policy])\n\n    def get_submit_policy(self) -&gt; SubmitPolicyStr:\n\"\"\"Return current submit policy.\n\n        Returns:\n            submit policy\n        \"\"\"\n        return SUBMIT_POLICY.inverse[self.submitPolicy()]\n\n    def add_mapping(\n        self, widget: QtWidgets.QWidget, section: int, property_name: str | None = None\n    ):\n        if property_name is None:\n            self.addMapping(widget, section)\n        else:\n            ba = QtCore.QByteArray(property_name.encode())\n            self.addMapping(widget, section, ba)\n\n    def get_mapped_property_name(self, widget: QtWidgets.QWidget) -&gt; str:\n        return self.mappedPropertyName(widget).data().decode()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\widgets\\datawidgetmapper.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_submit_policy","title":"<code>get_submit_policy() -&gt; SubmitPolicyStr</code>","text":"<p>Return current submit policy.</p> <p>Returns:</p> Type Description <code>SubmitPolicyStr</code> <p>submit policy</p> Source code in <code>prettyqt\\widgets\\datawidgetmapper.py</code> <pre><code>def get_submit_policy(self) -&gt; SubmitPolicyStr:\n\"\"\"Return current submit policy.\n\n    Returns:\n        submit policy\n    \"\"\"\n    return SUBMIT_POLICY.inverse[self.submitPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_orientation","title":"<code>set_orientation(orientation: constants.OrientationStr)</code>","text":"<p>Set the orientation of the data widget mapper.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr</code> <p>orientation for the data widget mapper</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt\\widgets\\datawidgetmapper.py</code> <pre><code>def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the data widget mapper.\n\n    Args:\n        orientation: orientation for the data widget mapper\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in constants.ORIENTATION:\n        raise InvalidParamError(orientation, constants.ORIENTATION)\n    self.setOrientation(constants.ORIENTATION[orientation])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_submit_policy","title":"<code>set_submit_policy(policy: SubmitPolicyStr)</code>","text":"<p>Set the submit policy of the mapper.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SubmitPolicyStr</code> <p>submit_policy for the data widget mapper</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>submit_policy does not exist</p> Source code in <code>prettyqt\\widgets\\datawidgetmapper.py</code> <pre><code>def set_submit_policy(self, policy: SubmitPolicyStr):\n\"\"\"Set the submit policy of the mapper.\n\n    Args:\n        policy: submit_policy for the data widget mapper\n\n    Raises:\n        InvalidParamError: submit_policy does not exist\n    \"\"\"\n    if policy not in SUBMIT_POLICY:\n        raise InvalidParamError(policy, SUBMIT_POLICY)\n    self.setSubmitPolicy(SUBMIT_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.DialogButtonBox","title":"<code>DialogButtonBox</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QDialogButtonBox</code></p> Source code in <code>prettyqt\\widgets\\dialogbuttonbox.py</code> <pre><code>class DialogButtonBox(widgets.WidgetMixin, QtWidgets.QDialogButtonBox):\n    button_clicked = core.Signal(str)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.clicked.connect(self.on_click)\n\n    def __len__(self) -&gt; int:\n        return len(self.buttons())\n\n    def __getitem__(self, index: ButtonStr) -&gt; QtWidgets.QPushButton:\n        return self.button(BUTTONS[index])\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QAbstractButton]:\n        return iter(self.buttons())\n\n    def __contains__(self, index: ButtonStr):\n        return self.button(BUTTONS[index]) is not None\n\n    @classmethod\n    def create(cls, **kwargs):\n        box = cls()\n        for k, v in kwargs.items():\n            box.add_default_button(k, callback=v)  # type: ignore\n        return box\n\n    def on_click(self, button: QtCore.QObject):\n        self.button_clicked.emit(button.objectName())\n\n    def set_horizontal(self):\n        self.setOrientation(constants.HORIZONTAL)\n\n    def set_vertical(self):\n        self.setOrientation(constants.VERTICAL)\n\n    def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the button box.\n\n        Args:\n            orientation: orientation for the button box\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in constants.ORIENTATION:\n            raise InvalidParamError(orientation, constants.ORIENTATION)\n        self.setOrientation(constants.ORIENTATION[orientation])\n\n    def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return constants.ORIENTATION.inverse[self.orientation()]\n\n    def add_default_buttons(self, buttons: Sequence[ButtonStr]):\n        return [self.add_default_button(btn) for btn in buttons]\n\n    def add_default_button(\n        self, button: ButtonStr, callback: Callable | None = None\n    ) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n\n        Args:\n            button: button to add\n            callback: function to call when button gets clicked\n\n        Returns:\n            created button\n\n        Raises:\n            InvalidParamError: Button type not available\n        \"\"\"\n        if button not in BUTTONS:\n            raise InvalidParamError(button, BUTTONS)\n        btn = self.addButton(BUTTONS[button])\n        btn.setObjectName(button)\n        if callback:\n            btn.clicked.connect(callback)\n        return btn\n\n    def add_button(\n        self,\n        button: QtWidgets.QPushButton | ButtonStr,\n        role: RoleStr = \"accept\",\n        callback: Callable | None = None,\n    ) -&gt; widgets.PushButton:\n\"\"\"Add a button.\n\n        Args:\n            button: button to add\n            role: role of the button\n            callback: function to call when button gets clicked\n\n        Returns:\n            created button\n\n        Raises:\n            InvalidParamError: Button type not available\n        \"\"\"\n        if isinstance(button, str):\n            button = widgets.PushButton(button)\n        self.addButton(button, ROLES[role])\n        if callback:\n            button.clicked.connect(callback)\n        return button\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_button","title":"<code>add_button(button: QtWidgets.QPushButton | ButtonStr, role: RoleStr = 'accept', callback: Callable | None = None) -&gt; widgets.PushButton</code>","text":"<p>Add a button.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>QtWidgets.QPushButton | ButtonStr</code> <p>button to add</p> required <code>role</code> <code>RoleStr</code> <p>role of the button</p> <code>'accept'</code> <code>callback</code> <code>Callable | None</code> <p>function to call when button gets clicked</p> <code>None</code> <p>Returns:</p> Type Description <code>widgets.PushButton</code> <p>created button</p> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>Button type not available</p> Source code in <code>prettyqt\\widgets\\dialogbuttonbox.py</code> <pre><code>def add_button(\n    self,\n    button: QtWidgets.QPushButton | ButtonStr,\n    role: RoleStr = \"accept\",\n    callback: Callable | None = None,\n) -&gt; widgets.PushButton:\n\"\"\"Add a button.\n\n    Args:\n        button: button to add\n        role: role of the button\n        callback: function to call when button gets clicked\n\n    Returns:\n        created button\n\n    Raises:\n        InvalidParamError: Button type not available\n    \"\"\"\n    if isinstance(button, str):\n        button = widgets.PushButton(button)\n    self.addButton(button, ROLES[role])\n    if callback:\n        button.clicked.connect(callback)\n    return button\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_default_button","title":"<code>add_default_button(button: ButtonStr, callback: Callable | None = None) -&gt; QtWidgets.QPushButton</code>","text":"<p>Add a default button.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>ButtonStr</code> <p>button to add</p> required <code>callback</code> <code>Callable | None</code> <p>function to call when button gets clicked</p> <code>None</code> <p>Returns:</p> Type Description <code>QtWidgets.QPushButton</code> <p>created button</p> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>Button type not available</p> Source code in <code>prettyqt\\widgets\\dialogbuttonbox.py</code> <pre><code>def add_default_button(\n    self, button: ButtonStr, callback: Callable | None = None\n) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n\n    Args:\n        button: button to add\n        callback: function to call when button gets clicked\n\n    Returns:\n        created button\n\n    Raises:\n        InvalidParamError: Button type not available\n    \"\"\"\n    if button not in BUTTONS:\n        raise InvalidParamError(button, BUTTONS)\n    btn = self.addButton(BUTTONS[button])\n    btn.setObjectName(button)\n    if callback:\n        btn.clicked.connect(callback)\n    return btn\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\widgets\\dialogbuttonbox.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.set_orientation","title":"<code>set_orientation(orientation: constants.OrientationStr)</code>","text":"<p>Set the orientation of the button box.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr</code> <p>orientation for the button box</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt\\widgets\\dialogbuttonbox.py</code> <pre><code>def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the button box.\n\n    Args:\n        orientation: orientation for the button box\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in constants.ORIENTATION:\n        raise InvalidParamError(orientation, constants.ORIENTATION)\n    self.setOrientation(constants.ORIENTATION[orientation])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.DockWidget","title":"<code>DockWidget</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QDockWidget</code></p> <p>Customized DockWidget class.</p> <p>Contains a custom TitleBar with maximize button</p> Source code in <code>prettyqt\\widgets\\dockwidget.py</code> <pre><code>class DockWidget(widgets.WidgetMixin, QtWidgets.QDockWidget):\n\"\"\"Customized DockWidget class.\n\n    Contains a custom TitleBar with maximize button\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        name = kwargs.pop(\"name\", None)\n        title = kwargs.pop(\"title\", None)\n        super().__init__(*args, **kwargs)\n        if name:\n            self.set_id(name)\n        if title:\n            self.set_title(title)\n        self.set_allowed_areas(\"all\")\n\n    # def __setstate__(self, state: dict[str, Any]) -&gt; None:\n    #     self.set_widget(state[\"widget\"])\n\n    # def __reduce__(self):\n    #     return type(self), (), self.__getstate__()\n\n    # def serialize_fields(self) -&gt; dict[str, Any]:\n    #     return dict(widget=self.widget())\n\n    def set_widget(self, widget: QtWidgets.QWidget):\n        self.setWidget(widget)\n\n    def set_allowed_areas(self, area: constants.DockPositionsStr):\n        self.setAllowedAreas(constants.DOCK_POSITIONS[area])\n\n    def setup_title_bar(self):\n        title_bar = widgets.Widget()\n        layout = widgets.BoxLayout(\"horizontal\")\n        layout.set_margin(0)\n        layout.set_alignment(\"right\")\n        title_bar.set_layout(layout)\n        maximize_button = widgets.PushButton()\n        layout.add(maximize_button)\n        maximize_button.set_style_icon(\"titlebar_max_button\")\n        maximize_button.clicked.connect(self.maximize)\n        close_button = widgets.PushButton()\n        close_button.set_style_icon(\"titlebar_close_button\")\n        layout.add(close_button)\n        close_button.clicked.connect(self.close)\n        self.setTitleBarWidget(title_bar)\n\n    @deprecated(reason=\"This method is deprecated, use 'maximize' instead.\")\n    def maximise(self):\n        self.maximize()\n\n    def maximize(self):\n        if not self.isFloating():\n            self.setFloating(True)\n        if not self.isMaximized():\n            self.showMaximized()\n        else:\n            self.showMinimized()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.FileDialog","title":"<code>FileDialog</code>","text":"<p>         Bases: <code>widgets.DialogMixin</code>, <code>QtWidgets.QFileDialog</code></p> <p>Simple dialog used to display some widget.</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>class FileDialog(widgets.DialogMixin, QtWidgets.QFileDialog):\n\"\"\"Simple dialog used to display some widget.\"\"\"\n\n    def __init__(\n        self,\n        path: None | datatypes.PathType = None,\n        mode: AcceptModeStr = \"open\",\n        caption: str | None = None,\n        path_id: str | None = None,\n        extension_filter: dict | None = None,\n        file_mode: FileModeStr = \"existing_files\",\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        super().__init__(parent=parent)\n        self.set_title(caption)\n        self.path_id = path_id\n        if extension_filter:\n            self.set_extension_filter(extension_filter)\n        if path_id is not None and path is None:\n            settings = core.Settings()\n            path = settings.get(path_id, \"\")\n        if path is not None:\n            self.set_directory(path)\n        self.set_file_mode(file_mode)\n        self.set_accept_mode(mode)\n\n    def set_accept_mode(self, mode: AcceptModeStr):\n\"\"\"Set accept mode.\n\n        Args:\n            mode: accept mode to use\n\n        Raises:\n            InvalidParamError: invalid accept mode\n        \"\"\"\n        if mode not in ACCEPT_MODE:\n            raise InvalidParamError(mode, ACCEPT_MODE)\n        self.setAcceptMode(ACCEPT_MODE[mode])\n\n    def get_accept_mode(self) -&gt; AcceptModeStr:\n\"\"\"Return accept mode.\n\n        Returns:\n            accept mode\n        \"\"\"\n        return ACCEPT_MODE.inverse[self.acceptMode()]\n\n    def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode.\n\n        Args:\n            mode: view mode to use\n\n        Raises:\n            InvalidParamError: invalid view mode\n        \"\"\"\n        if mode not in VIEW_MODE:\n            raise InvalidParamError(mode, VIEW_MODE)\n        self.setViewMode(VIEW_MODE[mode])\n\n    def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n\n        Returns:\n            view mode\n        \"\"\"\n        return VIEW_MODE.inverse[self.viewMode()]\n\n    def set_label_text(self, label: LabelStr, text: str):\n\"\"\"Set the label text for button label.\n\n        Args:\n            label: button to set text for\n            text: text to use\n        \"\"\"\n        if label not in LABEL:\n            raise InvalidParamError(label, LABEL)\n        self.setLabelText(LABEL[label], text)\n\n    def get_label_text(self, label: LabelStr) -&gt; str:\n\"\"\"Return label text.\n\n        Returns:\n            label text\n        \"\"\"\n        return self.labelText(LABEL[label])\n\n    def get_file_mode(self) -&gt; FileModeStr:\n\"\"\"Return file mode.\n\n        Returns:\n            file mode\n        \"\"\"\n        return FILE_MODE.inverse[self.fileMode()]\n\n    def set_file_mode(self, mode: FileModeStr):\n\"\"\"Set the file mode of the dialog.\n\n        Args:\n            mode: mode to use\n        \"\"\"\n        self.setFileMode(FILE_MODE[mode])\n\n    def selected_files(self) -&gt; list[pathlib.Path]:\n        return [pathlib.Path(p) for p in self.selectedFiles()]\n\n    def selected_file(self) -&gt; pathlib.Path | None:\n        selected = self.selectedFiles()\n        return pathlib.Path(selected[0]) if selected else None\n\n    def choose_folder(self) -&gt; list[pathlib.Path] | None:\n        self.set_file_mode(\"directory\")\n        return self.choose()\n\n    def open_file(self) -&gt; list[pathlib.Path] | None:\n        self.set_file_mode(\"existing_file\")\n        return self.choose()\n\n    def choose(self) -&gt; list[pathlib.Path] | None:\n        result = self.main_loop()\n        if result != self.DialogCode.Accepted:\n            return None\n        paths = self.selected_files()\n        if self.path_id:\n            settings = core.Settings()\n            folder_path = paths[0].parent\n            settings.setValue(self.path_id, str(folder_path))\n        return paths\n\n    def set_extension_filter(self, extension_dict: dict[str, list[str]]):\n\"\"\"Set filter based on given dictionary.\n\n        dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs\n\n        Args:\n            extension_dict: filter dictionary\n        \"\"\"\n        items = [\n            f\"{k} ({' '.join(f'*{ext}' for ext in v)})\" for k, v in extension_dict.items()\n        ]\n        filter_str = \";;\".join(items)\n        self.setNameFilter(filter_str)\n\n    def get_directory(self) -&gt; pathlib.Path:\n\"\"\"Return current directory.\n\n        returns current directory level as a Pathlib object\n\n        Returns:\n            Pathlib object\n        \"\"\"\n        return pathlib.Path(self.directory().absolutePath())\n\n    def set_directory(self, path: datatypes.PathType):\n\"\"\"Set start directory.\"\"\"\n        path = os.fspath(path)\n        self.setDirectory(path)\n\n    def set_filter(self, *filters: core.dir.FilterStr):\n        for item in filters:\n            if item not in core.dir.FILTERS:\n                raise InvalidParamError(item, core.dir.FILTERS)\n        flags = helpers.merge_flags(filters, core.dir.FILTERS)\n        self.setFilter(flags)\n\n    def get_filter(self) -&gt; list[core.dir.FilterStr]:\n        return core.dir.FILTERS.get_list(self.filter())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_accept_mode","title":"<code>get_accept_mode() -&gt; AcceptModeStr</code>","text":"<p>Return accept mode.</p> <p>Returns:</p> Type Description <code>AcceptModeStr</code> <p>accept mode</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def get_accept_mode(self) -&gt; AcceptModeStr:\n\"\"\"Return accept mode.\n\n    Returns:\n        accept mode\n    \"\"\"\n    return ACCEPT_MODE.inverse[self.acceptMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_directory","title":"<code>get_directory() -&gt; pathlib.Path</code>","text":"<p>Return current directory.</p> <p>returns current directory level as a Pathlib object</p> <p>Returns:</p> Type Description <code>pathlib.Path</code> <p>Pathlib object</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def get_directory(self) -&gt; pathlib.Path:\n\"\"\"Return current directory.\n\n    returns current directory level as a Pathlib object\n\n    Returns:\n        Pathlib object\n    \"\"\"\n    return pathlib.Path(self.directory().absolutePath())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_file_mode","title":"<code>get_file_mode() -&gt; FileModeStr</code>","text":"<p>Return file mode.</p> <p>Returns:</p> Type Description <code>FileModeStr</code> <p>file mode</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def get_file_mode(self) -&gt; FileModeStr:\n\"\"\"Return file mode.\n\n    Returns:\n        file mode\n    \"\"\"\n    return FILE_MODE.inverse[self.fileMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_label_text","title":"<code>get_label_text(label: LabelStr) -&gt; str</code>","text":"<p>Return label text.</p> <p>Returns:</p> Type Description <code>str</code> <p>label text</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def get_label_text(self, label: LabelStr) -&gt; str:\n\"\"\"Return label text.\n\n    Returns:\n        label text\n    \"\"\"\n    return self.labelText(LABEL[label])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_view_mode","title":"<code>get_view_mode() -&gt; ViewModeStr</code>","text":"<p>Return view mode.</p> <p>Returns:</p> Type Description <code>ViewModeStr</code> <p>view mode</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n\n    Returns:\n        view mode\n    \"\"\"\n    return VIEW_MODE.inverse[self.viewMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_accept_mode","title":"<code>set_accept_mode(mode: AcceptModeStr)</code>","text":"<p>Set accept mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>AcceptModeStr</code> <p>accept mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid accept mode</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_accept_mode(self, mode: AcceptModeStr):\n\"\"\"Set accept mode.\n\n    Args:\n        mode: accept mode to use\n\n    Raises:\n        InvalidParamError: invalid accept mode\n    \"\"\"\n    if mode not in ACCEPT_MODE:\n        raise InvalidParamError(mode, ACCEPT_MODE)\n    self.setAcceptMode(ACCEPT_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_directory","title":"<code>set_directory(path: datatypes.PathType)</code>","text":"<p>Set start directory.</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_directory(self, path: datatypes.PathType):\n\"\"\"Set start directory.\"\"\"\n    path = os.fspath(path)\n    self.setDirectory(path)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_extension_filter","title":"<code>set_extension_filter(extension_dict: dict[str, list[str]])</code>","text":"<p>Set filter based on given dictionary.</p> <p>dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs</p> <p>Parameters:</p> Name Type Description Default <code>extension_dict</code> <code>dict[str, list[str]]</code> <p>filter dictionary</p> required Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_extension_filter(self, extension_dict: dict[str, list[str]]):\n\"\"\"Set filter based on given dictionary.\n\n    dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs\n\n    Args:\n        extension_dict: filter dictionary\n    \"\"\"\n    items = [\n        f\"{k} ({' '.join(f'*{ext}' for ext in v)})\" for k, v in extension_dict.items()\n    ]\n    filter_str = \";;\".join(items)\n    self.setNameFilter(filter_str)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_file_mode","title":"<code>set_file_mode(mode: FileModeStr)</code>","text":"<p>Set the file mode of the dialog.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>FileModeStr</code> <p>mode to use</p> required Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_file_mode(self, mode: FileModeStr):\n\"\"\"Set the file mode of the dialog.\n\n    Args:\n        mode: mode to use\n    \"\"\"\n    self.setFileMode(FILE_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_label_text","title":"<code>set_label_text(label: LabelStr, text: str)</code>","text":"<p>Set the label text for button label.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>LabelStr</code> <p>button to set text for</p> required <code>text</code> <code>str</code> <p>text to use</p> required Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_label_text(self, label: LabelStr, text: str):\n\"\"\"Set the label text for button label.\n\n    Args:\n        label: button to set text for\n        text: text to use\n    \"\"\"\n    if label not in LABEL:\n        raise InvalidParamError(label, LABEL)\n    self.setLabelText(LABEL[label], text)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_view_mode","title":"<code>set_view_mode(mode: ViewModeStr)</code>","text":"<p>Set view mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewModeStr</code> <p>view mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid view mode</p> Source code in <code>prettyqt\\widgets\\filedialog.py</code> <pre><code>def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode.\n\n    Args:\n        mode: view mode to use\n\n    Raises:\n        InvalidParamError: invalid view mode\n    \"\"\"\n    if mode not in VIEW_MODE:\n        raise InvalidParamError(mode, VIEW_MODE)\n    self.setViewMode(VIEW_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.FileSystemModel","title":"<code>FileSystemModel</code>","text":"<p>         Bases: <code>core.AbstractItemModelMixin</code>, <code>QtWidgets.QFileSystemModel</code></p> <p>Class to populate a filesystem treeview.</p> Source code in <code>prettyqt\\widgets\\filesystemmodel.py</code> <pre><code>class FileSystemModel(core.AbstractItemModelMixin, QtWidgets.QFileSystemModel):\n\"\"\"Class to populate a filesystem treeview.\"\"\"\n\n    DATA_ROLE = constants.USER_ROLE + 33  # type: ignore\n    content_type = \"files\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.setReadOnly(False)\n\n    def data(self, index, role=QtCore.Qt.ItemDataRole.DisplayRole):\n        if role == self.DATA_ROLE:\n            path = index.data(self.Roles.FilePathRole)\n            return pathlib.Path(path)\n        return super().data(index, role)\n\n    def get_file_info(self, index: QtCore.QModelIndex) -&gt; core.FileInfo:\n        return core.FileInfo(self.fileInfo(index))\n\n    def get_file_path(self, index: QtCore.QModelIndex) -&gt; pathlib.Path:\n        return pathlib.Path(self.filePath(index))\n\n    def yield_child_indexes(\n        self, index: QtCore.QModelIndex\n    ) -&gt; Iterator[QtCore.QModelIndex]:\n        if not self.hasChildren(index):\n            return\n        path = self.get_file_path(index)\n        for it in path.iterdir():\n            yield self.index(str(path / it))\n\n    def resolve_sym_links(self, resolve: bool):\n        self.setResolveSymlinks(resolve)\n\n    def watch_for_changes(self, watch: bool):\n        self.setOption(OPTIONS[\"dont_watch_changes\"], not watch)\n\n    def use_custom_icons(self, use: bool):\n        self.setOption(OPTIONS[\"no_custom_icons\"], not use)\n\n    def set_root_path(self, path: datatypes.PathType) -&gt; QtCore.QModelIndex:\n        match path:\n            case \"/\" | \"root\":\n                path = core.Dir.rootPath()\n            case \"home\":\n                path = core.Dir.homePath()\n            case \"temp\":\n                path = core.Dir.tempPath()\n            case \"current\":\n                path = core.Dir.currentPath()\n            case _:\n                path = os.fspath(path)\n        return self.setRootPath(path)\n\n    def set_name_filters(self, filters, hide: bool = False):\n        self.setNameFilters(filters)\n        self.setNameFilterDisables(not hide)\n\n    def set_filter(self, filter_mode: core.dir.FilterStr):\n        if filter_mode not in core.dir.FILTERS:\n            raise InvalidParamError(filter_mode, core.dir.FILTERS)\n        self.setFilter(core.dir.FILTERS[filter_mode])\n\n    def get_paths(self, indexes: Sequence[QtCore.QModelIndex]) -&gt; list[pathlib.Path]:\n        paths = [i.data(self.DATA_ROLE) for i in indexes]\n        if not paths:\n            return []\n        if paths[0] == \"\":\n            paths = [\n                folder / filename\n                for folder in paths\n                for filename in folder.iterdir()\n                if (folder / filename).is_file()\n            ]\n        return paths\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.FontComboBox","title":"<code>FontComboBox</code>","text":"<p>         Bases: <code>widgets.ComboBoxMixin</code>, <code>QtWidgets.QFontComboBox</code></p> Source code in <code>prettyqt\\widgets\\fontcombobox.py</code> <pre><code>class FontComboBox(widgets.ComboBoxMixin, QtWidgets.QFontComboBox):\n    value_changed = core.Signal(object)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.currentIndexChanged.connect(self.index_changed)\n\n    def set_font_filters(self, *filters: FontFilterStr):\n\"\"\"Set font filters.\n\n        Args:\n            filters: font filters to use\n\n        Raises:\n            InvalidParamError: invalid font filters\n        \"\"\"\n        if not filters:\n            filters = (\"all\",)\n        for item in filters:\n            if item not in FONT_FILTERS:\n                raise InvalidParamError(item, FONT_FILTERS)\n        flags = helpers.merge_flags(filters, FONT_FILTERS)\n        self.setFontFilters(flags)\n\n    def get_font_filters(self) -&gt; list[FontFilterStr]:\n\"\"\"Return list of font filters.\n\n        Returns:\n            font filter list\n        \"\"\"\n        return FONT_FILTERS.get_list(self.fontFilters())\n\n    def set_value(self, value: QtGui.QFont):\n        self.setCurrentFont(value)\n\n    def get_value(self) -&gt; gui.Font:\n        return self.get_current_font()\n\n    def get_current_font(self) -&gt; gui.Font:\n        return gui.Font(self.currentFont())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.get_font_filters","title":"<code>get_font_filters() -&gt; list[FontFilterStr]</code>","text":"<p>Return list of font filters.</p> <p>Returns:</p> Type Description <code>list[FontFilterStr]</code> <p>font filter list</p> Source code in <code>prettyqt\\widgets\\fontcombobox.py</code> <pre><code>def get_font_filters(self) -&gt; list[FontFilterStr]:\n\"\"\"Return list of font filters.\n\n    Returns:\n        font filter list\n    \"\"\"\n    return FONT_FILTERS.get_list(self.fontFilters())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.set_font_filters","title":"<code>set_font_filters(*filters: FontFilterStr)</code>","text":"<p>Set font filters.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>FontFilterStr</code> <p>font filters to use</p> <code>()</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid font filters</p> Source code in <code>prettyqt\\widgets\\fontcombobox.py</code> <pre><code>def set_font_filters(self, *filters: FontFilterStr):\n\"\"\"Set font filters.\n\n    Args:\n        filters: font filters to use\n\n    Raises:\n        InvalidParamError: invalid font filters\n    \"\"\"\n    if not filters:\n        filters = (\"all\",)\n    for item in filters:\n        if item not in FONT_FILTERS:\n            raise InvalidParamError(item, FONT_FILTERS)\n    flags = helpers.merge_flags(filters, FONT_FILTERS)\n    self.setFontFilters(flags)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.FormLayout","title":"<code>FormLayout</code>","text":"<p>         Bases: <code>widgets.LayoutMixin</code>, <code>QtWidgets.QFormLayout</code></p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>class FormLayout(widgets.LayoutMixin, QtWidgets.QFormLayout):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.set_size_constraint(\"maximum\")\n        self.setVerticalSpacing(8)\n\n    def __setitem__(\n        self, index: int | tuple[int, RoleStr], value: str | QtWidgets.QWidget\n    ):\n        if isinstance(index, tuple):\n            row = index[0]\n            role = index[1]\n        else:\n            row = index\n            role = \"both\"\n        self.set_widget(value, row, role)\n\n    def __delitem__(self, index: int):\n        self.removeRow(index)\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QWidget | QtWidgets.QLayout]:\n        return iter(self[i] for i in range(self.count()) if self[i] is not None)\n\n    def __len__(self) -&gt; int:\n\"\"\"Needed for PySide2.\"\"\"\n        return self.rowCount()\n\n    def __add__(self, other: QtWidgets.QWidget | QtWidgets.QLayout | tuple):\n        self.add(other)\n        return self\n\n    # def serialize_fields(self):\n    #     widget_list = []\n    #     positions = []\n    #     for i, item in enumerate(list(self)):\n    #         widget_list.append(item)\n    #         positions.append(self.get_item_position(i))\n    #     return dict(widgets=widget_list, positions=positions)\n\n    # def __reduce__(self):\n    #     return type(self), (), self.__getstate__()\n\n    # def __setstate__(self, state):\n    #     for item, pos in zip(state[\"widgets\"], state[\"positions\"]):\n    #         self.set_widget(item, pos[0], pos[1])\n\n    def set_widget(\n        self, widget: str | QtWidgets.QWidget, row: int, role: RoleStr = \"both\"\n    ):\n        if isinstance(widget, str):\n            widget = widgets.Label(widget)\n        self.setWidget(row, ROLE[role], widget)\n\n    def get_widget(\n        self, row: int, role: RoleStr = \"both\"\n    ) -&gt; QtWidgets.QLayout | QtWidgets.QWidget:\n        item = self.itemAt(row, ROLE[role])\n        widget = item.widget()\n        if widget is None:\n            widget = item.layout()\n        return widget\n\n    def get_item_position(self, index: int) -&gt; tuple[int, RoleStr] | None:\n        pos = self.getItemPosition(index)  # type: ignore\n        return None if pos[0] == -1 else (pos[0], ROLE.inverse[pos[1]])\n\n    def add(self, *items):\n        for i in items:\n            if isinstance(i, QtWidgets.QWidget | QtWidgets.QLayout):\n                self.addRow(i)\n            elif isinstance(i, tuple):\n                self.addRow(*i)\n\n    def set_row_wrap_policy(self, policy: RowWrapPolicyStr):\n\"\"\"Set row wrap policy to use.\n\n        Args:\n            policy: row wrap policy to use\n\n        Raises:\n            InvalidParamError: row wrap policy does not exist\n        \"\"\"\n        if policy not in ROW_WRAP_POLICY:\n            raise InvalidParamError(policy, ROW_WRAP_POLICY)\n        self.setRowWrapPolicy(ROW_WRAP_POLICY[policy])\n\n    def get_row_wrap_policy(self) -&gt; RowWrapPolicyStr:\n\"\"\"Return current row wrap policy.\n\n        Returns:\n            row wrap policy\n        \"\"\"\n        return ROW_WRAP_POLICY.inverse[self.rowWrapPolicy()]\n\n    def set_field_growth_policy(self, policy: FieldGrowthPolicyStr):\n\"\"\"Set field growth policy to use.\n\n        Args:\n            policy: field growth policy to use\n\n        Raises:\n            InvalidParamError: field growth policy does not exist\n        \"\"\"\n        if policy not in FIELD_GROWTH_POLICY:\n            raise InvalidParamError(policy, FIELD_GROWTH_POLICY)\n        self.setFieldGrowthPolicy(FIELD_GROWTH_POLICY[policy])\n\n    def get_field_growth_policy(self) -&gt; FieldGrowthPolicyStr:\n\"\"\"Return current field growth policy.\n\n        Returns:\n            field growth policy\n        \"\"\"\n        return FIELD_GROWTH_POLICY.inverse[self.fieldGrowthPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>Needed for PySide2.</p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Needed for PySide2.\"\"\"\n    return self.rowCount()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_field_growth_policy","title":"<code>get_field_growth_policy() -&gt; FieldGrowthPolicyStr</code>","text":"<p>Return current field growth policy.</p> <p>Returns:</p> Type Description <code>FieldGrowthPolicyStr</code> <p>field growth policy</p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def get_field_growth_policy(self) -&gt; FieldGrowthPolicyStr:\n\"\"\"Return current field growth policy.\n\n    Returns:\n        field growth policy\n    \"\"\"\n    return FIELD_GROWTH_POLICY.inverse[self.fieldGrowthPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_row_wrap_policy","title":"<code>get_row_wrap_policy() -&gt; RowWrapPolicyStr</code>","text":"<p>Return current row wrap policy.</p> <p>Returns:</p> Type Description <code>RowWrapPolicyStr</code> <p>row wrap policy</p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def get_row_wrap_policy(self) -&gt; RowWrapPolicyStr:\n\"\"\"Return current row wrap policy.\n\n    Returns:\n        row wrap policy\n    \"\"\"\n    return ROW_WRAP_POLICY.inverse[self.rowWrapPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_field_growth_policy","title":"<code>set_field_growth_policy(policy: FieldGrowthPolicyStr)</code>","text":"<p>Set field growth policy to use.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>FieldGrowthPolicyStr</code> <p>field growth policy to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>field growth policy does not exist</p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def set_field_growth_policy(self, policy: FieldGrowthPolicyStr):\n\"\"\"Set field growth policy to use.\n\n    Args:\n        policy: field growth policy to use\n\n    Raises:\n        InvalidParamError: field growth policy does not exist\n    \"\"\"\n    if policy not in FIELD_GROWTH_POLICY:\n        raise InvalidParamError(policy, FIELD_GROWTH_POLICY)\n    self.setFieldGrowthPolicy(FIELD_GROWTH_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_row_wrap_policy","title":"<code>set_row_wrap_policy(policy: RowWrapPolicyStr)</code>","text":"<p>Set row wrap policy to use.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>RowWrapPolicyStr</code> <p>row wrap policy to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>row wrap policy does not exist</p> Source code in <code>prettyqt\\widgets\\formlayout.py</code> <pre><code>def set_row_wrap_policy(self, policy: RowWrapPolicyStr):\n\"\"\"Set row wrap policy to use.\n\n    Args:\n        policy: row wrap policy to use\n\n    Raises:\n        InvalidParamError: row wrap policy does not exist\n    \"\"\"\n    if policy not in ROW_WRAP_POLICY:\n        raise InvalidParamError(policy, ROW_WRAP_POLICY)\n    self.setRowWrapPolicy(ROW_WRAP_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.FrameMixin","title":"<code>FrameMixin</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code></p> Source code in <code>prettyqt\\widgets\\frame.py</code> <pre><code>class FrameMixin(widgets.WidgetMixin):\n    def set_frame_shadow(self, style: ShadowStr):\n\"\"\"Set frame shadow.\n\n        Args:\n            style: frame style to use\n\n        Raises:\n            InvalidParamError: style does not exist\n        \"\"\"\n        if style is None:\n            return\n        if style not in SHADOW:\n            raise InvalidParamError(style, SHADOW)\n        self.setFrameShadow(SHADOW[style])\n\n    def get_frame_shadow(self) -&gt; ShadowStr | None:\n\"\"\"Return current frame shadow.\n\n        Returns:\n            frame style\n        \"\"\"\n        if (frame_shadow := self.frameShadow()) == 0:\n            return None\n        return SHADOW.inverse[frame_shadow]\n\n    def set_frame_shape(self, shape: FrameShapeStr):\n\"\"\"Set frame shape.\n\n        Args:\n            shape: frame shape to use\n\n        Raises:\n            InvalidParamError: shape does not exist\n        \"\"\"\n        if shape not in FRAME_SHAPE:\n            raise InvalidParamError(shape, FRAME_SHAPE)\n        self.setFrameShape(FRAME_SHAPE[shape])\n\n    def get_frame_shape(self) -&gt; FrameShapeStr:\n\"\"\"Return current frame shape.\n\n        Returns:\n            frame shape\n        \"\"\"\n        return FRAME_SHAPE.inverse[self.frameShape()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.get_frame_shadow","title":"<code>get_frame_shadow() -&gt; ShadowStr | None</code>","text":"<p>Return current frame shadow.</p> <p>Returns:</p> Type Description <code>ShadowStr | None</code> <p>frame style</p> Source code in <code>prettyqt\\widgets\\frame.py</code> <pre><code>def get_frame_shadow(self) -&gt; ShadowStr | None:\n\"\"\"Return current frame shadow.\n\n    Returns:\n        frame style\n    \"\"\"\n    if (frame_shadow := self.frameShadow()) == 0:\n        return None\n    return SHADOW.inverse[frame_shadow]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.get_frame_shape","title":"<code>get_frame_shape() -&gt; FrameShapeStr</code>","text":"<p>Return current frame shape.</p> <p>Returns:</p> Type Description <code>FrameShapeStr</code> <p>frame shape</p> Source code in <code>prettyqt\\widgets\\frame.py</code> <pre><code>def get_frame_shape(self) -&gt; FrameShapeStr:\n\"\"\"Return current frame shape.\n\n    Returns:\n        frame shape\n    \"\"\"\n    return FRAME_SHAPE.inverse[self.frameShape()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.set_frame_shadow","title":"<code>set_frame_shadow(style: ShadowStr)</code>","text":"<p>Set frame shadow.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>ShadowStr</code> <p>frame style to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>style does not exist</p> Source code in <code>prettyqt\\widgets\\frame.py</code> <pre><code>def set_frame_shadow(self, style: ShadowStr):\n\"\"\"Set frame shadow.\n\n    Args:\n        style: frame style to use\n\n    Raises:\n        InvalidParamError: style does not exist\n    \"\"\"\n    if style is None:\n        return\n    if style not in SHADOW:\n        raise InvalidParamError(style, SHADOW)\n    self.setFrameShadow(SHADOW[style])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.set_frame_shape","title":"<code>set_frame_shape(shape: FrameShapeStr)</code>","text":"<p>Set frame shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>FrameShapeStr</code> <p>frame shape to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>shape does not exist</p> Source code in <code>prettyqt\\widgets\\frame.py</code> <pre><code>def set_frame_shape(self, shape: FrameShapeStr):\n\"\"\"Set frame shape.\n\n    Args:\n        shape: frame shape to use\n\n    Raises:\n        InvalidParamError: shape does not exist\n    \"\"\"\n    if shape not in FRAME_SHAPE:\n        raise InvalidParamError(shape, FRAME_SHAPE)\n    self.setFrameShape(FRAME_SHAPE[shape])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GestureMixin","title":"<code>GestureMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\widgets\\gesture.py</code> <pre><code>class GestureMixin(core.ObjectMixin):\n    def get_state(self) -&gt; constants.GestureStateStr:\n\"\"\"Return current state.\n\n        Returns:\n            state\n        \"\"\"\n        return constants.GESTURE_STATE.inverse[self.state()]\n\n    def get_gesture_type(self) -&gt; constants.GestureTypeStr:\n\"\"\"Return current gesture type.\n\n        Returns:\n            gesture type\n        \"\"\"\n        return constants.GESTURE_TYPE.inverse[self.gestureType()]\n\n    def get_hot_spot(self) -&gt; core.PointF:\n        return core.PointF(self.hotSpot())\n\n    def set_gesture_cancel_policy(self, policy: GestureCancelPolicyStr):\n\"\"\"Set gesture cancel policy.\n\n        Args:\n            policy: gesture cancel policy to use\n\n        Raises:\n            InvalidParamError: gesture cancel policy does not exist\n        \"\"\"\n        if policy not in GESTURE_CANCEL_POLICY:\n            raise InvalidParamError(policy, GESTURE_CANCEL_POLICY)\n        self.setGestureCancelPolicy(GESTURE_CANCEL_POLICY[policy])\n\n    def get_gesture_cancel_policy(self) -&gt; GestureCancelPolicyStr:\n\"\"\"Return current gesture cancel policy.\n\n        Returns:\n            gesture cancel policy\n        \"\"\"\n        return GESTURE_CANCEL_POLICY.inverse[self.gestureCancelPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.get_gesture_cancel_policy","title":"<code>get_gesture_cancel_policy() -&gt; GestureCancelPolicyStr</code>","text":"<p>Return current gesture cancel policy.</p> <p>Returns:</p> Type Description <code>GestureCancelPolicyStr</code> <p>gesture cancel policy</p> Source code in <code>prettyqt\\widgets\\gesture.py</code> <pre><code>def get_gesture_cancel_policy(self) -&gt; GestureCancelPolicyStr:\n\"\"\"Return current gesture cancel policy.\n\n    Returns:\n        gesture cancel policy\n    \"\"\"\n    return GESTURE_CANCEL_POLICY.inverse[self.gestureCancelPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.get_gesture_type","title":"<code>get_gesture_type() -&gt; constants.GestureTypeStr</code>","text":"<p>Return current gesture type.</p> <p>Returns:</p> Type Description <code>constants.GestureTypeStr</code> <p>gesture type</p> Source code in <code>prettyqt\\widgets\\gesture.py</code> <pre><code>def get_gesture_type(self) -&gt; constants.GestureTypeStr:\n\"\"\"Return current gesture type.\n\n    Returns:\n        gesture type\n    \"\"\"\n    return constants.GESTURE_TYPE.inverse[self.gestureType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.get_state","title":"<code>get_state() -&gt; constants.GestureStateStr</code>","text":"<p>Return current state.</p> <p>Returns:</p> Type Description <code>constants.GestureStateStr</code> <p>state</p> Source code in <code>prettyqt\\widgets\\gesture.py</code> <pre><code>def get_state(self) -&gt; constants.GestureStateStr:\n\"\"\"Return current state.\n\n    Returns:\n        state\n    \"\"\"\n    return constants.GESTURE_STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.set_gesture_cancel_policy","title":"<code>set_gesture_cancel_policy(policy: GestureCancelPolicyStr)</code>","text":"<p>Set gesture cancel policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>GestureCancelPolicyStr</code> <p>gesture cancel policy to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>gesture cancel policy does not exist</p> Source code in <code>prettyqt\\widgets\\gesture.py</code> <pre><code>def set_gesture_cancel_policy(self, policy: GestureCancelPolicyStr):\n\"\"\"Set gesture cancel policy.\n\n    Args:\n        policy: gesture cancel policy to use\n\n    Raises:\n        InvalidParamError: gesture cancel policy does not exist\n    \"\"\"\n    if policy not in GESTURE_CANCEL_POLICY:\n        raise InvalidParamError(policy, GESTURE_CANCEL_POLICY)\n    self.setGestureCancelPolicy(GESTURE_CANCEL_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsItemMixin","title":"<code>GraphicsItemMixin</code>","text":"Source code in <code>prettyqt\\widgets\\graphicsitem.py</code> <pre><code>class GraphicsItemMixin:\n    def __repr__(self):\n        return get_repr(self)\n\n    def __contains__(self, value: QtCore.QPointF) -&gt; bool:\n        return self.contains(value)\n\n    def __getitem__(self, key: int):\n        return self.data(key)\n\n    def __setitem__(self, key: int, value):\n        self.setData(key, value)\n\n    def set_focus(self, reason: constants.FocusReasonStr = \"other\"):\n        if reason not in constants.FOCUS_REASONS:\n            raise InvalidParamError(reason, constants.FOCUS_REASONS)\n        self.setFocus(constants.FOCUS_REASONS[reason])\n\n    def colliding_items(\n        self, mode: constants.ItemSelectionModeStr = \"intersects_shape\"\n    ) -&gt; list[QtWidgets.QGraphicsItem]:\n        if mode not in constants.ITEM_SELECTION_MODE:\n            raise InvalidParamError(mode, constants.ITEM_SELECTION_MODE)\n        return self.collidingItems(constants.ITEM_SELECTION_MODE[mode])\n\n    def collides_with(\n        self,\n        item: QtGui.QPainterPath | QtWidgets.QGraphicsItem,\n        mode: constants.ItemSelectionModeStr = \"intersects_shape\",\n    ) -&gt; bool:\n        if mode not in constants.ITEM_SELECTION_MODE:\n            raise InvalidParamError(mode, constants.ITEM_SELECTION_MODE)\n        if isinstance(item, QtGui.QPainterPath):\n            return self.collidesWithPath(item, constants.ITEM_SELECTION_MODE[mode])\n        else:\n            return self.collidesWithItem(item, constants.ITEM_SELECTION_MODE[mode])\n\n    def set_panel_modality(self, modality: PanelModalityStr) -&gt; None:\n\"\"\"Set panel modality.\n\n        Args:\n            modality: panel modality\n\n        Raises:\n            InvalidParamError: panel modality does not exist\n        \"\"\"\n        if modality not in PANEL_MODALITY:\n            raise InvalidParamError(modality, PANEL_MODALITY)\n        self.setPanelModality(PANEL_MODALITY[modality])\n\n    def get_panel_modality(self) -&gt; PanelModalityStr:\n\"\"\"Get the current modality modes as a string.\n\n        Returns:\n            panel modality\n        \"\"\"\n        return PANEL_MODALITY.inverse[self.panelModality()]\n\n    def set_cache_mode(self, mode: CacheModeStr) -&gt; None:\n\"\"\"Set cache mode.\n\n        Args:\n            mode: cache mode\n\n        Raises:\n            InvalidParamError: cache mode does not exist\n        \"\"\"\n        if mode not in CACHE_MODE:\n            raise InvalidParamError(mode, CACHE_MODE)\n        self.setCacheMode(CACHE_MODE[mode])\n\n    def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current mode modes as a string.\n\n        Returns:\n            cache mode\n        \"\"\"\n        return CACHE_MODE.inverse[self.cacheMode()]\n\n    def get_shape(self) -&gt; gui.PainterPath:\n        return gui.PainterPath(self.shape())\n\n    def set_scale(self, scale: tuple[float, float] | float):\n        if isinstance(scale, float):\n            self.setScale(scale)\n        else:\n            self.setTransform(gui.Transform.fromScale(scale[0], scale[1]), True)\n\n    def set_transform(self, transform: datatypes.TransformType, combine: bool = False):\n        if isinstance(transform, tuple):\n            transform = gui.Transform(*transform)\n        self.setTransform(transform, combine)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.get_cache_mode","title":"<code>get_cache_mode() -&gt; CacheModeStr</code>","text":"<p>Get the current mode modes as a string.</p> <p>Returns:</p> Type Description <code>CacheModeStr</code> <p>cache mode</p> Source code in <code>prettyqt\\widgets\\graphicsitem.py</code> <pre><code>def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current mode modes as a string.\n\n    Returns:\n        cache mode\n    \"\"\"\n    return CACHE_MODE.inverse[self.cacheMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.get_panel_modality","title":"<code>get_panel_modality() -&gt; PanelModalityStr</code>","text":"<p>Get the current modality modes as a string.</p> <p>Returns:</p> Type Description <code>PanelModalityStr</code> <p>panel modality</p> Source code in <code>prettyqt\\widgets\\graphicsitem.py</code> <pre><code>def get_panel_modality(self) -&gt; PanelModalityStr:\n\"\"\"Get the current modality modes as a string.\n\n    Returns:\n        panel modality\n    \"\"\"\n    return PANEL_MODALITY.inverse[self.panelModality()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.set_cache_mode","title":"<code>set_cache_mode(mode: CacheModeStr) -&gt; None</code>","text":"<p>Set cache mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CacheModeStr</code> <p>cache mode</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>cache mode does not exist</p> Source code in <code>prettyqt\\widgets\\graphicsitem.py</code> <pre><code>def set_cache_mode(self, mode: CacheModeStr) -&gt; None:\n\"\"\"Set cache mode.\n\n    Args:\n        mode: cache mode\n\n    Raises:\n        InvalidParamError: cache mode does not exist\n    \"\"\"\n    if mode not in CACHE_MODE:\n        raise InvalidParamError(mode, CACHE_MODE)\n    self.setCacheMode(CACHE_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.set_panel_modality","title":"<code>set_panel_modality(modality: PanelModalityStr) -&gt; None</code>","text":"<p>Set panel modality.</p> <p>Parameters:</p> Name Type Description Default <code>modality</code> <code>PanelModalityStr</code> <p>panel modality</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>panel modality does not exist</p> Source code in <code>prettyqt\\widgets\\graphicsitem.py</code> <pre><code>def set_panel_modality(self, modality: PanelModalityStr) -&gt; None:\n\"\"\"Set panel modality.\n\n    Args:\n        modality: panel modality\n\n    Raises:\n        InvalidParamError: panel modality does not exist\n    \"\"\"\n    if modality not in PANEL_MODALITY:\n        raise InvalidParamError(modality, PANEL_MODALITY)\n    self.setPanelModality(PANEL_MODALITY[modality])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsLayoutItemMixin","title":"<code>GraphicsLayoutItemMixin</code>","text":"Source code in <code>prettyqt\\widgets\\graphicslayoutitem.py</code> <pre><code>class GraphicsLayoutItemMixin:\n    def __repr__(self):\n        return get_repr(self)\n\n    def __bool__(self):\n        return not self.isEmpty()\n\n    @functools.singledispatchmethod\n    def set_size_policy(\n        self,\n        horizontal: widgets.sizepolicy.SizePolicyStr,\n        vertical: widgets.sizepolicy.SizePolicyStr,\n        control_type: widgets.sizepolicy.ControlTypeStr = \"default\",\n    ):\n\"\"\"Set the size policy.\n\n        Args:\n            horizontal: horizontal size policy\n            vertical: vertical size policy\n            control_type: control type associated with the widget\n        \"\"\"\n        h_policy = widgets.sizepolicy.SIZE_POLICY[horizontal]\n        v_policy = widgets.sizepolicy.SIZE_POLICY[vertical]\n        c = widgets.sizepolicy.CONTROL_TYPE[control_type]\n        self.setSizePolicy(h_policy, v_policy, c)\n\n    @set_size_policy.register\n    def _(self, policy: QtWidgets.QSizePolicy):\n        self.setSizePolicy(policy)\n\n    def get_size_policy(self) -&gt; widgets.SizePolicy:\n        qpol = self.sizePolicy()\n        return widgets.SizePolicy.clone(qpol)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicslayoutitem.GraphicsLayoutItemMixin.set_size_policy","title":"<code>set_size_policy(horizontal: widgets.sizepolicy.SizePolicyStr, vertical: widgets.sizepolicy.SizePolicyStr, control_type: widgets.sizepolicy.ControlTypeStr = 'default')</code>","text":"<p>Set the size policy.</p> <p>Parameters:</p> Name Type Description Default <code>horizontal</code> <code>widgets.sizepolicy.SizePolicyStr</code> <p>horizontal size policy</p> required <code>vertical</code> <code>widgets.sizepolicy.SizePolicyStr</code> <p>vertical size policy</p> required <code>control_type</code> <code>widgets.sizepolicy.ControlTypeStr</code> <p>control type associated with the widget</p> <code>'default'</code> Source code in <code>prettyqt\\widgets\\graphicslayoutitem.py</code> <pre><code>@functools.singledispatchmethod\ndef set_size_policy(\n    self,\n    horizontal: widgets.sizepolicy.SizePolicyStr,\n    vertical: widgets.sizepolicy.SizePolicyStr,\n    control_type: widgets.sizepolicy.ControlTypeStr = \"default\",\n):\n\"\"\"Set the size policy.\n\n    Args:\n        horizontal: horizontal size policy\n        vertical: vertical size policy\n        control_type: control type associated with the widget\n    \"\"\"\n    h_policy = widgets.sizepolicy.SIZE_POLICY[horizontal]\n    v_policy = widgets.sizepolicy.SIZE_POLICY[vertical]\n    c = widgets.sizepolicy.CONTROL_TYPE[control_type]\n    self.setSizePolicy(h_policy, v_policy, c)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsPixmapItem","title":"<code>GraphicsPixmapItem</code>","text":"<p>         Bases: <code>widgets.GraphicsItemMixin</code>, <code>QtWidgets.QGraphicsPixmapItem</code></p> Source code in <code>prettyqt\\widgets\\graphicspixmapitem.py</code> <pre><code>class GraphicsPixmapItem(widgets.GraphicsItemMixin, QtWidgets.QGraphicsPixmapItem):\n    def set_transformation_mode(self, mode: constants.TransformationModeStr):\n\"\"\"Set transformation mode.\n\n        Args:\n            mode: transformation mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in constants.TRANSFORMATION_MODE:\n            raise InvalidParamError(mode, constants.TRANSFORMATION_MODE)\n        self.setTransformationMode(constants.TRANSFORMATION_MODE[mode])\n\n    def get_transformation_mode(self) -&gt; constants.TransformationModeStr:\n\"\"\"Return current transformation mode.\n\n        Returns:\n            transformation mode\n        \"\"\"\n        return constants.TRANSFORMATION_MODE.inverse[self.transformationMode()]\n\n    def set_shape_mode(self, mode: ShapeModeStr):\n\"\"\"Set shape mode.\n\n        Args:\n            mode: shape mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in SHAPE_MODE:\n            raise InvalidParamError(mode, SHAPE_MODE)\n        self.setShapeMode(SHAPE_MODE[mode])\n\n    def get_shape_mode(self) -&gt; ShapeModeStr:\n\"\"\"Return current shape mode.\n\n        Returns:\n            shape mode\n        \"\"\"\n        return SHAPE_MODE.inverse[self.shapeMode()]\n\n    def get_pixmap(self) -&gt; gui.Pixmap | None:\n        pix = self.pixmap()\n        return None if pix.isNull() else gui.Pixmap(pix)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.get_shape_mode","title":"<code>get_shape_mode() -&gt; ShapeModeStr</code>","text":"<p>Return current shape mode.</p> <p>Returns:</p> Type Description <code>ShapeModeStr</code> <p>shape mode</p> Source code in <code>prettyqt\\widgets\\graphicspixmapitem.py</code> <pre><code>def get_shape_mode(self) -&gt; ShapeModeStr:\n\"\"\"Return current shape mode.\n\n    Returns:\n        shape mode\n    \"\"\"\n    return SHAPE_MODE.inverse[self.shapeMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.get_transformation_mode","title":"<code>get_transformation_mode() -&gt; constants.TransformationModeStr</code>","text":"<p>Return current transformation mode.</p> <p>Returns:</p> Type Description <code>constants.TransformationModeStr</code> <p>transformation mode</p> Source code in <code>prettyqt\\widgets\\graphicspixmapitem.py</code> <pre><code>def get_transformation_mode(self) -&gt; constants.TransformationModeStr:\n\"\"\"Return current transformation mode.\n\n    Returns:\n        transformation mode\n    \"\"\"\n    return constants.TRANSFORMATION_MODE.inverse[self.transformationMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.set_shape_mode","title":"<code>set_shape_mode(mode: ShapeModeStr)</code>","text":"<p>Set shape mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ShapeModeStr</code> <p>shape mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\widgets\\graphicspixmapitem.py</code> <pre><code>def set_shape_mode(self, mode: ShapeModeStr):\n\"\"\"Set shape mode.\n\n    Args:\n        mode: shape mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in SHAPE_MODE:\n        raise InvalidParamError(mode, SHAPE_MODE)\n    self.setShapeMode(SHAPE_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.set_transformation_mode","title":"<code>set_transformation_mode(mode: constants.TransformationModeStr)</code>","text":"<p>Set transformation mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.TransformationModeStr</code> <p>transformation mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\widgets\\graphicspixmapitem.py</code> <pre><code>def set_transformation_mode(self, mode: constants.TransformationModeStr):\n\"\"\"Set transformation mode.\n\n    Args:\n        mode: transformation mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in constants.TRANSFORMATION_MODE:\n        raise InvalidParamError(mode, constants.TRANSFORMATION_MODE)\n    self.setTransformationMode(constants.TRANSFORMATION_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsScene","title":"<code>GraphicsScene</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtWidgets.QGraphicsScene</code></p> Source code in <code>prettyqt\\widgets\\graphicsscene.py</code> <pre><code>class GraphicsScene(core.ObjectMixin, QtWidgets.QGraphicsScene):\n    def serialize_fields(self):\n        return dict(\n            items=self.items(),\n            background_brush=self.get_background_brush(),\n            foreground_brush=self.get_foreground_brush(),\n            item_index_method=self.get_item_index_method(),\n            minimum_render_size=self.minimumRenderSize(),\n            palette=self.get_palette(),\n            bsp_tree_depth=self.bspTreeDepth(),\n            focus_on_touch=self.focusOnTouch(),\n            sticky_focus=self.stickyFocus(),\n            scene_rect=core.RectF(self.sceneRect()),\n            font=self.get_font(),\n        )\n\n    def __setitem__(self, state):\n        # self.setItem\n        self.setBackgroundBrush(state[\"background_brush\"])\n        self.setForegroundBrush(state[\"foreground_brush\"])\n        self.set_item_index_method(state[\"item_index_method\"])\n        self.setMinimumRenderSize(state[\"minimum_render_size\"])\n        self.setPalette(state[\"palette\"])\n        self.setBspTreeDepth(state[\"bsp_tree_depth\"])\n        self.setFocusOnTouchRelease(state[\"focus_on_touch\"])\n        self.setStickyFocus(state[\"focus_on_touch\"])\n        self.setSceneRect(state[\"scene_rect\"])\n        self.setFont(state[\"font\"])\n\n    def __getitem__(self, index: int) -&gt; QtWidgets.QGraphicsItem:\n        return self.items()[index]\n\n    def get_palette(self) -&gt; gui.Palette:\n        return gui.Palette(self.palette())\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_background_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.backgroundBrush())\n\n    def get_foreground_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.foregroundBrush())\n\n    def add(self, item) -&gt; QtWidgets.QGraphicsItem:\n        match item:\n            case QtWidgets.QGraphicsItem():\n                self.addItem(item)\n                return item\n            case QtGui.QPixmap():\n                return self.add_pixmap(item)\n            case QtGui.QPainterPath():\n                return self.add_path(item)\n            case QtGui.QPolygonF():\n                return self.add_polygon(item)\n            case QtCore.QRectF():\n                return self.add_rect(item)\n            case QtCore.QLine():\n                return self.add_line(item)\n            case str():\n                return self.add_text(item)\n            case QtWidgets.QWidget():\n                return self.add_widget(item)\n            case _:\n                raise TypeError(item)\n\n    def add_pixmap(self, pixmap: QtGui.QPixmap) -&gt; widgets.GraphicsPixmapItem:\n        g_item = widgets.GraphicsPixmapItem()\n        g_item.setPixmap(pixmap)\n        self.addItem(g_item)\n        return g_item\n\n    def add_polygon(\n        self,\n        polygon: QtGui.QPolygonF | QtGui.QPolygon,\n        pen: QtGui.QPen | None = None,\n        brush: QtGui.QBrush | None = None,\n    ) -&gt; widgets.GraphicsPolygonItem:\n        if isinstance(polygon, QtGui.QPolygon):\n            polygon = gui.PolygonF(polygon)\n        g_item = widgets.GraphicsPolygonItem()\n        g_item.setPolygon(polygon)\n        if brush is not None:\n            g_item.setBrush(brush)\n        if pen is not None:\n            g_item.setPen(pen)\n        self.addItem(g_item)\n        return g_item\n\n    def add_path(\n        self,\n        path: QtGui.QPainterPath,\n        pen: QtGui.QPen | None = None,\n        brush: QtGui.QBrush | None = None,\n    ) -&gt; widgets.GraphicsPathItem:\n        g_item = widgets.GraphicsPathItem()\n        g_item.setPath(path)\n        if brush is not None:\n            g_item.setBrush(brush)\n        if pen is not None:\n            g_item.setPen(pen)\n        self.addItem(g_item)\n        return g_item\n\n    def add_rect(\n        self,\n        rect: datatypes.RectType | datatypes.RectFType,\n        pen: QtGui.QPen | None = None,\n        brush: QtGui.QBrush | None = None,\n    ) -&gt; widgets.GraphicsRectItem:\n        if isinstance(rect, QtCore.QRect):\n            rect = core.RectF(rect)\n        elif isinstance(rect, tuple):\n            rect = core.RectF(*rect)\n        g_item = widgets.GraphicsRectItem()\n        g_item.setRect(rect)\n        if brush is not None:\n            g_item.setBrush(brush)\n        if pen is not None:\n            g_item.setPen(pen)\n        self.addItem(g_item)\n        return g_item\n\n    def add_line(\n        self,\n        line: QtCore.QLineF | QtCore.QLine | tuple[float, float, float, float],\n        pen: QtGui.QPen | None = None,\n    ) -&gt; widgets.GraphicsLineItem:\n        if isinstance(line, QtCore.QLine):\n            line = core.LineF(line)\n        elif isinstance(line, tuple):\n            line = core.LineF(*line)\n        g_item = widgets.GraphicsLineItem()\n        g_item.setLine(line)\n        if pen is not None:\n            g_item.setPen(pen)\n        self.addItem(g_item)\n        return g_item\n\n    def add_ellipse(\n        self,\n        ellipse: datatypes.RectType | datatypes.RectFType,\n        pen: QtGui.QPen | None = None,\n        brush: QtGui.QBrush | None = None,\n    ) -&gt; widgets.GraphicsEllipseItem:\n        if isinstance(ellipse, QtCore.QRect):\n            ellipse = core.RectF(ellipse)\n        elif isinstance(ellipse, tuple):\n            ellipse = core.RectF(*ellipse)\n        g_item = widgets.GraphicsEllipseItem()\n        g_item.setRect(ellipse)\n        if brush is not None:\n            g_item.setBrush(brush)\n        if pen is not None:\n            g_item.setPen(pen)\n        self.addItem(g_item)\n        return g_item\n\n    def add_text(\n        self, text: str, font: QtGui.QFont | None = None\n    ) -&gt; widgets.GraphicsTextItem:\n        g_item = widgets.GraphicsTextItem()\n        g_item.setPlainText(text)\n        if font is not None:\n            g_item.setFont(font)\n        self.addItem(g_item)\n        return g_item\n\n    def add_simple_text(\n        self, text: str, font: QtGui.QFont | None = None\n    ) -&gt; widgets.GraphicsSimpleTextItem:\n        g_item = widgets.GraphicsSimpleTextItem()\n        g_item.setText(text)\n        if font is not None:\n            g_item.setFont(font)\n        self.addItem(g_item)\n        return g_item\n\n    def add_widget(self, widget: QtWidgets.QWidget) -&gt; widgets.GraphicsProxyWidget:\n        g_item = widgets.GraphicsProxyWidget()\n        g_item.setWidget(widget)\n        self.addItem(g_item)\n        return g_item\n\n    def colliding_items(\n        self,\n        item: QtWidgets.QGraphicsItem,\n        mode: constants.ItemSelectionModeStr = \"intersects_shape\",\n    ) -&gt; list[QtWidgets.QGraphicsItem]:\n        if mode not in constants.ITEM_SELECTION_MODE:\n            raise InvalidParamError(mode, constants.ITEM_SELECTION_MODE)\n        return self.collidingItems(item, constants.ITEM_SELECTION_MODE[mode])\n\n    def add_item_group(\n        self, *items: QtWidgets.QGraphicsItem\n    ) -&gt; widgets.GraphicsItemGroup:\n        group = widgets.GraphicsItemGroup()\n        for item in items:\n            group.addToGroup(item)\n        return group\n\n    def set_item_index_method(self, method: ItemIndexMethodStr):\n\"\"\"Set item index method.\n\n        Args:\n            method: item index method to use\n\n        Raises:\n            InvalidParamError: invalid item index method\n        \"\"\"\n        if method not in ITEM_INDEX_METHOD:\n            raise InvalidParamError(method, ITEM_INDEX_METHOD)\n        self.setItemIndexMethod(ITEM_INDEX_METHOD[method])\n\n    def get_item_index_method(self) -&gt; ItemIndexMethodStr:\n\"\"\"Return item index method.\n\n        Returns:\n            item index method\n        \"\"\"\n        return ITEM_INDEX_METHOD.inverse[self.itemIndexMethod()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.get_item_index_method","title":"<code>get_item_index_method() -&gt; ItemIndexMethodStr</code>","text":"<p>Return item index method.</p> <p>Returns:</p> Type Description <code>ItemIndexMethodStr</code> <p>item index method</p> Source code in <code>prettyqt\\widgets\\graphicsscene.py</code> <pre><code>def get_item_index_method(self) -&gt; ItemIndexMethodStr:\n\"\"\"Return item index method.\n\n    Returns:\n        item index method\n    \"\"\"\n    return ITEM_INDEX_METHOD.inverse[self.itemIndexMethod()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.set_item_index_method","title":"<code>set_item_index_method(method: ItemIndexMethodStr)</code>","text":"<p>Set item index method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>ItemIndexMethodStr</code> <p>item index method to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid item index method</p> Source code in <code>prettyqt\\widgets\\graphicsscene.py</code> <pre><code>def set_item_index_method(self, method: ItemIndexMethodStr):\n\"\"\"Set item index method.\n\n    Args:\n        method: item index method to use\n\n    Raises:\n        InvalidParamError: invalid item index method\n    \"\"\"\n    if method not in ITEM_INDEX_METHOD:\n        raise InvalidParamError(method, ITEM_INDEX_METHOD)\n    self.setItemIndexMethod(ITEM_INDEX_METHOD[method])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsViewMixin","title":"<code>GraphicsViewMixin</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code></p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>class GraphicsViewMixin(widgets.AbstractScrollAreaMixin):\n    def serialize_fields(self):\n        return dict(\n            scene=self.scene(),\n            background_brush=self.get_background_brush(),\n            foreground_brush=self.get_foreground_brush(),\n            transformation_anchor=self.get_transformation_anchor(),\n            resize_anchor=self.get_resize_anchor(),\n            viewport_update_mode=self.get_viewport_update_mode(),\n            drag_mode=self.get_drag_mode(),\n            rubberband_selection_mode=self.get_rubberband_selection_mode(),\n            scene_rect=core.RectF(self.sceneRect()),\n            cache_mode=self.get_cache_mode(),\n            is_interactive=self.isInteractive(),\n        )\n\n    def __setitem__(self, state):\n        super().__setstate__(state)\n        self.setScene(state[\"scene\"])\n        self.setBackgroundBrush(state[\"background_brush\"])\n        self.setForegroundBrush(state[\"foreground_brush\"])\n        self.set_transformation_anchor(state[\"transformation_anchor\"])\n        self.set_resize_anchor(state[\"resicze_anchor\"])\n        self.set_viewport_update_mode(state[\"viewport_update_mode\"])\n        self.set_drag_mode(state[\"drag_mode\"])\n        self.set_rubberband_selection_mode(state[\"rubberband_selection_mode\"])\n        self.setSceneRect(state[\"scene_rect\"])\n        self.set_cache_mode(state[\"cache_mode\"])\n        self.setInteractive(state[\"is_interactive\"])\n\n    def __getitem__(self, index: int) -&gt; QtWidgets.QGraphicsItem:\n        return self.items()[index]\n\n    def get_background_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.backgroundBrush())\n\n    def get_foreground_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.foregroundBrush())\n\n    def invalidate_scene(\n        self, rect: QtCore.QRectF, layer: widgets.graphicsscene.SceneLayerStr = \"all\"\n    ):\n        if layer not in widgets.graphicsscene.SCENE_LAYER:\n            raise InvalidParamError(layer, widgets.graphicsscene.SCENE_LAYER)\n        self.invalidateScene(rect, widgets.graphicsscene.SCENE_LAYER[layer])\n\n    def set_transformation_anchor(self, mode: ViewportAnchorStr):\n\"\"\"Set how the view should position the scene during transformations.\n\n        Args:\n            mode: transformation anchor to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in VIEWPORT_ANCHOR:\n            raise InvalidParamError(mode, VIEWPORT_ANCHOR)\n        self.setTransformationAnchor(VIEWPORT_ANCHOR[mode])\n\n    def get_transformation_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current transformation anchor.\n\n        Returns:\n            viewport anchor\n        \"\"\"\n        return VIEWPORT_ANCHOR.inverse[self.transformationAnchor()]\n\n    def set_transform(self, transform: datatypes.TransformType, combine: bool = False):\n        if isinstance(transform, tuple):\n            transform = gui.Transform(*transform)\n        self.setTransform(transform, combine)\n\n    def set_resize_anchor(self, mode: ViewportAnchorStr):\n\"\"\"Set how the view should position the scene during resizes.\n\n        Args:\n            mode: resize anchor to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in VIEWPORT_ANCHOR:\n            raise InvalidParamError(mode, VIEWPORT_ANCHOR)\n        self.setResizeAnchor(VIEWPORT_ANCHOR[mode])\n\n    def get_resize_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current resize anchor.\n\n        Returns:\n            resize anchor\n        \"\"\"\n        return VIEWPORT_ANCHOR.inverse[self.resizeAnchor()]\n\n    def set_viewport_update_mode(self, mode: ViewportUpdateModeStr):\n\"\"\"Set how the viewport should update its contents.\n\n        Args:\n            mode: viewport update mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in VIEWPORT_UPDATE_MODE:\n            raise InvalidParamError(mode, VIEWPORT_UPDATE_MODE)\n        self.setViewportUpdateMode(VIEWPORT_UPDATE_MODE[mode])\n\n    def get_viewport_update_mode(self) -&gt; ViewportUpdateModeStr:\n\"\"\"Return current viewport update mode.\n\n        Returns:\n            viewport update mode\n        \"\"\"\n        return VIEWPORT_UPDATE_MODE.inverse[self.viewportUpdateMode()]\n\n    def set_drag_mode(self, mode: DragModeStr):\n\"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed.\n\n        Args:\n            mode: drag mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in DRAG_MODE:\n            raise InvalidParamError(mode, DRAG_MODE)\n        self.setDragMode(DRAG_MODE[mode])\n\n    def get_drag_mode(self) -&gt; DragModeStr:\n\"\"\"Return current drag mode.\n\n        Returns:\n            drag mode\n        \"\"\"\n        return DRAG_MODE.inverse[self.dragMode()]\n\n    def set_rubberband_selection_mode(self, mode: constants.ItemSelectionModeStr):\n\"\"\"Set the behavior for selecting items with a rubber band selection rectangle.\n\n        Args:\n            mode: rubberband selection mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in constants.ITEM_SELECTION_MODE:\n            raise InvalidParamError(mode, constants.ITEM_SELECTION_MODE)\n        self.setRubberBandSelectionMode(constants.ITEM_SELECTION_MODE[mode])\n\n    def get_rubberband_selection_mode(self) -&gt; constants.ItemSelectionModeStr:\n\"\"\"Return current rubberband selection mode.\n\n        Returns:\n            rubberband selection mode\n        \"\"\"\n        return constants.ITEM_SELECTION_MODE.inverse[self.rubberBandSelectionMode()]\n\n    def set_cache_mode(self, mode: CacheModeStr):\n\"\"\"Set the cache mode.\n\n        Args:\n            mode: cache mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in CACHE_MODES:\n            raise InvalidParamError(mode, CACHE_MODES)\n        self.setCacheMode(CACHE_MODES[mode])\n\n    def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Return current cache mode.\n\n        Returns:\n            cache mode\n        \"\"\"\n        return CACHE_MODES.inverse[self.cacheMode()]\n\n    def set_optimization_flags(self, *items: OptimizationFlagStr):\n        for item in items:\n            if item not in OPTIMIZATION_FLAGS:\n                raise InvalidParamError(item, OPTIMIZATION_FLAGS)\n        flags = helpers.merge_flags(items, OPTIMIZATION_FLAGS)\n        self.setOptimizationFlags(flags)\n\n    def get_optimization_flags(self) -&gt; list[OptimizationFlagStr]:\n        return OPTIMIZATION_FLAGS.get_list(self.optimizationFlags())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_cache_mode","title":"<code>get_cache_mode() -&gt; CacheModeStr</code>","text":"<p>Return current cache mode.</p> <p>Returns:</p> Type Description <code>CacheModeStr</code> <p>cache mode</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Return current cache mode.\n\n    Returns:\n        cache mode\n    \"\"\"\n    return CACHE_MODES.inverse[self.cacheMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_drag_mode","title":"<code>get_drag_mode() -&gt; DragModeStr</code>","text":"<p>Return current drag mode.</p> <p>Returns:</p> Type Description <code>DragModeStr</code> <p>drag mode</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_drag_mode(self) -&gt; DragModeStr:\n\"\"\"Return current drag mode.\n\n    Returns:\n        drag mode\n    \"\"\"\n    return DRAG_MODE.inverse[self.dragMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_resize_anchor","title":"<code>get_resize_anchor() -&gt; ViewportAnchorStr</code>","text":"<p>Return current resize anchor.</p> <p>Returns:</p> Type Description <code>ViewportAnchorStr</code> <p>resize anchor</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_resize_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current resize anchor.\n\n    Returns:\n        resize anchor\n    \"\"\"\n    return VIEWPORT_ANCHOR.inverse[self.resizeAnchor()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_rubberband_selection_mode","title":"<code>get_rubberband_selection_mode() -&gt; constants.ItemSelectionModeStr</code>","text":"<p>Return current rubberband selection mode.</p> <p>Returns:</p> Type Description <code>constants.ItemSelectionModeStr</code> <p>rubberband selection mode</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_rubberband_selection_mode(self) -&gt; constants.ItemSelectionModeStr:\n\"\"\"Return current rubberband selection mode.\n\n    Returns:\n        rubberband selection mode\n    \"\"\"\n    return constants.ITEM_SELECTION_MODE.inverse[self.rubberBandSelectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_transformation_anchor","title":"<code>get_transformation_anchor() -&gt; ViewportAnchorStr</code>","text":"<p>Return current transformation anchor.</p> <p>Returns:</p> Type Description <code>ViewportAnchorStr</code> <p>viewport anchor</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_transformation_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current transformation anchor.\n\n    Returns:\n        viewport anchor\n    \"\"\"\n    return VIEWPORT_ANCHOR.inverse[self.transformationAnchor()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_viewport_update_mode","title":"<code>get_viewport_update_mode() -&gt; ViewportUpdateModeStr</code>","text":"<p>Return current viewport update mode.</p> <p>Returns:</p> Type Description <code>ViewportUpdateModeStr</code> <p>viewport update mode</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def get_viewport_update_mode(self) -&gt; ViewportUpdateModeStr:\n\"\"\"Return current viewport update mode.\n\n    Returns:\n        viewport update mode\n    \"\"\"\n    return VIEWPORT_UPDATE_MODE.inverse[self.viewportUpdateMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_cache_mode","title":"<code>set_cache_mode(mode: CacheModeStr)</code>","text":"<p>Set the cache mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CacheModeStr</code> <p>cache mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_cache_mode(self, mode: CacheModeStr):\n\"\"\"Set the cache mode.\n\n    Args:\n        mode: cache mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in CACHE_MODES:\n        raise InvalidParamError(mode, CACHE_MODES)\n    self.setCacheMode(CACHE_MODES[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_drag_mode","title":"<code>set_drag_mode(mode: DragModeStr)</code>","text":"<p>Set the behavior for dragging the mouse while the left mouse button is pressed.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>DragModeStr</code> <p>drag mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_drag_mode(self, mode: DragModeStr):\n\"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed.\n\n    Args:\n        mode: drag mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in DRAG_MODE:\n        raise InvalidParamError(mode, DRAG_MODE)\n    self.setDragMode(DRAG_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_resize_anchor","title":"<code>set_resize_anchor(mode: ViewportAnchorStr)</code>","text":"<p>Set how the view should position the scene during resizes.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewportAnchorStr</code> <p>resize anchor to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_resize_anchor(self, mode: ViewportAnchorStr):\n\"\"\"Set how the view should position the scene during resizes.\n\n    Args:\n        mode: resize anchor to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in VIEWPORT_ANCHOR:\n        raise InvalidParamError(mode, VIEWPORT_ANCHOR)\n    self.setResizeAnchor(VIEWPORT_ANCHOR[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_rubberband_selection_mode","title":"<code>set_rubberband_selection_mode(mode: constants.ItemSelectionModeStr)</code>","text":"<p>Set the behavior for selecting items with a rubber band selection rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ItemSelectionModeStr</code> <p>rubberband selection mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_rubberband_selection_mode(self, mode: constants.ItemSelectionModeStr):\n\"\"\"Set the behavior for selecting items with a rubber band selection rectangle.\n\n    Args:\n        mode: rubberband selection mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in constants.ITEM_SELECTION_MODE:\n        raise InvalidParamError(mode, constants.ITEM_SELECTION_MODE)\n    self.setRubberBandSelectionMode(constants.ITEM_SELECTION_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_transformation_anchor","title":"<code>set_transformation_anchor(mode: ViewportAnchorStr)</code>","text":"<p>Set how the view should position the scene during transformations.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewportAnchorStr</code> <p>transformation anchor to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_transformation_anchor(self, mode: ViewportAnchorStr):\n\"\"\"Set how the view should position the scene during transformations.\n\n    Args:\n        mode: transformation anchor to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in VIEWPORT_ANCHOR:\n        raise InvalidParamError(mode, VIEWPORT_ANCHOR)\n    self.setTransformationAnchor(VIEWPORT_ANCHOR[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_viewport_update_mode","title":"<code>set_viewport_update_mode(mode: ViewportUpdateModeStr)</code>","text":"<p>Set how the viewport should update its contents.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewportUpdateModeStr</code> <p>viewport update mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt\\widgets\\graphicsview.py</code> <pre><code>def set_viewport_update_mode(self, mode: ViewportUpdateModeStr):\n\"\"\"Set how the viewport should update its contents.\n\n    Args:\n        mode: viewport update mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in VIEWPORT_UPDATE_MODE:\n        raise InvalidParamError(mode, VIEWPORT_UPDATE_MODE)\n    self.setViewportUpdateMode(VIEWPORT_UPDATE_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GraphicsWidgetMixin","title":"<code>GraphicsWidgetMixin</code>","text":"<p>         Bases: <code>widgets.GraphicsObjectMixin</code>, <code>widgets.GraphicsLayoutItemMixin</code></p> Source code in <code>prettyqt\\widgets\\graphicswidget.py</code> <pre><code>class GraphicsWidgetMixin(widgets.GraphicsObjectMixin, widgets.GraphicsLayoutItemMixin):\n    def set_layout(self, layout: LayoutStr | QtWidgets.QGraphicsLayout | None):\n        match layout:\n            case None:\n                return\n            case QtWidgets.QGraphicsLayout():\n                self.box = layout\n            case \"grid\":\n                self.box = widgets.GraphicsGridLayout()\n            case \"anchor\":\n                self.box = widgets.GraphicsAnchorLayout()\n            case \"horizontal\" | \"vertical\":\n                self.box = widgets.GraphicsLinearLayout(layout)\n            case _:\n                raise ValueError(\"Invalid Layout\")\n        self.setLayout(self.box)\n\n    def set_focus_policy(self, policy: constants.FocusPolicyStr) -&gt; None:\n\"\"\"Set the way the widget accepts keyboard focus.\n\n        Args:\n            policy: Focus policy\n\n        Raises:\n            InvalidParamError: Description\n        \"\"\"\n        if policy not in constants.FOCUS_POLICY:\n            raise InvalidParamError(policy, constants.FOCUS_POLICY)\n        self.setFocusPolicy(constants.FOCUS_POLICY[policy])\n\n    def get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return way the widget accepts keyboard focus.\n\n        Returns:\n            str: Focus policy\n        \"\"\"\n        return constants.FOCUS_POLICY.inverse[self.focusPolicy()]\n\n    def window_frame_section_at(\n        self, point: datatypes.PointType\n    ) -&gt; constants.WindowFrameSectionStr:\n\"\"\"Return the window frame section at given position.\n\n        Returns:\n            str: Window frame section\n        \"\"\"\n        if isinstance(point, tuple):\n            point = QtCore.QPoint(*point)\n        return constants.WINDOW_FRAME_SECTION.inverse[self.windowFrameSectionAt(point)]\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_palette(self) -&gt; gui.Palette:\n        return gui.Palette(self.palette())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidgetMixin.get_focus_policy","title":"<code>get_focus_policy() -&gt; constants.FocusPolicyStr</code>","text":"<p>Return way the widget accepts keyboard focus.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>constants.FocusPolicyStr</code> <p>Focus policy</p> Source code in <code>prettyqt\\widgets\\graphicswidget.py</code> <pre><code>def get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return way the widget accepts keyboard focus.\n\n    Returns:\n        str: Focus policy\n    \"\"\"\n    return constants.FOCUS_POLICY.inverse[self.focusPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidgetMixin.set_focus_policy","title":"<code>set_focus_policy(policy: constants.FocusPolicyStr) -&gt; None</code>","text":"<p>Set the way the widget accepts keyboard focus.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>constants.FocusPolicyStr</code> <p>Focus policy</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>Description</p> Source code in <code>prettyqt\\widgets\\graphicswidget.py</code> <pre><code>def set_focus_policy(self, policy: constants.FocusPolicyStr) -&gt; None:\n\"\"\"Set the way the widget accepts keyboard focus.\n\n    Args:\n        policy: Focus policy\n\n    Raises:\n        InvalidParamError: Description\n    \"\"\"\n    if policy not in constants.FOCUS_POLICY:\n        raise InvalidParamError(policy, constants.FOCUS_POLICY)\n    self.setFocusPolicy(constants.FOCUS_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidgetMixin.window_frame_section_at","title":"<code>window_frame_section_at(point: datatypes.PointType) -&gt; constants.WindowFrameSectionStr</code>","text":"<p>Return the window frame section at given position.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>constants.WindowFrameSectionStr</code> <p>Window frame section</p> Source code in <code>prettyqt\\widgets\\graphicswidget.py</code> <pre><code>def window_frame_section_at(\n    self, point: datatypes.PointType\n) -&gt; constants.WindowFrameSectionStr:\n\"\"\"Return the window frame section at given position.\n\n    Returns:\n        str: Window frame section\n    \"\"\"\n    if isinstance(point, tuple):\n        point = QtCore.QPoint(*point)\n    return constants.WINDOW_FRAME_SECTION.inverse[self.windowFrameSectionAt(point)]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GridLayout","title":"<code>GridLayout</code>","text":"<p>         Bases: <code>widgets.LayoutMixin</code>, <code>QtWidgets.QGridLayout</code></p> Source code in <code>prettyqt\\widgets\\gridlayout.py</code> <pre><code>class GridLayout(widgets.LayoutMixin, QtWidgets.QGridLayout):\n    def __getitem__(\n        self, idx: tuple[int, int] | int | str\n    ) -&gt; QtWidgets.QWidget | QtWidgets.QLayout | None:\n        if isinstance(idx, tuple):\n            item = self.itemAtPosition(*idx)\n        elif isinstance(idx, int):\n            item = self.itemAt(idx)\n        else:\n            return self.find_child(QtCore.QObject, idx)\n        widget = item.widget()\n        return item.layout() if widget is None else widget\n\n    def __setitem__(\n        self,\n        idx: tuple[int | slice, int | slice],\n        value: QtWidgets.QWidget | QtWidgets.QLayout | QtWidgets.QLayoutItem,\n    ):\n        row, col = idx\n        rowspan = row.stop - row.start + 1 if isinstance(row, slice) else 1\n        colspan = col.stop - col.start + 1 if isinstance(col, slice) else 1\n        rowstart = row.start if isinstance(row, slice) else row\n        colstart = col.start if isinstance(col, slice) else col\n        self.add(value, rowstart, colstart, rowspan, colspan)\n\n    # def serialize_fields(self):\n    #     widgets = []\n    #     positions = []\n    #     for i, item in enumerate(list(self)):\n    #         widgets.append(item)\n    #         positions.append(self.getItemPosition(i))\n    #     return dict(widgets=widgets, positions=positions)\n\n    # def __setstate__(self, state):\n    #     for item, pos in zip(state[\"widgets\"], state[\"positions\"]):\n    #         x, y, w, h = pos\n    #         self[x : x + w - 1, y : y + h - 1] = item\n\n    # def __reduce__(self):\n    #     return type(self), (), self.__getstate__()\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QWidget | QtWidgets.QLayout]:\n        return iter(item for i in range(self.count()) if (item := self[i]) is not None)\n\n    def __add__(\n        self,\n        other: (\n            tuple | list | QtWidgets.QWidget | QtWidgets.QLayout | QtWidgets.QLayoutItem\n        ),\n    ):\n        if isinstance(other, tuple | list):\n            for i, _control in enumerate(other):\n                self[self.rowCount(), i] = other  # type: ignore\n        else:\n            self[self.rowCount(), 0 : self.columnCount() - 1] = other\n        return self\n\n    def add(\n        self,\n        item: QtWidgets.QWidget | QtWidgets.QLayout | QtWidgets.QLayoutItem,\n        rowstart: int,\n        colstart: int,\n        rowspan: int = 1,\n        colspan: int = 1,\n    ):\n        match item:\n            case QtWidgets.QWidget():\n                self.addWidget(item, rowstart, colstart, rowspan, colspan)\n            case QtWidgets.QLayout():\n                self.addLayout(item, rowstart, colstart, rowspan, colspan)\n            case QtWidgets.QLayoutItem():\n                self.addItem(item, rowstart, colstart, rowspan, colspan)\n\n    def append(self, item: QtWidgets.QWidget | QtWidgets.QLayout | QtWidgets.QLayoutItem):\n        self[self.rowCount(), 0 : self.columnCount() - 1] = item\n\n    def set_origin_corner(self, corner: constants.CornerStr):\n\"\"\"Set the origin corner.\n\n        Args:\n            corner: origin corner\n\n        Raises:\n            InvalidParamError: corner does not exist\n        \"\"\"\n        if corner not in constants.CORNER:\n            raise InvalidParamError(corner, constants.CORNER)\n        self.setOriginCorner(constants.CORNER[corner])\n\n    def get_origin_corner(self) -&gt; constants.CornerStr:\n\"\"\"Return current origin corner.\n\n        Returns:\n            origin corner\n        \"\"\"\n        return constants.CORNER.inverse[self.originCorner()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.get_origin_corner","title":"<code>get_origin_corner() -&gt; constants.CornerStr</code>","text":"<p>Return current origin corner.</p> <p>Returns:</p> Type Description <code>constants.CornerStr</code> <p>origin corner</p> Source code in <code>prettyqt\\widgets\\gridlayout.py</code> <pre><code>def get_origin_corner(self) -&gt; constants.CornerStr:\n\"\"\"Return current origin corner.\n\n    Returns:\n        origin corner\n    \"\"\"\n    return constants.CORNER.inverse[self.originCorner()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.set_origin_corner","title":"<code>set_origin_corner(corner: constants.CornerStr)</code>","text":"<p>Set the origin corner.</p> <p>Parameters:</p> Name Type Description Default <code>corner</code> <code>constants.CornerStr</code> <p>origin corner</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>corner does not exist</p> Source code in <code>prettyqt\\widgets\\gridlayout.py</code> <pre><code>def set_origin_corner(self, corner: constants.CornerStr):\n\"\"\"Set the origin corner.\n\n    Args:\n        corner: origin corner\n\n    Raises:\n        InvalidParamError: corner does not exist\n    \"\"\"\n    if corner not in constants.CORNER:\n        raise InvalidParamError(corner, constants.CORNER)\n    self.setOriginCorner(constants.CORNER[corner])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.GroupBox","title":"<code>GroupBox</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QGroupBox</code></p> <p>GroupBox widget.</p> <p>A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets.</p> Source code in <code>prettyqt\\widgets\\groupbox.py</code> <pre><code>class GroupBox(widgets.WidgetMixin, QtWidgets.QGroupBox):\n\"\"\"GroupBox widget.\n\n    A group box provides a frame, a title on top, a keyboard shortcut,\n    and displays various other widgets inside itself.\n    The keyboard shortcut moves keyboard focus to one of the group box's child widgets.\n    \"\"\"\n\n    def __init__(\n        self,\n        title: str = \"\",\n        checkable: bool = False,\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        super().__init__(title, parent)\n        self.setCheckable(checkable)\n\n    def __repr__(self):\n        return get_repr(self, self.title())\n\n    def set_title(self, title: str):\n        self.setTitle(title)\n\n    def set_alignment(self, alignment):\n        self.setAlignment(constants.H_ALIGNMENT[alignment])\n\n    def set_enabled(self, state):\n        for widget in self.layout():\n            widget.setEnabled(state)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.InputDialog","title":"<code>InputDialog</code>","text":"<p>         Bases: <code>widgets.DialogMixin</code>, <code>QtWidgets.QInputDialog</code></p> Source code in <code>prettyqt\\widgets\\inputdialog.py</code> <pre><code>class InputDialog(widgets.DialogMixin, QtWidgets.QInputDialog):\n    @classmethod\n    def get_int(\n        cls,\n        title: str = \"\",\n        label: str = \"\",\n        icon: datatypes.IconType = None,\n    ) -&gt; int | None:\n        par = widgets.Dialog()\n        par.set_icon(icon)\n        v = cls.getInt(par, title, label, value=0)\n        return v[0] if v[1] else None\n\n    @classmethod\n    def get_float(\n        cls,\n        title: str = \"\",\n        label: str = \"\",\n        icon: datatypes.IconType = None,\n    ) -&gt; float | None:\n        par = widgets.Dialog()\n        par.set_icon(icon)\n        v = cls.getDouble(par, title, label, value=0.0)\n        return v[0] if v[1] else None\n\n    @classmethod\n    def get_text(\n        cls,\n        title: str = \"\",\n        label: str = \"\",\n        icon: datatypes.IconType = None,\n        default_value: str = \"\",\n        echo_mode: widgets.lineedit.EchoModeStr = \"normal\",\n    ) -&gt; str | None:\n        par = widgets.Dialog()\n        par.set_icon(icon)\n        if echo_mode not in widgets.lineedit.ECHO_MODE:\n            raise InvalidParamError(echo_mode, widgets.lineedit.ECHO_MODE)\n        v = cls.getText(\n            par, title, label, widgets.lineedit.ECHO_MODE[echo_mode], default_value\n        )\n        return v[0] if v[1] else None\n\n    @classmethod\n    def get_item(\n        cls,\n        items: list[str],\n        title: str = \"\",\n        label: str = \"\",\n        icon: datatypes.IconType = None,\n        editable: bool = False,\n    ) -&gt; str | None:\n        par = widgets.Dialog()\n        par.set_icon(icon)\n        v = cls.getItem(par, title, label, items, editable=editable, current=0)\n        return v[0] if v[1] else None\n\n    def set_text_echo_mode(self, mode: widgets.lineedit.EchoModeStr):\n\"\"\"Set text echo mode.\n\n        Args:\n            mode: echo mode to use\n\n        Raises:\n            InvalidParamError: invalid echo mode\n        \"\"\"\n        if mode not in widgets.lineedit.ECHO_MODE:\n            raise InvalidParamError(mode, widgets.lineedit.ECHO_MODE)\n        self.setTextEchoMode(widgets.lineedit.ECHO_MODE[mode])\n\n    def get_text_echo_mode(self) -&gt; widgets.lineedit.EchoModeStr:\n\"\"\"Return text echo mode.\n\n        Returns:\n            echo mode\n        \"\"\"\n        return widgets.lineedit.ECHO_MODE.inverse[self.textEchoMode()]\n\n    def set_input_mode(self, mode: InputModeStr):\n\"\"\"Set input mode.\n\n        Args:\n            mode: input mode to use\n\n        Raises:\n            InvalidParamError: invalid input mode\n        \"\"\"\n        if mode not in INPUT_MODE:\n            raise InvalidParamError(mode, INPUT_MODE)\n        self.setInputMode(INPUT_MODE[mode])\n\n    def get_input_mode(self) -&gt; InputModeStr:\n\"\"\"Return input mode.\n\n        Returns:\n            input mode\n        \"\"\"\n        return INPUT_MODE.inverse[self.inputMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.get_input_mode","title":"<code>get_input_mode() -&gt; InputModeStr</code>","text":"<p>Return input mode.</p> <p>Returns:</p> Type Description <code>InputModeStr</code> <p>input mode</p> Source code in <code>prettyqt\\widgets\\inputdialog.py</code> <pre><code>def get_input_mode(self) -&gt; InputModeStr:\n\"\"\"Return input mode.\n\n    Returns:\n        input mode\n    \"\"\"\n    return INPUT_MODE.inverse[self.inputMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.get_text_echo_mode","title":"<code>get_text_echo_mode() -&gt; widgets.lineedit.EchoModeStr</code>","text":"<p>Return text echo mode.</p> <p>Returns:</p> Type Description <code>widgets.lineedit.EchoModeStr</code> <p>echo mode</p> Source code in <code>prettyqt\\widgets\\inputdialog.py</code> <pre><code>def get_text_echo_mode(self) -&gt; widgets.lineedit.EchoModeStr:\n\"\"\"Return text echo mode.\n\n    Returns:\n        echo mode\n    \"\"\"\n    return widgets.lineedit.ECHO_MODE.inverse[self.textEchoMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.set_input_mode","title":"<code>set_input_mode(mode: InputModeStr)</code>","text":"<p>Set input mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>InputModeStr</code> <p>input mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid input mode</p> Source code in <code>prettyqt\\widgets\\inputdialog.py</code> <pre><code>def set_input_mode(self, mode: InputModeStr):\n\"\"\"Set input mode.\n\n    Args:\n        mode: input mode to use\n\n    Raises:\n        InvalidParamError: invalid input mode\n    \"\"\"\n    if mode not in INPUT_MODE:\n        raise InvalidParamError(mode, INPUT_MODE)\n    self.setInputMode(INPUT_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.set_text_echo_mode","title":"<code>set_text_echo_mode(mode: widgets.lineedit.EchoModeStr)</code>","text":"<p>Set text echo mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>widgets.lineedit.EchoModeStr</code> <p>echo mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid echo mode</p> Source code in <code>prettyqt\\widgets\\inputdialog.py</code> <pre><code>def set_text_echo_mode(self, mode: widgets.lineedit.EchoModeStr):\n\"\"\"Set text echo mode.\n\n    Args:\n        mode: echo mode to use\n\n    Raises:\n        InvalidParamError: invalid echo mode\n    \"\"\"\n    if mode not in widgets.lineedit.ECHO_MODE:\n        raise InvalidParamError(mode, widgets.lineedit.ECHO_MODE)\n    self.setTextEchoMode(widgets.lineedit.ECHO_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.LCDNumber","title":"<code>LCDNumber</code>","text":"<p>         Bases: <code>widgets.FrameMixin</code>, <code>QtWidgets.QLCDNumber</code></p> Source code in <code>prettyqt\\widgets\\lcdnumber.py</code> <pre><code>class LCDNumber(widgets.FrameMixin, QtWidgets.QLCDNumber):\n    def set_mode(self, mode: ModeStr):\n\"\"\"Set the lcd mode.\n\n        Args:\n            mode: lcd mode to use\n\n        Raises:\n            InvalidParamError: lcd mode does not exist\n        \"\"\"\n        if mode not in MODE:\n            raise InvalidParamError(mode, MODE)\n        self.setMode(MODE[mode])\n\n    def get_mode(self) -&gt; ModeStr:\n\"\"\"Return current lcd mode.\n\n        Returns:\n            lcd mode\n        \"\"\"\n        return MODE.inverse[self.mode()]\n\n    def set_segment_style(self, mode: SegmentStyleStr):\n\"\"\"Set the segment style.\n\n        Args:\n            mode: segment style to use\n\n        Raises:\n            InvalidParamError: segment style does not exist\n        \"\"\"\n        if mode not in SEGMENT_STYLE:\n            raise InvalidParamError(mode, SEGMENT_STYLE)\n        self.setSegmentStyle(SEGMENT_STYLE[mode])\n\n    def get_segment_style(self) -&gt; SegmentStyleStr:\n\"\"\"Return current segment style.\n\n        Returns:\n            segment style\n        \"\"\"\n        return SEGMENT_STYLE.inverse[self.segmentStyle()]\n\n    def set_value(self, value: float | str):\n        self.display(value)\n\n    def get_value(self) -&gt; float:\n        return self.value()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_mode","title":"<code>get_mode() -&gt; ModeStr</code>","text":"<p>Return current lcd mode.</p> <p>Returns:</p> Type Description <code>ModeStr</code> <p>lcd mode</p> Source code in <code>prettyqt\\widgets\\lcdnumber.py</code> <pre><code>def get_mode(self) -&gt; ModeStr:\n\"\"\"Return current lcd mode.\n\n    Returns:\n        lcd mode\n    \"\"\"\n    return MODE.inverse[self.mode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_segment_style","title":"<code>get_segment_style() -&gt; SegmentStyleStr</code>","text":"<p>Return current segment style.</p> <p>Returns:</p> Type Description <code>SegmentStyleStr</code> <p>segment style</p> Source code in <code>prettyqt\\widgets\\lcdnumber.py</code> <pre><code>def get_segment_style(self) -&gt; SegmentStyleStr:\n\"\"\"Return current segment style.\n\n    Returns:\n        segment style\n    \"\"\"\n    return SEGMENT_STYLE.inverse[self.segmentStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_mode","title":"<code>set_mode(mode: ModeStr)</code>","text":"<p>Set the lcd mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ModeStr</code> <p>lcd mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>lcd mode does not exist</p> Source code in <code>prettyqt\\widgets\\lcdnumber.py</code> <pre><code>def set_mode(self, mode: ModeStr):\n\"\"\"Set the lcd mode.\n\n    Args:\n        mode: lcd mode to use\n\n    Raises:\n        InvalidParamError: lcd mode does not exist\n    \"\"\"\n    if mode not in MODE:\n        raise InvalidParamError(mode, MODE)\n    self.setMode(MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_segment_style","title":"<code>set_segment_style(mode: SegmentStyleStr)</code>","text":"<p>Set the segment style.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SegmentStyleStr</code> <p>segment style to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>segment style does not exist</p> Source code in <code>prettyqt\\widgets\\lcdnumber.py</code> <pre><code>def set_segment_style(self, mode: SegmentStyleStr):\n\"\"\"Set the segment style.\n\n    Args:\n        mode: segment style to use\n\n    Raises:\n        InvalidParamError: segment style does not exist\n    \"\"\"\n    if mode not in SEGMENT_STYLE:\n        raise InvalidParamError(mode, SEGMENT_STYLE)\n    self.setSegmentStyle(SEGMENT_STYLE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.Label","title":"<code>Label</code>","text":"<p>         Bases: <code>widgets.FrameMixin</code>, <code>QtWidgets.QLabel</code></p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>class Label(widgets.FrameMixin, QtWidgets.QLabel):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.openExternalLinks()\n\n    def __repr__(self):\n        return get_repr(self, self.text())\n\n    def allow_links(self) -&gt; Label:\n        # self.setText(\"&lt;a href=\\\"http://example.com/\\\"&gt;Click Here!&lt;/a&gt;\")\n        self.setTextFormat(QtCore.Qt.TextFormat.RichText)\n        self.setTextInteractionFlags(\n            QtCore.Qt.TextInteractionFlag.TextBrowserInteraction  # type: ignore\n        )\n        self.setOpenExternalLinks(True)\n        return self\n\n    def set_alignment(\n        self,\n        horizontal: constants.HorizontalAlignmentStr | None = None,\n        vertical: constants.VerticalAlignmentStr | None = None,\n    ):\n\"\"\"Set the alignment of the label's contents.\"\"\"\n        match horizontal, vertical:\n            case None, None:\n                return self\n            case None, _:\n                flag = constants.V_ALIGNMENT[vertical]\n            case _, None:\n                flag = constants.H_ALIGNMENT[horizontal]\n            case _, _:\n                flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n        self.setAlignment(flag)\n        return self\n\n    def get_horizontal_alignment(self) -&gt; constants.HorizontalAlignmentStr:\n        align = self.alignment()\n        if align &amp; constants.ALIGN_RIGHT:  # type: ignore\n            return \"right\"\n        elif align &amp; constants.ALIGN_H_CENTER:  # type: ignore\n            return \"center\"\n        elif align &amp; constants.ALIGN_JUSTIFY:  # type: ignore\n            return \"justify\"\n        else:\n            return \"left\"\n\n    def get_vertical_alignment(self) -&gt; constants.VerticalAlignmentStr:\n        align = self.alignment()\n        if align &amp; constants.ALIGN_TOP:  # type: ignore\n            return \"top\"\n        elif align &amp; constants.ALIGN_BOTTOM:  # type: ignore\n            return \"bottom\"\n        elif align &amp; constants.ALIGN_BASELINE:  # type: ignore\n            return \"baseline\"\n        else:\n            return \"center\"\n\n    def set_indent(self, indent: int) -&gt; Label:\n\"\"\"Set the label's text indent in pixels.\"\"\"\n        self.setIndent(indent)\n        return self\n\n    def set_text_format(self, text_format: TextFormatStr) -&gt; Label:\n\"\"\"Set the text format.\n\n        Args:\n            text_format: text format to use\n\n        Raises:\n            InvalidParamError: text format does not exist\n        \"\"\"\n        if text_format not in TEXT_FORMAT:\n            raise InvalidParamError(text_format, TEXT_FORMAT)\n        self.setTextFormat(TEXT_FORMAT[text_format])\n        return self\n\n    def get_text_format(self) -&gt; TextFormatStr:\n\"\"\"Return current text format.\n\n        Returns:\n            text format\n        \"\"\"\n        return TEXT_FORMAT.inverse[self.textFormat()]\n\n    def set_text_interaction(self, *types: TextInteractionStr) -&gt; Label:\n\"\"\"Set the text interaction mode.\n\n        Args:\n            types: text interaction mode to use\n\n        Raises:\n            InvalidParamError: text interaction mode does not exist\n        \"\"\"\n        for item in types:\n            if item not in TEXT_INTERACTION:\n                raise InvalidParamError(item, TEXT_INTERACTION)\n        flags = helpers.merge_flags(types, TEXT_INTERACTION)\n        self.setTextInteractionFlags(flags)\n        return self\n\n    def get_text_interaction(self) -&gt; list[TextInteractionStr]:\n\"\"\"Return current text interaction mode.\n\n        Returns:\n            list of text interaction modes\n        \"\"\"\n        return TEXT_INTERACTION.get_list(self.textInteractionFlags())\n\n    def set_text(self, text: str) -&gt; Label:\n\"\"\"Set the label's text.\"\"\"\n        self.setText(text)\n        return self\n\n    def set_bold(self, bold: bool = True) -&gt; Label:\n        font = self.font()\n        font.setBold(bold)\n        self.setFont(font)\n        return self\n\n    def set_italic(self, italic: bool = True) -&gt; Label:\n        font = self.font()\n        font.setItalic(italic)\n        self.setFont(font)\n        return self\n\n    def set_point_size(self, size: int) -&gt; Label:\n        font = self.font()\n        font.setPointSize(size)\n        self.setFont(font)\n        return self\n\n    def set_weight(self, weight: gui.font.WeightStr) -&gt; Label:\n\"\"\"Set the font weight.\n\n        Args:\n            weight: font weight\n\n        Raises:\n            InvalidParamError: invalid font weight\n        \"\"\"\n        if weight not in gui.font.WEIGHT:\n            raise InvalidParamError(weight, gui.font.WEIGHT)\n        font = self.font()\n        font.setWeight(gui.font.WEIGHT[weight])\n        self.setFont(font)\n        return self\n\n    def set_color(self, color: datatypes.ColorType) -&gt; Label:\n        with self.edit_stylesheet() as ss:\n            if color is None:\n                ss.color.setValue(\"\")\n            else:\n                color = colors.get_color(color)\n                ss.color.setValue(color.name())\n        return self\n\n    def set_image(self, path: datatypes.PathType, width: int = 300) -&gt; Label:\n        self.setScaledContents(True)\n        self.set_alignment(horizontal=\"center\")\n        self.setText(\n            \"&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;\"\n            f\"&lt;img src={os.fspath(path)!r} width={str(width)!r}/&gt;\"\n            \"&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\n        )\n        return self\n\n    @classmethod\n    def image_from_path(\n        cls, path: datatypes.PathType, parent: QtWidgets.QWidget | None = None\n    ) -&gt; Label:\n        pixmap = gui.Pixmap.from_file(path)\n        label = cls(parent=parent)\n        label.setPixmap(pixmap)\n        label.resize(pixmap.width(), pixmap.height())\n        return label\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_format","title":"<code>get_text_format() -&gt; TextFormatStr</code>","text":"<p>Return current text format.</p> <p>Returns:</p> Type Description <code>TextFormatStr</code> <p>text format</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def get_text_format(self) -&gt; TextFormatStr:\n\"\"\"Return current text format.\n\n    Returns:\n        text format\n    \"\"\"\n    return TEXT_FORMAT.inverse[self.textFormat()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_interaction","title":"<code>get_text_interaction() -&gt; list[TextInteractionStr]</code>","text":"<p>Return current text interaction mode.</p> <p>Returns:</p> Type Description <code>list[TextInteractionStr]</code> <p>list of text interaction modes</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def get_text_interaction(self) -&gt; list[TextInteractionStr]:\n\"\"\"Return current text interaction mode.\n\n    Returns:\n        list of text interaction modes\n    \"\"\"\n    return TEXT_INTERACTION.get_list(self.textInteractionFlags())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_alignment","title":"<code>set_alignment(horizontal: constants.HorizontalAlignmentStr | None = None, vertical: constants.VerticalAlignmentStr | None = None)</code>","text":"<p>Set the alignment of the label's contents.</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_alignment(\n    self,\n    horizontal: constants.HorizontalAlignmentStr | None = None,\n    vertical: constants.VerticalAlignmentStr | None = None,\n):\n\"\"\"Set the alignment of the label's contents.\"\"\"\n    match horizontal, vertical:\n        case None, None:\n            return self\n        case None, _:\n            flag = constants.V_ALIGNMENT[vertical]\n        case _, None:\n            flag = constants.H_ALIGNMENT[horizontal]\n        case _, _:\n            flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n    self.setAlignment(flag)\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_indent","title":"<code>set_indent(indent: int) -&gt; Label</code>","text":"<p>Set the label's text indent in pixels.</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_indent(self, indent: int) -&gt; Label:\n\"\"\"Set the label's text indent in pixels.\"\"\"\n    self.setIndent(indent)\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text","title":"<code>set_text(text: str) -&gt; Label</code>","text":"<p>Set the label's text.</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_text(self, text: str) -&gt; Label:\n\"\"\"Set the label's text.\"\"\"\n    self.setText(text)\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_format","title":"<code>set_text_format(text_format: TextFormatStr) -&gt; Label</code>","text":"<p>Set the text format.</p> <p>Parameters:</p> Name Type Description Default <code>text_format</code> <code>TextFormatStr</code> <p>text format to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>text format does not exist</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_text_format(self, text_format: TextFormatStr) -&gt; Label:\n\"\"\"Set the text format.\n\n    Args:\n        text_format: text format to use\n\n    Raises:\n        InvalidParamError: text format does not exist\n    \"\"\"\n    if text_format not in TEXT_FORMAT:\n        raise InvalidParamError(text_format, TEXT_FORMAT)\n    self.setTextFormat(TEXT_FORMAT[text_format])\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_interaction","title":"<code>set_text_interaction(*types: TextInteractionStr) -&gt; Label</code>","text":"<p>Set the text interaction mode.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>TextInteractionStr</code> <p>text interaction mode to use</p> <code>()</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>text interaction mode does not exist</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_text_interaction(self, *types: TextInteractionStr) -&gt; Label:\n\"\"\"Set the text interaction mode.\n\n    Args:\n        types: text interaction mode to use\n\n    Raises:\n        InvalidParamError: text interaction mode does not exist\n    \"\"\"\n    for item in types:\n        if item not in TEXT_INTERACTION:\n            raise InvalidParamError(item, TEXT_INTERACTION)\n    flags = helpers.merge_flags(types, TEXT_INTERACTION)\n    self.setTextInteractionFlags(flags)\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_weight","title":"<code>set_weight(weight: gui.font.WeightStr) -&gt; Label</code>","text":"<p>Set the font weight.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>gui.font.WeightStr</code> <p>font weight</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid font weight</p> Source code in <code>prettyqt\\widgets\\label.py</code> <pre><code>def set_weight(self, weight: gui.font.WeightStr) -&gt; Label:\n\"\"\"Set the font weight.\n\n    Args:\n        weight: font weight\n\n    Raises:\n        InvalidParamError: invalid font weight\n    \"\"\"\n    if weight not in gui.font.WEIGHT:\n        raise InvalidParamError(weight, gui.font.WEIGHT)\n    font = self.font()\n    font.setWeight(gui.font.WEIGHT[weight])\n    self.setFont(font)\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.LayoutItemMixin","title":"<code>LayoutItemMixin</code>","text":"Source code in <code>prettyqt\\widgets\\layoutitem.py</code> <pre><code>class LayoutItemMixin:\n    def __bool__(self):\n        return not self.isEmpty()\n\n    def set_alignment(self, alignment: constants.AlignmentStr):\n\"\"\"Set the alignment of the layout.\n\n        Args:\n            alignment: alignment for the layout\n\n        Raises:\n            InvalidParamError: alignment does not exist\n        \"\"\"\n        if alignment not in constants.ALIGNMENTS:\n            raise InvalidParamError(alignment, constants.ALIGNMENTS)\n        self.setAlignment(constants.ALIGNMENTS[alignment])\n\n    def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n\n        Returns:\n            alignment\n        \"\"\"\n        return constants.ALIGNMENTS.inverse[self.alignment()]\n\n    def get_item(\n        self,\n    ) -&gt; QtWidgets.QWidget | QtWidgets.QLayout | QtWidgets.QSpacerItem | None:\n        if content := self.widget():\n            return content\n        if content := self.layout():\n            return content\n        return content if (content := self.spacerItem()) else None\n\n    def get_control_types(self) -&gt; list[widgets.sizepolicy.ControlTypeStr]:\n        return widgets.sizepolicy.CONTROL_TYPE.get_list(self.controlTypes())\n\n    def get_expanding_directions(self) -&gt; list[constants.OrientationStr]:\n        return constants.ORIENTATION.get_list(self.expandingDirections())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layoutitem.LayoutItemMixin.get_alignment","title":"<code>get_alignment() -&gt; constants.AlignmentStr</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.AlignmentStr</code> <p>alignment</p> Source code in <code>prettyqt\\widgets\\layoutitem.py</code> <pre><code>def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n\n    Returns:\n        alignment\n    \"\"\"\n    return constants.ALIGNMENTS.inverse[self.alignment()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layoutitem.LayoutItemMixin.set_alignment","title":"<code>set_alignment(alignment: constants.AlignmentStr)</code>","text":"<p>Set the alignment of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr</code> <p>alignment for the layout</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>alignment does not exist</p> Source code in <code>prettyqt\\widgets\\layoutitem.py</code> <pre><code>def set_alignment(self, alignment: constants.AlignmentStr):\n\"\"\"Set the alignment of the layout.\n\n    Args:\n        alignment: alignment for the layout\n\n    Raises:\n        InvalidParamError: alignment does not exist\n    \"\"\"\n    if alignment not in constants.ALIGNMENTS:\n        raise InvalidParamError(alignment, constants.ALIGNMENTS)\n    self.setAlignment(constants.ALIGNMENTS[alignment])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.LayoutMixin","title":"<code>LayoutMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>widgets.LayoutItemMixin</code></p> Source code in <code>prettyqt\\widgets\\layout.py</code> <pre><code>class LayoutMixin(core.ObjectMixin, widgets.LayoutItemMixin):\n    def __getitem__(\n        self, index: str | int\n    ) -&gt; QtWidgets.QWidget | QtWidgets.QLayout | None:\n        if isinstance(index, int):\n            item = self.itemAt(index)\n            widget = item.widget()\n            if widget is None:\n                widget = item.layout()\n        elif isinstance(index, str):\n            return self.find_child(typ=QtCore.QObject, name=index)\n        return widget\n\n    def __delitem__(self, index: int):\n        item = self.itemAt(index)\n        self.removeItem(item)\n\n    def __len__(self) -&gt; int:\n        return self.count()\n\n    def __repr__(self):\n        return get_repr(self)\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QWidget | QtWidgets.QLayout | None]:\n        return iter(self[i] for i in range(self.count()))\n\n    def __contains__(self, item: QtWidgets.QWidget | QtWidgets.QLayoutItem):\n        return self.indexOf(item) &gt;= 0\n\n    def serialize_fields(self):\n        return dict(\n            size_mode=self.get_size_mode(),\n            spacing=self.spacing(),\n            enabled=self.isEnabled(),\n        )\n\n    def get_children(self) -&gt; list[QtWidgets.QWidget | QtWidgets.QLayout]:\n        return list(self)\n\n    def set_margin(self, margin: int):\n        self.setContentsMargins(margin, margin, margin, margin)\n\n    def set_spacing(self, pixels: int):\n        self.setSpacing(pixels)\n\n    @deprecated(reason=\"Use set_size_constraint instead\")\n    def set_size_mode(self, mode: SizeConstraintStr):\n        self.set_size_constraint(mode)\n\n    def set_size_constraint(self, mode: SizeConstraintStr):\n\"\"\"Set the size mode of the layout.\n\n        Args:\n            mode: size mode for the layout\n\n        Raises:\n            InvalidParamError: size mode does not exist\n        \"\"\"\n        if mode not in SIZE_CONSTRAINT:\n            raise InvalidParamError(mode, SIZE_CONSTRAINT)\n        self.setSizeConstraint(SIZE_CONSTRAINT[mode])\n\n    @deprecated(reason=\"Use set_size_constraint instead\")\n    def get_size_mode(self) -&gt; SizeConstraintStr:\n        return self.get_size_constraint()\n\n    def get_size_constraint(self) -&gt; SizeConstraintStr:\n\"\"\"Return current size mode.\n\n        Returns:\n            size mode\n        \"\"\"\n        return SIZE_CONSTRAINT.inverse[self.sizeConstraint()]\n\n    def set_alignment(\n        self,\n        alignment: constants.AlignmentStr,\n        item: QtWidgets.QWidget | QtWidgets.QLayout | None = None,\n    ) -&gt; bool:\n\"\"\"Set the alignment for widget / layout to alignment.\n\n        Returns true if w is found in this layout (not including child layouts).\n\n        Args:\n            alignment: alignment for the layout\n            item: set alignment for specific child only\n\n        Raises:\n            InvalidParamError: alignment does not exist\n        \"\"\"\n        if alignment not in constants.ALIGNMENTS:\n            raise InvalidParamError(alignment, constants.ALIGNMENTS)\n        if item is not None:\n            return self.setAlignment(item, constants.ALIGNMENTS[alignment])\n        else:\n            return self.setAlignment(constants.ALIGNMENTS[alignment])\n\n    def add_widget(self, widget: QtWidgets.QWidget):\n        self.addWidget(widget)\n\n    def add(self, *items: QtWidgets.QWidget | QtWidgets.QLayout):\n        for i in items:\n            match i:\n                case QtWidgets.QWidget():\n                    self.addWidget(i)\n                case QtWidgets.QLayout():\n                    w = widgets.Widget()\n                    w.set_layout(i)\n                    self.addWidget(w)\n                case _:\n                    raise TypeError(\"add_item only supports widgets and layouts\")\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layout.LayoutMixin.get_size_constraint","title":"<code>get_size_constraint() -&gt; SizeConstraintStr</code>","text":"<p>Return current size mode.</p> <p>Returns:</p> Type Description <code>SizeConstraintStr</code> <p>size mode</p> Source code in <code>prettyqt\\widgets\\layout.py</code> <pre><code>def get_size_constraint(self) -&gt; SizeConstraintStr:\n\"\"\"Return current size mode.\n\n    Returns:\n        size mode\n    \"\"\"\n    return SIZE_CONSTRAINT.inverse[self.sizeConstraint()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layout.LayoutMixin.set_alignment","title":"<code>set_alignment(alignment: constants.AlignmentStr, item: QtWidgets.QWidget | QtWidgets.QLayout | None = None) -&gt; bool</code>","text":"<p>Set the alignment for widget / layout to alignment.</p> <p>Returns true if w is found in this layout (not including child layouts).</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr</code> <p>alignment for the layout</p> required <code>item</code> <code>QtWidgets.QWidget | QtWidgets.QLayout | None</code> <p>set alignment for specific child only</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>alignment does not exist</p> Source code in <code>prettyqt\\widgets\\layout.py</code> <pre><code>def set_alignment(\n    self,\n    alignment: constants.AlignmentStr,\n    item: QtWidgets.QWidget | QtWidgets.QLayout | None = None,\n) -&gt; bool:\n\"\"\"Set the alignment for widget / layout to alignment.\n\n    Returns true if w is found in this layout (not including child layouts).\n\n    Args:\n        alignment: alignment for the layout\n        item: set alignment for specific child only\n\n    Raises:\n        InvalidParamError: alignment does not exist\n    \"\"\"\n    if alignment not in constants.ALIGNMENTS:\n        raise InvalidParamError(alignment, constants.ALIGNMENTS)\n    if item is not None:\n        return self.setAlignment(item, constants.ALIGNMENTS[alignment])\n    else:\n        return self.setAlignment(constants.ALIGNMENTS[alignment])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layout.LayoutMixin.set_size_constraint","title":"<code>set_size_constraint(mode: SizeConstraintStr)</code>","text":"<p>Set the size mode of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SizeConstraintStr</code> <p>size mode for the layout</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>size mode does not exist</p> Source code in <code>prettyqt\\widgets\\layout.py</code> <pre><code>def set_size_constraint(self, mode: SizeConstraintStr):\n\"\"\"Set the size mode of the layout.\n\n    Args:\n        mode: size mode for the layout\n\n    Raises:\n        InvalidParamError: size mode does not exist\n    \"\"\"\n    if mode not in SIZE_CONSTRAINT:\n        raise InvalidParamError(mode, SIZE_CONSTRAINT)\n    self.setSizeConstraint(SIZE_CONSTRAINT[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.LineEdit","title":"<code>LineEdit</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QLineEdit</code></p> Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>class LineEdit(widgets.WidgetMixin, QtWidgets.QLineEdit):\n    value_changed = core.Signal(str)\n\n    def __init__(\n        self,\n        default_value: str = \"\",\n        read_only: bool = False,\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        super().__init__(default_value, parent)\n        self.textChanged.connect(self._set_validation_color)\n        self.textChanged.connect(self.value_changed)\n        self.set_read_only(read_only)\n\n    def __repr__(self):\n        return get_repr(self, self.text())\n\n    def __add__(self, other: str):\n        self.append_text(other)\n        return self\n\n    def font(self) -&gt; gui.Font:\n        return gui.Font(super().font())\n\n    def append_text(self, text: str):\n        self.set_text(self.text() + text)\n\n    def set_text(self, text: str):\n        self.setText(text)\n\n    def set_read_only(self, value: bool = True):\n\"\"\"Set text to read-only.\n\n        Args:\n            value: True, for read-only, otherwise False\n        \"\"\"\n        self.setReadOnly(value)\n\n    def set_regex_validator(self, regex: str, flags=0) -&gt; gui.RegularExpressionValidator:\n        validator = gui.RegularExpressionValidator(self)\n        validator.set_regex(regex, flags)\n        self.set_validator(validator)\n        return validator\n\n    def set_range(self, lower: int | None, upper: int | None):\n        val = gui.IntValidator()\n        val.set_range(lower, upper)\n        self.set_validator(val)\n\n    def set_validator(self, validator: gui.Validator):\n        self.setValidator(validator)\n        self._set_validation_color()\n\n    def set_input_mask(self, mask: str):\n        match mask:\n            case \"ip_address\":\n                mask = \"000.000.000.000;_\"\n            case \"mac_address\":\n                mask = \"HH:HH:HH:HH:HH:HH;_\"\n            case \"iso_date\":\n                mask = \"0000-00-00\"\n        self.setInputMask(mask)\n\n    def _set_validation_color(self, state: bool = True):\n        color = None if self.is_valid() else \"orange\"\n        self.set_background_color(color)\n\n    def set_echo_mode(self, mode: EchoModeStr):\n\"\"\"Set echo mode.\n\n        Args:\n            mode: echo mode to use\n\n        Raises:\n            InvalidParamError: invalid echo mode\n        \"\"\"\n        if mode not in ECHO_MODE:\n            raise InvalidParamError(mode, ECHO_MODE)\n        self.setEchoMode(ECHO_MODE[mode])\n\n    def get_echo_mode(self) -&gt; EchoModeStr:\n\"\"\"Return echo mode.\n\n        Returns:\n            echo mode\n        \"\"\"\n        return ECHO_MODE.inverse[self.echoMode()]\n\n    def set_cursor_move_style(self, style: constants.CursorMoveStyleStr):\n\"\"\"Set cursor move style.\n\n        Args:\n            style: cursor move style to use\n\n        Raises:\n            InvalidParamError: invalid cursor move style\n        \"\"\"\n        if style not in constants.CURSOR_MOVE_STYLE:\n            raise InvalidParamError(style, constants.CURSOR_MOVE_STYLE)\n        self.setCursorMoveStyle(constants.CURSOR_MOVE_STYLE[style])\n\n    def get_cursor_move_style(self) -&gt; constants.CursorMoveStyleStr:\n\"\"\"Return cursor move style.\n\n        Returns:\n            cursor move style\n        \"\"\"\n        return constants.CURSOR_MOVE_STYLE.inverse[self.cursorMoveStyle()]\n\n    def add_action(\n        self, action: QtWidgets.QAction, position: ActionPositionStr = \"trailing\"\n    ):\n        self.addAction(action, ACTION_POSITION[position])\n\n    def set_value(self, value: str):\n        self.setText(value)\n\n    def get_value(self) -&gt; str:\n        return self.text()\n\n    def is_valid(self) -&gt; bool:\n        return self.hasAcceptableInput()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_cursor_move_style","title":"<code>get_cursor_move_style() -&gt; constants.CursorMoveStyleStr</code>","text":"<p>Return cursor move style.</p> <p>Returns:</p> Type Description <code>constants.CursorMoveStyleStr</code> <p>cursor move style</p> Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>def get_cursor_move_style(self) -&gt; constants.CursorMoveStyleStr:\n\"\"\"Return cursor move style.\n\n    Returns:\n        cursor move style\n    \"\"\"\n    return constants.CURSOR_MOVE_STYLE.inverse[self.cursorMoveStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_echo_mode","title":"<code>get_echo_mode() -&gt; EchoModeStr</code>","text":"<p>Return echo mode.</p> <p>Returns:</p> Type Description <code>EchoModeStr</code> <p>echo mode</p> Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>def get_echo_mode(self) -&gt; EchoModeStr:\n\"\"\"Return echo mode.\n\n    Returns:\n        echo mode\n    \"\"\"\n    return ECHO_MODE.inverse[self.echoMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_cursor_move_style","title":"<code>set_cursor_move_style(style: constants.CursorMoveStyleStr)</code>","text":"<p>Set cursor move style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.CursorMoveStyleStr</code> <p>cursor move style to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid cursor move style</p> Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>def set_cursor_move_style(self, style: constants.CursorMoveStyleStr):\n\"\"\"Set cursor move style.\n\n    Args:\n        style: cursor move style to use\n\n    Raises:\n        InvalidParamError: invalid cursor move style\n    \"\"\"\n    if style not in constants.CURSOR_MOVE_STYLE:\n        raise InvalidParamError(style, constants.CURSOR_MOVE_STYLE)\n    self.setCursorMoveStyle(constants.CURSOR_MOVE_STYLE[style])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_echo_mode","title":"<code>set_echo_mode(mode: EchoModeStr)</code>","text":"<p>Set echo mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>EchoModeStr</code> <p>echo mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid echo mode</p> Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>def set_echo_mode(self, mode: EchoModeStr):\n\"\"\"Set echo mode.\n\n    Args:\n        mode: echo mode to use\n\n    Raises:\n        InvalidParamError: invalid echo mode\n    \"\"\"\n    if mode not in ECHO_MODE:\n        raise InvalidParamError(mode, ECHO_MODE)\n    self.setEchoMode(ECHO_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_read_only","title":"<code>set_read_only(value: bool = True)</code>","text":"<p>Set text to read-only.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True, for read-only, otherwise False</p> <code>True</code> Source code in <code>prettyqt\\widgets\\lineedit.py</code> <pre><code>def set_read_only(self, value: bool = True):\n\"\"\"Set text to read-only.\n\n    Args:\n        value: True, for read-only, otherwise False\n    \"\"\"\n    self.setReadOnly(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ListViewMixin","title":"<code>ListViewMixin</code>","text":"<p>         Bases: <code>widgets.AbstractItemViewMixin</code></p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>class ListViewMixin(widgets.AbstractItemViewMixin):\n    def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode.\n\n        Args:\n            mode: view mode to use\n\n        Raises:\n            InvalidParamError: invalid view mode\n        \"\"\"\n        if mode not in VIEW_MODE:\n            raise InvalidParamError(mode, VIEW_MODE)\n        self.setViewMode(VIEW_MODE[mode])\n\n    def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n\n        Returns:\n            view mode\n        \"\"\"\n        return VIEW_MODE.inverse[self.viewMode()]\n\n    def set_resize_mode(self, mode: ResizeModeStr):\n\"\"\"Set resize mode.\n\n        Args:\n            mode: resize mode to use\n\n        Raises:\n            InvalidParamError: invalid resize mode\n        \"\"\"\n        if mode not in RESIZE_MODE:\n            raise InvalidParamError(mode, RESIZE_MODE)\n        self.setResizeMode(RESIZE_MODE[mode])\n\n    def get_resize_mode(self) -&gt; ResizeModeStr:\n\"\"\"Return resize mode.\n\n        Returns:\n            resize mode\n        \"\"\"\n        return RESIZE_MODE.inverse[self.resizeMode()]\n\n    def set_layout_mode(self, mode: LayoutModeStr):\n\"\"\"Set layout mode.\n\n        Args:\n            mode: layout mode to use\n\n        Raises:\n            InvalidParamError: invalid layout mode\n        \"\"\"\n        if mode not in LAYOUT_MODE:\n            raise InvalidParamError(mode, LAYOUT_MODE)\n        self.setLayoutMode(LAYOUT_MODE[mode])\n\n    def get_layout_mode(self) -&gt; LayoutModeStr:\n\"\"\"Return layout mode.\n\n        Returns:\n            layout mode\n        \"\"\"\n        return LAYOUT_MODE.inverse[self.layoutMode()]\n\n    def set_movement(self, mode: MovementStr):\n\"\"\"Set movement mode.\n\n        Args:\n            mode: movement mode to use\n\n        Raises:\n            InvalidParamError: invalid movement mode\n        \"\"\"\n        if mode not in MOVEMENT:\n            raise InvalidParamError(mode, MOVEMENT)\n        self.setMovement(MOVEMENT[mode])\n\n    def get_movement(self) -&gt; MovementStr:\n\"\"\"Return movement mode.\n\n        Returns:\n            movement mode\n        \"\"\"\n        return MOVEMENT.inverse[self.movement()]\n\n    def set_flow(self, mode: FlowStr):\n\"\"\"Set flow mode.\n\n        Args:\n            mode: flow mode to use\n\n        Raises:\n            InvalidParamError: invalid flow mode\n        \"\"\"\n        if mode not in FLOW:\n            raise InvalidParamError(mode, FLOW)\n        self.setFlow(FLOW[mode])\n\n    def get_flow(self) -&gt; FlowStr:\n\"\"\"Return flow mode.\n\n        Returns:\n            flow mode\n        \"\"\"\n        return FLOW.inverse[self.flow()]\n\n    def set_grid_size(self, size: QtCore.QSize | tuple[int, int]):\n        if isinstance(size, tuple):\n            size = QtCore.QSize(*size)\n        self.setGridSize(size)\n\n    def get_grid_size(self) -&gt; core.Size:\n        return core.Size(self.gridSize())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_flow","title":"<code>get_flow() -&gt; FlowStr</code>","text":"<p>Return flow mode.</p> <p>Returns:</p> Type Description <code>FlowStr</code> <p>flow mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def get_flow(self) -&gt; FlowStr:\n\"\"\"Return flow mode.\n\n    Returns:\n        flow mode\n    \"\"\"\n    return FLOW.inverse[self.flow()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_layout_mode","title":"<code>get_layout_mode() -&gt; LayoutModeStr</code>","text":"<p>Return layout mode.</p> <p>Returns:</p> Type Description <code>LayoutModeStr</code> <p>layout mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def get_layout_mode(self) -&gt; LayoutModeStr:\n\"\"\"Return layout mode.\n\n    Returns:\n        layout mode\n    \"\"\"\n    return LAYOUT_MODE.inverse[self.layoutMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_movement","title":"<code>get_movement() -&gt; MovementStr</code>","text":"<p>Return movement mode.</p> <p>Returns:</p> Type Description <code>MovementStr</code> <p>movement mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def get_movement(self) -&gt; MovementStr:\n\"\"\"Return movement mode.\n\n    Returns:\n        movement mode\n    \"\"\"\n    return MOVEMENT.inverse[self.movement()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_resize_mode","title":"<code>get_resize_mode() -&gt; ResizeModeStr</code>","text":"<p>Return resize mode.</p> <p>Returns:</p> Type Description <code>ResizeModeStr</code> <p>resize mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def get_resize_mode(self) -&gt; ResizeModeStr:\n\"\"\"Return resize mode.\n\n    Returns:\n        resize mode\n    \"\"\"\n    return RESIZE_MODE.inverse[self.resizeMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_view_mode","title":"<code>get_view_mode() -&gt; ViewModeStr</code>","text":"<p>Return view mode.</p> <p>Returns:</p> Type Description <code>ViewModeStr</code> <p>view mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n\n    Returns:\n        view mode\n    \"\"\"\n    return VIEW_MODE.inverse[self.viewMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_flow","title":"<code>set_flow(mode: FlowStr)</code>","text":"<p>Set flow mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>FlowStr</code> <p>flow mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid flow mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def set_flow(self, mode: FlowStr):\n\"\"\"Set flow mode.\n\n    Args:\n        mode: flow mode to use\n\n    Raises:\n        InvalidParamError: invalid flow mode\n    \"\"\"\n    if mode not in FLOW:\n        raise InvalidParamError(mode, FLOW)\n    self.setFlow(FLOW[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_layout_mode","title":"<code>set_layout_mode(mode: LayoutModeStr)</code>","text":"<p>Set layout mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>LayoutModeStr</code> <p>layout mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid layout mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def set_layout_mode(self, mode: LayoutModeStr):\n\"\"\"Set layout mode.\n\n    Args:\n        mode: layout mode to use\n\n    Raises:\n        InvalidParamError: invalid layout mode\n    \"\"\"\n    if mode not in LAYOUT_MODE:\n        raise InvalidParamError(mode, LAYOUT_MODE)\n    self.setLayoutMode(LAYOUT_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_movement","title":"<code>set_movement(mode: MovementStr)</code>","text":"<p>Set movement mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>MovementStr</code> <p>movement mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid movement mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def set_movement(self, mode: MovementStr):\n\"\"\"Set movement mode.\n\n    Args:\n        mode: movement mode to use\n\n    Raises:\n        InvalidParamError: invalid movement mode\n    \"\"\"\n    if mode not in MOVEMENT:\n        raise InvalidParamError(mode, MOVEMENT)\n    self.setMovement(MOVEMENT[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_resize_mode","title":"<code>set_resize_mode(mode: ResizeModeStr)</code>","text":"<p>Set resize mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ResizeModeStr</code> <p>resize mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid resize mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def set_resize_mode(self, mode: ResizeModeStr):\n\"\"\"Set resize mode.\n\n    Args:\n        mode: resize mode to use\n\n    Raises:\n        InvalidParamError: invalid resize mode\n    \"\"\"\n    if mode not in RESIZE_MODE:\n        raise InvalidParamError(mode, RESIZE_MODE)\n    self.setResizeMode(RESIZE_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_view_mode","title":"<code>set_view_mode(mode: ViewModeStr)</code>","text":"<p>Set view mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewModeStr</code> <p>view mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid view mode</p> Source code in <code>prettyqt\\widgets\\listview.py</code> <pre><code>def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode.\n\n    Args:\n        mode: view mode to use\n\n    Raises:\n        InvalidParamError: invalid view mode\n    \"\"\"\n    if mode not in VIEW_MODE:\n        raise InvalidParamError(mode, VIEW_MODE)\n    self.setViewMode(VIEW_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ListWidgetItem","title":"<code>ListWidgetItem</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtWidgets.QListWidgetItem</code></p> Source code in <code>prettyqt\\widgets\\listwidgetitem.py</code> <pre><code>class ListWidgetItem(serializemixin.SerializeMixin, QtWidgets.QListWidgetItem):\n    def __repr__(self):\n        return get_repr(self, self.icon(), self.text())\n\n    def __setitem__(self, index: int, value):\n        self.setData(index, value)\n\n    def __getitem__(self, index: int):\n        return self.data(index)\n\n    def serialize_fields(self):\n        return dict(\n            text=self.text(),\n            tool_tip=self.toolTip(),\n            status_tip=self.statusTip(),\n            checkstate=self.get_checkstate(),\n            icon=self.get_icon(),\n            data=self.data(constants.USER_ROLE),  # type: ignore\n        )\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n        Args:\n            state: checkstate to use\n\n        Raises:\n            InvalidParamError: invalid checkstate\n        \"\"\"\n        if state not in constants.STATE:\n            raise InvalidParamError(state, constants.STATE)\n        self.setCheckState(constants.STATE[state])\n\n    def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n        Returns:\n            checkstate\n        \"\"\"\n        return constants.STATE.inverse[self.checkState()]\n\n    def get_background(self) -&gt; gui.Brush:\n        return gui.Brush(self.background())\n\n    def get_foreground(self) -&gt; gui.Brush:\n        return gui.Brush(self.foreground())\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        return None if icon.isNull() else gui.Icon(icon)\n\n    def set_data(self, role: str, data):\n        role_id = constants.ITEM_DATA_ROLE[role]\n        self.setData(role_id, data)\n\n    def set_size_hint(self, hint: datatypes.SizeType):\n        if isinstance(hint, tuple):\n            hint = QtCore.QSize(*hint)\n        self.setSizeHint(hint)\n\n    def set_text_alignment(\n        self,\n        horizontal: constants.HorizontalAlignmentStr | None = None,\n        vertical: constants.VerticalAlignmentStr | None = None,\n    ):\n\"\"\"Set text alignment of the checkbox.\n\n        Args:\n            horizontal: horizontal text alignment to use\n            vertical: vertical text alignment to use\n\n        Raises:\n            InvalidParamError: invalid text alignment\n        \"\"\"\n        match horizontal, vertical:\n            case None, None:\n                return\n            case None, _:\n                flag = constants.V_ALIGNMENT[vertical]\n            case _, None:\n                flag = constants.H_ALIGNMENT[horizontal]\n            case _, _:\n                flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n        self.setTextAlignment(flag)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.get_checkstate","title":"<code>get_checkstate() -&gt; constants.StateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.StateStr</code> <p>checkstate</p> Source code in <code>prettyqt\\widgets\\listwidgetitem.py</code> <pre><code>def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n    Returns:\n        checkstate\n    \"\"\"\n    return constants.STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_checkstate","title":"<code>set_checkstate(state: constants.StateStr)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.StateStr</code> <p>checkstate to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid checkstate</p> Source code in <code>prettyqt\\widgets\\listwidgetitem.py</code> <pre><code>def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n    Args:\n        state: checkstate to use\n\n    Raises:\n        InvalidParamError: invalid checkstate\n    \"\"\"\n    if state not in constants.STATE:\n        raise InvalidParamError(state, constants.STATE)\n    self.setCheckState(constants.STATE[state])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\listwidgetitem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_text_alignment","title":"<code>set_text_alignment(horizontal: constants.HorizontalAlignmentStr | None = None, vertical: constants.VerticalAlignmentStr | None = None)</code>","text":"<p>Set text alignment of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>horizontal</code> <code>constants.HorizontalAlignmentStr | None</code> <p>horizontal text alignment to use</p> <code>None</code> <code>vertical</code> <code>constants.VerticalAlignmentStr | None</code> <p>vertical text alignment to use</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid text alignment</p> Source code in <code>prettyqt\\widgets\\listwidgetitem.py</code> <pre><code>def set_text_alignment(\n    self,\n    horizontal: constants.HorizontalAlignmentStr | None = None,\n    vertical: constants.VerticalAlignmentStr | None = None,\n):\n\"\"\"Set text alignment of the checkbox.\n\n    Args:\n        horizontal: horizontal text alignment to use\n        vertical: vertical text alignment to use\n\n    Raises:\n        InvalidParamError: invalid text alignment\n    \"\"\"\n    match horizontal, vertical:\n        case None, None:\n            return\n        case None, _:\n            flag = constants.V_ALIGNMENT[vertical]\n        case _, None:\n            flag = constants.H_ALIGNMENT[horizontal]\n        case _, _:\n            flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n    self.setTextAlignment(flag)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.MainWindow","title":"<code>MainWindow</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QMainWindow</code></p> <p>Class for our mainWindow.</p> <p>Includes all docks, a centralwidget and a toolbar</p> Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>class MainWindow(widgets.WidgetMixin, QtWidgets.QMainWindow):\n\"\"\"Class for our mainWindow.\n\n    Includes all docks, a centralwidget and a toolbar\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.setMenuBar(widgets.MenuBar())\n        self.setDockOptions(\n            self.DockOption.AllowTabbedDocks  # type: ignore\n            | self.DockOption.AllowNestedDocks\n            | self.DockOption.GroupedDragging\n            | self.DockOption.AnimatedDocks\n        )\n\n    def __getitem__(self, index: str) -&gt; QtWidgets.QWidget:\n        result = self.find_child(QtWidgets.QWidget, index)\n        if result is None:\n            raise KeyError(\"Widget not found\")\n        return result\n\n    def set_widget(self, widget: QtWidgets.QWidget | None):\n        if widget is None:\n            self.takeCentralWidget()\n        else:\n            self.setCentralWidget(widget)\n\n    def createPopupMenu(self) -&gt; widgets.Menu:\n        # qactions = self.createPopupMenu()\n        menu = widgets.Menu(parent=self)\n        for i, item in enumerate(self.get_docks()):\n            action = widgets.Action(text=item.windowTitle(), parent=self)\n            action.set_checkable(True)\n            action.set_checked(item.isVisible())\n            action.set_shortcut(f\"Ctrl+Shift+{i}\")\n            action.set_shortcut_context(\"application\")\n            action.toggled.connect(item.setVisible)\n            menu.add(action)\n        menu.add_separator()\n        for tb in self.get_toolbars():\n            action = widgets.Action(text=tb.windowTitle(), parent=self)\n            action.set_checkable(True)\n            action.toggled.connect(tb.setVisible)\n            action.set_checked(tb.isVisible())\n            menu.add(action)\n        return menu\n\n    def add_toolbar(\n        self, toolbar: QtWidgets.QToolBar, position: constants.ToolbarAreaStr = \"top\"\n    ):\n\"\"\"Adds a toolbar to the mainmenu at specified area.\n\n        Args:\n            toolbar: toolbar to use\n            position: position of the toolbar\n\n        Raises:\n            InvalidParamError: position does not exist\n        \"\"\"\n        if position not in constants.TOOLBAR_AREA:\n            raise InvalidParamError(position, constants.TOOLBAR_AREA)\n        self.addToolBar(constants.TOOLBAR_AREA[position], toolbar)\n\n    def add_toolbar_break(self, position: constants.ToolbarAreaStr = \"top\"):\n\"\"\"Adds a toolbar break to the given area behind the last item.\n\n        Args:\n            position: position of the toolbar\n\n        Raises:\n            InvalidParamError: position does not exist\n        \"\"\"\n        if position not in constants.TOOLBAR_AREA:\n            raise InvalidParamError(position, constants.TOOLBAR_AREA)\n        self.addToolBarBreak(constants.TOOLBAR_AREA[position])\n\n    def load_window_state(self, recursive: bool = False) -&gt; bool:\n        settings = core.Settings()\n        name = self.get_id()\n        geom = settings.get(f\"{name}.geometry\")\n        state = settings.get(f\"{name}.state\")\n        restored = False\n        if geom is not None and state is not None:\n            try:\n                logger.debug(f\"Loading window state for {self.windowTitle()!r}...\")\n                self.restoreGeometry(geom)\n                if isinstance(state, str):\n                    state = state.encode()\n                self.restoreState(state)\n                restored = True\n            except TypeError:\n                logger.error(\"Wrong type for window state. Probably Qt binding switch?\")\n        if recursive:\n            for window in self.find_children(MainWindow, recursive=True):\n                if window.get_id():\n                    window.load_window_state()\n        return restored\n\n    def save_window_state(self, recursive: bool = False):\n\"\"\"Save current window state as QSetting.\n\n        Args:\n            recursive (bool, optional): Description\n        \"\"\"\n        settings = core.Settings()\n        name = self.get_id()\n        logger.debug(f\"Saving window state for {self.windowTitle()!r}...\")\n        settings[f\"{name}.geometry\"] = self.saveGeometry()\n        settings[f\"{name}.state\"] = self.saveState()\n        if recursive:\n            for window in self.find_children(MainWindow, recursive=True):\n                if window.get_id():\n                    window.save_window_state()\n\n    def add_widget_as_dock(\n        self,\n        name: str,\n        title: str,\n        vertical: bool = True,\n        position: constants.DockPositionStr = \"left\",\n    ) -&gt; widgets.DockWidget:\n        dock_widget = widgets.DockWidget(self, name=name, title=title)\n        widget = widgets.Widget()\n        widget.set_id(f\"{name}.widget\")\n        layout = widgets.BoxLayout(\n            \"vertical\" if vertical else \"horizontal\", widget, margin=0\n        )\n        dock_widget.setWidget(widget)\n        self.add_dockwidget(dock_widget, position)\n        dock_widget.box = layout\n        return dock_widget\n\n    def add_dockwidget(\n        self,\n        dockwidget: QtWidgets.QDockWidget,\n        position: constants.DockPositionStr = \"left\",\n    ):\n        self.addDockWidget(constants.DOCK_POSITION[position], dockwidget)\n\n    def remove_dockwidgets(self, dockwidgets: Sequence[QtWidgets.QDockWidget]):\n        for i in dockwidgets:\n            self.removeDockWidget(i)\n\n    def show_blocking(self):\n        self.set_modality(\"application\")\n        self.show()\n\n    def get_docks(self) -&gt; list[QtWidgets.QDockWidget]:\n        return self.find_children(QtWidgets.QDockWidget, recursive=False)\n\n    def get_toolbars(self) -&gt; list[QtWidgets.QToolBar]:\n        return self.find_children(QtWidgets.QToolBar, recursive=False)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar","title":"<code>add_toolbar(toolbar: QtWidgets.QToolBar, position: constants.ToolbarAreaStr = 'top')</code>","text":"<p>Adds a toolbar to the mainmenu at specified area.</p> <p>Parameters:</p> Name Type Description Default <code>toolbar</code> <code>QtWidgets.QToolBar</code> <p>toolbar to use</p> required <code>position</code> <code>constants.ToolbarAreaStr</code> <p>position of the toolbar</p> <code>'top'</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>position does not exist</p> Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>def add_toolbar(\n    self, toolbar: QtWidgets.QToolBar, position: constants.ToolbarAreaStr = \"top\"\n):\n\"\"\"Adds a toolbar to the mainmenu at specified area.\n\n    Args:\n        toolbar: toolbar to use\n        position: position of the toolbar\n\n    Raises:\n        InvalidParamError: position does not exist\n    \"\"\"\n    if position not in constants.TOOLBAR_AREA:\n        raise InvalidParamError(position, constants.TOOLBAR_AREA)\n    self.addToolBar(constants.TOOLBAR_AREA[position], toolbar)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar_break","title":"<code>add_toolbar_break(position: constants.ToolbarAreaStr = 'top')</code>","text":"<p>Adds a toolbar break to the given area behind the last item.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>constants.ToolbarAreaStr</code> <p>position of the toolbar</p> <code>'top'</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>position does not exist</p> Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>def add_toolbar_break(self, position: constants.ToolbarAreaStr = \"top\"):\n\"\"\"Adds a toolbar break to the given area behind the last item.\n\n    Args:\n        position: position of the toolbar\n\n    Raises:\n        InvalidParamError: position does not exist\n    \"\"\"\n    if position not in constants.TOOLBAR_AREA:\n        raise InvalidParamError(position, constants.TOOLBAR_AREA)\n    self.addToolBarBreak(constants.TOOLBAR_AREA[position])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.save_window_state","title":"<code>save_window_state(recursive: bool = False)</code>","text":"<p>Save current window state as QSetting.</p> <p>Parameters:</p> Name Type Description Default <code>recursive</code> <code>bool</code> <p>Description</p> <code>False</code> Source code in <code>prettyqt\\widgets\\mainwindow.py</code> <pre><code>def save_window_state(self, recursive: bool = False):\n\"\"\"Save current window state as QSetting.\n\n    Args:\n        recursive (bool, optional): Description\n    \"\"\"\n    settings = core.Settings()\n    name = self.get_id()\n    logger.debug(f\"Saving window state for {self.windowTitle()!r}...\")\n    settings[f\"{name}.geometry\"] = self.saveGeometry()\n    settings[f\"{name}.state\"] = self.saveState()\n    if recursive:\n        for window in self.find_children(MainWindow, recursive=True):\n            if window.get_id():\n                window.save_window_state()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.MdiArea","title":"<code>MdiArea</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code>, <code>QtWidgets.QMdiArea</code></p> Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>class MdiArea(widgets.AbstractScrollAreaMixin, QtWidgets.QMdiArea):\n    def __add__(self, other: QtWidgets.QWidget):\n        self.add(other)\n        return self\n\n    def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode for the MDI area.\n\n        Args:\n            mode: view mode to use\n\n        Raises:\n            InvalidParamError: view mode does not exist\n        \"\"\"\n        if mode not in VIEW_MODE:\n            raise InvalidParamError(mode, VIEW_MODE)\n        self.setViewMode(VIEW_MODE[mode])\n\n    def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return current view mode.\n\n        Returns:\n            view mode\n        \"\"\"\n        return VIEW_MODE.inverse[self.viewMode()]\n\n    def set_window_order(self, mode: WindowOrderStr):\n\"\"\"Set the window order behaviour for the MDI area.\n\n        Args:\n            mode: window order behaviour to use\n\n        Raises:\n            InvalidParamError: window order mode not existing.\n        \"\"\"\n        if mode not in WINDOW_ORDER:\n            raise InvalidParamError(mode, WINDOW_ORDER)\n        self.setActivationOrder(WINDOW_ORDER[mode])\n\n    def get_window_order(self) -&gt; WindowOrderStr:\n\"\"\"Return current window order.\n\n        Returns:\n            view mode\n        \"\"\"\n        return WINDOW_ORDER.inverse[self.activationOrder()]\n\n    def set_tab_position(self, position: TabPositionStr):\n\"\"\"Set tab position for the MDI area.\n\n        Args:\n            position: tabs position to use\n\n        Raises:\n            InvalidParamError: tab position does not exist\n        \"\"\"\n        if position not in TAB_POSITION:\n            raise InvalidParamError(position, TAB_POSITION)\n        self.setTabPosition(TAB_POSITION[position])\n\n    def get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return current tab position.\n\n        Returns:\n            tab position\n        \"\"\"\n        return TAB_POSITION.inverse[self.tabPosition()]\n\n    def set_background(\n        self,\n        brush_or_color: datatypes.ColorAndBrushType,\n        pattern: constants.BrushStyleStr = \"solid\",\n    ):\n        if isinstance(brush_or_color, QtGui.QBrush):\n            brush = brush_or_color\n        else:\n            color = colors.get_color(brush_or_color)\n            brush = gui.Brush(color, constants.BRUSH_STYLE[pattern])\n        self.setBackground(brush)\n\n    def get_background(self) -&gt; gui.Brush:\n        return gui.Brush(self.background())\n\n    def add(self, *item: QtWidgets.QWidget):\n        for i in item:\n            if not isinstance(i, QtWidgets.QMdiSubWindow):\n                widget = widgets.MdiSubWindow()\n                widget.setWidget(i)\n                self.addSubWindow(widget)\n            else:\n                self.addSubWindow(i)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_tab_position","title":"<code>get_tab_position() -&gt; TabPositionStr</code>","text":"<p>Return current tab position.</p> <p>Returns:</p> Type Description <code>TabPositionStr</code> <p>tab position</p> Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return current tab position.\n\n    Returns:\n        tab position\n    \"\"\"\n    return TAB_POSITION.inverse[self.tabPosition()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_view_mode","title":"<code>get_view_mode() -&gt; ViewModeStr</code>","text":"<p>Return current view mode.</p> <p>Returns:</p> Type Description <code>ViewModeStr</code> <p>view mode</p> Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return current view mode.\n\n    Returns:\n        view mode\n    \"\"\"\n    return VIEW_MODE.inverse[self.viewMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_window_order","title":"<code>get_window_order() -&gt; WindowOrderStr</code>","text":"<p>Return current window order.</p> <p>Returns:</p> Type Description <code>WindowOrderStr</code> <p>view mode</p> Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def get_window_order(self) -&gt; WindowOrderStr:\n\"\"\"Return current window order.\n\n    Returns:\n        view mode\n    \"\"\"\n    return WINDOW_ORDER.inverse[self.activationOrder()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_tab_position","title":"<code>set_tab_position(position: TabPositionStr)</code>","text":"<p>Set tab position for the MDI area.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>TabPositionStr</code> <p>tabs position to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>tab position does not exist</p> Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def set_tab_position(self, position: TabPositionStr):\n\"\"\"Set tab position for the MDI area.\n\n    Args:\n        position: tabs position to use\n\n    Raises:\n        InvalidParamError: tab position does not exist\n    \"\"\"\n    if position not in TAB_POSITION:\n        raise InvalidParamError(position, TAB_POSITION)\n    self.setTabPosition(TAB_POSITION[position])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_view_mode","title":"<code>set_view_mode(mode: ViewModeStr)</code>","text":"<p>Set view mode for the MDI area.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewModeStr</code> <p>view mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>view mode does not exist</p> Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode for the MDI area.\n\n    Args:\n        mode: view mode to use\n\n    Raises:\n        InvalidParamError: view mode does not exist\n    \"\"\"\n    if mode not in VIEW_MODE:\n        raise InvalidParamError(mode, VIEW_MODE)\n    self.setViewMode(VIEW_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_window_order","title":"<code>set_window_order(mode: WindowOrderStr)</code>","text":"<p>Set the window order behaviour for the MDI area.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>WindowOrderStr</code> <p>window order behaviour to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>window order mode not existing.</p> Source code in <code>prettyqt\\widgets\\mdiarea.py</code> <pre><code>def set_window_order(self, mode: WindowOrderStr):\n\"\"\"Set the window order behaviour for the MDI area.\n\n    Args:\n        mode: window order behaviour to use\n\n    Raises:\n        InvalidParamError: window order mode not existing.\n    \"\"\"\n    if mode not in WINDOW_ORDER:\n        raise InvalidParamError(mode, WINDOW_ORDER)\n    self.setActivationOrder(WINDOW_ORDER[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.MessageBox","title":"<code>MessageBox</code>","text":"<p>         Bases: <code>widgets.DialogMixin</code>, <code>QtWidgets.QMessageBox</code></p> Source code in <code>prettyqt\\widgets\\messagebox.py</code> <pre><code>class MessageBox(widgets.DialogMixin, QtWidgets.QMessageBox):\n    def __init__(\n        self,\n        icon: datatypes.IconType | IconStr = None,\n        title: str = \"\",\n        text: str = \"\",\n        informative_text: str = \"\",\n        details: str = \"\",\n        buttons: list[ButtonStr] | None = None,\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        super().__init__(parent)\n        self.set_icon(icon)\n        self.setText(text)\n        self.setInformativeText(informative_text)\n        self.setWindowTitle(title)\n        self.setWindowFlags(\n            QtCore.Qt.WindowType.Dialog  # type: ignore\n            | QtCore.Qt.WindowType.WindowTitleHint\n            | QtCore.Qt.WindowType.CustomizeWindowHint\n        )\n        self.setDetailedText(details)\n        if isinstance(buttons, list):\n            for b in buttons:\n                self.add_button(b)\n\n    def serialize_fields(self):\n        return dict(\n            icon=self.get_icon(),\n            detailed_text=self.detailedText(),\n            icon_pixmap=self.get_icon_pixmap(),\n            informative_text=self.informativeText(),\n            text=self.text(),\n            text_format=self.get_text_format(),\n        )\n\n    @classmethod\n    def message(\n        cls,\n        text: str,\n        title: str = \"\",\n        icon: datatypes.IconType = None,\n        detail_text: str | None = None,\n    ) -&gt; str:\n        m = cls(\"none\", title, text)\n        m.set_icon(icon)\n        if detail_text is not None:\n            m.setDetailedText(detail_text)\n        return m.show_blocking()\n\n    @classmethod\n    def show_exception(cls, exception: Exception):\n        exctype, value = sys.exc_info()[:2]\n        tb = traceback.format_exc()\n        dlg = cls(text=str(value), title=str(exctype), icon=\"critical\", details=tb)\n        dlg.show_blocking()\n\n    def set_icon(self, icon: datatypes.IconType | IconStr):\n        if icon in ICONS:\n            self.setIcon(ICONS[icon])\n        else:\n            ico = iconprovider.get_icon(icon)\n            self.setIconPixmap(ico.get_pixmap(size=64))\n\n    def show_blocking(self) -&gt; ButtonStr:\n        return BUTTONS.inverse[self.main_loop()]\n\n    def get_icon_pixmap(self) -&gt; gui.Pixmap | None:\n        pix = self.iconPixmap()\n        return None if pix.isNull() else gui.Pixmap(pix)\n\n    def get_standard_buttons(self) -&gt; list[ButtonStr]:\n        return BUTTONS.get_list(self.standardButtons())\n\n    def add_button(self, button: ButtonStr) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n\n        Args:\n            button: button to add\n\n        Returns:\n            created button\n\n        Raises:\n            InvalidParamError: Button type not available\n        \"\"\"\n        if button not in BUTTONS:\n            raise InvalidParamError(button, BUTTONS)\n        return self.addButton(BUTTONS[button])\n\n    # @classmethod\n    # def show_exception(cls, exception):\n    #     header = str(exception[0])\n    #     error_text = str(exception[1])\n    #     widgets.MessageBox.message(error_text, header, \"mdi.exclamation\")\n\n    def set_text_format(self, text_format: TextFormatStr):\n\"\"\"Set the text format.\n\n        Args:\n            text_format: text format to use\n\n        Raises:\n            InvalidParamError: text format does not exist\n        \"\"\"\n        if text_format not in TEXT_FORMAT:\n            raise InvalidParamError(text_format, TEXT_FORMAT)\n        self.setTextFormat(TEXT_FORMAT[text_format])\n\n    def get_text_format(self) -&gt; TextFormatStr:\n\"\"\"Return current text format.\n\n        Returns:\n            text format\n        \"\"\"\n        return TEXT_FORMAT.inverse[self.textFormat()]\n\n    def set_escape_button(self, button: ButtonStr | QtWidgets.QAbstractButton):\n        if isinstance(button, QtWidgets.QAbstractButton):\n            self.setEscapeButton(button)\n        else:\n            self.setEscapeButton(BUTTONS[button])\n\n    def set_default_button(self, button: ButtonStr | QtWidgets.QPushButton):\n        if isinstance(button, QtWidgets.QPushButton):\n            self.setDefaultButton(button)\n        else:\n            self.setDefaultButton(BUTTONS[button])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.add_button","title":"<code>add_button(button: ButtonStr) -&gt; QtWidgets.QPushButton</code>","text":"<p>Add a default button.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>ButtonStr</code> <p>button to add</p> required <p>Returns:</p> Type Description <code>QtWidgets.QPushButton</code> <p>created button</p> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>Button type not available</p> Source code in <code>prettyqt\\widgets\\messagebox.py</code> <pre><code>def add_button(self, button: ButtonStr) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n\n    Args:\n        button: button to add\n\n    Returns:\n        created button\n\n    Raises:\n        InvalidParamError: Button type not available\n    \"\"\"\n    if button not in BUTTONS:\n        raise InvalidParamError(button, BUTTONS)\n    return self.addButton(BUTTONS[button])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.get_text_format","title":"<code>get_text_format() -&gt; TextFormatStr</code>","text":"<p>Return current text format.</p> <p>Returns:</p> Type Description <code>TextFormatStr</code> <p>text format</p> Source code in <code>prettyqt\\widgets\\messagebox.py</code> <pre><code>def get_text_format(self) -&gt; TextFormatStr:\n\"\"\"Return current text format.\n\n    Returns:\n        text format\n    \"\"\"\n    return TEXT_FORMAT.inverse[self.textFormat()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_text_format","title":"<code>set_text_format(text_format: TextFormatStr)</code>","text":"<p>Set the text format.</p> <p>Parameters:</p> Name Type Description Default <code>text_format</code> <code>TextFormatStr</code> <p>text format to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>text format does not exist</p> Source code in <code>prettyqt\\widgets\\messagebox.py</code> <pre><code>def set_text_format(self, text_format: TextFormatStr):\n\"\"\"Set the text format.\n\n    Args:\n        text_format: text format to use\n\n    Raises:\n        InvalidParamError: text format does not exist\n    \"\"\"\n    if text_format not in TEXT_FORMAT:\n        raise InvalidParamError(text_format, TEXT_FORMAT)\n    self.setTextFormat(TEXT_FORMAT[text_format])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.PlainTextEditMixin","title":"<code>PlainTextEditMixin</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code></p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>class PlainTextEditMixin(widgets.AbstractScrollAreaMixin):\n    value_changed = core.Signal()\n\n    def __init__(\n        self,\n        text: str = \"\",\n        parent: QtWidgets.QWidget | None = None,\n        read_only: bool = False,\n    ):\n        super().__init__(parent)\n        self._allow_wheel_zoom = False\n        self.validator: QtGui.QValidator | None = None\n        self.textChanged.connect(self._on_value_change)\n        self.set_read_only(read_only)\n        doc = gui.TextDocument(self)\n        layout = widgets.PlainTextDocumentLayout(doc)\n        doc.setDocumentLayout(layout)\n        self.setDocument(doc)\n        self.set_text(text)\n\n    def __add__(self, other: str):\n        self.append_text(other)\n        return self\n\n    def wheelEvent(self, event):\n\"\"\"Handle wheel event for zooming.\"\"\"\n        if not self._allow_wheel_zoom:\n            return None\n        if event.modifiers() &amp; constants.CTRL_MOD:\n            self.zoomIn() if event.angleDelta().y() &gt; 0 else self.zoomOut()\n        else:\n            super().wheelEvent(event)\n\n    def allow_wheel_zoom(self, do_zoom: bool = True):\n        self._allow_wheel_zoom = do_zoom\n\n    def goto_line(self, line_no: int):\n        doc = self.document()\n        lines = doc.blockCount()\n        assert 1 &lt;= line_no &lt;= lines\n        pos = doc.findBlockByLineNumber(line_no - 1).position()\n        with self.current_cursor() as text_cursor:\n            text_cursor.setPosition(pos)\n\n    def get_selected_text(self) -&gt; str:\n        if self.textCursor().hasSelection():\n            return self.textCursor().selectedText()\n        else:\n            return \"\"\n\n    def get_current_line(self) -&gt; int:\n        return self.textCursor().blockNumber()\n\n    def get_selected_rows(self) -&gt; tuple[int, int]:\n        start = self.textCursor().selectionStart()\n        end = self.textCursor().selectionEnd()\n        start_block_id = self.document().findBlock(start).blockNumber()\n        end_block_id = self.document().findBlock(end).blockNumber()\n\n        return (start_block_id, end_block_id)\n\n    @contextlib.contextmanager\n    def create_cursor(self) -&gt; Iterator[gui.TextCursor]:\n        cursor = gui.TextCursor(self.document())\n        yield cursor\n        self.setTextCursor(cursor)\n\n    @contextlib.contextmanager\n    def current_cursor(self) -&gt; Iterator[gui.TextCursor]:\n        cursor = gui.TextCursor(self.textCursor())\n        yield cursor\n        self.setTextCursor(cursor)\n\n    def get_text_cursor(self) -&gt; gui.TextCursor:\n        return gui.TextCursor(self.textCursor())\n\n    def move_cursor(\n        self,\n        operation: gui.textcursor.MoveOperationStr,\n        mode: gui.textcursor.MoveModeStr = \"move\",\n    ):\n        self.moveCursor(\n            gui.textcursor.MOVE_OPERATION[operation], gui.textcursor.MOVE_MODE[mode]\n        )\n\n    def append_text(self, text: str, newline: bool = True):\n        if newline:\n            self.appendPlainText(text)\n        else:\n            self.move_cursor(\"end\")\n            self.insertPlainText(text)\n            self.move_cursor(\"end\")\n\n    def set_text(self, text: str):\n        self.setPlainText(text)\n\n    def set_syntaxhighlighter(self, syntax: str, style: str | None = None):\n        self._hl = syntaxhighlighters.PygmentsHighlighter(self.document(), syntax, style)\n\n    def text(self) -&gt; str:\n        return self.toPlainText()\n\n    def select_text(self, start: int, end: int):\n        with self.create_cursor() as c:\n            c.select_text(start, end)\n\n    def set_read_only(self, value: bool = True):\n\"\"\"Make the PlainTextEdit read-only.\n\n        Args:\n            value: True, for read-only, otherwise False\n        \"\"\"\n        self.setReadOnly(value)\n\n    def show_whitespace_and_tabs(self, show: bool):\n\"\"\"Set show white spaces flag.\"\"\"\n        doc = self.document()\n        options = doc.defaultTextOption()\n        flag = QtGui.QTextOption.Flag.ShowTabsAndSpaces\n        if show:\n            options.setFlags(options.flags() | flag)  # type: ignore\n        else:\n            options.setFlags(options.flags() &amp; ~flag)  # type: ignore\n        doc.setDefaultTextOption(options)\n\n    def highlight_current_line(self, color: datatypes.ColorType = None):\n        if color is None:\n            color = self.get_palette().get_color(\"highlight\")\n        else:\n            color = colors.get_color(color)\n        extra_selections = []\n\n        if not self.isReadOnly():\n            selection = widgets.TextEdit.ExtraSelection()\n            selection.format.setBackground(color)\n            prop = QtGui.QTextFormat.Property.FullWidthSelection\n            selection.format.setProperty(prop, True)\n            selection.cursor = self.textCursor()\n            selection.cursor.clearSelection()\n            extra_selections.append(selection)\n\n        self.setExtraSelections(extra_selections)\n\n    @deprecated(reason=\"This method is deprecated, use set_word_wrap_mode instead.\")\n    def set_wrap_mode(self, mode: gui.textoption.WordWrapModeStr):\n        self.set_word_wrap_mode(mode)\n\n    def set_word_wrap_mode(self, mode: gui.textoption.WordWrapModeStr):\n\"\"\"Set word wrap mode.\n\n        Args:\n            mode: word wrap mode to use\n\n        Raises:\n            InvalidParamError: wrap mode does not exist\n        \"\"\"\n        if mode not in gui.textoption.WORD_WRAP_MODE:\n            raise InvalidParamError(mode, gui.textoption.WORD_WRAP_MODE)\n        self.setWordWrapMode(gui.textoption.WORD_WRAP_MODE[mode])\n\n    @deprecated(reason=\"This method is deprecated, use get_word_wrap_mode instead.\")\n    def get_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n        return self.get_word_wrap_mode()\n\n    def get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n\n        Returns:\n            Word wrap mode\n        \"\"\"\n        return gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\n\n    def set_line_wrap_mode(self, mode: LineWrapModeStr):\n\"\"\"Set line wrap mode.\n\n        Args:\n            mode: line wrap mode to use\n\n        Raises:\n            InvalidParamError: line wrap mode does not exist\n        \"\"\"\n        if mode not in LINE_WRAP_MODE:\n            raise InvalidParamError(mode, LINE_WRAP_MODE)\n        self.setLineWrapMode(LINE_WRAP_MODE[mode])\n\n    def get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n\n        Returns:\n            Wrap mode\n        \"\"\"\n        return LINE_WRAP_MODE.inverse[self.lineWrapMode()]\n\n    def _on_value_change(self):\n        self.value_changed.emit()\n        if self.validator is not None:\n            self._set_validation_color()\n\n    def _set_validation_color(self, state: bool = True):\n        color = None if self.is_valid() else \"orange\"\n        self.set_background_color(color)\n\n    def set_validator(self, validator: QtGui.QValidator | None):\n        self.validator = validator\n        self._set_validation_color()\n\n    def set_regex_validator(self, regex: str, flags=0) -&gt; gui.RegularExpressionValidator:\n        validator = gui.RegularExpressionValidator(self)\n        validator.set_regex(regex, flags)\n        self.set_validator(validator)\n        return validator\n\n    def is_valid(self) -&gt; bool:\n        if self.validator is None:\n            return True\n        val = self.validator.validate(self.text(), 0)\n        return val[0] == self.validator.State.Acceptable\n\n    def set_value(self, value: str):\n        self.setPlainText(value)\n\n    def get_value(self) -&gt; str:\n        return self.text()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.get_line_wrap_mode","title":"<code>get_line_wrap_mode() -&gt; LineWrapModeStr</code>","text":"<p>Get the current wrap mode.</p> <p>Returns:</p> Type Description <code>LineWrapModeStr</code> <p>Wrap mode</p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n\n    Returns:\n        Wrap mode\n    \"\"\"\n    return LINE_WRAP_MODE.inverse[self.lineWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.get_word_wrap_mode","title":"<code>get_word_wrap_mode() -&gt; gui.textoption.WordWrapModeStr</code>","text":"<p>Get the current word wrap mode.</p> <p>Returns:</p> Type Description <code>gui.textoption.WordWrapModeStr</code> <p>Word wrap mode</p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n\n    Returns:\n        Word wrap mode\n    \"\"\"\n    return gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.set_line_wrap_mode","title":"<code>set_line_wrap_mode(mode: LineWrapModeStr)</code>","text":"<p>Set line wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>LineWrapModeStr</code> <p>line wrap mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>line wrap mode does not exist</p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def set_line_wrap_mode(self, mode: LineWrapModeStr):\n\"\"\"Set line wrap mode.\n\n    Args:\n        mode: line wrap mode to use\n\n    Raises:\n        InvalidParamError: line wrap mode does not exist\n    \"\"\"\n    if mode not in LINE_WRAP_MODE:\n        raise InvalidParamError(mode, LINE_WRAP_MODE)\n    self.setLineWrapMode(LINE_WRAP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.set_read_only","title":"<code>set_read_only(value: bool = True)</code>","text":"<p>Make the PlainTextEdit read-only.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True, for read-only, otherwise False</p> <code>True</code> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def set_read_only(self, value: bool = True):\n\"\"\"Make the PlainTextEdit read-only.\n\n    Args:\n        value: True, for read-only, otherwise False\n    \"\"\"\n    self.setReadOnly(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.set_word_wrap_mode","title":"<code>set_word_wrap_mode(mode: gui.textoption.WordWrapModeStr)</code>","text":"<p>Set word wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>gui.textoption.WordWrapModeStr</code> <p>word wrap mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>wrap mode does not exist</p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def set_word_wrap_mode(self, mode: gui.textoption.WordWrapModeStr):\n\"\"\"Set word wrap mode.\n\n    Args:\n        mode: word wrap mode to use\n\n    Raises:\n        InvalidParamError: wrap mode does not exist\n    \"\"\"\n    if mode not in gui.textoption.WORD_WRAP_MODE:\n        raise InvalidParamError(mode, gui.textoption.WORD_WRAP_MODE)\n    self.setWordWrapMode(gui.textoption.WORD_WRAP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.show_whitespace_and_tabs","title":"<code>show_whitespace_and_tabs(show: bool)</code>","text":"<p>Set show white spaces flag.</p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def show_whitespace_and_tabs(self, show: bool):\n\"\"\"Set show white spaces flag.\"\"\"\n    doc = self.document()\n    options = doc.defaultTextOption()\n    flag = QtGui.QTextOption.Flag.ShowTabsAndSpaces\n    if show:\n        options.setFlags(options.flags() | flag)  # type: ignore\n    else:\n        options.setFlags(options.flags() &amp; ~flag)  # type: ignore\n    doc.setDefaultTextOption(options)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.wheelEvent","title":"<code>wheelEvent(event)</code>","text":"<p>Handle wheel event for zooming.</p> Source code in <code>prettyqt\\widgets\\plaintextedit.py</code> <pre><code>def wheelEvent(self, event):\n\"\"\"Handle wheel event for zooming.\"\"\"\n    if not self._allow_wheel_zoom:\n        return None\n    if event.modifiers() &amp; constants.CTRL_MOD:\n        self.zoomIn() if event.angleDelta().y() &gt; 0 else self.zoomOut()\n    else:\n        super().wheelEvent(event)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ProgressBar","title":"<code>ProgressBar</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QProgressBar</code></p> <p>Progress dialog.</p> <p>wrapper for QtWidgets.QProgressBar</p> Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>class ProgressBar(widgets.WidgetMixin, QtWidgets.QProgressBar):\n\"\"\"Progress dialog.\n\n    wrapper for QtWidgets.QProgressBar\n    \"\"\"\n\n    def __init__(\n        self, text_visible: bool = True, parent: QtWidgets.QWidget | None = None\n    ):\n        super().__init__(parent=parent)\n        self.setTextVisible(text_visible)\n\n    def serialize_fields(self):\n        return dict(\n            alignment=self.get_alignment(),\n            format=self.format(),\n            # inverted_appearance=self.invertedAppearance(),\n            minimum=self.minimum(),\n            maximum=self.maximum(),\n            orientation=self.get_orientation(),\n            text=self.text(),\n            # text_direction=self.get_text_direction(),\n            text_visible=self.isTextVisible(),\n            value=self.value(),\n        )\n\n    def set_alignment(self, alignment: constants.AlignmentStr):\n\"\"\"Set the alignment of the layout.\n\n        Args:\n            alignment: alignment for the layout\n\n        Raises:\n            InvalidParamError: alignment does not exist\n        \"\"\"\n        if alignment not in constants.ALIGNMENTS:\n            raise InvalidParamError(alignment, constants.ALIGNMENTS)\n        self.setAlignment(constants.ALIGNMENTS[alignment])\n\n    def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n\n        Returns:\n            alignment\n        \"\"\"\n        return constants.ALIGNMENTS.inverse[self.alignment()]\n\n    def set_text_direction(self, text_direction: TextDirectionStr):\n\"\"\"Set the text direction of the layout.\n\n        Args:\n            text_direction: text direction for the layout\n\n        Raises:\n            InvalidParamError: text direction does not exist\n        \"\"\"\n        if text_direction not in TEXT_DIRECTIONS:\n            raise InvalidParamError(text_direction, TEXT_DIRECTIONS)\n        self.setTextDirection(TEXT_DIRECTIONS[text_direction])\n\n    def get_text_direction(self) -&gt; TextDirectionStr:\n\"\"\"Return current text direction.\n\n        Returns:\n            Text direction\n        \"\"\"\n        return TEXT_DIRECTIONS.inverse[self.textDirection()]\n\n    def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the progress bar.\n\n        Args:\n            orientation: orientation for the progress bar\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in constants.ORIENTATION:\n            raise InvalidParamError(orientation, constants.ORIENTATION)\n        self.setOrientation(constants.ORIENTATION[orientation])\n\n    def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return constants.ORIENTATION.inverse[self.orientation()]\n\n    def set_range(self, start: int, end: int):\n        self.setRange(start, end)\n\n    def set_value(self, value: int):\n        self.setValue(value)\n\n    def get_value(self) -&gt; int:\n        return self.value()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_alignment","title":"<code>get_alignment() -&gt; constants.AlignmentStr</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.AlignmentStr</code> <p>alignment</p> Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n\n    Returns:\n        alignment\n    \"\"\"\n    return constants.ALIGNMENTS.inverse[self.alignment()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_text_direction","title":"<code>get_text_direction() -&gt; TextDirectionStr</code>","text":"<p>Return current text direction.</p> <p>Returns:</p> Type Description <code>TextDirectionStr</code> <p>Text direction</p> Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def get_text_direction(self) -&gt; TextDirectionStr:\n\"\"\"Return current text direction.\n\n    Returns:\n        Text direction\n    \"\"\"\n    return TEXT_DIRECTIONS.inverse[self.textDirection()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_alignment","title":"<code>set_alignment(alignment: constants.AlignmentStr)</code>","text":"<p>Set the alignment of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr</code> <p>alignment for the layout</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>alignment does not exist</p> Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def set_alignment(self, alignment: constants.AlignmentStr):\n\"\"\"Set the alignment of the layout.\n\n    Args:\n        alignment: alignment for the layout\n\n    Raises:\n        InvalidParamError: alignment does not exist\n    \"\"\"\n    if alignment not in constants.ALIGNMENTS:\n        raise InvalidParamError(alignment, constants.ALIGNMENTS)\n    self.setAlignment(constants.ALIGNMENTS[alignment])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_orientation","title":"<code>set_orientation(orientation: constants.OrientationStr)</code>","text":"<p>Set the orientation of the progress bar.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr</code> <p>orientation for the progress bar</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the progress bar.\n\n    Args:\n        orientation: orientation for the progress bar\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in constants.ORIENTATION:\n        raise InvalidParamError(orientation, constants.ORIENTATION)\n    self.setOrientation(constants.ORIENTATION[orientation])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_text_direction","title":"<code>set_text_direction(text_direction: TextDirectionStr)</code>","text":"<p>Set the text direction of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>text_direction</code> <code>TextDirectionStr</code> <p>text direction for the layout</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>text direction does not exist</p> Source code in <code>prettyqt\\widgets\\progressbar.py</code> <pre><code>def set_text_direction(self, text_direction: TextDirectionStr):\n\"\"\"Set the text direction of the layout.\n\n    Args:\n        text_direction: text direction for the layout\n\n    Raises:\n        InvalidParamError: text direction does not exist\n    \"\"\"\n    if text_direction not in TEXT_DIRECTIONS:\n        raise InvalidParamError(text_direction, TEXT_DIRECTIONS)\n    self.setTextDirection(TEXT_DIRECTIONS[text_direction])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ProgressDialog","title":"<code>ProgressDialog</code>","text":"<p>         Bases: <code>widgets.DialogMixin</code>, <code>QtWidgets.QProgressDialog</code></p> <p>Progress dialog.</p> <p>Wrapper for QtWidgets.QProgressDialog</p> Source code in <code>prettyqt\\widgets\\progressdialog.py</code> <pre><code>class ProgressDialog(widgets.DialogMixin, QtWidgets.QProgressDialog):\n\"\"\"Progress dialog.\n\n    Wrapper for QtWidgets.QProgressDialog\n    \"\"\"\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(parent=parent)\n\n        progress_bar = widgets.ProgressBar()\n        progress_bar.setRange(0, 0)\n        progress_bar.setTextVisible(False)\n        self.setBar(progress_bar)\n\n        self.set_icon(\"mdi.timer-sand-empty\")\n        self.set_modality(\"application\")\n        self.set_flags(\n            minimize=False, maximize=False, close=False, stay_on_top=True, window=True\n        )\n        self.setCancelButton(None)  # type: ignore\n        self.cancel()\n\n    def show_message(self, message: str):\n        self.setLabelText(message)\n        self.show()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.Scroller","title":"<code>Scroller</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\widgets\\scroller.py</code> <pre><code>class Scroller(core.ObjectMixin):\n    def __init__(self, item: QtWidgets.QScroller):\n        self.item = item\n\n    def __getattr__(self, val):\n        return getattr(self.item, val)\n\n    def get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n\n        Returns:\n            state\n        \"\"\"\n        return STATE.inverse[self.state()]\n\n    def get_velocity(self) -&gt; core.PointF:\n        return core.PointF(self.velocity())\n\n    def get_pixel_per_meter(self) -&gt; core.PointF:\n        return core.PointF(self.pixelPerMeter())\n\n    def get_final_position(self) -&gt; core.PointF:\n        return core.PointF(self.finalPosition())\n\n    def handle_input(\n        self, input_type: InputStr, position: datatypes.PointFType, timestamp: int = 0\n    ) -&gt; bool:\n        if isinstance(position, tuple):\n            position = core.PointF(*position)\n        if input_type not in INPUT:\n            raise InvalidParamError(input_type, INPUT)\n        return self.handleInput(INPUT[input_type], position, timestamp)\n\n    def get_scroller_properties(self) -&gt; widgets.ScrollerProperties:\n        return widgets.ScrollerProperties(self.scrollerProperties())\n\n    @classmethod\n    def get_scroller(cls, obj: QtCore.QObject):\n        return cls(QtWidgets.QScroller.scroller(obj))\n\n    @staticmethod\n    def grab_gesture(\n        target: QtCore.QObject, gesture_type: ScrollGestureTypeStr = \"touch\"\n    ) -&gt; constants.GestureTypeStr:\n        if gesture_type not in SCROLLER_GESTURE_TYPE:\n            raise InvalidParamError(gesture_type, SCROLLER_GESTURE_TYPE)\n        gesture = QtWidgets.QScroller.grabGesture(\n            target, SCROLLER_GESTURE_TYPE[gesture_type]\n        )\n        if gesture &gt;= 256:\n            gesture -= 256\n        return constants.GESTURE_TYPE.inverse[gesture]\n\n    @staticmethod\n    def grabbed_gesture(target: QtCore.QObject) -&gt; constants.GestureTypeStr:\n        return constants.GESTURE_TYPE.inverse[QtWidgets.QScroller.grabbedGesture(target)]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scroller.Scroller.get_state","title":"<code>get_state() -&gt; StateStr</code>","text":"<p>Return current state.</p> <p>Returns:</p> Type Description <code>StateStr</code> <p>state</p> Source code in <code>prettyqt\\widgets\\scroller.py</code> <pre><code>def get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n\n    Returns:\n        state\n    \"\"\"\n    return STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ScrollerProperties","title":"<code>ScrollerProperties</code>","text":"<p>         Bases: <code>QtWidgets.QScrollerProperties</code></p> Source code in <code>prettyqt\\widgets\\scrollerproperties.py</code> <pre><code>class ScrollerProperties(QtWidgets.QScrollerProperties):\n    def __getitem__(self, metric: ScrollmetricStr):\n        return self.get_scroll_metric(metric)\n\n    def __setitem__(self, metric: ScrollmetricStr, value: Any):\n        self.set_scroll_metric(metric, value)\n\n    def keys(self):\n        return SCROLL_METRIC.keys()\n\n    def __iter__(self):\n        return iter(SCROLL_METRIC.keys())\n\n    def set_scroll_metric(self, metric: ScrollmetricStr, value: Any):\n\"\"\"Set scroll metric.\n\n        Args:\n            metric: Scroll metric to set\n            value: Value to set\n\n        Raises:\n            InvalidParamError: metric does not exist\n\n        \"\"\"\n        if metric not in SCROLL_METRIC:\n            raise InvalidParamError(metric, SCROLL_METRIC)\n        self.setScrollMetric(SCROLL_METRIC[metric], value)\n\n    def get_scroll_metric(self, metric: ScrollmetricStr) -&gt; Any:\n\"\"\"Return scroll metric.\n\n        Args:\n            metric: Scroll metric to get\n\n        Raises:\n            InvalidParamError: metric does not exist\n\n        Returns:\n            state\n        \"\"\"\n        if metric not in SCROLL_METRIC:\n            raise InvalidParamError(metric, SCROLL_METRIC)\n        return self.scrollMetric(SCROLL_METRIC[metric])\n\n    def get_scroll_metrics(self) -&gt; dict:\n        return {i: self.get_scroll_metric(i) for i in SCROLL_METRIC}\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.get_scroll_metric","title":"<code>get_scroll_metric(metric: ScrollmetricStr) -&gt; Any</code>","text":"<p>Return scroll metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>ScrollmetricStr</code> <p>Scroll metric to get</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>metric does not exist</p> <p>Returns:</p> Type Description <code>Any</code> <p>state</p> Source code in <code>prettyqt\\widgets\\scrollerproperties.py</code> <pre><code>def get_scroll_metric(self, metric: ScrollmetricStr) -&gt; Any:\n\"\"\"Return scroll metric.\n\n    Args:\n        metric: Scroll metric to get\n\n    Raises:\n        InvalidParamError: metric does not exist\n\n    Returns:\n        state\n    \"\"\"\n    if metric not in SCROLL_METRIC:\n        raise InvalidParamError(metric, SCROLL_METRIC)\n    return self.scrollMetric(SCROLL_METRIC[metric])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.set_scroll_metric","title":"<code>set_scroll_metric(metric: ScrollmetricStr, value: Any)</code>","text":"<p>Set scroll metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>ScrollmetricStr</code> <p>Scroll metric to set</p> required <code>value</code> <code>Any</code> <p>Value to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>metric does not exist</p> Source code in <code>prettyqt\\widgets\\scrollerproperties.py</code> <pre><code>def set_scroll_metric(self, metric: ScrollmetricStr, value: Any):\n\"\"\"Set scroll metric.\n\n    Args:\n        metric: Scroll metric to set\n        value: Value to set\n\n    Raises:\n        InvalidParamError: metric does not exist\n\n    \"\"\"\n    if metric not in SCROLL_METRIC:\n        raise InvalidParamError(metric, SCROLL_METRIC)\n    self.setScrollMetric(SCROLL_METRIC[metric], value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.Shortcut","title":"<code>Shortcut</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtWidgets.QShortcut</code></p> Source code in <code>prettyqt\\widgets\\shortcut.py</code> <pre><code>class Shortcut(core.ObjectMixin, QtWidgets.QShortcut):\n    def __str__(self):\n        return self.key().toString()\n\n    def serialize_field(self):\n        return dict(\n            auto_repeat=self.autoRepeat(),\n            context=self.get_context(),\n            enabled=self.isEnabled(),\n            key=self.get_key(),\n            whats_this=self.whatsThis(),\n        )\n\n    def set_context(self, context: constants.ContextStr):\n\"\"\"Set shortcut context.\n\n        Args:\n            context: shortcut context\n\n        Raises:\n            InvalidParamError: shortcut context does not exist\n        \"\"\"\n        if context not in constants.CONTEXT:\n            raise InvalidParamError(context, constants.CONTEXT)\n        self.setContext(constants.CONTEXT[context])\n\n    def get_context(self) -&gt; constants.ContextStr:\n\"\"\"Return shortcut context.\n\n        Returns:\n            shortcut context\n        \"\"\"\n        return constants.CONTEXT.inverse[self.context()]\n\n    def get_key(self) -&gt; gui.KeySequence:\n\"\"\"Return the shortcut's key sequence.\n\n        Returns:\n            Key sequence\n        \"\"\"\n        return gui.KeySequence(\n            self.key().toString(), gui.KeySequence.SequenceFormat.PortableText\n        )\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.get_context","title":"<code>get_context() -&gt; constants.ContextStr</code>","text":"<p>Return shortcut context.</p> <p>Returns:</p> Type Description <code>constants.ContextStr</code> <p>shortcut context</p> Source code in <code>prettyqt\\widgets\\shortcut.py</code> <pre><code>def get_context(self) -&gt; constants.ContextStr:\n\"\"\"Return shortcut context.\n\n    Returns:\n        shortcut context\n    \"\"\"\n    return constants.CONTEXT.inverse[self.context()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.get_key","title":"<code>get_key() -&gt; gui.KeySequence</code>","text":"<p>Return the shortcut's key sequence.</p> <p>Returns:</p> Type Description <code>gui.KeySequence</code> <p>Key sequence</p> Source code in <code>prettyqt\\widgets\\shortcut.py</code> <pre><code>def get_key(self) -&gt; gui.KeySequence:\n\"\"\"Return the shortcut's key sequence.\n\n    Returns:\n        Key sequence\n    \"\"\"\n    return gui.KeySequence(\n        self.key().toString(), gui.KeySequence.SequenceFormat.PortableText\n    )\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.set_context","title":"<code>set_context(context: constants.ContextStr)</code>","text":"<p>Set shortcut context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>constants.ContextStr</code> <p>shortcut context</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>shortcut context does not exist</p> Source code in <code>prettyqt\\widgets\\shortcut.py</code> <pre><code>def set_context(self, context: constants.ContextStr):\n\"\"\"Set shortcut context.\n\n    Args:\n        context: shortcut context\n\n    Raises:\n        InvalidParamError: shortcut context does not exist\n    \"\"\"\n    if context not in constants.CONTEXT:\n        raise InvalidParamError(context, constants.CONTEXT)\n    self.setContext(constants.CONTEXT[context])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.SizePolicy","title":"<code>SizePolicy</code>","text":"<p>         Bases: <code>prettyprinter.PrettyPrinter</code>, <code>QtWidgets.QSizePolicy</code></p> Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>class SizePolicy(prettyprinter.PrettyPrinter, QtWidgets.QSizePolicy):\n    def __repr__(self) -&gt; str:\n        cls_name = type(self).__name__\n        params = helpers.format_kwargs(self.__getstate__())\n        return f\"{cls_name}({params})\"\n\n    def __getstate__(self):\n        return dict(\n            has_height_for_width=self.hasHeightForWidth(),\n            has_width_for_height=self.hasWidthForHeight(),\n            horizontal_stretch=self.horizontalStretch(),\n            vertical_stretch=self.verticalStretch(),\n            horizontal_policy=self.get_horizontal_policy(),\n            vertical_policy=self.get_vertical_policy(),\n            retain_size_when_hidden=self.retainSizeWhenHidden(),\n            control_type=self.get_control_type(),\n        )\n\n    def __setstate__(self, state: dict[str, Any]) -&gt; None:\n        self.setHeightForWidth(state[\"has_height_for_width\"])\n        self.setWidthForHeight(state[\"has_width_for_height\"])\n        self.setHorizontalStretch(state[\"horizontal_stretch\"])\n        self.setVerticalStretch(state[\"vertical_stretch\"])\n        self.set_horizontal_policy(state[\"horizontal_policy\"])\n        self.set_vertical_policy(state[\"vertical_policy\"])\n        self.setRetainSizeWhenHidden(state[\"retain_size_when_hidden\"])\n        self.set_control_type(state[\"control_type\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def serialize(self) -&gt; dict[str, Any]:\n        return self.__getstate__()\n\n    @classmethod\n    def clone(cls, qpol: QtWidgets.QSizePolicy) -&gt; SizePolicy:\n        pol = cls(qpol.horizontalPolicy(), qpol.verticalPolicy(), qpol.controlType())\n        pol.setHeightForWidth(qpol.hasHeightForWidth())\n        pol.setWidthForHeight(qpol.hasWidthForHeight())\n        pol.setHorizontalStretch(qpol.horizontalStretch())\n        pol.setVerticalStretch(qpol.verticalStretch())\n        pol.setRetainSizeWhenHidden(qpol.retainSizeWhenHidden())\n        return pol\n\n    def get_horizontal_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n\n        Returns:\n            horizontal size policy\n        \"\"\"\n        return SIZE_POLICY.inverse[self.horizontalPolicy()]\n\n    def set_horizontal_policy(self, policy: SizePolicyStr) -&gt; None:\n\"\"\"Set the horizontal policy.\n\n        Args:\n            policy: policy to set\n\n        Raises:\n            InvalidParamError: policy does not exist\n        \"\"\"\n        self.setHorizontalPolicy(SIZE_POLICY[policy])\n\n    def get_vertical_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n\n        Returns:\n            vertical size policy\n\n        \"\"\"\n        return SIZE_POLICY.inverse[self.verticalPolicy()]\n\n    def set_vertical_policy(self, policy: SizePolicyStr) -&gt; None:\n\"\"\"Set the horizontal policy.\n\n        Args:\n            policy: policy to set\n\n        Raises:\n            InvalidParamError: policy does not exist\n        \"\"\"\n        self.setVerticalPolicy(SIZE_POLICY[policy])\n\n    def get_control_type(self) -&gt; ControlTypeStr:\n\"\"\"Return control type.\n\n        Returns:\n            control type\n        \"\"\"\n        return CONTROL_TYPE.inverse[self.controlType()]\n\n    def set_control_type(self, typ: ControlTypeStr) -&gt; None:\n\"\"\"Set the control type.\n\n        Args:\n            typ: control type to set\n\n        Raises:\n            InvalidParamError: control type does not exist\n        \"\"\"\n        if typ not in CONTROL_TYPE:\n            raise InvalidParamError(typ, CONTROL_TYPE)\n        self.setControlType(CONTROL_TYPE[typ])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_control_type","title":"<code>get_control_type() -&gt; ControlTypeStr</code>","text":"<p>Return control type.</p> <p>Returns:</p> Type Description <code>ControlTypeStr</code> <p>control type</p> Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def get_control_type(self) -&gt; ControlTypeStr:\n\"\"\"Return control type.\n\n    Returns:\n        control type\n    \"\"\"\n    return CONTROL_TYPE.inverse[self.controlType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_horizontal_policy","title":"<code>get_horizontal_policy() -&gt; SizePolicyStr</code>","text":"<p>Return size policy.</p> <p>Returns:</p> Type Description <code>SizePolicyStr</code> <p>horizontal size policy</p> Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def get_horizontal_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n\n    Returns:\n        horizontal size policy\n    \"\"\"\n    return SIZE_POLICY.inverse[self.horizontalPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_vertical_policy","title":"<code>get_vertical_policy() -&gt; SizePolicyStr</code>","text":"<p>Return size policy.</p> <p>Returns:</p> Type Description <code>SizePolicyStr</code> <p>vertical size policy</p> Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def get_vertical_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n\n    Returns:\n        vertical size policy\n\n    \"\"\"\n    return SIZE_POLICY.inverse[self.verticalPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_control_type","title":"<code>set_control_type(typ: ControlTypeStr) -&gt; None</code>","text":"<p>Set the control type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>ControlTypeStr</code> <p>control type to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>control type does not exist</p> Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def set_control_type(self, typ: ControlTypeStr) -&gt; None:\n\"\"\"Set the control type.\n\n    Args:\n        typ: control type to set\n\n    Raises:\n        InvalidParamError: control type does not exist\n    \"\"\"\n    if typ not in CONTROL_TYPE:\n        raise InvalidParamError(typ, CONTROL_TYPE)\n    self.setControlType(CONTROL_TYPE[typ])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_horizontal_policy","title":"<code>set_horizontal_policy(policy: SizePolicyStr) -&gt; None</code>","text":"<p>Set the horizontal policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizePolicyStr</code> <p>policy to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>policy does not exist</p> Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def set_horizontal_policy(self, policy: SizePolicyStr) -&gt; None:\n\"\"\"Set the horizontal policy.\n\n    Args:\n        policy: policy to set\n\n    Raises:\n        InvalidParamError: policy does not exist\n    \"\"\"\n    self.setHorizontalPolicy(SIZE_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_vertical_policy","title":"<code>set_vertical_policy(policy: SizePolicyStr) -&gt; None</code>","text":"<p>Set the horizontal policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizePolicyStr</code> <p>policy to set</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>policy does not exist</p> Source code in <code>prettyqt\\widgets\\sizepolicy.py</code> <pre><code>def set_vertical_policy(self, policy: SizePolicyStr) -&gt; None:\n\"\"\"Set the horizontal policy.\n\n    Args:\n        policy: policy to set\n\n    Raises:\n        InvalidParamError: policy does not exist\n    \"\"\"\n    self.setVerticalPolicy(SIZE_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.Slider","title":"<code>Slider</code>","text":"<p>         Bases: <code>widgets.AbstractSliderMixin</code>, <code>QtWidgets.QSlider</code></p> Source code in <code>prettyqt\\widgets\\slider.py</code> <pre><code>class Slider(widgets.AbstractSliderMixin, QtWidgets.QSlider):\n    value_changed = core.Signal(int)\n\n    def __init__(\n        self,\n        orientation: (constants.OrientationStr | QtCore.Qt.Orientation) = \"horizontal\",\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        if isinstance(orientation, QtCore.Qt.Orientation):\n            ori = orientation\n        else:\n            ori = constants.ORIENTATION[orientation]\n        super().__init__(ori, parent)\n        self.valueChanged.connect(self.on_value_change)\n\n    def set_tick_position(self, position: TickPositionAllStr):\n\"\"\"Set the tick position for the slider.\n\n        For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\".\n\n        Args:\n            position: position for the ticks\n        \"\"\"\n        if position == \"left\":\n            position = \"above\"\n        elif position == \"right\":\n            position = \"below\"\n        elif position not in TICK_POSITION:\n            raise InvalidParamError(position, TICK_POSITION)\n        self.setTickPosition(TICK_POSITION[position])\n\n    def get_tick_position(self) -&gt; TickPositionStr:\n\"\"\"Return tick position.\n\n        Returns:\n            tick position\n        \"\"\"\n        return TICK_POSITION.inverse[self.tickPosition()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.get_tick_position","title":"<code>get_tick_position() -&gt; TickPositionStr</code>","text":"<p>Return tick position.</p> <p>Returns:</p> Type Description <code>TickPositionStr</code> <p>tick position</p> Source code in <code>prettyqt\\widgets\\slider.py</code> <pre><code>def get_tick_position(self) -&gt; TickPositionStr:\n\"\"\"Return tick position.\n\n    Returns:\n        tick position\n    \"\"\"\n    return TICK_POSITION.inverse[self.tickPosition()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.set_tick_position","title":"<code>set_tick_position(position: TickPositionAllStr)</code>","text":"<p>Set the tick position for the slider.</p> <p>For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\".</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>TickPositionAllStr</code> <p>position for the ticks</p> required Source code in <code>prettyqt\\widgets\\slider.py</code> <pre><code>def set_tick_position(self, position: TickPositionAllStr):\n\"\"\"Set the tick position for the slider.\n\n    For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\".\n\n    Args:\n        position: position for the ticks\n    \"\"\"\n    if position == \"left\":\n        position = \"above\"\n    elif position == \"right\":\n        position = \"below\"\n    elif position not in TICK_POSITION:\n        raise InvalidParamError(position, TICK_POSITION)\n    self.setTickPosition(TICK_POSITION[position])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.SplitterHandle","title":"<code>SplitterHandle</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QSplitterHandle</code></p> Source code in <code>prettyqt\\widgets\\splitterhandle.py</code> <pre><code>class SplitterHandle(widgets.WidgetMixin, QtWidgets.QSplitterHandle):\n    def __init__(\n        self,\n        orientation: constants.OrientationStr | QtCore.Qt.Orientation,\n        parent: QtWidgets.QSplitter,\n    ):\n        if isinstance(orientation, QtCore.Qt.Orientation):\n            ori = orientation\n        else:\n            ori = constants.ORIENTATION[orientation]\n        super().__init__(ori, parent)\n\n    def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the slider.\n\n        Args:\n            orientation: orientation for the slider\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in constants.ORIENTATION:\n            raise InvalidParamError(orientation, constants.ORIENTATION)\n        self.setOrientation(constants.ORIENTATION[orientation])\n\n    def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle.SplitterHandle.get_orientation","title":"<code>get_orientation() -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt\\widgets\\splitterhandle.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle.SplitterHandle.set_orientation","title":"<code>set_orientation(orientation: constants.OrientationStr)</code>","text":"<p>Set the orientation of the slider.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr</code> <p>orientation for the slider</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt\\widgets\\splitterhandle.py</code> <pre><code>def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the slider.\n\n    Args:\n        orientation: orientation for the slider\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in constants.ORIENTATION:\n        raise InvalidParamError(orientation, constants.ORIENTATION)\n    self.setOrientation(constants.ORIENTATION[orientation])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.StyleOptionSlider","title":"<code>StyleOptionSlider</code>","text":"<p>         Bases: <code>widgets.StyleOptionComplexMixin</code>, <code>QtWidgets.QStyleOptionSlider</code></p> Source code in <code>prettyqt\\widgets\\styleoptionslider.py</code> <pre><code>class StyleOptionSlider(widgets.StyleOptionComplexMixin, QtWidgets.QStyleOptionSlider):\n    def is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n\n        Returns:\n            True if horizontal, else False\n        \"\"\"\n        return self.orientation == constants.HORIZONTAL\n\n    def is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n\n        Returns:\n            True if vertical, else False\n        \"\"\"\n        return self.orientation == constants.VERTICAL\n\n    def set_horizontal(self) -&gt; None:\n\"\"\"Set slider orientation to horizontal.\"\"\"\n        self.orientation = constants.HORIZONTAL\n\n    def set_vertical(self) -&gt; None:\n\"\"\"Set slider orientation to vertical.\"\"\"\n        self.orientation = constants.VERTICAL\n\n    def get_orientation(self) -&gt; Literal[\"horizontal\", \"vertical\"]:\n        return \"horizontal\" if self.is_horizontal() else \"vertical\"\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_horizontal","title":"<code>is_horizontal() -&gt; bool</code>","text":"<p>Check if silder is horizontal.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if horizontal, else False</p> Source code in <code>prettyqt\\widgets\\styleoptionslider.py</code> <pre><code>def is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n\n    Returns:\n        True if horizontal, else False\n    \"\"\"\n    return self.orientation == constants.HORIZONTAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_vertical","title":"<code>is_vertical() -&gt; bool</code>","text":"<p>Check if silder is vertical.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if vertical, else False</p> Source code in <code>prettyqt\\widgets\\styleoptionslider.py</code> <pre><code>def is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n\n    Returns:\n        True if vertical, else False\n    \"\"\"\n    return self.orientation == constants.VERTICAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_horizontal","title":"<code>set_horizontal() -&gt; None</code>","text":"<p>Set slider orientation to horizontal.</p> Source code in <code>prettyqt\\widgets\\styleoptionslider.py</code> <pre><code>def set_horizontal(self) -&gt; None:\n\"\"\"Set slider orientation to horizontal.\"\"\"\n    self.orientation = constants.HORIZONTAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_vertical","title":"<code>set_vertical() -&gt; None</code>","text":"<p>Set slider orientation to vertical.</p> Source code in <code>prettyqt\\widgets\\styleoptionslider.py</code> <pre><code>def set_vertical(self) -&gt; None:\n\"\"\"Set slider orientation to vertical.\"\"\"\n    self.orientation = constants.VERTICAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.SystemTrayIcon","title":"<code>SystemTrayIcon</code>","text":"<p>         Bases: <code>core.ObjectMixin</code>, <code>QtWidgets.QSystemTrayIcon</code></p> Source code in <code>prettyqt\\widgets\\systemtrayicon.py</code> <pre><code>class SystemTrayIcon(core.ObjectMixin, QtWidgets.QSystemTrayIcon):\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the system tray icon.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def show_message(\n        self,\n        title: str,\n        message: str = \"\",\n        icon: datatypes.IconType = None,\n        timeout: int = 10,\n    ):\n        if icon is None:\n            ico = gui.Icon()\n        if icon in MESSAGE_ICONS:\n            ico = MESSAGE_ICONS[icon]\n        else:\n            ico = iconprovider.get_icon(icon)\n        self.showMessage(title, message, ico, timeout * 1000)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the system tray icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\systemtrayicon.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the system tray icon.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.TabWidget","title":"<code>TabWidget</code>","text":"<p>         Bases: <code>widgets.WidgetMixin</code>, <code>QtWidgets.QTabWidget</code></p> <p>Widget for managing the tabs section.</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>class TabWidget(widgets.WidgetMixin, QtWidgets.QTabWidget):\n\"\"\"Widget for managing the tabs section.\"\"\"\n\n    def __init__(\n        self,\n        parent: QtWidgets.QWidget | None = None,\n        closable: bool = False,\n        detachable: bool = False,\n    ) -&gt; None:\n        # Basic initalization\n        super().__init__(parent)\n        self.tabCloseRequested.connect(self.remove_tab)\n        self.tab_bar = widgets.TabBar(self)\n\n        self.setTabBar(self.tab_bar)\n\n        # Used to keep a reference to detached tabs since their QMainWindow\n        # does not have a parent\n        self.detached_tabs: dict[str, DetachedTab] = {}\n        if detachable:\n            self.set_detachable()\n        self.set_closable(closable)\n\n    def __len__(self) -&gt; int:\n        return self.count()\n\n    def __getitem__(self, index: int) -&gt; QtWidgets.QWidget:\n        if isinstance(index, int):\n            return self.widget(index)\n        result = self.findChild(QtWidgets.QWidget, index)\n        if result is None:\n            raise KeyError(\"Widget not found\")\n        return result\n\n    def __contains__(self, item: QtWidgets.QWidget):\n        return self.indexOf(item) &gt;= 0\n\n    # def serialize_fields(self):\n    #     return dict(\n    #         tabbar=self.tabBar(),\n    #         widgets=self.get_children(),\n    #         movable=self.isMovable(),\n    #         document_mode=self.documentMode(),\n    #         current_index=self.currentIndex(),\n    #         tab_shape=self.get_tab_shape(),\n    #         # elide_mode=self.get_elide_mode(),\n    #         icon_size=self.iconSize(),\n    #         tab_position=self.get_tab_position(),\n    #     )\n\n    # def __setstate__(self, state):\n    #     super().__setstate__(state)\n    #     self.setTabBar(state[\"tabbar\"])\n    #     self.setDocumentMode(state.get(\"document_mode\", False))\n    #     self.setMovable(state.get(\"movable\", False))\n    #     self.set_tab_shape(state.get(\"tab_shape\", \"rounded\"))\n    #     self.setIconSize(state[\"icon_size\"])\n    #     for widget, name, icon, tooltip, whatsthis in state[\"widgets\"]:\n    #         i = self.add_tab(widget, name, icon)\n    #         self.setTabToolTip(i, tooltip)\n    #         self.setTabWhatsThis(i, whatsthis)\n    #     self.setCurrentIndex(state.get(\"index\", 0))\n\n    # def __reduce__(self):\n    #     return type(self), (), self.__getstate__()\n\n    def update_tab_bar_visibility(self):\n\"\"\"Update visibility of the tabBar depending of the number of tabs.\n\n        0 or 1 tab -&gt; tabBar hidden, 2+ tabs - &gt;tabBar visible\n        need to be called explicitly, or be connected to tabInserted/tabRemoved\n        \"\"\"\n        self.tabBar().setVisible(self.count() &gt; 1)\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n        if isinstance(size, int):\n            size = core.Size(size, size)\n        elif isinstance(size, tuple):\n            size = core.Size(*size)\n        self.setIconSize(size)\n\n    def set_document_mode(self, state: bool = True) -&gt; None:\n        self.setDocumentMode(state)\n\n    def set_tab_shape(self, shape: TabShapeStr):\n\"\"\"Set tab shape for the tabwidget.\n\n        Args:\n            shape: tab shape to use\n\n        Raises:\n            InvalidParamError: tab shape does not exist\n        \"\"\"\n        if shape not in TAB_SHAPES:\n            raise InvalidParamError(shape, TAB_SHAPES)\n        self.setTabShape(TAB_SHAPES[shape])\n\n    def get_tab_shape(self) -&gt; TabShapeStr:\n\"\"\"Return tab shape.\n\n        Returns:\n            tab shape\n        \"\"\"\n        return TAB_SHAPES.inverse[self.tabShape()]\n\n    def set_tab_position(self, position: TabPositionStr):\n\"\"\"Set tab position for the tabwidget.\n\n        Args:\n            position: tab position to use\n\n        Raises:\n            InvalidParamError: tab position does not exist\n        \"\"\"\n        if position not in TAB_POSITION:\n            raise InvalidParamError(position, TAB_POSITION)\n        self.setTabPosition(TAB_POSITION[position])\n\n    def get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return tab position.\n\n        Returns:\n            tab position\n        \"\"\"\n        return TAB_POSITION.inverse[self.tabPosition()]\n\n    def get_children(self) -&gt; list[tuple]:\n        return [\n            (\n                self.widget(i),\n                self.tabText(i),\n                self.tab_icon(i),\n                self.tabToolTip(i),\n                self.tabWhatsThis(i),\n            )\n            for i in range(self.count())\n        ]\n\n    def tab_icon(self, i: int) -&gt; gui.Icon | None:\n        icon = self.tabIcon(i)\n        return None if icon.isNull() else gui.Icon(icon)\n\n    def set_detachable(self):\n        self.tab_bar.on_detach.connect(self.detach_tab)\n        core.CoreApplication.call_on_exit(self.close_detached_tabs)\n        self.setMovable(True)\n\n    def set_closable(self, closable: bool = True):\n        self.setTabsClosable(closable)\n\n    @core.Slot(int, QtCore.QPoint)\n    def detach_tab(self, index: int, point: datatypes.PointType):\n\"\"\"Detach tab by removing its contents and placing them in a DetachedTab window.\n\n        Args:\n            index (int): index location of the tab to be detached\n            point (QtCore.QPoint): screen pos for creating the new DetachedTab window\n\n        \"\"\"\n        # Get the tab content\n        if isinstance(point, tuple):\n            point = QtCore.QPoint(*point)\n        name = self.tabText(index)\n        icon = self.tab_icon(index) or self.window().windowIcon()\n        widget = self.widget(index)\n\n        try:\n            widget_rect = widget.frameGeometry()\n        except AttributeError:\n            return\n\n        # Create a new detached tab window\n        detached_tab = DetachedTab(name, widget)\n        detached_tab.set_modality(\"none\")\n        detached_tab.set_icon(icon)\n        detached_tab.setGeometry(widget_rect)\n        detached_tab.on_close.connect(self.attach_tab)\n        detached_tab.move(point)\n        detached_tab.show()\n\n        # Create a reference to maintain access to the detached tab\n        self.detached_tabs[name] = detached_tab\n\n    def add_tab(\n        self,\n        item: QtWidgets.QWidget | QtWidgets.QLayout,\n        label: str,\n        icon: datatypes.IconType = None,\n        position: int | None = None,\n        show: bool = False,\n    ) -&gt; int:\n        if isinstance(item, QtWidgets.QLayout):\n            widget = widgets.Widget()\n            widget.set_layout(item)\n        else:\n            widget = item\n        if position is None:\n            position = len(self)\n        if not icon:\n            index = self.insertTab(position, widget, label)\n        else:\n            icon = iconprovider.get_icon(icon)\n            index = self.insertTab(position, widget, icon, label)\n        if show:\n            self.setCurrentIndex(index)\n        return index\n\n    def attach_tab(\n        self,\n        widget: QtWidgets.QWidget | QtWidgets.QLayout,\n        name: str,\n        icon: datatypes.IconType = None,\n        insert_at: int | None = None,\n    ):\n\"\"\"Re-attach tab.\n\n        Re-attach the tab by removing the content from the DetachedTab window,\n        closing it, and placing the content back into the DetachableTabWidget.\n\n        Args:\n            widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget\n                from the DetachedTab window\n            name (str): the name of the detached tab\n            icon (datatypes.IconType, optional): the window icon for the detached tab\n            insert_at (Optional[int], optional): insert the re-attached tab at the\n                given index\n        \"\"\"\n        widget.setParent(self)\n\n        # Remove the reference\n        del self.detached_tabs[name]\n\n        # Determine if the given image and the main window icon are the same.\n        # If they are, then do not add the icon to the tab\n        self.add_tab(widget, name, icon=icon, position=insert_at, show=True)\n\n    def close_detached_tabs(self):\n\"\"\"Close all tabs that are currently detached.\"\"\"\n        tabs = list(self.detached_tabs.values())\n        for tab in tabs:\n            tab.close()\n\n    @core.Slot(int)\n    def remove_tab(self, index: int):\n        widget = self.widget(index)\n        self.removeTab(index)\n        if widget is not None:\n            widget.deleteLater()\n\n    @core.Slot(QtWidgets.QWidget, str)\n    def open_widget(self, widget: QtWidgets.QWidget, title: str = \"Unnamed\"):\n\"\"\"Create a tab containing delivered widget.\"\"\"\n        self.add_tab(widget, title, icon=\"mdi.widgets\", show=True)\n\n    def set_tab(self, index: int, position: str, widget: QtWidgets.QWidget | None = None):\n        self.tabBar().set_tab(index, position, widget)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.attach_tab","title":"<code>attach_tab(widget: QtWidgets.QWidget | QtWidgets.QLayout, name: str, icon: datatypes.IconType = None, insert_at: int | None = None)</code>","text":"<p>Re-attach tab.</p> <p>Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>Union[QtWidgets.QWidget, QtWidgets.QLayout]</code> <p>the content widget from the DetachedTab window</p> required <code>name</code> <code>str</code> <p>the name of the detached tab</p> required <code>icon</code> <code>datatypes.IconType</code> <p>the window icon for the detached tab</p> <code>None</code> <code>insert_at</code> <code>Optional[int]</code> <p>insert the re-attached tab at the given index</p> <code>None</code> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def attach_tab(\n    self,\n    widget: QtWidgets.QWidget | QtWidgets.QLayout,\n    name: str,\n    icon: datatypes.IconType = None,\n    insert_at: int | None = None,\n):\n\"\"\"Re-attach tab.\n\n    Re-attach the tab by removing the content from the DetachedTab window,\n    closing it, and placing the content back into the DetachableTabWidget.\n\n    Args:\n        widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget\n            from the DetachedTab window\n        name (str): the name of the detached tab\n        icon (datatypes.IconType, optional): the window icon for the detached tab\n        insert_at (Optional[int], optional): insert the re-attached tab at the\n            given index\n    \"\"\"\n    widget.setParent(self)\n\n    # Remove the reference\n    del self.detached_tabs[name]\n\n    # Determine if the given image and the main window icon are the same.\n    # If they are, then do not add the icon to the tab\n    self.add_tab(widget, name, icon=icon, position=insert_at, show=True)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.close_detached_tabs","title":"<code>close_detached_tabs()</code>","text":"<p>Close all tabs that are currently detached.</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def close_detached_tabs(self):\n\"\"\"Close all tabs that are currently detached.\"\"\"\n    tabs = list(self.detached_tabs.values())\n    for tab in tabs:\n        tab.close()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.detach_tab","title":"<code>detach_tab(index: int, point: datatypes.PointType)</code>","text":"<p>Detach tab by removing its contents and placing them in a DetachedTab window.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index location of the tab to be detached</p> required <code>point</code> <code>QtCore.QPoint</code> <p>screen pos for creating the new DetachedTab window</p> required Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>@core.Slot(int, QtCore.QPoint)\ndef detach_tab(self, index: int, point: datatypes.PointType):\n\"\"\"Detach tab by removing its contents and placing them in a DetachedTab window.\n\n    Args:\n        index (int): index location of the tab to be detached\n        point (QtCore.QPoint): screen pos for creating the new DetachedTab window\n\n    \"\"\"\n    # Get the tab content\n    if isinstance(point, tuple):\n        point = QtCore.QPoint(*point)\n    name = self.tabText(index)\n    icon = self.tab_icon(index) or self.window().windowIcon()\n    widget = self.widget(index)\n\n    try:\n        widget_rect = widget.frameGeometry()\n    except AttributeError:\n        return\n\n    # Create a new detached tab window\n    detached_tab = DetachedTab(name, widget)\n    detached_tab.set_modality(\"none\")\n    detached_tab.set_icon(icon)\n    detached_tab.setGeometry(widget_rect)\n    detached_tab.on_close.connect(self.attach_tab)\n    detached_tab.move(point)\n    detached_tab.show()\n\n    # Create a reference to maintain access to the detached tab\n    self.detached_tabs[name] = detached_tab\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_position","title":"<code>get_tab_position() -&gt; TabPositionStr</code>","text":"<p>Return tab position.</p> <p>Returns:</p> Type Description <code>TabPositionStr</code> <p>tab position</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return tab position.\n\n    Returns:\n        tab position\n    \"\"\"\n    return TAB_POSITION.inverse[self.tabPosition()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_shape","title":"<code>get_tab_shape() -&gt; TabShapeStr</code>","text":"<p>Return tab shape.</p> <p>Returns:</p> Type Description <code>TabShapeStr</code> <p>tab shape</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def get_tab_shape(self) -&gt; TabShapeStr:\n\"\"\"Return tab shape.\n\n    Returns:\n        tab shape\n    \"\"\"\n    return TAB_SHAPES.inverse[self.tabShape()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.open_widget","title":"<code>open_widget(widget: QtWidgets.QWidget, title: str = 'Unnamed')</code>","text":"<p>Create a tab containing delivered widget.</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>@core.Slot(QtWidgets.QWidget, str)\ndef open_widget(self, widget: QtWidgets.QWidget, title: str = \"Unnamed\"):\n\"\"\"Create a tab containing delivered widget.\"\"\"\n    self.add_tab(widget, title, icon=\"mdi.widgets\", show=True)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_icon_size","title":"<code>set_icon_size(size: int | datatypes.SizeType)</code>","text":"<p>Set size of the icons.</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n    if isinstance(size, int):\n        size = core.Size(size, size)\n    elif isinstance(size, tuple):\n        size = core.Size(*size)\n    self.setIconSize(size)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_position","title":"<code>set_tab_position(position: TabPositionStr)</code>","text":"<p>Set tab position for the tabwidget.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>TabPositionStr</code> <p>tab position to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>tab position does not exist</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def set_tab_position(self, position: TabPositionStr):\n\"\"\"Set tab position for the tabwidget.\n\n    Args:\n        position: tab position to use\n\n    Raises:\n        InvalidParamError: tab position does not exist\n    \"\"\"\n    if position not in TAB_POSITION:\n        raise InvalidParamError(position, TAB_POSITION)\n    self.setTabPosition(TAB_POSITION[position])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_shape","title":"<code>set_tab_shape(shape: TabShapeStr)</code>","text":"<p>Set tab shape for the tabwidget.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>TabShapeStr</code> <p>tab shape to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>tab shape does not exist</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def set_tab_shape(self, shape: TabShapeStr):\n\"\"\"Set tab shape for the tabwidget.\n\n    Args:\n        shape: tab shape to use\n\n    Raises:\n        InvalidParamError: tab shape does not exist\n    \"\"\"\n    if shape not in TAB_SHAPES:\n        raise InvalidParamError(shape, TAB_SHAPES)\n    self.setTabShape(TAB_SHAPES[shape])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.update_tab_bar_visibility","title":"<code>update_tab_bar_visibility()</code>","text":"<p>Update visibility of the tabBar depending of the number of tabs.</p> <p>0 or 1 tab -&gt; tabBar hidden, 2+ tabs - &gt;tabBar visible need to be called explicitly, or be connected to tabInserted/tabRemoved</p> Source code in <code>prettyqt\\widgets\\tabwidget.py</code> <pre><code>def update_tab_bar_visibility(self):\n\"\"\"Update visibility of the tabBar depending of the number of tabs.\n\n    0 or 1 tab -&gt; tabBar hidden, 2+ tabs - &gt;tabBar visible\n    need to be called explicitly, or be connected to tabInserted/tabRemoved\n    \"\"\"\n    self.tabBar().setVisible(self.count() &gt; 1)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.TableViewMixin","title":"<code>TableViewMixin</code>","text":"<p>         Bases: <code>widgets.AbstractItemViewMixin</code></p> Source code in <code>prettyqt\\widgets\\tableview.py</code> <pre><code>class TableViewMixin(widgets.AbstractItemViewMixin):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        class_name = type(self).__name__\n        self.set_id(class_name)\n        self.setHorizontalHeader(widgets.HeaderView(\"horizontal\", parent=self))\n        self.setVerticalHeader(widgets.HeaderView(\"vertical\", parent=self))\n        self.setAlternatingRowColors(True)\n        self.setWordWrap(False)\n\n    @property\n    def h_header(self):\n        return self.horizontalHeader()\n\n    @h_header.setter\n    def h_header(self, header):\n        self.setHorizontalHeader(header)\n\n    @property\n    def v_header(self):\n        return self.verticalHeader()\n\n    @v_header.setter\n    def v_header(self, header):\n        self.setVerticalHeader(header)\n\n    def setup_list_style(self):\n        self.set_selection_behaviour(\"rows\")\n        self.h_header.setStretchLastSection(True)\n        self.v_header.set_resize_mode(\"fixed\")\n        self.v_header.set_default_section_size(28)\n\n    def adapt_sizes(self):\n        model = self.model()\n        if model is not None and (model.rowCount() * model.columnCount()) &lt; 1000:\n            self.resizeColumnsToContents()\n        else:\n            self.h_header.resize_sections(\"interactive\")\n\n    def sort_by_column(self, column: int | None, ascending: bool = True):\n        column = -1 if column is None else column\n        order = constants.ASCENDING if ascending else constants.DESCENDING\n        self.sortByColumn(column, order)\n\n    def set_grid_style(self, style: constants.PenStyleStr):\n\"\"\"Set grid style.\n\n        Args:\n            style: grid style to use\n\n        Raises:\n            InvalidParamError: invalid grid style\n        \"\"\"\n        if style not in constants.PEN_STYLE:\n            raise InvalidParamError(style, constants.PEN_STYLE)\n        self.setGridStyle(constants.PEN_STYLE[style])\n\n    def get_grid_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return grid style.\n\n        Returns:\n            grid style\n        \"\"\"\n        return constants.PEN_STYLE.inverse[self.gridStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableViewMixin.get_grid_style","title":"<code>get_grid_style() -&gt; constants.PenStyleStr</code>","text":"<p>Return grid style.</p> <p>Returns:</p> Type Description <code>constants.PenStyleStr</code> <p>grid style</p> Source code in <code>prettyqt\\widgets\\tableview.py</code> <pre><code>def get_grid_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return grid style.\n\n    Returns:\n        grid style\n    \"\"\"\n    return constants.PEN_STYLE.inverse[self.gridStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableViewMixin.set_grid_style","title":"<code>set_grid_style(style: constants.PenStyleStr)</code>","text":"<p>Set grid style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.PenStyleStr</code> <p>grid style to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid grid style</p> Source code in <code>prettyqt\\widgets\\tableview.py</code> <pre><code>def set_grid_style(self, style: constants.PenStyleStr):\n\"\"\"Set grid style.\n\n    Args:\n        style: grid style to use\n\n    Raises:\n        InvalidParamError: invalid grid style\n    \"\"\"\n    if style not in constants.PEN_STYLE:\n        raise InvalidParamError(style, constants.PEN_STYLE)\n    self.setGridStyle(constants.PEN_STYLE[style])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.TableWidgetItem","title":"<code>TableWidgetItem</code>","text":"<p>         Bases: <code>QtWidgets.QTableWidgetItem</code></p> Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>class TableWidgetItem(QtWidgets.QTableWidgetItem):\n    def __setitem__(self, index: int, value):\n        self.setData(index, value)\n\n    def __getitem__(self, index: int):\n        return self.data(index)\n\n    def serialize_fields(self):\n        return dict(\n            text=self.text(),\n            tool_tip=self.toolTip(),\n            status_tip=self.statusTip(),\n            checkstate=self.get_checkstate(),\n            icon=self.get_icon(),\n            data=self.data(constants.USER_ROLE),  # type: ignore\n        )\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n        Args:\n            state: checkstate to use\n\n        Raises:\n            InvalidParamError: invalid checkstate\n        \"\"\"\n        if state not in constants.STATE:\n            raise InvalidParamError(state, constants.STATE)\n        self.setCheckState(constants.STATE[state])\n\n    def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n        Returns:\n            checkstate\n        \"\"\"\n        return constants.STATE.inverse[self.checkState()]\n\n    def set_text_alignment(\n        self,\n        horizontal: constants.HorizontalAlignmentStr | None = None,\n        vertical: constants.VerticalAlignmentStr | None = None,\n    ):\n\"\"\"Set text alignment of the checkbox.\n\n        Args:\n            horizontal: horizontal text alignment to use\n            vertical: vertical text alignment to use\n\n        Raises:\n            InvalidParamError: invalid text alignment\n        \"\"\"\n        match horizontal, vertical:\n            case None, None:\n                return\n            case None, _:\n                flag = constants.V_ALIGNMENT[vertical]\n            case _, None:\n                flag = constants.H_ALIGNMENT[horizontal]\n            case _, _:\n                flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n        self.setTextAlignment(flag)\n\n    def get_background(self) -&gt; gui.Brush:\n        return gui.Brush(self.background())\n\n    def get_foreground(self) -&gt; gui.Brush:\n        return gui.Brush(self.foreground())\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        return None if icon.isNull() else gui.Icon(icon)\n\n    def set_tooltip(\n        self,\n        tooltip: str | datatypes.PathType,\n        size: datatypes.SizeType | None = None,\n    ):\n        if isinstance(tooltip, os.PathLike):\n            path = os.fspath(tooltip)\n            if size is None:\n                tooltip = f\"&lt;img src={path!r}&gt;\"\n            else:\n                if isinstance(size, QtCore.QSize):\n                    size = (size.width(), size.height())\n                tooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\n        self.setToolTip(tooltip)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.get_checkstate","title":"<code>get_checkstate() -&gt; constants.StateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.StateStr</code> <p>checkstate</p> Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n    Returns:\n        checkstate\n    \"\"\"\n    return constants.STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_checkstate","title":"<code>set_checkstate(state: constants.StateStr)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.StateStr</code> <p>checkstate to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid checkstate</p> Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n    Args:\n        state: checkstate to use\n\n    Raises:\n        InvalidParamError: invalid checkstate\n    \"\"\"\n    if state not in constants.STATE:\n        raise InvalidParamError(state, constants.STATE)\n    self.setCheckState(constants.STATE[state])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_icon","title":"<code>set_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_text_alignment","title":"<code>set_text_alignment(horizontal: constants.HorizontalAlignmentStr | None = None, vertical: constants.VerticalAlignmentStr | None = None)</code>","text":"<p>Set text alignment of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>horizontal</code> <code>constants.HorizontalAlignmentStr | None</code> <p>horizontal text alignment to use</p> <code>None</code> <code>vertical</code> <code>constants.VerticalAlignmentStr | None</code> <p>vertical text alignment to use</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid text alignment</p> Source code in <code>prettyqt\\widgets\\tablewidgetitem.py</code> <pre><code>def set_text_alignment(\n    self,\n    horizontal: constants.HorizontalAlignmentStr | None = None,\n    vertical: constants.VerticalAlignmentStr | None = None,\n):\n\"\"\"Set text alignment of the checkbox.\n\n    Args:\n        horizontal: horizontal text alignment to use\n        vertical: vertical text alignment to use\n\n    Raises:\n        InvalidParamError: invalid text alignment\n    \"\"\"\n    match horizontal, vertical:\n        case None, None:\n            return\n        case None, _:\n            flag = constants.V_ALIGNMENT[vertical]\n        case _, None:\n            flag = constants.H_ALIGNMENT[horizontal]\n        case _, _:\n            flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n    self.setTextAlignment(flag)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.TextEditMixin","title":"<code>TextEditMixin</code>","text":"<p>         Bases: <code>widgets.AbstractScrollAreaMixin</code></p> Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>class TextEditMixin(widgets.AbstractScrollAreaMixin):\n    value_changed = core.Signal(str)\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.textChanged.connect(self.on_value_change)\n\n    def __add__(self, other: str) -&gt; TextEdit:\n        self.append_text(other)\n        return self\n\n    def on_value_change(self) -&gt; None:\n        self.value_changed.emit(self.text())\n\n    @contextlib.contextmanager\n    def create_cursor(self) -&gt; Iterator[gui.TextCursor]:\n        cursor = gui.TextCursor(self.document())\n        yield cursor\n        self.setTextCursor(cursor)\n\n    def get_text_cursor(self) -&gt; gui.TextCursor:\n        return gui.TextCursor(self.textCursor())\n\n    def set_text(self, text: str) -&gt; None:\n        self.setPlainText(text)\n\n    def append_text(self, text: str) -&gt; None:\n        self.append(text)\n\n    def text(self) -&gt; str:\n        return self.toPlainText()\n\n    def select_text(self, start: int, end: int) -&gt; None:\n        with self.create_cursor() as c:\n            c.select_text(start, end)\n\n    def set_read_only(self, value: bool = True) -&gt; None:\n        self.setReadOnly(value)\n\n    def set_text_color(self, color: datatypes.ColorType) -&gt; None:\n        color = colors.get_color(color)\n        self.setTextColor(color)\n\n    def set_line_wrap_mode(self, mode: LineWrapModeStr):\n\"\"\"Set line wrap mode.\n\n        Args:\n            mode: line wrap mode to use\n\n        Raises:\n            InvalidParamError: line wrap mode does not exist\n        \"\"\"\n        if mode not in LINE_WRAP_MODE:\n            raise InvalidParamError(mode, LINE_WRAP_MODE)\n        self.setLineWrapMode(LINE_WRAP_MODE[mode])\n\n    def get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n\n        Returns:\n            Wrap mode\n        \"\"\"\n        return LINE_WRAP_MODE.inverse[self.lineWrapMode()]\n\n    def set_auto_formatting(self, mode: AutoFormattingStr):\n\"\"\"Set auto formatting mode.\n\n        Args:\n            mode: auto formatting mode to use\n\n        Raises:\n            InvalidParamError: auto formatting mode does not exist\n        \"\"\"\n        if mode not in AUTO_FORMATTING:\n            raise InvalidParamError(mode, AUTO_FORMATTING)\n        self.setAutoFormatting(AUTO_FORMATTING[mode])\n\n    def get_auto_formatting(self) -&gt; AutoFormattingStr:\n\"\"\"Get the current auto formatting mode.\n\n        Returns:\n            Auto formatting mode\n        \"\"\"\n        return AUTO_FORMATTING.inverse[self.autoFormatting()]\n\n    def set_word_wrap_mode(self, mode: gui.textoption.WordWrapModeStr):\n\"\"\"Set word wrap mode.\n\n        Args:\n            mode: word wrap mode to use\n\n        Raises:\n            InvalidParamError: wrap mode does not exist\n        \"\"\"\n        if mode not in gui.textoption.WORD_WRAP_MODE:\n            raise InvalidParamError(mode, gui.textoption.WORD_WRAP_MODE)\n        self.setWordWrapMode(gui.textoption.WORD_WRAP_MODE[mode])\n\n    def get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n\n        Returns:\n            Word wrap mode\n        \"\"\"\n        return gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.get_auto_formatting","title":"<code>get_auto_formatting() -&gt; AutoFormattingStr</code>","text":"<p>Get the current auto formatting mode.</p> <p>Returns:</p> Type Description <code>AutoFormattingStr</code> <p>Auto formatting mode</p> Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def get_auto_formatting(self) -&gt; AutoFormattingStr:\n\"\"\"Get the current auto formatting mode.\n\n    Returns:\n        Auto formatting mode\n    \"\"\"\n    return AUTO_FORMATTING.inverse[self.autoFormatting()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.get_line_wrap_mode","title":"<code>get_line_wrap_mode() -&gt; LineWrapModeStr</code>","text":"<p>Get the current wrap mode.</p> <p>Returns:</p> Type Description <code>LineWrapModeStr</code> <p>Wrap mode</p> Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n\n    Returns:\n        Wrap mode\n    \"\"\"\n    return LINE_WRAP_MODE.inverse[self.lineWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.get_word_wrap_mode","title":"<code>get_word_wrap_mode() -&gt; gui.textoption.WordWrapModeStr</code>","text":"<p>Get the current word wrap mode.</p> <p>Returns:</p> Type Description <code>gui.textoption.WordWrapModeStr</code> <p>Word wrap mode</p> Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n\n    Returns:\n        Word wrap mode\n    \"\"\"\n    return gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.set_auto_formatting","title":"<code>set_auto_formatting(mode: AutoFormattingStr)</code>","text":"<p>Set auto formatting mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>AutoFormattingStr</code> <p>auto formatting mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>auto formatting mode does not exist</p> Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def set_auto_formatting(self, mode: AutoFormattingStr):\n\"\"\"Set auto formatting mode.\n\n    Args:\n        mode: auto formatting mode to use\n\n    Raises:\n        InvalidParamError: auto formatting mode does not exist\n    \"\"\"\n    if mode not in AUTO_FORMATTING:\n        raise InvalidParamError(mode, AUTO_FORMATTING)\n    self.setAutoFormatting(AUTO_FORMATTING[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.set_line_wrap_mode","title":"<code>set_line_wrap_mode(mode: LineWrapModeStr)</code>","text":"<p>Set line wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>LineWrapModeStr</code> <p>line wrap mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>line wrap mode does not exist</p> Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def set_line_wrap_mode(self, mode: LineWrapModeStr):\n\"\"\"Set line wrap mode.\n\n    Args:\n        mode: line wrap mode to use\n\n    Raises:\n        InvalidParamError: line wrap mode does not exist\n    \"\"\"\n    if mode not in LINE_WRAP_MODE:\n        raise InvalidParamError(mode, LINE_WRAP_MODE)\n    self.setLineWrapMode(LINE_WRAP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.set_word_wrap_mode","title":"<code>set_word_wrap_mode(mode: gui.textoption.WordWrapModeStr)</code>","text":"<p>Set word wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>gui.textoption.WordWrapModeStr</code> <p>word wrap mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>wrap mode does not exist</p> Source code in <code>prettyqt\\widgets\\textedit.py</code> <pre><code>def set_word_wrap_mode(self, mode: gui.textoption.WordWrapModeStr):\n\"\"\"Set word wrap mode.\n\n    Args:\n        mode: word wrap mode to use\n\n    Raises:\n        InvalidParamError: wrap mode does not exist\n    \"\"\"\n    if mode not in gui.textoption.WORD_WRAP_MODE:\n        raise InvalidParamError(mode, gui.textoption.WORD_WRAP_MODE)\n    self.setWordWrapMode(gui.textoption.WORD_WRAP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.ToolButton","title":"<code>ToolButton</code>","text":"<p>         Bases: <code>widgets.AbstractButtonMixin</code>, <code>QtWidgets.QToolButton</code></p> Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>class ToolButton(widgets.AbstractButtonMixin, QtWidgets.QToolButton):\n    def __getitem__(self, item: str) -&gt; QtWidgets.QAction:\n        menu = self.menu()\n        return menu[item]\n\n    # def set_menu(self, menu: QtWidgets.QMenu):\n    #     menu.setParent(self)\n    #     self.setMenu(menu)\n\n    @classmethod\n    def for_menu(cls, menu: QtWidgets.QMenu, icon: datatypes.IconType = None):\n        btn = cls()\n        btn.setMenu(menu)\n        # btn.set_title(menu.title())\n        btn.set_popup_mode(\"instant\")\n        btn.set_icon(icon)\n        return btn\n\n    def set_default_action(self, action):\n        self.setDefaultAction(action)\n\n    def set_popup_mode(self, mode: PopupModeStr):\n\"\"\"Set the popup mode of the toolbutton.\n\n        Args:\n            mode: popup mode to use\n\n        Raises:\n            InvalidParamError: invalid popup mode\n        \"\"\"\n        if mode not in POPUP_MODE:\n            raise InvalidParamError(mode, POPUP_MODE)\n        self.setPopupMode(POPUP_MODE[mode])\n\n    def get_popup_mode(self) -&gt; PopupModeStr:\n\"\"\"Return popup mode.\n\n        Returns:\n            popup mode\n        \"\"\"\n        return POPUP_MODE.inverse[self.popupMode()]\n\n    def set_arrow_type(self, mode: constants.ArrowTypeStr):\n\"\"\"Set the arrow type of the toolbutton.\n\n        Args:\n            mode: arrow type to use\n\n        Raises:\n            InvalidParamError: invalid arrow type\n        \"\"\"\n        if mode not in constants.ARROW_TYPE:\n            raise InvalidParamError(mode, constants.ARROW_TYPE)\n        self.setArrowType(constants.ARROW_TYPE[mode])\n\n    def get_arrow_type(self) -&gt; constants.ArrowTypeStr:\n\"\"\"Return arrow type.\n\n        Returns:\n            arrow type\n        \"\"\"\n        return constants.ARROW_TYPE.inverse[self.arrowType()]\n\n    def set_style(self, style: constants.ToolButtonStyleStr):\n\"\"\"Set the toolbutton style.\n\n        Args:\n            style: style to use\n\n        Raises:\n            InvalidParamError: invalid style\n        \"\"\"\n        if style not in constants.TOOLBUTTON_STYLE:\n            raise InvalidParamError(style, constants.TOOLBUTTON_STYLE)\n        self.setToolButtonStyle(constants.TOOLBUTTON_STYLE[style])\n\n    def get_style(self) -&gt; constants.ToolButtonStyleStr:\n\"\"\"Return toolbutton style.\n\n        Returns:\n            toolbutton style\n        \"\"\"\n        return constants.TOOLBUTTON_STYLE.inverse[self.toolButtonStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_arrow_type","title":"<code>get_arrow_type() -&gt; constants.ArrowTypeStr</code>","text":"<p>Return arrow type.</p> <p>Returns:</p> Type Description <code>constants.ArrowTypeStr</code> <p>arrow type</p> Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def get_arrow_type(self) -&gt; constants.ArrowTypeStr:\n\"\"\"Return arrow type.\n\n    Returns:\n        arrow type\n    \"\"\"\n    return constants.ARROW_TYPE.inverse[self.arrowType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_popup_mode","title":"<code>get_popup_mode() -&gt; PopupModeStr</code>","text":"<p>Return popup mode.</p> <p>Returns:</p> Type Description <code>PopupModeStr</code> <p>popup mode</p> Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def get_popup_mode(self) -&gt; PopupModeStr:\n\"\"\"Return popup mode.\n\n    Returns:\n        popup mode\n    \"\"\"\n    return POPUP_MODE.inverse[self.popupMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_style","title":"<code>get_style() -&gt; constants.ToolButtonStyleStr</code>","text":"<p>Return toolbutton style.</p> <p>Returns:</p> Type Description <code>constants.ToolButtonStyleStr</code> <p>toolbutton style</p> Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def get_style(self) -&gt; constants.ToolButtonStyleStr:\n\"\"\"Return toolbutton style.\n\n    Returns:\n        toolbutton style\n    \"\"\"\n    return constants.TOOLBUTTON_STYLE.inverse[self.toolButtonStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_arrow_type","title":"<code>set_arrow_type(mode: constants.ArrowTypeStr)</code>","text":"<p>Set the arrow type of the toolbutton.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ArrowTypeStr</code> <p>arrow type to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid arrow type</p> Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def set_arrow_type(self, mode: constants.ArrowTypeStr):\n\"\"\"Set the arrow type of the toolbutton.\n\n    Args:\n        mode: arrow type to use\n\n    Raises:\n        InvalidParamError: invalid arrow type\n    \"\"\"\n    if mode not in constants.ARROW_TYPE:\n        raise InvalidParamError(mode, constants.ARROW_TYPE)\n    self.setArrowType(constants.ARROW_TYPE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_popup_mode","title":"<code>set_popup_mode(mode: PopupModeStr)</code>","text":"<p>Set the popup mode of the toolbutton.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>PopupModeStr</code> <p>popup mode to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid popup mode</p> Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def set_popup_mode(self, mode: PopupModeStr):\n\"\"\"Set the popup mode of the toolbutton.\n\n    Args:\n        mode: popup mode to use\n\n    Raises:\n        InvalidParamError: invalid popup mode\n    \"\"\"\n    if mode not in POPUP_MODE:\n        raise InvalidParamError(mode, POPUP_MODE)\n    self.setPopupMode(POPUP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_style","title":"<code>set_style(style: constants.ToolButtonStyleStr)</code>","text":"<p>Set the toolbutton style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.ToolButtonStyleStr</code> <p>style to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid style</p> Source code in <code>prettyqt\\widgets\\toolbutton.py</code> <pre><code>def set_style(self, style: constants.ToolButtonStyleStr):\n\"\"\"Set the toolbutton style.\n\n    Args:\n        style: style to use\n\n    Raises:\n        InvalidParamError: invalid style\n    \"\"\"\n    if style not in constants.TOOLBUTTON_STYLE:\n        raise InvalidParamError(style, constants.TOOLBUTTON_STYLE)\n    self.setToolButtonStyle(constants.TOOLBUTTON_STYLE[style])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.TreeWidgetItem","title":"<code>TreeWidgetItem</code>","text":"<p>         Bases: <code>serializemixin.SerializeMixin</code>, <code>QtWidgets.QTreeWidgetItem</code></p> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>class TreeWidgetItem(serializemixin.SerializeMixin, QtWidgets.QTreeWidgetItem):\n    def __repr__(self):\n        return get_repr(self)\n\n    def serialize_fields(self):\n        data = [\n            self.data(i, constants.USER_ROLE)  # type: ignore\n            for i in range(self.columnCount())\n        ]\n        return dict(\n            text=[self.text(i) for i in range(self.columnCount())],\n            tool_tip=[self.toolTip(i) for i in range(self.columnCount())],\n            status_tip=[self.statusTip(i) for i in range(self.columnCount())],\n            checkstate=[self.get_checkstate(i) for i in range(self.columnCount())],\n            icon=[self.get_icon(i) for i in range(self.columnCount())],\n            data=data,\n        )\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QTreeWidgetItem]:\n        return iter(self.child(i) for i in range(self.childCount()))\n\n    def __len__(self):\n        return self.childCount()\n\n    def __getitem__(self, index: int) -&gt; QtWidgets.QTreeWidgetItem:\n        item = self.child(index)\n        if item is None:\n            raise KeyError(index)\n        return item\n\n    def __delitem__(self, index: int):\n        self.takeChild(index)\n\n    def __add__(self, other: QtWidgets.QTreeWidgetItem) -&gt; TreeWidgetItem:\n        self.addChild(other)\n        return self\n\n    def set_size_hint(self, hint: datatypes.SizeType, column: int = 0):\n        if isinstance(hint, tuple):\n            hint = QtCore.QSize(*hint)\n        self.setSizeHint(column, hint)\n\n    def sort_children(self, column: int, descending: bool = False):\n        order = constants.DESCENDING if descending else constants.ASCENDING\n        self.sortChildren(column, order)\n\n    def set_icon(self, icon: datatypes.IconType, column: int = 0):\n\"\"\"Set the icon for the action.\n\n        Args:\n            icon: icon to use\n            column: column\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(column, icon)\n\n    def get_background(self, column: int = 0) -&gt; gui.Brush:\n        return gui.Brush(self.background(column))\n\n    def get_foreground(self, column: int = 0) -&gt; gui.Brush:\n        return gui.Brush(self.foreground(column))\n\n    def get_font(self, column: int = 0) -&gt; gui.Font:\n        return gui.Font(self.font(column))\n\n    def get_icon(self, column: int = 0) -&gt; gui.Icon | None:\n        icon = self.icon(column)\n        return None if icon.isNull() else gui.Icon(icon)\n\n    def set_checkstate(self, state: constants.StateStr, column: int = 0):\n\"\"\"Set checkstate of the checkbox.\n\n        Args:\n            state: checkstate to use\n            column: column\n\n        Raises:\n            InvalidParamError: invalid checkstate\n        \"\"\"\n        if state not in constants.STATE:\n            raise InvalidParamError(state, constants.STATE)\n        self.setCheckState(column, constants.STATE[state])\n\n    def get_checkstate(self, column: int = 0) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n        Args:\n            column: column\n\n        Returns:\n            checkstate\n        \"\"\"\n        return constants.STATE.inverse[self.checkState(column)]\n\n    def set_child_indicator_policy(self, policy: ChildIndicatorPolicyStr):\n\"\"\"Set the child indicator policy.\n\n        Args:\n            policy: child indicator policy\n\n        Raises:\n            InvalidParamError: policy does not exist\n        \"\"\"\n        if policy not in CHILD_INDICATOR_POLICY:\n            raise InvalidParamError(policy, CHILD_INDICATOR_POLICY)\n        self.setChildIndicatorPolicy(CHILD_INDICATOR_POLICY[policy])\n\n    def get_child_indicator_policy(self) -&gt; ChildIndicatorPolicyStr:\n\"\"\"Return current child indicator policy.\n\n        Returns:\n            child indicator policy\n        \"\"\"\n        return CHILD_INDICATOR_POLICY.inverse[self.childIndicatorPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_checkstate","title":"<code>get_checkstate(column: int = 0) -&gt; constants.StateStr</code>","text":"<p>Return checkstate.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>int</code> <p>column</p> <code>0</code> <p>Returns:</p> Type Description <code>constants.StateStr</code> <p>checkstate</p> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>def get_checkstate(self, column: int = 0) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n    Args:\n        column: column\n\n    Returns:\n        checkstate\n    \"\"\"\n    return constants.STATE.inverse[self.checkState(column)]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_child_indicator_policy","title":"<code>get_child_indicator_policy() -&gt; ChildIndicatorPolicyStr</code>","text":"<p>Return current child indicator policy.</p> <p>Returns:</p> Type Description <code>ChildIndicatorPolicyStr</code> <p>child indicator policy</p> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>def get_child_indicator_policy(self) -&gt; ChildIndicatorPolicyStr:\n\"\"\"Return current child indicator policy.\n\n    Returns:\n        child indicator policy\n    \"\"\"\n    return CHILD_INDICATOR_POLICY.inverse[self.childIndicatorPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_checkstate","title":"<code>set_checkstate(state: constants.StateStr, column: int = 0)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.StateStr</code> <p>checkstate to use</p> required <code>column</code> <code>int</code> <p>column</p> <code>0</code> <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>invalid checkstate</p> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>def set_checkstate(self, state: constants.StateStr, column: int = 0):\n\"\"\"Set checkstate of the checkbox.\n\n    Args:\n        state: checkstate to use\n        column: column\n\n    Raises:\n        InvalidParamError: invalid checkstate\n    \"\"\"\n    if state not in constants.STATE:\n        raise InvalidParamError(state, constants.STATE)\n    self.setCheckState(column, constants.STATE[state])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_child_indicator_policy","title":"<code>set_child_indicator_policy(policy: ChildIndicatorPolicyStr)</code>","text":"<p>Set the child indicator policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>ChildIndicatorPolicyStr</code> <p>child indicator policy</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>policy does not exist</p> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>def set_child_indicator_policy(self, policy: ChildIndicatorPolicyStr):\n\"\"\"Set the child indicator policy.\n\n    Args:\n        policy: child indicator policy\n\n    Raises:\n        InvalidParamError: policy does not exist\n    \"\"\"\n    if policy not in CHILD_INDICATOR_POLICY:\n        raise InvalidParamError(policy, CHILD_INDICATOR_POLICY)\n    self.setChildIndicatorPolicy(CHILD_INDICATOR_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_icon","title":"<code>set_icon(icon: datatypes.IconType, column: int = 0)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required <code>column</code> <code>int</code> <p>column</p> <code>0</code> Source code in <code>prettyqt\\widgets\\treewidgetitem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType, column: int = 0):\n\"\"\"Set the icon for the action.\n\n    Args:\n        icon: icon to use\n        column: column\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(column, icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.UndoView","title":"<code>UndoView</code>","text":"<p>         Bases: <code>widgets.ListViewMixin</code>, <code>QtWidgets.QUndoView</code></p> Source code in <code>prettyqt\\widgets\\undoview.py</code> <pre><code>class UndoView(widgets.ListViewMixin, QtWidgets.QUndoView):\n    def __getitem__(self, index: int) -&gt; QtGui.QUndoCommand:\n        return self.stack().command(index)\n\n    def set_clean_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the clean button.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setCleanIcon(icon)\n\n    def set_value(self, value: QtGui.QUndoGroup | QtGui.QUndoStack):\n        if isinstance(value, QtGui.QUndoGroup):\n            self.setGroup(value)\n        else:\n            self.setStack(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView.set_clean_icon","title":"<code>set_clean_icon(icon: datatypes.IconType)</code>","text":"<p>Set the icon for the clean button.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\undoview.py</code> <pre><code>def set_clean_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the clean button.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setCleanIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.WidgetMixin","title":"<code>WidgetMixin</code>","text":"<p>         Bases: <code>core.ObjectMixin</code></p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>class WidgetMixin(core.ObjectMixin):\n    box: QtWidgets.QLayout\n\n    def __repr__(self) -&gt; str:\n        return get_repr(self)\n\n    def resize(self, *size) -&gt; None:\n        if isinstance(size[0], tuple):\n            super().resize(*size[0])\n        else:\n            super().resize(*size)\n\n    def toggle_fullscreen(self):\n\"\"\"Toggle between fullscreen and regular size.\"\"\"\n        if self.isFullScreen():\n            self.showNormal()\n        else:\n            self.showFullScreen()\n\n    def toggle_maximized(self):\n\"\"\"Toggle between maximized and regular size.\"\"\"\n        if self.isMaximized():\n            self.showNormal()\n        else:\n            self.showMaximized()\n\n    def raise_to_top(self):\n        if sys.platform.startswith(\"win\"):\n            import win32con\n            from win32gui import SetWindowPos\n\n            # set to always-on-top and disable it again. that way windows stays in front\n            flag = win32con.SWP_NOMOVE | win32con.SWP_NOSIZE | win32con.SWP_SHOWWINDOW\n            win_id = self.winId()\n            SetWindowPos(win_id, win32con.HWND_TOPMOST, 0, 0, 0, 0, flag)\n            SetWindowPos(win_id, win32con.HWND_NOTOPMOST, 0, 0, 0, 0, flag)\n        # state = (self.windowState() &amp; ~Qt.WindowMinimized) | Qt.WindowActive\n        # self.setWindowState(state)\n        self.raise_()\n        self.show()\n        self.activateWindow()\n\n    def set_icon(self, icon: datatypes.IconType) -&gt; None:\n\"\"\"Set the window icon.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\n        self.setWindowIcon(icon)\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.windowIcon()\n        return None if icon.isNull() else gui.Icon(icon)\n\n    @functools.singledispatchmethod\n    def set_min_size(self, size: QtCore.QSize | tuple[int | None, int | None]) -&gt; None:\n        if isinstance(size, tuple):\n            x = 0 if size[0] is None else size[0]\n            y = 0 if size[1] is None else size[1]\n            self.setMinimumSize(x, y)\n        else:\n            self.setMinimumSize(size)\n\n    @set_min_size.register\n    def _(self, x: int, y: int | None):\n        self.set_min_size((x, y))\n\n    @set_min_size.register  # these can be merged when min py version is 3.11\n    def _(self, x: None, y: int | None):\n        self.set_min_size((x, y))\n\n    @functools.singledispatchmethod\n    def set_max_size(self, size: QtCore.QSize | tuple[int | None, int | None]) -&gt; None:\n        if isinstance(size, tuple):\n            x = QWIDGETSIZE_MAX if size[0] is None else size[0]\n            y = QWIDGETSIZE_MAX if size[1] is None else size[1]\n            self.setMaximumSize(x, y)\n        else:\n            self.setMaximumSize(size)\n\n    @set_max_size.register\n    def _(self, x: int, y: int | None):\n        self.set_max_size((x, y))\n\n    @set_max_size.register  # these can be merged when min py version is 3.11\n    def _(self, x: None, y: int | None):\n        self.set_max_size((x, y))\n\n    def set_min_width(self, width: int | None) -&gt; None:\n        if width is None:\n            width = 0\n        self.setMinimumWidth(width)\n\n    def set_max_width(self, width: int | None) -&gt; None:\n        if width is None:\n            width = QWIDGETSIZE_MAX\n        self.setMaximumWidth(width)\n\n    def set_min_height(self, height: int | None) -&gt; None:\n        if height is None:\n            height = 0\n        self.setMinimumHeight(height)\n\n    def set_max_height(self, height: int | None) -&gt; None:\n        if height is None:\n            height = QWIDGETSIZE_MAX\n        self.setMaximumHeight(height)\n\n    def set_enabled(self, enabled: bool = True) -&gt; None:\n        self.setEnabled(enabled)\n\n    def set_disabled(self) -&gt; None:\n        self.setEnabled(False)\n\n    def set_title(self, title: str) -&gt; None:\n        self.setWindowTitle(title)\n\n    def get_title(self) -&gt; str:\n        return self.windowTitle()\n\n    def set_tooltip(\n        self,\n        tooltip: str | datatypes.PathType,\n        size: datatypes.SizeType | None = None,\n    ):\n        if isinstance(tooltip, os.PathLike):\n            path = os.fspath(tooltip)\n            if size is None:\n                tooltip = f\"&lt;img src={path!r}&gt;\"\n            else:\n                if isinstance(size, QtCore.QSize):\n                    size = (size.width(), size.height())\n                tooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\n        self.setToolTip(tooltip)\n\n    def set_font(\n        self,\n        font_name: str | None = None,\n        font_size: int | None = None,\n        weight: int | None = None,\n        italic: bool = False,\n    ) -&gt; gui.Font:\n        if font_size is None:\n            font_size = -1\n        if weight is None:\n            weight = -1\n        if font_name is None:\n            font_name = self.font().family()\n        font = gui.Font(font_name, font_size, weight, italic)\n        self.setFont(font)\n        return font\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_foreground_role(self) -&gt; gui.palette.RoleStr:\n        return gui.palette.ROLE.inverse[self.foregroundRole()]\n\n    def set_foreground_role(self, role: gui.palette.RoleStr):\n        if role not in gui.palette.ROLE:\n            raise InvalidParamError(role, gui.palette.ROLE)\n        self.setForegroundRole(gui.palette.ROLE[role])\n\n    def get_background_role(self) -&gt; gui.palette.RoleStr:\n        return gui.palette.ROLE.inverse[self.backgroundRole()]\n\n    def set_background_role(self, role: gui.palette.RoleStr):\n        if role not in gui.palette.ROLE:\n            raise InvalidParamError(role, gui.palette.ROLE)\n        self.setBackgroundRole(gui.palette.ROLE[role])\n\n    def set_window_flags(self, *flags: constants.WindowFlagStr, append: bool = False):\n        for flag in flags:\n            if flag not in constants.WINDOW_FLAGS:\n                raise InvalidParamError(flag, constants.WINDOW_FLAGS)\n        result = helpers.merge_flags(flags, constants.WINDOW_FLAGS)\n        if append:\n            result = result | self.windowFlags()\n        self.setWindowFlags(result)\n\n    def set_flags(\n        self,\n        minimize: bool | None = None,\n        maximize: bool | None = None,\n        close: bool | None = None,\n        stay_on_top: bool | None = None,\n        frameless: bool | None = None,\n        window: bool | None = None,\n        dialog: bool | None = None,\n        tooltip: bool | None = None,\n        tool: bool | None = None,\n        customize: bool | None = None,\n        window_title: bool | None = None,\n    ) -&gt; None:\n        flags = {\n            minimize: QtCore.Qt.WindowType.WindowMinimizeButtonHint,\n            maximize: QtCore.Qt.WindowType.WindowMaximizeButtonHint,\n            close: QtCore.Qt.WindowType.WindowCloseButtonHint,\n            stay_on_top: QtCore.Qt.WindowType.WindowStaysOnTopHint,\n            frameless: QtCore.Qt.WindowType.FramelessWindowHint,\n            window: QtCore.Qt.WindowType.Window,\n            dialog: QtCore.Qt.WindowType.Dialog,\n            tooltip: QtCore.Qt.WindowType.ToolTip,\n            tool: QtCore.Qt.WindowType.Tool,\n            customize: QtCore.Qt.WindowType.CustomizeWindowHint,\n            window_title: QtCore.Qt.WindowType.WindowTitleHint,\n        }\n        for k, v in flags.items():\n            if k is not None:\n                self.setWindowFlag(v, k)\n\n    def set_attribute(\n        self, attribute: constants.WidgetAttributeStr, state: bool = True\n    ) -&gt; None:\n        if attribute not in constants.WIDGET_ATTRIBUTE:\n            raise InvalidParamError(attribute, constants.WIDGET_ATTRIBUTE)\n        self.setAttribute(constants.WIDGET_ATTRIBUTE[attribute], state)\n\n    def set_attributes(self, **kwargs: bool) -&gt; None:\n        for attr, state in kwargs.items():\n            if attr not in constants.WIDGET_ATTRIBUTE:\n                raise InvalidParamError(attr, constants.WIDGET_ATTRIBUTE)\n            self.setAttribute(constants.WIDGET_ATTRIBUTE[attr], state)  # type: ignore\n\n    def set_modality(self, modality: constants.ModalityStr) -&gt; None:\n\"\"\"Set modality for the dialog.\n\n        Args:\n            modality: modality for the main window\n\n        Raises:\n            InvalidParamError: modality type does not exist\n        \"\"\"\n        if modality not in constants.MODALITY:\n            raise InvalidParamError(modality, constants.MODALITY)\n        self.setWindowModality(constants.MODALITY[modality])\n\n    def get_modality(self) -&gt; constants.ModalityStr:\n\"\"\"Get the current modality modes as a string.\n\n        Returns:\n            modality mode\n        \"\"\"\n        return constants.MODALITY.inverse[self.windowModality()]\n\n    def set_size_policy(\n        self,\n        horizontal: widgets.sizepolicy.SizePolicyStr | None = None,\n        vertical: widgets.sizepolicy.SizePolicyStr | None = None,\n    ) -&gt; None:\n\"\"\"Set the sizes policy.\n\n        Args:\n            horizontal: horizontal size policy\n            vertical: vertical size policy\n        \"\"\"\n        sp = self.get_size_policy()\n        if horizontal is not None:\n            sp.set_horizontal_policy(horizontal)\n        if vertical is not None:\n            sp.set_vertical_policy(vertical)\n        self.setSizePolicy(sp)\n\n    def get_size_policy(self) -&gt; widgets.SizePolicy:\n        qpol = self.sizePolicy()\n        if isinstance(qpol, widgets.SizePolicy):\n            return qpol\n        return widgets.SizePolicy.clone(qpol)\n\n    def get_palette(self) -&gt; gui.Palette:\n        return gui.Palette(self.palette())\n\n    def set_background_color(self, color: datatypes.ColorType) -&gt; None:\n        col_str = \"\" if color is None else colors.get_color(color).name()\n        with self.edit_stylesheet() as ss:\n            ss.backgroundColor.setValue(col_str)\n\n    @contextlib.contextmanager\n    def grab_mouse_events(\n        self, cursor_shape: constants.CursorShapeStr | None = None\n    ) -&gt; Iterator[None]:\n        if cursor_shape is not None:\n            self.grabMouse(constants.CURSOR_SHAPE[cursor_shape])\n        else:\n            self.grabMouse()\n        yield None\n        self.releaseMouse()\n\n    @contextlib.contextmanager\n    def grab_keyboard_events(self) -&gt; Iterator[None]:\n        self.grabKeyboard()\n        yield None\n        self.releaseKeyboard()\n\n    @contextlib.contextmanager\n    def updates_off(self) -&gt; Iterator[None]:\n        updates = self.updatesEnabled()\n        self.setUpdatesEnabled(False)\n        yield None\n        self.setUpdatesEnabled(updates)\n\n    @contextlib.contextmanager\n    def edit_stylesheet(self) -&gt; Iterator[qstylizer.style.StyleSheet]:\n        ss = self.get_stylesheet()\n        yield ss\n        self.set_stylesheet(ss)\n\n    def set_stylesheet(\n        self, ss: None | str | qstylizer.style.StyleSheet | datatypes.PathType\n    ):\n        match ss:\n            case None:\n                ss = \"\"\n            case os.PathLike():\n                ss = pathlib.Path(ss).read_text()\n            case qstylizer.style.StyleSheet():\n                ss = str(ss)\n        self.setStyleSheet(ss)\n\n    def get_stylesheet(self) -&gt; qstylizer.style.StyleSheet:\n        try:\n            return qstylizer.parser.parse(self.styleSheet())\n        except ValueError:\n            return qstylizer.style.StyleSheet()\n\n    @contextlib.contextmanager\n    def edit_palette(self) -&gt; Iterator[gui.Palette]:\n        palette = gui.Palette(self.palette())\n        yield palette\n        self.setPalette(palette)\n\n    @contextlib.contextmanager\n    def edit_font(self) -&gt; Iterator[gui.Font]:\n        font = gui.Font(self.font())\n        yield font\n        self.setFont(font)\n\n    @deprecated(reason=\"This context manager is deprecated, use edit_font instead.\")\n    @contextlib.contextmanager\n    def current_font(self) -&gt; Iterator[gui.Font]:\n        with self.edit_font() as font:\n            yield font\n\n    @deprecated(reason=\"This method is deprecated, use set_context_menu_policy instead.\")\n    def set_contextmenu_policy(self, policy: constants.ContextPolicyStr) -&gt; None:\n        return self.set_context_menu_policy(policy)\n\n    def set_context_menu_policy(self, policy: constants.ContextPolicyStr) -&gt; None:\n\"\"\"Set contextmenu policy for given item view.\n\n        Args:\n            policy: contextmenu policy to use\n\n        Raises:\n            InvalidParamError: policy does not exist\n        \"\"\"\n        if policy not in constants.CONTEXT_POLICY:\n            raise InvalidParamError(policy, constants.CONTEXT_POLICY)\n        self.setContextMenuPolicy(constants.CONTEXT_POLICY[policy])\n\n    @deprecated(reason=\"This method is deprecated, use get_context_menu_policy instead.\")\n    def get_contextmenu_policy(self) -&gt; constants.ContextPolicyStr:\n\"\"\"Return current contextmenu policy.\n\n        Returns:\n            contextmenu policy\n        \"\"\"\n        return self.get_context_menu_policy()\n\n    def get_context_menu_policy(self) -&gt; constants.ContextPolicyStr:\n\"\"\"Return current contextmenu policy.\n\n        Returns:\n            contextmenu policy\n        \"\"\"\n        return constants.CONTEXT_POLICY.inverse[self.contextMenuPolicy()]\n\n    def set_window_state(self, policy: constants.WindowStateStr) -&gt; None:\n\"\"\"Set window state for given item view.\n\n        Args:\n            policy: window state to use\n\n        Raises:\n            InvalidParamError: policy does not exist\n        \"\"\"\n        if policy not in constants.WINDOW_STATES:\n            raise InvalidParamError(policy, constants.WINDOW_STATES)\n        self.setWindowState(constants.WINDOW_STATES[policy])\n\n    def get_window_state(self) -&gt; constants.WindowStateStr:\n\"\"\"Return current window state.\n\n        Returns:\n            window state\n        \"\"\"\n        return constants.WINDOW_STATES.inverse[self.windowState()]\n\n    def set_custom_menu(self, method: Callable) -&gt; None:\n        self.set_context_menu_policy(\"custom\")\n        self.customContextMenuRequested.connect(method)\n\n    def set_layout(\n        self,\n        layout: LayoutStr | QtWidgets.QLayout | None,\n        margin: int | None = None,\n        spacing: int | None = None,\n    ):\n        if layout is None:\n            return\n        match layout:\n            case \"horizontal\" | \"vertical\":\n                self.box = widgets.BoxLayout(layout)\n            case \"grid\":\n                self.box = widgets.GridLayout()\n            case \"form\":\n                self.box = widgets.FormLayout()\n            case \"stacked\":\n                self.box = widgets.StackedLayout()\n            case \"flow\":\n                from prettyqt import custom_widgets\n\n                self.box = custom_widgets.FlowLayout()\n            case QtWidgets.QLayout():\n                self.box = layout\n            case _:\n                raise ValueError(\"Invalid Layout\")\n        self.setLayout(self.box)\n        if margin is not None:\n            self.box.set_margin(margin)\n        if spacing is not None:\n            self.box.setSpacing(spacing)\n\n    def center(self, screen: int = 0) -&gt; None:\n        qr = self.frameGeometry()\n        cp = gui.GuiApplication.screens()[screen].geometry().center()\n        qr.moveCenter(cp)\n        self.move(qr.topLeft())\n\n    def set_cursor(self, cursor: constants.CursorShapeStr | QtGui.QCursor) -&gt; None:\n        if isinstance(cursor, QtGui.QCursor):\n            curs = cursor\n        elif cursor in constants.CURSOR_SHAPE:\n            curs = gui.Cursor(constants.CURSOR_SHAPE[cursor])\n        else:\n            raise InvalidParamError(cursor, constants.CURSOR_SHAPE)\n        self.setCursor(curs)\n\n    def set_focus_policy(self, policy: constants.FocusPolicyStr) -&gt; None:\n\"\"\"Set the way the widget accepts keyboard focus.\n\n        Args:\n            policy (str): Focus policy\n\n        Raises:\n            InvalidParamError: Description\n        \"\"\"\n        if policy not in constants.FOCUS_POLICY:\n            raise InvalidParamError(policy, constants.FOCUS_POLICY)\n        self.setFocusPolicy(constants.FOCUS_POLICY[policy])\n\n    def get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return waay the widget accepts keyboard focus.\n\n        Returns:\n            str: Focus policy\n        \"\"\"\n        return constants.FOCUS_POLICY.inverse[self.focusPolicy()]\n\n    def set_font_size(self, size: int) -&gt; None:\n        font = self.font()\n        font.setPointSize(size)\n        self.setFont(font)\n\n    @deprecated(reason=\"This method is deprecated, use get_font_metrics instead.\")\n    def font_metrics(self) -&gt; gui.FontMetrics:\n        return self.get_font_metrics()\n\n    def get_font_metrics(self) -&gt; gui.FontMetrics:\n        return gui.FontMetrics(self.fontMetrics())\n\n    def get_font_info(self) -&gt; gui.FontInfo:\n        return gui.FontInfo(self.fontInfo())\n\n    def set_margin(self, margin: int) -&gt; None:\n        self.setContentsMargins(margin, margin, margin, margin)\n\n    def raise_dock(self) -&gt; bool:\n        w = self.find_parent(QtWidgets.QDockWidget)\n        if w is None:\n            return False\n        w.setVisible(True)\n        w.raise_()\n        return True\n\n    def set_mask(\n        self,\n        area: datatypes.RectType | QtGui.QRegion | None,\n        typ: gui.region.RegionTypeStr = \"rectangle\",\n    ):\n        match area:\n            case None:\n                self.clearMask()\n                return\n            case tuple():\n                area = gui.Region(*area, gui.region.REGION_TYPE[typ])\n            case QtCore.QRect():\n                area = gui.Region(area, gui.region.REGION_TYPE[typ])\n        self.setMask(area)\n\n    def set_window_file_path(self, path: datatypes.PathType):\n        self.setWindowFilePath(os.fspath(path))\n\n    def get_window_file_path(self) -&gt; pathlib.Path | None:\n        path = self.windowFilePath()\n        return pathlib.Path(path) if path else None\n\n    def get_image(self) -&gt; QtGui.QPixmap:\n        image = self.grab()\n        if gl_widget := self.find_child(QtWidgets.QOpenGLWidget):\n            d = gl_widget.mapToGlobal(core.Point()) - self.mapToGlobal(core.Point())\n            with gui.Painter(image) as painter:\n                painter.set_composition_mode(\"source_atop\")\n                painter.drawImage(d, gl_widget.grabFramebuffer())\n        return image\n\n    def get_screen(self) -&gt; gui.Screen | None:\n        window = self.window().windowHandle()\n        return None if window is None else gui.Screen(window.screen())\n\n    def delete_children(self):\n\"\"\"Delete all children of the specified QObject.\"\"\"\n        if hasattr(self, \"clear\"):\n            return self.clear()\n        layout = self.layout()\n        while layout.count():\n            item = layout.takeAt(0)\n            if widget := item.widget():\n                widget.deleteLater()\n            else:\n                self.delete_children(item.layout())\n\n    def get_cursor(self) -&gt; gui.Cursor:\n        return gui.Cursor(self.cursor())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.delete_children","title":"<code>delete_children()</code>","text":"<p>Delete all children of the specified QObject.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def delete_children(self):\n\"\"\"Delete all children of the specified QObject.\"\"\"\n    if hasattr(self, \"clear\"):\n        return self.clear()\n    layout = self.layout()\n    while layout.count():\n        item = layout.takeAt(0)\n        if widget := item.widget():\n            widget.deleteLater()\n        else:\n            self.delete_children(item.layout())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_context_menu_policy","title":"<code>get_context_menu_policy() -&gt; constants.ContextPolicyStr</code>","text":"<p>Return current contextmenu policy.</p> <p>Returns:</p> Type Description <code>constants.ContextPolicyStr</code> <p>contextmenu policy</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_context_menu_policy(self) -&gt; constants.ContextPolicyStr:\n\"\"\"Return current contextmenu policy.\n\n    Returns:\n        contextmenu policy\n    \"\"\"\n    return constants.CONTEXT_POLICY.inverse[self.contextMenuPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_contextmenu_policy","title":"<code>get_contextmenu_policy() -&gt; constants.ContextPolicyStr</code>","text":"<p>Return current contextmenu policy.</p> <p>Returns:</p> Type Description <code>constants.ContextPolicyStr</code> <p>contextmenu policy</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>@deprecated(reason=\"This method is deprecated, use get_context_menu_policy instead.\")\ndef get_contextmenu_policy(self) -&gt; constants.ContextPolicyStr:\n\"\"\"Return current contextmenu policy.\n\n    Returns:\n        contextmenu policy\n    \"\"\"\n    return self.get_context_menu_policy()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_focus_policy","title":"<code>get_focus_policy() -&gt; constants.FocusPolicyStr</code>","text":"<p>Return waay the widget accepts keyboard focus.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>constants.FocusPolicyStr</code> <p>Focus policy</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return waay the widget accepts keyboard focus.\n\n    Returns:\n        str: Focus policy\n    \"\"\"\n    return constants.FOCUS_POLICY.inverse[self.focusPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_modality","title":"<code>get_modality() -&gt; constants.ModalityStr</code>","text":"<p>Get the current modality modes as a string.</p> <p>Returns:</p> Type Description <code>constants.ModalityStr</code> <p>modality mode</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_modality(self) -&gt; constants.ModalityStr:\n\"\"\"Get the current modality modes as a string.\n\n    Returns:\n        modality mode\n    \"\"\"\n    return constants.MODALITY.inverse[self.windowModality()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_window_state","title":"<code>get_window_state() -&gt; constants.WindowStateStr</code>","text":"<p>Return current window state.</p> <p>Returns:</p> Type Description <code>constants.WindowStateStr</code> <p>window state</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def get_window_state(self) -&gt; constants.WindowStateStr:\n\"\"\"Return current window state.\n\n    Returns:\n        window state\n    \"\"\"\n    return constants.WINDOW_STATES.inverse[self.windowState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_context_menu_policy","title":"<code>set_context_menu_policy(policy: constants.ContextPolicyStr) -&gt; None</code>","text":"<p>Set contextmenu policy for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>constants.ContextPolicyStr</code> <p>contextmenu policy to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>policy does not exist</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_context_menu_policy(self, policy: constants.ContextPolicyStr) -&gt; None:\n\"\"\"Set contextmenu policy for given item view.\n\n    Args:\n        policy: contextmenu policy to use\n\n    Raises:\n        InvalidParamError: policy does not exist\n    \"\"\"\n    if policy not in constants.CONTEXT_POLICY:\n        raise InvalidParamError(policy, constants.CONTEXT_POLICY)\n    self.setContextMenuPolicy(constants.CONTEXT_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_focus_policy","title":"<code>set_focus_policy(policy: constants.FocusPolicyStr) -&gt; None</code>","text":"<p>Set the way the widget accepts keyboard focus.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>str</code> <p>Focus policy</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>Description</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_focus_policy(self, policy: constants.FocusPolicyStr) -&gt; None:\n\"\"\"Set the way the widget accepts keyboard focus.\n\n    Args:\n        policy (str): Focus policy\n\n    Raises:\n        InvalidParamError: Description\n    \"\"\"\n    if policy not in constants.FOCUS_POLICY:\n        raise InvalidParamError(policy, constants.FOCUS_POLICY)\n    self.setFocusPolicy(constants.FOCUS_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_icon","title":"<code>set_icon(icon: datatypes.IconType) -&gt; None</code>","text":"<p>Set the window icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType) -&gt; None:\n\"\"\"Set the window icon.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\n    self.setWindowIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_modality","title":"<code>set_modality(modality: constants.ModalityStr) -&gt; None</code>","text":"<p>Set modality for the dialog.</p> <p>Parameters:</p> Name Type Description Default <code>modality</code> <code>constants.ModalityStr</code> <p>modality for the main window</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>modality type does not exist</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_modality(self, modality: constants.ModalityStr) -&gt; None:\n\"\"\"Set modality for the dialog.\n\n    Args:\n        modality: modality for the main window\n\n    Raises:\n        InvalidParamError: modality type does not exist\n    \"\"\"\n    if modality not in constants.MODALITY:\n        raise InvalidParamError(modality, constants.MODALITY)\n    self.setWindowModality(constants.MODALITY[modality])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_size_policy","title":"<code>set_size_policy(horizontal: widgets.sizepolicy.SizePolicyStr | None = None, vertical: widgets.sizepolicy.SizePolicyStr | None = None) -&gt; None</code>","text":"<p>Set the sizes policy.</p> <p>Parameters:</p> Name Type Description Default <code>horizontal</code> <code>widgets.sizepolicy.SizePolicyStr | None</code> <p>horizontal size policy</p> <code>None</code> <code>vertical</code> <code>widgets.sizepolicy.SizePolicyStr | None</code> <p>vertical size policy</p> <code>None</code> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_size_policy(\n    self,\n    horizontal: widgets.sizepolicy.SizePolicyStr | None = None,\n    vertical: widgets.sizepolicy.SizePolicyStr | None = None,\n) -&gt; None:\n\"\"\"Set the sizes policy.\n\n    Args:\n        horizontal: horizontal size policy\n        vertical: vertical size policy\n    \"\"\"\n    sp = self.get_size_policy()\n    if horizontal is not None:\n        sp.set_horizontal_policy(horizontal)\n    if vertical is not None:\n        sp.set_vertical_policy(vertical)\n    self.setSizePolicy(sp)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_window_state","title":"<code>set_window_state(policy: constants.WindowStateStr) -&gt; None</code>","text":"<p>Set window state for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>constants.WindowStateStr</code> <p>window state to use</p> required <p>Raises:</p> Type Description <code>InvalidParamError</code> <p>policy does not exist</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def set_window_state(self, policy: constants.WindowStateStr) -&gt; None:\n\"\"\"Set window state for given item view.\n\n    Args:\n        policy: window state to use\n\n    Raises:\n        InvalidParamError: policy does not exist\n    \"\"\"\n    if policy not in constants.WINDOW_STATES:\n        raise InvalidParamError(policy, constants.WINDOW_STATES)\n    self.setWindowState(constants.WINDOW_STATES[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.toggle_fullscreen","title":"<code>toggle_fullscreen()</code>","text":"<p>Toggle between fullscreen and regular size.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def toggle_fullscreen(self):\n\"\"\"Toggle between fullscreen and regular size.\"\"\"\n    if self.isFullScreen():\n        self.showNormal()\n    else:\n        self.showFullScreen()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.toggle_maximized","title":"<code>toggle_maximized()</code>","text":"<p>Toggle between maximized and regular size.</p> Source code in <code>prettyqt\\widgets\\widget.py</code> <pre><code>def toggle_maximized(self):\n\"\"\"Toggle between maximized and regular size.\"\"\"\n    if self.isMaximized():\n        self.showNormal()\n    else:\n        self.showMaximized()\n</code></pre>"}]}