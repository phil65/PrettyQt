{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"prettyqt: Pythonic layer on top of PyQt5 / PyQt6 / PySide6 What is it? PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PyQt6 / PySide6. Main Features Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module. Where to get it The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt Dependencies bidict orjson regex docutils Installation from sources This project uses poetry for dependency management and packaging. Install this first. In the prettyqt directory (same one where you found this file after cloning the git repo), execute: poetry install License MIT Documentation The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/ Contributing to prettyqt All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Home"},{"location":"index.html#prettyqt-pythonic-layer-on-top-of-pyqt5-pyqt6-pyside6","text":"","title":"prettyqt: Pythonic layer on top of PyQt5 / PyQt6 / PySide6"},{"location":"index.html#what-is-it","text":"PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PyQt6 / PySide6.","title":"What is it?"},{"location":"index.html#main-features","text":"Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module.","title":"Main Features"},{"location":"index.html#where-to-get-it","text":"The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt","title":"Where to get it"},{"location":"index.html#dependencies","text":"bidict orjson regex docutils","title":"Dependencies"},{"location":"index.html#installation-from-sources","text":"This project uses poetry for dependency management and packaging. Install this first. In the prettyqt directory (same one where you found this file after cloning the git repo), execute: poetry install","title":"Installation from sources"},{"location":"index.html#license","text":"MIT","title":"License"},{"location":"index.html#documentation","text":"The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/","title":"Documentation"},{"location":"index.html#contributing-to-prettyqt","text":"All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Contributing to prettyqt"},{"location":"changelog.html","text":"v0.192.1 (2022-11-12) Fix disable BaseModelMixin test for now v0.192.0 (2022-11-12) Feat custom_models : add BaseListMixin class v0.191.0 (2022-11-10) Feat custom_models : add BaseModelMixin class v0.190.8 (2022-11-09) Fix better check for combobox set_editable method v0.190.7 (2022-11-08) Fix Combobox : set Completer only when calling set_editable to avoid error message v0.190.6 (2022-11-03) Fix proper fix for restoreState v0.190.5 (2022-11-03) Fix allow str for restoreState v0.190.4 (2022-11-03) Fix qt compat some compat fixes qt6 flag compat qt6 compat v0.190.3 (2022-06-30) Fix bump regex dep v0.190.2 (2022-04-07) Fix scxml not available for PyQt5 v0.190.1 (2022-04-06) Fix regex fix v0.190.0 (2022-04-06) Feat Application : add sleep method add scxml module v0.189.0 (2021-12-31) Feat XmlStreamReader : add get_token_type / read_next methods Rect : add margins_added / margins_removed methods TextDocument : add show_whitespaces_and_tabs method Chart : add set_margins method core : add XmlStreamReader class Size/SizeF : add shrunk_by / grown_by methods StandardItem/ListWidgetItem/TreeWidgetItem : add set_size_hint method Polygon/PolygonF : add get_data_buffer method ListWidgetItem : add set_data method Window/Widget : add get_screen method Fix typo for DateType CompletionWidget : correctly cast to int for SetY v0.188.0 (2021-12-14) Feat add JsonModel class Translator : add for_system_language method StyleOptionToolBox : add get/set_selected_position methods Widget : add screen param to center method Url : add from_local_file method custom_widgets : add CompletionWidget class TextDocument/TextDocumentFragment : add write_to_file method Font : add set_family method gui : add TextDocumentWriter class TextCursor : add get_selection method Mimedata : add set_svg_data / set_path_data gui : add TextDocumentFragment class ListWidet : add find_items method SpacerItem : add get_size_policy method custom_validators : add IntegerValidator class v0.187.2 (2021-11-18) Fix fix import for non-windows v0.187.1 (2021-11-18) Fix add FramelessWindow to init .py v0.187.0 (2021-11-18) Feat Pixmap : add get_image_data_url method FramelessWindow : make AeroSnap work custom_widgets : add JoystickButton class Add SvgBufferIconEngine class FontDatabase : keep track of font paths Style : add draw_control method Icon : add from_char method Pixmap : add create_char method Fix fix ProgressBarDelegate orientation for Qt6 v0.186.0 (2021-11-11) Feat WebEnginePage : add some more methods Color : add get_name method iconprovider : add dir and getattr methods to iconsets TextDocument : add some more methods TextBlock : add str method Process : add get_process_environment method qml : add clear_type_registrations method FileIconProvider : support os.PathLike for get_icon custom_widgets : add SubsequenceCompleter class Completer : add set/is_case_sensitive methods custom_models : add SubsequenceSortFilterProxyModel class SortFilterProxyModel : add set_sort_role method v0.185.0 (2021-11-04) Feat add QT_VERSION var to qt module Fix core : dont shadow builtin libraries v0.184.0 (2021-10-30) Feat qt : add flag_to_int method debugging : add is_deleted fn TextEdit : add get_text_cursor method PlainTextEdit : add get_text_cursor method better package support by using importlib.resources for resource files add qt.set_env_vars fallback to installed qt package in case environment var QT_API is invalid / empty TextBlock : add some methods related to syntax highlighting HeaderView : add section_resized_by_user signal Widget : add resized signal add StandardIconsWidget class TextCursor : add get_cursor_position method SyntaxHighlighter : add get_current_block / get_format Process : add edit_environment method Widget : rename get/set_context_menu_policy methods TextLayout : add get_text_option method TextDocument : add some more methods TextCursor : add str method StandardItemModel : add create_single_item_model classmethod ProcessEnvironment : add update() / items() methods Color : add drift_color classmethod PlaintextEdit : TextDocument by default PlainTextEdit : add show_whitespace_and_tabs method add mimetype_icon fn for FileIconProvider Add MenuRecentFiles class update iconsets Fix TextCursor : correctly convert EOL in str qt6 flag fix typo in AwesomeFileIconProvider v0.183.6 (2021-10-26) Fix more qt compat stuff generate docs on py3.9 v0.183.5 (2021-10-12) Fix only test on 3.9 / macos10 v0.183.4 (2021-10-12) Fix dont use poetry pre version v0.183.3 (2021-10-12) Fix qt6 compat some flag fixes v0.183.2 (2021-02-05) Fix another try to fix docs generation v0.183.1 (2021-02-05) Fix fix docs generation v0.183.0 (2021-02-05) Feat JSEngine : add eval method Pixmap : add rotated method ColorDialog : add replace_qcolorshowlabel JSValue : add call method PlainTextEdit : add some more methods core : add Slot method core : add Mutex/Semaphore classes LineEdit : add some signals svg : add SvgWidget class Fix correctly keep state when using block_signals / updates_off context managers v0.182.1 (2021-01-26) Fix colors fix v0.182.0 (2021-01-26) Feat Image : add invert_pixels method Color : invert_alpha param for inverted method MetaObject : type_filter kwarg for get_methods core : add MetaProperty class MetaObject : include_super param for get_ methods ItemEditorFactory : add property_name kwarg to register_editor method TabWidget : add update_tab_bar_visibility method Pixmap : add from_image method MessageBox : add some constants MessageBox : add set_escape/default_button methods MessageBox : add get_icon_pixmap method svg : add SvgRenderer class Image : add from_ndarray method v0.181.0 (2021-01-23) Feat Color : add is_dark and inverted methods Dir : add set_search_paths method Palette : add inverted method Dir : add add_search_path method core : add AbstractNativeEventFilter v0.180.0 (2021-01-20) Feat TextDocument : add some methods related to default stylesheet editing PygmentsHighlighter : add repr method PygmentsHighlighter : add style kwarg QtCore : add QClassInfo for PyQt5/6 colors : add interpolate_text_colors fn Color : add from_hsv method gui : add Drag class DataWidgetMapper : add get_mapped_property_name method DataWidgetMapper : add add_mapping method v0.179.0 (2021-01-18) Fix RegexInput flags fix ModelTester : correctly disconnect model Feat Painter : more kwargs for set_pen method Pen : allow custom dash pattern for set_style ItemEditorFactory : add register_default_editor method GraphicsItem : add set_scale method Pixmap : add create_checkerboard_pattern method ColorDialog : add get_qcolorshower/get_qcolorshowlabel methods TableWidgetItem : add set_tooltip method v0.178.0 (2021-01-14) Feat IODevice : add len method EventLoop : throw exception when running twice Color : add to_qsscolor method Color : add interpolate_color method Locale : add get_system_locale / get_system_language methods use subclassed ItemEditorFactory as default factory v0.177.1 (2021-01-13) Fix test fix v0.177.0 (2021-01-13) Feat allow args for app() methods v0.176.0 (2021-01-13) Feat Timer : add start_timer method Timer : add set_interval method allow os.PathLike for using images in set_tooltip methods Movie : add get_supported_formats method iconprovider : add AwesomeQuickImageProvider class iconprovider : add AwesomeFileIconProvider class v0.175.0 (2021-01-12) Feat add prettyqtest qml : add register_qml_type method AbstractSlider : add set_auto_scroll_to_end method GuiApplication : add edit_palette context manager Dir : add get_entry_list method v0.174.0 (2021-01-11) Feat core : add FileSelector class Dir : add get_entry_info_list method Resource : add set/get_file_name and register_resource methods Application : add get_available_themes method v0.173.0 (2021-01-10) Fix correct icon color for dark mode Feat custom_models : add StorageInfoModel class DataStream : add get/set_status methods custom_widgets : add ElidedLabel class Painter : add get_font_metrics method gui : add TextLayout class add SyncedProperty class Widget : add get/set_window_file_path methods widgets : add SplitterHandle class v0.172.0 (2021-01-09) Feat Application : add set_theme method gui : add TextObjectInterface class PyQt5 : import QEnum and QFlag classes core : add MetaMethod/MetaObject classes widgets : add FocusFrame class quick : add Quick(Async)ImageProvider classes QmlEngine : add some more methods QmlApplicationEngine : add load_file method v0.171.1 (2021-01-07) Fix comment out some event constants v0.171.0 (2021-01-07) Feat GraphicsItem : add get/set_cache_mode methods GraphicsPixmapItem : some additional methods custom_widgets : add BorderLayout class widgets : add WidgetItem class LayoutItem : add get_item method LayoutItem : add get/set_alignment methods Style : add draw_primitive method StyleOption : add based_on method Fix AutoSlot : use typing.get_type_hints v0.170.0 (2021-01-05) Feat Validators : also allow Pattern for set_regex add tile rule constant add SingleApplication class custom_widgets : add Notification class TreeWidget : add contains method HelpContentWidget : add index_of method add contains method to some widgets ItemEditorFactory : add register_editor method widgets : add ItemEditorCreatorBase / ItemEditorFactory types : add Variant(Type) VariantAnimation : add set_range method TextStream : add read_lines method TextStream : add set_codec method v0.169.0 (2021-01-04) Feat RegularExpressionMatch : add get_match_type method CoreApplication : allow more types for version metadata Windows : add workaround for raising window network : add LocalSocket class Fix CoreApplication : fix setting metadata v0.168.0 (2021-01-03) Feat eventfilters : add AnimatedToolTipEventFilter class Widget : tooltip kwarg for set_flags method AbstractAnimation : add restart_animation method add custom_animations module AbstractAnimation : implement and and or Dir : some additional methods v0.167.0 (2021-01-02) Feat FileSystemModel : add get_file_info and get_file_path methods add fspath to Dir and FileInfo classes v0.166.1 (2021-01-01) Fix localization fixups v0.166.0 (2020-12-31) Feat CoreApplication : add get_available_languages and load_language methods v0.165.0 (2020-12-31) Feat WebEngineView : add register_as_browser method WebEngineView : ass some settings-related methods Translator : add load_file method add FramelessWindow class add webchannel module qt : add QtWebchannel module widgets : add FileIconProvider class add prettyqt.qt.QtUiTools module v0.164.0 (2020-12-29) Feat CoreApplication : add restart method Fix FontDatabase : make get_system_font a classmethod ObjectBrowser signal fix for Qt6 PdfWriter : correctly inherit from Object and PagedPaintDevice v0.163.0 (2020-12-27) Feat OperatingsystemVersion : add eq and hash methods VersionNumber : add hash method FontDatabase : add optional md5 check for add_font Fix revert CharIconPainter paint method for now v0.162.0 (2020-12-27) Feat FontDatabase : add additional check in add_font Painter : add offset_by and apply_transform context managers Fix IconWidget : update when setting size v0.161.0 (2020-12-26) Feat LineEdit : add add_action method ListView/TableView : add some more setters / getters Painter : add edit_pen context manager PolygonF : alternative ctors for diamond / star creation Fix LabeledSlider : call adjust_margins on correct object correct IconProvider init v0.160.0 (2020-12-25) Feat gui : add TextLine module Doublevalidator : add set_range method IntValidator : add set_range method Pixmap : add eq method v0.159.0 (2020-12-24) Feat LineEdit : add set/get_cursor_move_style methods v0.158.0 (2020-12-22) Feat iconprovider : add reset_cache method Widget : add set/get_foreground/background_role methods Application/Widget : add set/get_stylesheet methods Application : add edit_stylesheet context manager v0.157.1 (2020-12-22) Fix SpanSlider fix v0.157.0 (2020-12-22) Feat Painter : add native_mode context manager FontDatabase : add add_font method gui : add IconEngine class TabWidget : add set_icon_size method Icon : allow more types for size param v0.156.0 (2020-12-21) Feat RegularExpressionMatch : add bool method custom_widgets : add ObjectBrowser class Timer : add restart method ListView : add set_grid_size method SortFilterProxyModel : add is/set_filter_case_sensitive methods AbstractItemView : add set_icon_size method v0.155.0 (2020-12-20) Feat Label : add get_horizontal/vertical_alignment methods GraphicsWidget : add window_frame_section_at method v0.154.0 (2020-12-18) Feat add QtLocation and QtHelp to qt submodule Dir/FileDialog : add get/set_filter methods InputDialog : add get/set_input_mode and get/set_text_echo_mode methods Fix correct StarDelegate setModelData call v0.153.0 (2020-12-17) Feat MediaPlayer : add get_error method v0.152.1 (2020-12-17) Fix PySide2 workaround for non-recursive Object.findChild(ren) v0.152.0 (2020-12-16) Feat Standarditem/StandardItemModel : add enabled and editable kwarg to add_item methods AbstractItemView : add get/set_drag_drop_mode methods v0.151.0 (2020-12-16) Feat ToolBar : add add method Icon : add get_actual_size method winextras : add WinThumbnailToolButton class ToolButton : add set_menu method Uuid : add str method Fix PySide2 find_child(ren) fix v0.150.0 (2020-12-15) Feat Movie : add get_state method v0.149.0 (2020-12-15) Feat add HoverIconEventFilter class positioning : add GeoPositionInfo class Icon : add mode and state kwarg for add/get_pixmap widget : add set_mask method core : add FileSystemWatcher class Palette : add get/set_color_group methods Brush : add some addtional methods Region : add some additional methods custom_delegates : add RenderLinkDelegate class TableWidgetItem : add set_text_alignment method Gradients : add repr and some helper methods to gradient classes Fix PySide2 workaround for missing recursive param in findChild(ren) WebEngineHistory len fix for PySide2 CategoryAxis len fix for PySide2 correctly inherit LCDNumber v0.148.0 (2020-12-14) Feat Widget : add get/set_window_state methods AbstractTextDocumentLayout : add tuple support for hit_test point arg TimeZone : add get_display_name method GuiApplication : add get/set_high_dpi_scale_factor_rounding_policy methods StandardItem : add some new methods AbstractButton : add get_icon method StandardItemModel : add add_item method StandardItem : add get/set_checkstate methods Window : add start_system_resize method v0.147.2 (2020-12-14) Fix MacOs test fix v0.147.1 (2020-12-14) Fix MacOs test fix v0.147.0 (2020-12-13) Feat ToolBar : add get_allowed_areas method WebEnginePage : add some additional methods WebEngineSettings : add delitem method Application : add send/post_event methods v0.146.0 (2020-12-13) Fix correctly serialize AbstractGraphicsShapeItem Feat GuiApplication : add get_icon method PlainTextEdit : add get(_line)_wrap_mode methods GuiApplication : add get_application_state method v0.145.0 (2020-12-11) Fix GraphicsGridLayout : serialize correctly MediaRecorder : use correct module in set_video/audio_settings correct constant naming install_exceptionhook fix Feat GridLayout : add get/set_origin_corner methods BoxLayout : add get/set_direction methods NetworkCookieJar : add add and set_cookies_from_url methods NetworkCookie : add set_expiration_date method Translator : add bool method custom_widgets : add RoundProgressBar class DateTimeEdit : add some more methods related to sections get/set_icon_size work for some widgets CalendarWidget : add set_range method HeaderView : add generate_header_id method Widget : add edit_palette contextmanager and get_font method Palette : add brush methods custom_models : add ImportlibDistributionModel class v0.144.0 (2020-12-09) Fix Settings : iter through key-value pairs correct inheritance for QuickItem ColumnItemModel : correct get_width signature Feat qml : add QmlImageProviderbase class widgets : add TreeWidgetItemIterator class quick : add some more classes qml : add QmlParserStatus class Widget : add get_title method Painter : add get_text_rect method ListWidget : add add_item method v0.143.0 (2020-12-08) Fix ObjectBrowser fix Feat implement eq method for some more validator classes v0.142.1 (2020-12-07) Fix use our own SizeF class v0.142.0 (2020-12-07) Feat SizeF : add some methods to be on par with Size Size : add expanded_to method CompositeValidator : add some additional methods custom_validators : add eq method to validator classes TreeWidgetItem : add some more methods widgets : add TableWidgetSelectionRange class core : add Calendar class core : add SignalMapper class core : add StateMachine class core : add LockFile class core : add JsonDocument/JsonValue classes GeoCircle : allow tuple in ctor core : add SocketNotifier class widgets : add Shortcut class Fix Correctly inherit StyleItemDelegate v0.141.0 (2020-12-03) Feat core : add Collator(SortKey) classes Fix github actions fix v0.140.4 (2020-12-02) Fix docs build fix v0.140.3 (2020-12-02) Fix docs deployment v0.140.2 (2020-12-02) Fix deploy check for github actions v0.140.1 (2020-12-02) Fix github actions: conditional deploy step v0.140.0 (2020-12-02) Feat gui : add ColorSpace class v0.139.0 (2020-12-02) Feat FileInfo/Dir : fallback to pathlib.Path methods widgets : add Proxy/CommonStyle classes widgets : add Gesture classes core : add TemporaryDir class widgets : add WhatsThis class core : add ItemSelectionRange class FormLayout : add some more methods core : add ProcessEnvironment class gui : add StaticText class core : add PauseAnimation class v0.138.0 (2020-12-01) Feat core : add ChildEvent / TimerEvent classes core : add IdentityProxyModel class gui : add SessionManager class gui : add InputMethod class core : add AbstractEventDispatcher class widgets : add StackedWidget class widgets : add some events FileInfo : add some additional methods gui : add Vector3D class core : add MimeType / MimeDatabase classes core : add SaveFile class core : add SignalBlocker class core : add TimeLine class gui : add Bitmap class core : add RandomGenerator class FileDevice : add get_error method widgets : add Dial class widgets : add RubberBand class Wizard/WizardPage : add some more methods widgets : add GraphicsRotation / GraphicsScale classes widgets : add GraphicsTransform class widgets : add LCDNumber class widgets : add Scroller(Properties) classes core : add CommandLineParser/Option classes Pixmap : add some more methods gui : add Screen class Transform : add some more methods add Abstract/PlainTextTextDocumentLayout classes core : add BasicTimer class core : add Resource class core : add StorageInfo class core : add ElapsedTimer class core : add CryptographicHash class v0.137.1 (2020-11-27) Fix doc build fix v0.137.0 (2020-11-27) Feat core : add OperatingSystemVersion class PdfWriter : add set_page_margins method core : add MarginsF class core : Add TextStream class core : add ByteArrayMatcher AbstractItemModel : add check_index method PlaceManager : add search_place method core : add app method add bytes method to some classes utils : add Singleton metaclass icon : add add_pixmap method gui : Add PixmapCache Font : add some more methods v0.136.0 (2020-11-26) Feat location : add PlaceResult class location : add PlaceProposedSearchResult class location : add clone_from method to reply classes Object : add has_id method Fix emit inputandslider signal correctly on value change correct flag for constants.NO_CHILDREN v0.135.0 (2020-11-26) Feat WebEngineHistoryItem : add get_icon_url method location : add PlaceMatchReply / PlaceIdReply classes PlaceContentReply/PlaceSearchReply : add request methods gui : add TextListFormat class gui : add TextImageFormat class location : add some reply/result classes gui : add TextTableCellFormat class gui : add app method gui : add TextFrameFormat class Application : add get_font method add qthelp module quick : add QuickPaintedItem class gui : add TextBlockGroup class TextCharFormat : add get/set_vertical_alignment methods TextBlock : add contains method PaintDevice : add get_metric method GuiApplication : add get/set_layout_direction methods gui : add TextObject / TextLength / TextFrame / TextFormat classes core : add ItemSelection class GraphicsLayout : add set_margin method Fix correctly add items for GraphicsGridLayout v0.134.0 (2020-11-23) Feat core : add PersistentModelIndex class core : add PluginLoader class core : add Library class gui : add PainterPathStroker class gui : add ImageWriter / ImageReader / ImageIOHandler classes quick : add QuickItem / QuickWindow classes core : add install_message_handler method gui : add RasterWindow / PaintDeviceWindow / OpenGLWindow classes svg : add SvgGenerator class SplashScreen : allow pixmap for ctor icon : add get_available_sizes method widget : add set_attributes method gui : add Vector4D / Matrix4x4 classes custom_widgets : add StarDelegate class custom_delegates : add ProgressBarDelegate class widgets : add missing StyleOption classes WidgetItems : some more methods Painter : add backup_state contextmanager Fix KeySequenceEdit : correct repr correct coloring for WaitingSpinner v0.133.1 (2020-11-16) Fix test fix v0.133.0 (2020-11-16) Feat ComboBox : default param for add_items AbstractItemModel : add force_reset/force_layoutchange methods add location module gui : add FontMetricsF class GeoCoordinate : add bool method FontMetrics : add get_(tight_)bounding_rect methods Url : add to_string method network : add LocalServer / TcpServer classes multimediawidgets : add GraphicsVideoItem class mediaobject : add get_availability method add qt module v0.132.1 (2020-11-07) Fix import fix v0.132.0 (2020-11-07) Feat NetworkAccessManager : allow str for request network : add UdpSocket network : add NetworkAddressEntry / NetworkInterface classes add texttospeech module network : add NetworkDatagram class core : add DeadlineTimer class network : add HostAddress/AbstractSocket/TcpSocket classes network : add NetworkProxy class network : add HttpMultiPart class network : add HttpPart class NetworkRequest : add set/get_header methods v0.131.0 (2020-11-04) Feat webenginecore : add WebEngineHttpRequest class webenginewidgets : add WebEngineContextMenuData class webenginewidgets : add WebEngineScriptCollection class multimedia : add CameraExposure/CameraImageProcessing classes multimedia : add CameraFocus(Zone) classes webenginecore : add WebEngineUrlSchemeHandler v0.130.0 (2020-11-04) Feat WebEnginePage : add some settings methods webenginewidgets : add WebEngineSettings class add bluetooth module core : add Uuid class add quick module gui : add Surface and Window class multimedia : add ImageEncoderSettings multimedia : add MediaTimeRange and MediaTimeInterval classes v0.129.1 (2020-10-29) Fix fix tests fix multimedia tests for Travis Feat charts : add Legend class WebEnginePage : add get_history method qml : add JSValue(Iterator) class VideoWidget : option for fullscreen toggling via double click multimedia : add CameraViewFinderSettings multimedia : add VideoFrame class multimedia : add AbstractPlanarVideoBuffer class multimedia : add AbstractVideoBuffer class multimedia : add Camera class multimedia : add CameraInfo class gui : add Clipboard class multimedia : add AudioFormat class multimedia : add SoundEffect class charts : add PieSlice class charts : add BoxSet and CandlestickSet classes charts : add Axis-related classes charts : add BarSeries-related classes v0.128.1 (2020-10-25) Fix import fix v0.128.0 (2020-10-25) Feat custom_widgets : add ExpandableLine class ParallelAnimationGroup : add set_duration method charts : add Abstract/ValueAxis and PolarChart classes core : add SequentialAnimationGroup class AnimationGroup : allow slicing for indexing AnimationGroup : add add_property_animation method ChartView : add get/set_rubber_band methods Chart : add some more methods core : add Locale class core : add Margins class webenginewidgets : add some more modules Fix Chart : properly inherit from GraphicsWidget v0.127.1 (2020-10-20) Fix fix tests v0.127.0 (2020-10-20) Fix always import correct bindings for winextras module Url : allow initializing without arg Feat PainterPath : add set_fill_rule method PainterPath : add get_bounding_rect method GraphicsItem : add get_shape method MediaPlaylist : add get_media_url method start with webenginecore module core : add EventLoop class Widget : add get_font_info method custom_models : add PlaylistModel Translator : add get_file_path method add positioning module add some first QtQml classes core : add LibraryInfo class Application : add iter method Application : add get/set_navigation_mode methods Application : add get/is_effect_enabled methods custom_widgets : add Player class v0.126.0 (2020-10-08) Feat core : add Process class DateTime : add get/set_time_spec and get_date/time methods core : add Time class DateTime : add timezone methods core : add TimeZone class Pixmap : add create_dot classmethod v0.125.1 (2020-10-07) Fix import fix v0.125.0 (2020-10-07) Feat widgets : add Transition classes core : add Transition classes Fix fix Action.get_shortcut for NoneValue v0.124.0 (2020-10-05) Feat IODevice : add get_open_mode method Improve repr and add str method for Date and DateTime core : add TemporaryFile class FileDevice : add set/get_file_time methods MainWindow : allow setting central widget to None AbstractButton : add get_shortcut method Url : add from_user_input method WebEngineView : add get_url method FileInfo : support pathlib + add proper repr KeySequence : allow initializing with standard keys v0.123.1 (2020-09-29) Fix add missing State import in core module v0.123.0 (2020-09-29) Feat core : add State classes core : add TextBoundaryFinder class ProgressBar : add get/set_orientation methods + serialize work Action : allow setting callback with ctor WebEngineView : set subclassed WebEnginePage by default WebEnginePage : add some more methods and constants AbstractSlider : add get/set_orientation methods core : add FileInfo class webenginewidgets : add WebEngineProfile class v0.122.1 (2020-09-27) Fix use correct icon names v0.122.0 (2020-09-27) Feat gui : add PageLayout gui : add Movie class gui : add PageSize class gui : add FontInfo class core : add UrlQuery class add network module PropertyAnimation : add get/set_property_name methods core : add ParallelAnimationGroup widgets : add SizeGrip class widgets : add DataWidgetMapper class core : add StringListModel VersionNumber : add get_python_version gui : add Transform class Painter : add draw_polygon method add core.ByteArray v0.121.0 (2020-09-10) Feat Image : add setitem / getitem methods Line/LineF : add reversed and abs methods GraphicsScene : add get/set_item_index_method method Fix serialization fixes v0.120.0 (2020-08-27) Feat GraphicsWidget : add set_layout method GraphicsLayout : add some magic methods GraphicsScene : add add_item_group method widgets : add GraphicsAnchorLayout / GraphicsGridLayout / GraphicsLinearLayout widgets : add GraphicsItemGroup Layout : add delitem method Polygon/PolygonF : add repr and iter methods PainterPath : some additional methods GraphicsItems : add repr methods Line/LineF : add repr and iter Application : allow loading included language files via load_language_file widgets : add GraphicsView class Refactor PromptLineEdit rework v0.119.1 (2020-08-24) Fix add missing StyleOptionComplex class v0.119.0 (2020-08-24) Feat GraphicsScene : add some convenience methods widgets : add graphicsitem classes StylePainter : add draw_complex_control method gui : allow pickling some more classes core : add LineF class Widget : add get_palette() method widgets : add GraphicsPixmapItem / GraphicsScene GraphicsItem : add getitem and setitem methods widgets : add Blur/Colorize/DropShadowEffect Fix Graphicsitem collides methods fix KeySequence : pickling v0.118.2 (2020-08-17) Fix Fix tests v0.118.1 (2020-08-17) Fix MenuBar : fix add method v0.118.0 (2020-08-17) Refactor MenuBar : return subclassed types instead of qt classes Feat gui : add TextDocument / TextBlock / TextOption gui : add ConicalGradient / RadialGradient custom_widgets : add CollapsibleFrame GraphicsItem : add some more methods v0.117.0 (2020-08-16) Feat MimeData : add dict-like interface Timer : add get/set_type methods File : add repr and str methods Dir : add repr and truediv methods Frame : set/get_frame_shape, set/get_frame_shadow Splitter : add setitem method, and some more typing Polygon/PolygonF : pythonize core : add Abstract/Variant/PropertyAnimation and AnimationGroup core : add EasingCurve StyleOptionSlider : add get_orientation method Refactor SpanSlider : clean up code v0.116.0 (2020-08-13) Feat gui : add LinearGradient AbstractSlider : add get/set_repeat_action and trigger_action methods TabWidget : add get/set_tab_position methods Image/Pixmap : add bool method MenuBar : serialize stuff MdiArea : serialize stuff Brush : allow pickling + add get_texture_image method custom_widgets : add Timeline Pen : add methods for setting and getting style / join style / cap style Refactor Painter : rework set_pen / get_pen v0.115.0 (2020-08-12) Feat Polygon : add add_points method Object : add store_widget_states / restore_widget_states Painter : add paint_on, set_transparent_background, set_brush PainterPath : add add_rect method Application : add class_getitem Fix RegexEditor : correctly initialize dialog v0.114.1 (2020-08-12) Fix HeaderView : fix saving state v0.114.0 (2020-08-12) Refactor use AutoSlot decorator Feat add autoslot decorator add prettyqt.debug v0.113.0 (2020-08-10) Feat gui : add PainterPath class gui : add Polygon class gui : palette improvements core : add Line class core : add TransposeProxyModel / ConcatenateTablesProxyModel add ObjectBrowser widgets : add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect Action : \"checked\" param for ctor gui : some magic methods + get_matches for KeySequence core : allow pickling VersionNumber / Size / Dir gui : add Gradient class add ColumnItemModel / ColumnItem Settings : add set_values method Widget : spacing kwarg for set_layout Refactor add serialization stuff improve some repr methods v0.112.0 (2020-08-04) Feat utils : add install_exceptionhook method FileSystemModel : add some more shortcuts for set_root_path core : add VersionNumber class Application : add get_icon method MessageBox : add show_exception method Refactor improve compat with older Qt Versions Fix another test fix v0.111.1 (2020-08-03) Fix fix tests for Linux v0.111.0 (2020-08-03) Feat widgets : add FontComboBox StandardPaths : add class_getitem method Action : some more ctor kwargs Action : add get/set_menu_role methods, some pickle work Refactor custom Exception for wrong params Fix Menu : disable separator widgetAction v0.110.2 (2020-08-03) Fix fix broken LogTextEdit v0.110.1 (2020-08-03) Fix LogTextEdit : improve exception handling SidebarWidget : some fixes related to set_marker v0.110.0 (2020-08-02) Refactor improve serialization for listitems Validator pickle work Feat Image : allow pickling DataStream : add create_bytearray / write_bytearray / copy_data methods core : add DataStream class v0.109.0 (2020-08-02) Feat widget : add pretty method for devtools GridLayout : allow adding tuples/lists Refactor rework widget pickling move CheckboxDelegate to custom_delegates pickle stuff for undocommand v0.108.0 (2020-07-31) Feat custom_delegates : add IconDelegate and NoFocusDelegate TableWidet : add getitem and setitem methods Icon : add from_image method allow str for layout. getitem (uses objectName) SidebarWidget : add set_marker method Refactor move delegates to separate module v0.107.0 (2020-07-29) Feat GridLayout : also allow adding LayoutItems via add method v0.106.1 (2020-07-29) Fix TabWidget : correctly close detached tabs on app close pickle fixes for toolbar and dockwidget PygmentsHighlighter : catch pygments KeyError v0.106.0 (2020-07-26) Feat gui : add DesktopServices class multimedia : add AudioRecorder class core : add StandardPaths class widgets : add Undo classes v0.105.0 (2020-07-24) Feat MediaRecorder : some new methods sort_by_column for tableview and treeview multimedia : dict-setter and getter for encodersettings Refactor improve Url-Pathlib interoperability Fix PopupInfo : use PrimaryScreen geometry instead of screens[0] for positioning v0.104.0 (2020-07-23) Feat multimedia : add MediaRecorder AbstractItemModel : add getitem method multimedia : add VideoEncoderSettings / AudioEncoderSettings Refactor use subclassed core.Size v0.103.0 (2020-07-22) Feat ActionGroup : add getitem method MediaContent : add get_url method add multimediawidgets module add multimedia module PlainTextEdit : add allow_wheel_zoom method Object : name kwarg for find_parent method v0.102.0 (2020-07-21) Refactor move raise_dock to from Widget to Object SidebarWidget : some code cleanup, make settings button size configurable Widget : default state to True for set_attribute MainWindow : add return value for load_window_state Feat Object : add find_parent method PlainTextEdit : add style kwarg to set_syntaxhighlighter v0.101.1 (2020-07-20) Fix LogTextEdit : better integrate with custom qstylesheets v0.101.0 (2020-07-20) Feat MessageBox : add detail_text keyword argument to message method Fix correct return type for gui.icon.get_icon v0.100.0 (2020-07-20) Feat ToolTip : add show_text method GuiApplication : add set_override_cursor / restore_override_cursor methods GuiApplication : add override_cursor context manager v0.99.0 (2020-07-18) Refactor FileChooserButton : typing and fixes Dataset : typing and fixes SidebarWidget : use button map instead of attaching button to widget Feat AbstractItemView : add scroll_to method v0.98.5 (2020-07-17) Perf add icon cache Refactor use core.Settings for windows dark mode detection v0.98.4 (2020-07-15) Fix use qta default icon color instead of black for default v0.98.3 (2020-07-15) Refactor properly set stylesheets by using contextmanager FontDialog : do not override current_font contextmanager move current_font context manager to Widget class v0.98.2 (2020-07-15) Fix package name v0.98.1 (2020-07-15) Fix correctly reset stylesheet for widget validation background Refactor use qstylizer for stylesheet editing v0.98.0 (2020-07-15) Feat widgets : add StyleFactory Refactor FontDatabase : make add_fonts_from_folder a classmethod v0.97.0 (2020-07-15) Feat gui : add FontDatabase widgets : add Completer widgets : add ActionGroup v0.96.0 (2020-07-14) Feat SelectionWidget : default keyword argument for add_custom v0.95.0 (2020-07-14) Feat SelectionWidget : different options for custom type add PagedPaintDevice Widget : add set_margin method v0.94.0 (2020-07-14) Feat Widget : add Widget.font_metrics() SpacerItem : allow strings for size policy in ctor allow Mapping for listwidget.add_items Refactor change to {value: label} dicts for FlagSelectionWidget.add_items v0.93.1 (2020-07-14) Refactor typecheck for Mapping instead of dict for combobox / selectionwidget add_items method v0.93.0 (2020-07-14) Feat add register_extensions function to settings module Refactor Settings : do not override value method v0.92.1 (2020-07-14) Fix winextras test fix v0.92.0 (2020-07-14) Feat add widgets.SystemTrayIcon add winextras module Label : set_indent method v0.91.0 (2020-07-13) Feat SidebarWidget : allow choosing layout MainWindow : add show_blocking method v0.90.0 (2020-07-13) Feat Toolbar : allow combinations of allowed areas for set_allowed_areas SidebarWidget : add optional settings menu v0.89.1 (2020-07-13) Refactor SelectionWidget : switch to {data: label} dicts for add_items to be in line with RadioButton v0.89.0 (2020-07-13) Feat SidebarWidget : make button width configurable v0.88.1 (2020-07-13) Refactor ComboBox : use set_data for set_value Fix ComboBox : fix add_items method v0.88.0 (2020-07-13) Feat ComboBox : set_data method v0.87.0 (2020-07-13) Feat ComboBox : allow dict for add_items v0.86.3 (2020-07-12) Refactor RegexEditor : code cleanup v0.86.2 (2020-07-12) Fix another deployment fix v0.86.1 (2020-07-12) Fix deployment fix v0.86.0 (2020-07-12) Feat add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line v0.85.1 (2020-07-10) Fix add missing pygments requirement v0.85.0 (2020-07-10) Feat dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method Refactor CodeEditor : use pygments for syntax highlighting v0.84.0 (2020-07-10) Feat sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child v0.83.1 (2020-07-09) Refactor move set_icon from window classes to widget class v0.83.0 (2020-07-09) Feat add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager v0.82.0 (2020-07-09) Feat add Label.set_bold / set_italic / set_weight added Font.set_weight v0.81.0 (2020-07-08) Feat allow setting window icon color os dark mode detection v0.80.1 (2020-07-08) Fix Settings.value() returned wrong type v0.80.0 (2020-07-08) Feat add Widget.set_attribute add margin keyword argument to Widget.set_layout v0.79.1 (2020-07-08) Fix remove Qt logger on Application exit v0.79.0 (2020-07-08) Feat add widgets.Application.get_widget v0.78.0 (2020-07-08) Feat allow to save/load window state recursively. Saving needs to be done explicitely now. Fix some fixes for core.Settings dict interface properly preserve types in core.Settings v0.77.1 (2020-07-07) Refactor also allow qt flag for Splitter ctor Fix return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview 0.77.0 (2020-07-06) Feat allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages Fix fix Messagebox.message call Refactor dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars v0.75.9 (2020-07-05) v0.75.8 (2020-07-05) v0.75.7 (2020-07-05) v0.75.6 (2020-07-05) v0.75.5 (2020-07-05) v0.75.4 (2020-07-05) v0.75.3 (2020-07-05) v0.75.2 (2020-07-05) v0.75.1 (2020-07-05) v0.75.0 (2020-07-05) v0.74.3 (2020-07-05) v0.74.2 (2020-07-05) v0.74.1 (2020-07-05) v0.74.0 (2020-07-05) v0.73.4 (2020-07-04) v0.73.3 (2020-07-04) v0.73.2 (2020-07-04) v0.73.1 (2020-07-04) v0.73.0 (2020-07-02) v0.72.3 (2020-07-01) v0.72.2 (2020-07-01) v0.72.1 (2020-07-01) v0.72.0 (2020-07-01) v0.71.0 (2020-06-30) v0.70.0 (2020-06-30) v0.69.0 (2020-06-29) v0.68.0 (2020-06-29) v0.67.1 (2020-06-28) v0.65.1 (2020-06-24) v0.65.0 (2020-06-24) v0.64.0 (2020-06-24) v0.63.0 (2020-06-22) v0.62.0 (2020-06-21) v0.61.0 (2020-06-21) v0.60.1 (2020-06-21) v0.60.0 (2020-06-20) v0.59.0 (2020-06-20) v0.58.1 (2020-06-19) v0.57.1 (2020-06-15) v0.57.0 (2020-06-14) v0.56.1 (2020-06-10) v0.56.0 (2020-06-10) v0.55.0 (2020-06-09) v0.54.0 (2020-06-08)","title":"Changelog"},{"location":"changelog.html#v01921-2022-11-12","text":"","title":"v0.192.1 (2022-11-12)"},{"location":"changelog.html#fix","text":"disable BaseModelMixin test for now","title":"Fix"},{"location":"changelog.html#v01920-2022-11-12","text":"","title":"v0.192.0 (2022-11-12)"},{"location":"changelog.html#feat","text":"custom_models : add BaseListMixin class","title":"Feat"},{"location":"changelog.html#v01910-2022-11-10","text":"","title":"v0.191.0 (2022-11-10)"},{"location":"changelog.html#feat_1","text":"custom_models : add BaseModelMixin class","title":"Feat"},{"location":"changelog.html#v01908-2022-11-09","text":"","title":"v0.190.8 (2022-11-09)"},{"location":"changelog.html#fix_1","text":"better check for combobox set_editable method","title":"Fix"},{"location":"changelog.html#v01907-2022-11-08","text":"","title":"v0.190.7 (2022-11-08)"},{"location":"changelog.html#fix_2","text":"Combobox : set Completer only when calling set_editable to avoid error message","title":"Fix"},{"location":"changelog.html#v01906-2022-11-03","text":"","title":"v0.190.6 (2022-11-03)"},{"location":"changelog.html#fix_3","text":"proper fix for restoreState","title":"Fix"},{"location":"changelog.html#v01905-2022-11-03","text":"","title":"v0.190.5 (2022-11-03)"},{"location":"changelog.html#fix_4","text":"allow str for restoreState","title":"Fix"},{"location":"changelog.html#v01904-2022-11-03","text":"","title":"v0.190.4 (2022-11-03)"},{"location":"changelog.html#fix_5","text":"qt compat some compat fixes qt6 flag compat qt6 compat","title":"Fix"},{"location":"changelog.html#v01903-2022-06-30","text":"","title":"v0.190.3 (2022-06-30)"},{"location":"changelog.html#fix_6","text":"bump regex dep","title":"Fix"},{"location":"changelog.html#v01902-2022-04-07","text":"","title":"v0.190.2 (2022-04-07)"},{"location":"changelog.html#fix_7","text":"scxml not available for PyQt5","title":"Fix"},{"location":"changelog.html#v01901-2022-04-06","text":"","title":"v0.190.1 (2022-04-06)"},{"location":"changelog.html#fix_8","text":"regex fix","title":"Fix"},{"location":"changelog.html#v01900-2022-04-06","text":"","title":"v0.190.0 (2022-04-06)"},{"location":"changelog.html#feat_2","text":"Application : add sleep method add scxml module","title":"Feat"},{"location":"changelog.html#v01890-2021-12-31","text":"","title":"v0.189.0 (2021-12-31)"},{"location":"changelog.html#feat_3","text":"XmlStreamReader : add get_token_type / read_next methods Rect : add margins_added / margins_removed methods TextDocument : add show_whitespaces_and_tabs method Chart : add set_margins method core : add XmlStreamReader class Size/SizeF : add shrunk_by / grown_by methods StandardItem/ListWidgetItem/TreeWidgetItem : add set_size_hint method Polygon/PolygonF : add get_data_buffer method ListWidgetItem : add set_data method Window/Widget : add get_screen method","title":"Feat"},{"location":"changelog.html#fix_9","text":"typo for DateType CompletionWidget : correctly cast to int for SetY","title":"Fix"},{"location":"changelog.html#v01880-2021-12-14","text":"","title":"v0.188.0 (2021-12-14)"},{"location":"changelog.html#feat_4","text":"add JsonModel class Translator : add for_system_language method StyleOptionToolBox : add get/set_selected_position methods Widget : add screen param to center method Url : add from_local_file method custom_widgets : add CompletionWidget class TextDocument/TextDocumentFragment : add write_to_file method Font : add set_family method gui : add TextDocumentWriter class TextCursor : add get_selection method Mimedata : add set_svg_data / set_path_data gui : add TextDocumentFragment class ListWidet : add find_items method SpacerItem : add get_size_policy method custom_validators : add IntegerValidator class","title":"Feat"},{"location":"changelog.html#v01872-2021-11-18","text":"","title":"v0.187.2 (2021-11-18)"},{"location":"changelog.html#fix_10","text":"fix import for non-windows","title":"Fix"},{"location":"changelog.html#v01871-2021-11-18","text":"","title":"v0.187.1 (2021-11-18)"},{"location":"changelog.html#fix_11","text":"add FramelessWindow to init .py","title":"Fix"},{"location":"changelog.html#v01870-2021-11-18","text":"","title":"v0.187.0 (2021-11-18)"},{"location":"changelog.html#feat_5","text":"Pixmap : add get_image_data_url method FramelessWindow : make AeroSnap work custom_widgets : add JoystickButton class Add SvgBufferIconEngine class FontDatabase : keep track of font paths Style : add draw_control method Icon : add from_char method Pixmap : add create_char method","title":"Feat"},{"location":"changelog.html#fix_12","text":"fix ProgressBarDelegate orientation for Qt6","title":"Fix"},{"location":"changelog.html#v01860-2021-11-11","text":"","title":"v0.186.0 (2021-11-11)"},{"location":"changelog.html#feat_6","text":"WebEnginePage : add some more methods Color : add get_name method iconprovider : add dir and getattr methods to iconsets TextDocument : add some more methods TextBlock : add str method Process : add get_process_environment method qml : add clear_type_registrations method FileIconProvider : support os.PathLike for get_icon custom_widgets : add SubsequenceCompleter class Completer : add set/is_case_sensitive methods custom_models : add SubsequenceSortFilterProxyModel class SortFilterProxyModel : add set_sort_role method","title":"Feat"},{"location":"changelog.html#v01850-2021-11-04","text":"","title":"v0.185.0 (2021-11-04)"},{"location":"changelog.html#feat_7","text":"add QT_VERSION var to qt module","title":"Feat"},{"location":"changelog.html#fix_13","text":"core : dont shadow builtin libraries","title":"Fix"},{"location":"changelog.html#v01840-2021-10-30","text":"","title":"v0.184.0 (2021-10-30)"},{"location":"changelog.html#feat_8","text":"qt : add flag_to_int method debugging : add is_deleted fn TextEdit : add get_text_cursor method PlainTextEdit : add get_text_cursor method better package support by using importlib.resources for resource files add qt.set_env_vars fallback to installed qt package in case environment var QT_API is invalid / empty TextBlock : add some methods related to syntax highlighting HeaderView : add section_resized_by_user signal Widget : add resized signal add StandardIconsWidget class TextCursor : add get_cursor_position method SyntaxHighlighter : add get_current_block / get_format Process : add edit_environment method Widget : rename get/set_context_menu_policy methods TextLayout : add get_text_option method TextDocument : add some more methods TextCursor : add str method StandardItemModel : add create_single_item_model classmethod ProcessEnvironment : add update() / items() methods Color : add drift_color classmethod PlaintextEdit : TextDocument by default PlainTextEdit : add show_whitespace_and_tabs method add mimetype_icon fn for FileIconProvider Add MenuRecentFiles class update iconsets","title":"Feat"},{"location":"changelog.html#fix_14","text":"TextCursor : correctly convert EOL in str qt6 flag fix typo in AwesomeFileIconProvider","title":"Fix"},{"location":"changelog.html#v01836-2021-10-26","text":"","title":"v0.183.6 (2021-10-26)"},{"location":"changelog.html#fix_15","text":"more qt compat stuff generate docs on py3.9","title":"Fix"},{"location":"changelog.html#v01835-2021-10-12","text":"","title":"v0.183.5 (2021-10-12)"},{"location":"changelog.html#fix_16","text":"only test on 3.9 / macos10","title":"Fix"},{"location":"changelog.html#v01834-2021-10-12","text":"","title":"v0.183.4 (2021-10-12)"},{"location":"changelog.html#fix_17","text":"dont use poetry pre version","title":"Fix"},{"location":"changelog.html#v01833-2021-10-12","text":"","title":"v0.183.3 (2021-10-12)"},{"location":"changelog.html#fix_18","text":"qt6 compat some flag fixes","title":"Fix"},{"location":"changelog.html#v01832-2021-02-05","text":"","title":"v0.183.2 (2021-02-05)"},{"location":"changelog.html#fix_19","text":"another try to fix docs generation","title":"Fix"},{"location":"changelog.html#v01831-2021-02-05","text":"","title":"v0.183.1 (2021-02-05)"},{"location":"changelog.html#fix_20","text":"fix docs generation","title":"Fix"},{"location":"changelog.html#v01830-2021-02-05","text":"","title":"v0.183.0 (2021-02-05)"},{"location":"changelog.html#feat_9","text":"JSEngine : add eval method Pixmap : add rotated method ColorDialog : add replace_qcolorshowlabel JSValue : add call method PlainTextEdit : add some more methods core : add Slot method core : add Mutex/Semaphore classes LineEdit : add some signals svg : add SvgWidget class","title":"Feat"},{"location":"changelog.html#fix_21","text":"correctly keep state when using block_signals / updates_off context managers","title":"Fix"},{"location":"changelog.html#v01821-2021-01-26","text":"","title":"v0.182.1 (2021-01-26)"},{"location":"changelog.html#fix_22","text":"colors fix","title":"Fix"},{"location":"changelog.html#v01820-2021-01-26","text":"","title":"v0.182.0 (2021-01-26)"},{"location":"changelog.html#feat_10","text":"Image : add invert_pixels method Color : invert_alpha param for inverted method MetaObject : type_filter kwarg for get_methods core : add MetaProperty class MetaObject : include_super param for get_ methods ItemEditorFactory : add property_name kwarg to register_editor method TabWidget : add update_tab_bar_visibility method Pixmap : add from_image method MessageBox : add some constants MessageBox : add set_escape/default_button methods MessageBox : add get_icon_pixmap method svg : add SvgRenderer class Image : add from_ndarray method","title":"Feat"},{"location":"changelog.html#v01810-2021-01-23","text":"","title":"v0.181.0 (2021-01-23)"},{"location":"changelog.html#feat_11","text":"Color : add is_dark and inverted methods Dir : add set_search_paths method Palette : add inverted method Dir : add add_search_path method core : add AbstractNativeEventFilter","title":"Feat"},{"location":"changelog.html#v01800-2021-01-20","text":"","title":"v0.180.0 (2021-01-20)"},{"location":"changelog.html#feat_12","text":"TextDocument : add some methods related to default stylesheet editing PygmentsHighlighter : add repr method PygmentsHighlighter : add style kwarg QtCore : add QClassInfo for PyQt5/6 colors : add interpolate_text_colors fn Color : add from_hsv method gui : add Drag class DataWidgetMapper : add get_mapped_property_name method DataWidgetMapper : add add_mapping method","title":"Feat"},{"location":"changelog.html#v01790-2021-01-18","text":"","title":"v0.179.0 (2021-01-18)"},{"location":"changelog.html#fix_23","text":"RegexInput flags fix ModelTester : correctly disconnect model","title":"Fix"},{"location":"changelog.html#feat_13","text":"Painter : more kwargs for set_pen method Pen : allow custom dash pattern for set_style ItemEditorFactory : add register_default_editor method GraphicsItem : add set_scale method Pixmap : add create_checkerboard_pattern method ColorDialog : add get_qcolorshower/get_qcolorshowlabel methods TableWidgetItem : add set_tooltip method","title":"Feat"},{"location":"changelog.html#v01780-2021-01-14","text":"","title":"v0.178.0 (2021-01-14)"},{"location":"changelog.html#feat_14","text":"IODevice : add len method EventLoop : throw exception when running twice Color : add to_qsscolor method Color : add interpolate_color method Locale : add get_system_locale / get_system_language methods use subclassed ItemEditorFactory as default factory","title":"Feat"},{"location":"changelog.html#v01771-2021-01-13","text":"","title":"v0.177.1 (2021-01-13)"},{"location":"changelog.html#fix_24","text":"test fix","title":"Fix"},{"location":"changelog.html#v01770-2021-01-13","text":"","title":"v0.177.0 (2021-01-13)"},{"location":"changelog.html#feat_15","text":"allow args for app() methods","title":"Feat"},{"location":"changelog.html#v01760-2021-01-13","text":"","title":"v0.176.0 (2021-01-13)"},{"location":"changelog.html#feat_16","text":"Timer : add start_timer method Timer : add set_interval method allow os.PathLike for using images in set_tooltip methods Movie : add get_supported_formats method iconprovider : add AwesomeQuickImageProvider class iconprovider : add AwesomeFileIconProvider class","title":"Feat"},{"location":"changelog.html#v01750-2021-01-12","text":"","title":"v0.175.0 (2021-01-12)"},{"location":"changelog.html#feat_17","text":"add prettyqtest qml : add register_qml_type method AbstractSlider : add set_auto_scroll_to_end method GuiApplication : add edit_palette context manager Dir : add get_entry_list method","title":"Feat"},{"location":"changelog.html#v01740-2021-01-11","text":"","title":"v0.174.0 (2021-01-11)"},{"location":"changelog.html#feat_18","text":"core : add FileSelector class Dir : add get_entry_info_list method Resource : add set/get_file_name and register_resource methods Application : add get_available_themes method","title":"Feat"},{"location":"changelog.html#v01730-2021-01-10","text":"","title":"v0.173.0 (2021-01-10)"},{"location":"changelog.html#fix_25","text":"correct icon color for dark mode","title":"Fix"},{"location":"changelog.html#feat_19","text":"custom_models : add StorageInfoModel class DataStream : add get/set_status methods custom_widgets : add ElidedLabel class Painter : add get_font_metrics method gui : add TextLayout class add SyncedProperty class Widget : add get/set_window_file_path methods widgets : add SplitterHandle class","title":"Feat"},{"location":"changelog.html#v01720-2021-01-09","text":"","title":"v0.172.0 (2021-01-09)"},{"location":"changelog.html#feat_20","text":"Application : add set_theme method gui : add TextObjectInterface class PyQt5 : import QEnum and QFlag classes core : add MetaMethod/MetaObject classes widgets : add FocusFrame class quick : add Quick(Async)ImageProvider classes QmlEngine : add some more methods QmlApplicationEngine : add load_file method","title":"Feat"},{"location":"changelog.html#v01711-2021-01-07","text":"","title":"v0.171.1 (2021-01-07)"},{"location":"changelog.html#fix_26","text":"comment out some event constants","title":"Fix"},{"location":"changelog.html#v01710-2021-01-07","text":"","title":"v0.171.0 (2021-01-07)"},{"location":"changelog.html#feat_21","text":"GraphicsItem : add get/set_cache_mode methods GraphicsPixmapItem : some additional methods custom_widgets : add BorderLayout class widgets : add WidgetItem class LayoutItem : add get_item method LayoutItem : add get/set_alignment methods Style : add draw_primitive method StyleOption : add based_on method","title":"Feat"},{"location":"changelog.html#fix_27","text":"AutoSlot : use typing.get_type_hints","title":"Fix"},{"location":"changelog.html#v01700-2021-01-05","text":"","title":"v0.170.0 (2021-01-05)"},{"location":"changelog.html#feat_22","text":"Validators : also allow Pattern for set_regex add tile rule constant add SingleApplication class custom_widgets : add Notification class TreeWidget : add contains method HelpContentWidget : add index_of method add contains method to some widgets ItemEditorFactory : add register_editor method widgets : add ItemEditorCreatorBase / ItemEditorFactory types : add Variant(Type) VariantAnimation : add set_range method TextStream : add read_lines method TextStream : add set_codec method","title":"Feat"},{"location":"changelog.html#v01690-2021-01-04","text":"","title":"v0.169.0 (2021-01-04)"},{"location":"changelog.html#feat_23","text":"RegularExpressionMatch : add get_match_type method CoreApplication : allow more types for version metadata Windows : add workaround for raising window network : add LocalSocket class","title":"Feat"},{"location":"changelog.html#fix_28","text":"CoreApplication : fix setting metadata","title":"Fix"},{"location":"changelog.html#v01680-2021-01-03","text":"","title":"v0.168.0 (2021-01-03)"},{"location":"changelog.html#feat_24","text":"eventfilters : add AnimatedToolTipEventFilter class Widget : tooltip kwarg for set_flags method AbstractAnimation : add restart_animation method add custom_animations module AbstractAnimation : implement and and or Dir : some additional methods","title":"Feat"},{"location":"changelog.html#v01670-2021-01-02","text":"","title":"v0.167.0 (2021-01-02)"},{"location":"changelog.html#feat_25","text":"FileSystemModel : add get_file_info and get_file_path methods add fspath to Dir and FileInfo classes","title":"Feat"},{"location":"changelog.html#v01661-2021-01-01","text":"","title":"v0.166.1 (2021-01-01)"},{"location":"changelog.html#fix_29","text":"localization fixups","title":"Fix"},{"location":"changelog.html#v01660-2020-12-31","text":"","title":"v0.166.0 (2020-12-31)"},{"location":"changelog.html#feat_26","text":"CoreApplication : add get_available_languages and load_language methods","title":"Feat"},{"location":"changelog.html#v01650-2020-12-31","text":"","title":"v0.165.0 (2020-12-31)"},{"location":"changelog.html#feat_27","text":"WebEngineView : add register_as_browser method WebEngineView : ass some settings-related methods Translator : add load_file method add FramelessWindow class add webchannel module qt : add QtWebchannel module widgets : add FileIconProvider class add prettyqt.qt.QtUiTools module","title":"Feat"},{"location":"changelog.html#v01640-2020-12-29","text":"","title":"v0.164.0 (2020-12-29)"},{"location":"changelog.html#feat_28","text":"CoreApplication : add restart method","title":"Feat"},{"location":"changelog.html#fix_30","text":"FontDatabase : make get_system_font a classmethod ObjectBrowser signal fix for Qt6 PdfWriter : correctly inherit from Object and PagedPaintDevice","title":"Fix"},{"location":"changelog.html#v01630-2020-12-27","text":"","title":"v0.163.0 (2020-12-27)"},{"location":"changelog.html#feat_29","text":"OperatingsystemVersion : add eq and hash methods VersionNumber : add hash method FontDatabase : add optional md5 check for add_font","title":"Feat"},{"location":"changelog.html#fix_31","text":"revert CharIconPainter paint method for now","title":"Fix"},{"location":"changelog.html#v01620-2020-12-27","text":"","title":"v0.162.0 (2020-12-27)"},{"location":"changelog.html#feat_30","text":"FontDatabase : add additional check in add_font Painter : add offset_by and apply_transform context managers","title":"Feat"},{"location":"changelog.html#fix_32","text":"IconWidget : update when setting size","title":"Fix"},{"location":"changelog.html#v01610-2020-12-26","text":"","title":"v0.161.0 (2020-12-26)"},{"location":"changelog.html#feat_31","text":"LineEdit : add add_action method ListView/TableView : add some more setters / getters Painter : add edit_pen context manager PolygonF : alternative ctors for diamond / star creation","title":"Feat"},{"location":"changelog.html#fix_33","text":"LabeledSlider : call adjust_margins on correct object correct IconProvider init","title":"Fix"},{"location":"changelog.html#v01600-2020-12-25","text":"","title":"v0.160.0 (2020-12-25)"},{"location":"changelog.html#feat_32","text":"gui : add TextLine module Doublevalidator : add set_range method IntValidator : add set_range method Pixmap : add eq method","title":"Feat"},{"location":"changelog.html#v01590-2020-12-24","text":"","title":"v0.159.0 (2020-12-24)"},{"location":"changelog.html#feat_33","text":"LineEdit : add set/get_cursor_move_style methods","title":"Feat"},{"location":"changelog.html#v01580-2020-12-22","text":"","title":"v0.158.0 (2020-12-22)"},{"location":"changelog.html#feat_34","text":"iconprovider : add reset_cache method Widget : add set/get_foreground/background_role methods Application/Widget : add set/get_stylesheet methods Application : add edit_stylesheet context manager","title":"Feat"},{"location":"changelog.html#v01571-2020-12-22","text":"","title":"v0.157.1 (2020-12-22)"},{"location":"changelog.html#fix_34","text":"SpanSlider fix","title":"Fix"},{"location":"changelog.html#v01570-2020-12-22","text":"","title":"v0.157.0 (2020-12-22)"},{"location":"changelog.html#feat_35","text":"Painter : add native_mode context manager FontDatabase : add add_font method gui : add IconEngine class TabWidget : add set_icon_size method Icon : allow more types for size param","title":"Feat"},{"location":"changelog.html#v01560-2020-12-21","text":"","title":"v0.156.0 (2020-12-21)"},{"location":"changelog.html#feat_36","text":"RegularExpressionMatch : add bool method custom_widgets : add ObjectBrowser class Timer : add restart method ListView : add set_grid_size method SortFilterProxyModel : add is/set_filter_case_sensitive methods AbstractItemView : add set_icon_size method","title":"Feat"},{"location":"changelog.html#v01550-2020-12-20","text":"","title":"v0.155.0 (2020-12-20)"},{"location":"changelog.html#feat_37","text":"Label : add get_horizontal/vertical_alignment methods GraphicsWidget : add window_frame_section_at method","title":"Feat"},{"location":"changelog.html#v01540-2020-12-18","text":"","title":"v0.154.0 (2020-12-18)"},{"location":"changelog.html#feat_38","text":"add QtLocation and QtHelp to qt submodule Dir/FileDialog : add get/set_filter methods InputDialog : add get/set_input_mode and get/set_text_echo_mode methods","title":"Feat"},{"location":"changelog.html#fix_35","text":"correct StarDelegate setModelData call","title":"Fix"},{"location":"changelog.html#v01530-2020-12-17","text":"","title":"v0.153.0 (2020-12-17)"},{"location":"changelog.html#feat_39","text":"MediaPlayer : add get_error method","title":"Feat"},{"location":"changelog.html#v01521-2020-12-17","text":"","title":"v0.152.1 (2020-12-17)"},{"location":"changelog.html#fix_36","text":"PySide2 workaround for non-recursive Object.findChild(ren)","title":"Fix"},{"location":"changelog.html#v01520-2020-12-16","text":"","title":"v0.152.0 (2020-12-16)"},{"location":"changelog.html#feat_40","text":"Standarditem/StandardItemModel : add enabled and editable kwarg to add_item methods AbstractItemView : add get/set_drag_drop_mode methods","title":"Feat"},{"location":"changelog.html#v01510-2020-12-16","text":"","title":"v0.151.0 (2020-12-16)"},{"location":"changelog.html#feat_41","text":"ToolBar : add add method Icon : add get_actual_size method winextras : add WinThumbnailToolButton class ToolButton : add set_menu method Uuid : add str method","title":"Feat"},{"location":"changelog.html#fix_37","text":"PySide2 find_child(ren) fix","title":"Fix"},{"location":"changelog.html#v01500-2020-12-15","text":"","title":"v0.150.0 (2020-12-15)"},{"location":"changelog.html#feat_42","text":"Movie : add get_state method","title":"Feat"},{"location":"changelog.html#v01490-2020-12-15","text":"","title":"v0.149.0 (2020-12-15)"},{"location":"changelog.html#feat_43","text":"add HoverIconEventFilter class positioning : add GeoPositionInfo class Icon : add mode and state kwarg for add/get_pixmap widget : add set_mask method core : add FileSystemWatcher class Palette : add get/set_color_group methods Brush : add some addtional methods Region : add some additional methods custom_delegates : add RenderLinkDelegate class TableWidgetItem : add set_text_alignment method Gradients : add repr and some helper methods to gradient classes","title":"Feat"},{"location":"changelog.html#fix_38","text":"PySide2 workaround for missing recursive param in findChild(ren) WebEngineHistory len fix for PySide2 CategoryAxis len fix for PySide2 correctly inherit LCDNumber","title":"Fix"},{"location":"changelog.html#v01480-2020-12-14","text":"","title":"v0.148.0 (2020-12-14)"},{"location":"changelog.html#feat_44","text":"Widget : add get/set_window_state methods AbstractTextDocumentLayout : add tuple support for hit_test point arg TimeZone : add get_display_name method GuiApplication : add get/set_high_dpi_scale_factor_rounding_policy methods StandardItem : add some new methods AbstractButton : add get_icon method StandardItemModel : add add_item method StandardItem : add get/set_checkstate methods Window : add start_system_resize method","title":"Feat"},{"location":"changelog.html#v01472-2020-12-14","text":"","title":"v0.147.2 (2020-12-14)"},{"location":"changelog.html#fix_39","text":"MacOs test fix","title":"Fix"},{"location":"changelog.html#v01471-2020-12-14","text":"","title":"v0.147.1 (2020-12-14)"},{"location":"changelog.html#fix_40","text":"MacOs test fix","title":"Fix"},{"location":"changelog.html#v01470-2020-12-13","text":"","title":"v0.147.0 (2020-12-13)"},{"location":"changelog.html#feat_45","text":"ToolBar : add get_allowed_areas method WebEnginePage : add some additional methods WebEngineSettings : add delitem method Application : add send/post_event methods","title":"Feat"},{"location":"changelog.html#v01460-2020-12-13","text":"","title":"v0.146.0 (2020-12-13)"},{"location":"changelog.html#fix_41","text":"correctly serialize AbstractGraphicsShapeItem","title":"Fix"},{"location":"changelog.html#feat_46","text":"GuiApplication : add get_icon method PlainTextEdit : add get(_line)_wrap_mode methods GuiApplication : add get_application_state method","title":"Feat"},{"location":"changelog.html#v01450-2020-12-11","text":"","title":"v0.145.0 (2020-12-11)"},{"location":"changelog.html#fix_42","text":"GraphicsGridLayout : serialize correctly MediaRecorder : use correct module in set_video/audio_settings correct constant naming install_exceptionhook fix","title":"Fix"},{"location":"changelog.html#feat_47","text":"GridLayout : add get/set_origin_corner methods BoxLayout : add get/set_direction methods NetworkCookieJar : add add and set_cookies_from_url methods NetworkCookie : add set_expiration_date method Translator : add bool method custom_widgets : add RoundProgressBar class DateTimeEdit : add some more methods related to sections get/set_icon_size work for some widgets CalendarWidget : add set_range method HeaderView : add generate_header_id method Widget : add edit_palette contextmanager and get_font method Palette : add brush methods custom_models : add ImportlibDistributionModel class","title":"Feat"},{"location":"changelog.html#v01440-2020-12-09","text":"","title":"v0.144.0 (2020-12-09)"},{"location":"changelog.html#fix_43","text":"Settings : iter through key-value pairs correct inheritance for QuickItem ColumnItemModel : correct get_width signature","title":"Fix"},{"location":"changelog.html#feat_48","text":"qml : add QmlImageProviderbase class widgets : add TreeWidgetItemIterator class quick : add some more classes qml : add QmlParserStatus class Widget : add get_title method Painter : add get_text_rect method ListWidget : add add_item method","title":"Feat"},{"location":"changelog.html#v01430-2020-12-08","text":"","title":"v0.143.0 (2020-12-08)"},{"location":"changelog.html#fix_44","text":"ObjectBrowser fix","title":"Fix"},{"location":"changelog.html#feat_49","text":"implement eq method for some more validator classes","title":"Feat"},{"location":"changelog.html#v01421-2020-12-07","text":"","title":"v0.142.1 (2020-12-07)"},{"location":"changelog.html#fix_45","text":"use our own SizeF class","title":"Fix"},{"location":"changelog.html#v01420-2020-12-07","text":"","title":"v0.142.0 (2020-12-07)"},{"location":"changelog.html#feat_50","text":"SizeF : add some methods to be on par with Size Size : add expanded_to method CompositeValidator : add some additional methods custom_validators : add eq method to validator classes TreeWidgetItem : add some more methods widgets : add TableWidgetSelectionRange class core : add Calendar class core : add SignalMapper class core : add StateMachine class core : add LockFile class core : add JsonDocument/JsonValue classes GeoCircle : allow tuple in ctor core : add SocketNotifier class widgets : add Shortcut class","title":"Feat"},{"location":"changelog.html#fix_46","text":"Correctly inherit StyleItemDelegate","title":"Fix"},{"location":"changelog.html#v01410-2020-12-03","text":"","title":"v0.141.0 (2020-12-03)"},{"location":"changelog.html#feat_51","text":"core : add Collator(SortKey) classes","title":"Feat"},{"location":"changelog.html#fix_47","text":"github actions fix","title":"Fix"},{"location":"changelog.html#v01404-2020-12-02","text":"","title":"v0.140.4 (2020-12-02)"},{"location":"changelog.html#fix_48","text":"docs build fix","title":"Fix"},{"location":"changelog.html#v01403-2020-12-02","text":"","title":"v0.140.3 (2020-12-02)"},{"location":"changelog.html#fix_49","text":"docs deployment","title":"Fix"},{"location":"changelog.html#v01402-2020-12-02","text":"","title":"v0.140.2 (2020-12-02)"},{"location":"changelog.html#fix_50","text":"deploy check for github actions","title":"Fix"},{"location":"changelog.html#v01401-2020-12-02","text":"","title":"v0.140.1 (2020-12-02)"},{"location":"changelog.html#fix_51","text":"github actions: conditional deploy step","title":"Fix"},{"location":"changelog.html#v01400-2020-12-02","text":"","title":"v0.140.0 (2020-12-02)"},{"location":"changelog.html#feat_52","text":"gui : add ColorSpace class","title":"Feat"},{"location":"changelog.html#v01390-2020-12-02","text":"","title":"v0.139.0 (2020-12-02)"},{"location":"changelog.html#feat_53","text":"FileInfo/Dir : fallback to pathlib.Path methods widgets : add Proxy/CommonStyle classes widgets : add Gesture classes core : add TemporaryDir class widgets : add WhatsThis class core : add ItemSelectionRange class FormLayout : add some more methods core : add ProcessEnvironment class gui : add StaticText class core : add PauseAnimation class","title":"Feat"},{"location":"changelog.html#v01380-2020-12-01","text":"","title":"v0.138.0 (2020-12-01)"},{"location":"changelog.html#feat_54","text":"core : add ChildEvent / TimerEvent classes core : add IdentityProxyModel class gui : add SessionManager class gui : add InputMethod class core : add AbstractEventDispatcher class widgets : add StackedWidget class widgets : add some events FileInfo : add some additional methods gui : add Vector3D class core : add MimeType / MimeDatabase classes core : add SaveFile class core : add SignalBlocker class core : add TimeLine class gui : add Bitmap class core : add RandomGenerator class FileDevice : add get_error method widgets : add Dial class widgets : add RubberBand class Wizard/WizardPage : add some more methods widgets : add GraphicsRotation / GraphicsScale classes widgets : add GraphicsTransform class widgets : add LCDNumber class widgets : add Scroller(Properties) classes core : add CommandLineParser/Option classes Pixmap : add some more methods gui : add Screen class Transform : add some more methods add Abstract/PlainTextTextDocumentLayout classes core : add BasicTimer class core : add Resource class core : add StorageInfo class core : add ElapsedTimer class core : add CryptographicHash class","title":"Feat"},{"location":"changelog.html#v01371-2020-11-27","text":"","title":"v0.137.1 (2020-11-27)"},{"location":"changelog.html#fix_52","text":"doc build fix","title":"Fix"},{"location":"changelog.html#v01370-2020-11-27","text":"","title":"v0.137.0 (2020-11-27)"},{"location":"changelog.html#feat_55","text":"core : add OperatingSystemVersion class PdfWriter : add set_page_margins method core : add MarginsF class core : Add TextStream class core : add ByteArrayMatcher AbstractItemModel : add check_index method PlaceManager : add search_place method core : add app method add bytes method to some classes utils : add Singleton metaclass icon : add add_pixmap method gui : Add PixmapCache Font : add some more methods","title":"Feat"},{"location":"changelog.html#v01360-2020-11-26","text":"","title":"v0.136.0 (2020-11-26)"},{"location":"changelog.html#feat_56","text":"location : add PlaceResult class location : add PlaceProposedSearchResult class location : add clone_from method to reply classes Object : add has_id method","title":"Feat"},{"location":"changelog.html#fix_53","text":"emit inputandslider signal correctly on value change correct flag for constants.NO_CHILDREN","title":"Fix"},{"location":"changelog.html#v01350-2020-11-26","text":"","title":"v0.135.0 (2020-11-26)"},{"location":"changelog.html#feat_57","text":"WebEngineHistoryItem : add get_icon_url method location : add PlaceMatchReply / PlaceIdReply classes PlaceContentReply/PlaceSearchReply : add request methods gui : add TextListFormat class gui : add TextImageFormat class location : add some reply/result classes gui : add TextTableCellFormat class gui : add app method gui : add TextFrameFormat class Application : add get_font method add qthelp module quick : add QuickPaintedItem class gui : add TextBlockGroup class TextCharFormat : add get/set_vertical_alignment methods TextBlock : add contains method PaintDevice : add get_metric method GuiApplication : add get/set_layout_direction methods gui : add TextObject / TextLength / TextFrame / TextFormat classes core : add ItemSelection class GraphicsLayout : add set_margin method","title":"Feat"},{"location":"changelog.html#fix_54","text":"correctly add items for GraphicsGridLayout","title":"Fix"},{"location":"changelog.html#v01340-2020-11-23","text":"","title":"v0.134.0 (2020-11-23)"},{"location":"changelog.html#feat_58","text":"core : add PersistentModelIndex class core : add PluginLoader class core : add Library class gui : add PainterPathStroker class gui : add ImageWriter / ImageReader / ImageIOHandler classes quick : add QuickItem / QuickWindow classes core : add install_message_handler method gui : add RasterWindow / PaintDeviceWindow / OpenGLWindow classes svg : add SvgGenerator class SplashScreen : allow pixmap for ctor icon : add get_available_sizes method widget : add set_attributes method gui : add Vector4D / Matrix4x4 classes custom_widgets : add StarDelegate class custom_delegates : add ProgressBarDelegate class widgets : add missing StyleOption classes WidgetItems : some more methods Painter : add backup_state contextmanager","title":"Feat"},{"location":"changelog.html#fix_55","text":"KeySequenceEdit : correct repr correct coloring for WaitingSpinner","title":"Fix"},{"location":"changelog.html#v01331-2020-11-16","text":"","title":"v0.133.1 (2020-11-16)"},{"location":"changelog.html#fix_56","text":"test fix","title":"Fix"},{"location":"changelog.html#v01330-2020-11-16","text":"","title":"v0.133.0 (2020-11-16)"},{"location":"changelog.html#feat_59","text":"ComboBox : default param for add_items AbstractItemModel : add force_reset/force_layoutchange methods add location module gui : add FontMetricsF class GeoCoordinate : add bool method FontMetrics : add get_(tight_)bounding_rect methods Url : add to_string method network : add LocalServer / TcpServer classes multimediawidgets : add GraphicsVideoItem class mediaobject : add get_availability method add qt module","title":"Feat"},{"location":"changelog.html#v01321-2020-11-07","text":"","title":"v0.132.1 (2020-11-07)"},{"location":"changelog.html#fix_57","text":"import fix","title":"Fix"},{"location":"changelog.html#v01320-2020-11-07","text":"","title":"v0.132.0 (2020-11-07)"},{"location":"changelog.html#feat_60","text":"NetworkAccessManager : allow str for request network : add UdpSocket network : add NetworkAddressEntry / NetworkInterface classes add texttospeech module network : add NetworkDatagram class core : add DeadlineTimer class network : add HostAddress/AbstractSocket/TcpSocket classes network : add NetworkProxy class network : add HttpMultiPart class network : add HttpPart class NetworkRequest : add set/get_header methods","title":"Feat"},{"location":"changelog.html#v01310-2020-11-04","text":"","title":"v0.131.0 (2020-11-04)"},{"location":"changelog.html#feat_61","text":"webenginecore : add WebEngineHttpRequest class webenginewidgets : add WebEngineContextMenuData class webenginewidgets : add WebEngineScriptCollection class multimedia : add CameraExposure/CameraImageProcessing classes multimedia : add CameraFocus(Zone) classes webenginecore : add WebEngineUrlSchemeHandler","title":"Feat"},{"location":"changelog.html#v01300-2020-11-04","text":"","title":"v0.130.0 (2020-11-04)"},{"location":"changelog.html#feat_62","text":"WebEnginePage : add some settings methods webenginewidgets : add WebEngineSettings class add bluetooth module core : add Uuid class add quick module gui : add Surface and Window class multimedia : add ImageEncoderSettings multimedia : add MediaTimeRange and MediaTimeInterval classes","title":"Feat"},{"location":"changelog.html#v01291-2020-10-29","text":"","title":"v0.129.1 (2020-10-29)"},{"location":"changelog.html#fix_58","text":"fix tests fix multimedia tests for Travis","title":"Fix"},{"location":"changelog.html#feat_63","text":"charts : add Legend class WebEnginePage : add get_history method qml : add JSValue(Iterator) class VideoWidget : option for fullscreen toggling via double click multimedia : add CameraViewFinderSettings multimedia : add VideoFrame class multimedia : add AbstractPlanarVideoBuffer class multimedia : add AbstractVideoBuffer class multimedia : add Camera class multimedia : add CameraInfo class gui : add Clipboard class multimedia : add AudioFormat class multimedia : add SoundEffect class charts : add PieSlice class charts : add BoxSet and CandlestickSet classes charts : add Axis-related classes charts : add BarSeries-related classes","title":"Feat"},{"location":"changelog.html#v01281-2020-10-25","text":"","title":"v0.128.1 (2020-10-25)"},{"location":"changelog.html#fix_59","text":"import fix","title":"Fix"},{"location":"changelog.html#v01280-2020-10-25","text":"","title":"v0.128.0 (2020-10-25)"},{"location":"changelog.html#feat_64","text":"custom_widgets : add ExpandableLine class ParallelAnimationGroup : add set_duration method charts : add Abstract/ValueAxis and PolarChart classes core : add SequentialAnimationGroup class AnimationGroup : allow slicing for indexing AnimationGroup : add add_property_animation method ChartView : add get/set_rubber_band methods Chart : add some more methods core : add Locale class core : add Margins class webenginewidgets : add some more modules","title":"Feat"},{"location":"changelog.html#fix_60","text":"Chart : properly inherit from GraphicsWidget","title":"Fix"},{"location":"changelog.html#v01271-2020-10-20","text":"","title":"v0.127.1 (2020-10-20)"},{"location":"changelog.html#fix_61","text":"fix tests","title":"Fix"},{"location":"changelog.html#v01270-2020-10-20","text":"","title":"v0.127.0 (2020-10-20)"},{"location":"changelog.html#fix_62","text":"always import correct bindings for winextras module Url : allow initializing without arg","title":"Fix"},{"location":"changelog.html#feat_65","text":"PainterPath : add set_fill_rule method PainterPath : add get_bounding_rect method GraphicsItem : add get_shape method MediaPlaylist : add get_media_url method start with webenginecore module core : add EventLoop class Widget : add get_font_info method custom_models : add PlaylistModel Translator : add get_file_path method add positioning module add some first QtQml classes core : add LibraryInfo class Application : add iter method Application : add get/set_navigation_mode methods Application : add get/is_effect_enabled methods custom_widgets : add Player class","title":"Feat"},{"location":"changelog.html#v01260-2020-10-08","text":"","title":"v0.126.0 (2020-10-08)"},{"location":"changelog.html#feat_66","text":"core : add Process class DateTime : add get/set_time_spec and get_date/time methods core : add Time class DateTime : add timezone methods core : add TimeZone class Pixmap : add create_dot classmethod","title":"Feat"},{"location":"changelog.html#v01251-2020-10-07","text":"","title":"v0.125.1 (2020-10-07)"},{"location":"changelog.html#fix_63","text":"import fix","title":"Fix"},{"location":"changelog.html#v01250-2020-10-07","text":"","title":"v0.125.0 (2020-10-07)"},{"location":"changelog.html#feat_67","text":"widgets : add Transition classes core : add Transition classes","title":"Feat"},{"location":"changelog.html#fix_64","text":"fix Action.get_shortcut for NoneValue","title":"Fix"},{"location":"changelog.html#v01240-2020-10-05","text":"","title":"v0.124.0 (2020-10-05)"},{"location":"changelog.html#feat_68","text":"IODevice : add get_open_mode method Improve repr and add str method for Date and DateTime core : add TemporaryFile class FileDevice : add set/get_file_time methods MainWindow : allow setting central widget to None AbstractButton : add get_shortcut method Url : add from_user_input method WebEngineView : add get_url method FileInfo : support pathlib + add proper repr KeySequence : allow initializing with standard keys","title":"Feat"},{"location":"changelog.html#v01231-2020-09-29","text":"","title":"v0.123.1 (2020-09-29)"},{"location":"changelog.html#fix_65","text":"add missing State import in core module","title":"Fix"},{"location":"changelog.html#v01230-2020-09-29","text":"","title":"v0.123.0 (2020-09-29)"},{"location":"changelog.html#feat_69","text":"core : add State classes core : add TextBoundaryFinder class ProgressBar : add get/set_orientation methods + serialize work Action : allow setting callback with ctor WebEngineView : set subclassed WebEnginePage by default WebEnginePage : add some more methods and constants AbstractSlider : add get/set_orientation methods core : add FileInfo class webenginewidgets : add WebEngineProfile class","title":"Feat"},{"location":"changelog.html#v01221-2020-09-27","text":"","title":"v0.122.1 (2020-09-27)"},{"location":"changelog.html#fix_66","text":"use correct icon names","title":"Fix"},{"location":"changelog.html#v01220-2020-09-27","text":"","title":"v0.122.0 (2020-09-27)"},{"location":"changelog.html#feat_70","text":"gui : add PageLayout gui : add Movie class gui : add PageSize class gui : add FontInfo class core : add UrlQuery class add network module PropertyAnimation : add get/set_property_name methods core : add ParallelAnimationGroup widgets : add SizeGrip class widgets : add DataWidgetMapper class core : add StringListModel VersionNumber : add get_python_version gui : add Transform class Painter : add draw_polygon method add core.ByteArray","title":"Feat"},{"location":"changelog.html#v01210-2020-09-10","text":"","title":"v0.121.0 (2020-09-10)"},{"location":"changelog.html#feat_71","text":"Image : add setitem / getitem methods Line/LineF : add reversed and abs methods GraphicsScene : add get/set_item_index_method method","title":"Feat"},{"location":"changelog.html#fix_67","text":"serialization fixes","title":"Fix"},{"location":"changelog.html#v01200-2020-08-27","text":"","title":"v0.120.0 (2020-08-27)"},{"location":"changelog.html#feat_72","text":"GraphicsWidget : add set_layout method GraphicsLayout : add some magic methods GraphicsScene : add add_item_group method widgets : add GraphicsAnchorLayout / GraphicsGridLayout / GraphicsLinearLayout widgets : add GraphicsItemGroup Layout : add delitem method Polygon/PolygonF : add repr and iter methods PainterPath : some additional methods GraphicsItems : add repr methods Line/LineF : add repr and iter Application : allow loading included language files via load_language_file widgets : add GraphicsView class","title":"Feat"},{"location":"changelog.html#refactor","text":"PromptLineEdit rework","title":"Refactor"},{"location":"changelog.html#v01191-2020-08-24","text":"","title":"v0.119.1 (2020-08-24)"},{"location":"changelog.html#fix_68","text":"add missing StyleOptionComplex class","title":"Fix"},{"location":"changelog.html#v01190-2020-08-24","text":"","title":"v0.119.0 (2020-08-24)"},{"location":"changelog.html#feat_73","text":"GraphicsScene : add some convenience methods widgets : add graphicsitem classes StylePainter : add draw_complex_control method gui : allow pickling some more classes core : add LineF class Widget : add get_palette() method widgets : add GraphicsPixmapItem / GraphicsScene GraphicsItem : add getitem and setitem methods widgets : add Blur/Colorize/DropShadowEffect","title":"Feat"},{"location":"changelog.html#fix_69","text":"Graphicsitem collides methods fix KeySequence : pickling","title":"Fix"},{"location":"changelog.html#v01182-2020-08-17","text":"","title":"v0.118.2 (2020-08-17)"},{"location":"changelog.html#fix_70","text":"Fix tests","title":"Fix"},{"location":"changelog.html#v01181-2020-08-17","text":"","title":"v0.118.1 (2020-08-17)"},{"location":"changelog.html#fix_71","text":"MenuBar : fix add method","title":"Fix"},{"location":"changelog.html#v01180-2020-08-17","text":"","title":"v0.118.0 (2020-08-17)"},{"location":"changelog.html#refactor_1","text":"MenuBar : return subclassed types instead of qt classes","title":"Refactor"},{"location":"changelog.html#feat_74","text":"gui : add TextDocument / TextBlock / TextOption gui : add ConicalGradient / RadialGradient custom_widgets : add CollapsibleFrame GraphicsItem : add some more methods","title":"Feat"},{"location":"changelog.html#v01170-2020-08-16","text":"","title":"v0.117.0 (2020-08-16)"},{"location":"changelog.html#feat_75","text":"MimeData : add dict-like interface Timer : add get/set_type methods File : add repr and str methods Dir : add repr and truediv methods Frame : set/get_frame_shape, set/get_frame_shadow Splitter : add setitem method, and some more typing Polygon/PolygonF : pythonize core : add Abstract/Variant/PropertyAnimation and AnimationGroup core : add EasingCurve StyleOptionSlider : add get_orientation method","title":"Feat"},{"location":"changelog.html#refactor_2","text":"SpanSlider : clean up code","title":"Refactor"},{"location":"changelog.html#v01160-2020-08-13","text":"","title":"v0.116.0 (2020-08-13)"},{"location":"changelog.html#feat_76","text":"gui : add LinearGradient AbstractSlider : add get/set_repeat_action and trigger_action methods TabWidget : add get/set_tab_position methods Image/Pixmap : add bool method MenuBar : serialize stuff MdiArea : serialize stuff Brush : allow pickling + add get_texture_image method custom_widgets : add Timeline Pen : add methods for setting and getting style / join style / cap style","title":"Feat"},{"location":"changelog.html#refactor_3","text":"Painter : rework set_pen / get_pen","title":"Refactor"},{"location":"changelog.html#v01150-2020-08-12","text":"","title":"v0.115.0 (2020-08-12)"},{"location":"changelog.html#feat_77","text":"Polygon : add add_points method Object : add store_widget_states / restore_widget_states Painter : add paint_on, set_transparent_background, set_brush PainterPath : add add_rect method Application : add class_getitem","title":"Feat"},{"location":"changelog.html#fix_72","text":"RegexEditor : correctly initialize dialog","title":"Fix"},{"location":"changelog.html#v01141-2020-08-12","text":"","title":"v0.114.1 (2020-08-12)"},{"location":"changelog.html#fix_73","text":"HeaderView : fix saving state","title":"Fix"},{"location":"changelog.html#v01140-2020-08-12","text":"","title":"v0.114.0 (2020-08-12)"},{"location":"changelog.html#refactor_4","text":"use AutoSlot decorator","title":"Refactor"},{"location":"changelog.html#feat_78","text":"add autoslot decorator add prettyqt.debug","title":"Feat"},{"location":"changelog.html#v01130-2020-08-10","text":"","title":"v0.113.0 (2020-08-10)"},{"location":"changelog.html#feat_79","text":"gui : add PainterPath class gui : add Polygon class gui : palette improvements core : add Line class core : add TransposeProxyModel / ConcatenateTablesProxyModel add ObjectBrowser widgets : add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect Action : \"checked\" param for ctor gui : some magic methods + get_matches for KeySequence core : allow pickling VersionNumber / Size / Dir gui : add Gradient class add ColumnItemModel / ColumnItem Settings : add set_values method Widget : spacing kwarg for set_layout","title":"Feat"},{"location":"changelog.html#refactor_5","text":"add serialization stuff improve some repr methods","title":"Refactor"},{"location":"changelog.html#v01120-2020-08-04","text":"","title":"v0.112.0 (2020-08-04)"},{"location":"changelog.html#feat_80","text":"utils : add install_exceptionhook method FileSystemModel : add some more shortcuts for set_root_path core : add VersionNumber class Application : add get_icon method MessageBox : add show_exception method","title":"Feat"},{"location":"changelog.html#refactor_6","text":"improve compat with older Qt Versions","title":"Refactor"},{"location":"changelog.html#fix_74","text":"another test fix","title":"Fix"},{"location":"changelog.html#v01111-2020-08-03","text":"","title":"v0.111.1 (2020-08-03)"},{"location":"changelog.html#fix_75","text":"fix tests for Linux","title":"Fix"},{"location":"changelog.html#v01110-2020-08-03","text":"","title":"v0.111.0 (2020-08-03)"},{"location":"changelog.html#feat_81","text":"widgets : add FontComboBox StandardPaths : add class_getitem method Action : some more ctor kwargs Action : add get/set_menu_role methods, some pickle work","title":"Feat"},{"location":"changelog.html#refactor_7","text":"custom Exception for wrong params","title":"Refactor"},{"location":"changelog.html#fix_76","text":"Menu : disable separator widgetAction","title":"Fix"},{"location":"changelog.html#v01102-2020-08-03","text":"","title":"v0.110.2 (2020-08-03)"},{"location":"changelog.html#fix_77","text":"fix broken LogTextEdit","title":"Fix"},{"location":"changelog.html#v01101-2020-08-03","text":"","title":"v0.110.1 (2020-08-03)"},{"location":"changelog.html#fix_78","text":"LogTextEdit : improve exception handling SidebarWidget : some fixes related to set_marker","title":"Fix"},{"location":"changelog.html#v01100-2020-08-02","text":"","title":"v0.110.0 (2020-08-02)"},{"location":"changelog.html#refactor_8","text":"improve serialization for listitems Validator pickle work","title":"Refactor"},{"location":"changelog.html#feat_82","text":"Image : allow pickling DataStream : add create_bytearray / write_bytearray / copy_data methods core : add DataStream class","title":"Feat"},{"location":"changelog.html#v01090-2020-08-02","text":"","title":"v0.109.0 (2020-08-02)"},{"location":"changelog.html#feat_83","text":"widget : add pretty method for devtools GridLayout : allow adding tuples/lists","title":"Feat"},{"location":"changelog.html#refactor_9","text":"rework widget pickling move CheckboxDelegate to custom_delegates pickle stuff for undocommand","title":"Refactor"},{"location":"changelog.html#v01080-2020-07-31","text":"","title":"v0.108.0 (2020-07-31)"},{"location":"changelog.html#feat_84","text":"custom_delegates : add IconDelegate and NoFocusDelegate TableWidet : add getitem and setitem methods Icon : add from_image method allow str for layout. getitem (uses objectName) SidebarWidget : add set_marker method","title":"Feat"},{"location":"changelog.html#refactor_10","text":"move delegates to separate module","title":"Refactor"},{"location":"changelog.html#v01070-2020-07-29","text":"","title":"v0.107.0 (2020-07-29)"},{"location":"changelog.html#feat_85","text":"GridLayout : also allow adding LayoutItems via add method","title":"Feat"},{"location":"changelog.html#v01061-2020-07-29","text":"","title":"v0.106.1 (2020-07-29)"},{"location":"changelog.html#fix_79","text":"TabWidget : correctly close detached tabs on app close pickle fixes for toolbar and dockwidget PygmentsHighlighter : catch pygments KeyError","title":"Fix"},{"location":"changelog.html#v01060-2020-07-26","text":"","title":"v0.106.0 (2020-07-26)"},{"location":"changelog.html#feat_86","text":"gui : add DesktopServices class multimedia : add AudioRecorder class core : add StandardPaths class widgets : add Undo classes","title":"Feat"},{"location":"changelog.html#v01050-2020-07-24","text":"","title":"v0.105.0 (2020-07-24)"},{"location":"changelog.html#feat_87","text":"MediaRecorder : some new methods sort_by_column for tableview and treeview multimedia : dict-setter and getter for encodersettings","title":"Feat"},{"location":"changelog.html#refactor_11","text":"improve Url-Pathlib interoperability","title":"Refactor"},{"location":"changelog.html#fix_80","text":"PopupInfo : use PrimaryScreen geometry instead of screens[0] for positioning","title":"Fix"},{"location":"changelog.html#v01040-2020-07-23","text":"","title":"v0.104.0 (2020-07-23)"},{"location":"changelog.html#feat_88","text":"multimedia : add MediaRecorder AbstractItemModel : add getitem method multimedia : add VideoEncoderSettings / AudioEncoderSettings","title":"Feat"},{"location":"changelog.html#refactor_12","text":"use subclassed core.Size","title":"Refactor"},{"location":"changelog.html#v01030-2020-07-22","text":"","title":"v0.103.0 (2020-07-22)"},{"location":"changelog.html#feat_89","text":"ActionGroup : add getitem method MediaContent : add get_url method add multimediawidgets module add multimedia module PlainTextEdit : add allow_wheel_zoom method Object : name kwarg for find_parent method","title":"Feat"},{"location":"changelog.html#v01020-2020-07-21","text":"","title":"v0.102.0 (2020-07-21)"},{"location":"changelog.html#refactor_13","text":"move raise_dock to from Widget to Object SidebarWidget : some code cleanup, make settings button size configurable Widget : default state to True for set_attribute MainWindow : add return value for load_window_state","title":"Refactor"},{"location":"changelog.html#feat_90","text":"Object : add find_parent method PlainTextEdit : add style kwarg to set_syntaxhighlighter","title":"Feat"},{"location":"changelog.html#v01011-2020-07-20","text":"","title":"v0.101.1 (2020-07-20)"},{"location":"changelog.html#fix_81","text":"LogTextEdit : better integrate with custom qstylesheets","title":"Fix"},{"location":"changelog.html#v01010-2020-07-20","text":"","title":"v0.101.0 (2020-07-20)"},{"location":"changelog.html#feat_91","text":"MessageBox : add detail_text keyword argument to message method","title":"Feat"},{"location":"changelog.html#fix_82","text":"correct return type for gui.icon.get_icon","title":"Fix"},{"location":"changelog.html#v01000-2020-07-20","text":"","title":"v0.100.0 (2020-07-20)"},{"location":"changelog.html#feat_92","text":"ToolTip : add show_text method GuiApplication : add set_override_cursor / restore_override_cursor methods GuiApplication : add override_cursor context manager","title":"Feat"},{"location":"changelog.html#v0990-2020-07-18","text":"","title":"v0.99.0 (2020-07-18)"},{"location":"changelog.html#refactor_14","text":"FileChooserButton : typing and fixes Dataset : typing and fixes SidebarWidget : use button map instead of attaching button to widget","title":"Refactor"},{"location":"changelog.html#feat_93","text":"AbstractItemView : add scroll_to method","title":"Feat"},{"location":"changelog.html#v0985-2020-07-17","text":"","title":"v0.98.5 (2020-07-17)"},{"location":"changelog.html#perf","text":"add icon cache","title":"Perf"},{"location":"changelog.html#refactor_15","text":"use core.Settings for windows dark mode detection","title":"Refactor"},{"location":"changelog.html#v0984-2020-07-15","text":"","title":"v0.98.4 (2020-07-15)"},{"location":"changelog.html#fix_83","text":"use qta default icon color instead of black for default","title":"Fix"},{"location":"changelog.html#v0983-2020-07-15","text":"","title":"v0.98.3 (2020-07-15)"},{"location":"changelog.html#refactor_16","text":"properly set stylesheets by using contextmanager FontDialog : do not override current_font contextmanager move current_font context manager to Widget class","title":"Refactor"},{"location":"changelog.html#v0982-2020-07-15","text":"","title":"v0.98.2 (2020-07-15)"},{"location":"changelog.html#fix_84","text":"package name","title":"Fix"},{"location":"changelog.html#v0981-2020-07-15","text":"","title":"v0.98.1 (2020-07-15)"},{"location":"changelog.html#fix_85","text":"correctly reset stylesheet for widget validation background","title":"Fix"},{"location":"changelog.html#refactor_17","text":"use qstylizer for stylesheet editing","title":"Refactor"},{"location":"changelog.html#v0980-2020-07-15","text":"","title":"v0.98.0 (2020-07-15)"},{"location":"changelog.html#feat_94","text":"widgets : add StyleFactory","title":"Feat"},{"location":"changelog.html#refactor_18","text":"FontDatabase : make add_fonts_from_folder a classmethod","title":"Refactor"},{"location":"changelog.html#v0970-2020-07-15","text":"","title":"v0.97.0 (2020-07-15)"},{"location":"changelog.html#feat_95","text":"gui : add FontDatabase widgets : add Completer widgets : add ActionGroup","title":"Feat"},{"location":"changelog.html#v0960-2020-07-14","text":"","title":"v0.96.0 (2020-07-14)"},{"location":"changelog.html#feat_96","text":"SelectionWidget : default keyword argument for add_custom","title":"Feat"},{"location":"changelog.html#v0950-2020-07-14","text":"","title":"v0.95.0 (2020-07-14)"},{"location":"changelog.html#feat_97","text":"SelectionWidget : different options for custom type add PagedPaintDevice Widget : add set_margin method","title":"Feat"},{"location":"changelog.html#v0940-2020-07-14","text":"","title":"v0.94.0 (2020-07-14)"},{"location":"changelog.html#feat_98","text":"Widget : add Widget.font_metrics() SpacerItem : allow strings for size policy in ctor allow Mapping for listwidget.add_items","title":"Feat"},{"location":"changelog.html#refactor_19","text":"change to {value: label} dicts for FlagSelectionWidget.add_items","title":"Refactor"},{"location":"changelog.html#v0931-2020-07-14","text":"","title":"v0.93.1 (2020-07-14)"},{"location":"changelog.html#refactor_20","text":"typecheck for Mapping instead of dict for combobox / selectionwidget add_items method","title":"Refactor"},{"location":"changelog.html#v0930-2020-07-14","text":"","title":"v0.93.0 (2020-07-14)"},{"location":"changelog.html#feat_99","text":"add register_extensions function to settings module","title":"Feat"},{"location":"changelog.html#refactor_21","text":"Settings : do not override value method","title":"Refactor"},{"location":"changelog.html#v0921-2020-07-14","text":"","title":"v0.92.1 (2020-07-14)"},{"location":"changelog.html#fix_86","text":"winextras test fix","title":"Fix"},{"location":"changelog.html#v0920-2020-07-14","text":"","title":"v0.92.0 (2020-07-14)"},{"location":"changelog.html#feat_100","text":"add widgets.SystemTrayIcon add winextras module Label : set_indent method","title":"Feat"},{"location":"changelog.html#v0910-2020-07-13","text":"","title":"v0.91.0 (2020-07-13)"},{"location":"changelog.html#feat_101","text":"SidebarWidget : allow choosing layout MainWindow : add show_blocking method","title":"Feat"},{"location":"changelog.html#v0900-2020-07-13","text":"","title":"v0.90.0 (2020-07-13)"},{"location":"changelog.html#feat_102","text":"Toolbar : allow combinations of allowed areas for set_allowed_areas SidebarWidget : add optional settings menu","title":"Feat"},{"location":"changelog.html#v0891-2020-07-13","text":"","title":"v0.89.1 (2020-07-13)"},{"location":"changelog.html#refactor_22","text":"SelectionWidget : switch to {data: label} dicts for add_items to be in line with RadioButton","title":"Refactor"},{"location":"changelog.html#v0890-2020-07-13","text":"","title":"v0.89.0 (2020-07-13)"},{"location":"changelog.html#feat_103","text":"SidebarWidget : make button width configurable","title":"Feat"},{"location":"changelog.html#v0881-2020-07-13","text":"","title":"v0.88.1 (2020-07-13)"},{"location":"changelog.html#refactor_23","text":"ComboBox : use set_data for set_value","title":"Refactor"},{"location":"changelog.html#fix_87","text":"ComboBox : fix add_items method","title":"Fix"},{"location":"changelog.html#v0880-2020-07-13","text":"","title":"v0.88.0 (2020-07-13)"},{"location":"changelog.html#feat_104","text":"ComboBox : set_data method","title":"Feat"},{"location":"changelog.html#v0870-2020-07-13","text":"","title":"v0.87.0 (2020-07-13)"},{"location":"changelog.html#feat_105","text":"ComboBox : allow dict for add_items","title":"Feat"},{"location":"changelog.html#v0863-2020-07-12","text":"","title":"v0.86.3 (2020-07-12)"},{"location":"changelog.html#refactor_24","text":"RegexEditor : code cleanup","title":"Refactor"},{"location":"changelog.html#v0862-2020-07-12","text":"","title":"v0.86.2 (2020-07-12)"},{"location":"changelog.html#fix_88","text":"another deployment fix","title":"Fix"},{"location":"changelog.html#v0861-2020-07-12","text":"","title":"v0.86.1 (2020-07-12)"},{"location":"changelog.html#fix_89","text":"deployment fix","title":"Fix"},{"location":"changelog.html#v0860-2020-07-12","text":"","title":"v0.86.0 (2020-07-12)"},{"location":"changelog.html#feat_106","text":"add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line","title":"Feat"},{"location":"changelog.html#v0851-2020-07-10","text":"","title":"v0.85.1 (2020-07-10)"},{"location":"changelog.html#fix_90","text":"add missing pygments requirement","title":"Fix"},{"location":"changelog.html#v0850-2020-07-10","text":"","title":"v0.85.0 (2020-07-10)"},{"location":"changelog.html#feat_107","text":"dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method","title":"Feat"},{"location":"changelog.html#refactor_25","text":"CodeEditor : use pygments for syntax highlighting","title":"Refactor"},{"location":"changelog.html#v0840-2020-07-10","text":"","title":"v0.84.0 (2020-07-10)"},{"location":"changelog.html#feat_108","text":"sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child","title":"Feat"},{"location":"changelog.html#v0831-2020-07-09","text":"","title":"v0.83.1 (2020-07-09)"},{"location":"changelog.html#refactor_26","text":"move set_icon from window classes to widget class","title":"Refactor"},{"location":"changelog.html#v0830-2020-07-09","text":"","title":"v0.83.0 (2020-07-09)"},{"location":"changelog.html#feat_109","text":"add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager","title":"Feat"},{"location":"changelog.html#v0820-2020-07-09","text":"","title":"v0.82.0 (2020-07-09)"},{"location":"changelog.html#feat_110","text":"add Label.set_bold / set_italic / set_weight added Font.set_weight","title":"Feat"},{"location":"changelog.html#v0810-2020-07-08","text":"","title":"v0.81.0 (2020-07-08)"},{"location":"changelog.html#feat_111","text":"allow setting window icon color os dark mode detection","title":"Feat"},{"location":"changelog.html#v0801-2020-07-08","text":"","title":"v0.80.1 (2020-07-08)"},{"location":"changelog.html#fix_91","text":"Settings.value() returned wrong type","title":"Fix"},{"location":"changelog.html#v0800-2020-07-08","text":"","title":"v0.80.0 (2020-07-08)"},{"location":"changelog.html#feat_112","text":"add Widget.set_attribute add margin keyword argument to Widget.set_layout","title":"Feat"},{"location":"changelog.html#v0791-2020-07-08","text":"","title":"v0.79.1 (2020-07-08)"},{"location":"changelog.html#fix_92","text":"remove Qt logger on Application exit","title":"Fix"},{"location":"changelog.html#v0790-2020-07-08","text":"","title":"v0.79.0 (2020-07-08)"},{"location":"changelog.html#feat_113","text":"add widgets.Application.get_widget","title":"Feat"},{"location":"changelog.html#v0780-2020-07-08","text":"","title":"v0.78.0 (2020-07-08)"},{"location":"changelog.html#feat_114","text":"allow to save/load window state recursively. Saving needs to be done explicitely now.","title":"Feat"},{"location":"changelog.html#fix_93","text":"some fixes for core.Settings dict interface properly preserve types in core.Settings","title":"Fix"},{"location":"changelog.html#v0771-2020-07-07","text":"","title":"v0.77.1 (2020-07-07)"},{"location":"changelog.html#refactor_27","text":"also allow qt flag for Splitter ctor","title":"Refactor"},{"location":"changelog.html#fix_94","text":"return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview","title":"Fix"},{"location":"changelog.html#0770-2020-07-06","text":"","title":"0.77.0 (2020-07-06)"},{"location":"changelog.html#feat_115","text":"allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages","title":"Feat"},{"location":"changelog.html#fix_95","text":"fix Messagebox.message call","title":"Fix"},{"location":"changelog.html#refactor_28","text":"dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars","title":"Refactor"},{"location":"changelog.html#v0759-2020-07-05","text":"","title":"v0.75.9 (2020-07-05)"},{"location":"changelog.html#v0758-2020-07-05","text":"","title":"v0.75.8 (2020-07-05)"},{"location":"changelog.html#v0757-2020-07-05","text":"","title":"v0.75.7 (2020-07-05)"},{"location":"changelog.html#v0756-2020-07-05","text":"","title":"v0.75.6 (2020-07-05)"},{"location":"changelog.html#v0755-2020-07-05","text":"","title":"v0.75.5 (2020-07-05)"},{"location":"changelog.html#v0754-2020-07-05","text":"","title":"v0.75.4 (2020-07-05)"},{"location":"changelog.html#v0753-2020-07-05","text":"","title":"v0.75.3 (2020-07-05)"},{"location":"changelog.html#v0752-2020-07-05","text":"","title":"v0.75.2 (2020-07-05)"},{"location":"changelog.html#v0751-2020-07-05","text":"","title":"v0.75.1 (2020-07-05)"},{"location":"changelog.html#v0750-2020-07-05","text":"","title":"v0.75.0 (2020-07-05)"},{"location":"changelog.html#v0743-2020-07-05","text":"","title":"v0.74.3 (2020-07-05)"},{"location":"changelog.html#v0742-2020-07-05","text":"","title":"v0.74.2 (2020-07-05)"},{"location":"changelog.html#v0741-2020-07-05","text":"","title":"v0.74.1 (2020-07-05)"},{"location":"changelog.html#v0740-2020-07-05","text":"","title":"v0.74.0 (2020-07-05)"},{"location":"changelog.html#v0734-2020-07-04","text":"","title":"v0.73.4 (2020-07-04)"},{"location":"changelog.html#v0733-2020-07-04","text":"","title":"v0.73.3 (2020-07-04)"},{"location":"changelog.html#v0732-2020-07-04","text":"","title":"v0.73.2 (2020-07-04)"},{"location":"changelog.html#v0731-2020-07-04","text":"","title":"v0.73.1 (2020-07-04)"},{"location":"changelog.html#v0730-2020-07-02","text":"","title":"v0.73.0 (2020-07-02)"},{"location":"changelog.html#v0723-2020-07-01","text":"","title":"v0.72.3 (2020-07-01)"},{"location":"changelog.html#v0722-2020-07-01","text":"","title":"v0.72.2 (2020-07-01)"},{"location":"changelog.html#v0721-2020-07-01","text":"","title":"v0.72.1 (2020-07-01)"},{"location":"changelog.html#v0720-2020-07-01","text":"","title":"v0.72.0 (2020-07-01)"},{"location":"changelog.html#v0710-2020-06-30","text":"","title":"v0.71.0 (2020-06-30)"},{"location":"changelog.html#v0700-2020-06-30","text":"","title":"v0.70.0 (2020-06-30)"},{"location":"changelog.html#v0690-2020-06-29","text":"","title":"v0.69.0 (2020-06-29)"},{"location":"changelog.html#v0680-2020-06-29","text":"","title":"v0.68.0 (2020-06-29)"},{"location":"changelog.html#v0671-2020-06-28","text":"","title":"v0.67.1 (2020-06-28)"},{"location":"changelog.html#v0651-2020-06-24","text":"","title":"v0.65.1 (2020-06-24)"},{"location":"changelog.html#v0650-2020-06-24","text":"","title":"v0.65.0 (2020-06-24)"},{"location":"changelog.html#v0640-2020-06-24","text":"","title":"v0.64.0 (2020-06-24)"},{"location":"changelog.html#v0630-2020-06-22","text":"","title":"v0.63.0 (2020-06-22)"},{"location":"changelog.html#v0620-2020-06-21","text":"","title":"v0.62.0 (2020-06-21)"},{"location":"changelog.html#v0610-2020-06-21","text":"","title":"v0.61.0 (2020-06-21)"},{"location":"changelog.html#v0601-2020-06-21","text":"","title":"v0.60.1 (2020-06-21)"},{"location":"changelog.html#v0600-2020-06-20","text":"","title":"v0.60.0 (2020-06-20)"},{"location":"changelog.html#v0590-2020-06-20","text":"","title":"v0.59.0 (2020-06-20)"},{"location":"changelog.html#v0581-2020-06-19","text":"","title":"v0.58.1 (2020-06-19)"},{"location":"changelog.html#v0571-2020-06-15","text":"","title":"v0.57.1 (2020-06-15)"},{"location":"changelog.html#v0570-2020-06-14","text":"","title":"v0.57.0 (2020-06-14)"},{"location":"changelog.html#v0561-2020-06-10","text":"","title":"v0.56.1 (2020-06-10)"},{"location":"changelog.html#v0560-2020-06-10","text":"","title":"v0.56.0 (2020-06-10)"},{"location":"changelog.html#v0550-2020-06-09","text":"","title":"v0.55.0 (2020-06-09)"},{"location":"changelog.html#v0540-2020-06-08","text":"","title":"v0.54.0 (2020-06-08)"},{"location":"api/bluetooth.html","text":"bluetooth module bluetooth module. contains QtBluetooth-based classes","title":"bluetooth"},{"location":"api/bluetooth.html#bluetooth-module","text":"bluetooth module. contains QtBluetooth-based classes","title":"bluetooth module"},{"location":"api/charts.html","text":"charts module Charts module. abstractaxis AbstractAxis ( QAbstractAxis ) Source code in prettyqt/charts/abstractaxis.py class AbstractAxis ( QtCharts . QAbstractAxis ): def get_alignment ( self ) -> constants . SideStr | None : \"\"\"Return current alignment. Returns: alignment \"\"\" alignment = self . alignment () if alignment == constants . ALIGN_NONE : return None return constants . SIDES . inverse [ alignment ] def get_orientation ( self ) -> constants . OrientationStr | None : \"\"\"Return current orientation. Returns: orientation \"\"\" orientation = self . orientation () if orientation == constants . ORIENTATION_NONE : return None return constants . ORIENTATION . inverse [ orientation ] def get_grid_line_color ( self ) -> gui . Color : return gui . Color ( self . gridLineColor ()) def get_grid_line_pen ( self ) -> gui . Pen : return gui . Pen ( self . gridLinePen ()) def get_line_pen ( self ) -> gui . Pen : return gui . Pen ( self . linePen ()) def get_line_pen_color ( self ) -> gui . Color : return gui . Color ( self . linePenColor ()) def get_labels_color ( self ) -> gui . Color : return gui . Color ( self . labelsColor ()) def get_labels_brush ( self ) -> gui . Brush : return gui . Brush ( self . labelsBrush ()) def get_labels_font ( self ) -> gui . Font : return gui . Font ( self . labelsFont ()) def get_title_font ( self ) -> gui . Font : return gui . Font ( self . titleFont ()) def get_title_brush ( self ) -> gui . Brush : return gui . Brush ( self . titleBrush ()) def get_shades_color ( self ) -> gui . Color : return gui . Color ( self . shadesColor ()) def get_shades_brush ( self ) -> gui . Brush : return gui . Brush ( self . shadesBrush ()) def get_shades_pen ( self ) -> gui . Pen : return gui . Pen ( self . shadesPen ()) def get_shades_border_color ( self ) -> gui . Color : return gui . Color ( self . shadesBorderColor ()) def get_minor_grid_line_pen ( self ) -> gui . Pen : return gui . Pen ( self . minorGridLinePen ()) def get_minor_grid_line_color ( self ) -> gui . Color : return gui . Color ( self . minorGridLineColor ()) get_alignment ( self ) -> constants . SideStr | None Return current alignment. Returns: Type Description constants.SideStr | None alignment Source code in prettyqt/charts/abstractaxis.py def get_alignment ( self ) -> constants . SideStr | None : \"\"\"Return current alignment. Returns: alignment \"\"\" alignment = self . alignment () if alignment == constants . ALIGN_NONE : return None return constants . SIDES . inverse [ alignment ] get_orientation ( self ) -> constants . OrientationStr | None Return current orientation. Returns: Type Description constants.OrientationStr | None orientation Source code in prettyqt/charts/abstractaxis.py def get_orientation ( self ) -> constants . OrientationStr | None : \"\"\"Return current orientation. Returns: orientation \"\"\" orientation = self . orientation () if orientation == constants . ORIENTATION_NONE : return None return constants . ORIENTATION . inverse [ orientation ] abstractbarseries AbstractBarSeries ( QAbstractBarSeries ) Source code in prettyqt/charts/abstractbarseries.py class AbstractBarSeries ( QtCharts . QAbstractBarSeries ): def __delitem__ ( self , index : int ): barsets = self . barSets () self . remove ( barsets [ index ]) def __getitem__ ( self , index : int ) -> QtCharts . QBarSet : barsets = self . barSets () return barsets [ index ] def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ]) def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()] get_labels_position ( self ) -> LabelsPositionStr Return current labels position. Returns: Type Description LabelsPositionStr labels position Source code in prettyqt/charts/abstractbarseries.py def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()] set_labels_position ( self , position : LabelsPositionStr ) Set the labels position. Parameters: Name Type Description Default position LabelsPositionStr labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/abstractbarseries.py def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ]) categoryaxis CategoryAxis ( QCategoryAxis ) Source code in prettyqt/charts/categoryaxis.py class CategoryAxis ( QtCharts . QCategoryAxis ): def __delitem__ ( self , index : str ): self . remove ( index ) def __getitem__ ( self , label : int | slice ) -> str | list [ str ]: return self . categoriesLabels ()[ label ] def __setitem__ ( self , index : str , value : str ): self . replaceLabel ( index , value ) def __iter__ ( self ) -> Iterator [ str ]: return iter ( self . categoriesLabels ()) def __add__ ( self , other : tuple [ str , int ]) -> CategoryAxis : self . append ( * other ) return self def __len__ ( self ): # needed for PySide6 return self . count () def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ]) def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()] get_labels_position ( self ) -> LabelsPositionStr Return current labels position. Returns: Type Description LabelsPositionStr labels position Source code in prettyqt/charts/categoryaxis.py def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()] set_labels_position ( self , position : LabelsPositionStr ) Set the labels position. Parameters: Name Type Description Default position LabelsPositionStr labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/categoryaxis.py def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ]) chart Chart ( QChart ) Source code in prettyqt/charts/chart.py class Chart ( QtCharts . QChart ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . max_x = 0 self . max_y = 0 self . min_x = 0 self . min_y = 0 def serialize_fields ( self ): return dict ( animation_duration = self . animationDuration (), animation_easing_curve = self . get_animation_easing_curve (), animation_options = self . get_animation_options (), background_roundness = self . backgroundRoundness (), background_visible = self . isBackgroundVisible (), chart_type = self . get_chart_type (), drop_shadow_enabled = self . isDropShadowEnabled (), locale = self . get_locale (), localize_numbers = self . localizeNumbers (), margins = self . get_margins (), plot_area = self . get_plot_area (), plot_area_background_visible = self . isPlotAreaBackgroundVisible (), theme = self . get_theme (), title = self . title (), ) def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min () def hide_legend ( self ): self . legend () . hide () def show_legend ( self ): self . legend () . show () def get_legend ( self ) -> charts . Legend : return charts . Legend ( self . legend ()) def set_legend_alignment ( self , alignment : constants . SideStr ): if alignment not in constants . SIDES : raise InvalidParamError ( alignment , constants . SIDES ) self . legend () . setAlignment ( constants . SIDES [ alignment ]) def set_theme ( self , theme_name : ThemeStr ): self . setTheme ( THEMES [ theme_name ]) def set_margins ( self , margins : types . MarginsType ): if isinstance ( margins , tuple ): margins = QtCore . QMargins ( * margins ) self . setMargins ( margins ) def set_animation_options ( self , option : AnimationOptionStr ): self . setAnimationOptions ( ANIMATION_OPTIONS [ option ]) def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers () def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y )) def get_chart_type ( self ) -> ChartTypeStr : return CHART_TYPES . inverse [ self . chartType ()] def get_margins ( self ) -> core . Margins : return core . Margins ( self . margins ()) def get_plot_area ( self ) -> core . RectF : return core . RectF ( self . plotArea ()) def get_locale ( self ) -> core . Locale : return core . Locale ( self . locale ()) def get_theme ( self ) -> ThemeStr : return THEMES . inverse [ self . theme ()] def get_animation_options ( self ) -> list [ AnimationOptionStr ]: return [ k for k , v in ANIMATION_OPTIONS . items () if v & self . animationOptions ()] def get_animation_easing_curve ( self ) -> core . EasingCurve : return core . EasingCurve ( self . animationEasingCurve ()) apply_nice_numbers ( self ) Adjust both axis to display nice round numbers. Source code in prettyqt/charts/chart.py def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers () update_boundaries ( self ) Set new min/max values based on axis. Source code in prettyqt/charts/chart.py def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min () zoom_by_factor ( self , factor : float ) Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y )) chartview ChartView ( QChartView ) Source code in prettyqt/charts/chartview.py class ChartView ( QtCharts . QChartView ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) chart = charts . Chart () self . setChart ( chart ) self . setRenderHint ( gui . Painter . RenderHint . Antialiasing ) self . set_rubber_band ( \"rectangle\" ) # self.setDragMode(self.RubberBandDrag) def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key . Key_0 : self . chart () . apply_nice_numbers () else : super () . keyPressEvent ( event ) return event . accept () def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct ) def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . MouseButton . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return super () . mouseReleaseEvent ( event ) def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . MouseButton . RightButton : cursor = gui . Cursor ( QtCore . Qt . CursorShape . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . position () event . accept () super () . mousePressEvent ( event ) def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . MouseButton . RightButton : # type: ignore if not self . last_mouse_pos : return pos_diff = event . position () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . position () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event ) @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return self . chart () . show_legend () image = self . get_image () image . save ( str ( filename [ 0 ])) self . chart () . hide_legend () def get_image ( self ) -> QtGui . QPixmap : image = self . grab () gl_widget = self . find_child ( QtWidgets . QOpenGLWidget ) if gl_widget : d = gl_widget . mapToGlobal ( core . Point ()) - self . mapToGlobal ( core . Point ()) with gui . Painter ( image ) as painter : painter . set_composition_mode ( \"source_atop\" ) painter . drawImage ( d , gl_widget . grabFramebuffer ()) return image def set_rubber_band ( self , typ : RubberBandStr ): \"\"\"Set the rubber band type. Args: typ: rubber band type Raises: InvalidParamError: rubber band type does not exist \"\"\" if typ not in RUBBER_BAND : raise InvalidParamError ( typ , RUBBER_BAND ) self . setRubberBand ( RUBBER_BAND [ typ ]) def get_rubber_band ( self ) -> RubberBandStr : \"\"\"Return current rubber band type. Returns: Rubber band type \"\"\" return RUBBER_BAND . inverse [ self . rubberBand ()] # def hide_legend(self): # self.chart().hide_legend() # def show_legend(self): # self.chart().show_legend() # def set_legend_alignment(self, alignment: str): # if alignment not in constants.SIDES: # raise ValueError(f\"{alignment!r} not a valid alignment.\") # self.chart().legend().setAlignment(constants.SIDES[alignment]) get_rubber_band ( self ) -> RubberBandStr Return current rubber band type. Returns: Type Description RubberBandStr Rubber band type Source code in prettyqt/charts/chartview.py def get_rubber_band ( self ) -> RubberBandStr : \"\"\"Return current rubber band type. Returns: Rubber band type \"\"\" return RUBBER_BAND . inverse [ self . rubberBand ()] keyPressEvent ( self , event : QtGui . QKeyEvent ) Handle keypress events to allow navigation via keyboard. Source code in prettyqt/charts/chartview.py def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key . Key_0 : self . chart () . apply_nice_numbers () else : super () . keyPressEvent ( event ) return event . accept () mouseMoveEvent ( self , event : QtGui . QMouseEvent ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . MouseButton . RightButton : # type: ignore if not self . last_mouse_pos : return pos_diff = event . position () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . position () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event ) mousePressEvent ( self , event : QtGui . QMouseEvent ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . MouseButton . RightButton : cursor = gui . Cursor ( QtCore . Qt . CursorShape . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . position () event . accept () super () . mousePressEvent ( event ) mouseReleaseEvent ( self , event : QtGui . QMouseEvent ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . MouseButton . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return super () . mouseReleaseEvent ( event ) save_as_image ( self ) Let user choose folder and save chart as an image file. Source code in prettyqt/charts/chartview.py @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return self . chart () . show_legend () image = self . get_image () image . save ( str ( filename [ 0 ])) self . chart () . hide_legend () set_rubber_band ( self , typ : RubberBandStr ) Set the rubber band type. Parameters: Name Type Description Default typ RubberBandStr rubber band type required Exceptions: Type Description InvalidParamError rubber band type does not exist Source code in prettyqt/charts/chartview.py def set_rubber_band ( self , typ : RubberBandStr ): \"\"\"Set the rubber band type. Args: typ: rubber band type Raises: InvalidParamError: rubber band type does not exist \"\"\" if typ not in RUBBER_BAND : raise InvalidParamError ( typ , RUBBER_BAND ) self . setRubberBand ( RUBBER_BAND [ typ ]) wheelEvent ( self , event : QtGui . QWheelEvent ) Handle wheel event for zooming. Source code in prettyqt/charts/chartview.py def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct ) legend Legend Source code in prettyqt/charts/legend.py class Legend : def __init__ ( self , item : QtCharts . QLegend ): self . item = item def __getattr__ ( self , val ): return getattr ( self . item , val ) def serialize_fields ( self ): return dict ( alignment = self . get_alignment (), background_visible = self . isBackgroundVisible (), border_color = self . get_border_color (), color = self . get_color (), font = self . get_font (), label_color = self . get_label_color (), marker_shape = self . get_marker_shape (), reverse_markers = self . reverseMarkers (), show_tooltips = self . showToolTips (), ) def set_alignment ( self , alignment : constants . SideStr ): \"\"\"Set the alignment of the legend. Args: alignment: alignment for the legend Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . SIDES : raise InvalidParamError ( alignment , constants . SIDES ) self . setAlignment ( constants . SIDES [ alignment ]) def get_alignment ( self ) -> constants . SideStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . SIDES . inverse [ self . alignment ()] def set_marker_shape ( self , shape : MarkerShapeStr ): \"\"\"Set the marker shape. Args: shape: marker shape Raises: InvalidParamError: marker shape does not exist \"\"\" if shape not in MARKER_SHAPES : raise InvalidParamError ( shape , MARKER_SHAPES ) self . setMarkerShape ( MARKER_SHAPES [ shape ]) def get_marker_shape ( self ) -> MarkerShapeStr : \"\"\"Return current marker shape. Returns: Marker shape \"\"\" return MARKER_SHAPES . inverse [ self . markerShape ()] def get_border_color ( self ) -> gui . Color : return gui . Color ( self . borderColor ()) def get_color ( self ) -> gui . Color : return gui . Color ( self . color ()) def get_label_color ( self ) -> gui . Color : return gui . Color ( self . labelColor ()) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) get_alignment ( self ) -> constants . SideStr Return current alignment. Returns: Type Description constants.SideStr alignment Source code in prettyqt/charts/legend.py def get_alignment ( self ) -> constants . SideStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . SIDES . inverse [ self . alignment ()] get_marker_shape ( self ) -> MarkerShapeStr Return current marker shape. Returns: Type Description MarkerShapeStr Marker shape Source code in prettyqt/charts/legend.py def get_marker_shape ( self ) -> MarkerShapeStr : \"\"\"Return current marker shape. Returns: Marker shape \"\"\" return MARKER_SHAPES . inverse [ self . markerShape ()] set_alignment ( self , alignment : constants . SideStr ) Set the alignment of the legend. Parameters: Name Type Description Default alignment constants.SideStr alignment for the legend required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/charts/legend.py def set_alignment ( self , alignment : constants . SideStr ): \"\"\"Set the alignment of the legend. Args: alignment: alignment for the legend Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . SIDES : raise InvalidParamError ( alignment , constants . SIDES ) self . setAlignment ( constants . SIDES [ alignment ]) set_marker_shape ( self , shape : MarkerShapeStr ) Set the marker shape. Parameters: Name Type Description Default shape MarkerShapeStr marker shape required Exceptions: Type Description InvalidParamError marker shape does not exist Source code in prettyqt/charts/legend.py def set_marker_shape ( self , shape : MarkerShapeStr ): \"\"\"Set the marker shape. Args: shape: marker shape Raises: InvalidParamError: marker shape does not exist \"\"\" if shape not in MARKER_SHAPES : raise InvalidParamError ( shape , MARKER_SHAPES ) self . setMarkerShape ( MARKER_SHAPES [ shape ]) pieslice PieSlice ( QPieSlice ) Source code in prettyqt/charts/pieslice.py class PieSlice ( QtCharts . QPieSlice ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . label () !r} , { self . value () } )\" def set_label_position ( self , position : LabelPositionStr ): \"\"\"Set the label position. Args: position: label position Raises: InvalidParamError: label position does not exist \"\"\" if position not in LABEL_POSITION : raise InvalidParamError ( position , LABEL_POSITION ) self . setLabelPosition ( LABEL_POSITION [ position ]) def get_label_position ( self ) -> LabelPositionStr : \"\"\"Return current label position. Returns: label position \"\"\" return LABEL_POSITION . inverse [ self . labelPosition ()] def get_label_font ( self ) -> gui . Font : return gui . Font ( self . labelFont ()) def get_label_brush ( self ) -> gui . Brush : return gui . Brush ( self . labelBrush ()) def get_label_color ( self ) -> gui . Color : return gui . Color ( self . labelColor ()) def get_pen ( self ) -> gui . Pen : return gui . Pen ( self . pen ()) def get_brush ( self ) -> gui . Brush : return gui . Brush ( self . brush ()) def get_color ( self ) -> gui . Color : return gui . Color ( self . color ()) def get_border_color ( self ) -> gui . Color : return gui . Color ( self . borderColor ()) get_label_position ( self ) -> LabelPositionStr Return current label position. Returns: Type Description LabelPositionStr label position Source code in prettyqt/charts/pieslice.py def get_label_position ( self ) -> LabelPositionStr : \"\"\"Return current label position. Returns: label position \"\"\" return LABEL_POSITION . inverse [ self . labelPosition ()] set_label_position ( self , position : LabelPositionStr ) Set the label position. Parameters: Name Type Description Default position LabelPositionStr label position required Exceptions: Type Description InvalidParamError label position does not exist Source code in prettyqt/charts/pieslice.py def set_label_position ( self , position : LabelPositionStr ): \"\"\"Set the label position. Args: position: label position Raises: InvalidParamError: label position does not exist \"\"\" if position not in LABEL_POSITION : raise InvalidParamError ( position , LABEL_POSITION ) self . setLabelPosition ( LABEL_POSITION [ position ]) valueaxis ValueAxis ( QValueAxis ) Source code in prettyqt/charts/valueaxis.py class ValueAxis ( QtCharts . QValueAxis ): def set_tick_type ( self , tick_type : TickTypeStr ): \"\"\"Set the tick type of the legend. Args: tick_type: tick type for the legend Raises: InvalidParamError: tick type does not exist \"\"\" if tick_type not in TICK_TYPES : raise InvalidParamError ( tick_type , TICK_TYPES ) self . setTickType ( TICK_TYPES [ tick_type ]) def get_tick_type ( self ) -> TickTypeStr : \"\"\"Return current tick type. Returns: tick_type \"\"\" return TICK_TYPES . inverse [ self . tickType ()] get_tick_type ( self ) -> TickTypeStr Return current tick type. Returns: Type Description TickTypeStr tick_type Source code in prettyqt/charts/valueaxis.py def get_tick_type ( self ) -> TickTypeStr : \"\"\"Return current tick type. Returns: tick_type \"\"\" return TICK_TYPES . inverse [ self . tickType ()] set_tick_type ( self , tick_type : TickTypeStr ) Set the tick type of the legend. Parameters: Name Type Description Default tick_type TickTypeStr tick type for the legend required Exceptions: Type Description InvalidParamError tick type does not exist Source code in prettyqt/charts/valueaxis.py def set_tick_type ( self , tick_type : TickTypeStr ): \"\"\"Set the tick type of the legend. Args: tick_type: tick type for the legend Raises: InvalidParamError: tick type does not exist \"\"\" if tick_type not in TICK_TYPES : raise InvalidParamError ( tick_type , TICK_TYPES ) self . setTickType ( TICK_TYPES [ tick_type ])","title":"charts"},{"location":"api/charts.html#charts-module","text":"Charts module.","title":"charts module"},{"location":"api/charts.html#prettyqt.charts.abstractaxis","text":"","title":"abstractaxis"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxis","text":"Source code in prettyqt/charts/abstractaxis.py class AbstractAxis ( QtCharts . QAbstractAxis ): def get_alignment ( self ) -> constants . SideStr | None : \"\"\"Return current alignment. Returns: alignment \"\"\" alignment = self . alignment () if alignment == constants . ALIGN_NONE : return None return constants . SIDES . inverse [ alignment ] def get_orientation ( self ) -> constants . OrientationStr | None : \"\"\"Return current orientation. Returns: orientation \"\"\" orientation = self . orientation () if orientation == constants . ORIENTATION_NONE : return None return constants . ORIENTATION . inverse [ orientation ] def get_grid_line_color ( self ) -> gui . Color : return gui . Color ( self . gridLineColor ()) def get_grid_line_pen ( self ) -> gui . Pen : return gui . Pen ( self . gridLinePen ()) def get_line_pen ( self ) -> gui . Pen : return gui . Pen ( self . linePen ()) def get_line_pen_color ( self ) -> gui . Color : return gui . Color ( self . linePenColor ()) def get_labels_color ( self ) -> gui . Color : return gui . Color ( self . labelsColor ()) def get_labels_brush ( self ) -> gui . Brush : return gui . Brush ( self . labelsBrush ()) def get_labels_font ( self ) -> gui . Font : return gui . Font ( self . labelsFont ()) def get_title_font ( self ) -> gui . Font : return gui . Font ( self . titleFont ()) def get_title_brush ( self ) -> gui . Brush : return gui . Brush ( self . titleBrush ()) def get_shades_color ( self ) -> gui . Color : return gui . Color ( self . shadesColor ()) def get_shades_brush ( self ) -> gui . Brush : return gui . Brush ( self . shadesBrush ()) def get_shades_pen ( self ) -> gui . Pen : return gui . Pen ( self . shadesPen ()) def get_shades_border_color ( self ) -> gui . Color : return gui . Color ( self . shadesBorderColor ()) def get_minor_grid_line_pen ( self ) -> gui . Pen : return gui . Pen ( self . minorGridLinePen ()) def get_minor_grid_line_color ( self ) -> gui . Color : return gui . Color ( self . minorGridLineColor ())","title":"AbstractAxis"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxis.get_alignment","text":"Return current alignment. Returns: Type Description constants.SideStr | None alignment Source code in prettyqt/charts/abstractaxis.py def get_alignment ( self ) -> constants . SideStr | None : \"\"\"Return current alignment. Returns: alignment \"\"\" alignment = self . alignment () if alignment == constants . ALIGN_NONE : return None return constants . SIDES . inverse [ alignment ]","title":"get_alignment()"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxis.get_orientation","text":"Return current orientation. Returns: Type Description constants.OrientationStr | None orientation Source code in prettyqt/charts/abstractaxis.py def get_orientation ( self ) -> constants . OrientationStr | None : \"\"\"Return current orientation. Returns: orientation \"\"\" orientation = self . orientation () if orientation == constants . ORIENTATION_NONE : return None return constants . ORIENTATION . inverse [ orientation ]","title":"get_orientation()"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries","text":"","title":"abstractbarseries"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeries","text":"Source code in prettyqt/charts/abstractbarseries.py class AbstractBarSeries ( QtCharts . QAbstractBarSeries ): def __delitem__ ( self , index : int ): barsets = self . barSets () self . remove ( barsets [ index ]) def __getitem__ ( self , index : int ) -> QtCharts . QBarSet : barsets = self . barSets () return barsets [ index ] def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ]) def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()]","title":"AbstractBarSeries"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeries.get_labels_position","text":"Return current labels position. Returns: Type Description LabelsPositionStr labels position Source code in prettyqt/charts/abstractbarseries.py def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()]","title":"get_labels_position()"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeries.set_labels_position","text":"Set the labels position. Parameters: Name Type Description Default position LabelsPositionStr labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/abstractbarseries.py def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ])","title":"set_labels_position()"},{"location":"api/charts.html#prettyqt.charts.categoryaxis","text":"","title":"categoryaxis"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis","text":"Source code in prettyqt/charts/categoryaxis.py class CategoryAxis ( QtCharts . QCategoryAxis ): def __delitem__ ( self , index : str ): self . remove ( index ) def __getitem__ ( self , label : int | slice ) -> str | list [ str ]: return self . categoriesLabels ()[ label ] def __setitem__ ( self , index : str , value : str ): self . replaceLabel ( index , value ) def __iter__ ( self ) -> Iterator [ str ]: return iter ( self . categoriesLabels ()) def __add__ ( self , other : tuple [ str , int ]) -> CategoryAxis : self . append ( * other ) return self def __len__ ( self ): # needed for PySide6 return self . count () def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ]) def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()]","title":"CategoryAxis"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.get_labels_position","text":"Return current labels position. Returns: Type Description LabelsPositionStr labels position Source code in prettyqt/charts/categoryaxis.py def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()]","title":"get_labels_position()"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.set_labels_position","text":"Set the labels position. Parameters: Name Type Description Default position LabelsPositionStr labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/categoryaxis.py def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ])","title":"set_labels_position()"},{"location":"api/charts.html#prettyqt.charts.chart","text":"","title":"chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart","text":"Source code in prettyqt/charts/chart.py class Chart ( QtCharts . QChart ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . max_x = 0 self . max_y = 0 self . min_x = 0 self . min_y = 0 def serialize_fields ( self ): return dict ( animation_duration = self . animationDuration (), animation_easing_curve = self . get_animation_easing_curve (), animation_options = self . get_animation_options (), background_roundness = self . backgroundRoundness (), background_visible = self . isBackgroundVisible (), chart_type = self . get_chart_type (), drop_shadow_enabled = self . isDropShadowEnabled (), locale = self . get_locale (), localize_numbers = self . localizeNumbers (), margins = self . get_margins (), plot_area = self . get_plot_area (), plot_area_background_visible = self . isPlotAreaBackgroundVisible (), theme = self . get_theme (), title = self . title (), ) def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min () def hide_legend ( self ): self . legend () . hide () def show_legend ( self ): self . legend () . show () def get_legend ( self ) -> charts . Legend : return charts . Legend ( self . legend ()) def set_legend_alignment ( self , alignment : constants . SideStr ): if alignment not in constants . SIDES : raise InvalidParamError ( alignment , constants . SIDES ) self . legend () . setAlignment ( constants . SIDES [ alignment ]) def set_theme ( self , theme_name : ThemeStr ): self . setTheme ( THEMES [ theme_name ]) def set_margins ( self , margins : types . MarginsType ): if isinstance ( margins , tuple ): margins = QtCore . QMargins ( * margins ) self . setMargins ( margins ) def set_animation_options ( self , option : AnimationOptionStr ): self . setAnimationOptions ( ANIMATION_OPTIONS [ option ]) def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers () def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y )) def get_chart_type ( self ) -> ChartTypeStr : return CHART_TYPES . inverse [ self . chartType ()] def get_margins ( self ) -> core . Margins : return core . Margins ( self . margins ()) def get_plot_area ( self ) -> core . RectF : return core . RectF ( self . plotArea ()) def get_locale ( self ) -> core . Locale : return core . Locale ( self . locale ()) def get_theme ( self ) -> ThemeStr : return THEMES . inverse [ self . theme ()] def get_animation_options ( self ) -> list [ AnimationOptionStr ]: return [ k for k , v in ANIMATION_OPTIONS . items () if v & self . animationOptions ()] def get_animation_easing_curve ( self ) -> core . EasingCurve : return core . EasingCurve ( self . animationEasingCurve ())","title":"Chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.apply_nice_numbers","text":"Adjust both axis to display nice round numbers. Source code in prettyqt/charts/chart.py def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers ()","title":"apply_nice_numbers()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.update_boundaries","text":"Set new min/max values based on axis. Source code in prettyqt/charts/chart.py def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min ()","title":"update_boundaries()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.zoom_by_factor","text":"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y ))","title":"zoom_by_factor()"},{"location":"api/charts.html#prettyqt.charts.chartview","text":"","title":"chartview"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView","text":"Source code in prettyqt/charts/chartview.py class ChartView ( QtCharts . QChartView ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) chart = charts . Chart () self . setChart ( chart ) self . setRenderHint ( gui . Painter . RenderHint . Antialiasing ) self . set_rubber_band ( \"rectangle\" ) # self.setDragMode(self.RubberBandDrag) def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key . Key_0 : self . chart () . apply_nice_numbers () else : super () . keyPressEvent ( event ) return event . accept () def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct ) def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . MouseButton . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return super () . mouseReleaseEvent ( event ) def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . MouseButton . RightButton : cursor = gui . Cursor ( QtCore . Qt . CursorShape . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . position () event . accept () super () . mousePressEvent ( event ) def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . MouseButton . RightButton : # type: ignore if not self . last_mouse_pos : return pos_diff = event . position () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . position () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event ) @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return self . chart () . show_legend () image = self . get_image () image . save ( str ( filename [ 0 ])) self . chart () . hide_legend () def get_image ( self ) -> QtGui . QPixmap : image = self . grab () gl_widget = self . find_child ( QtWidgets . QOpenGLWidget ) if gl_widget : d = gl_widget . mapToGlobal ( core . Point ()) - self . mapToGlobal ( core . Point ()) with gui . Painter ( image ) as painter : painter . set_composition_mode ( \"source_atop\" ) painter . drawImage ( d , gl_widget . grabFramebuffer ()) return image def set_rubber_band ( self , typ : RubberBandStr ): \"\"\"Set the rubber band type. Args: typ: rubber band type Raises: InvalidParamError: rubber band type does not exist \"\"\" if typ not in RUBBER_BAND : raise InvalidParamError ( typ , RUBBER_BAND ) self . setRubberBand ( RUBBER_BAND [ typ ]) def get_rubber_band ( self ) -> RubberBandStr : \"\"\"Return current rubber band type. Returns: Rubber band type \"\"\" return RUBBER_BAND . inverse [ self . rubberBand ()] # def hide_legend(self): # self.chart().hide_legend() # def show_legend(self): # self.chart().show_legend() # def set_legend_alignment(self, alignment: str): # if alignment not in constants.SIDES: # raise ValueError(f\"{alignment!r} not a valid alignment.\") # self.chart().legend().setAlignment(constants.SIDES[alignment])","title":"ChartView"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.get_rubber_band","text":"Return current rubber band type. Returns: Type Description RubberBandStr Rubber band type Source code in prettyqt/charts/chartview.py def get_rubber_band ( self ) -> RubberBandStr : \"\"\"Return current rubber band type. Returns: Rubber band type \"\"\" return RUBBER_BAND . inverse [ self . rubberBand ()]","title":"get_rubber_band()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.keyPressEvent","text":"Handle keypress events to allow navigation via keyboard. Source code in prettyqt/charts/chartview.py def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key . Key_0 : self . chart () . apply_nice_numbers () else : super () . keyPressEvent ( event ) return event . accept ()","title":"keyPressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseMoveEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . MouseButton . RightButton : # type: ignore if not self . last_mouse_pos : return pos_diff = event . position () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . position () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event )","title":"mouseMoveEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mousePressEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . MouseButton . RightButton : cursor = gui . Cursor ( QtCore . Qt . CursorShape . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . position () event . accept () super () . mousePressEvent ( event )","title":"mousePressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseReleaseEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . MouseButton . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return super () . mouseReleaseEvent ( event )","title":"mouseReleaseEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.save_as_image","text":"Let user choose folder and save chart as an image file. Source code in prettyqt/charts/chartview.py @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return self . chart () . show_legend () image = self . get_image () image . save ( str ( filename [ 0 ])) self . chart () . hide_legend ()","title":"save_as_image()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.set_rubber_band","text":"Set the rubber band type. Parameters: Name Type Description Default typ RubberBandStr rubber band type required Exceptions: Type Description InvalidParamError rubber band type does not exist Source code in prettyqt/charts/chartview.py def set_rubber_band ( self , typ : RubberBandStr ): \"\"\"Set the rubber band type. Args: typ: rubber band type Raises: InvalidParamError: rubber band type does not exist \"\"\" if typ not in RUBBER_BAND : raise InvalidParamError ( typ , RUBBER_BAND ) self . setRubberBand ( RUBBER_BAND [ typ ])","title":"set_rubber_band()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.wheelEvent","text":"Handle wheel event for zooming. Source code in prettyqt/charts/chartview.py def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct )","title":"wheelEvent()"},{"location":"api/charts.html#prettyqt.charts.legend","text":"","title":"legend"},{"location":"api/charts.html#prettyqt.charts.legend.Legend","text":"Source code in prettyqt/charts/legend.py class Legend : def __init__ ( self , item : QtCharts . QLegend ): self . item = item def __getattr__ ( self , val ): return getattr ( self . item , val ) def serialize_fields ( self ): return dict ( alignment = self . get_alignment (), background_visible = self . isBackgroundVisible (), border_color = self . get_border_color (), color = self . get_color (), font = self . get_font (), label_color = self . get_label_color (), marker_shape = self . get_marker_shape (), reverse_markers = self . reverseMarkers (), show_tooltips = self . showToolTips (), ) def set_alignment ( self , alignment : constants . SideStr ): \"\"\"Set the alignment of the legend. Args: alignment: alignment for the legend Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . SIDES : raise InvalidParamError ( alignment , constants . SIDES ) self . setAlignment ( constants . SIDES [ alignment ]) def get_alignment ( self ) -> constants . SideStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . SIDES . inverse [ self . alignment ()] def set_marker_shape ( self , shape : MarkerShapeStr ): \"\"\"Set the marker shape. Args: shape: marker shape Raises: InvalidParamError: marker shape does not exist \"\"\" if shape not in MARKER_SHAPES : raise InvalidParamError ( shape , MARKER_SHAPES ) self . setMarkerShape ( MARKER_SHAPES [ shape ]) def get_marker_shape ( self ) -> MarkerShapeStr : \"\"\"Return current marker shape. Returns: Marker shape \"\"\" return MARKER_SHAPES . inverse [ self . markerShape ()] def get_border_color ( self ) -> gui . Color : return gui . Color ( self . borderColor ()) def get_color ( self ) -> gui . Color : return gui . Color ( self . color ()) def get_label_color ( self ) -> gui . Color : return gui . Color ( self . labelColor ()) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ())","title":"Legend"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_alignment","text":"Return current alignment. Returns: Type Description constants.SideStr alignment Source code in prettyqt/charts/legend.py def get_alignment ( self ) -> constants . SideStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . SIDES . inverse [ self . alignment ()]","title":"get_alignment()"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_marker_shape","text":"Return current marker shape. Returns: Type Description MarkerShapeStr Marker shape Source code in prettyqt/charts/legend.py def get_marker_shape ( self ) -> MarkerShapeStr : \"\"\"Return current marker shape. Returns: Marker shape \"\"\" return MARKER_SHAPES . inverse [ self . markerShape ()]","title":"get_marker_shape()"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_alignment","text":"Set the alignment of the legend. Parameters: Name Type Description Default alignment constants.SideStr alignment for the legend required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/charts/legend.py def set_alignment ( self , alignment : constants . SideStr ): \"\"\"Set the alignment of the legend. Args: alignment: alignment for the legend Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . SIDES : raise InvalidParamError ( alignment , constants . SIDES ) self . setAlignment ( constants . SIDES [ alignment ])","title":"set_alignment()"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_marker_shape","text":"Set the marker shape. Parameters: Name Type Description Default shape MarkerShapeStr marker shape required Exceptions: Type Description InvalidParamError marker shape does not exist Source code in prettyqt/charts/legend.py def set_marker_shape ( self , shape : MarkerShapeStr ): \"\"\"Set the marker shape. Args: shape: marker shape Raises: InvalidParamError: marker shape does not exist \"\"\" if shape not in MARKER_SHAPES : raise InvalidParamError ( shape , MARKER_SHAPES ) self . setMarkerShape ( MARKER_SHAPES [ shape ])","title":"set_marker_shape()"},{"location":"api/charts.html#prettyqt.charts.pieslice","text":"","title":"pieslice"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice","text":"Source code in prettyqt/charts/pieslice.py class PieSlice ( QtCharts . QPieSlice ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . label () !r} , { self . value () } )\" def set_label_position ( self , position : LabelPositionStr ): \"\"\"Set the label position. Args: position: label position Raises: InvalidParamError: label position does not exist \"\"\" if position not in LABEL_POSITION : raise InvalidParamError ( position , LABEL_POSITION ) self . setLabelPosition ( LABEL_POSITION [ position ]) def get_label_position ( self ) -> LabelPositionStr : \"\"\"Return current label position. Returns: label position \"\"\" return LABEL_POSITION . inverse [ self . labelPosition ()] def get_label_font ( self ) -> gui . Font : return gui . Font ( self . labelFont ()) def get_label_brush ( self ) -> gui . Brush : return gui . Brush ( self . labelBrush ()) def get_label_color ( self ) -> gui . Color : return gui . Color ( self . labelColor ()) def get_pen ( self ) -> gui . Pen : return gui . Pen ( self . pen ()) def get_brush ( self ) -> gui . Brush : return gui . Brush ( self . brush ()) def get_color ( self ) -> gui . Color : return gui . Color ( self . color ()) def get_border_color ( self ) -> gui . Color : return gui . Color ( self . borderColor ())","title":"PieSlice"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.get_label_position","text":"Return current label position. Returns: Type Description LabelPositionStr label position Source code in prettyqt/charts/pieslice.py def get_label_position ( self ) -> LabelPositionStr : \"\"\"Return current label position. Returns: label position \"\"\" return LABEL_POSITION . inverse [ self . labelPosition ()]","title":"get_label_position()"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.set_label_position","text":"Set the label position. Parameters: Name Type Description Default position LabelPositionStr label position required Exceptions: Type Description InvalidParamError label position does not exist Source code in prettyqt/charts/pieslice.py def set_label_position ( self , position : LabelPositionStr ): \"\"\"Set the label position. Args: position: label position Raises: InvalidParamError: label position does not exist \"\"\" if position not in LABEL_POSITION : raise InvalidParamError ( position , LABEL_POSITION ) self . setLabelPosition ( LABEL_POSITION [ position ])","title":"set_label_position()"},{"location":"api/charts.html#prettyqt.charts.valueaxis","text":"","title":"valueaxis"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxis","text":"Source code in prettyqt/charts/valueaxis.py class ValueAxis ( QtCharts . QValueAxis ): def set_tick_type ( self , tick_type : TickTypeStr ): \"\"\"Set the tick type of the legend. Args: tick_type: tick type for the legend Raises: InvalidParamError: tick type does not exist \"\"\" if tick_type not in TICK_TYPES : raise InvalidParamError ( tick_type , TICK_TYPES ) self . setTickType ( TICK_TYPES [ tick_type ]) def get_tick_type ( self ) -> TickTypeStr : \"\"\"Return current tick type. Returns: tick_type \"\"\" return TICK_TYPES . inverse [ self . tickType ()]","title":"ValueAxis"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxis.get_tick_type","text":"Return current tick type. Returns: Type Description TickTypeStr tick_type Source code in prettyqt/charts/valueaxis.py def get_tick_type ( self ) -> TickTypeStr : \"\"\"Return current tick type. Returns: tick_type \"\"\" return TICK_TYPES . inverse [ self . tickType ()]","title":"get_tick_type()"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxis.set_tick_type","text":"Set the tick type of the legend. Parameters: Name Type Description Default tick_type TickTypeStr tick type for the legend required Exceptions: Type Description InvalidParamError tick type does not exist Source code in prettyqt/charts/valueaxis.py def set_tick_type ( self , tick_type : TickTypeStr ): \"\"\"Set the tick type of the legend. Args: tick_type: tick type for the legend Raises: InvalidParamError: tick type does not exist \"\"\" if tick_type not in TICK_TYPES : raise InvalidParamError ( tick_type , TICK_TYPES ) self . setTickType ( TICK_TYPES [ tick_type ])","title":"set_tick_type()"},{"location":"api/constants.html","text":"constants module Constants module.","title":"constants"},{"location":"api/constants.html#constants-module","text":"Constants module.","title":"constants module"},{"location":"api/core.html","text":"core module Core module. Contains QtCore-based classes abstractanimation AbstractAnimation ( QAbstractAnimation ) Source code in prettyqt/core/abstractanimation.py class AbstractAnimation ( QtCore . QAbstractAnimation ): def __len__ ( self ): return self . duration () def __and__ ( self , other : AbstractAnimation ) -> core . SequentialAnimationGroup : group = core . SequentialAnimationGroup () group . addAnimation ( self ) group . addAnimation ( other ) return group def __or__ ( self , other : AbstractAnimation ) -> core . ParallelAnimationGroup : group = core . ParallelAnimationGroup () group . addAnimation ( self ) group . addAnimation ( other ) return group def serialize_fields ( self ): return dict ( duration = self . duration (), direction = self . get_direction (), loop_count = self . loopCount (), current_time = self . currentTime (), ) def set_direction ( self , direction : DirectionStr ): \"\"\"Set animation direction. Args: direction: animation direction Raises: InvalidParamError: animation direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) def get_direction ( self ) -> DirectionStr : \"\"\"Get the current animation direction. Returns: animation direction \"\"\" return DIRECTION . inverse [ self . direction ()] def get_state ( self ) -> StateStr : \"\"\"Get the current animation state. Returns: animation state \"\"\" return STATE . inverse [ self . state ()] def start_animation ( self , policy : DeletionPolicyStr = \"keep\" ): \"\"\"Start the animation. Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" if policy not in DELETION_POLICY : raise InvalidParamError ( policy , DELETION_POLICY ) self . start ( DELETION_POLICY [ policy ]) def restart_animation ( self , policy : DeletionPolicyStr = \"keep\" ): \"\"\"Restart the animation. Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" self . stop () self . start_animation ( policy ) get_direction ( self ) -> DirectionStr Get the current animation direction. Returns: Type Description DirectionStr animation direction Source code in prettyqt/core/abstractanimation.py def get_direction ( self ) -> DirectionStr : \"\"\"Get the current animation direction. Returns: animation direction \"\"\" return DIRECTION . inverse [ self . direction ()] get_state ( self ) -> StateStr Get the current animation state. Returns: Type Description StateStr animation state Source code in prettyqt/core/abstractanimation.py def get_state ( self ) -> StateStr : \"\"\"Get the current animation state. Returns: animation state \"\"\" return STATE . inverse [ self . state ()] restart_animation ( self , policy : DeletionPolicyStr = 'keep' ) Restart the animation. Parameters: Name Type Description Default policy DeletionPolicyStr animation policy 'keep' Exceptions: Type Description InvalidParamError animation policy does not exist Source code in prettyqt/core/abstractanimation.py def restart_animation ( self , policy : DeletionPolicyStr = \"keep\" ): \"\"\"Restart the animation. Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" self . stop () self . start_animation ( policy ) set_direction ( self , direction : DirectionStr ) Set animation direction. Parameters: Name Type Description Default direction DirectionStr animation direction required Exceptions: Type Description InvalidParamError animation direction does not exist Source code in prettyqt/core/abstractanimation.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set animation direction. Args: direction: animation direction Raises: InvalidParamError: animation direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) start_animation ( self , policy : DeletionPolicyStr = 'keep' ) Start the animation. Parameters: Name Type Description Default policy DeletionPolicyStr animation policy 'keep' Exceptions: Type Description InvalidParamError animation policy does not exist Source code in prettyqt/core/abstractanimation.py def start_animation ( self , policy : DeletionPolicyStr = \"keep\" ): \"\"\"Start the animation. Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" if policy not in DELETION_POLICY : raise InvalidParamError ( policy , DELETION_POLICY ) self . start ( DELETION_POLICY [ policy ]) abstractitemmodel AbstractItemModel ( QAbstractItemModel ) Source code in prettyqt/core/abstractitemmodel.py class AbstractItemModel ( QtCore . QAbstractItemModel ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } : { self . rowCount () } rows\" def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount () # causes issues with PySide2 # def __getitem__(self, index: Tuple[int, int]) -> QtCore.QModelIndex: # return self.index(*index) def check_index ( self , index : QtCore . QModelIndex , index_is_valid : bool = False , do_not_use_parent : bool = False , parent_is_invalid : bool = False , ) -> bool : flag = QtCore . QAbstractItemModel . CheckIndexOption . NoOption if index_is_valid : flag |= CHECK_INDEX_OPTIONS [ \"index_is_valid\" ] # type: ignore if do_not_use_parent : flag |= CHECK_INDEX_OPTIONS [ \"do_not_use_parent\" ] # type: ignore if parent_is_invalid : flag |= CHECK_INDEX_OPTIONS [ \"parent_is_invalid\" ] # type: ignore check_flag = QtCore . QAbstractItemModel . CheckIndexOption ( 0 ) | flag # type: ignore if qt . API . endswith ( \"5\" ): check_flag = QtCore . QAbstractItemModel . CheckIndexOptions ( check_flag ) return self . checkIndex ( index , check_flag ) # type: ignore @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit () @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel () def update_row ( self , row : int ): start_index = self . index ( row , 0 ) end_index = self . index ( row , self . columnCount () - 1 ) self . dataChanged . emit ( start_index , end_index ) @contextlib . contextmanager def remove_rows ( self , first : int | None = None , last : int | None = None , parent : QtCore . QModelIndex | None = None , ): parent = QtCore . QModelIndex () if parent is None else parent first = first if first is not None else 0 last = last if last is not None else self . rowCount () self . beginRemoveRows ( parent , first , last ) yield None self . endRemoveRows () @contextlib . contextmanager def remove_columns ( self , first : int | None = None , last : int | None = None , parent : QtCore . QModelIndex | None = None , ): parent = QtCore . QModelIndex () if parent is None else parent first = first if first is not None else 0 last = last if last is not None else self . rowCount () self . beginRemoveColumns ( parent , first , last ) yield None self . endRemoveColumns () @contextlib . contextmanager def insert_rows ( self , first : int | None = None , last : int | None = None , parent : QtCore . QModelIndex | None = None , ): parent = QtCore . QModelIndex () if parent is None else parent first = first if first is not None else 0 last = last if last is not None else self . rowCount () self . beginInsertRows ( parent , first , last ) yield None self . endInsertRows () @contextlib . contextmanager def append_rows ( self , num_rows : int , parent : QtCore . QModelIndex | None = None ): parent = QtCore . QModelIndex () if parent is None else parent self . beginInsertRows ( parent , self . rowCount (), self . rowCount () + num_rows - 1 ) yield None self . endInsertRows () @contextlib . contextmanager def insert_columns ( self , first : int | None = None , last : int | None = None , parent : QtCore . QModelIndex | None = None , ): parent = QtCore . QModelIndex () if parent is None else parent first = first if first is not None else 0 last = last if last is not None else self . rowCount () self . beginInsertColumns ( parent , first , last ) yield None self . endInsertColumns () def force_reset ( self ): self . beginResetModel () self . endResetModel () def force_layoutchange ( self ): self . layoutAboutToBeChanged . emit () self . layoutChanged . emit () __len__ ( self ) -> int special Return amount of rows. Source code in prettyqt/core/abstractitemmodel.py def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount () change_layout ( self ) Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit () reset_model ( self ) Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel () collator Collator ( QCollator ) Source code in prettyqt/core/collator.py class Collator ( QtCore . QCollator ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_locale () !r} )\" def get_locale ( self ) -> core . Locale : return core . Locale ( self . locale ()) def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = ( QtCore . Qt . CaseSensitivity . CaseSensitive if state else QtCore . Qt . CaseSensitivity . CaseInsensitive ) self . setCaseSensitivity ( sensitivity ) def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ()) def get_sort_key ( self , string : str ) -> core . CollatorSortKey : return core . CollatorSortKey ( self . sortKey ( string )) is_case_sensitive ( self ) -> bool Return case sensitivity. Returns: Type Description bool case sensitivity Source code in prettyqt/core/collator.py def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ()) set_case_sensitive ( self , state : bool ) Set case sensitivity. Parameters: Name Type Description Default state bool case sensitive required Source code in prettyqt/core/collator.py def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = ( QtCore . Qt . CaseSensitivity . CaseSensitive if state else QtCore . Qt . CaseSensitivity . CaseInsensitive ) self . setCaseSensitivity ( sensitivity ) commandlineparser CommandLineParser ( QCommandLineParser ) Source code in prettyqt/core/commandlineparser.py class CommandLineParser ( QtCore . QCommandLineParser ): def set_single_dash_word_option_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the single dash word option mode. Args: mode: single dash word option mode Raises: InvalidParamError: single dash word option mode does not exist \"\"\" if mode not in SINGLE_DASH_WORD : raise InvalidParamError ( mode , SINGLE_DASH_WORD ) self . setSingleDashWordOptionMode ( SINGLE_DASH_WORD [ mode ]) def set_options_after_positional_arguments_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the options after positional arguments mode. Args: mode: options after positional arguments mode Raises: InvalidParamError: options after positional arguments mode does not exist \"\"\" if mode not in OPTIONS_AFTER_POS_ARG : raise InvalidParamError ( mode , OPTIONS_AFTER_POS_ARG ) self . setOptionsAfterPositionalArgumentsMode ( OPTIONS_AFTER_POS_ARG [ mode ]) def add_option ( self , name : str , description : str | None = None , value_name : str | None = None , default_value : str | None = None , ) -> core . CommandLineOption : if description is None : description = \"\" if value_name is None : value_name = \"\" if default_value is None : default_value = \"\" option = core . CommandLineOption ( name , description , value_name , default_value ) self . addOption ( option ) return option set_options_after_positional_arguments_mode ( self , mode : SingleDashWordStr ) Set the options after positional arguments mode. Parameters: Name Type Description Default mode SingleDashWordStr options after positional arguments mode required Exceptions: Type Description InvalidParamError options after positional arguments mode does not exist Source code in prettyqt/core/commandlineparser.py def set_options_after_positional_arguments_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the options after positional arguments mode. Args: mode: options after positional arguments mode Raises: InvalidParamError: options after positional arguments mode does not exist \"\"\" if mode not in OPTIONS_AFTER_POS_ARG : raise InvalidParamError ( mode , OPTIONS_AFTER_POS_ARG ) self . setOptionsAfterPositionalArgumentsMode ( OPTIONS_AFTER_POS_ARG [ mode ]) set_single_dash_word_option_mode ( self , mode : SingleDashWordStr ) Set the single dash word option mode. Parameters: Name Type Description Default mode SingleDashWordStr single dash word option mode required Exceptions: Type Description InvalidParamError single dash word option mode does not exist Source code in prettyqt/core/commandlineparser.py def set_single_dash_word_option_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the single dash word option mode. Args: mode: single dash word option mode Raises: InvalidParamError: single dash word option mode does not exist \"\"\" if mode not in SINGLE_DASH_WORD : raise InvalidParamError ( mode , SINGLE_DASH_WORD ) self . setSingleDashWordOptionMode ( SINGLE_DASH_WORD [ mode ]) datastream DataStream ( QDataStream ) Source code in prettyqt/core/datastream.py class DataStream ( QtCore . QDataStream ): def set_byte_order ( self , order : ByteOrderStr ): \"\"\"Set byte order. Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ]) def get_byte_order ( self ) -> ByteOrderStr : \"\"\"Return byte order. Returns: byte order \"\"\" return BYTE_ORDER . inverse [ self . byteOrder ()] def set_status ( self , status : StatusStr ): \"\"\"Set status. Args: status: status to use Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ]) def get_status ( self ) -> StatusStr : \"\"\"Return status. Returns: status \"\"\" return STATUS . inverse [ self . status ()] def set_floating_point_precision ( self , precision : FloatingPointPrecisionStr ): \"\"\"Set floating point precision. Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOATING_POINT_PRECISION : raise InvalidParamError ( precision , FLOATING_POINT_PRECISION ) self . setFloatingPointPrecision ( FLOATING_POINT_PRECISION [ precision ]) def get_floating_point_precision ( self ) -> FloatingPointPrecisionStr : \"\"\"Return floating point precision. Returns: floating point precision \"\"\" return FLOATING_POINT_PRECISION . inverse [ self . floatingPointPrecision ()] @classmethod def create_bytearray ( cls , data : types . QtSerializableType ) -> QtCore . QByteArray : ba = QtCore . QByteArray () stream = cls ( ba , core . iodevice . OPEN_MODES [ \"write_only\" ]) stream << data return ba @classmethod def write_bytearray ( cls , ba : types . ByteArrayType , write_to : types . QtSerializableType ): if isinstance ( ba , str ): ba = ba . encode () if not isinstance ( ba , QtCore . QByteArray ): ba = QtCore . QByteArray ( ba ) stream = cls ( ba , core . iodevice . OPEN_MODES [ \"read_only\" ]) stream >> write_to @classmethod def copy_data ( cls , source , dest ): ba = cls . create_bytearray ( source ) cls . write_bytearray ( ba , dest ) get_byte_order ( self ) -> ByteOrderStr Return byte order. Returns: Type Description ByteOrderStr byte order Source code in prettyqt/core/datastream.py def get_byte_order ( self ) -> ByteOrderStr : \"\"\"Return byte order. Returns: byte order \"\"\" return BYTE_ORDER . inverse [ self . byteOrder ()] get_floating_point_precision ( self ) -> FloatingPointPrecisionStr Return floating point precision. Returns: Type Description FloatingPointPrecisionStr floating point precision Source code in prettyqt/core/datastream.py def get_floating_point_precision ( self ) -> FloatingPointPrecisionStr : \"\"\"Return floating point precision. Returns: floating point precision \"\"\" return FLOATING_POINT_PRECISION . inverse [ self . floatingPointPrecision ()] get_status ( self ) -> StatusStr Return status. Returns: Type Description StatusStr status Source code in prettyqt/core/datastream.py def get_status ( self ) -> StatusStr : \"\"\"Return status. Returns: status \"\"\" return STATUS . inverse [ self . status ()] set_byte_order ( self , order : ByteOrderStr ) Set byte order. Parameters: Name Type Description Default order ByteOrderStr byte order to use required Exceptions: Type Description InvalidParamError invalid order Source code in prettyqt/core/datastream.py def set_byte_order ( self , order : ByteOrderStr ): \"\"\"Set byte order. Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ]) set_floating_point_precision ( self , precision : FloatingPointPrecisionStr ) Set floating point precision. Parameters: Name Type Description Default precision FloatingPointPrecisionStr floating point precision required Exceptions: Type Description InvalidParamError invalid precision Source code in prettyqt/core/datastream.py def set_floating_point_precision ( self , precision : FloatingPointPrecisionStr ): \"\"\"Set floating point precision. Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOATING_POINT_PRECISION : raise InvalidParamError ( precision , FLOATING_POINT_PRECISION ) self . setFloatingPointPrecision ( FLOATING_POINT_PRECISION [ precision ]) set_status ( self , status : StatusStr ) Set status. Parameters: Name Type Description Default status StatusStr status to use required Exceptions: Type Description InvalidParamError invalid status Source code in prettyqt/core/datastream.py def set_status ( self , status : StatusStr ): \"\"\"Set status. Args: status: status to use Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ]) deadlinetimer DeadlineTimer ( QDeadlineTimer ) Source code in prettyqt/core/deadlinetimer.py class DeadlineTimer ( QtCore . QDeadlineTimer ): def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ]) def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()] get_type ( self ) -> constants . TimerTypeStr Return current timer type. Returns: Type Description constants.TimerTypeStr timer type Source code in prettyqt/core/deadlinetimer.py def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()] set_type ( self , typ : constants . TimerTypeStr ) Set the timer type. Parameters: Name Type Description Default typ constants.TimerTypeStr timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/deadlinetimer.py def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ]) easingcurve EasingCurve ( QEasingCurve ) Source code in prettyqt/core/easingcurve.py class EasingCurve ( QtCore . QEasingCurve ): def __init__ ( self , other_or_type : TypeStr | int | QtCore . QEasingCurve = \"linear\" ): if isinstance ( other_or_type , str ) and other_or_type in TYPE : typ = TYPE [ other_or_type ] else : typ = other_or_type super () . __init__ ( typ ) def __getitem__ ( self , value : float ) -> float : return self . valueForProgress ( value ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_type () !r} )\" def set_custom_type ( self , method : CurveMethod ): self . setCustomType ( method ) def get_custom_type ( self ) -> CurveMethod : return self . customType () # type: ignore def set_type ( self , typ : TypeStr ): \"\"\"Set easing curve type. Args: typ: easing curve type Raises: InvalidParamError: easing curve type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setType ( TYPE [ typ ]) def get_type ( self ) -> TypeStr : \"\"\"Get the current easing curve type. Returns: easing curve type \"\"\" return TYPE . inverse [ self . type ()] get_type ( self ) -> TypeStr Get the current easing curve type. Returns: Type Description TypeStr easing curve type Source code in prettyqt/core/easingcurve.py def get_type ( self ) -> TypeStr : \"\"\"Get the current easing curve type. Returns: easing curve type \"\"\" return TYPE . inverse [ self . type ()] set_type ( self , typ : TypeStr ) Set easing curve type. Parameters: Name Type Description Default typ TypeStr easing curve type required Exceptions: Type Description InvalidParamError easing curve type does not exist Source code in prettyqt/core/easingcurve.py def set_type ( self , typ : TypeStr ): \"\"\"Set easing curve type. Args: typ: easing curve type Raises: InvalidParamError: easing curve type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setType ( TYPE [ typ ]) elapsedtimer ElapsedTimer ( QElapsedTimer ) Source code in prettyqt/core/elapsedtimer.py class ElapsedTimer ( QtCore . QElapsedTimer ): def __bool__ ( self ): return self . isValid () def get_clock_type ( self ) -> ClockTypeStr : \"\"\"Return current clock type. Returns: clock type \"\"\" return CLOCK_TYPE . inverse [ self . clockType ()] get_clock_type ( self ) -> ClockTypeStr Return current clock type. Returns: Type Description ClockTypeStr clock type Source code in prettyqt/core/elapsedtimer.py def get_clock_type ( self ) -> ClockTypeStr : \"\"\"Return current clock type. Returns: clock type \"\"\" return CLOCK_TYPE . inverse [ self . clockType ()] filedevice FileDevice ( QFileDevice ) Source code in prettyqt/core/filedevice.py class FileDevice ( QtCore . QFileDevice ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . fileName () !r} )\" def __str__ ( self ): return self . fileName () def set_file_time ( self , file_time : types . DateTimeType , typ : FileTimeStr ) -> bool : \"\"\"Set file time. Args: file_time: file time to set typ: file time type Raises: InvalidParamError: file time does not exist \"\"\" if isinstance ( file_time , str ): file_time = dateutil . parser . parse ( file_time ) if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) return self . setFileTime ( file_time , FILE_TIME [ typ ]) # type: ignore def get_file_time ( self , typ : FileTimeStr ) -> datetime . datetime | None : \"\"\"Return current file time. Returns: file time \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) date = self . fileTime ( FILE_TIME [ typ ]) if not date : return None return date . toPython () # type: ignore def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return FILE_ERROR . inverse [ self . error ()] get_error ( self ) -> FileErrorStr Return file error status. Returns: Type Description FileErrorStr file error status Source code in prettyqt/core/filedevice.py def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return FILE_ERROR . inverse [ self . error ()] get_file_time ( self , typ : FileTimeStr ) -> datetime . datetime | None Return current file time. Returns: Type Description datetime.datetime | None file time Source code in prettyqt/core/filedevice.py def get_file_time ( self , typ : FileTimeStr ) -> datetime . datetime | None : \"\"\"Return current file time. Returns: file time \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) date = self . fileTime ( FILE_TIME [ typ ]) if not date : return None return date . toPython () # type: ignore set_file_time ( self , file_time : types . DateTimeType , typ : FileTimeStr ) -> bool Set file time. Parameters: Name Type Description Default file_time types.DateTimeType file time to set required typ FileTimeStr file time type required Exceptions: Type Description InvalidParamError file time does not exist Source code in prettyqt/core/filedevice.py def set_file_time ( self , file_time : types . DateTimeType , typ : FileTimeStr ) -> bool : \"\"\"Set file time. Args: file_time: file time to set typ: file time type Raises: InvalidParamError: file time does not exist \"\"\" if isinstance ( file_time , str ): file_time = dateutil . parser . parse ( file_time ) if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) return self . setFileTime ( file_time , FILE_TIME [ typ ]) # type: ignore operatingsystemversion OperatingSystemVersion ( QOperatingSystemVersion ) Source code in prettyqt/core/operatingsystemversion.py class OperatingSystemVersion ( QtCore . QOperatingSystemVersion ): def __init__ ( self , typ : QtCore . QOperatingSystemVersion . OSType | str , major : int , minor : int | None = None , micro : int | None = None , ): if isinstance ( typ , str ): os_type = OS_TYPE [ typ ] else : os_type = typ if minor is None : minor = - 1 if micro is None : micro = - 1 super () . __init__ ( os_type , major , minor , micro ) def __repr__ ( self ): return ( f \" { type ( self ) . __name__ } ( { self . get_type () !r} , { self . majorVersion () } , \" f \" { self . minorVersion () } , { self . microVersion () } )\" ) def __reduce__ ( self ): return ( type ( self ), ( self . get_type (), self . majorVersion (), self . minorVersion (), self . microVersion (), ), ) def __eq__ ( self , other ): if not isinstance ( other , OperatingSystemVersion ): return False return ( self . get_type () == other . get_type () and self . get_versionnumber () == other . get_versionnumber () ) def __hash__ ( self ): return hash ( ( self . get_type (), self . majorVersion (), self . minorVersion (), self . microVersion (), ) ) def get_type ( self ) -> OsTypeStr : \"\"\"Get current os type. Returns: current os type \"\"\" return OS_TYPE . inverse [ self . type ()] def get_versionnumber ( self ) -> core . VersionNumber : return core . VersionNumber ( self . majorVersion (), self . minorVersion (), self . microVersion () ) __hash__ ( self ) special Return hash(self). Source code in prettyqt/core/operatingsystemversion.py def __hash__ ( self ): return hash ( ( self . get_type (), self . majorVersion (), self . minorVersion (), self . microVersion (), ) ) get_type ( self ) -> OsTypeStr Get current os type. Returns: Type Description OsTypeStr current os type Source code in prettyqt/core/operatingsystemversion.py def get_type ( self ) -> OsTypeStr : \"\"\"Get current os type. Returns: current os type \"\"\" return OS_TYPE . inverse [ self . type ()] process Process ( QProcess ) Source code in prettyqt/core/process.py class Process ( QtCore . QProcess ): def set_read_channel ( self , channel : ProcessChannelStr ): \"\"\"Set the input channel channel. Args: channel: channel to set Raises: InvalidParamError: invalid channel \"\"\" if channel not in PROCESS_CHANNELS : raise InvalidParamError ( channel , PROCESS_CHANNELS ) self . setReadChannel ( PROCESS_CHANNELS [ channel ]) def get_read_channel ( self ) -> ProcessChannelStr : return PROCESS_CHANNELS . inverse [ self . readChannel ()] def close_read_channel ( self , channel : ProcessChannelStr ): self . closeReadChannel ( PROCESS_CHANNELS [ channel ]) def set_input_channel_mode ( self , mode : InputChannelModeStr ): \"\"\"Set the input channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in INPUT_CHANNEL_MODES : raise InvalidParamError ( mode , INPUT_CHANNEL_MODES ) self . setInputChannelMode ( INPUT_CHANNEL_MODES [ mode ]) def get_input_channel_mode ( self ) -> InputChannelModeStr : return INPUT_CHANNEL_MODES . inverse [ self . inputChannelMode ()] def set_process_channel_mode ( self , mode : ProcessChannelModeStr ): \"\"\"Set the process channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in PROCESS_CHANNEL_MODES : raise InvalidParamError ( mode , PROCESS_CHANNEL_MODES ) self . setProcessChannelMode ( PROCESS_CHANNEL_MODES [ mode ]) def get_process_channel_mode ( self ) -> ProcessChannelModeStr : return PROCESS_CHANNEL_MODES . inverse [ self . processChannelMode ()] def set_state ( self , state : ProcessStateStr ): \"\"\"Set the process state. Args: state: state to set Raises: InvalidParamError: invalid state \"\"\" if state not in PROCESS_STATES : raise InvalidParamError ( state , PROCESS_STATES ) self . setProcessState ( PROCESS_STATES [ state ]) def get_state ( self ) -> ProcessStateStr : return PROCESS_STATES . inverse [ self . state ()] def get_error ( self ) -> ProcessErrorStr : return PROCESS_ERRORS . inverse [ self . error ()] def get_exit_status ( self ) -> ExitStatusStr : return EXIT_STATUS . inverse [ self . exitStatus ()] def get_process_environment ( self ) -> core . ProcessEnvironment : return core . ProcessEnvironment ( self . processEnvironment ()) @contextlib . contextmanager def edit_process_environment ( self ): env = self . get_process_environment () yield env self . setProcessEnvironment ( env ) set_input_channel_mode ( self , mode : InputChannelModeStr ) Set the input channel mode. Parameters: Name Type Description Default mode InputChannelModeStr mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_input_channel_mode ( self , mode : InputChannelModeStr ): \"\"\"Set the input channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in INPUT_CHANNEL_MODES : raise InvalidParamError ( mode , INPUT_CHANNEL_MODES ) self . setInputChannelMode ( INPUT_CHANNEL_MODES [ mode ]) set_process_channel_mode ( self , mode : ProcessChannelModeStr ) Set the process channel mode. Parameters: Name Type Description Default mode ProcessChannelModeStr mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_process_channel_mode ( self , mode : ProcessChannelModeStr ): \"\"\"Set the process channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in PROCESS_CHANNEL_MODES : raise InvalidParamError ( mode , PROCESS_CHANNEL_MODES ) self . setProcessChannelMode ( PROCESS_CHANNEL_MODES [ mode ]) set_read_channel ( self , channel : ProcessChannelStr ) Set the input channel channel. Parameters: Name Type Description Default channel ProcessChannelStr channel to set required Exceptions: Type Description InvalidParamError invalid channel Source code in prettyqt/core/process.py def set_read_channel ( self , channel : ProcessChannelStr ): \"\"\"Set the input channel channel. Args: channel: channel to set Raises: InvalidParamError: invalid channel \"\"\" if channel not in PROCESS_CHANNELS : raise InvalidParamError ( channel , PROCESS_CHANNELS ) self . setReadChannel ( PROCESS_CHANNELS [ channel ]) set_state ( self , state : ProcessStateStr ) Set the process state. Parameters: Name Type Description Default state ProcessStateStr state to set required Exceptions: Type Description InvalidParamError invalid state Source code in prettyqt/core/process.py def set_state ( self , state : ProcessStateStr ): \"\"\"Set the process state. Args: state: state to set Raises: InvalidParamError: invalid state \"\"\" if state not in PROCESS_STATES : raise InvalidParamError ( state , PROCESS_STATES ) self . setProcessState ( PROCESS_STATES [ state ]) regularexpression RegularExpression ( QRegularExpression ) Source code in prettyqt/core/regularexpression.py class RegularExpression ( QtCore . QRegularExpression ): def __init__ ( self , pattern : str | QtCore . QRegularExpression = \"\" , flags : QtCore . QRegularExpression . PatternOption = FLAGS [ \"none\" ], ): if isinstance ( pattern , QtCore . QRegularExpression ): super () . __init__ ( pattern ) else : if isinstance ( flags , int ): flags = core . RegularExpression . PatternOption ( flags ) # type: ignore super () . __init__ ( pattern , flags ) # type: ignore def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . pattern () !r} )\" def __reduce__ ( self ): return type ( self ), ( self . pattern (), qt . flag_to_int ( self . flags )) def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it ) def global_match ( self , text : str , offset : int = 0 , match_type : MatchTypeStr = \"normal\" , anchored : bool = False , ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] return self . globalMatch ( text , offset , MATCH_TYPE [ match_type ], options ) def match ( # type: ignore self , text : str , offset : int = 0 , match_type : MatchTypeStr | QtCore . QRegularExpression . MatchType = \"normal\" , anchored : bool = False , ) -> core . RegularExpressionMatch : if isinstance ( match_type , str ): typ = MATCH_TYPE [ match_type ] else : typ = match_type if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , typ , options ) return core . RegularExpressionMatch ( match ) def fullmatch ( self , string : str , pos : int = 0 , endpos : int | None = None ) -> core . RegularExpressionMatch | None : if endpos : string = string [: endpos ] match = super () . match ( string , pos ) if match . hasMatch () and len ( string ) == match . end () - match . start (): return core . RegularExpressionMatch ( match ) else : return None def finditer ( self , string : str , pos : int = 0 , endpos : int | None = None ) -> Iterator [ core . RegularExpressionMatch ]: for match in self . globalMatch ( string [: endpos ], offset = pos ): match . pos = pos match . endpos = endpos match . string = string yield match def findall ( self , string : str , pos : int = 0 , endpos : int | None = None ) -> list : matches = list ( self . globalMatch ( string [: endpos ], offset = pos )) return [ m . groups () if len ( m . groups ()) > 1 else m . group ( 0 ) for m in matches ] def subn ( self , repl : str | Callable , string : str , count : int = 0 ) -> tuple [ str , int ]: result = string matches = self . global_match ( string ) matches = list ( matches ) if count > 0 : matches = matches [: count ] matches = list ( reversed ( matches )) for m in matches : to_replace = repl if isinstance ( repl , str ) else repl ( m ) for j in range ( self . groups ): to_replace = to_replace . replace ( rf \"\\g< { j } >\" , m . group ( j )) for k in self . groupindex . keys (): to_replace = to_replace . replace ( rf \"\\g< { k } >\" , m . group ( k )) result = result [: m . start ()] + to_replace + result [ m . end () :] return ( result , min ( len ( matches ), count )) def sub ( self , repl : str | Callable , string : str , count : int = 0 ) -> str : res = self . subn ( repl , string , count ) return res [ 0 ] def search ( self , string : str , pos : int = 0 , endpos : int | None = None ): match = super () . match ( string [: endpos ], pos ) return match if match . hasMatch () else None def split ( self , string : str , maxsplit : int = 0 ): raise NotImplementedError () # result = list() # matches = self.global_match(string) # matches = list(matches) # if 0 < maxsplit <= len(matches): # remainder = string[matches[maxsplit - 1].end() :] # print(remainder) # else: # print(None) # remainder = None # if maxsplit > 0: # matches = matches[:maxsplit] # prev_match = None # m = matches[0] # if m.start() == 0: # result.append(\"\") # else: # result.append(string[0 : m.start()]) # for g in m.groups(): # result.append(g) # prev_match = m # for m in matches[1:]: # result.append(string[prev_match.end() : m.start()]) # for g in m.groups(): # result.append(g) # if m.end() == len(string): # result.append(\"\") # prev_match = m # if remainder: # result.append(remainder) # return result @property def groups ( self ) -> int : return self . captureCount () @property def groupindex ( self ) -> dict [ str , int ]: return { k : i for i , k in enumerate ( self . namedCaptureGroups ()[ 1 :], start = 1 )} @property def flags ( self ): return self . patternOptions () globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator globalMatch(self, subject: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -> PySide6.QtCore.QRegularExpressionMatchIterator globalMatch(self, subjectView: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -> PySide6.QtCore.QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it ) match ( self , text : str , offset : int = 0 , match_type : MatchTypeStr | QtCore . QRegularExpression . MatchType = 'normal' , anchored : bool = False ) -> core . RegularExpressionMatch match(self, subject: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -> PySide6.QtCore.QRegularExpressionMatch match(self, subjectView: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -> PySide6.QtCore.QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py def match ( # type: ignore self , text : str , offset : int = 0 , match_type : MatchTypeStr | QtCore . QRegularExpression . MatchType = \"normal\" , anchored : bool = False , ) -> core . RegularExpressionMatch : if isinstance ( match_type , str ): typ = MATCH_TYPE [ match_type ] else : typ = match_type if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , typ , options ) return core . RegularExpressionMatch ( match ) settings Settings ( QSettings ) Source code in prettyqt/core/settings.py class Settings ( QtCore . QSettings ): def __init__ ( self , * args , settings_id : str | None = None ): super () . __init__ ( * args ) self . settings_id = settings_id def __repr__ ( self ): return f \" { type ( self ) . __name__ } : { self . as_dict () } \" def __contains__ ( self , key : str ) -> bool : return self . contains ( key ) def __enter__ ( self ): if self . settings_id : self . beginGroup ( self . settings_id ) return self def __exit__ ( self , exc_type , exc_value , traceback ): if self . settings_id : self . endGroup () def __getitem__ ( self , index : str ): return self . get_value ( index ) def __setitem__ ( self , name : str , value ): return self . set_value ( name , value ) def __delitem__ ( self , key : str ): if not self . contains ( key ): raise KeyError ( key ) return self . remove ( key ) def __iter__ ( self ) -> Iterator [ tuple [ str , Any ]]: return iter ( self . items ()) def __len__ ( self ) -> int : return len ( self . allKeys ()) @classmethod def build_from_dict ( cls , dct : dict [ str , Any ]): settings = cls () for k , v in dct . items (): settings . set_value ( k , v ) return settings def as_dict ( self ) -> dict [ str , Any ]: return { k : v for k , v in self . items ()} def set_value ( self , key : str , value ): if not self . applicationName (): raise RuntimeError ( \"no app name defined\" ) self . setValue ( key , dict ( value = value )) def set_values ( self , dct : dict [ str , Any ]): for k , v in dct . items (): self . set_value ( k , v ) def get_value ( self , key : str , default = None ): if not self . contains ( key ): return default val = self . value ( key ) # this is for migration if not isinstance ( val , dict ) or \"value\" not in val : self . set_value ( key , val ) return val return val [ \"value\" ] @classmethod def set_default_format ( cls , fmt : FormatStr ): \"\"\"Set the default format. Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) cls . setDefaultFormat ( FORMAT [ fmt ]) @classmethod def get_default_format ( cls ) -> FormatStr : \"\"\"Return default settings format. Returns: default settings format \"\"\" return FORMAT . inverse [ cls . defaultFormat ()] def get_scope ( self ) -> ScopeStr : \"\"\"Return scope. Returns: scope \"\"\" return SCOPE . inverse [ self . scope ()] @classmethod def set_path ( cls , fmt : FormatStr , scope : ScopeStr , path : types . PathType ): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) if scope not in SCOPE : raise InvalidParamError ( scope , SCOPE ) cls . setPath ( FORMAT [ fmt ], SCOPE [ scope ], os . fspath ( path )) @contextlib . contextmanager def edit_group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup () @contextlib . contextmanager def write_array ( self , prefix : str , size : int | None = None ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" if size is None : size = - 1 self . beginWriteArray ( prefix , size ) yield None self . endArray () @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray () # Dictionary interface def get ( self , key : str , default : Any = None ) -> Any : return self . get_value ( key , default ) def setdefault ( self , key : str , default : Any = None ) -> Any : if not self . contains ( key ): self . set_value ( key , default ) return default return self . get_value ( key ) def keys ( self ) -> list [ str ]: return self . allKeys () def values ( self ) -> Iterator [ Any ]: return ( self . get_value ( key ) for key in self . allKeys ()) def items ( self ): return zip ( self . keys (), self . values ()) def pop ( self , key : str ): if self . contains ( key ): return self . get_value ( key ) raise KeyError ( key ) def popitem ( self ) -> tuple [ str , Any ]: key = self . keys ()[ 0 ] return ( key , self . get_value ( key )) def update ( self , other : Mapping [ str , Any ]): for k , v in other . items (): self . set_value ( k , v ) @classmethod def register_extensions ( cls , * exts : str , app_name : str | None = None , app_path : None | types . PathType = None , ): logger . debug ( f \"assigning extensions { exts } to { app_name } \" ) s = cls ( \"HKEY_CURRENT_USER \\\\ SOFTWARE \\\\ Classes\" , Settings . Format . NativeFormat ) if app_path is None : app_path = str ( core . CoreApplication . get_application_file_path ()) app_path = os . fspath ( app_path ) if app_name is None : app_name = core . CoreApplication . applicationName () for ext in exts : s . setValue ( f \" { ext } /DefaultIcon/.\" , app_path ) # perhaps ,0 after app_path s . setValue ( f \" { ext } /.\" , app_name ) s . setValue ( f \" { app_name } /shell/open/command/.\" , f \" { app_path } %1\" ) edit_group ( self , prefix : str ) Context manager for setting groups. Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py @contextlib . contextmanager def edit_group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup () get_default_format () -> FormatStr classmethod Return default settings format. Returns: Type Description FormatStr default settings format Source code in prettyqt/core/settings.py @classmethod def get_default_format ( cls ) -> FormatStr : \"\"\"Return default settings format. Returns: default settings format \"\"\" return FORMAT . inverse [ cls . defaultFormat ()] get_scope ( self ) -> ScopeStr Return scope. Returns: Type Description ScopeStr scope Source code in prettyqt/core/settings.py def get_scope ( self ) -> ScopeStr : \"\"\"Return scope. Returns: scope \"\"\" return SCOPE . inverse [ self . scope ()] read_array ( self , prefix : str ) Context manager for reading arrays. Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray () set_default_format ( fmt : FormatStr ) classmethod Set the default format. Parameters: Name Type Description Default fmt FormatStr the default format to use required Exceptions: Type Description InvalidParamError invalid format Source code in prettyqt/core/settings.py @classmethod def set_default_format ( cls , fmt : FormatStr ): \"\"\"Set the default format. Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) cls . setDefaultFormat ( FORMAT [ fmt ]) set_path ( fmt : FormatStr , scope : ScopeStr , path : types . PathType ) classmethod Set the path to the settings file. Parameters: Name Type Description Default fmt FormatStr the default format to use required scope ScopeStr the scope to use required Exceptions: Type Description InvalidParamError invalid format or scope Source code in prettyqt/core/settings.py @classmethod def set_path ( cls , fmt : FormatStr , scope : ScopeStr , path : types . PathType ): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) if scope not in SCOPE : raise InvalidParamError ( scope , SCOPE ) cls . setPath ( FORMAT [ fmt ], SCOPE [ scope ], os . fspath ( path )) write_array ( self , prefix : str , size : int | None = None ) Context manager for writing arrays. Parameters: Name Type Description Default prefix str prefix for settings array required size int | None size of settings array None Source code in prettyqt/core/settings.py @contextlib . contextmanager def write_array ( self , prefix : str , size : int | None = None ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" if size is None : size = - 1 self . beginWriteArray ( prefix , size ) yield None self . endArray () socketnotifier SocketNotifier ( QSocketNotifier ) Source code in prettyqt/core/socketnotifier.py class SocketNotifier ( QtCore . QSocketNotifier ): # def __repr__(self): # return f\"{type(self).__name__}({self.socket()}, {self.type()})\" def get_type ( self ) -> TypeStr : \"\"\"Return socket event type. Returns: socket event type \"\"\" return TYPE . inverse [ self . type ()] get_type ( self ) -> TypeStr Return socket event type. Returns: Type Description TypeStr socket event type Source code in prettyqt/core/socketnotifier.py def get_type ( self ) -> TypeStr : \"\"\"Return socket event type. Returns: socket event type \"\"\" return TYPE . inverse [ self . type ()] textstream TextStream ( QTextStream ) Source code in prettyqt/core/textstream.py class TextStream ( QtCore . QTextStream ): def set_field_alignment ( self , alignment : FieldAlignmentStr ): \"\"\"Set the field alignment. Args: alignment: field alignment Raises: InvalidParamError: invalid field alignment \"\"\" if alignment not in FIELD_ALIGNMENT : raise InvalidParamError ( alignment , FIELD_ALIGNMENT ) self . setFieldAlignment ( FIELD_ALIGNMENT [ alignment ]) def get_field_alignment ( self ) -> FieldAlignmentStr : \"\"\"Get current field alignment. Returns: current field alignment \"\"\" return FIELD_ALIGNMENT . inverse [ self . fieldAlignment ()] def set_status ( self , status : StatusStr ): \"\"\"Set the status. Args: status: status Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ]) def get_status ( self ) -> StatusStr : \"\"\"Get current status. Returns: current status \"\"\" return STATUS . inverse [ self . status ()] def set_real_number_notation ( self , notation : RealNumberNotationStr ): \"\"\"Set the real number notation. Args: notation: real number notation Raises: InvalidParamError: invalid real number notation \"\"\" if notation not in REAL_NUMBER_NOTATION : raise InvalidParamError ( notation , REAL_NUMBER_NOTATION ) self . setRealNumberNotation ( REAL_NUMBER_NOTATION [ notation ]) def get_real_number_notation ( self ) -> RealNumberNotationStr : \"\"\"Get current real number notation. Returns: current real number notation \"\"\" return REAL_NUMBER_NOTATION . inverse [ self . realNumberNotation ()] def set_codec ( self , codec : bytes | str ): if isinstance ( codec , str ): codec = codec . encode () self . setCodec ( codec ) def read_lines ( self ) -> Iterator [ str ]: while True : msg = self . readLine () if not msg : return yield msg get_field_alignment ( self ) -> FieldAlignmentStr Get current field alignment. Returns: Type Description FieldAlignmentStr current field alignment Source code in prettyqt/core/textstream.py def get_field_alignment ( self ) -> FieldAlignmentStr : \"\"\"Get current field alignment. Returns: current field alignment \"\"\" return FIELD_ALIGNMENT . inverse [ self . fieldAlignment ()] get_real_number_notation ( self ) -> RealNumberNotationStr Get current real number notation. Returns: Type Description RealNumberNotationStr current real number notation Source code in prettyqt/core/textstream.py def get_real_number_notation ( self ) -> RealNumberNotationStr : \"\"\"Get current real number notation. Returns: current real number notation \"\"\" return REAL_NUMBER_NOTATION . inverse [ self . realNumberNotation ()] get_status ( self ) -> StatusStr Get current status. Returns: Type Description StatusStr current status Source code in prettyqt/core/textstream.py def get_status ( self ) -> StatusStr : \"\"\"Get current status. Returns: current status \"\"\" return STATUS . inverse [ self . status ()] set_field_alignment ( self , alignment : FieldAlignmentStr ) Set the field alignment. Parameters: Name Type Description Default alignment FieldAlignmentStr field alignment required Exceptions: Type Description InvalidParamError invalid field alignment Source code in prettyqt/core/textstream.py def set_field_alignment ( self , alignment : FieldAlignmentStr ): \"\"\"Set the field alignment. Args: alignment: field alignment Raises: InvalidParamError: invalid field alignment \"\"\" if alignment not in FIELD_ALIGNMENT : raise InvalidParamError ( alignment , FIELD_ALIGNMENT ) self . setFieldAlignment ( FIELD_ALIGNMENT [ alignment ]) set_real_number_notation ( self , notation : RealNumberNotationStr ) Set the real number notation. Parameters: Name Type Description Default notation RealNumberNotationStr real number notation required Exceptions: Type Description InvalidParamError invalid real number notation Source code in prettyqt/core/textstream.py def set_real_number_notation ( self , notation : RealNumberNotationStr ): \"\"\"Set the real number notation. Args: notation: real number notation Raises: InvalidParamError: invalid real number notation \"\"\" if notation not in REAL_NUMBER_NOTATION : raise InvalidParamError ( notation , REAL_NUMBER_NOTATION ) self . setRealNumberNotation ( REAL_NUMBER_NOTATION [ notation ]) set_status ( self , status : StatusStr ) Set the status. Parameters: Name Type Description Default status StatusStr status required Exceptions: Type Description InvalidParamError invalid status Source code in prettyqt/core/textstream.py def set_status ( self , status : StatusStr ): \"\"\"Set the status. Args: status: status Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ]) timeline TimeLine ( QTimeLine ) Source code in prettyqt/core/timeline.py class TimeLine ( QtCore . QTimeLine ): def serialize_fields ( self ): return dict ( current_time = self . currentTime (), direction = self . get_direction (), duration = self . duration (), easing_curve = self . easingCurve (), loop_count = self . loopCount (), update_interval = self . updateInterval (), ) def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()] def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()] def set_easing ( self , easing_type : core . easingcurve . TypeStr | Callable [[ float ], float ] ) -> core . EasingCurve : curve = core . EasingCurve () if isinstance ( easing_type , str ): curve . set_type ( easing_type ) else : curve . set_custom_type ( easing_type ) self . setEasingCurve ( curve ) return curve def get_easing ( self ) -> core . easingcurve . TypeStr | Callable [[ float ], float ]: curve = core . EasingCurve ( self . easingCurve ()) typ = curve . get_type () if typ == \"custom\" : return curve . get_custom_type () else : return typ get_direction ( self ) -> DirectionStr Return current direction. Returns: Type Description DirectionStr direction Source code in prettyqt/core/timeline.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()] get_state ( self ) -> StateStr Return current state. Returns: Type Description StateStr state Source code in prettyqt/core/timeline.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()] set_direction ( self , direction : DirectionStr ) Set the direction. Parameters: Name Type Description Default direction DirectionStr direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/core/timeline.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) timer Timer ( QTimer ) Source code in prettyqt/core/timer.py class Timer ( QtCore . QTimer ): def serialize_fields ( self ): return dict ( interval = self . interval (), single_shot = self . isSingleShot (), timer_type = self . get_type (), ) @classmethod def single_shot ( cls , callback : Callable ) -> Timer : timer = cls () timer . timeout . connect ( callback ) timer . setSingleShot ( True ) return timer def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ]) def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()] def set_interval ( self , interval : int | str ): if isinstance ( interval , str ): interval = helpers . parse_time ( interval ) self . setInterval ( interval ) def start_timer ( self , interval : None | int | str = None ): if isinstance ( interval , str ): interval = helpers . parse_time ( interval ) if interval is None : self . start () else : self . start ( interval ) def restart ( self ): self . stop () self . start () get_type ( self ) -> constants . TimerTypeStr Return current timer type. Returns: Type Description constants.TimerTypeStr timer type Source code in prettyqt/core/timer.py def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()] set_type ( self , typ : constants . TimerTypeStr ) Set the timer type. Parameters: Name Type Description Default typ constants.TimerTypeStr timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/timer.py def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ]) url Url ( QUrl ) Source code in prettyqt/core/url.py class Url ( QtCore . QUrl ): def __init__ ( self , path : types . UrlType | types . PathType | None = None ): if path is None : super () . __init__ () else : if isinstance ( path , QtCore . QUrl ): super () . __init__ ( path ) else : super () . __init__ ( os . fspath ( path )) if isinstance ( path , os . PathLike ): self . setScheme ( \"file\" ) # def __str__(self): # return self.absolutePath() def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . toString () !r} )\" def __str__ ( self ): return self . toString () def serialize_fields ( self ): return dict ( path = self . toString ()) def serialize ( self ) -> dict [ str , Any ]: return self . serialize_fields () def to_string ( self ) -> str : return self . toString () def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self )) def is_local_file ( self ) -> bool : return self . isLocalFile () @classmethod def from_user_input ( cls , url : str , working_dir : str | None = None ) -> Url : if working_dir is None : working_dir = \"\" return cls ( cls . fromUserInput ( url , working_dir )) @classmethod def from_local_file ( cls , path : types . PathType ) -> Url : url = cls . fromLocalFile ( os . fspath ( path )) return cls ( url ) to_path ( self ) -> pathlib . Path Get pathlib object from the URL. Returns: Type Description pathlib.Path Path Source code in prettyqt/core/url.py def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self )) versionnumber VersionNumber ( QVersionNumber ) Source code in prettyqt/core/versionnumber.py class VersionNumber ( QtCore . QVersionNumber ): def __init__ ( self , * args , ** kwargs ): if len ( args ) == 1 : if isinstance ( args [ 0 ], str ): args = tuple ( int ( i ) for i in args [ 0 ] . split ( \".\" )) elif isinstance ( args [ 0 ], tuple ): args = args [ 0 ] # PySide6 Workaround: elif isinstance ( args [ 0 ], QtCore . QVersionNumber ): args = ( args [ 0 ] . majorVersion (), args [ 0 ] . minorVersion (), args [ 0 ] . microVersion (), ) super () . __init__ ( * args , ** kwargs ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . major () } , { self . minor () } , { self . micro () } )\" def __reduce__ ( self ): return type ( self ), ( self . major (), self . minor (), self . micro ()) def __str__ ( self ): return self . toString () def __eq__ ( self , other ): if isinstance ( other , ( str , tuple )): other = VersionNumber ( other ) return super () . __eq__ ( other ) def __hash__ ( self ): return hash (( self . major (), self . minor (), self . micro ())) def __gt__ ( self , other : types . SemanticVersionType ): if isinstance ( other , ( str , tuple )): other = VersionNumber ( other ) return super () . __gt__ ( other ) def __ge__ ( self , other : types . SemanticVersionType ): if isinstance ( other , ( str , tuple )): other = VersionNumber ( other ) return super () . __ge__ ( other ) def __lt__ ( self , other : types . SemanticVersionType ): if isinstance ( other , ( str , tuple )): other = VersionNumber ( other ) return super () . __lt__ ( other ) def __le__ ( self , other : types . SemanticVersionType ): if isinstance ( other , ( str , tuple )): other = VersionNumber ( other ) return super () . __le__ ( other ) @classmethod def get_qt_version ( cls ) -> VersionNumber : return cls ( * [ int ( i ) for i in QtCore . __version__ . split ( \".\" )]) @classmethod def get_python_version ( cls ) -> VersionNumber : return cls ( * sys . version_info [: 3 ]) def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion () def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion () def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion () major ( self ) -> int An integer representing the major version. Source code in prettyqt/core/versionnumber.py def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion () micro ( self ) -> int An integer representing the micro version. Source code in prettyqt/core/versionnumber.py def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion () minor ( self ) -> int An integer representing the minor version. Source code in prettyqt/core/versionnumber.py def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion () xmlstreamreader XmlStreamReader ( QXmlStreamReader ) Source code in prettyqt/core/xmlstreamreader.py class XmlStreamReader ( QtCore . QXmlStreamReader ): def __iter__ ( self ): return self def __next__ ( self ): while not self . atEnd (): self . readNext () if self . hasError (): raise RuntimeError ( self . get_error ()) return self raise StopIteration def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return ERROR . inverse [ self . error ()] def get_token_type ( self ) -> TokenTypeStr : \"\"\"Get the current token type. Returns: token type \"\"\" return TOKEN_TYPE . inverse [ self . tokenType ()] def read_next ( self ) -> TokenTypeStr : \"\"\"Read the next token and returns its type. Returns: token type \"\"\" return TOKEN_TYPE . inverse [ self . readNext ()] get_error ( self ) -> FileErrorStr Return file error status. Returns: Type Description FileErrorStr file error status Source code in prettyqt/core/xmlstreamreader.py def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return ERROR . inverse [ self . error ()] get_token_type ( self ) -> TokenTypeStr Get the current token type. Returns: Type Description TokenTypeStr token type Source code in prettyqt/core/xmlstreamreader.py def get_token_type ( self ) -> TokenTypeStr : \"\"\"Get the current token type. Returns: token type \"\"\" return TOKEN_TYPE . inverse [ self . tokenType ()] read_next ( self ) -> TokenTypeStr Read the next token and returns its type. Returns: Type Description TokenTypeStr token type Source code in prettyqt/core/xmlstreamreader.py def read_next ( self ) -> TokenTypeStr : \"\"\"Read the next token and returns its type. Returns: token type \"\"\" return TOKEN_TYPE . inverse [ self . readNext ()]","title":"core"},{"location":"api/core.html#core-module","text":"Core module. Contains QtCore-based classes","title":"core module"},{"location":"api/core.html#prettyqt.core.abstractanimation","text":"","title":"abstractanimation"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation","text":"Source code in prettyqt/core/abstractanimation.py class AbstractAnimation ( QtCore . QAbstractAnimation ): def __len__ ( self ): return self . duration () def __and__ ( self , other : AbstractAnimation ) -> core . SequentialAnimationGroup : group = core . SequentialAnimationGroup () group . addAnimation ( self ) group . addAnimation ( other ) return group def __or__ ( self , other : AbstractAnimation ) -> core . ParallelAnimationGroup : group = core . ParallelAnimationGroup () group . addAnimation ( self ) group . addAnimation ( other ) return group def serialize_fields ( self ): return dict ( duration = self . duration (), direction = self . get_direction (), loop_count = self . loopCount (), current_time = self . currentTime (), ) def set_direction ( self , direction : DirectionStr ): \"\"\"Set animation direction. Args: direction: animation direction Raises: InvalidParamError: animation direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) def get_direction ( self ) -> DirectionStr : \"\"\"Get the current animation direction. Returns: animation direction \"\"\" return DIRECTION . inverse [ self . direction ()] def get_state ( self ) -> StateStr : \"\"\"Get the current animation state. Returns: animation state \"\"\" return STATE . inverse [ self . state ()] def start_animation ( self , policy : DeletionPolicyStr = \"keep\" ): \"\"\"Start the animation. Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" if policy not in DELETION_POLICY : raise InvalidParamError ( policy , DELETION_POLICY ) self . start ( DELETION_POLICY [ policy ]) def restart_animation ( self , policy : DeletionPolicyStr = \"keep\" ): \"\"\"Restart the animation. Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" self . stop () self . start_animation ( policy )","title":"AbstractAnimation"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.get_direction","text":"Get the current animation direction. Returns: Type Description DirectionStr animation direction Source code in prettyqt/core/abstractanimation.py def get_direction ( self ) -> DirectionStr : \"\"\"Get the current animation direction. Returns: animation direction \"\"\" return DIRECTION . inverse [ self . direction ()]","title":"get_direction()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.get_state","text":"Get the current animation state. Returns: Type Description StateStr animation state Source code in prettyqt/core/abstractanimation.py def get_state ( self ) -> StateStr : \"\"\"Get the current animation state. Returns: animation state \"\"\" return STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.restart_animation","text":"Restart the animation. Parameters: Name Type Description Default policy DeletionPolicyStr animation policy 'keep' Exceptions: Type Description InvalidParamError animation policy does not exist Source code in prettyqt/core/abstractanimation.py def restart_animation ( self , policy : DeletionPolicyStr = \"keep\" ): \"\"\"Restart the animation. Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" self . stop () self . start_animation ( policy )","title":"restart_animation()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.set_direction","text":"Set animation direction. Parameters: Name Type Description Default direction DirectionStr animation direction required Exceptions: Type Description InvalidParamError animation direction does not exist Source code in prettyqt/core/abstractanimation.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set animation direction. Args: direction: animation direction Raises: InvalidParamError: animation direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ])","title":"set_direction()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.start_animation","text":"Start the animation. Parameters: Name Type Description Default policy DeletionPolicyStr animation policy 'keep' Exceptions: Type Description InvalidParamError animation policy does not exist Source code in prettyqt/core/abstractanimation.py def start_animation ( self , policy : DeletionPolicyStr = \"keep\" ): \"\"\"Start the animation. Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" if policy not in DELETION_POLICY : raise InvalidParamError ( policy , DELETION_POLICY ) self . start ( DELETION_POLICY [ policy ])","title":"start_animation()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel","text":"","title":"abstractitemmodel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel","text":"Source code in prettyqt/core/abstractitemmodel.py class AbstractItemModel ( QtCore . QAbstractItemModel ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } : { self . rowCount () } rows\" def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount () # causes issues with PySide2 # def __getitem__(self, index: Tuple[int, int]) -> QtCore.QModelIndex: # return self.index(*index) def check_index ( self , index : QtCore . QModelIndex , index_is_valid : bool = False , do_not_use_parent : bool = False , parent_is_invalid : bool = False , ) -> bool : flag = QtCore . QAbstractItemModel . CheckIndexOption . NoOption if index_is_valid : flag |= CHECK_INDEX_OPTIONS [ \"index_is_valid\" ] # type: ignore if do_not_use_parent : flag |= CHECK_INDEX_OPTIONS [ \"do_not_use_parent\" ] # type: ignore if parent_is_invalid : flag |= CHECK_INDEX_OPTIONS [ \"parent_is_invalid\" ] # type: ignore check_flag = QtCore . QAbstractItemModel . CheckIndexOption ( 0 ) | flag # type: ignore if qt . API . endswith ( \"5\" ): check_flag = QtCore . QAbstractItemModel . CheckIndexOptions ( check_flag ) return self . checkIndex ( index , check_flag ) # type: ignore @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit () @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel () def update_row ( self , row : int ): start_index = self . index ( row , 0 ) end_index = self . index ( row , self . columnCount () - 1 ) self . dataChanged . emit ( start_index , end_index ) @contextlib . contextmanager def remove_rows ( self , first : int | None = None , last : int | None = None , parent : QtCore . QModelIndex | None = None , ): parent = QtCore . QModelIndex () if parent is None else parent first = first if first is not None else 0 last = last if last is not None else self . rowCount () self . beginRemoveRows ( parent , first , last ) yield None self . endRemoveRows () @contextlib . contextmanager def remove_columns ( self , first : int | None = None , last : int | None = None , parent : QtCore . QModelIndex | None = None , ): parent = QtCore . QModelIndex () if parent is None else parent first = first if first is not None else 0 last = last if last is not None else self . rowCount () self . beginRemoveColumns ( parent , first , last ) yield None self . endRemoveColumns () @contextlib . contextmanager def insert_rows ( self , first : int | None = None , last : int | None = None , parent : QtCore . QModelIndex | None = None , ): parent = QtCore . QModelIndex () if parent is None else parent first = first if first is not None else 0 last = last if last is not None else self . rowCount () self . beginInsertRows ( parent , first , last ) yield None self . endInsertRows () @contextlib . contextmanager def append_rows ( self , num_rows : int , parent : QtCore . QModelIndex | None = None ): parent = QtCore . QModelIndex () if parent is None else parent self . beginInsertRows ( parent , self . rowCount (), self . rowCount () + num_rows - 1 ) yield None self . endInsertRows () @contextlib . contextmanager def insert_columns ( self , first : int | None = None , last : int | None = None , parent : QtCore . QModelIndex | None = None , ): parent = QtCore . QModelIndex () if parent is None else parent first = first if first is not None else 0 last = last if last is not None else self . rowCount () self . beginInsertColumns ( parent , first , last ) yield None self . endInsertColumns () def force_reset ( self ): self . beginResetModel () self . endResetModel () def force_layoutchange ( self ): self . layoutAboutToBeChanged . emit () self . layoutChanged . emit ()","title":"AbstractItemModel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.__len__","text":"Return amount of rows. Source code in prettyqt/core/abstractitemmodel.py def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.change_layout","text":"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit ()","title":"change_layout()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.reset_model","text":"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel ()","title":"reset_model()"},{"location":"api/core.html#prettyqt.core.collator","text":"","title":"collator"},{"location":"api/core.html#prettyqt.core.collator.Collator","text":"Source code in prettyqt/core/collator.py class Collator ( QtCore . QCollator ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_locale () !r} )\" def get_locale ( self ) -> core . Locale : return core . Locale ( self . locale ()) def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = ( QtCore . Qt . CaseSensitivity . CaseSensitive if state else QtCore . Qt . CaseSensitivity . CaseInsensitive ) self . setCaseSensitivity ( sensitivity ) def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ()) def get_sort_key ( self , string : str ) -> core . CollatorSortKey : return core . CollatorSortKey ( self . sortKey ( string ))","title":"Collator"},{"location":"api/core.html#prettyqt.core.collator.Collator.is_case_sensitive","text":"Return case sensitivity. Returns: Type Description bool case sensitivity Source code in prettyqt/core/collator.py def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ())","title":"is_case_sensitive()"},{"location":"api/core.html#prettyqt.core.collator.Collator.set_case_sensitive","text":"Set case sensitivity. Parameters: Name Type Description Default state bool case sensitive required Source code in prettyqt/core/collator.py def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = ( QtCore . Qt . CaseSensitivity . CaseSensitive if state else QtCore . Qt . CaseSensitivity . CaseInsensitive ) self . setCaseSensitivity ( sensitivity )","title":"set_case_sensitive()"},{"location":"api/core.html#prettyqt.core.commandlineparser","text":"","title":"commandlineparser"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser","text":"Source code in prettyqt/core/commandlineparser.py class CommandLineParser ( QtCore . QCommandLineParser ): def set_single_dash_word_option_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the single dash word option mode. Args: mode: single dash word option mode Raises: InvalidParamError: single dash word option mode does not exist \"\"\" if mode not in SINGLE_DASH_WORD : raise InvalidParamError ( mode , SINGLE_DASH_WORD ) self . setSingleDashWordOptionMode ( SINGLE_DASH_WORD [ mode ]) def set_options_after_positional_arguments_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the options after positional arguments mode. Args: mode: options after positional arguments mode Raises: InvalidParamError: options after positional arguments mode does not exist \"\"\" if mode not in OPTIONS_AFTER_POS_ARG : raise InvalidParamError ( mode , OPTIONS_AFTER_POS_ARG ) self . setOptionsAfterPositionalArgumentsMode ( OPTIONS_AFTER_POS_ARG [ mode ]) def add_option ( self , name : str , description : str | None = None , value_name : str | None = None , default_value : str | None = None , ) -> core . CommandLineOption : if description is None : description = \"\" if value_name is None : value_name = \"\" if default_value is None : default_value = \"\" option = core . CommandLineOption ( name , description , value_name , default_value ) self . addOption ( option ) return option","title":"CommandLineParser"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_options_after_positional_arguments_mode","text":"Set the options after positional arguments mode. Parameters: Name Type Description Default mode SingleDashWordStr options after positional arguments mode required Exceptions: Type Description InvalidParamError options after positional arguments mode does not exist Source code in prettyqt/core/commandlineparser.py def set_options_after_positional_arguments_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the options after positional arguments mode. Args: mode: options after positional arguments mode Raises: InvalidParamError: options after positional arguments mode does not exist \"\"\" if mode not in OPTIONS_AFTER_POS_ARG : raise InvalidParamError ( mode , OPTIONS_AFTER_POS_ARG ) self . setOptionsAfterPositionalArgumentsMode ( OPTIONS_AFTER_POS_ARG [ mode ])","title":"set_options_after_positional_arguments_mode()"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_single_dash_word_option_mode","text":"Set the single dash word option mode. Parameters: Name Type Description Default mode SingleDashWordStr single dash word option mode required Exceptions: Type Description InvalidParamError single dash word option mode does not exist Source code in prettyqt/core/commandlineparser.py def set_single_dash_word_option_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the single dash word option mode. Args: mode: single dash word option mode Raises: InvalidParamError: single dash word option mode does not exist \"\"\" if mode not in SINGLE_DASH_WORD : raise InvalidParamError ( mode , SINGLE_DASH_WORD ) self . setSingleDashWordOptionMode ( SINGLE_DASH_WORD [ mode ])","title":"set_single_dash_word_option_mode()"},{"location":"api/core.html#prettyqt.core.datastream","text":"","title":"datastream"},{"location":"api/core.html#prettyqt.core.datastream.DataStream","text":"Source code in prettyqt/core/datastream.py class DataStream ( QtCore . QDataStream ): def set_byte_order ( self , order : ByteOrderStr ): \"\"\"Set byte order. Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ]) def get_byte_order ( self ) -> ByteOrderStr : \"\"\"Return byte order. Returns: byte order \"\"\" return BYTE_ORDER . inverse [ self . byteOrder ()] def set_status ( self , status : StatusStr ): \"\"\"Set status. Args: status: status to use Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ]) def get_status ( self ) -> StatusStr : \"\"\"Return status. Returns: status \"\"\" return STATUS . inverse [ self . status ()] def set_floating_point_precision ( self , precision : FloatingPointPrecisionStr ): \"\"\"Set floating point precision. Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOATING_POINT_PRECISION : raise InvalidParamError ( precision , FLOATING_POINT_PRECISION ) self . setFloatingPointPrecision ( FLOATING_POINT_PRECISION [ precision ]) def get_floating_point_precision ( self ) -> FloatingPointPrecisionStr : \"\"\"Return floating point precision. Returns: floating point precision \"\"\" return FLOATING_POINT_PRECISION . inverse [ self . floatingPointPrecision ()] @classmethod def create_bytearray ( cls , data : types . QtSerializableType ) -> QtCore . QByteArray : ba = QtCore . QByteArray () stream = cls ( ba , core . iodevice . OPEN_MODES [ \"write_only\" ]) stream << data return ba @classmethod def write_bytearray ( cls , ba : types . ByteArrayType , write_to : types . QtSerializableType ): if isinstance ( ba , str ): ba = ba . encode () if not isinstance ( ba , QtCore . QByteArray ): ba = QtCore . QByteArray ( ba ) stream = cls ( ba , core . iodevice . OPEN_MODES [ \"read_only\" ]) stream >> write_to @classmethod def copy_data ( cls , source , dest ): ba = cls . create_bytearray ( source ) cls . write_bytearray ( ba , dest )","title":"DataStream"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_byte_order","text":"Return byte order. Returns: Type Description ByteOrderStr byte order Source code in prettyqt/core/datastream.py def get_byte_order ( self ) -> ByteOrderStr : \"\"\"Return byte order. Returns: byte order \"\"\" return BYTE_ORDER . inverse [ self . byteOrder ()]","title":"get_byte_order()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_floating_point_precision","text":"Return floating point precision. Returns: Type Description FloatingPointPrecisionStr floating point precision Source code in prettyqt/core/datastream.py def get_floating_point_precision ( self ) -> FloatingPointPrecisionStr : \"\"\"Return floating point precision. Returns: floating point precision \"\"\" return FLOATING_POINT_PRECISION . inverse [ self . floatingPointPrecision ()]","title":"get_floating_point_precision()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_status","text":"Return status. Returns: Type Description StatusStr status Source code in prettyqt/core/datastream.py def get_status ( self ) -> StatusStr : \"\"\"Return status. Returns: status \"\"\" return STATUS . inverse [ self . status ()]","title":"get_status()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_byte_order","text":"Set byte order. Parameters: Name Type Description Default order ByteOrderStr byte order to use required Exceptions: Type Description InvalidParamError invalid order Source code in prettyqt/core/datastream.py def set_byte_order ( self , order : ByteOrderStr ): \"\"\"Set byte order. Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ])","title":"set_byte_order()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_floating_point_precision","text":"Set floating point precision. Parameters: Name Type Description Default precision FloatingPointPrecisionStr floating point precision required Exceptions: Type Description InvalidParamError invalid precision Source code in prettyqt/core/datastream.py def set_floating_point_precision ( self , precision : FloatingPointPrecisionStr ): \"\"\"Set floating point precision. Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOATING_POINT_PRECISION : raise InvalidParamError ( precision , FLOATING_POINT_PRECISION ) self . setFloatingPointPrecision ( FLOATING_POINT_PRECISION [ precision ])","title":"set_floating_point_precision()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_status","text":"Set status. Parameters: Name Type Description Default status StatusStr status to use required Exceptions: Type Description InvalidParamError invalid status Source code in prettyqt/core/datastream.py def set_status ( self , status : StatusStr ): \"\"\"Set status. Args: status: status to use Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ])","title":"set_status()"},{"location":"api/core.html#prettyqt.core.deadlinetimer","text":"","title":"deadlinetimer"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer","text":"Source code in prettyqt/core/deadlinetimer.py class DeadlineTimer ( QtCore . QDeadlineTimer ): def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ]) def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()]","title":"DeadlineTimer"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.get_type","text":"Return current timer type. Returns: Type Description constants.TimerTypeStr timer type Source code in prettyqt/core/deadlinetimer.py def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.set_type","text":"Set the timer type. Parameters: Name Type Description Default typ constants.TimerTypeStr timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/deadlinetimer.py def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ])","title":"set_type()"},{"location":"api/core.html#prettyqt.core.easingcurve","text":"","title":"easingcurve"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve","text":"Source code in prettyqt/core/easingcurve.py class EasingCurve ( QtCore . QEasingCurve ): def __init__ ( self , other_or_type : TypeStr | int | QtCore . QEasingCurve = \"linear\" ): if isinstance ( other_or_type , str ) and other_or_type in TYPE : typ = TYPE [ other_or_type ] else : typ = other_or_type super () . __init__ ( typ ) def __getitem__ ( self , value : float ) -> float : return self . valueForProgress ( value ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_type () !r} )\" def set_custom_type ( self , method : CurveMethod ): self . setCustomType ( method ) def get_custom_type ( self ) -> CurveMethod : return self . customType () # type: ignore def set_type ( self , typ : TypeStr ): \"\"\"Set easing curve type. Args: typ: easing curve type Raises: InvalidParamError: easing curve type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setType ( TYPE [ typ ]) def get_type ( self ) -> TypeStr : \"\"\"Get the current easing curve type. Returns: easing curve type \"\"\" return TYPE . inverse [ self . type ()]","title":"EasingCurve"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.get_type","text":"Get the current easing curve type. Returns: Type Description TypeStr easing curve type Source code in prettyqt/core/easingcurve.py def get_type ( self ) -> TypeStr : \"\"\"Get the current easing curve type. Returns: easing curve type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.set_type","text":"Set easing curve type. Parameters: Name Type Description Default typ TypeStr easing curve type required Exceptions: Type Description InvalidParamError easing curve type does not exist Source code in prettyqt/core/easingcurve.py def set_type ( self , typ : TypeStr ): \"\"\"Set easing curve type. Args: typ: easing curve type Raises: InvalidParamError: easing curve type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setType ( TYPE [ typ ])","title":"set_type()"},{"location":"api/core.html#prettyqt.core.elapsedtimer","text":"","title":"elapsedtimer"},{"location":"api/core.html#prettyqt.core.elapsedtimer.ElapsedTimer","text":"Source code in prettyqt/core/elapsedtimer.py class ElapsedTimer ( QtCore . QElapsedTimer ): def __bool__ ( self ): return self . isValid () def get_clock_type ( self ) -> ClockTypeStr : \"\"\"Return current clock type. Returns: clock type \"\"\" return CLOCK_TYPE . inverse [ self . clockType ()]","title":"ElapsedTimer"},{"location":"api/core.html#prettyqt.core.elapsedtimer.ElapsedTimer.get_clock_type","text":"Return current clock type. Returns: Type Description ClockTypeStr clock type Source code in prettyqt/core/elapsedtimer.py def get_clock_type ( self ) -> ClockTypeStr : \"\"\"Return current clock type. Returns: clock type \"\"\" return CLOCK_TYPE . inverse [ self . clockType ()]","title":"get_clock_type()"},{"location":"api/core.html#prettyqt.core.filedevice","text":"","title":"filedevice"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice","text":"Source code in prettyqt/core/filedevice.py class FileDevice ( QtCore . QFileDevice ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . fileName () !r} )\" def __str__ ( self ): return self . fileName () def set_file_time ( self , file_time : types . DateTimeType , typ : FileTimeStr ) -> bool : \"\"\"Set file time. Args: file_time: file time to set typ: file time type Raises: InvalidParamError: file time does not exist \"\"\" if isinstance ( file_time , str ): file_time = dateutil . parser . parse ( file_time ) if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) return self . setFileTime ( file_time , FILE_TIME [ typ ]) # type: ignore def get_file_time ( self , typ : FileTimeStr ) -> datetime . datetime | None : \"\"\"Return current file time. Returns: file time \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) date = self . fileTime ( FILE_TIME [ typ ]) if not date : return None return date . toPython () # type: ignore def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return FILE_ERROR . inverse [ self . error ()]","title":"FileDevice"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice.get_error","text":"Return file error status. Returns: Type Description FileErrorStr file error status Source code in prettyqt/core/filedevice.py def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return FILE_ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice.get_file_time","text":"Return current file time. Returns: Type Description datetime.datetime | None file time Source code in prettyqt/core/filedevice.py def get_file_time ( self , typ : FileTimeStr ) -> datetime . datetime | None : \"\"\"Return current file time. Returns: file time \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) date = self . fileTime ( FILE_TIME [ typ ]) if not date : return None return date . toPython () # type: ignore","title":"get_file_time()"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice.set_file_time","text":"Set file time. Parameters: Name Type Description Default file_time types.DateTimeType file time to set required typ FileTimeStr file time type required Exceptions: Type Description InvalidParamError file time does not exist Source code in prettyqt/core/filedevice.py def set_file_time ( self , file_time : types . DateTimeType , typ : FileTimeStr ) -> bool : \"\"\"Set file time. Args: file_time: file time to set typ: file time type Raises: InvalidParamError: file time does not exist \"\"\" if isinstance ( file_time , str ): file_time = dateutil . parser . parse ( file_time ) if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) return self . setFileTime ( file_time , FILE_TIME [ typ ]) # type: ignore","title":"set_file_time()"},{"location":"api/core.html#prettyqt.core.operatingsystemversion","text":"","title":"operatingsystemversion"},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion","text":"Source code in prettyqt/core/operatingsystemversion.py class OperatingSystemVersion ( QtCore . QOperatingSystemVersion ): def __init__ ( self , typ : QtCore . QOperatingSystemVersion . OSType | str , major : int , minor : int | None = None , micro : int | None = None , ): if isinstance ( typ , str ): os_type = OS_TYPE [ typ ] else : os_type = typ if minor is None : minor = - 1 if micro is None : micro = - 1 super () . __init__ ( os_type , major , minor , micro ) def __repr__ ( self ): return ( f \" { type ( self ) . __name__ } ( { self . get_type () !r} , { self . majorVersion () } , \" f \" { self . minorVersion () } , { self . microVersion () } )\" ) def __reduce__ ( self ): return ( type ( self ), ( self . get_type (), self . majorVersion (), self . minorVersion (), self . microVersion (), ), ) def __eq__ ( self , other ): if not isinstance ( other , OperatingSystemVersion ): return False return ( self . get_type () == other . get_type () and self . get_versionnumber () == other . get_versionnumber () ) def __hash__ ( self ): return hash ( ( self . get_type (), self . majorVersion (), self . minorVersion (), self . microVersion (), ) ) def get_type ( self ) -> OsTypeStr : \"\"\"Get current os type. Returns: current os type \"\"\" return OS_TYPE . inverse [ self . type ()] def get_versionnumber ( self ) -> core . VersionNumber : return core . VersionNumber ( self . majorVersion (), self . minorVersion (), self . microVersion () )","title":"OperatingSystemVersion"},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion.__hash__","text":"Return hash(self). Source code in prettyqt/core/operatingsystemversion.py def __hash__ ( self ): return hash ( ( self . get_type (), self . majorVersion (), self . minorVersion (), self . microVersion (), ) )","title":"__hash__()"},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion.get_type","text":"Get current os type. Returns: Type Description OsTypeStr current os type Source code in prettyqt/core/operatingsystemversion.py def get_type ( self ) -> OsTypeStr : \"\"\"Get current os type. Returns: current os type \"\"\" return OS_TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.process","text":"","title":"process"},{"location":"api/core.html#prettyqt.core.process.Process","text":"Source code in prettyqt/core/process.py class Process ( QtCore . QProcess ): def set_read_channel ( self , channel : ProcessChannelStr ): \"\"\"Set the input channel channel. Args: channel: channel to set Raises: InvalidParamError: invalid channel \"\"\" if channel not in PROCESS_CHANNELS : raise InvalidParamError ( channel , PROCESS_CHANNELS ) self . setReadChannel ( PROCESS_CHANNELS [ channel ]) def get_read_channel ( self ) -> ProcessChannelStr : return PROCESS_CHANNELS . inverse [ self . readChannel ()] def close_read_channel ( self , channel : ProcessChannelStr ): self . closeReadChannel ( PROCESS_CHANNELS [ channel ]) def set_input_channel_mode ( self , mode : InputChannelModeStr ): \"\"\"Set the input channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in INPUT_CHANNEL_MODES : raise InvalidParamError ( mode , INPUT_CHANNEL_MODES ) self . setInputChannelMode ( INPUT_CHANNEL_MODES [ mode ]) def get_input_channel_mode ( self ) -> InputChannelModeStr : return INPUT_CHANNEL_MODES . inverse [ self . inputChannelMode ()] def set_process_channel_mode ( self , mode : ProcessChannelModeStr ): \"\"\"Set the process channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in PROCESS_CHANNEL_MODES : raise InvalidParamError ( mode , PROCESS_CHANNEL_MODES ) self . setProcessChannelMode ( PROCESS_CHANNEL_MODES [ mode ]) def get_process_channel_mode ( self ) -> ProcessChannelModeStr : return PROCESS_CHANNEL_MODES . inverse [ self . processChannelMode ()] def set_state ( self , state : ProcessStateStr ): \"\"\"Set the process state. Args: state: state to set Raises: InvalidParamError: invalid state \"\"\" if state not in PROCESS_STATES : raise InvalidParamError ( state , PROCESS_STATES ) self . setProcessState ( PROCESS_STATES [ state ]) def get_state ( self ) -> ProcessStateStr : return PROCESS_STATES . inverse [ self . state ()] def get_error ( self ) -> ProcessErrorStr : return PROCESS_ERRORS . inverse [ self . error ()] def get_exit_status ( self ) -> ExitStatusStr : return EXIT_STATUS . inverse [ self . exitStatus ()] def get_process_environment ( self ) -> core . ProcessEnvironment : return core . ProcessEnvironment ( self . processEnvironment ()) @contextlib . contextmanager def edit_process_environment ( self ): env = self . get_process_environment () yield env self . setProcessEnvironment ( env )","title":"Process"},{"location":"api/core.html#prettyqt.core.process.Process.set_input_channel_mode","text":"Set the input channel mode. Parameters: Name Type Description Default mode InputChannelModeStr mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_input_channel_mode ( self , mode : InputChannelModeStr ): \"\"\"Set the input channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in INPUT_CHANNEL_MODES : raise InvalidParamError ( mode , INPUT_CHANNEL_MODES ) self . setInputChannelMode ( INPUT_CHANNEL_MODES [ mode ])","title":"set_input_channel_mode()"},{"location":"api/core.html#prettyqt.core.process.Process.set_process_channel_mode","text":"Set the process channel mode. Parameters: Name Type Description Default mode ProcessChannelModeStr mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_process_channel_mode ( self , mode : ProcessChannelModeStr ): \"\"\"Set the process channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in PROCESS_CHANNEL_MODES : raise InvalidParamError ( mode , PROCESS_CHANNEL_MODES ) self . setProcessChannelMode ( PROCESS_CHANNEL_MODES [ mode ])","title":"set_process_channel_mode()"},{"location":"api/core.html#prettyqt.core.process.Process.set_read_channel","text":"Set the input channel channel. Parameters: Name Type Description Default channel ProcessChannelStr channel to set required Exceptions: Type Description InvalidParamError invalid channel Source code in prettyqt/core/process.py def set_read_channel ( self , channel : ProcessChannelStr ): \"\"\"Set the input channel channel. Args: channel: channel to set Raises: InvalidParamError: invalid channel \"\"\" if channel not in PROCESS_CHANNELS : raise InvalidParamError ( channel , PROCESS_CHANNELS ) self . setReadChannel ( PROCESS_CHANNELS [ channel ])","title":"set_read_channel()"},{"location":"api/core.html#prettyqt.core.process.Process.set_state","text":"Set the process state. Parameters: Name Type Description Default state ProcessStateStr state to set required Exceptions: Type Description InvalidParamError invalid state Source code in prettyqt/core/process.py def set_state ( self , state : ProcessStateStr ): \"\"\"Set the process state. Args: state: state to set Raises: InvalidParamError: invalid state \"\"\" if state not in PROCESS_STATES : raise InvalidParamError ( state , PROCESS_STATES ) self . setProcessState ( PROCESS_STATES [ state ])","title":"set_state()"},{"location":"api/core.html#prettyqt.core.regularexpression","text":"","title":"regularexpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression","text":"Source code in prettyqt/core/regularexpression.py class RegularExpression ( QtCore . QRegularExpression ): def __init__ ( self , pattern : str | QtCore . QRegularExpression = \"\" , flags : QtCore . QRegularExpression . PatternOption = FLAGS [ \"none\" ], ): if isinstance ( pattern , QtCore . QRegularExpression ): super () . __init__ ( pattern ) else : if isinstance ( flags , int ): flags = core . RegularExpression . PatternOption ( flags ) # type: ignore super () . __init__ ( pattern , flags ) # type: ignore def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . pattern () !r} )\" def __reduce__ ( self ): return type ( self ), ( self . pattern (), qt . flag_to_int ( self . flags )) def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it ) def global_match ( self , text : str , offset : int = 0 , match_type : MatchTypeStr = \"normal\" , anchored : bool = False , ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] return self . globalMatch ( text , offset , MATCH_TYPE [ match_type ], options ) def match ( # type: ignore self , text : str , offset : int = 0 , match_type : MatchTypeStr | QtCore . QRegularExpression . MatchType = \"normal\" , anchored : bool = False , ) -> core . RegularExpressionMatch : if isinstance ( match_type , str ): typ = MATCH_TYPE [ match_type ] else : typ = match_type if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , typ , options ) return core . RegularExpressionMatch ( match ) def fullmatch ( self , string : str , pos : int = 0 , endpos : int | None = None ) -> core . RegularExpressionMatch | None : if endpos : string = string [: endpos ] match = super () . match ( string , pos ) if match . hasMatch () and len ( string ) == match . end () - match . start (): return core . RegularExpressionMatch ( match ) else : return None def finditer ( self , string : str , pos : int = 0 , endpos : int | None = None ) -> Iterator [ core . RegularExpressionMatch ]: for match in self . globalMatch ( string [: endpos ], offset = pos ): match . pos = pos match . endpos = endpos match . string = string yield match def findall ( self , string : str , pos : int = 0 , endpos : int | None = None ) -> list : matches = list ( self . globalMatch ( string [: endpos ], offset = pos )) return [ m . groups () if len ( m . groups ()) > 1 else m . group ( 0 ) for m in matches ] def subn ( self , repl : str | Callable , string : str , count : int = 0 ) -> tuple [ str , int ]: result = string matches = self . global_match ( string ) matches = list ( matches ) if count > 0 : matches = matches [: count ] matches = list ( reversed ( matches )) for m in matches : to_replace = repl if isinstance ( repl , str ) else repl ( m ) for j in range ( self . groups ): to_replace = to_replace . replace ( rf \"\\g< { j } >\" , m . group ( j )) for k in self . groupindex . keys (): to_replace = to_replace . replace ( rf \"\\g< { k } >\" , m . group ( k )) result = result [: m . start ()] + to_replace + result [ m . end () :] return ( result , min ( len ( matches ), count )) def sub ( self , repl : str | Callable , string : str , count : int = 0 ) -> str : res = self . subn ( repl , string , count ) return res [ 0 ] def search ( self , string : str , pos : int = 0 , endpos : int | None = None ): match = super () . match ( string [: endpos ], pos ) return match if match . hasMatch () else None def split ( self , string : str , maxsplit : int = 0 ): raise NotImplementedError () # result = list() # matches = self.global_match(string) # matches = list(matches) # if 0 < maxsplit <= len(matches): # remainder = string[matches[maxsplit - 1].end() :] # print(remainder) # else: # print(None) # remainder = None # if maxsplit > 0: # matches = matches[:maxsplit] # prev_match = None # m = matches[0] # if m.start() == 0: # result.append(\"\") # else: # result.append(string[0 : m.start()]) # for g in m.groups(): # result.append(g) # prev_match = m # for m in matches[1:]: # result.append(string[prev_match.end() : m.start()]) # for g in m.groups(): # result.append(g) # if m.end() == len(string): # result.append(\"\") # prev_match = m # if remainder: # result.append(remainder) # return result @property def groups ( self ) -> int : return self . captureCount () @property def groupindex ( self ) -> dict [ str , int ]: return { k : i for i , k in enumerate ( self . namedCaptureGroups ()[ 1 :], start = 1 )} @property def flags ( self ): return self . patternOptions ()","title":"RegularExpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.globalMatch","text":"globalMatch(self, subject: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -> PySide6.QtCore.QRegularExpressionMatchIterator globalMatch(self, subjectView: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -> PySide6.QtCore.QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it )","title":"globalMatch()"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.match","text":"match(self, subject: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -> PySide6.QtCore.QRegularExpressionMatch match(self, subjectView: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -> PySide6.QtCore.QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py def match ( # type: ignore self , text : str , offset : int = 0 , match_type : MatchTypeStr | QtCore . QRegularExpression . MatchType = \"normal\" , anchored : bool = False , ) -> core . RegularExpressionMatch : if isinstance ( match_type , str ): typ = MATCH_TYPE [ match_type ] else : typ = match_type if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , typ , options ) return core . RegularExpressionMatch ( match )","title":"match()"},{"location":"api/core.html#prettyqt.core.settings","text":"","title":"settings"},{"location":"api/core.html#prettyqt.core.settings.Settings","text":"Source code in prettyqt/core/settings.py class Settings ( QtCore . QSettings ): def __init__ ( self , * args , settings_id : str | None = None ): super () . __init__ ( * args ) self . settings_id = settings_id def __repr__ ( self ): return f \" { type ( self ) . __name__ } : { self . as_dict () } \" def __contains__ ( self , key : str ) -> bool : return self . contains ( key ) def __enter__ ( self ): if self . settings_id : self . beginGroup ( self . settings_id ) return self def __exit__ ( self , exc_type , exc_value , traceback ): if self . settings_id : self . endGroup () def __getitem__ ( self , index : str ): return self . get_value ( index ) def __setitem__ ( self , name : str , value ): return self . set_value ( name , value ) def __delitem__ ( self , key : str ): if not self . contains ( key ): raise KeyError ( key ) return self . remove ( key ) def __iter__ ( self ) -> Iterator [ tuple [ str , Any ]]: return iter ( self . items ()) def __len__ ( self ) -> int : return len ( self . allKeys ()) @classmethod def build_from_dict ( cls , dct : dict [ str , Any ]): settings = cls () for k , v in dct . items (): settings . set_value ( k , v ) return settings def as_dict ( self ) -> dict [ str , Any ]: return { k : v for k , v in self . items ()} def set_value ( self , key : str , value ): if not self . applicationName (): raise RuntimeError ( \"no app name defined\" ) self . setValue ( key , dict ( value = value )) def set_values ( self , dct : dict [ str , Any ]): for k , v in dct . items (): self . set_value ( k , v ) def get_value ( self , key : str , default = None ): if not self . contains ( key ): return default val = self . value ( key ) # this is for migration if not isinstance ( val , dict ) or \"value\" not in val : self . set_value ( key , val ) return val return val [ \"value\" ] @classmethod def set_default_format ( cls , fmt : FormatStr ): \"\"\"Set the default format. Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) cls . setDefaultFormat ( FORMAT [ fmt ]) @classmethod def get_default_format ( cls ) -> FormatStr : \"\"\"Return default settings format. Returns: default settings format \"\"\" return FORMAT . inverse [ cls . defaultFormat ()] def get_scope ( self ) -> ScopeStr : \"\"\"Return scope. Returns: scope \"\"\" return SCOPE . inverse [ self . scope ()] @classmethod def set_path ( cls , fmt : FormatStr , scope : ScopeStr , path : types . PathType ): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) if scope not in SCOPE : raise InvalidParamError ( scope , SCOPE ) cls . setPath ( FORMAT [ fmt ], SCOPE [ scope ], os . fspath ( path )) @contextlib . contextmanager def edit_group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup () @contextlib . contextmanager def write_array ( self , prefix : str , size : int | None = None ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" if size is None : size = - 1 self . beginWriteArray ( prefix , size ) yield None self . endArray () @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray () # Dictionary interface def get ( self , key : str , default : Any = None ) -> Any : return self . get_value ( key , default ) def setdefault ( self , key : str , default : Any = None ) -> Any : if not self . contains ( key ): self . set_value ( key , default ) return default return self . get_value ( key ) def keys ( self ) -> list [ str ]: return self . allKeys () def values ( self ) -> Iterator [ Any ]: return ( self . get_value ( key ) for key in self . allKeys ()) def items ( self ): return zip ( self . keys (), self . values ()) def pop ( self , key : str ): if self . contains ( key ): return self . get_value ( key ) raise KeyError ( key ) def popitem ( self ) -> tuple [ str , Any ]: key = self . keys ()[ 0 ] return ( key , self . get_value ( key )) def update ( self , other : Mapping [ str , Any ]): for k , v in other . items (): self . set_value ( k , v ) @classmethod def register_extensions ( cls , * exts : str , app_name : str | None = None , app_path : None | types . PathType = None , ): logger . debug ( f \"assigning extensions { exts } to { app_name } \" ) s = cls ( \"HKEY_CURRENT_USER \\\\ SOFTWARE \\\\ Classes\" , Settings . Format . NativeFormat ) if app_path is None : app_path = str ( core . CoreApplication . get_application_file_path ()) app_path = os . fspath ( app_path ) if app_name is None : app_name = core . CoreApplication . applicationName () for ext in exts : s . setValue ( f \" { ext } /DefaultIcon/.\" , app_path ) # perhaps ,0 after app_path s . setValue ( f \" { ext } /.\" , app_name ) s . setValue ( f \" { app_name } /shell/open/command/.\" , f \" { app_path } %1\" )","title":"Settings"},{"location":"api/core.html#prettyqt.core.settings.Settings.edit_group","text":"Context manager for setting groups. Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py @contextlib . contextmanager def edit_group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup ()","title":"edit_group()"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_default_format","text":"Return default settings format. Returns: Type Description FormatStr default settings format Source code in prettyqt/core/settings.py @classmethod def get_default_format ( cls ) -> FormatStr : \"\"\"Return default settings format. Returns: default settings format \"\"\" return FORMAT . inverse [ cls . defaultFormat ()]","title":"get_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_scope","text":"Return scope. Returns: Type Description ScopeStr scope Source code in prettyqt/core/settings.py def get_scope ( self ) -> ScopeStr : \"\"\"Return scope. Returns: scope \"\"\" return SCOPE . inverse [ self . scope ()]","title":"get_scope()"},{"location":"api/core.html#prettyqt.core.settings.Settings.read_array","text":"Context manager for reading arrays. Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray ()","title":"read_array()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_default_format","text":"Set the default format. Parameters: Name Type Description Default fmt FormatStr the default format to use required Exceptions: Type Description InvalidParamError invalid format Source code in prettyqt/core/settings.py @classmethod def set_default_format ( cls , fmt : FormatStr ): \"\"\"Set the default format. Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) cls . setDefaultFormat ( FORMAT [ fmt ])","title":"set_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_path","text":"Set the path to the settings file. Parameters: Name Type Description Default fmt FormatStr the default format to use required scope ScopeStr the scope to use required Exceptions: Type Description InvalidParamError invalid format or scope Source code in prettyqt/core/settings.py @classmethod def set_path ( cls , fmt : FormatStr , scope : ScopeStr , path : types . PathType ): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) if scope not in SCOPE : raise InvalidParamError ( scope , SCOPE ) cls . setPath ( FORMAT [ fmt ], SCOPE [ scope ], os . fspath ( path ))","title":"set_path()"},{"location":"api/core.html#prettyqt.core.settings.Settings.write_array","text":"Context manager for writing arrays. Parameters: Name Type Description Default prefix str prefix for settings array required size int | None size of settings array None Source code in prettyqt/core/settings.py @contextlib . contextmanager def write_array ( self , prefix : str , size : int | None = None ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" if size is None : size = - 1 self . beginWriteArray ( prefix , size ) yield None self . endArray ()","title":"write_array()"},{"location":"api/core.html#prettyqt.core.socketnotifier","text":"","title":"socketnotifier"},{"location":"api/core.html#prettyqt.core.socketnotifier.SocketNotifier","text":"Source code in prettyqt/core/socketnotifier.py class SocketNotifier ( QtCore . QSocketNotifier ): # def __repr__(self): # return f\"{type(self).__name__}({self.socket()}, {self.type()})\" def get_type ( self ) -> TypeStr : \"\"\"Return socket event type. Returns: socket event type \"\"\" return TYPE . inverse [ self . type ()]","title":"SocketNotifier"},{"location":"api/core.html#prettyqt.core.socketnotifier.SocketNotifier.get_type","text":"Return socket event type. Returns: Type Description TypeStr socket event type Source code in prettyqt/core/socketnotifier.py def get_type ( self ) -> TypeStr : \"\"\"Return socket event type. Returns: socket event type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.textstream","text":"","title":"textstream"},{"location":"api/core.html#prettyqt.core.textstream.TextStream","text":"Source code in prettyqt/core/textstream.py class TextStream ( QtCore . QTextStream ): def set_field_alignment ( self , alignment : FieldAlignmentStr ): \"\"\"Set the field alignment. Args: alignment: field alignment Raises: InvalidParamError: invalid field alignment \"\"\" if alignment not in FIELD_ALIGNMENT : raise InvalidParamError ( alignment , FIELD_ALIGNMENT ) self . setFieldAlignment ( FIELD_ALIGNMENT [ alignment ]) def get_field_alignment ( self ) -> FieldAlignmentStr : \"\"\"Get current field alignment. Returns: current field alignment \"\"\" return FIELD_ALIGNMENT . inverse [ self . fieldAlignment ()] def set_status ( self , status : StatusStr ): \"\"\"Set the status. Args: status: status Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ]) def get_status ( self ) -> StatusStr : \"\"\"Get current status. Returns: current status \"\"\" return STATUS . inverse [ self . status ()] def set_real_number_notation ( self , notation : RealNumberNotationStr ): \"\"\"Set the real number notation. Args: notation: real number notation Raises: InvalidParamError: invalid real number notation \"\"\" if notation not in REAL_NUMBER_NOTATION : raise InvalidParamError ( notation , REAL_NUMBER_NOTATION ) self . setRealNumberNotation ( REAL_NUMBER_NOTATION [ notation ]) def get_real_number_notation ( self ) -> RealNumberNotationStr : \"\"\"Get current real number notation. Returns: current real number notation \"\"\" return REAL_NUMBER_NOTATION . inverse [ self . realNumberNotation ()] def set_codec ( self , codec : bytes | str ): if isinstance ( codec , str ): codec = codec . encode () self . setCodec ( codec ) def read_lines ( self ) -> Iterator [ str ]: while True : msg = self . readLine () if not msg : return yield msg","title":"TextStream"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_field_alignment","text":"Get current field alignment. Returns: Type Description FieldAlignmentStr current field alignment Source code in prettyqt/core/textstream.py def get_field_alignment ( self ) -> FieldAlignmentStr : \"\"\"Get current field alignment. Returns: current field alignment \"\"\" return FIELD_ALIGNMENT . inverse [ self . fieldAlignment ()]","title":"get_field_alignment()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_real_number_notation","text":"Get current real number notation. Returns: Type Description RealNumberNotationStr current real number notation Source code in prettyqt/core/textstream.py def get_real_number_notation ( self ) -> RealNumberNotationStr : \"\"\"Get current real number notation. Returns: current real number notation \"\"\" return REAL_NUMBER_NOTATION . inverse [ self . realNumberNotation ()]","title":"get_real_number_notation()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_status","text":"Get current status. Returns: Type Description StatusStr current status Source code in prettyqt/core/textstream.py def get_status ( self ) -> StatusStr : \"\"\"Get current status. Returns: current status \"\"\" return STATUS . inverse [ self . status ()]","title":"get_status()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_field_alignment","text":"Set the field alignment. Parameters: Name Type Description Default alignment FieldAlignmentStr field alignment required Exceptions: Type Description InvalidParamError invalid field alignment Source code in prettyqt/core/textstream.py def set_field_alignment ( self , alignment : FieldAlignmentStr ): \"\"\"Set the field alignment. Args: alignment: field alignment Raises: InvalidParamError: invalid field alignment \"\"\" if alignment not in FIELD_ALIGNMENT : raise InvalidParamError ( alignment , FIELD_ALIGNMENT ) self . setFieldAlignment ( FIELD_ALIGNMENT [ alignment ])","title":"set_field_alignment()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_real_number_notation","text":"Set the real number notation. Parameters: Name Type Description Default notation RealNumberNotationStr real number notation required Exceptions: Type Description InvalidParamError invalid real number notation Source code in prettyqt/core/textstream.py def set_real_number_notation ( self , notation : RealNumberNotationStr ): \"\"\"Set the real number notation. Args: notation: real number notation Raises: InvalidParamError: invalid real number notation \"\"\" if notation not in REAL_NUMBER_NOTATION : raise InvalidParamError ( notation , REAL_NUMBER_NOTATION ) self . setRealNumberNotation ( REAL_NUMBER_NOTATION [ notation ])","title":"set_real_number_notation()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_status","text":"Set the status. Parameters: Name Type Description Default status StatusStr status required Exceptions: Type Description InvalidParamError invalid status Source code in prettyqt/core/textstream.py def set_status ( self , status : StatusStr ): \"\"\"Set the status. Args: status: status Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ])","title":"set_status()"},{"location":"api/core.html#prettyqt.core.timeline","text":"","title":"timeline"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine","text":"Source code in prettyqt/core/timeline.py class TimeLine ( QtCore . QTimeLine ): def serialize_fields ( self ): return dict ( current_time = self . currentTime (), direction = self . get_direction (), duration = self . duration (), easing_curve = self . easingCurve (), loop_count = self . loopCount (), update_interval = self . updateInterval (), ) def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()] def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()] def set_easing ( self , easing_type : core . easingcurve . TypeStr | Callable [[ float ], float ] ) -> core . EasingCurve : curve = core . EasingCurve () if isinstance ( easing_type , str ): curve . set_type ( easing_type ) else : curve . set_custom_type ( easing_type ) self . setEasingCurve ( curve ) return curve def get_easing ( self ) -> core . easingcurve . TypeStr | Callable [[ float ], float ]: curve = core . EasingCurve ( self . easingCurve ()) typ = curve . get_type () if typ == \"custom\" : return curve . get_custom_type () else : return typ","title":"TimeLine"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_direction","text":"Return current direction. Returns: Type Description DirectionStr direction Source code in prettyqt/core/timeline.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()]","title":"get_direction()"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_state","text":"Return current state. Returns: Type Description StateStr state Source code in prettyqt/core/timeline.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.set_direction","text":"Set the direction. Parameters: Name Type Description Default direction DirectionStr direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/core/timeline.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ])","title":"set_direction()"},{"location":"api/core.html#prettyqt.core.timer","text":"","title":"timer"},{"location":"api/core.html#prettyqt.core.timer.Timer","text":"Source code in prettyqt/core/timer.py class Timer ( QtCore . QTimer ): def serialize_fields ( self ): return dict ( interval = self . interval (), single_shot = self . isSingleShot (), timer_type = self . get_type (), ) @classmethod def single_shot ( cls , callback : Callable ) -> Timer : timer = cls () timer . timeout . connect ( callback ) timer . setSingleShot ( True ) return timer def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ]) def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()] def set_interval ( self , interval : int | str ): if isinstance ( interval , str ): interval = helpers . parse_time ( interval ) self . setInterval ( interval ) def start_timer ( self , interval : None | int | str = None ): if isinstance ( interval , str ): interval = helpers . parse_time ( interval ) if interval is None : self . start () else : self . start ( interval ) def restart ( self ): self . stop () self . start ()","title":"Timer"},{"location":"api/core.html#prettyqt.core.timer.Timer.get_type","text":"Return current timer type. Returns: Type Description constants.TimerTypeStr timer type Source code in prettyqt/core/timer.py def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.timer.Timer.set_type","text":"Set the timer type. Parameters: Name Type Description Default typ constants.TimerTypeStr timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/timer.py def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ])","title":"set_type()"},{"location":"api/core.html#prettyqt.core.url","text":"","title":"url"},{"location":"api/core.html#prettyqt.core.url.Url","text":"Source code in prettyqt/core/url.py class Url ( QtCore . QUrl ): def __init__ ( self , path : types . UrlType | types . PathType | None = None ): if path is None : super () . __init__ () else : if isinstance ( path , QtCore . QUrl ): super () . __init__ ( path ) else : super () . __init__ ( os . fspath ( path )) if isinstance ( path , os . PathLike ): self . setScheme ( \"file\" ) # def __str__(self): # return self.absolutePath() def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . toString () !r} )\" def __str__ ( self ): return self . toString () def serialize_fields ( self ): return dict ( path = self . toString ()) def serialize ( self ) -> dict [ str , Any ]: return self . serialize_fields () def to_string ( self ) -> str : return self . toString () def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self )) def is_local_file ( self ) -> bool : return self . isLocalFile () @classmethod def from_user_input ( cls , url : str , working_dir : str | None = None ) -> Url : if working_dir is None : working_dir = \"\" return cls ( cls . fromUserInput ( url , working_dir )) @classmethod def from_local_file ( cls , path : types . PathType ) -> Url : url = cls . fromLocalFile ( os . fspath ( path )) return cls ( url )","title":"Url"},{"location":"api/core.html#prettyqt.core.url.Url.to_path","text":"Get pathlib object from the URL. Returns: Type Description pathlib.Path Path Source code in prettyqt/core/url.py def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self ))","title":"to_path()"},{"location":"api/core.html#prettyqt.core.versionnumber","text":"","title":"versionnumber"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber","text":"Source code in prettyqt/core/versionnumber.py class VersionNumber ( QtCore . QVersionNumber ): def __init__ ( self , * args , ** kwargs ): if len ( args ) == 1 : if isinstance ( args [ 0 ], str ): args = tuple ( int ( i ) for i in args [ 0 ] . split ( \".\" )) elif isinstance ( args [ 0 ], tuple ): args = args [ 0 ] # PySide6 Workaround: elif isinstance ( args [ 0 ], QtCore . QVersionNumber ): args = ( args [ 0 ] . majorVersion (), args [ 0 ] . minorVersion (), args [ 0 ] . microVersion (), ) super () . __init__ ( * args , ** kwargs ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . major () } , { self . minor () } , { self . micro () } )\" def __reduce__ ( self ): return type ( self ), ( self . major (), self . minor (), self . micro ()) def __str__ ( self ): return self . toString () def __eq__ ( self , other ): if isinstance ( other , ( str , tuple )): other = VersionNumber ( other ) return super () . __eq__ ( other ) def __hash__ ( self ): return hash (( self . major (), self . minor (), self . micro ())) def __gt__ ( self , other : types . SemanticVersionType ): if isinstance ( other , ( str , tuple )): other = VersionNumber ( other ) return super () . __gt__ ( other ) def __ge__ ( self , other : types . SemanticVersionType ): if isinstance ( other , ( str , tuple )): other = VersionNumber ( other ) return super () . __ge__ ( other ) def __lt__ ( self , other : types . SemanticVersionType ): if isinstance ( other , ( str , tuple )): other = VersionNumber ( other ) return super () . __lt__ ( other ) def __le__ ( self , other : types . SemanticVersionType ): if isinstance ( other , ( str , tuple )): other = VersionNumber ( other ) return super () . __le__ ( other ) @classmethod def get_qt_version ( cls ) -> VersionNumber : return cls ( * [ int ( i ) for i in QtCore . __version__ . split ( \".\" )]) @classmethod def get_python_version ( cls ) -> VersionNumber : return cls ( * sys . version_info [: 3 ]) def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion () def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion () def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion ()","title":"VersionNumber"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.major","text":"An integer representing the major version. Source code in prettyqt/core/versionnumber.py def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion ()","title":"major()"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.micro","text":"An integer representing the micro version. Source code in prettyqt/core/versionnumber.py def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion ()","title":"micro()"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.minor","text":"An integer representing the minor version. Source code in prettyqt/core/versionnumber.py def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion ()","title":"minor()"},{"location":"api/core.html#prettyqt.core.xmlstreamreader","text":"","title":"xmlstreamreader"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader","text":"Source code in prettyqt/core/xmlstreamreader.py class XmlStreamReader ( QtCore . QXmlStreamReader ): def __iter__ ( self ): return self def __next__ ( self ): while not self . atEnd (): self . readNext () if self . hasError (): raise RuntimeError ( self . get_error ()) return self raise StopIteration def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return ERROR . inverse [ self . error ()] def get_token_type ( self ) -> TokenTypeStr : \"\"\"Get the current token type. Returns: token type \"\"\" return TOKEN_TYPE . inverse [ self . tokenType ()] def read_next ( self ) -> TokenTypeStr : \"\"\"Read the next token and returns its type. Returns: token type \"\"\" return TOKEN_TYPE . inverse [ self . readNext ()]","title":"XmlStreamReader"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.get_error","text":"Return file error status. Returns: Type Description FileErrorStr file error status Source code in prettyqt/core/xmlstreamreader.py def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.get_token_type","text":"Get the current token type. Returns: Type Description TokenTypeStr token type Source code in prettyqt/core/xmlstreamreader.py def get_token_type ( self ) -> TokenTypeStr : \"\"\"Get the current token type. Returns: token type \"\"\" return TOKEN_TYPE . inverse [ self . tokenType ()]","title":"get_token_type()"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.read_next","text":"Read the next token and returns its type. Returns: Type Description TokenTypeStr token type Source code in prettyqt/core/xmlstreamreader.py def read_next ( self ) -> TokenTypeStr : \"\"\"Read the next token and returns its type. Returns: token type \"\"\" return TOKEN_TYPE . inverse [ self . readNext ()]","title":"read_next()"},{"location":"api/custom_delegates.html","text":"custom_delegates module Module containing custom delegate classes. buttondelegate ButtonDelegate ( ItemDelegate ) Source code in prettyqt/custom_delegates/buttondelegate.py class ButtonDelegate ( widgets . ItemDelegate ): def __init__ ( self , parent : QtWidgets . QWidget | None , role = QtCore . Qt . ItemDataRole . UserRole ): super () . __init__ ( parent ) self . fn_role = role def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn def setEditorData ( self , editor , index ): pass def setModelData ( self , editor , model , index ): pass @core . Slot () def currentIndexChanged ( self ): self . commitData . emit ( self . sender ()) createEditor ( self , parent , option , index ) -> widgets . PushButton createEditor(self, parent: PySide6.QtWidgets.QWidget, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtWidgets.QWidget Source code in prettyqt/custom_delegates/buttondelegate.py def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn setEditorData ( self , editor , index ) setEditorData(self, editor: PySide6.QtWidgets.QWidget, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/buttondelegate.py def setEditorData ( self , editor , index ): pass setModelData ( self , editor , model , index ) setModelData(self, editor: PySide6.QtWidgets.QWidget, model: PySide6.QtCore.QAbstractItemModel, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/buttondelegate.py def setModelData ( self , editor , model , index ): pass checkboxdelegate CheckBoxDelegate ( ItemDelegate ) Source code in prettyqt/custom_delegates/checkboxdelegate.py class CheckBoxDelegate ( widgets . ItemDelegate ): \"\"\"Delegate that places a CheckBox in every cell.\"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . selected = [] def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection ) @core . Slot () def currentIndexChanged ( self ): self . commitData . emit ( self . sender ()) createEditor ( self , parent , option , index ) Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. Source code in prettyqt/custom_delegates/checkboxdelegate.py def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb setEditorData ( self , cb , index ) Override. set correct initial value for editor widget Source code in prettyqt/custom_delegates/checkboxdelegate.py def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection ) icondelegate IconDelegate ( StyledItemDelegate ) Source code in prettyqt/custom_delegates/icondelegate.py class IconDelegate ( widgets . StyledItemDelegate ): def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if not value : return margin = 10 mode = gui . Icon . Mode . Normal if not ( option . state & widgets . Style . StateFlag . State_Enabled ): mode = gui . Icon . Mode . Disabled elif option . state & widgets . Style . StateFlag . State_Selected : mode = gui . Icon . Mode . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = int ( value . size () / value . devicePixelRatio ()) elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = int ( value . size () / value . devicePixelRatio ()) elif isinstance ( value , QtGui . QIcon ): is_on = option . state & widgets . Style . StateFlag . State_Open state = gui . Icon . State . On if is_on else gui . Icon . State . Off actual_size = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = option . decorationSize & actual_size r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = ( gui . Icon . State . On if option . state & widgets . Style . StateFlag . State_Open else gui . Icon . State . Off ) alignment = constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER # type: ignore icon . paint ( painter , r , alignment , mode , state ) paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex ) Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000' Parameters: Name Type Description Default painter QtGui.QPainter painter to paint the icon required option QtWidgets.QStyleOptionViewItem state of the item to be displayed required index QtCore.QModelIndex index which gets decorated required Source code in prettyqt/custom_delegates/icondelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if not value : return margin = 10 mode = gui . Icon . Mode . Normal if not ( option . state & widgets . Style . StateFlag . State_Enabled ): mode = gui . Icon . Mode . Disabled elif option . state & widgets . Style . StateFlag . State_Selected : mode = gui . Icon . Mode . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = int ( value . size () / value . devicePixelRatio ()) elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = int ( value . size () / value . devicePixelRatio ()) elif isinstance ( value , QtGui . QIcon ): is_on = option . state & widgets . Style . StateFlag . State_Open state = gui . Icon . State . On if is_on else gui . Icon . State . Off actual_size = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = option . decorationSize & actual_size r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = ( gui . Icon . State . On if option . state & widgets . Style . StateFlag . State_Open else gui . Icon . State . Off ) alignment = constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER # type: ignore icon . paint ( painter , r , alignment , mode , state ) nofocusdelegate NoFocusDelegate ( StyledItemDelegate ) Source code in prettyqt/custom_delegates/nofocusdelegate.py class NoFocusDelegate ( widgets . StyledItemDelegate ): def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . StateFlag . State_HasFocus : option . state = option . state ^ widgets . Style . StateFlag . State_HasFocus super () . paint ( painter , option , index ) paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex ) paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/nofocusdelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . StateFlag . State_HasFocus : option . state = option . state ^ widgets . Style . StateFlag . State_HasFocus super () . paint ( painter , option , index ) progressbardelegate ProgressBarDelegate ( StyledItemDelegate ) Source code in prettyqt/custom_delegates/progressbardelegate.py class ProgressBarDelegate ( widgets . StyledItemDelegate ): def paint ( self , painter , option , index ): progress = index . data () opt = widgets . StyleOptionProgressBar () opt . rect = option . rect opt . minimum = 0 opt . maximum = 100 opt . progress = progress opt . text = f \" { progress } %\" opt . textVisible = True opt . state |= widgets . Style . StateFlag . State_Horizontal widgets . Application . style () . drawControl ( widgets . Style . ControlElement . CE_ProgressBar , opt , painter ) paint ( self , painter , option , index ) paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/progressbardelegate.py def paint ( self , painter , option , index ): progress = index . data () opt = widgets . StyleOptionProgressBar () opt . rect = option . rect opt . minimum = 0 opt . maximum = 100 opt . progress = progress opt . text = f \" { progress } %\" opt . textVisible = True opt . state |= widgets . Style . StateFlag . State_Horizontal widgets . Application . style () . drawControl ( widgets . Style . ControlElement . CE_ProgressBar , opt , painter ) radiodelegate RadioDelegate ( StyledItemDelegate ) Source code in prettyqt/custom_delegates/radiodelegate.py class RadioDelegate ( widgets . StyledItemDelegate ): def __init__ ( self , parent : QtWidgets . QWidget , items : list [ str ]): super () . __init__ ( parent ) self . items = items self . choices : list [ int | None ] = [ None for i in self . items ] def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ) -> widgets . Widget : editor = widgets . Widget ( parent ) editor . set_margin ( 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . button_group = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . set_margin ( 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . set_focus_policy ( \"none\" ) rb . installEventFilter ( self ) editor . button_group . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) # type: ignore editor . installEventFilter ( self ) return editor def eventFilter ( self , source : QtWidgets . QWidget , event : QtCore . QEvent ) -> bool : if event . type () == core . Event . Type . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . Type . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . Type . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( b \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event ) def updateEditorGeometry ( self , editor : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): rect = core . Rect ( option . rect ) min_width = editor . minimumSizeHint () . width () if rect . width () < min_width : rect . setWidth ( min_width ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) # type: ignore editor . setMask ( mask ) def setEditorData ( self , editor : QtWidgets . QWidget , index : QtCore . QModelIndex ): value = index . data ( constants . DISPLAY_ROLE ) # type: ignore if value in self . items : editor . button_group . button ( self . items . index ( value )) . setChecked ( True ) def setModelData ( self , editor : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , index : QtCore . QModelIndex , ): button = editor . button_group . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], constants . DISPLAY_ROLE # type: ignore ) self . choices [ button ] = index . row () createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex ) -> widgets . Widget createEditor(self, parent: PySide6.QtWidgets.QWidget, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtWidgets.QWidget Source code in prettyqt/custom_delegates/radiodelegate.py def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ) -> widgets . Widget : editor = widgets . Widget ( parent ) editor . set_margin ( 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . button_group = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . set_margin ( 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . set_focus_policy ( \"none\" ) rb . installEventFilter ( self ) editor . button_group . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) # type: ignore editor . installEventFilter ( self ) return editor eventFilter ( self , source : QtWidgets . QWidget , event : QtCore . QEvent ) -> bool eventFilter(self, object: PySide6.QtCore.QObject, event: PySide6.QtCore.QEvent) -> bool Source code in prettyqt/custom_delegates/radiodelegate.py def eventFilter ( self , source : QtWidgets . QWidget , event : QtCore . QEvent ) -> bool : if event . type () == core . Event . Type . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . Type . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . Type . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( b \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event ) setEditorData ( self , editor : QtWidgets . QWidget , index : QtCore . QModelIndex ) setEditorData(self, editor: PySide6.QtWidgets.QWidget, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/radiodelegate.py def setEditorData ( self , editor : QtWidgets . QWidget , index : QtCore . QModelIndex ): value = index . data ( constants . DISPLAY_ROLE ) # type: ignore if value in self . items : editor . button_group . button ( self . items . index ( value )) . setChecked ( True ) setModelData ( self , editor : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , index : QtCore . QModelIndex ) setModelData(self, editor: PySide6.QtWidgets.QWidget, model: PySide6.QtCore.QAbstractItemModel, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/radiodelegate.py def setModelData ( self , editor : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , index : QtCore . QModelIndex , ): button = editor . button_group . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], constants . DISPLAY_ROLE # type: ignore ) self . choices [ button ] = index . row () updateEditorGeometry ( self , editor : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex ) updateEditorGeometry(self, editor: PySide6.QtWidgets.QWidget, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/radiodelegate.py def updateEditorGeometry ( self , editor : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): rect = core . Rect ( option . rect ) min_width = editor . minimumSizeHint () . width () if rect . width () < min_width : rect . setWidth ( min_width ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) # type: ignore editor . setMask ( mask ) renderlinkdelegate RenderLinkDelegate ( StyledItemDelegate ) Source code in prettyqt/custom_delegates/renderlinkdelegate.py class RenderLinkDelegate ( widgets . StyledItemDelegate ): def paint ( self , painter , option , index ): text = index . data () if not text : return painter . save () # I only wanted it for mouse over, but you'll probably want to remove # this condition if option . state and widgets . Style . StateFlag . State_MouseOver : font = option . font font . setUnderline ( True ) painter . setFont ( font ) painter . setPen ( option . palette . link () . color ()) painter . drawText ( option . rect , constants . ALIGN_LEFT | constants . ALIGN_V_CENTER , # type: ignore ) painter . restore () def editorEvent ( self , event , model , option , index ): text = index . data () font = index . data ( constants . FONT_ROLE ) # alignment = index.data(constants.ALIGNMENT_ROLE) if font is None : font = gui . GuiApplication . get_font () fm = gui . FontMetricsF ( font ) rect = fm . get_bounding_rect ( core . RectF ( option . rect ), constants . ALIGN_LEFT | constants . ALIGN_V_CENTER , # type: ignore text , ) if ( event . type () == QtCore . QEvent . Type . MouseButtonPress and event . button () == QtCore . Qt . MouseButton . LeftButton and event . localPos () in rect ): text = index . data () gui . DesktopServices . open_url ( text ) return True return False editorEvent ( self , event , model , option , index ) editorEvent(self, event: PySide6.QtCore.QEvent, model: PySide6.QtCore.QAbstractItemModel, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> bool Source code in prettyqt/custom_delegates/renderlinkdelegate.py def editorEvent ( self , event , model , option , index ): text = index . data () font = index . data ( constants . FONT_ROLE ) # alignment = index.data(constants.ALIGNMENT_ROLE) if font is None : font = gui . GuiApplication . get_font () fm = gui . FontMetricsF ( font ) rect = fm . get_bounding_rect ( core . RectF ( option . rect ), constants . ALIGN_LEFT | constants . ALIGN_V_CENTER , # type: ignore text , ) if ( event . type () == QtCore . QEvent . Type . MouseButtonPress and event . button () == QtCore . Qt . MouseButton . LeftButton and event . localPos () in rect ): text = index . data () gui . DesktopServices . open_url ( text ) return True return False paint ( self , painter , option , index ) paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/renderlinkdelegate.py def paint ( self , painter , option , index ): text = index . data () if not text : return painter . save () # I only wanted it for mouse over, but you'll probably want to remove # this condition if option . state and widgets . Style . StateFlag . State_MouseOver : font = option . font font . setUnderline ( True ) painter . setFont ( font ) painter . setPen ( option . palette . link () . color ()) painter . drawText ( option . rect , constants . ALIGN_LEFT | constants . ALIGN_V_CENTER , # type: ignore ) painter . restore () stardelegate StarDelegate ( StyledItemDelegate ) Source code in prettyqt/custom_delegates/stardelegate.py class StarDelegate ( widgets . StyledItemDelegate ): \"\"\"A delegate class that allows us to render our star ratings.\"\"\" def paint ( self , painter , option , index ): star_rating = StarRating ( index . data ()) # If the row is currently selected, we need to make sure we # paint the background accordingly. if option . state & widgets . Style . StateFlag . State_Selected : # The original C++ example used option.palette.foreground() to # get the brush for painting, but there are a couple of # problems with that: # - foreground() is obsolete now, use windowText() instead # - more importantly, windowText() just returns a brush # containing a flat color, where sometimes the style # would have a nice subtle gradient or something. # Here we just use the brush of the painter object that's # passed in to us, which keeps the row highlighting nice # and consistent. painter . fillRect ( option . rect , painter . brush ()) # Now that we've painted the background, call star_rating.paint() # to paint the stars. star_rating . paint ( painter , option . rect , option . palette ) def sizeHint ( self , option , index ): \"\"\"Return the size needed to display the item in a QSize object.\"\"\" star_rating = StarRating ( index . data ()) return star_rating . sizeHint () # The next 4 methods handle the custom editing that we need to do. # If this were just a display delegate, paint() and sizeHint() would # be all we needed. def createEditor ( self , parent , option , index ): \"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\" editor = StarEditor ( parent ) editor . editing_finished . connect ( self . commitAndCloseEditor ) return editor def setEditorData ( self , editor , index ): \"\"\"Set the data to be displayed and edited by our custom editor.\"\"\" editor . set_star_rating ( index . data ()) def setModelData ( self , editor , model , index ): \"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\" model . setData ( index , editor . star_rating . star_count ) def commitAndCloseEditor ( self ): editor = self . sender () # The commitData signal must be emitted when we've finished editing # and need to write our changed back to the model. self . commitData . emit ( editor ) self . closeEditor . emit ( editor , self . NoHint ) createEditor ( self , parent , option , index ) Create and return the StarEditor object we'll use to edit the StarRating. Source code in prettyqt/custom_delegates/stardelegate.py def createEditor ( self , parent , option , index ): \"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\" editor = StarEditor ( parent ) editor . editing_finished . connect ( self . commitAndCloseEditor ) return editor paint ( self , painter , option , index ) paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter , option , index ): star_rating = StarRating ( index . data ()) # If the row is currently selected, we need to make sure we # paint the background accordingly. if option . state & widgets . Style . StateFlag . State_Selected : # The original C++ example used option.palette.foreground() to # get the brush for painting, but there are a couple of # problems with that: # - foreground() is obsolete now, use windowText() instead # - more importantly, windowText() just returns a brush # containing a flat color, where sometimes the style # would have a nice subtle gradient or something. # Here we just use the brush of the painter object that's # passed in to us, which keeps the row highlighting nice # and consistent. painter . fillRect ( option . rect , painter . brush ()) # Now that we've painted the background, call star_rating.paint() # to paint the stars. star_rating . paint ( painter , option . rect , option . palette ) setEditorData ( self , editor , index ) Set the data to be displayed and edited by our custom editor. Source code in prettyqt/custom_delegates/stardelegate.py def setEditorData ( self , editor , index ): \"\"\"Set the data to be displayed and edited by our custom editor.\"\"\" editor . set_star_rating ( index . data ()) setModelData ( self , editor , model , index ) Get the data from our custom editor and stuffs it into the model. Source code in prettyqt/custom_delegates/stardelegate.py def setModelData ( self , editor , model , index ): \"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\" model . setData ( index , editor . star_rating . star_count ) sizeHint ( self , option , index ) Return the size needed to display the item in a QSize object. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self , option , index ): \"\"\"Return the size needed to display the item in a QSize object.\"\"\" star_rating = StarRating ( index . data ()) return star_rating . sizeHint () StarEditor ( Widget ) Source code in prettyqt/custom_delegates/stardelegate.py class StarEditor ( widgets . Widget ): \"\"\"The custom editor for editing StarRatings.\"\"\" # A signal to tell the delegate when we've finished editing. editing_finished = core . Signal () def __init__ ( self , parent : QtWidgets . QWidget | None = None ): \"\"\"Initialize the editor object, making sure we can watch mouse events.\"\"\" super () . __init__ ( parent ) self . setMouseTracking ( True ) self . setAutoFillBackground ( True ) self . star_rating = StarRating () def sizeHint ( self ): \"\"\"Tell the caller how big we are.\"\"\" return self . star_rating . sizeHint () def paintEvent ( self , event ): \"\"\"Paint the editor, offloading the work to the StarRating class.\"\"\" painter = gui . Painter ( self ) self . star_rating . paint ( painter , self . rect (), self . palette (), is_editable = True ) def mouseMoveEvent ( self , event ): \"\"\"Update stars on mouse move.\"\"\" star = self . star_at_position ( event . x ()) if star != - 1 : self . star_rating . star_count = star self . update () def mouseReleaseEvent ( self , event ): \"\"\"Once star rating was clicked, tell the delegate we're done editing.\"\"\" self . editing_finished . emit () def star_at_position ( self , x : int ) -> int : \"\"\"Calculate which star the user's mouse cursor is currently hovering over.\"\"\" val = x // ( self . star_rating . sizeHint () . width () // self . star_rating . max_stars ) + 1 if not 0 < val <= self . star_rating . max_stars : return - 1 return val def set_star_rating ( self , rating : int ): self . star_rating . star_count = rating __init__ ( self , parent : QtWidgets . QWidget | None = None ) special Initialize the editor object, making sure we can watch mouse events. Source code in prettyqt/custom_delegates/stardelegate.py def __init__ ( self , parent : QtWidgets . QWidget | None = None ): \"\"\"Initialize the editor object, making sure we can watch mouse events.\"\"\" super () . __init__ ( parent ) self . setMouseTracking ( True ) self . setAutoFillBackground ( True ) self . star_rating = StarRating () mouseMoveEvent ( self , event ) Update stars on mouse move. Source code in prettyqt/custom_delegates/stardelegate.py def mouseMoveEvent ( self , event ): \"\"\"Update stars on mouse move.\"\"\" star = self . star_at_position ( event . x ()) if star != - 1 : self . star_rating . star_count = star self . update () mouseReleaseEvent ( self , event ) Once star rating was clicked, tell the delegate we're done editing. Source code in prettyqt/custom_delegates/stardelegate.py def mouseReleaseEvent ( self , event ): \"\"\"Once star rating was clicked, tell the delegate we're done editing.\"\"\" self . editing_finished . emit () paintEvent ( self , event ) Paint the editor, offloading the work to the StarRating class. Source code in prettyqt/custom_delegates/stardelegate.py def paintEvent ( self , event ): \"\"\"Paint the editor, offloading the work to the StarRating class.\"\"\" painter = gui . Painter ( self ) self . star_rating . paint ( painter , self . rect (), self . palette (), is_editable = True ) sizeHint ( self ) Tell the caller how big we are. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self ): \"\"\"Tell the caller how big we are.\"\"\" return self . star_rating . sizeHint () star_at_position ( self , x : int ) -> int Calculate which star the user's mouse cursor is currently hovering over. Source code in prettyqt/custom_delegates/stardelegate.py def star_at_position ( self , x : int ) -> int : \"\"\"Calculate which star the user's mouse cursor is currently hovering over.\"\"\" val = x // ( self . star_rating . sizeHint () . width () // self . star_rating . max_stars ) + 1 if not 0 < val <= self . star_rating . max_stars : return - 1 return val StarRating Handle the actual painting of the stars themselves. Source code in prettyqt/custom_delegates/stardelegate.py class StarRating : \"\"\"Handle the actual painting of the stars themselves.\"\"\" def __init__ ( self , star_count : int = 1 , max_stars : int = 5 ): self . star_count = star_count self . max_stars = max_stars def sizeHint ( self ): return PAINTING_SCALE_FACTOR * core . Size ( self . max_stars , 1 ) def paint ( self , painter : QtGui . QPainter , rect : QtCore . QRect , palette : QtGui . QPalette , is_editable : bool = False , ): \"\"\"Paint the stars (and/or diamonds if we're in editing mode).\"\"\" painter . save () painter . setRenderHint ( painter . RenderHint . Antialiasing , True ) painter . setPen ( QtCore . Qt . PenStyle . NoPen ) painter . setBrush ( palette . highlight () if is_editable else palette . windowText ()) y_offset = ( rect . height () - PAINTING_SCALE_FACTOR ) / 2 painter . translate ( rect . x (), rect . y () + y_offset ) painter . scale ( PAINTING_SCALE_FACTOR , PAINTING_SCALE_FACTOR ) for i in range ( self . max_stars ): if i < self . star_count : painter . drawPolygon ( STAR_POLYGON , QtCore . Qt . FillRule . WindingFill ) elif is_editable : painter . drawPolygon ( DIAMOND_POLYGON , QtCore . Qt . FillRule . WindingFill ) else : break painter . translate ( 1.0 , 0.0 ) painter . restore () paint ( self , painter : QtGui . QPainter , rect : QtCore . QRect , palette : QtGui . QPalette , is_editable : bool = False ) Paint the stars (and/or diamonds if we're in editing mode). Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter : QtGui . QPainter , rect : QtCore . QRect , palette : QtGui . QPalette , is_editable : bool = False , ): \"\"\"Paint the stars (and/or diamonds if we're in editing mode).\"\"\" painter . save () painter . setRenderHint ( painter . RenderHint . Antialiasing , True ) painter . setPen ( QtCore . Qt . PenStyle . NoPen ) painter . setBrush ( palette . highlight () if is_editable else palette . windowText ()) y_offset = ( rect . height () - PAINTING_SCALE_FACTOR ) / 2 painter . translate ( rect . x (), rect . y () + y_offset ) painter . scale ( PAINTING_SCALE_FACTOR , PAINTING_SCALE_FACTOR ) for i in range ( self . max_stars ): if i < self . star_count : painter . drawPolygon ( STAR_POLYGON , QtCore . Qt . FillRule . WindingFill ) elif is_editable : painter . drawPolygon ( DIAMOND_POLYGON , QtCore . Qt . FillRule . WindingFill ) else : break painter . translate ( 1.0 , 0.0 ) painter . restore ()","title":"custom_delegates"},{"location":"api/custom_delegates.html#custom_delegates-module","text":"Module containing custom delegate classes.","title":"custom_delegates module"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate","text":"","title":"buttondelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate","text":"Source code in prettyqt/custom_delegates/buttondelegate.py class ButtonDelegate ( widgets . ItemDelegate ): def __init__ ( self , parent : QtWidgets . QWidget | None , role = QtCore . Qt . ItemDataRole . UserRole ): super () . __init__ ( parent ) self . fn_role = role def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn def setEditorData ( self , editor , index ): pass def setModelData ( self , editor , model , index ): pass @core . Slot () def currentIndexChanged ( self ): self . commitData . emit ( self . sender ())","title":"ButtonDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.createEditor","text":"createEditor(self, parent: PySide6.QtWidgets.QWidget, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtWidgets.QWidget Source code in prettyqt/custom_delegates/buttondelegate.py def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setEditorData","text":"setEditorData(self, editor: PySide6.QtWidgets.QWidget, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/buttondelegate.py def setEditorData ( self , editor , index ): pass","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setModelData","text":"setModelData(self, editor: PySide6.QtWidgets.QWidget, model: PySide6.QtCore.QAbstractItemModel, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/buttondelegate.py def setModelData ( self , editor , model , index ): pass","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate","text":"","title":"checkboxdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate","text":"Source code in prettyqt/custom_delegates/checkboxdelegate.py class CheckBoxDelegate ( widgets . ItemDelegate ): \"\"\"Delegate that places a CheckBox in every cell.\"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . selected = [] def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection ) @core . Slot () def currentIndexChanged ( self ): self . commitData . emit ( self . sender ())","title":"CheckBoxDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.createEditor","text":"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. Source code in prettyqt/custom_delegates/checkboxdelegate.py def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.setEditorData","text":"Override. set correct initial value for editor widget Source code in prettyqt/custom_delegates/checkboxdelegate.py def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection )","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate","text":"","title":"icondelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate","text":"Source code in prettyqt/custom_delegates/icondelegate.py class IconDelegate ( widgets . StyledItemDelegate ): def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if not value : return margin = 10 mode = gui . Icon . Mode . Normal if not ( option . state & widgets . Style . StateFlag . State_Enabled ): mode = gui . Icon . Mode . Disabled elif option . state & widgets . Style . StateFlag . State_Selected : mode = gui . Icon . Mode . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = int ( value . size () / value . devicePixelRatio ()) elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = int ( value . size () / value . devicePixelRatio ()) elif isinstance ( value , QtGui . QIcon ): is_on = option . state & widgets . Style . StateFlag . State_Open state = gui . Icon . State . On if is_on else gui . Icon . State . Off actual_size = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = option . decorationSize & actual_size r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = ( gui . Icon . State . On if option . state & widgets . Style . StateFlag . State_Open else gui . Icon . State . Off ) alignment = constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER # type: ignore icon . paint ( painter , r , alignment , mode , state )","title":"IconDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate.paint","text":"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000' Parameters: Name Type Description Default painter QtGui.QPainter painter to paint the icon required option QtWidgets.QStyleOptionViewItem state of the item to be displayed required index QtCore.QModelIndex index which gets decorated required Source code in prettyqt/custom_delegates/icondelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if not value : return margin = 10 mode = gui . Icon . Mode . Normal if not ( option . state & widgets . Style . StateFlag . State_Enabled ): mode = gui . Icon . Mode . Disabled elif option . state & widgets . Style . StateFlag . State_Selected : mode = gui . Icon . Mode . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = int ( value . size () / value . devicePixelRatio ()) elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = int ( value . size () / value . devicePixelRatio ()) elif isinstance ( value , QtGui . QIcon ): is_on = option . state & widgets . Style . StateFlag . State_Open state = gui . Icon . State . On if is_on else gui . Icon . State . Off actual_size = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = option . decorationSize & actual_size r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = ( gui . Icon . State . On if option . state & widgets . Style . StateFlag . State_Open else gui . Icon . State . Off ) alignment = constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER # type: ignore icon . paint ( painter , r , alignment , mode , state )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate","text":"","title":"nofocusdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate","text":"Source code in prettyqt/custom_delegates/nofocusdelegate.py class NoFocusDelegate ( widgets . StyledItemDelegate ): def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . StateFlag . State_HasFocus : option . state = option . state ^ widgets . Style . StateFlag . State_HasFocus super () . paint ( painter , option , index )","title":"NoFocusDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate.paint","text":"paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/nofocusdelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . StateFlag . State_HasFocus : option . state = option . state ^ widgets . Style . StateFlag . State_HasFocus super () . paint ( painter , option , index )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate","text":"","title":"progressbardelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate.ProgressBarDelegate","text":"Source code in prettyqt/custom_delegates/progressbardelegate.py class ProgressBarDelegate ( widgets . StyledItemDelegate ): def paint ( self , painter , option , index ): progress = index . data () opt = widgets . StyleOptionProgressBar () opt . rect = option . rect opt . minimum = 0 opt . maximum = 100 opt . progress = progress opt . text = f \" { progress } %\" opt . textVisible = True opt . state |= widgets . Style . StateFlag . State_Horizontal widgets . Application . style () . drawControl ( widgets . Style . ControlElement . CE_ProgressBar , opt , painter )","title":"ProgressBarDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate.ProgressBarDelegate.paint","text":"paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/progressbardelegate.py def paint ( self , painter , option , index ): progress = index . data () opt = widgets . StyleOptionProgressBar () opt . rect = option . rect opt . minimum = 0 opt . maximum = 100 opt . progress = progress opt . text = f \" { progress } %\" opt . textVisible = True opt . state |= widgets . Style . StateFlag . State_Horizontal widgets . Application . style () . drawControl ( widgets . Style . ControlElement . CE_ProgressBar , opt , painter )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate","text":"","title":"radiodelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate","text":"Source code in prettyqt/custom_delegates/radiodelegate.py class RadioDelegate ( widgets . StyledItemDelegate ): def __init__ ( self , parent : QtWidgets . QWidget , items : list [ str ]): super () . __init__ ( parent ) self . items = items self . choices : list [ int | None ] = [ None for i in self . items ] def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ) -> widgets . Widget : editor = widgets . Widget ( parent ) editor . set_margin ( 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . button_group = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . set_margin ( 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . set_focus_policy ( \"none\" ) rb . installEventFilter ( self ) editor . button_group . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) # type: ignore editor . installEventFilter ( self ) return editor def eventFilter ( self , source : QtWidgets . QWidget , event : QtCore . QEvent ) -> bool : if event . type () == core . Event . Type . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . Type . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . Type . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( b \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event ) def updateEditorGeometry ( self , editor : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): rect = core . Rect ( option . rect ) min_width = editor . minimumSizeHint () . width () if rect . width () < min_width : rect . setWidth ( min_width ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) # type: ignore editor . setMask ( mask ) def setEditorData ( self , editor : QtWidgets . QWidget , index : QtCore . QModelIndex ): value = index . data ( constants . DISPLAY_ROLE ) # type: ignore if value in self . items : editor . button_group . button ( self . items . index ( value )) . setChecked ( True ) def setModelData ( self , editor : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , index : QtCore . QModelIndex , ): button = editor . button_group . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], constants . DISPLAY_ROLE # type: ignore ) self . choices [ button ] = index . row ()","title":"RadioDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.createEditor","text":"createEditor(self, parent: PySide6.QtWidgets.QWidget, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtWidgets.QWidget Source code in prettyqt/custom_delegates/radiodelegate.py def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ) -> widgets . Widget : editor = widgets . Widget ( parent ) editor . set_margin ( 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . button_group = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . set_margin ( 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . set_focus_policy ( \"none\" ) rb . installEventFilter ( self ) editor . button_group . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) # type: ignore editor . installEventFilter ( self ) return editor","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.eventFilter","text":"eventFilter(self, object: PySide6.QtCore.QObject, event: PySide6.QtCore.QEvent) -> bool Source code in prettyqt/custom_delegates/radiodelegate.py def eventFilter ( self , source : QtWidgets . QWidget , event : QtCore . QEvent ) -> bool : if event . type () == core . Event . Type . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . Type . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . Type . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( b \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event )","title":"eventFilter()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setEditorData","text":"setEditorData(self, editor: PySide6.QtWidgets.QWidget, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/radiodelegate.py def setEditorData ( self , editor : QtWidgets . QWidget , index : QtCore . QModelIndex ): value = index . data ( constants . DISPLAY_ROLE ) # type: ignore if value in self . items : editor . button_group . button ( self . items . index ( value )) . setChecked ( True )","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setModelData","text":"setModelData(self, editor: PySide6.QtWidgets.QWidget, model: PySide6.QtCore.QAbstractItemModel, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/radiodelegate.py def setModelData ( self , editor : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , index : QtCore . QModelIndex , ): button = editor . button_group . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], constants . DISPLAY_ROLE # type: ignore ) self . choices [ button ] = index . row ()","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.updateEditorGeometry","text":"updateEditorGeometry(self, editor: PySide6.QtWidgets.QWidget, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/radiodelegate.py def updateEditorGeometry ( self , editor : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): rect = core . Rect ( option . rect ) min_width = editor . minimumSizeHint () . width () if rect . width () < min_width : rect . setWidth ( min_width ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) # type: ignore editor . setMask ( mask )","title":"updateEditorGeometry()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate","text":"","title":"renderlinkdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate.RenderLinkDelegate","text":"Source code in prettyqt/custom_delegates/renderlinkdelegate.py class RenderLinkDelegate ( widgets . StyledItemDelegate ): def paint ( self , painter , option , index ): text = index . data () if not text : return painter . save () # I only wanted it for mouse over, but you'll probably want to remove # this condition if option . state and widgets . Style . StateFlag . State_MouseOver : font = option . font font . setUnderline ( True ) painter . setFont ( font ) painter . setPen ( option . palette . link () . color ()) painter . drawText ( option . rect , constants . ALIGN_LEFT | constants . ALIGN_V_CENTER , # type: ignore ) painter . restore () def editorEvent ( self , event , model , option , index ): text = index . data () font = index . data ( constants . FONT_ROLE ) # alignment = index.data(constants.ALIGNMENT_ROLE) if font is None : font = gui . GuiApplication . get_font () fm = gui . FontMetricsF ( font ) rect = fm . get_bounding_rect ( core . RectF ( option . rect ), constants . ALIGN_LEFT | constants . ALIGN_V_CENTER , # type: ignore text , ) if ( event . type () == QtCore . QEvent . Type . MouseButtonPress and event . button () == QtCore . Qt . MouseButton . LeftButton and event . localPos () in rect ): text = index . data () gui . DesktopServices . open_url ( text ) return True return False","title":"RenderLinkDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate.RenderLinkDelegate.editorEvent","text":"editorEvent(self, event: PySide6.QtCore.QEvent, model: PySide6.QtCore.QAbstractItemModel, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> bool Source code in prettyqt/custom_delegates/renderlinkdelegate.py def editorEvent ( self , event , model , option , index ): text = index . data () font = index . data ( constants . FONT_ROLE ) # alignment = index.data(constants.ALIGNMENT_ROLE) if font is None : font = gui . GuiApplication . get_font () fm = gui . FontMetricsF ( font ) rect = fm . get_bounding_rect ( core . RectF ( option . rect ), constants . ALIGN_LEFT | constants . ALIGN_V_CENTER , # type: ignore text , ) if ( event . type () == QtCore . QEvent . Type . MouseButtonPress and event . button () == QtCore . Qt . MouseButton . LeftButton and event . localPos () in rect ): text = index . data () gui . DesktopServices . open_url ( text ) return True return False","title":"editorEvent()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate.RenderLinkDelegate.paint","text":"paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/renderlinkdelegate.py def paint ( self , painter , option , index ): text = index . data () if not text : return painter . save () # I only wanted it for mouse over, but you'll probably want to remove # this condition if option . state and widgets . Style . StateFlag . State_MouseOver : font = option . font font . setUnderline ( True ) painter . setFont ( font ) painter . setPen ( option . palette . link () . color ()) painter . drawText ( option . rect , constants . ALIGN_LEFT | constants . ALIGN_V_CENTER , # type: ignore ) painter . restore ()","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate","text":"","title":"stardelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate","text":"Source code in prettyqt/custom_delegates/stardelegate.py class StarDelegate ( widgets . StyledItemDelegate ): \"\"\"A delegate class that allows us to render our star ratings.\"\"\" def paint ( self , painter , option , index ): star_rating = StarRating ( index . data ()) # If the row is currently selected, we need to make sure we # paint the background accordingly. if option . state & widgets . Style . StateFlag . State_Selected : # The original C++ example used option.palette.foreground() to # get the brush for painting, but there are a couple of # problems with that: # - foreground() is obsolete now, use windowText() instead # - more importantly, windowText() just returns a brush # containing a flat color, where sometimes the style # would have a nice subtle gradient or something. # Here we just use the brush of the painter object that's # passed in to us, which keeps the row highlighting nice # and consistent. painter . fillRect ( option . rect , painter . brush ()) # Now that we've painted the background, call star_rating.paint() # to paint the stars. star_rating . paint ( painter , option . rect , option . palette ) def sizeHint ( self , option , index ): \"\"\"Return the size needed to display the item in a QSize object.\"\"\" star_rating = StarRating ( index . data ()) return star_rating . sizeHint () # The next 4 methods handle the custom editing that we need to do. # If this were just a display delegate, paint() and sizeHint() would # be all we needed. def createEditor ( self , parent , option , index ): \"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\" editor = StarEditor ( parent ) editor . editing_finished . connect ( self . commitAndCloseEditor ) return editor def setEditorData ( self , editor , index ): \"\"\"Set the data to be displayed and edited by our custom editor.\"\"\" editor . set_star_rating ( index . data ()) def setModelData ( self , editor , model , index ): \"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\" model . setData ( index , editor . star_rating . star_count ) def commitAndCloseEditor ( self ): editor = self . sender () # The commitData signal must be emitted when we've finished editing # and need to write our changed back to the model. self . commitData . emit ( editor ) self . closeEditor . emit ( editor , self . NoHint )","title":"StarDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.createEditor","text":"Create and return the StarEditor object we'll use to edit the StarRating. Source code in prettyqt/custom_delegates/stardelegate.py def createEditor ( self , parent , option , index ): \"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\" editor = StarEditor ( parent ) editor . editing_finished . connect ( self . commitAndCloseEditor ) return editor","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.paint","text":"paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> None Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter , option , index ): star_rating = StarRating ( index . data ()) # If the row is currently selected, we need to make sure we # paint the background accordingly. if option . state & widgets . Style . StateFlag . State_Selected : # The original C++ example used option.palette.foreground() to # get the brush for painting, but there are a couple of # problems with that: # - foreground() is obsolete now, use windowText() instead # - more importantly, windowText() just returns a brush # containing a flat color, where sometimes the style # would have a nice subtle gradient or something. # Here we just use the brush of the painter object that's # passed in to us, which keeps the row highlighting nice # and consistent. painter . fillRect ( option . rect , painter . brush ()) # Now that we've painted the background, call star_rating.paint() # to paint the stars. star_rating . paint ( painter , option . rect , option . palette )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setEditorData","text":"Set the data to be displayed and edited by our custom editor. Source code in prettyqt/custom_delegates/stardelegate.py def setEditorData ( self , editor , index ): \"\"\"Set the data to be displayed and edited by our custom editor.\"\"\" editor . set_star_rating ( index . data ())","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setModelData","text":"Get the data from our custom editor and stuffs it into the model. Source code in prettyqt/custom_delegates/stardelegate.py def setModelData ( self , editor , model , index ): \"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\" model . setData ( index , editor . star_rating . star_count )","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.sizeHint","text":"Return the size needed to display the item in a QSize object. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self , option , index ): \"\"\"Return the size needed to display the item in a QSize object.\"\"\" star_rating = StarRating ( index . data ()) return star_rating . sizeHint ()","title":"sizeHint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor","text":"Source code in prettyqt/custom_delegates/stardelegate.py class StarEditor ( widgets . Widget ): \"\"\"The custom editor for editing StarRatings.\"\"\" # A signal to tell the delegate when we've finished editing. editing_finished = core . Signal () def __init__ ( self , parent : QtWidgets . QWidget | None = None ): \"\"\"Initialize the editor object, making sure we can watch mouse events.\"\"\" super () . __init__ ( parent ) self . setMouseTracking ( True ) self . setAutoFillBackground ( True ) self . star_rating = StarRating () def sizeHint ( self ): \"\"\"Tell the caller how big we are.\"\"\" return self . star_rating . sizeHint () def paintEvent ( self , event ): \"\"\"Paint the editor, offloading the work to the StarRating class.\"\"\" painter = gui . Painter ( self ) self . star_rating . paint ( painter , self . rect (), self . palette (), is_editable = True ) def mouseMoveEvent ( self , event ): \"\"\"Update stars on mouse move.\"\"\" star = self . star_at_position ( event . x ()) if star != - 1 : self . star_rating . star_count = star self . update () def mouseReleaseEvent ( self , event ): \"\"\"Once star rating was clicked, tell the delegate we're done editing.\"\"\" self . editing_finished . emit () def star_at_position ( self , x : int ) -> int : \"\"\"Calculate which star the user's mouse cursor is currently hovering over.\"\"\" val = x // ( self . star_rating . sizeHint () . width () // self . star_rating . max_stars ) + 1 if not 0 < val <= self . star_rating . max_stars : return - 1 return val def set_star_rating ( self , rating : int ): self . star_rating . star_count = rating","title":"StarEditor"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.__init__","text":"Initialize the editor object, making sure we can watch mouse events. Source code in prettyqt/custom_delegates/stardelegate.py def __init__ ( self , parent : QtWidgets . QWidget | None = None ): \"\"\"Initialize the editor object, making sure we can watch mouse events.\"\"\" super () . __init__ ( parent ) self . setMouseTracking ( True ) self . setAutoFillBackground ( True ) self . star_rating = StarRating ()","title":"__init__()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.mouseMoveEvent","text":"Update stars on mouse move. Source code in prettyqt/custom_delegates/stardelegate.py def mouseMoveEvent ( self , event ): \"\"\"Update stars on mouse move.\"\"\" star = self . star_at_position ( event . x ()) if star != - 1 : self . star_rating . star_count = star self . update ()","title":"mouseMoveEvent()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.mouseReleaseEvent","text":"Once star rating was clicked, tell the delegate we're done editing. Source code in prettyqt/custom_delegates/stardelegate.py def mouseReleaseEvent ( self , event ): \"\"\"Once star rating was clicked, tell the delegate we're done editing.\"\"\" self . editing_finished . emit ()","title":"mouseReleaseEvent()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.paintEvent","text":"Paint the editor, offloading the work to the StarRating class. Source code in prettyqt/custom_delegates/stardelegate.py def paintEvent ( self , event ): \"\"\"Paint the editor, offloading the work to the StarRating class.\"\"\" painter = gui . Painter ( self ) self . star_rating . paint ( painter , self . rect (), self . palette (), is_editable = True )","title":"paintEvent()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.sizeHint","text":"Tell the caller how big we are. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self ): \"\"\"Tell the caller how big we are.\"\"\" return self . star_rating . sizeHint ()","title":"sizeHint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.star_at_position","text":"Calculate which star the user's mouse cursor is currently hovering over. Source code in prettyqt/custom_delegates/stardelegate.py def star_at_position ( self , x : int ) -> int : \"\"\"Calculate which star the user's mouse cursor is currently hovering over.\"\"\" val = x // ( self . star_rating . sizeHint () . width () // self . star_rating . max_stars ) + 1 if not 0 < val <= self . star_rating . max_stars : return - 1 return val","title":"star_at_position()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarRating","text":"Handle the actual painting of the stars themselves. Source code in prettyqt/custom_delegates/stardelegate.py class StarRating : \"\"\"Handle the actual painting of the stars themselves.\"\"\" def __init__ ( self , star_count : int = 1 , max_stars : int = 5 ): self . star_count = star_count self . max_stars = max_stars def sizeHint ( self ): return PAINTING_SCALE_FACTOR * core . Size ( self . max_stars , 1 ) def paint ( self , painter : QtGui . QPainter , rect : QtCore . QRect , palette : QtGui . QPalette , is_editable : bool = False , ): \"\"\"Paint the stars (and/or diamonds if we're in editing mode).\"\"\" painter . save () painter . setRenderHint ( painter . RenderHint . Antialiasing , True ) painter . setPen ( QtCore . Qt . PenStyle . NoPen ) painter . setBrush ( palette . highlight () if is_editable else palette . windowText ()) y_offset = ( rect . height () - PAINTING_SCALE_FACTOR ) / 2 painter . translate ( rect . x (), rect . y () + y_offset ) painter . scale ( PAINTING_SCALE_FACTOR , PAINTING_SCALE_FACTOR ) for i in range ( self . max_stars ): if i < self . star_count : painter . drawPolygon ( STAR_POLYGON , QtCore . Qt . FillRule . WindingFill ) elif is_editable : painter . drawPolygon ( DIAMOND_POLYGON , QtCore . Qt . FillRule . WindingFill ) else : break painter . translate ( 1.0 , 0.0 ) painter . restore ()","title":"StarRating"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarRating.paint","text":"Paint the stars (and/or diamonds if we're in editing mode). Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter : QtGui . QPainter , rect : QtCore . QRect , palette : QtGui . QPalette , is_editable : bool = False , ): \"\"\"Paint the stars (and/or diamonds if we're in editing mode).\"\"\" painter . save () painter . setRenderHint ( painter . RenderHint . Antialiasing , True ) painter . setPen ( QtCore . Qt . PenStyle . NoPen ) painter . setBrush ( palette . highlight () if is_editable else palette . windowText ()) y_offset = ( rect . height () - PAINTING_SCALE_FACTOR ) / 2 painter . translate ( rect . x (), rect . y () + y_offset ) painter . scale ( PAINTING_SCALE_FACTOR , PAINTING_SCALE_FACTOR ) for i in range ( self . max_stars ): if i < self . star_count : painter . drawPolygon ( STAR_POLYGON , QtCore . Qt . FillRule . WindingFill ) elif is_editable : painter . drawPolygon ( DIAMOND_POLYGON , QtCore . Qt . FillRule . WindingFill ) else : break painter . translate ( 1.0 , 0.0 ) painter . restore ()","title":"paint()"},{"location":"api/custom_models.html","text":"custom_models module Custom_models module. Contains custom models baselistmixin BaseListMixin Source code in prettyqt/custom_models/baselistmixin.py class BaseListMixin : remove_rows : Callable SORT_METHODS : dict [ int , Callable ] change_layout : Callable insert_rows : Callable removeRow : Callable def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . items = [] def setData ( self , index , value , role ): if role == self . DATA_ROLE : self . items [ index . row ()] = value self . update_row ( index . row ()) return True return super () . setData ( index , value , role ) def removeRows ( self , row : int , count : int , parent ): end_row = row + count - 1 with self . remove_rows ( row , end_row , parent ): for i in range ( end_row , row - 1 , - 1 ): self . items . pop ( i ) return True def rowCount ( self , parent = None ): \"\"\"Returns number of rows. required override for AbstractitemModels \"\"\" return len ( self . items ) def data_by_index ( self , index ): return self . items [ index . row ()] def dropMimeData ( self , mime_data , action , row , column , parent_index ): if not mime_data . hasFormat ( self . MIME_TYPE ): return False # Since we only drop in between items, parent_index must be invalid, # and we use the row arg to know where the drop took place. if parent_index . isValid (): return False indexes = mime_data . get_json_data ( self . MIME_TYPE ) pos = row if row < len ( self . items ) and row != - 1 else len ( self . items ) rem_offset = sum ( i <= pos for i in indexes ) new = [ self . items [ i ] for i in indexes ] with self . change_layout (): for i in sorted ( indexes , reverse = True ): self . items . pop ( i ) for item in reversed ( new ): self . items . insert ( pos - rem_offset , item ) return False def sort ( self , ncol : int , order ): \"\"\"Sorts table by given column number.\"\"\" is_asc = order == constants . ASCENDING sorter = self . SORT_METHODS . get ( ncol ) if sorter : with self . change_layout (): self . items . sort ( key = sorter , reverse = is_asc ) def add ( self , item : Any , position : int | None = None ): \"\"\"Appends provided item to the list.\"\"\" self . add_items ( items = [ item ], position = position ) return item def add_items ( self , items : Iterable [ Any ], position : int | None = None ): \"\"\"Appends a list of items to the list.\"\"\" if position is None : position = len ( self . items ) items = list ( items ) with self . insert_rows ( position , position + len ( items ) - 1 ): for i in range ( len ( items )): self . items . insert ( i + position , items [ i ]) # self.items.extend(items) return items def remove_items ( self , offsets : Iterable [ int ]): for offset in sorted ( offsets , reverse = True ): self . removeRow ( offset ) add ( self , item : Any , position : int | None = None ) Appends provided item to the list. Source code in prettyqt/custom_models/baselistmixin.py def add ( self , item : Any , position : int | None = None ): \"\"\"Appends provided item to the list.\"\"\" self . add_items ( items = [ item ], position = position ) return item add_items ( self , items : Iterable [ Any ], position : int | None = None ) Appends a list of items to the list. Source code in prettyqt/custom_models/baselistmixin.py def add_items ( self , items : Iterable [ Any ], position : int | None = None ): \"\"\"Appends a list of items to the list.\"\"\" if position is None : position = len ( self . items ) items = list ( items ) with self . insert_rows ( position , position + len ( items ) - 1 ): for i in range ( len ( items )): self . items . insert ( i + position , items [ i ]) # self.items.extend(items) return items rowCount ( self , parent = None ) Returns number of rows. required override for AbstractitemModels Source code in prettyqt/custom_models/baselistmixin.py def rowCount ( self , parent = None ): \"\"\"Returns number of rows. required override for AbstractitemModels \"\"\" return len ( self . items ) sort ( self , ncol : int , order ) Sorts table by given column number. Source code in prettyqt/custom_models/baselistmixin.py def sort ( self , ncol : int , order ): \"\"\"Sorts table by given column number.\"\"\" is_asc = order == constants . ASCENDING sorter = self . SORT_METHODS . get ( ncol ) if sorter : with self . change_layout (): self . items . sort ( key = sorter , reverse = is_asc ) basemodelmixin BaseModelMixin Source code in prettyqt/custom_models/basemodelmixin.py class BaseModelMixin : DATA_ROLE = constants . USER_ROLE DTYPE_ROLE = constants . USER_ROLE + 1 NAME_ROLE = constants . USER_ROLE + 2 SORT_ROLE = constants . USER_ROLE + 3 MAX_ROWS = 1_000_000 HEADER = [ \"Name\" ] DEFAULT_FLAGS = ( constants . DRAG_ENABLED | constants . IS_ENABLED | constants . IS_SELECTABLE | constants . NO_CHILDREN ) LABELS : dict = dict () CHECKSTATE : dict = dict () TOOLTIPS : dict = dict () DECORATIONS : dict = dict () SET_DATA : dict = dict () content_type = \"\" data_by_index : Callable def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] def columnCount ( self , parent = None ): return len ( self . HEADER ) def flags ( self , index ): \"\"\"Returns corresponding flags for cell of supplied index. required override for AbstractitemModels \"\"\" if not index . isValid (): return constants . DROP_ENABLED if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None item = self . data_by_index ( index ) if role == constants . DECORATION_ROLE : fn = self . DECORATIONS . get ( index . column ()) if fn : return fn ( item ) elif role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: fn = self . LABELS . get ( index . column ()) if fn : return fn ( item ) elif role == constants . TOOLTIP_ROLE : fn = self . TOOLTIPS . get ( index . column ()) if fn : return fn ( item ) elif role == constants . CHECKSTATE_ROLE : fn = self . CHECKSTATE . get ( index . column ()) if fn : return fn ( item ) elif role == self . DATA_ROLE : return item return None def setData ( self , index , value , role ): if role == constants . EDIT_ROLE : if not value : return False item = self . data_by_index ( index ) fn = self . SET_DATA . get ( index . column ()) if fn : fn ( item , value ) self . update_row ( index . row ()) return True flags ( self , index ) Returns corresponding flags for cell of supplied index. required override for AbstractitemModels Source code in prettyqt/custom_models/basemodelmixin.py def flags ( self , index ): \"\"\"Returns corresponding flags for cell of supplied index. required override for AbstractitemModels \"\"\" if not index . isValid (): return constants . DROP_ENABLED if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS columnitemmodel ColumnItem dataclass Determines how an object attribute is shown. Source code in prettyqt/custom_models/columnitemmodel.py @dataclass ( frozen = True ) class ColumnItem : \"\"\"Determines how an object attribute is shown.\"\"\" name : str label : Callable | None checkstate : Callable | None = None doc : str = \"<no help available>\" col_visible : bool = True width : int | str = SMALL_COL_WIDTH alignment : Callable | int | None = None line_wrap : gui . textoption . WordWrapModeStr = \"none\" foreground_color : Callable | str | None = None background_color : Callable | str | None = None decoration : Callable | QtGui . QIcon | None = None font : Callable | QtGui . QFont | None = None selectable : bool = True enabled : bool = True editable : bool = False checkable : bool = False tristate : bool = False def get_name ( self ) -> str : return self . name def get_flag ( self ): flag = constants . NO_FLAGS if self . selectable : flag |= constants . IS_SELECTABLE # type: ignore if self . enabled : flag |= constants . IS_ENABLED # type: ignore if self . editable : flag |= constants . IS_EDITABLE # type: ignore if self . checkable : flag |= constants . IS_CHECKABLE # type: ignore if self . tristate : flag |= constants . IS_USER_TRISTATE # type: ignore return flag def get_label ( self , tree_item ): if self . label is None : return \"\" elif callable ( self . label ): return self . label ( tree_item ) return self . label def get_checkstate ( self , tree_item ): if self . checkstate is None : return None elif callable ( self . checkstate ): return self . checkstate ( tree_item ) return self . checkstate def get_font ( self , tree_item ): if self . font is None : return None elif callable ( self . font ): return self . font ( tree_item ) return self . font def get_foreground_color ( self , tree_item ): if self . foreground_color is None : return None elif callable ( self . foreground_color ): return self . foreground_color ( tree_item ) return self . foreground_color def get_background_color ( self , tree_item ): if self . background_color is None : return None elif callable ( self . background_color ): return self . background_color ( tree_item ) return self . background_color def get_decoration ( self , tree_item ): if self . decoration is None : return None elif callable ( self . decoration ): return self . decoration ( tree_item ) return self . decoration def get_alignment ( self , tree_item ) -> int : if self . alignment is None : return constants . ALIGN_LEFT # type: ignore elif callable ( self . alignment ): return self . alignment ( tree_item ) elif isinstance ( self . alignment , str ): return constants . ALIGNMENTS [ self . alignment ] return self . alignment def get_width ( self ) -> int : if self . width == \"small\" : return SMALL_COL_WIDTH elif self . width == \"medium\" : return MEDIUM_COL_WIDTH elif isinstance ( self . width , int ): return self . width raise ValueError ( self . width ) ColumnItemModel ( AbstractItemModel ) Source code in prettyqt/custom_models/columnitemmodel.py class ColumnItemModel ( core . AbstractItemModel ): \"\"\"Model that provides an interface to an objectree that is build of TreeItems.\"\"\" def __init__ ( self , attr_cols : list [ ColumnItem ] | None = None , parent : QtCore . QObject | None = None , ): super () . __init__ ( parent ) self . _attr_cols = attr_cols if attr_cols is not None else [] def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols ) def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: val = self . _attr_cols [ col ] . get_label ( tree_item ) return val . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN col = index . column () return self . _attr_cols [ col ] . get_flag () def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None columnCount ( self , _parent = None ) Return the number of columns in the tree. Source code in prettyqt/custom_models/columnitemmodel.py def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols ) data ( self , index , role ) Return the tree item at the given index and role. Source code in prettyqt/custom_models/columnitemmodel.py def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: val = self . _attr_cols [ col ] . get_label ( tree_item ) return val . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None flags ( self , index ) flags(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.Qt.ItemFlag Source code in prettyqt/custom_models/columnitemmodel.py def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN col = index . column () return self . _attr_cols [ col ] . get_flag () headerData ( self , section , orientation , role ) headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/columnitemmodel.py def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None importlibdistributionmodel ImportlibDistributionModel ( AbstractTableModel ) Source code in prettyqt/custom_models/importlibdistributionmodel.py class ImportlibDistributionModel ( core . AbstractTableModel ): HEADER = [ \"Name\" , \"Version\" , \"Summary\" , \"Homepage\" , \"Author\" , \"License\" ] def __init__ ( self , distributions : Sequence [ metadata . Distribution ], parent : QtCore . QObject | None = None , ): super () . __init__ ( parent ) self . distributions = distributions def rowCount ( self , parent = core . ModelIndex ()): return len ( self . distributions ) if not parent . isValid () else 0 def columnCount ( self , parent = core . ModelIndex ()): return len ( self . HEADER ) if not parent . isValid () else 0 def headerData ( self , offset : int , orientation , role ): # type: ignore if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Name\" ] elif index . column () == 1 : dist = self . distributions [ index . row ()] return dist . version elif index . column () == 2 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Summary\" ] elif index . column () == 3 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Home-Page\" ] elif index . column () == 4 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Author\" ] elif index . column () == 5 : dist = self . distributions [ index . row ()] return dist . metadata [ \"License\" ] elif role == constants . USER_ROLE : dist = self . distributions [ index . row ()] return dist @classmethod def from_system ( cls , parent : QtCore . QObject | None = None ) -> ImportlibDistributionModel : distributions = list_system_modules () return cls ( distributions , parent ) @classmethod def from_package ( cls , package_name : str , parent : QtCore . QObject | None = None ) -> ImportlibDistributionModel : distributions = list_package_requirements ( package_name ) return cls ( distributions , parent ) columnCount ( self , parent = < PySide6 . QtCore . QModelIndex ( - 1 , - 1 , 0x0 , QObject ( 0x0 )) at 0x7f073733af80 > ) columnCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def columnCount ( self , parent = core . ModelIndex ()): return len ( self . HEADER ) if not parent . isValid () else 0 data ( self , index , role = < ItemDataRole . DisplayRole : 0 > ) data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Name\" ] elif index . column () == 1 : dist = self . distributions [ index . row ()] return dist . version elif index . column () == 2 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Summary\" ] elif index . column () == 3 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Home-Page\" ] elif index . column () == 4 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Author\" ] elif index . column () == 5 : dist = self . distributions [ index . row ()] return dist . metadata [ \"License\" ] elif role == constants . USER_ROLE : dist = self . distributions [ index . row ()] return dist headerData ( self , offset : int , orientation , role ) headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def headerData ( self , offset : int , orientation , role ): # type: ignore if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] rowCount ( self , parent = < PySide6 . QtCore . QModelIndex ( - 1 , - 1 , 0x0 , QObject ( 0x0 )) at 0x7f073733bfc0 > ) rowCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def rowCount ( self , parent = core . ModelIndex ()): return len ( self . distributions ) if not parent . isValid () else 0 jsonmodel JsonModel ( NestedModel ) Source code in prettyqt/custom_models/jsonmodel.py class JsonModel ( custom_models . NestedModel ): HEADER = [ \"Key\" , \"Value\" , \"Type\" ] def __init__ ( self , parent : QtCore . QObject | None = None ): super () . __init__ ( parent = parent ) self . root = JsonTreeItem () # type: ignore self . items = self . root . children def __repr__ ( self ): return str ( self . root . as_json ()) # type: ignore def load ( self , document ): \"\"\"Load from dictionary. Arguments: document (dict): JSON-compatible dictionary \"\"\" assert isinstance ( document , ( dict , list , tuple ) ), \"`document` must be of dict, list or tuple, \" \"not %s \" % type ( document ) with self . reset_model (): self . root = JsonTreeItem . load ( document ) self . root . type = type ( document ) # type: ignore self . items = self . root . children return True def data ( self , index , role ): if not index . isValid (): return None item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: if index . column () == 0 : return repr ( item . key ) elif index . column () == 1 : if item . type in ( dict , list , tuple ): return \"\" else : if role == constants . DISPLAY_ROLE : return repr ( item . value ) else : return item . value elif index . column () == 2 : return item . type . __name__ def setData ( self , index , value , role ): if role == constants . EDIT_ROLE : if index . column () == 1 : item = index . internalPointer () item . value = str ( value ) self . update_row ( index . row ()) return True return False data ( self , index , role ) data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/jsonmodel.py def data ( self , index , role ): if not index . isValid (): return None item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: if index . column () == 0 : return repr ( item . key ) elif index . column () == 1 : if item . type in ( dict , list , tuple ): return \"\" else : if role == constants . DISPLAY_ROLE : return repr ( item . value ) else : return item . value elif index . column () == 2 : return item . type . __name__ load ( self , document ) Load from dictionary. Parameters: Name Type Description Default document dict JSON-compatible dictionary required Source code in prettyqt/custom_models/jsonmodel.py def load ( self , document ): \"\"\"Load from dictionary. Arguments: document (dict): JSON-compatible dictionary \"\"\" assert isinstance ( document , ( dict , list , tuple ) ), \"`document` must be of dict, list or tuple, \" \"not %s \" % type ( document ) with self . reset_model (): self . root = JsonTreeItem . load ( document ) self . root . type = type ( document ) # type: ignore self . items = self . root . children return True setData ( self , index , value , role ) setData(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], value: Any, role: int = Instance(Qt.EditRole)) -> bool Source code in prettyqt/custom_models/jsonmodel.py def setData ( self , index , value , role ): if role == constants . EDIT_ROLE : if index . column () == 1 : item = index . internalPointer () item . value = str ( value ) self . update_row ( index . row ()) return True return False listmixin ListMixin Source code in prettyqt/custom_models/listmixin.py class ListMixin : remove_rows : Callable SORT_METHODS : dict [ int , Callable ] change_layout : Callable insert_rows : Callable removeRow : Callable # setData: Callable update_row : Callable MIME_TYPE : str DATA_ROLE = constants . USER_ROLE def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) # type: ignore self . items = [] def setData ( self , index , value , role ): if role == self . DATA_ROLE : self . items [ index . row ()] = value self . update_row ( index . row ()) return True return super () . setData ( index , value , role ) # type: ignore def removeRows ( self , row : int , count : int , parent ): end_row = row + count - 1 with self . remove_rows ( row , end_row , parent ): for i in range ( end_row , row - 1 , - 1 ): self . items . pop ( i ) return True def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . items ) def data_by_index ( self , index ): return self . items [ index . row ()] def dropMimeData ( self , mime_data , action , row , column , parent_index ): if not mime_data . hasFormat ( self . MIME_TYPE ): return False # Since we only drop in between items, parent_index must be invalid, # and we use the row arg to know where the drop took place. if parent_index . isValid (): return False indexes = mime_data . get_json_data ( self . MIME_TYPE ) pos = row if row < len ( self . items ) and row != - 1 else len ( self . items ) rem_offset = sum ( i <= pos for i in indexes ) new = [ self . items [ i ] for i in indexes ] with self . change_layout (): for i in sorted ( indexes , reverse = True ): self . items . pop ( i ) for item in reversed ( new ): self . items . insert ( pos - rem_offset , item ) return False def sort ( self , ncol : int , order ): \"\"\"Sort table by given column number.\"\"\" is_asc = order == constants . ASCENDING sorter = self . SORT_METHODS . get ( ncol ) if sorter : with self . change_layout (): self . items . sort ( key = sorter , reverse = is_asc ) def add ( self , item : Any , position : Optional [ int ] = None ): \"\"\"Append provided item to the list.\"\"\" self . add_items ( items = [ item ], position = position ) return item def add_items ( self , items : Iterable [ Any ], position : Optional [ int ] = None ): \"\"\"Append a list of items to the list.\"\"\" if position is None : position = len ( self . items ) items = list ( items ) with self . insert_rows ( position , position + len ( items ) - 1 ): for i in range ( len ( items )): self . items . insert ( i + position , items [ i ]) # self.items.extend(items) return items def remove_items ( self , offsets : Iterable [ int ]): for offset in sorted ( offsets , reverse = True ): self . removeRow ( offset ) add ( self , item : Any , position : Optional [ int ] = None ) Append provided item to the list. Source code in prettyqt/custom_models/listmixin.py def add ( self , item : Any , position : Optional [ int ] = None ): \"\"\"Append provided item to the list.\"\"\" self . add_items ( items = [ item ], position = position ) return item add_items ( self , items : Iterable , position : Optional [ int ] = None ) Append a list of items to the list. Source code in prettyqt/custom_models/listmixin.py def add_items ( self , items : Iterable [ Any ], position : Optional [ int ] = None ): \"\"\"Append a list of items to the list.\"\"\" if position is None : position = len ( self . items ) items = list ( items ) with self . insert_rows ( position , position + len ( items ) - 1 ): for i in range ( len ( items )): self . items . insert ( i + position , items [ i ]) # self.items.extend(items) return items rowCount ( self , parent = None ) Required override for AbstractitemModels. Source code in prettyqt/custom_models/listmixin.py def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . items ) sort ( self , ncol : int , order ) Sort table by given column number. Source code in prettyqt/custom_models/listmixin.py def sort ( self , ncol : int , order ): \"\"\"Sort table by given column number.\"\"\" is_asc = order == constants . ASCENDING sorter = self . SORT_METHODS . get ( ncol ) if sorter : with self . change_layout (): self . items . sort ( key = sorter , reverse = is_asc ) modelmixin ModelMixin Source code in prettyqt/custom_models/modelmixin.py class ModelMixin : DATA_ROLE = constants . USER_ROLE DTYPE_ROLE = constants . USER_ROLE + 1 # type: ignore NAME_ROLE = constants . USER_ROLE + 2 # type: ignore SORT_ROLE = constants . USER_ROLE + 3 # type: ignore MAX_ROWS = 1_000_000 HEADER = [ \"Name\" ] DEFAULT_FLAGS = ( constants . DRAG_ENABLED # type: ignore | constants . IS_ENABLED | constants . IS_SELECTABLE | constants . NO_CHILDREN ) LABELS : dict = dict () CHECKSTATE : dict = dict () TOOLTIPS : dict = dict () DECORATIONS : dict = dict () SET_DATA : dict = dict () content_type = \"\" data_by_index : Callable update_row : Callable def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] def columnCount ( self , parent = None ): return len ( self . HEADER ) def flags ( self , index ): \"\"\"Required override for AbstractitemModels. returns corresponding flags for cell of supplied index \"\"\" if not index . isValid (): return constants . DROP_ENABLED if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None item = self . data_by_index ( index ) if role == constants . DECORATION_ROLE : fn = self . DECORATIONS . get ( index . column ()) if fn : return fn ( item ) elif role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: fn = self . LABELS . get ( index . column ()) if fn : return fn ( item ) elif role == constants . TOOLTIP_ROLE : fn = self . TOOLTIPS . get ( index . column ()) if fn : return fn ( item ) elif role == constants . CHECKSTATE_ROLE : fn = self . CHECKSTATE . get ( index . column ()) if fn : return fn ( item ) elif role == self . DATA_ROLE : return item return None def setData ( self , index , value , role ): if role == constants . EDIT_ROLE : if not value : return False item = self . data_by_index ( index ) fn = self . SET_DATA . get ( index . column ()) if fn : fn ( item , value ) self . update_row ( index . row ()) return True flags ( self , index ) Required override for AbstractitemModels. returns corresponding flags for cell of supplied index Source code in prettyqt/custom_models/modelmixin.py def flags ( self , index ): \"\"\"Required override for AbstractitemModels. returns corresponding flags for cell of supplied index \"\"\" if not index . isValid (): return constants . DROP_ENABLED if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS nesteditem NestedItem Source code in prettyqt/custom_models/nesteditem.py class NestedItem : item_name = \"not_defined\" def __init__ ( self , parent : NestedItem | None = None , dynamic_name : str | None = None , count : int | None = None , children : list [ NestedItem ] | None = None , ): self . parent = parent self . dynamic_name = dynamic_name if dynamic_name else self . item_name self . count = count # self.timestamp = kwargs.pop(\"timestamp\", time.time()) self . children : list [ NestedItem ] = list () if children : self . add_children ( children ) def __iter__ ( self ): return iter ( self . children ) def add_children ( self , children : Iterable ): for child in children : child . parent = self self . children . extend ( children ) def append_child ( self , item ): self . children . append ( item ) def child ( self , row : int ) -> NestedItem : return self . children [ row ] def row ( self ) -> int : \"\"\"Return row number. returns row position of item inside parent\u00b4s children returns 0 if no parent available Returns: row number \"\"\" return self . parent . children . index ( self ) if self . parent else 0 def iter_tree ( self , name : str | None = None , yield_self : bool = True , recursive : bool = True , level : int = 0 , count : int = 0 , assign_names : bool = True , ): \"\"\"Yield children from bottom to top, yield self at end. assigns dynamic vars count, level and dynamic name \"\"\" if name is None : name = self . item_name for i , c in enumerate ( self . children , start = 1 ): count += 1 level += 1 with_suffix = f \" { name } _ { i } \" if len ( self . children ) > 1 else name if recursive : yield from c . iter_tree ( with_suffix , yield_self = False , level = level , count = count ) if assign_names : c . dynamic_name , c . count = with_suffix , count yield c level -= 1 if yield_self : if assign_names : self . dynamic_name , self . count = name , 0 yield self iter_tree ( self , name : str | None = None , yield_self : bool = True , recursive : bool = True , level : int = 0 , count : int = 0 , assign_names : bool = True ) Yield children from bottom to top, yield self at end. assigns dynamic vars count, level and dynamic name Source code in prettyqt/custom_models/nesteditem.py def iter_tree ( self , name : str | None = None , yield_self : bool = True , recursive : bool = True , level : int = 0 , count : int = 0 , assign_names : bool = True , ): \"\"\"Yield children from bottom to top, yield self at end. assigns dynamic vars count, level and dynamic name \"\"\" if name is None : name = self . item_name for i , c in enumerate ( self . children , start = 1 ): count += 1 level += 1 with_suffix = f \" { name } _ { i } \" if len ( self . children ) > 1 else name if recursive : yield from c . iter_tree ( with_suffix , yield_self = False , level = level , count = count ) if assign_names : c . dynamic_name , c . count = with_suffix , count yield c level -= 1 if yield_self : if assign_names : self . dynamic_name , self . count = name , 0 yield self row ( self ) -> int Return row number. returns row position of item inside parent\u00b4s children returns 0 if no parent available Returns: Type Description int row number Source code in prettyqt/custom_models/nesteditem.py def row ( self ) -> int : \"\"\"Return row number. returns row position of item inside parent\u00b4s children returns 0 if no parent available Returns: row number \"\"\" return self . parent . children . index ( self ) if self . parent else 0 nestedmodel NestedModel ( ListMixin , ModelMixin , AbstractItemModel ) Source code in prettyqt/custom_models/nestedmodel.py class NestedModel ( # type: ignore custom_models . ListMixin , custom_models . ModelMixin , core . AbstractItemModel ): DEFAULT_FLAGS = ( constants . DRAG_ENABLED # type: ignore | constants . IS_ENABLED | constants . IS_SELECTABLE ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . root = Root () self . items = self . root . children def flags ( self , index ): if not index . isValid (): return constants . NO_FLAGS if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS def rowCount ( self , parent = core . ModelIndex ()) -> int : if parent . column () > 0 : return 0 if not parent . isValid (): return len ( self . items ) return len ( parent . internalPointer () . children ) def index ( self , row , column , parent ): if not self . hasIndex ( row , column , parent ): return core . ModelIndex () parent_item = parent . internalPointer () if not parent_item : parent_item = self . root return self . createIndex ( row , column , parent_item . children [ row ]) def parent ( self , index ): if not index . isValid (): return core . ModelIndex () item = index . internalPointer () if not item : return core . ModelIndex () if item . parent in [ self . root , None ]: return core . ModelIndex () return self . createIndex ( item . parent . row (), 0 , item . parent ) def data_by_index ( self , index ): return index . internalPointer () def json ( self , root = None ) -> dict : \"\"\"Serialise model as JSON-compliant dictionary. Arguments: root (JsonTreeItem, optional): Serialise from here defaults to the the top-level item Returns: model as dict \"\"\" root = root if root else self . root return root . as_json () flags ( self , index ) Required override for AbstractitemModels. returns corresponding flags for cell of supplied index Source code in prettyqt/custom_models/nestedmodel.py def flags ( self , index ): if not index . isValid (): return constants . NO_FLAGS if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS index ( self , row , column , parent ) index(self, row: int, column: int, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/nestedmodel.py def index ( self , row , column , parent ): if not self . hasIndex ( row , column , parent ): return core . ModelIndex () parent_item = parent . internalPointer () if not parent_item : parent_item = self . root return self . createIndex ( row , column , parent_item . children [ row ]) json ( self , root = None ) -> dict Serialise model as JSON-compliant dictionary. Parameters: Name Type Description Default root JsonTreeItem Serialise from here defaults to the the top-level item None Returns: Type Description dict model as dict Source code in prettyqt/custom_models/nestedmodel.py def json ( self , root = None ) -> dict : \"\"\"Serialise model as JSON-compliant dictionary. Arguments: root (JsonTreeItem, optional): Serialise from here defaults to the the top-level item Returns: model as dict \"\"\" root = root if root else self . root return root . as_json () parent ( self , index ) parent(self) -> PySide6.QtCore.QObject parent(self, child: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/nestedmodel.py def parent ( self , index ): if not index . isValid (): return core . ModelIndex () item = index . internalPointer () if not item : return core . ModelIndex () if item . parent in [ self . root , None ]: return core . ModelIndex () return self . createIndex ( item . parent . row (), 0 , item . parent ) rowCount ( self , parent = < PySide6 . QtCore . QModelIndex ( - 1 , - 1 , 0x0 , QObject ( 0x0 )) at 0x7f0737060640 > ) -> int Required override for AbstractitemModels. Source code in prettyqt/custom_models/nestedmodel.py def rowCount ( self , parent = core . ModelIndex ()) -> int : if parent . column () > 0 : return 0 if not parent . isValid (): return len ( self . items ) return len ( parent . internalPointer () . children ) regexmatchesmodel RegexMatchesModel ( AbstractTableModel ) Source code in prettyqt/custom_models/regexmatchesmodel.py class RegexMatchesModel ( core . AbstractTableModel ): HEADER = [ \"Start\" , \"End\" , \"Value\" , \"Groups\" ] def __init__ ( self , matches : list | None = None , parent : QtCore . QObject | None = None ): super () . __init__ ( parent = parent ) self . matches = matches if matches else list () def columnCount ( self , parent = None ): return len ( self . HEADER ) def headerData ( # type: ignore self , section : int , orientation : QtCore . Qt . Orientation , role : int ) -> str | None : if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ section ] def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span () def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches ) columnCount ( self , parent = None ) columnCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER ) data ( self , index , role ) data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span () headerData ( self , section : int , orientation : QtCore . Qt . Orientation , role : int ) -> str | None headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def headerData ( # type: ignore self , section : int , orientation : QtCore . Qt . Orientation , role : int ) -> str | None : if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ section ] rowCount ( self , parent = None ) Required override for AbstractitemModels. Source code in prettyqt/custom_models/regexmatchesmodel.py def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches ) storageinfomodel StorageInfoModel ( AbstractTableModel ) Source code in prettyqt/custom_models/storageinfomodel.py class StorageInfoModel ( core . AbstractTableModel ): ( ColumnRootPath , ColumnName , ColumnDevice , ColumnFileSystemName , ColumnTotal , ColumnFree , ColumnAvailable , ColumnIsReady , ColumnIsReadOnly , ColumnIsValid , ColumnCount , ) = range ( 11 ) columnFuncMap = { ColumnRootPath : lambda volume : str ( volume . get_root_path ()), ColumnName : lambda volume : volume . name (), ColumnDevice : lambda volume : volume . get_device (), ColumnFileSystemName : lambda volume : volume . get_file_system_type (), ColumnTotal : lambda volume : size_to_string ( volume . bytesTotal ()), ColumnFree : lambda volume : size_to_string ( volume . bytesFree ()), ColumnAvailable : lambda volume : size_to_string ( volume . bytesAvailable ()), ColumnIsReady : lambda volume : volume . isReady (), ColumnIsReadOnly : lambda volume : volume . isReadOnly (), ColumnIsValid : lambda volume : volume . isValid (), } columnNameMap = { ColumnRootPath : \"Root path\" , ColumnName : \"Volume Name\" , ColumnDevice : \"Device\" , ColumnFileSystemName : \"File system\" , ColumnTotal : \"Total\" , ColumnFree : \"Free\" , ColumnAvailable : \"Available\" , ColumnIsReady : \"Ready\" , ColumnIsReadOnly : \"Read-only\" , ColumnIsValid : \"Valid\" , } def __init__ ( self , parent : QtCore . QObject | None = None ): super () . __init__ ( parent ) self . volumes = core . StorageInfo . get_mounted_volumes () def columnCount ( self , parent = None ): return self . ColumnCount def rowCount ( self , parent ): if parent . isValid (): return 0 return len ( self . volumes ) def data ( self , index , role ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : volume = self . volumes [ index . row ()] func = self . columnFuncMap . get ( index . column ()) if func is not None : return func ( volume ) elif role == constants . TOOLTIP_ROLE : volume = self . volumes [ index . row ()] tooltip = [] for column in range ( self . ColumnCount ): label = self . columnNameMap . get ( column ) value = self . columnFuncMap [ column ]( volume ) tooltip . append ( f \" { label } : { value } \" ) return \" \\n \" . join ( tooltip ) def headerData ( self , section , orientation , role ): if orientation != constants . HORIZONTAL : return None if role != constants . DISPLAY_ROLE : return None return self . columnNameMap . get ( section ) columnCount ( self , parent = None ) columnCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/storageinfomodel.py def columnCount ( self , parent = None ): return self . ColumnCount data ( self , index , role ) data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/storageinfomodel.py def data ( self , index , role ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : volume = self . volumes [ index . row ()] func = self . columnFuncMap . get ( index . column ()) if func is not None : return func ( volume ) elif role == constants . TOOLTIP_ROLE : volume = self . volumes [ index . row ()] tooltip = [] for column in range ( self . ColumnCount ): label = self . columnNameMap . get ( column ) value = self . columnFuncMap [ column ]( volume ) tooltip . append ( f \" { label } : { value } \" ) return \" \\n \" . join ( tooltip ) headerData ( self , section , orientation , role ) headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/storageinfomodel.py def headerData ( self , section , orientation , role ): if orientation != constants . HORIZONTAL : return None if role != constants . DISPLAY_ROLE : return None return self . columnNameMap . get ( section ) rowCount ( self , parent ) rowCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/storageinfomodel.py def rowCount ( self , parent ): if parent . isValid (): return 0 return len ( self . volumes ) subsequencesortfilterproxymodel SubsequenceSortFilterProxyModel ( SortFilterProxyModel ) Source code in prettyqt/custom_models/subsequencesortfilterproxymodel.py class SubsequenceSortFilterProxyModel ( core . SortFilterProxyModel ): \"\"\"Performs subsequence matching/sorting.\"\"\" def __init__ ( self , case_sensitivity : bool , parent = None ): super () . __init__ ( parent ) self . case_sensitivity = case_sensitivity def set_prefix ( self , prefix : str ): self . filter_patterns = [] self . filter_patterns_case_sensitive = [] self . sort_patterns = [] flags = re . IGNORECASE if self . case_sensitivity is False else 0 for i in reversed ( range ( 1 , len ( prefix ) + 1 )): ptrn = f \".* { prefix [ 0 : i ] } .* { prefix [ i :] } \" try : self . filter_patterns . append ( re . compile ( ptrn , flags )) self . filter_patterns_case_sensitive . append ( re . compile ( ptrn , 0 )) ptrn = f \" { prefix [ 0 : i ] } .* { prefix [ i :] } \" self . sort_patterns . append ( re . compile ( ptrn , flags )) except Exception : continue self . prefix = prefix def filterAcceptsRow ( self , row , _ ): completion = self . sourceModel () . data ( self . sourceModel () . index ( row , 0 )) if completion is None or self . prefix is None : return False if len ( completion ) < len ( self . prefix ): return False if len ( self . prefix ) == 1 : try : prefix = self . prefix if self . case_sensitivity is False : completion = completion . lower () prefix = self . prefix . lower () rank = completion . index ( prefix ) idx = self . sourceModel () . index ( row , 0 ) self . sourceModel () . setData ( idx , rank , USER_ROLE ) # type: ignore return prefix in completion except ValueError : return False for i , patterns in enumerate ( zip ( self . filter_patterns , self . filter_patterns_case_sensitive , self . sort_patterns , ) ): pattern , pattern_case , sort_pattern = patterns match = re . match ( pattern , completion ) if match : # compute rank, the lowest rank the closer it is from the # completion start = MAX_SIZE for m in sort_pattern . finditer ( completion ): start , end = m . span () rank = start + i * 10 if re . match ( pattern_case , completion ): # favorise completions where case is matched rank -= 10 self . sourceModel () . setData ( idx , rank , USER_ROLE ) # type: ignore return True return len ( self . prefix ) == 0 filterAcceptsRow ( self , row , _ ) filterAcceptsRow(self, source_row: int, source_parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> bool Source code in prettyqt/custom_models/subsequencesortfilterproxymodel.py def filterAcceptsRow ( self , row , _ ): completion = self . sourceModel () . data ( self . sourceModel () . index ( row , 0 )) if completion is None or self . prefix is None : return False if len ( completion ) < len ( self . prefix ): return False if len ( self . prefix ) == 1 : try : prefix = self . prefix if self . case_sensitivity is False : completion = completion . lower () prefix = self . prefix . lower () rank = completion . index ( prefix ) idx = self . sourceModel () . index ( row , 0 ) self . sourceModel () . setData ( idx , rank , USER_ROLE ) # type: ignore return prefix in completion except ValueError : return False for i , patterns in enumerate ( zip ( self . filter_patterns , self . filter_patterns_case_sensitive , self . sort_patterns , ) ): pattern , pattern_case , sort_pattern = patterns match = re . match ( pattern , completion ) if match : # compute rank, the lowest rank the closer it is from the # completion start = MAX_SIZE for m in sort_pattern . finditer ( completion ): start , end = m . span () rank = start + i * 10 if re . match ( pattern_case , completion ): # favorise completions where case is matched rank -= 10 self . sourceModel () . setData ( idx , rank , USER_ROLE ) # type: ignore return True return len ( self . prefix ) == 0 transposeproxymodel TransposeProxyModel ( AbstractProxyModel ) Source code in prettyqt/custom_models/transposeproxymodel.py class TransposeProxyModel ( core . AbstractProxyModel ): def __init__ ( self , source_model : QtCore . QAbstractItemModel ): super () . __init__ () self . _source_model = source_model self . setSourceModel ( source_model ) def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model ) def mapFromSource ( self , source_index : core . ModelIndex ) -> core . ModelIndex : return self . index ( source_index . column (), source_index . row ()) def mapToSource ( self , proxy_index : core . ModelIndex ) -> core . ModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ()) def index ( self , row : int , column : int , parent : core . ModelIndex | None = None ) -> core . ModelIndex : return self . createIndex ( row , column ) def parent ( self , index : core . ModelIndex ): # type: ignore return None def rowCount ( self , parent : core . ModelIndex | None = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . columnCount ( parent ) def columnCount ( self , parent : core . ModelIndex | None = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . rowCount ( parent ) def data ( self , index : core . ModelIndex , role = QtCore . Qt . ItemDataRole . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role ) def headerData ( self , section : int , orientation , role ): # type: ignore return self . _source_model . headerData ( section , orientation , role ) columnCount ( self , parent : core . ModelIndex | None = None ) -> int columnCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def columnCount ( self , parent : core . ModelIndex | None = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . rowCount ( parent ) data ( self , index : core . ModelIndex , role = < ItemDataRole . DisplayRole : 0 > ) data(self, proxyIndex: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def data ( self , index : core . ModelIndex , role = QtCore . Qt . ItemDataRole . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role ) headerData ( self , section : int , orientation , role ) headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def headerData ( self , section : int , orientation , role ): # type: ignore return self . _source_model . headerData ( section , orientation , role ) index ( self , row : int , column : int , parent : core . ModelIndex | None = None ) -> core . ModelIndex index(self, row: int, column: int, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def index ( self , row : int , column : int , parent : core . ModelIndex | None = None ) -> core . ModelIndex : return self . createIndex ( row , column ) mapFromSource ( self , source_index : core . ModelIndex ) -> core . ModelIndex mapFromSource(self, sourceIndex: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapFromSource ( self , source_index : core . ModelIndex ) -> core . ModelIndex : return self . index ( source_index . column (), source_index . row ()) mapToSource ( self , proxy_index : core . ModelIndex ) -> core . ModelIndex mapToSource(self, proxyIndex: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapToSource ( self , proxy_index : core . ModelIndex ) -> core . ModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ()) parent ( self , index : core . ModelIndex ) parent(self) -> PySide6.QtCore.QObject parent(self, child: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def parent ( self , index : core . ModelIndex ): # type: ignore return None rowCount ( self , parent : core . ModelIndex | None = None ) -> int rowCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def rowCount ( self , parent : core . ModelIndex | None = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . columnCount ( parent ) setSourceModel ( self , source_model : QtCore . QAbstractItemModel ) setSourceModel(self, sourceModel: PySide6.QtCore.QAbstractItemModel) -> None Source code in prettyqt/custom_models/transposeproxymodel.py def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"custom_models"},{"location":"api/custom_models.html#custom_models-module","text":"Custom_models module. Contains custom models","title":"custom_models module"},{"location":"api/custom_models.html#prettyqt.custom_models.baselistmixin","text":"","title":"baselistmixin"},{"location":"api/custom_models.html#prettyqt.custom_models.baselistmixin.BaseListMixin","text":"Source code in prettyqt/custom_models/baselistmixin.py class BaseListMixin : remove_rows : Callable SORT_METHODS : dict [ int , Callable ] change_layout : Callable insert_rows : Callable removeRow : Callable def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . items = [] def setData ( self , index , value , role ): if role == self . DATA_ROLE : self . items [ index . row ()] = value self . update_row ( index . row ()) return True return super () . setData ( index , value , role ) def removeRows ( self , row : int , count : int , parent ): end_row = row + count - 1 with self . remove_rows ( row , end_row , parent ): for i in range ( end_row , row - 1 , - 1 ): self . items . pop ( i ) return True def rowCount ( self , parent = None ): \"\"\"Returns number of rows. required override for AbstractitemModels \"\"\" return len ( self . items ) def data_by_index ( self , index ): return self . items [ index . row ()] def dropMimeData ( self , mime_data , action , row , column , parent_index ): if not mime_data . hasFormat ( self . MIME_TYPE ): return False # Since we only drop in between items, parent_index must be invalid, # and we use the row arg to know where the drop took place. if parent_index . isValid (): return False indexes = mime_data . get_json_data ( self . MIME_TYPE ) pos = row if row < len ( self . items ) and row != - 1 else len ( self . items ) rem_offset = sum ( i <= pos for i in indexes ) new = [ self . items [ i ] for i in indexes ] with self . change_layout (): for i in sorted ( indexes , reverse = True ): self . items . pop ( i ) for item in reversed ( new ): self . items . insert ( pos - rem_offset , item ) return False def sort ( self , ncol : int , order ): \"\"\"Sorts table by given column number.\"\"\" is_asc = order == constants . ASCENDING sorter = self . SORT_METHODS . get ( ncol ) if sorter : with self . change_layout (): self . items . sort ( key = sorter , reverse = is_asc ) def add ( self , item : Any , position : int | None = None ): \"\"\"Appends provided item to the list.\"\"\" self . add_items ( items = [ item ], position = position ) return item def add_items ( self , items : Iterable [ Any ], position : int | None = None ): \"\"\"Appends a list of items to the list.\"\"\" if position is None : position = len ( self . items ) items = list ( items ) with self . insert_rows ( position , position + len ( items ) - 1 ): for i in range ( len ( items )): self . items . insert ( i + position , items [ i ]) # self.items.extend(items) return items def remove_items ( self , offsets : Iterable [ int ]): for offset in sorted ( offsets , reverse = True ): self . removeRow ( offset )","title":"BaseListMixin"},{"location":"api/custom_models.html#prettyqt.custom_models.baselistmixin.BaseListMixin.add","text":"Appends provided item to the list. Source code in prettyqt/custom_models/baselistmixin.py def add ( self , item : Any , position : int | None = None ): \"\"\"Appends provided item to the list.\"\"\" self . add_items ( items = [ item ], position = position ) return item","title":"add()"},{"location":"api/custom_models.html#prettyqt.custom_models.baselistmixin.BaseListMixin.add_items","text":"Appends a list of items to the list. Source code in prettyqt/custom_models/baselistmixin.py def add_items ( self , items : Iterable [ Any ], position : int | None = None ): \"\"\"Appends a list of items to the list.\"\"\" if position is None : position = len ( self . items ) items = list ( items ) with self . insert_rows ( position , position + len ( items ) - 1 ): for i in range ( len ( items )): self . items . insert ( i + position , items [ i ]) # self.items.extend(items) return items","title":"add_items()"},{"location":"api/custom_models.html#prettyqt.custom_models.baselistmixin.BaseListMixin.rowCount","text":"Returns number of rows. required override for AbstractitemModels Source code in prettyqt/custom_models/baselistmixin.py def rowCount ( self , parent = None ): \"\"\"Returns number of rows. required override for AbstractitemModels \"\"\" return len ( self . items )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.baselistmixin.BaseListMixin.sort","text":"Sorts table by given column number. Source code in prettyqt/custom_models/baselistmixin.py def sort ( self , ncol : int , order ): \"\"\"Sorts table by given column number.\"\"\" is_asc = order == constants . ASCENDING sorter = self . SORT_METHODS . get ( ncol ) if sorter : with self . change_layout (): self . items . sort ( key = sorter , reverse = is_asc )","title":"sort()"},{"location":"api/custom_models.html#prettyqt.custom_models.basemodelmixin","text":"","title":"basemodelmixin"},{"location":"api/custom_models.html#prettyqt.custom_models.basemodelmixin.BaseModelMixin","text":"Source code in prettyqt/custom_models/basemodelmixin.py class BaseModelMixin : DATA_ROLE = constants . USER_ROLE DTYPE_ROLE = constants . USER_ROLE + 1 NAME_ROLE = constants . USER_ROLE + 2 SORT_ROLE = constants . USER_ROLE + 3 MAX_ROWS = 1_000_000 HEADER = [ \"Name\" ] DEFAULT_FLAGS = ( constants . DRAG_ENABLED | constants . IS_ENABLED | constants . IS_SELECTABLE | constants . NO_CHILDREN ) LABELS : dict = dict () CHECKSTATE : dict = dict () TOOLTIPS : dict = dict () DECORATIONS : dict = dict () SET_DATA : dict = dict () content_type = \"\" data_by_index : Callable def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] def columnCount ( self , parent = None ): return len ( self . HEADER ) def flags ( self , index ): \"\"\"Returns corresponding flags for cell of supplied index. required override for AbstractitemModels \"\"\" if not index . isValid (): return constants . DROP_ENABLED if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None item = self . data_by_index ( index ) if role == constants . DECORATION_ROLE : fn = self . DECORATIONS . get ( index . column ()) if fn : return fn ( item ) elif role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: fn = self . LABELS . get ( index . column ()) if fn : return fn ( item ) elif role == constants . TOOLTIP_ROLE : fn = self . TOOLTIPS . get ( index . column ()) if fn : return fn ( item ) elif role == constants . CHECKSTATE_ROLE : fn = self . CHECKSTATE . get ( index . column ()) if fn : return fn ( item ) elif role == self . DATA_ROLE : return item return None def setData ( self , index , value , role ): if role == constants . EDIT_ROLE : if not value : return False item = self . data_by_index ( index ) fn = self . SET_DATA . get ( index . column ()) if fn : fn ( item , value ) self . update_row ( index . row ()) return True","title":"BaseModelMixin"},{"location":"api/custom_models.html#prettyqt.custom_models.basemodelmixin.BaseModelMixin.flags","text":"Returns corresponding flags for cell of supplied index. required override for AbstractitemModels Source code in prettyqt/custom_models/basemodelmixin.py def flags ( self , index ): \"\"\"Returns corresponding flags for cell of supplied index. required override for AbstractitemModels \"\"\" if not index . isValid (): return constants . DROP_ENABLED if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS","title":"flags()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel","text":"","title":"columnitemmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItem","text":"Determines how an object attribute is shown. Source code in prettyqt/custom_models/columnitemmodel.py @dataclass ( frozen = True ) class ColumnItem : \"\"\"Determines how an object attribute is shown.\"\"\" name : str label : Callable | None checkstate : Callable | None = None doc : str = \"<no help available>\" col_visible : bool = True width : int | str = SMALL_COL_WIDTH alignment : Callable | int | None = None line_wrap : gui . textoption . WordWrapModeStr = \"none\" foreground_color : Callable | str | None = None background_color : Callable | str | None = None decoration : Callable | QtGui . QIcon | None = None font : Callable | QtGui . QFont | None = None selectable : bool = True enabled : bool = True editable : bool = False checkable : bool = False tristate : bool = False def get_name ( self ) -> str : return self . name def get_flag ( self ): flag = constants . NO_FLAGS if self . selectable : flag |= constants . IS_SELECTABLE # type: ignore if self . enabled : flag |= constants . IS_ENABLED # type: ignore if self . editable : flag |= constants . IS_EDITABLE # type: ignore if self . checkable : flag |= constants . IS_CHECKABLE # type: ignore if self . tristate : flag |= constants . IS_USER_TRISTATE # type: ignore return flag def get_label ( self , tree_item ): if self . label is None : return \"\" elif callable ( self . label ): return self . label ( tree_item ) return self . label def get_checkstate ( self , tree_item ): if self . checkstate is None : return None elif callable ( self . checkstate ): return self . checkstate ( tree_item ) return self . checkstate def get_font ( self , tree_item ): if self . font is None : return None elif callable ( self . font ): return self . font ( tree_item ) return self . font def get_foreground_color ( self , tree_item ): if self . foreground_color is None : return None elif callable ( self . foreground_color ): return self . foreground_color ( tree_item ) return self . foreground_color def get_background_color ( self , tree_item ): if self . background_color is None : return None elif callable ( self . background_color ): return self . background_color ( tree_item ) return self . background_color def get_decoration ( self , tree_item ): if self . decoration is None : return None elif callable ( self . decoration ): return self . decoration ( tree_item ) return self . decoration def get_alignment ( self , tree_item ) -> int : if self . alignment is None : return constants . ALIGN_LEFT # type: ignore elif callable ( self . alignment ): return self . alignment ( tree_item ) elif isinstance ( self . alignment , str ): return constants . ALIGNMENTS [ self . alignment ] return self . alignment def get_width ( self ) -> int : if self . width == \"small\" : return SMALL_COL_WIDTH elif self . width == \"medium\" : return MEDIUM_COL_WIDTH elif isinstance ( self . width , int ): return self . width raise ValueError ( self . width )","title":"ColumnItem"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel","text":"Source code in prettyqt/custom_models/columnitemmodel.py class ColumnItemModel ( core . AbstractItemModel ): \"\"\"Model that provides an interface to an objectree that is build of TreeItems.\"\"\" def __init__ ( self , attr_cols : list [ ColumnItem ] | None = None , parent : QtCore . QObject | None = None , ): super () . __init__ ( parent ) self . _attr_cols = attr_cols if attr_cols is not None else [] def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols ) def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: val = self . _attr_cols [ col ] . get_label ( tree_item ) return val . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN col = index . column () return self . _attr_cols [ col ] . get_flag () def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None","title":"ColumnItemModel"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.columnCount","text":"Return the number of columns in the tree. Source code in prettyqt/custom_models/columnitemmodel.py def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.data","text":"Return the tree item at the given index and role. Source code in prettyqt/custom_models/columnitemmodel.py def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: val = self . _attr_cols [ col ] . get_label ( tree_item ) return val . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.flags","text":"flags(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.Qt.ItemFlag Source code in prettyqt/custom_models/columnitemmodel.py def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN col = index . column () return self . _attr_cols [ col ] . get_flag ()","title":"flags()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.headerData","text":"headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/columnitemmodel.py def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel","text":"","title":"importlibdistributionmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel","text":"Source code in prettyqt/custom_models/importlibdistributionmodel.py class ImportlibDistributionModel ( core . AbstractTableModel ): HEADER = [ \"Name\" , \"Version\" , \"Summary\" , \"Homepage\" , \"Author\" , \"License\" ] def __init__ ( self , distributions : Sequence [ metadata . Distribution ], parent : QtCore . QObject | None = None , ): super () . __init__ ( parent ) self . distributions = distributions def rowCount ( self , parent = core . ModelIndex ()): return len ( self . distributions ) if not parent . isValid () else 0 def columnCount ( self , parent = core . ModelIndex ()): return len ( self . HEADER ) if not parent . isValid () else 0 def headerData ( self , offset : int , orientation , role ): # type: ignore if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Name\" ] elif index . column () == 1 : dist = self . distributions [ index . row ()] return dist . version elif index . column () == 2 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Summary\" ] elif index . column () == 3 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Home-Page\" ] elif index . column () == 4 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Author\" ] elif index . column () == 5 : dist = self . distributions [ index . row ()] return dist . metadata [ \"License\" ] elif role == constants . USER_ROLE : dist = self . distributions [ index . row ()] return dist @classmethod def from_system ( cls , parent : QtCore . QObject | None = None ) -> ImportlibDistributionModel : distributions = list_system_modules () return cls ( distributions , parent ) @classmethod def from_package ( cls , package_name : str , parent : QtCore . QObject | None = None ) -> ImportlibDistributionModel : distributions = list_package_requirements ( package_name ) return cls ( distributions , parent )","title":"ImportlibDistributionModel"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.columnCount","text":"columnCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def columnCount ( self , parent = core . ModelIndex ()): return len ( self . HEADER ) if not parent . isValid () else 0","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.data","text":"data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Name\" ] elif index . column () == 1 : dist = self . distributions [ index . row ()] return dist . version elif index . column () == 2 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Summary\" ] elif index . column () == 3 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Home-Page\" ] elif index . column () == 4 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Author\" ] elif index . column () == 5 : dist = self . distributions [ index . row ()] return dist . metadata [ \"License\" ] elif role == constants . USER_ROLE : dist = self . distributions [ index . row ()] return dist","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.headerData","text":"headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def headerData ( self , offset : int , orientation , role ): # type: ignore if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ]","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.rowCount","text":"rowCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def rowCount ( self , parent = core . ModelIndex ()): return len ( self . distributions ) if not parent . isValid () else 0","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.jsonmodel","text":"","title":"jsonmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.jsonmodel.JsonModel","text":"Source code in prettyqt/custom_models/jsonmodel.py class JsonModel ( custom_models . NestedModel ): HEADER = [ \"Key\" , \"Value\" , \"Type\" ] def __init__ ( self , parent : QtCore . QObject | None = None ): super () . __init__ ( parent = parent ) self . root = JsonTreeItem () # type: ignore self . items = self . root . children def __repr__ ( self ): return str ( self . root . as_json ()) # type: ignore def load ( self , document ): \"\"\"Load from dictionary. Arguments: document (dict): JSON-compatible dictionary \"\"\" assert isinstance ( document , ( dict , list , tuple ) ), \"`document` must be of dict, list or tuple, \" \"not %s \" % type ( document ) with self . reset_model (): self . root = JsonTreeItem . load ( document ) self . root . type = type ( document ) # type: ignore self . items = self . root . children return True def data ( self , index , role ): if not index . isValid (): return None item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: if index . column () == 0 : return repr ( item . key ) elif index . column () == 1 : if item . type in ( dict , list , tuple ): return \"\" else : if role == constants . DISPLAY_ROLE : return repr ( item . value ) else : return item . value elif index . column () == 2 : return item . type . __name__ def setData ( self , index , value , role ): if role == constants . EDIT_ROLE : if index . column () == 1 : item = index . internalPointer () item . value = str ( value ) self . update_row ( index . row ()) return True return False","title":"JsonModel"},{"location":"api/custom_models.html#prettyqt.custom_models.jsonmodel.JsonModel.data","text":"data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/jsonmodel.py def data ( self , index , role ): if not index . isValid (): return None item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: if index . column () == 0 : return repr ( item . key ) elif index . column () == 1 : if item . type in ( dict , list , tuple ): return \"\" else : if role == constants . DISPLAY_ROLE : return repr ( item . value ) else : return item . value elif index . column () == 2 : return item . type . __name__","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.jsonmodel.JsonModel.load","text":"Load from dictionary. Parameters: Name Type Description Default document dict JSON-compatible dictionary required Source code in prettyqt/custom_models/jsonmodel.py def load ( self , document ): \"\"\"Load from dictionary. Arguments: document (dict): JSON-compatible dictionary \"\"\" assert isinstance ( document , ( dict , list , tuple ) ), \"`document` must be of dict, list or tuple, \" \"not %s \" % type ( document ) with self . reset_model (): self . root = JsonTreeItem . load ( document ) self . root . type = type ( document ) # type: ignore self . items = self . root . children return True","title":"load()"},{"location":"api/custom_models.html#prettyqt.custom_models.jsonmodel.JsonModel.setData","text":"setData(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], value: Any, role: int = Instance(Qt.EditRole)) -> bool Source code in prettyqt/custom_models/jsonmodel.py def setData ( self , index , value , role ): if role == constants . EDIT_ROLE : if index . column () == 1 : item = index . internalPointer () item . value = str ( value ) self . update_row ( index . row ()) return True return False","title":"setData()"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin","text":"","title":"listmixin"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin","text":"Source code in prettyqt/custom_models/listmixin.py class ListMixin : remove_rows : Callable SORT_METHODS : dict [ int , Callable ] change_layout : Callable insert_rows : Callable removeRow : Callable # setData: Callable update_row : Callable MIME_TYPE : str DATA_ROLE = constants . USER_ROLE def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) # type: ignore self . items = [] def setData ( self , index , value , role ): if role == self . DATA_ROLE : self . items [ index . row ()] = value self . update_row ( index . row ()) return True return super () . setData ( index , value , role ) # type: ignore def removeRows ( self , row : int , count : int , parent ): end_row = row + count - 1 with self . remove_rows ( row , end_row , parent ): for i in range ( end_row , row - 1 , - 1 ): self . items . pop ( i ) return True def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . items ) def data_by_index ( self , index ): return self . items [ index . row ()] def dropMimeData ( self , mime_data , action , row , column , parent_index ): if not mime_data . hasFormat ( self . MIME_TYPE ): return False # Since we only drop in between items, parent_index must be invalid, # and we use the row arg to know where the drop took place. if parent_index . isValid (): return False indexes = mime_data . get_json_data ( self . MIME_TYPE ) pos = row if row < len ( self . items ) and row != - 1 else len ( self . items ) rem_offset = sum ( i <= pos for i in indexes ) new = [ self . items [ i ] for i in indexes ] with self . change_layout (): for i in sorted ( indexes , reverse = True ): self . items . pop ( i ) for item in reversed ( new ): self . items . insert ( pos - rem_offset , item ) return False def sort ( self , ncol : int , order ): \"\"\"Sort table by given column number.\"\"\" is_asc = order == constants . ASCENDING sorter = self . SORT_METHODS . get ( ncol ) if sorter : with self . change_layout (): self . items . sort ( key = sorter , reverse = is_asc ) def add ( self , item : Any , position : Optional [ int ] = None ): \"\"\"Append provided item to the list.\"\"\" self . add_items ( items = [ item ], position = position ) return item def add_items ( self , items : Iterable [ Any ], position : Optional [ int ] = None ): \"\"\"Append a list of items to the list.\"\"\" if position is None : position = len ( self . items ) items = list ( items ) with self . insert_rows ( position , position + len ( items ) - 1 ): for i in range ( len ( items )): self . items . insert ( i + position , items [ i ]) # self.items.extend(items) return items def remove_items ( self , offsets : Iterable [ int ]): for offset in sorted ( offsets , reverse = True ): self . removeRow ( offset )","title":"ListMixin"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.add","text":"Append provided item to the list. Source code in prettyqt/custom_models/listmixin.py def add ( self , item : Any , position : Optional [ int ] = None ): \"\"\"Append provided item to the list.\"\"\" self . add_items ( items = [ item ], position = position ) return item","title":"add()"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.add_items","text":"Append a list of items to the list. Source code in prettyqt/custom_models/listmixin.py def add_items ( self , items : Iterable [ Any ], position : Optional [ int ] = None ): \"\"\"Append a list of items to the list.\"\"\" if position is None : position = len ( self . items ) items = list ( items ) with self . insert_rows ( position , position + len ( items ) - 1 ): for i in range ( len ( items )): self . items . insert ( i + position , items [ i ]) # self.items.extend(items) return items","title":"add_items()"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.rowCount","text":"Required override for AbstractitemModels. Source code in prettyqt/custom_models/listmixin.py def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . items )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.sort","text":"Sort table by given column number. Source code in prettyqt/custom_models/listmixin.py def sort ( self , ncol : int , order ): \"\"\"Sort table by given column number.\"\"\" is_asc = order == constants . ASCENDING sorter = self . SORT_METHODS . get ( ncol ) if sorter : with self . change_layout (): self . items . sort ( key = sorter , reverse = is_asc )","title":"sort()"},{"location":"api/custom_models.html#prettyqt.custom_models.modelmixin","text":"","title":"modelmixin"},{"location":"api/custom_models.html#prettyqt.custom_models.modelmixin.ModelMixin","text":"Source code in prettyqt/custom_models/modelmixin.py class ModelMixin : DATA_ROLE = constants . USER_ROLE DTYPE_ROLE = constants . USER_ROLE + 1 # type: ignore NAME_ROLE = constants . USER_ROLE + 2 # type: ignore SORT_ROLE = constants . USER_ROLE + 3 # type: ignore MAX_ROWS = 1_000_000 HEADER = [ \"Name\" ] DEFAULT_FLAGS = ( constants . DRAG_ENABLED # type: ignore | constants . IS_ENABLED | constants . IS_SELECTABLE | constants . NO_CHILDREN ) LABELS : dict = dict () CHECKSTATE : dict = dict () TOOLTIPS : dict = dict () DECORATIONS : dict = dict () SET_DATA : dict = dict () content_type = \"\" data_by_index : Callable update_row : Callable def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] def columnCount ( self , parent = None ): return len ( self . HEADER ) def flags ( self , index ): \"\"\"Required override for AbstractitemModels. returns corresponding flags for cell of supplied index \"\"\" if not index . isValid (): return constants . DROP_ENABLED if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None item = self . data_by_index ( index ) if role == constants . DECORATION_ROLE : fn = self . DECORATIONS . get ( index . column ()) if fn : return fn ( item ) elif role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: fn = self . LABELS . get ( index . column ()) if fn : return fn ( item ) elif role == constants . TOOLTIP_ROLE : fn = self . TOOLTIPS . get ( index . column ()) if fn : return fn ( item ) elif role == constants . CHECKSTATE_ROLE : fn = self . CHECKSTATE . get ( index . column ()) if fn : return fn ( item ) elif role == self . DATA_ROLE : return item return None def setData ( self , index , value , role ): if role == constants . EDIT_ROLE : if not value : return False item = self . data_by_index ( index ) fn = self . SET_DATA . get ( index . column ()) if fn : fn ( item , value ) self . update_row ( index . row ()) return True","title":"ModelMixin"},{"location":"api/custom_models.html#prettyqt.custom_models.modelmixin.ModelMixin.flags","text":"Required override for AbstractitemModels. returns corresponding flags for cell of supplied index Source code in prettyqt/custom_models/modelmixin.py def flags ( self , index ): \"\"\"Required override for AbstractitemModels. returns corresponding flags for cell of supplied index \"\"\" if not index . isValid (): return constants . DROP_ENABLED if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS","title":"flags()"},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem","text":"","title":"nesteditem"},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem.NestedItem","text":"Source code in prettyqt/custom_models/nesteditem.py class NestedItem : item_name = \"not_defined\" def __init__ ( self , parent : NestedItem | None = None , dynamic_name : str | None = None , count : int | None = None , children : list [ NestedItem ] | None = None , ): self . parent = parent self . dynamic_name = dynamic_name if dynamic_name else self . item_name self . count = count # self.timestamp = kwargs.pop(\"timestamp\", time.time()) self . children : list [ NestedItem ] = list () if children : self . add_children ( children ) def __iter__ ( self ): return iter ( self . children ) def add_children ( self , children : Iterable ): for child in children : child . parent = self self . children . extend ( children ) def append_child ( self , item ): self . children . append ( item ) def child ( self , row : int ) -> NestedItem : return self . children [ row ] def row ( self ) -> int : \"\"\"Return row number. returns row position of item inside parent\u00b4s children returns 0 if no parent available Returns: row number \"\"\" return self . parent . children . index ( self ) if self . parent else 0 def iter_tree ( self , name : str | None = None , yield_self : bool = True , recursive : bool = True , level : int = 0 , count : int = 0 , assign_names : bool = True , ): \"\"\"Yield children from bottom to top, yield self at end. assigns dynamic vars count, level and dynamic name \"\"\" if name is None : name = self . item_name for i , c in enumerate ( self . children , start = 1 ): count += 1 level += 1 with_suffix = f \" { name } _ { i } \" if len ( self . children ) > 1 else name if recursive : yield from c . iter_tree ( with_suffix , yield_self = False , level = level , count = count ) if assign_names : c . dynamic_name , c . count = with_suffix , count yield c level -= 1 if yield_self : if assign_names : self . dynamic_name , self . count = name , 0 yield self","title":"NestedItem"},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem.NestedItem.iter_tree","text":"Yield children from bottom to top, yield self at end. assigns dynamic vars count, level and dynamic name Source code in prettyqt/custom_models/nesteditem.py def iter_tree ( self , name : str | None = None , yield_self : bool = True , recursive : bool = True , level : int = 0 , count : int = 0 , assign_names : bool = True , ): \"\"\"Yield children from bottom to top, yield self at end. assigns dynamic vars count, level and dynamic name \"\"\" if name is None : name = self . item_name for i , c in enumerate ( self . children , start = 1 ): count += 1 level += 1 with_suffix = f \" { name } _ { i } \" if len ( self . children ) > 1 else name if recursive : yield from c . iter_tree ( with_suffix , yield_self = False , level = level , count = count ) if assign_names : c . dynamic_name , c . count = with_suffix , count yield c level -= 1 if yield_self : if assign_names : self . dynamic_name , self . count = name , 0 yield self","title":"iter_tree()"},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem.NestedItem.row","text":"Return row number. returns row position of item inside parent\u00b4s children returns 0 if no parent available Returns: Type Description int row number Source code in prettyqt/custom_models/nesteditem.py def row ( self ) -> int : \"\"\"Return row number. returns row position of item inside parent\u00b4s children returns 0 if no parent available Returns: row number \"\"\" return self . parent . children . index ( self ) if self . parent else 0","title":"row()"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel","text":"","title":"nestedmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel","text":"Source code in prettyqt/custom_models/nestedmodel.py class NestedModel ( # type: ignore custom_models . ListMixin , custom_models . ModelMixin , core . AbstractItemModel ): DEFAULT_FLAGS = ( constants . DRAG_ENABLED # type: ignore | constants . IS_ENABLED | constants . IS_SELECTABLE ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . root = Root () self . items = self . root . children def flags ( self , index ): if not index . isValid (): return constants . NO_FLAGS if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS def rowCount ( self , parent = core . ModelIndex ()) -> int : if parent . column () > 0 : return 0 if not parent . isValid (): return len ( self . items ) return len ( parent . internalPointer () . children ) def index ( self , row , column , parent ): if not self . hasIndex ( row , column , parent ): return core . ModelIndex () parent_item = parent . internalPointer () if not parent_item : parent_item = self . root return self . createIndex ( row , column , parent_item . children [ row ]) def parent ( self , index ): if not index . isValid (): return core . ModelIndex () item = index . internalPointer () if not item : return core . ModelIndex () if item . parent in [ self . root , None ]: return core . ModelIndex () return self . createIndex ( item . parent . row (), 0 , item . parent ) def data_by_index ( self , index ): return index . internalPointer () def json ( self , root = None ) -> dict : \"\"\"Serialise model as JSON-compliant dictionary. Arguments: root (JsonTreeItem, optional): Serialise from here defaults to the the top-level item Returns: model as dict \"\"\" root = root if root else self . root return root . as_json ()","title":"NestedModel"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.flags","text":"Required override for AbstractitemModels. returns corresponding flags for cell of supplied index Source code in prettyqt/custom_models/nestedmodel.py def flags ( self , index ): if not index . isValid (): return constants . NO_FLAGS if index . column () in self . SET_DATA : return self . DEFAULT_FLAGS | constants . IS_EDITABLE return self . DEFAULT_FLAGS","title":"flags()"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.index","text":"index(self, row: int, column: int, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/nestedmodel.py def index ( self , row , column , parent ): if not self . hasIndex ( row , column , parent ): return core . ModelIndex () parent_item = parent . internalPointer () if not parent_item : parent_item = self . root return self . createIndex ( row , column , parent_item . children [ row ])","title":"index()"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.json","text":"Serialise model as JSON-compliant dictionary. Parameters: Name Type Description Default root JsonTreeItem Serialise from here defaults to the the top-level item None Returns: Type Description dict model as dict Source code in prettyqt/custom_models/nestedmodel.py def json ( self , root = None ) -> dict : \"\"\"Serialise model as JSON-compliant dictionary. Arguments: root (JsonTreeItem, optional): Serialise from here defaults to the the top-level item Returns: model as dict \"\"\" root = root if root else self . root return root . as_json ()","title":"json()"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.parent","text":"parent(self) -> PySide6.QtCore.QObject parent(self, child: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/nestedmodel.py def parent ( self , index ): if not index . isValid (): return core . ModelIndex () item = index . internalPointer () if not item : return core . ModelIndex () if item . parent in [ self . root , None ]: return core . ModelIndex () return self . createIndex ( item . parent . row (), 0 , item . parent )","title":"parent()"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.rowCount","text":"Required override for AbstractitemModels. Source code in prettyqt/custom_models/nestedmodel.py def rowCount ( self , parent = core . ModelIndex ()) -> int : if parent . column () > 0 : return 0 if not parent . isValid (): return len ( self . items ) return len ( parent . internalPointer () . children )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel","text":"","title":"regexmatchesmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel","text":"Source code in prettyqt/custom_models/regexmatchesmodel.py class RegexMatchesModel ( core . AbstractTableModel ): HEADER = [ \"Start\" , \"End\" , \"Value\" , \"Groups\" ] def __init__ ( self , matches : list | None = None , parent : QtCore . QObject | None = None ): super () . __init__ ( parent = parent ) self . matches = matches if matches else list () def columnCount ( self , parent = None ): return len ( self . HEADER ) def headerData ( # type: ignore self , section : int , orientation : QtCore . Qt . Orientation , role : int ) -> str | None : if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ section ] def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span () def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches )","title":"RegexMatchesModel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.columnCount","text":"columnCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.data","text":"data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span ()","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.headerData","text":"headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def headerData ( # type: ignore self , section : int , orientation : QtCore . Qt . Orientation , role : int ) -> str | None : if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ section ]","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.rowCount","text":"Required override for AbstractitemModels. Source code in prettyqt/custom_models/regexmatchesmodel.py def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.storageinfomodel","text":"","title":"storageinfomodel"},{"location":"api/custom_models.html#prettyqt.custom_models.storageinfomodel.StorageInfoModel","text":"Source code in prettyqt/custom_models/storageinfomodel.py class StorageInfoModel ( core . AbstractTableModel ): ( ColumnRootPath , ColumnName , ColumnDevice , ColumnFileSystemName , ColumnTotal , ColumnFree , ColumnAvailable , ColumnIsReady , ColumnIsReadOnly , ColumnIsValid , ColumnCount , ) = range ( 11 ) columnFuncMap = { ColumnRootPath : lambda volume : str ( volume . get_root_path ()), ColumnName : lambda volume : volume . name (), ColumnDevice : lambda volume : volume . get_device (), ColumnFileSystemName : lambda volume : volume . get_file_system_type (), ColumnTotal : lambda volume : size_to_string ( volume . bytesTotal ()), ColumnFree : lambda volume : size_to_string ( volume . bytesFree ()), ColumnAvailable : lambda volume : size_to_string ( volume . bytesAvailable ()), ColumnIsReady : lambda volume : volume . isReady (), ColumnIsReadOnly : lambda volume : volume . isReadOnly (), ColumnIsValid : lambda volume : volume . isValid (), } columnNameMap = { ColumnRootPath : \"Root path\" , ColumnName : \"Volume Name\" , ColumnDevice : \"Device\" , ColumnFileSystemName : \"File system\" , ColumnTotal : \"Total\" , ColumnFree : \"Free\" , ColumnAvailable : \"Available\" , ColumnIsReady : \"Ready\" , ColumnIsReadOnly : \"Read-only\" , ColumnIsValid : \"Valid\" , } def __init__ ( self , parent : QtCore . QObject | None = None ): super () . __init__ ( parent ) self . volumes = core . StorageInfo . get_mounted_volumes () def columnCount ( self , parent = None ): return self . ColumnCount def rowCount ( self , parent ): if parent . isValid (): return 0 return len ( self . volumes ) def data ( self , index , role ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : volume = self . volumes [ index . row ()] func = self . columnFuncMap . get ( index . column ()) if func is not None : return func ( volume ) elif role == constants . TOOLTIP_ROLE : volume = self . volumes [ index . row ()] tooltip = [] for column in range ( self . ColumnCount ): label = self . columnNameMap . get ( column ) value = self . columnFuncMap [ column ]( volume ) tooltip . append ( f \" { label } : { value } \" ) return \" \\n \" . join ( tooltip ) def headerData ( self , section , orientation , role ): if orientation != constants . HORIZONTAL : return None if role != constants . DISPLAY_ROLE : return None return self . columnNameMap . get ( section )","title":"StorageInfoModel"},{"location":"api/custom_models.html#prettyqt.custom_models.storageinfomodel.StorageInfoModel.columnCount","text":"columnCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/storageinfomodel.py def columnCount ( self , parent = None ): return self . ColumnCount","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.storageinfomodel.StorageInfoModel.data","text":"data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/storageinfomodel.py def data ( self , index , role ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : volume = self . volumes [ index . row ()] func = self . columnFuncMap . get ( index . column ()) if func is not None : return func ( volume ) elif role == constants . TOOLTIP_ROLE : volume = self . volumes [ index . row ()] tooltip = [] for column in range ( self . ColumnCount ): label = self . columnNameMap . get ( column ) value = self . columnFuncMap [ column ]( volume ) tooltip . append ( f \" { label } : { value } \" ) return \" \\n \" . join ( tooltip )","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.storageinfomodel.StorageInfoModel.headerData","text":"headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/storageinfomodel.py def headerData ( self , section , orientation , role ): if orientation != constants . HORIZONTAL : return None if role != constants . DISPLAY_ROLE : return None return self . columnNameMap . get ( section )","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.storageinfomodel.StorageInfoModel.rowCount","text":"rowCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/storageinfomodel.py def rowCount ( self , parent ): if parent . isValid (): return 0 return len ( self . volumes )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.subsequencesortfilterproxymodel","text":"","title":"subsequencesortfilterproxymodel"},{"location":"api/custom_models.html#prettyqt.custom_models.subsequencesortfilterproxymodel.SubsequenceSortFilterProxyModel","text":"Source code in prettyqt/custom_models/subsequencesortfilterproxymodel.py class SubsequenceSortFilterProxyModel ( core . SortFilterProxyModel ): \"\"\"Performs subsequence matching/sorting.\"\"\" def __init__ ( self , case_sensitivity : bool , parent = None ): super () . __init__ ( parent ) self . case_sensitivity = case_sensitivity def set_prefix ( self , prefix : str ): self . filter_patterns = [] self . filter_patterns_case_sensitive = [] self . sort_patterns = [] flags = re . IGNORECASE if self . case_sensitivity is False else 0 for i in reversed ( range ( 1 , len ( prefix ) + 1 )): ptrn = f \".* { prefix [ 0 : i ] } .* { prefix [ i :] } \" try : self . filter_patterns . append ( re . compile ( ptrn , flags )) self . filter_patterns_case_sensitive . append ( re . compile ( ptrn , 0 )) ptrn = f \" { prefix [ 0 : i ] } .* { prefix [ i :] } \" self . sort_patterns . append ( re . compile ( ptrn , flags )) except Exception : continue self . prefix = prefix def filterAcceptsRow ( self , row , _ ): completion = self . sourceModel () . data ( self . sourceModel () . index ( row , 0 )) if completion is None or self . prefix is None : return False if len ( completion ) < len ( self . prefix ): return False if len ( self . prefix ) == 1 : try : prefix = self . prefix if self . case_sensitivity is False : completion = completion . lower () prefix = self . prefix . lower () rank = completion . index ( prefix ) idx = self . sourceModel () . index ( row , 0 ) self . sourceModel () . setData ( idx , rank , USER_ROLE ) # type: ignore return prefix in completion except ValueError : return False for i , patterns in enumerate ( zip ( self . filter_patterns , self . filter_patterns_case_sensitive , self . sort_patterns , ) ): pattern , pattern_case , sort_pattern = patterns match = re . match ( pattern , completion ) if match : # compute rank, the lowest rank the closer it is from the # completion start = MAX_SIZE for m in sort_pattern . finditer ( completion ): start , end = m . span () rank = start + i * 10 if re . match ( pattern_case , completion ): # favorise completions where case is matched rank -= 10 self . sourceModel () . setData ( idx , rank , USER_ROLE ) # type: ignore return True return len ( self . prefix ) == 0","title":"SubsequenceSortFilterProxyModel"},{"location":"api/custom_models.html#prettyqt.custom_models.subsequencesortfilterproxymodel.SubsequenceSortFilterProxyModel.filterAcceptsRow","text":"filterAcceptsRow(self, source_row: int, source_parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> bool Source code in prettyqt/custom_models/subsequencesortfilterproxymodel.py def filterAcceptsRow ( self , row , _ ): completion = self . sourceModel () . data ( self . sourceModel () . index ( row , 0 )) if completion is None or self . prefix is None : return False if len ( completion ) < len ( self . prefix ): return False if len ( self . prefix ) == 1 : try : prefix = self . prefix if self . case_sensitivity is False : completion = completion . lower () prefix = self . prefix . lower () rank = completion . index ( prefix ) idx = self . sourceModel () . index ( row , 0 ) self . sourceModel () . setData ( idx , rank , USER_ROLE ) # type: ignore return prefix in completion except ValueError : return False for i , patterns in enumerate ( zip ( self . filter_patterns , self . filter_patterns_case_sensitive , self . sort_patterns , ) ): pattern , pattern_case , sort_pattern = patterns match = re . match ( pattern , completion ) if match : # compute rank, the lowest rank the closer it is from the # completion start = MAX_SIZE for m in sort_pattern . finditer ( completion ): start , end = m . span () rank = start + i * 10 if re . match ( pattern_case , completion ): # favorise completions where case is matched rank -= 10 self . sourceModel () . setData ( idx , rank , USER_ROLE ) # type: ignore return True return len ( self . prefix ) == 0","title":"filterAcceptsRow()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel","text":"","title":"transposeproxymodel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel","text":"Source code in prettyqt/custom_models/transposeproxymodel.py class TransposeProxyModel ( core . AbstractProxyModel ): def __init__ ( self , source_model : QtCore . QAbstractItemModel ): super () . __init__ () self . _source_model = source_model self . setSourceModel ( source_model ) def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model ) def mapFromSource ( self , source_index : core . ModelIndex ) -> core . ModelIndex : return self . index ( source_index . column (), source_index . row ()) def mapToSource ( self , proxy_index : core . ModelIndex ) -> core . ModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ()) def index ( self , row : int , column : int , parent : core . ModelIndex | None = None ) -> core . ModelIndex : return self . createIndex ( row , column ) def parent ( self , index : core . ModelIndex ): # type: ignore return None def rowCount ( self , parent : core . ModelIndex | None = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . columnCount ( parent ) def columnCount ( self , parent : core . ModelIndex | None = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . rowCount ( parent ) def data ( self , index : core . ModelIndex , role = QtCore . Qt . ItemDataRole . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role ) def headerData ( self , section : int , orientation , role ): # type: ignore return self . _source_model . headerData ( section , orientation , role )","title":"TransposeProxyModel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.columnCount","text":"columnCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def columnCount ( self , parent : core . ModelIndex | None = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . rowCount ( parent )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.data","text":"data(self, proxyIndex: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def data ( self , index : core . ModelIndex , role = QtCore . Qt . ItemDataRole . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role )","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.headerData","text":"headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def headerData ( self , section : int , orientation , role ): # type: ignore return self . _source_model . headerData ( section , orientation , role )","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.index","text":"index(self, row: int, column: int, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def index ( self , row : int , column : int , parent : core . ModelIndex | None = None ) -> core . ModelIndex : return self . createIndex ( row , column )","title":"index()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapFromSource","text":"mapFromSource(self, sourceIndex: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapFromSource ( self , source_index : core . ModelIndex ) -> core . ModelIndex : return self . index ( source_index . column (), source_index . row ())","title":"mapFromSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapToSource","text":"mapToSource(self, proxyIndex: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapToSource ( self , proxy_index : core . ModelIndex ) -> core . ModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ())","title":"mapToSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.parent","text":"parent(self) -> PySide6.QtCore.QObject parent(self, child: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def parent ( self , index : core . ModelIndex ): # type: ignore return None","title":"parent()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.rowCount","text":"rowCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def rowCount ( self , parent : core . ModelIndex | None = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . columnCount ( parent )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.setSourceModel","text":"setSourceModel(self, sourceModel: PySide6.QtCore.QAbstractItemModel) -> None Source code in prettyqt/custom_models/transposeproxymodel.py def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"setSourceModel()"},{"location":"api/custom_validators.html","text":"custom_validators module Custom_validators module. Contains custom validators compositevalidator CompositeValidator ( Validator ) Source code in prettyqt/custom_validators/compositevalidator.py class CompositeValidator ( gui . Validator ): def __init__ ( self , validators : list [ gui . Validator ] | None = None , parent : QtCore . QObject | None = None , ): super () . __init__ ( parent ) self . validators = validators if validators is not None else [] def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . validators } )\" def __getitem__ ( self , index : int ) -> gui . Validator : return self . validators [ index ] def __setitem__ ( self , index : int , value : gui . Validator ): self . validators [ index ] = value def __delitem__ ( self , index : int ): del self . validators [ index ] def __contains__ ( self , index : int ): return index in self . validators def __iter__ ( self ) -> Iterator [ gui . Validator ]: return iter ( self . validators ) def __reduce__ ( self ): return type ( self ), ( self . validators ,) def __len__ ( self ): return len ( self . validators ) def __eq__ ( self , other : object ): if not isinstance ( other , type ( self )): return False return self . validators == other . validators def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] # type: ignore if self . State . Invalid in vals : return self . State . Invalid , text , pos elif self . State . Intermediate in vals : return self . State . Intermediate , text , pos else : return self . State . Acceptable , text , pos validate ( self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ] validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/compositevalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] # type: ignore if self . State . Invalid in vals : return self . State . Invalid , text , pos elif self . State . Intermediate in vals : return self . State . Intermediate , text , pos else : return self . State . Acceptable , text , pos integervalidator IntegerValidator ( Validator ) Source code in prettyqt/custom_validators/integervalidator.py class IntegerValidator ( gui . Validator ): def __init__ ( self , parent : QtCore . QObject | None = None ): super () . __init__ ( parent ) self . range : tuple [ int | None , int | None ] = ( None , None ) def set_range ( self , lower : int | None , upper : int | None ): self . range = ( lower , upper ) def validate ( self , text : str , pos : int ): if not text . lstrip ( \"-\" ): return self . State . Intermediate , text , len ( text ) if text . lstrip ( \"-\" ) . isnumeric (): left = float ( \"-inf\" ) if self . range [ 0 ] is None else self . range [ 0 ] right = float ( \"inf\" ) if self . range [ 1 ] is None else self . range [ 1 ] if left <= int ( text ) <= right : return self . State . Acceptable , text , len ( text ) return self . State . Invalid , text , len ( text ) validate ( self , text : str , pos : int ) validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/integervalidator.py def validate ( self , text : str , pos : int ): if not text . lstrip ( \"-\" ): return self . State . Intermediate , text , len ( text ) if text . lstrip ( \"-\" ) . isnumeric (): left = float ( \"-inf\" ) if self . range [ 0 ] is None else self . range [ 0 ] right = float ( \"inf\" ) if self . range [ 1 ] is None else self . range [ 1 ] if left <= int ( text ) <= right : return self . State . Acceptable , text , len ( text ) return self . State . Invalid , text , len ( text ) notemptyvalidator NotEmptyValidator ( Validator ) Source code in prettyqt/custom_validators/notemptyvalidator.py class NotEmptyValidator ( gui . Validator ): def __eq__ ( self , other : object ): return isinstance ( other , NotEmptyValidator ) def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if text == \"\" : return ( self . State . Intermediate , text , pos ) return self . State . Acceptable , text , pos validate ( self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ] validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/notemptyvalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if text == \"\" : return ( self . State . Intermediate , text , pos ) return self . State . Acceptable , text , pos notzerovalidator NotZeroValidator ( Validator ) Source code in prettyqt/custom_validators/notzerovalidator.py class NotZeroValidator ( gui . Validator ): def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if text == \"0\" : return self . State . Intermediate , text , pos return self . State . Acceptable , text , pos def __eq__ ( self , other : object ): return isinstance ( other , NotZeroValidator ) validate ( self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ] validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/notzerovalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if text == \"0\" : return self . State . Intermediate , text , pos return self . State . Acceptable , text , pos pathvalidator PathValidator ( Validator ) Source code in prettyqt/custom_validators/pathvalidator.py class PathValidator ( gui . Validator ): def __eq__ ( self , other : object ): return isinstance ( other , PathValidator ) def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return self . State . Acceptable , text , pos return self . State . Intermediate , text , pos validate ( self , text : str , pos : int = 0 ) validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/pathvalidator.py def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return self . State . Acceptable , text , pos return self . State . Intermediate , text , pos regexpatternvalidator RegexPatternValidator ( Validator ) Source code in prettyqt/custom_validators/regexpatternvalidator.py class RegexPatternValidator ( gui . Validator ): error_occured = core . Signal ( str ) pattern_updated = core . Signal ( object ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def __eq__ ( self , other : object ): return isinstance ( other , type ( self )) def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : compiled = re . compile ( text ) except sre_constants . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . State . Intermediate , text , pos except re . _regex_core . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . State . Intermediate , text , pos else : self . error_occured . emit ( \"\" ) self . pattern_updated . emit ( compiled ) return self . State . Acceptable , text , pos validate ( self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ] validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/regexpatternvalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : compiled = re . compile ( text ) except sre_constants . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . State . Intermediate , text , pos except re . _regex_core . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . State . Intermediate , text , pos else : self . error_occured . emit ( \"\" ) self . pattern_updated . emit ( compiled ) return self . State . Acceptable , text , pos regexvalidators BaseRegexValidator ( Validator ) Source code in prettyqt/custom_validators/regexvalidators.py class BaseRegexValidator ( gui . Validator ): def __init__ ( self , parent : QtCore . QObject | None = None , regex : PatternType | None = None ): super () . __init__ ( parent ) self . regex : Pattern | None = None if regex : self . set_regex ( regex ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_regex () !r} )\" def __reduce__ ( self ): return type ( self ), ( self . get_regex (),) def __eq__ ( self , other : object ): if not isinstance ( other , type ( self )): return False return self . regex == other . regex def set_regex ( self , regex : PatternType ): if isinstance ( regex , str ): self . regex = re . compile ( regex ) else : self . regex = regex def get_regex ( self ) -> str : if self . regex is None : raise TypeError ( \"Validator not initialized\" ) return self . regex . pattern def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return self . State . Intermediate , text , pos match = self . regex . match ( text , partial = True ) # type: ignore if match is None : return self . State . Invalid , text , pos elif match . partial : # type: ignore return self . State . Intermediate , text , pos else : return self . State . Acceptable , text , pos validate ( self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ] validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/regexvalidators.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return self . State . Intermediate , text , pos match = self . regex . match ( text , partial = True ) # type: ignore if match is None : return self . State . Invalid , text , pos elif match . partial : # type: ignore return self . State . Intermediate , text , pos else : return self . State . Acceptable , text , pos","title":"custom_validators"},{"location":"api/custom_validators.html#custom_validators-module","text":"Custom_validators module. Contains custom validators","title":"custom_validators module"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator","text":"","title":"compositevalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator","text":"Source code in prettyqt/custom_validators/compositevalidator.py class CompositeValidator ( gui . Validator ): def __init__ ( self , validators : list [ gui . Validator ] | None = None , parent : QtCore . QObject | None = None , ): super () . __init__ ( parent ) self . validators = validators if validators is not None else [] def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . validators } )\" def __getitem__ ( self , index : int ) -> gui . Validator : return self . validators [ index ] def __setitem__ ( self , index : int , value : gui . Validator ): self . validators [ index ] = value def __delitem__ ( self , index : int ): del self . validators [ index ] def __contains__ ( self , index : int ): return index in self . validators def __iter__ ( self ) -> Iterator [ gui . Validator ]: return iter ( self . validators ) def __reduce__ ( self ): return type ( self ), ( self . validators ,) def __len__ ( self ): return len ( self . validators ) def __eq__ ( self , other : object ): if not isinstance ( other , type ( self )): return False return self . validators == other . validators def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] # type: ignore if self . State . Invalid in vals : return self . State . Invalid , text , pos elif self . State . Intermediate in vals : return self . State . Intermediate , text , pos else : return self . State . Acceptable , text , pos","title":"CompositeValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator.validate","text":"validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/compositevalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] # type: ignore if self . State . Invalid in vals : return self . State . Invalid , text , pos elif self . State . Intermediate in vals : return self . State . Intermediate , text , pos else : return self . State . Acceptable , text , pos","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.integervalidator","text":"","title":"integervalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.integervalidator.IntegerValidator","text":"Source code in prettyqt/custom_validators/integervalidator.py class IntegerValidator ( gui . Validator ): def __init__ ( self , parent : QtCore . QObject | None = None ): super () . __init__ ( parent ) self . range : tuple [ int | None , int | None ] = ( None , None ) def set_range ( self , lower : int | None , upper : int | None ): self . range = ( lower , upper ) def validate ( self , text : str , pos : int ): if not text . lstrip ( \"-\" ): return self . State . Intermediate , text , len ( text ) if text . lstrip ( \"-\" ) . isnumeric (): left = float ( \"-inf\" ) if self . range [ 0 ] is None else self . range [ 0 ] right = float ( \"inf\" ) if self . range [ 1 ] is None else self . range [ 1 ] if left <= int ( text ) <= right : return self . State . Acceptable , text , len ( text ) return self . State . Invalid , text , len ( text )","title":"IntegerValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.integervalidator.IntegerValidator.validate","text":"validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/integervalidator.py def validate ( self , text : str , pos : int ): if not text . lstrip ( \"-\" ): return self . State . Intermediate , text , len ( text ) if text . lstrip ( \"-\" ) . isnumeric (): left = float ( \"-inf\" ) if self . range [ 0 ] is None else self . range [ 0 ] right = float ( \"inf\" ) if self . range [ 1 ] is None else self . range [ 1 ] if left <= int ( text ) <= right : return self . State . Acceptable , text , len ( text ) return self . State . Invalid , text , len ( text )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator","text":"","title":"notemptyvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator","text":"Source code in prettyqt/custom_validators/notemptyvalidator.py class NotEmptyValidator ( gui . Validator ): def __eq__ ( self , other : object ): return isinstance ( other , NotEmptyValidator ) def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if text == \"\" : return ( self . State . Intermediate , text , pos ) return self . State . Acceptable , text , pos","title":"NotEmptyValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator.validate","text":"validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/notemptyvalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if text == \"\" : return ( self . State . Intermediate , text , pos ) return self . State . Acceptable , text , pos","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator","text":"","title":"notzerovalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator","text":"Source code in prettyqt/custom_validators/notzerovalidator.py class NotZeroValidator ( gui . Validator ): def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if text == \"0\" : return self . State . Intermediate , text , pos return self . State . Acceptable , text , pos def __eq__ ( self , other : object ): return isinstance ( other , NotZeroValidator )","title":"NotZeroValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator.validate","text":"validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/notzerovalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if text == \"0\" : return self . State . Intermediate , text , pos return self . State . Acceptable , text , pos","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator","text":"","title":"pathvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator","text":"Source code in prettyqt/custom_validators/pathvalidator.py class PathValidator ( gui . Validator ): def __eq__ ( self , other : object ): return isinstance ( other , PathValidator ) def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return self . State . Acceptable , text , pos return self . State . Intermediate , text , pos","title":"PathValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator.validate","text":"validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/pathvalidator.py def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return self . State . Acceptable , text , pos return self . State . Intermediate , text , pos","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator","text":"","title":"regexpatternvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator","text":"Source code in prettyqt/custom_validators/regexpatternvalidator.py class RegexPatternValidator ( gui . Validator ): error_occured = core . Signal ( str ) pattern_updated = core . Signal ( object ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def __eq__ ( self , other : object ): return isinstance ( other , type ( self )) def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : compiled = re . compile ( text ) except sre_constants . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . State . Intermediate , text , pos except re . _regex_core . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . State . Intermediate , text , pos else : self . error_occured . emit ( \"\" ) self . pattern_updated . emit ( compiled ) return self . State . Acceptable , text , pos","title":"RegexPatternValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator.validate","text":"validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/regexpatternvalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : compiled = re . compile ( text ) except sre_constants . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . State . Intermediate , text , pos except re . _regex_core . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . State . Intermediate , text , pos else : self . error_occured . emit ( \"\" ) self . pattern_updated . emit ( compiled ) return self . State . Acceptable , text , pos","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators","text":"","title":"regexvalidators"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator","text":"Source code in prettyqt/custom_validators/regexvalidators.py class BaseRegexValidator ( gui . Validator ): def __init__ ( self , parent : QtCore . QObject | None = None , regex : PatternType | None = None ): super () . __init__ ( parent ) self . regex : Pattern | None = None if regex : self . set_regex ( regex ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_regex () !r} )\" def __reduce__ ( self ): return type ( self ), ( self . get_regex (),) def __eq__ ( self , other : object ): if not isinstance ( other , type ( self )): return False return self . regex == other . regex def set_regex ( self , regex : PatternType ): if isinstance ( regex , str ): self . regex = re . compile ( regex ) else : self . regex = regex def get_regex ( self ) -> str : if self . regex is None : raise TypeError ( \"Validator not initialized\" ) return self . regex . pattern def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return self . State . Intermediate , text , pos match = self . regex . match ( text , partial = True ) # type: ignore if match is None : return self . State . Invalid , text , pos elif match . partial : # type: ignore return self . State . Intermediate , text , pos else : return self . State . Acceptable , text , pos","title":"BaseRegexValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator.validate","text":"validate(self, arg__1: str, arg__2: int) -> object Source code in prettyqt/custom_validators/regexvalidators.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> tuple [ QtGui . QValidator . State , str , int ]: if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return self . State . Intermediate , text , pos match = self . regex . match ( text , partial = True ) # type: ignore if match is None : return self . State . Invalid , text , pos elif match . partial : # type: ignore return self . State . Intermediate , text , pos else : return self . State . Acceptable , text , pos","title":"validate()"},{"location":"api/custom_widgets.html","text":"custom_widgets module Module containing custom widget classes. borderlayout BorderLayout ( Layout ) Source code in prettyqt/custom_widgets/borderlayout.py class BorderLayout ( widgets . Layout ): class Position ( enum . IntEnum ): \"\"\"Item position.\"\"\" West = 0 North = 1 South = 2 East = 3 Center = 4 QtCore . QEnum ( Position ) def __init__ ( self , parent : QtWidgets . QWidget | None = None , margin : int = 0 , spacing : int | None = None , ): super () . __init__ ( parent ) # type: ignore self . set_margin ( margin ) self . setSpacing ( spacing if spacing is not None else - 1 ) self . items : list [ ItemWrapper ] = [] def __del__ ( self ): item = self . takeAt ( 0 ) while item : item = self . takeAt ( 0 ) def addItem ( self , item : QtWidgets . QWidgetItem ): self . add_widgetitem ( item , BorderLayout . Position . West ) def addWidget ( self , widget : QtWidgets . QWidget , position : Position = Position . West , ): self . add_widgetitem ( widgets . WidgetItem ( widget ), position ) def expandingDirections ( self ): return constants . HORIZONTAL | constants . VERTICAL # type: ignore def hasHeightForWidth ( self ) -> bool : return False def count ( self ) -> int : return len ( self . items ) def itemAt ( self , index : int ) -> QtWidgets . QWidgetItem | None : # type: ignore if index < len ( self . items ): return self . items [ index ] . item return None def minimumSize ( self ): return self . calculate_size ( \"minimum\" ) def setGeometry ( self , rect : QtCore . QRect ): center = None east_width = 0 west_width = 0 north_height = 0 south_height = 0 super () . setGeometry ( rect ) for wrapper in self . items : item = wrapper . item position = wrapper . position if position == BorderLayout . Position . North : geom = core . Rect ( rect . x (), north_height , rect . width (), item . sizeHint () . height () ) item . setGeometry ( geom ) north_height += item . geometry () . height () + self . spacing () elif position == BorderLayout . Position . South : geom = core . Rect ( item . geometry () . x (), item . geometry () . y (), rect . width (), item . sizeHint () . height (), ) item . setGeometry ( geom ) south_height += item . geometry () . height () + self . spacing () geom = core . Rect ( rect . x (), rect . y () + rect . height () - south_height + self . spacing (), item . geometry () . width (), item . geometry () . height (), ) item . setGeometry ( geom ) elif position == BorderLayout . Position . Center : center = wrapper center_height = rect . height () - north_height - south_height for wrapper in self . items : item = wrapper . item position = wrapper . position if position == BorderLayout . Position . West : geom = core . Rect ( rect . x () + west_width , north_height , item . sizeHint () . width (), center_height , ) item . setGeometry ( geom ) west_width += item . geometry () . width () + self . spacing () elif position == BorderLayout . Position . East : geom = core . Rect ( item . geometry () . x (), item . geometry () . y (), item . sizeHint () . width (), center_height , ) item . setGeometry ( geom ) east_width += item . geometry () . width () + self . spacing () geom = core . Rect ( rect . x () + rect . width () - east_width + self . spacing (), north_height , item . geometry () . width (), item . geometry () . height (), ) item . setGeometry ( geom ) if center : rect = core . Rect ( west_width , north_height , rect . width () - east_width - west_width , center_height , ) center . item . setGeometry ( rect ) def sizeHint ( self ) -> core . Size : return self . calculate_size ( \"size_hint\" ) def takeAt ( self , index : int ) -> QtWidgets . QWidgetItem | None : # type: ignore if 0 <= index < len ( self . items ): layout_struct = self . items . pop ( index ) return layout_struct . item return None def add_widgetitem ( self , item : QtWidgets . QWidgetItem , position : Position ): self . items . append ( ItemWrapper ( item , position )) def calculate_size ( self , size_type : Literal [ \"minimum\" , \"size_hint\" ]) -> core . Size : total_size = core . Size () for wrapper in self . items : position = wrapper . position if size_type == \"minimum\" : item_size = wrapper . item . minimumSize () else : # size_type == \"size_hint\" item_size = wrapper . item . sizeHint () if position in ( BorderLayout . Position . North , BorderLayout . Position . South , BorderLayout . Position . Center , ): total_size . setHeight ( total_size . height () + item_size . height ()) if position in ( BorderLayout . Position . West , BorderLayout . Position . East , BorderLayout . Position . Center , ): total_size . setWidth ( total_size . width () + item_size . width ()) return total_size Position ( IntEnum ) Item position. Source code in prettyqt/custom_widgets/borderlayout.py class Position ( enum . IntEnum ): \"\"\"Item position.\"\"\" West = 0 North = 1 South = 2 East = 3 Center = 4 addItem ( self , item : QtWidgets . QWidgetItem ) addItem(self, arg__1: PySide6.QtWidgets.QLayoutItem) -> None Source code in prettyqt/custom_widgets/borderlayout.py def addItem ( self , item : QtWidgets . QWidgetItem ): self . add_widgetitem ( item , BorderLayout . Position . West ) addWidget ( self , widget : QtWidgets . QWidget , position : Position = < Position . West : 0 > ) addWidget(self, w: PySide6.QtWidgets.QWidget) -> None Source code in prettyqt/custom_widgets/borderlayout.py def addWidget ( self , widget : QtWidgets . QWidget , position : Position = Position . West , ): self . add_widgetitem ( widgets . WidgetItem ( widget ), position ) count ( self ) -> int count(self) -> int Source code in prettyqt/custom_widgets/borderlayout.py def count ( self ) -> int : return len ( self . items ) expandingDirections ( self ) expandingDirections(self) -> PySide6.QtCore.Qt.Orientation Source code in prettyqt/custom_widgets/borderlayout.py def expandingDirections ( self ): return constants . HORIZONTAL | constants . VERTICAL # type: ignore hasHeightForWidth ( self ) -> bool hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/borderlayout.py def hasHeightForWidth ( self ) -> bool : return False itemAt ( self , index : int ) -> QtWidgets . QWidgetItem | None itemAt(self, index: int) -> PySide6.QtWidgets.QLayoutItem Source code in prettyqt/custom_widgets/borderlayout.py def itemAt ( self , index : int ) -> QtWidgets . QWidgetItem | None : # type: ignore if index < len ( self . items ): return self . items [ index ] . item return None minimumSize ( self ) minimumSize(self) -> PySide6.QtCore.QSize Source code in prettyqt/custom_widgets/borderlayout.py def minimumSize ( self ): return self . calculate_size ( \"minimum\" ) setGeometry ( self , rect : QtCore . QRect ) setGeometry(self, arg__1: PySide6.QtCore.QRect) -> None Source code in prettyqt/custom_widgets/borderlayout.py def setGeometry ( self , rect : QtCore . QRect ): center = None east_width = 0 west_width = 0 north_height = 0 south_height = 0 super () . setGeometry ( rect ) for wrapper in self . items : item = wrapper . item position = wrapper . position if position == BorderLayout . Position . North : geom = core . Rect ( rect . x (), north_height , rect . width (), item . sizeHint () . height () ) item . setGeometry ( geom ) north_height += item . geometry () . height () + self . spacing () elif position == BorderLayout . Position . South : geom = core . Rect ( item . geometry () . x (), item . geometry () . y (), rect . width (), item . sizeHint () . height (), ) item . setGeometry ( geom ) south_height += item . geometry () . height () + self . spacing () geom = core . Rect ( rect . x (), rect . y () + rect . height () - south_height + self . spacing (), item . geometry () . width (), item . geometry () . height (), ) item . setGeometry ( geom ) elif position == BorderLayout . Position . Center : center = wrapper center_height = rect . height () - north_height - south_height for wrapper in self . items : item = wrapper . item position = wrapper . position if position == BorderLayout . Position . West : geom = core . Rect ( rect . x () + west_width , north_height , item . sizeHint () . width (), center_height , ) item . setGeometry ( geom ) west_width += item . geometry () . width () + self . spacing () elif position == BorderLayout . Position . East : geom = core . Rect ( item . geometry () . x (), item . geometry () . y (), item . sizeHint () . width (), center_height , ) item . setGeometry ( geom ) east_width += item . geometry () . width () + self . spacing () geom = core . Rect ( rect . x () + rect . width () - east_width + self . spacing (), north_height , item . geometry () . width (), item . geometry () . height (), ) item . setGeometry ( geom ) if center : rect = core . Rect ( west_width , north_height , rect . width () - east_width - west_width , center_height , ) center . item . setGeometry ( rect ) sizeHint ( self ) -> core . Size sizeHint(self) -> PySide6.QtCore.QSize Source code in prettyqt/custom_widgets/borderlayout.py def sizeHint ( self ) -> core . Size : return self . calculate_size ( \"size_hint\" ) takeAt ( self , index : int ) -> QtWidgets . QWidgetItem | None takeAt(self, index: int) -> PySide6.QtWidgets.QLayoutItem Source code in prettyqt/custom_widgets/borderlayout.py def takeAt ( self , index : int ) -> QtWidgets . QWidgetItem | None : # type: ignore if 0 <= index < len ( self . items ): layout_struct = self . items . pop ( index ) return layout_struct . item return None ItemWrapper dataclass ItemWrapper(item: 'QtWidgets.QWidgetItem', position: 'BorderLayout.Position') Source code in prettyqt/custom_widgets/borderlayout.py @dataclass class ItemWrapper : item : QtWidgets . QWidgetItem position : BorderLayout . Position codeeditor CodeEditor ( PlainTextEdit ) Source code in prettyqt/custom_widgets/codeeditor.py class CodeEditor ( widgets . PlainTextEdit ): def __init__ ( self , language : str = \"python\" , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent = parent ) self . line_area = LineNumberArea ( self ) self . blockCountChanged . connect ( self . update_line_area_width ) self . updateRequest . connect ( self . update_line_area ) self . cursorPositionChanged . connect ( self . highlight_current_line ) self . set_font ( \"Consolas\" ) self . update_line_area_width ( 0 ) self . highlight_current_line () self . set_syntaxhighlighter ( language ) def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect ) def text ( self ) -> str : return self . toPlainText () def line_area_width ( self ) -> int : digits = len ( str ( self . blockCount ())) return 3 + self . fontMetrics () . boundingRect ( \"9\" ) . width () * digits def update_line_area_width ( self , _ ): self . setViewportMargins ( self . line_area_width (), 0 , 0 , 0 ) def update_line_area ( self , rect : QtCore . QRect , dy : int ): if dy : self . line_area . scroll ( 0 , dy ) else : self . line_area . update ( 0 , rect . y (), self . line_area . width (), rect . height ()) if rect . contains ( self . viewport () . rect ()): self . update_line_area_width ( 0 ) def line_area_paintevent ( self , event ): with gui . Painter ( self . line_area ) as painter : painter . fill_rect ( event . rect (), \"lightgray\" ) block = self . firstVisibleBlock () block_number = block . blockNumber () top = self . blockBoundingGeometry ( block ) . translated ( self . contentOffset ()) . top () bottom = top + self . blockBoundingRect ( block ) . height () width = self . line_area . width () height = self . fontMetrics () . height () painter . set_color ( \"black\" ) while block . isValid () and ( top <= event . rect () . bottom ()): if block . isVisible () and ( bottom >= event . rect () . top ()): number = str ( block_number + 1 ) painter . drawText ( 0 , int ( top ), width , height , constants . ALIGN_RIGHT , number ) block = block . next () top = bottom bottom = top + self . blockBoundingRect ( block ) . height () block_number += 1 resizeEvent ( self , event ) resizeEvent(self, e: PySide6.QtGui.QResizeEvent) -> None Source code in prettyqt/custom_widgets/codeeditor.py def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect ) LineNumberArea ( Widget ) Source code in prettyqt/custom_widgets/codeeditor.py class LineNumberArea ( widgets . Widget ): def __init__ ( self , editor : CodeEditor ): super () . __init__ ( editor ) self . editor = editor def sizeHint ( self ) -> core . Size : return core . Size ( self . editor . line_area_width (), 0 ) def paintEvent ( self , event ): self . editor . line_area_paintevent ( event ) paintEvent ( self , event ) paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/codeeditor.py def paintEvent ( self , event ): self . editor . line_area_paintevent ( event ) sizeHint ( self ) -> core . Size sizeHint(self) -> PySide6.QtCore.QSize Source code in prettyqt/custom_widgets/codeeditor.py def sizeHint ( self ) -> core . Size : return core . Size ( self . editor . line_area_width (), 0 ) completionwidget A dropdown completer widget for the text edits. CompletionWidget ( ListWidget ) Source code in prettyqt/custom_widgets/completionwidget.py class CompletionWidget ( widgets . ListWidget ): def __init__ ( self , textedit : QtWidgets . QTextEdit | QtWidgets . QPlainTextEdit ): super () . __init__ ( parent = textedit ) self . _text_edit = textedit self . set_edit_triggers ( \"none\" ) self . set_selection_behaviour ( \"rows\" ) self . set_selection_mode ( \"single\" ) # We need Popup style to ensure correct mouse interaction # (dialog would dissappear on mouse click with ToolTip style) self . setWindowFlags ( QtCore . Qt . WindowType . Popup ) # type: ignore self . setAttribute ( QtCore . Qt . WidgetAttribute . WA_StaticContents ) original_policy = self . _text_edit . focusPolicy () self . set_focus_policy ( \"none\" ) self . _text_edit . setFocusPolicy ( original_policy ) # Ensure that the text edit keeps focus when widget is displayed. self . setFocusProxy ( self . _text_edit ) self . set_frame_shadow ( \"plain\" ) self . set_frame_shape ( \"styled_panel\" ) self . itemActivated . connect ( self . _complete_current ) def eventFilter ( self , obj , event ): \"\"\"Handle mouse input and to auto-hide when losing focus.\"\"\" if obj is self : if event . type () == QtCore . QEvent . Type . MouseButtonPress : pos = self . mapToGlobal ( event . pos ()) target = QtWidgets . QApplication . widgetAt ( pos ) if target and self . isAncestorOf ( target ) or target is self : return False else : self . cancel_completion () return super () . eventFilter ( obj , event ) def keyPressEvent ( self , event ): key = event . key () if key in ( QtCore . Qt . Key . Key_Return , QtCore . Qt . Key . Key_Enter , QtCore . Qt . Key . Key_Tab , ): self . _complete_current () elif key == QtCore . Qt . Key . Key_Escape : self . hide () elif key in ( QtCore . Qt . Key . Key_Up , QtCore . Qt . Key . Key_Down , QtCore . Qt . Key . Key_PageUp , QtCore . Qt . Key . Key_PageDown , QtCore . Qt . Key . Key_Home , QtCore . Qt . Key . Key_End , ): return super () . keyPressEvent ( event ) else : QtWidgets . QApplication . sendEvent ( self . _text_edit , event ) # 'QWidget' interface def hideEvent ( self , event ): \"\"\"Disconnect signal handlers and event filter.\"\"\" super () . hideEvent ( event ) try : self . _text_edit . cursorPositionChanged . disconnect ( self . _update_current ) except TypeError : pass self . removeEventFilter ( self ) def showEvent ( self , event ): \"\"\"Connect signal handlers and event filter.\"\"\" super () . showEvent ( event ) self . _text_edit . cursorPositionChanged . connect ( self . _update_current ) self . installEventFilter ( self ) # 'CompletionWidget' interface def show_items ( self , cursor , items : list [ str ], prefix_length : int = 0 ): \"\"\"Show the widget with 'items' at the position specified by 'cursor'.\"\"\" point = self . _get_top_left_position ( cursor ) self . clear () path_items = [] for item in items : # Check if the item could refer to a file or dir. The replacing # of '\"' is needed for items on Windows path = os . path . abspath ( item . replace ( '\"' , \"\" )) if os . path . isfile ( path ) or os . path . isdir ( path ): path_items . append ( item . replace ( '\"' , \"\" )) else : list_item = widgets . ListWidgetItem () list_item . setData ( QtCore . Qt . ItemDataRole . UserRole , item ) # type: ignore # Need to split to only show last element of a dot completion list_item . setText ( item . split ( \".\" )[ - 1 ]) self . addItem ( list_item ) common_prefix = os . path . dirname ( os . path . commonprefix ( path_items )) for path_item in path_items : list_item = widgets . ListWidgetItem () list_item . setData ( QtCore . Qt . ItemDataRole . UserRole , path_item ) # type: ignore text = path_item . split ( common_prefix )[ - 1 ] if common_prefix else path_item list_item . setText ( text ) self . addItem ( list_item ) height = self . sizeHint () . height () screen_rect = self . get_screen () . availableGeometry () if screen_rect . size () . height () + screen_rect . y () - point . y () - height < 0 : point = self . _text_edit . mapToGlobal ( self . _text_edit . cursorRect () . topRight ()) point . setY ( int ( point . y () - height )) scrollbar_width = self . verticalScrollBar () . sizeHint () . width () w = self . sizeHintForColumn ( 0 ) + scrollbar_width + 2 * self . frameWidth () self . setGeometry ( point . x (), point . y (), w , height ) # Move cursor to start of the prefix to replace it # when a item is selected cursor . movePosition ( QtGui . QTextCursor . MoveOperation . Left , n = prefix_length ) self . _start_position = cursor . position () self . setCurrentRow ( 0 ) self . raise_ () self . show () # Protected interface def _get_top_left_position ( self , cursor : QtGui . QTextCursor ) -> QtCore . QPoint : \"\"\"Get top left position for this widget.\"\"\" point = self . _text_edit . cursorRect ( cursor ) . center () point_size = self . _text_edit . font () . pointSize () factor = 1.05 if os . name == \"nt\" else 0.98 delta = int (( point_size * 1.20 ) ** factor ) y = delta - ( point_size // 2 ) point . setY ( int ( point . y () + y )) point = self . _text_edit . mapToGlobal ( point ) return point def _complete_current ( self ): \"\"\"Perform the completion with the currently selected item.\"\"\" text = self . currentItem () . data ( QtCore . Qt . ItemDataRole . UserRole ) # type: ignore self . _current_text_cursor () . insertText ( text ) self . hide () def _current_text_cursor ( self ) -> gui . TextCursor : \"\"\"Return a cursor with text between the start and currentposition selected.\"\"\" cursor = self . _text_edit . get_text_cursor () if cursor . position () >= self . _start_position : cursor . setPosition ( self . _start_position , gui . TextCursor . MoveMode . KeepAnchor ) return cursor def _update_current ( self ): \"\"\"Update the current item based on the current text and the widget position.\"\"\" # Update widget position cursor = self . _text_edit . get_text_cursor () point = self . _get_top_left_position ( cursor ) self . move ( point ) # Update current item prefix = self . _current_text_cursor () . selection () . toPlainText () if prefix : flags = ( QtCore . Qt . MatchFlag . MatchStartsWith # type: ignore | QtCore . Qt . MatchFlag . MatchCaseSensitive ) items = self . findItems ( prefix , flags ) if items : self . setCurrentItem ( items [ 0 ]) else : self . hide () else : self . hide () def cancel_completion ( self ): self . hide () eventFilter ( self , obj , event ) Handle mouse input and to auto-hide when losing focus. Source code in prettyqt/custom_widgets/completionwidget.py def eventFilter ( self , obj , event ): \"\"\"Handle mouse input and to auto-hide when losing focus.\"\"\" if obj is self : if event . type () == QtCore . QEvent . Type . MouseButtonPress : pos = self . mapToGlobal ( event . pos ()) target = QtWidgets . QApplication . widgetAt ( pos ) if target and self . isAncestorOf ( target ) or target is self : return False else : self . cancel_completion () return super () . eventFilter ( obj , event ) hideEvent ( self , event ) Disconnect signal handlers and event filter. Source code in prettyqt/custom_widgets/completionwidget.py def hideEvent ( self , event ): \"\"\"Disconnect signal handlers and event filter.\"\"\" super () . hideEvent ( event ) try : self . _text_edit . cursorPositionChanged . disconnect ( self . _update_current ) except TypeError : pass self . removeEventFilter ( self ) keyPressEvent ( self , event ) keyPressEvent(self, event: PySide6.QtGui.QKeyEvent) -> None Source code in prettyqt/custom_widgets/completionwidget.py def keyPressEvent ( self , event ): key = event . key () if key in ( QtCore . Qt . Key . Key_Return , QtCore . Qt . Key . Key_Enter , QtCore . Qt . Key . Key_Tab , ): self . _complete_current () elif key == QtCore . Qt . Key . Key_Escape : self . hide () elif key in ( QtCore . Qt . Key . Key_Up , QtCore . Qt . Key . Key_Down , QtCore . Qt . Key . Key_PageUp , QtCore . Qt . Key . Key_PageDown , QtCore . Qt . Key . Key_Home , QtCore . Qt . Key . Key_End , ): return super () . keyPressEvent ( event ) else : QtWidgets . QApplication . sendEvent ( self . _text_edit , event ) showEvent ( self , event ) Connect signal handlers and event filter. Source code in prettyqt/custom_widgets/completionwidget.py def showEvent ( self , event ): \"\"\"Connect signal handlers and event filter.\"\"\" super () . showEvent ( event ) self . _text_edit . cursorPositionChanged . connect ( self . _update_current ) self . installEventFilter ( self ) show_items ( self , cursor , items : list [ str ], prefix_length : int = 0 ) Show the widget with 'items' at the position specified by 'cursor'. Source code in prettyqt/custom_widgets/completionwidget.py def show_items ( self , cursor , items : list [ str ], prefix_length : int = 0 ): \"\"\"Show the widget with 'items' at the position specified by 'cursor'.\"\"\" point = self . _get_top_left_position ( cursor ) self . clear () path_items = [] for item in items : # Check if the item could refer to a file or dir. The replacing # of '\"' is needed for items on Windows path = os . path . abspath ( item . replace ( '\"' , \"\" )) if os . path . isfile ( path ) or os . path . isdir ( path ): path_items . append ( item . replace ( '\"' , \"\" )) else : list_item = widgets . ListWidgetItem () list_item . setData ( QtCore . Qt . ItemDataRole . UserRole , item ) # type: ignore # Need to split to only show last element of a dot completion list_item . setText ( item . split ( \".\" )[ - 1 ]) self . addItem ( list_item ) common_prefix = os . path . dirname ( os . path . commonprefix ( path_items )) for path_item in path_items : list_item = widgets . ListWidgetItem () list_item . setData ( QtCore . Qt . ItemDataRole . UserRole , path_item ) # type: ignore text = path_item . split ( common_prefix )[ - 1 ] if common_prefix else path_item list_item . setText ( text ) self . addItem ( list_item ) height = self . sizeHint () . height () screen_rect = self . get_screen () . availableGeometry () if screen_rect . size () . height () + screen_rect . y () - point . y () - height < 0 : point = self . _text_edit . mapToGlobal ( self . _text_edit . cursorRect () . topRight ()) point . setY ( int ( point . y () - height )) scrollbar_width = self . verticalScrollBar () . sizeHint () . width () w = self . sizeHintForColumn ( 0 ) + scrollbar_width + 2 * self . frameWidth () self . setGeometry ( point . x (), point . y (), w , height ) # Move cursor to start of the prefix to replace it # when a item is selected cursor . movePosition ( QtGui . QTextCursor . MoveOperation . Left , n = prefix_length ) self . _start_position = cursor . position () self . setCurrentRow ( 0 ) self . raise_ () self . show () dataset DataItem Source code in prettyqt/custom_widgets/dataset.py class DataItem : def __init__ ( self , label : str , value = None , optional : str | None = None , include : bool = True , enabled_on = None , disabled_on = None , ): self . set_value ( value ) self . enabled_on = [ enabled_on ] if enabled_on else list () self . disabled_on = [ disabled_on ] if disabled_on else list () self . name = None self . label = label self . optional = optional self . include = include self . colspan = 1 self . label_col = 0 self . is_enabled = True def __get__ ( self , instance , owner ): return self . value def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self def set_value ( self , value ): self . value = value def store ( self , prop ): # self.set_prop(\"display\", store=prop) return self def is_valid ( self ): return True def create_widget ( self ): widget = self . _create_widget () if self . optional : return custom_widgets . OptionalWidget ( widget , self . optional ) return widget def _create_widget ( self ): return None set_pos ( self , col = 0 , colspan = None ) Set data item's position on a GUI layout. Source code in prettyqt/custom_widgets/dataset.py def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self DataSetMeta ( type ) Source code in prettyqt/custom_widgets/dataset.py class DataSetMeta ( type ): def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct ) __new__ ( mcs , name , bases , dct ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct ) elidedlabel ElidedLabel ( Frame ) Source code in prettyqt/custom_widgets/elidedlabel.py class ElidedLabel ( widgets . Frame ): elision_changed = core . Signal ( bool ) def __init__ ( self , text : str = \"\" , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( parent = parent ) self . elided = False self . content = text self . set_size_policy ( \"expanding\" , \"preferred\" ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . text () !r} )\" def set_text ( self , text : str ): self . content = text self . update () def paintEvent ( self , event ): super () . paintEvent ( event ) painter = gui . Painter ( self ) metrics = painter . get_font_metrics () did_elide = False line_spacing = metrics . lineSpacing () y = 0 layout = gui . TextLayout ( self . content , painter . font ()) with layout . process_layout (): while True : line = layout . createLine () if not line . isValid (): break line . setLineWidth ( self . width ()) next_line_y = y + line_spacing if self . height () >= next_line_y + line_spacing : line . draw ( painter , core . Point ( 0 , y )) y = next_line_y else : last_line = self . content [ line . textStart () :] elided_line = metrics . elided_text ( last_line , \"right\" , self . width ()) painter . drawText ( 0 , y + metrics . ascent (), elided_line ) line = layout . createLine () did_elide = line . isValid () break if did_elide != self . elided : self . elided = did_elide self . elision_changed . emit ( did_elide ) # def paintEvent(self, event): # painter = gui.Painter(self) # metrics = gui.FontMetrics(self.font()) # elided = metrics.elided_text(self.text(), \"right\", self.width()) # painter.drawText(self.rect(), self.alignment(), elided) paintEvent ( self , event ) paintEvent(self, arg__1: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/elidedlabel.py def paintEvent ( self , event ): super () . paintEvent ( event ) painter = gui . Painter ( self ) metrics = painter . get_font_metrics () did_elide = False line_spacing = metrics . lineSpacing () y = 0 layout = gui . TextLayout ( self . content , painter . font ()) with layout . process_layout (): while True : line = layout . createLine () if not line . isValid (): break line . setLineWidth ( self . width ()) next_line_y = y + line_spacing if self . height () >= next_line_y + line_spacing : line . draw ( painter , core . Point ( 0 , y )) y = next_line_y else : last_line = self . content [ line . textStart () :] elided_line = metrics . elided_text ( last_line , \"right\" , self . width ()) painter . drawText ( 0 , y + metrics . ascent (), elided_line ) line = layout . createLine () did_elide = line . isValid () break if did_elide != self . elided : self . elided = did_elide self . elision_changed . emit ( did_elide ) filechooserbutton FileChooserButton ( Widget ) Source code in prettyqt/custom_widgets/filechooserbutton.py class FileChooserButton ( widgets . Widget ): value_changed = core . Signal ( pathlib . Path ) def __init__ ( self , extensions : dict [ str , list [ str ]] | None = None , mode : widgets . filedialog . AcceptModeStr = \"save\" , file_mode : widgets . filedialog . FileModeStr = \"existing_files\" , root : None | str | pathlib . Path = None , parent : QtWidgets . QWidget | None = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : pathlib . Path | None = None self . extensions = extensions self . mode : widgets . filedialog . AcceptModeStr = mode self . file_mode : widgets . filedialog . FileModeStr = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout . add ( self . lineedit ) action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout . add ( self . button ) def serialize_fields ( self ): return dict ( path = self . path , extensions = self . extensions , enabled = self . isEnabled ()) def __setstate__ ( self , state ): self . set_path ( state [ \"path\" ]) self . set_enabled ( state . get ( \"enabled\" , True )) def __reduce__ ( self ): return type ( self ), ( self . extensions ,), self . __getstate__ () @core . Slot () def open_file ( self ): dialog = widgets . FileDialog ( parent = self , path_id = \"file_path\" , mode = self . mode , path = self . root , file_mode = self . file_mode , ) if self . extensions : dialog . set_extension_filter ( self . extensions ) if not dialog . choose (): return self . set_path ( dialog . selected_file ()) self . value_changed . emit ( self . path ) def set_path ( self , path : types . PathType | None ): if path is None : self . path = None self . lineedit . set_text ( \"\" ) else : self . path = pathlib . Path ( path ) self . lineedit . set_text ( os . fspath ( path )) def get_value ( self ) -> pathlib . Path | None : return self . path def set_value ( self , value : types . PathType | None ): self . set_path ( value ) __init__ ( self , extensions : dict [ str , list [ str ]] | None = None , mode : widgets . filedialog . AcceptModeStr = 'save' , file_mode : widgets . filedialog . FileModeStr = 'existing_files' , root : None | str | pathlib . Path = None , parent : QtWidgets . QWidget | None = None ) special Initialize FileChooserButton. Parameters: Name Type Description Default extensions dict[str, list[str]] | None dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode widgets.filedialog.AcceptModeStr Accept mode (\"save\" or \"load\") 'save' file_mode widgets.filedialog.FileModeStr File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' root None | str | pathlib.Path Root path None parent QtWidgets.QWidget | None parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py def __init__ ( self , extensions : dict [ str , list [ str ]] | None = None , mode : widgets . filedialog . AcceptModeStr = \"save\" , file_mode : widgets . filedialog . FileModeStr = \"existing_files\" , root : None | str | pathlib . Path = None , parent : QtWidgets . QWidget | None = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : pathlib . Path | None = None self . extensions = extensions self . mode : widgets . filedialog . AcceptModeStr = mode self . file_mode : widgets . filedialog . FileModeStr = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout . add ( self . lineedit ) action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout . add ( self . button ) flowlayout FlowLayout ( Layout ) Source code in prettyqt/custom_widgets/flowlayout.py class FlowLayout ( widgets . Layout ): def __init__ ( self , parent : QtWidgets . QWidget | None = None , margin : int | None = None , spacing : int = - 1 , ): super () . __init__ ( parent ) # type: ignore if margin is not None : self . set_margin ( margin ) self . set_spacing ( spacing ) self . items : list [ QtWidgets . QLayoutItem ] = [] def serialize_fields ( self ): return dict ( items = self . get_children ()) def __add__ ( self , other : QtWidgets . QWidget | QtWidgets . QLayout ) -> FlowLayout : if not isinstance ( other , ( QtWidgets . QWidget , QtWidgets . QLayout )): raise TypeError () self . add ( other ) return self def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __setstate__ ( self , state ): for item in state [ \"items\" ]: self . add ( item ) def __del__ ( self ): item = self . takeAt ( 0 ) while item : item = self . takeAt ( 0 ) def addItem ( self , item : QtWidgets . QLayoutItem ): self . items . append ( item ) def count ( self ) -> int : return len ( self . items ) def itemAt ( self , index : int ) -> QtWidgets . QLayoutItem | None : # type: ignore if 0 <= index < len ( self . items ): return self . items [ index ] return None def takeAt ( self , index : int ) -> QtWidgets . QLayoutItem | None : # type: ignore if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None # def expandingDirections(self) -> QtCore.Qt.Orientations: # return QtCore.Qt.Orientations(0) def hasHeightForWidth ( self ) -> bool : return True def heightForWidth ( self , width : int ) -> int : rect = QtCore . QRect ( 0 , 0 , width , 0 ) return self . do_layout ( rect , True ) def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False ) def sizeHint ( self ) -> QtCore . QSize : return self . minimumSize () def minimumSize ( self ) -> QtCore . QSize : size = QtCore . QSize () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += QtCore . QSize ( margin_width , margin_width ) return size def do_layout ( self , rect : QtCore . QRect , test_only : bool ) -> int : x = rect . x () y = rect . y () line_height = 0 space = self . spacing () pb = widgets . SizePolicy . ControlType . PushButton for item in self . items : wid = item . widget () space_x = space + wid . style () . layoutSpacing ( pb , pb , constants . HORIZONTAL ) next_x = x + item . sizeHint () . width () + space_x if next_x - space_x > rect . right () and line_height > 0 : x = rect . x () space_y = space + wid . style () . layoutSpacing ( pb , pb , constants . VERTICAL ) y = y + line_height + space_y next_x = x + item . sizeHint () . width () + space_x line_height = 0 if not test_only : item . setGeometry ( core . Rect ( core . Point ( x , y ), item . sizeHint ())) x = next_x line_height = max ( line_height , item . sizeHint () . height ()) return y + line_height - rect . y () addItem ( self , item : QtWidgets . QLayoutItem ) addItem(self, arg__1: PySide6.QtWidgets.QLayoutItem) -> None Source code in prettyqt/custom_widgets/flowlayout.py def addItem ( self , item : QtWidgets . QLayoutItem ): self . items . append ( item ) count ( self ) -> int count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py def count ( self ) -> int : return len ( self . items ) hasHeightForWidth ( self ) -> bool hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py def hasHeightForWidth ( self ) -> bool : return True heightForWidth ( self , width : int ) -> int heightForWidth(self, arg__1: int) -> int Source code in prettyqt/custom_widgets/flowlayout.py def heightForWidth ( self , width : int ) -> int : rect = QtCore . QRect ( 0 , 0 , width , 0 ) return self . do_layout ( rect , True ) itemAt ( self , index : int ) -> QtWidgets . QLayoutItem | None itemAt(self, index: int) -> PySide6.QtWidgets.QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def itemAt ( self , index : int ) -> QtWidgets . QLayoutItem | None : # type: ignore if 0 <= index < len ( self . items ): return self . items [ index ] return None minimumSize ( self ) -> QtCore . QSize minimumSize(self) -> PySide6.QtCore.QSize Source code in prettyqt/custom_widgets/flowlayout.py def minimumSize ( self ) -> QtCore . QSize : size = QtCore . QSize () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += QtCore . QSize ( margin_width , margin_width ) return size setGeometry ( self , rect : QtCore . QRect ) setGeometry(self, arg__1: PySide6.QtCore.QRect) -> None Source code in prettyqt/custom_widgets/flowlayout.py def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False ) sizeHint ( self ) -> QtCore . QSize sizeHint(self) -> PySide6.QtCore.QSize Source code in prettyqt/custom_widgets/flowlayout.py def sizeHint ( self ) -> QtCore . QSize : return self . minimumSize () takeAt ( self , index : int ) -> QtWidgets . QLayoutItem | None takeAt(self, index: int) -> PySide6.QtWidgets.QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def takeAt ( self , index : int ) -> QtWidgets . QLayoutItem | None : # type: ignore if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None framelesswindow CustomTitleBar ( Frame ) Source code in prettyqt/custom_widgets/framelesswindow.py class CustomTitleBar ( widgets . Frame ): def __init__ ( self , window_widget : QtWidgets . QWidget ): super () . __init__ ( window_widget ) self . window_widget = window_widget self . minimize_button = TitleBarIcon ( \"\ud83d\uddd5\" ) self . maximize_button = TitleBarIcon ( \"\ud83d\uddd6\" ) self . exit_button = TitleBarIcon ( \"\u2715\" ) self . setObjectName ( \"ControlWidget\" ) state = QtCore . Qt . WindowState . WindowMinimized self . minimize_button . clicked . connect ( lambda : window_widget . setWindowState ( state ) # type: ignore ) self . maximize_button . clicked . connect ( lambda : ( window_widget . showNormal () if window_widget . isMaximized () else window_widget . showMaximized () ) ) self . exit_button . clicked . connect ( window_widget . close ) self . set_layout ( \"horizontal\" ) spacer_item = QtWidgets . QSpacerItem ( 0 , 0 , QtWidgets . QSizePolicy . Expanding ) self . box . addSpacerItem ( spacer_item ) for widget in [ self . minimize_button , self . maximize_button , self . exit_button , ]: self . box . addWidget ( widget ) self . setStyleSheet ( \"width: 100%;\" \"padding: 0;\" \"margin: 0;\" ) self . setContentsMargins ( 0 , 0 , 0 , 0 ) self . box . setContentsMargins ( 0 , 0 , 0 , 0 ) self . box . setSpacing ( 0 ) def mousePressEvent ( self , a0 : QtGui . QMouseEvent ) -> None : self . window_widget . windowHandle () . startSystemMove () mousePressEvent ( self , a0 : QtGui . QMouseEvent ) -> None mousePressEvent(self, event: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/framelesswindow.py def mousePressEvent ( self , a0 : QtGui . QMouseEvent ) -> None : self . window_widget . windowHandle () . startSystemMove () EdgeGrip ( Widget ) Source code in prettyqt/custom_widgets/framelesswindow.py class EdgeGrip ( widgets . Widget ): def __init__ ( self , edges : str , grip_size = 6 , parent = None ): super () . __init__ ( parent ) self . edges = edges self . grip_size = grip_size # Sides if edges == \"top\" : self . setCursor ( QtCore . Qt . SizeVerCursor ) self . setFixedHeight ( self . grip_size ) elif edges == \"right\" : self . setCursor ( QtCore . Qt . SizeHorCursor ) self . setFixedWidth ( self . grip_size ) elif edges == \"bottom\" : self . setCursor ( QtCore . Qt . SizeVerCursor ) self . setFixedHeight ( self . grip_size ) elif edges == \"left\" : self . setCursor ( QtCore . Qt . SizeHorCursor ) self . setFixedWidth ( self . grip_size ) # Corners elif edges == \"top_left\" : self . setCursor ( QtCore . Qt . SizeFDiagCursor ) elif edges == \"top_right\" : self . setCursor ( QtCore . Qt . SizeBDiagCursor ) elif edges == \"bottom_left\" : self . setCursor ( QtCore . Qt . SizeBDiagCursor ) elif edges == \"bottom_right\" : self . setCursor ( QtCore . Qt . SizeFDiagCursor ) def mousePressEvent ( self , event ): if event . button () == QtCore . Qt . LeftButton : self . parent () . windowHandle () . startSystemResize ( self . edges ) mousePressEvent ( self , event ) mousePressEvent(self, event: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/framelesswindow.py def mousePressEvent ( self , event ): if event . button () == QtCore . Qt . LeftButton : self . parent () . windowHandle () . startSystemResize ( self . edges ) FramelessWindow ( Widget ) Source code in prettyqt/custom_widgets/framelesswindow.py class FramelessWindow ( widgets . Widget ): BORDER_WIDTH = 5 def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) # Remove window title bar and frame self . setWindowFlags ( QtCore . Qt . WindowFlag . Window # type: ignore | QtCore . Qt . WindowFlag . FramelessWindowHint ) self . title_bar = CustomTitleBar ( self ) self . main_widget = widgets . MainWindow () # Set up layout self . main_layout = widgets . BoxLayout ( \"vertical\" ) self . main_layout . addWidget ( self . title_bar ) self . main_layout . addWidget ( self . main_widget ) self . main_layout . setContentsMargins ( 0 , 0 , 0 , 0 ) self . main_layout . setSpacing ( 0 ) self . grip_layout = widgets . GridLayout () self . grip_layout . addLayout ( self . main_layout , 1 , 1 ) self . grip_layout . addWidget ( EdgeGrip ( \"top\" ), 0 , 1 ) self . grip_layout . addWidget ( EdgeGrip ( \"right\" ), 1 , 2 ) self . grip_layout . addWidget ( EdgeGrip ( \"bottom\" ), 2 , 1 ) self . grip_layout . addWidget ( EdgeGrip ( \"left\" ), 1 , 0 ) self . grip_layout . addWidget ( EdgeGrip ( \"top_left\" ), 0 , 0 ) self . grip_layout . addWidget ( EdgeGrip ( \"top_right\" ), 0 , 2 ) self . grip_layout . addWidget ( EdgeGrip ( \"bottom_left\" ), 2 , 0 ) self . grip_layout . addWidget ( EdgeGrip ( \"bottom_right\" ), 2 , 2 ) self . grip_layout . setContentsMargins ( 0 , 0 , 0 , 0 ) self . grip_layout . setSpacing ( 0 ) self . setLayout ( self . grip_layout ) if sys . platform == \"win32\" : self . hwnd = self . winId () . __int__ () window_style = win32gui . GetWindowLong ( self . hwnd , GWL_STYLE ) win32gui . SetWindowLong ( self . hwnd , GWL_STYLE , window_style | WS_POPUP | WS_THICKFRAME | WS_CAPTION | WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX , ) # if QtWin.isCompositionEnabled(): # # Aero Shadow # QtWin.extendFrameIntoClientArea(self, -1, -1, -1, -1) # else: # QtWin.resetExtendedFrame(self) def __getattr__ ( self , attr : str ): return getattr ( self . main_widget , attr ) def changeEvent ( self , event ): # not sure if this should be done on non-windows if event . type () == event . WindowStateChange : if self . windowState () & QtCore . Qt . WindowState . WindowMaximized : # type: ignore margin = abs ( self . mapToGlobal ( self . rect () . topLeft ()) . y ()) self . setContentsMargins ( margin , margin , margin , margin ) else : self . setContentsMargins ( 0 , 0 , 0 , 0 ) return super () . changeEvent ( event ) def nativeEvent ( self , event , message ): return_value , result = super () . nativeEvent ( event , message ) if sys . platform != \"win32\" : return return_value , result # if you use Windows OS if event == b \"windows_generic_MSG\" : msg = ctypes . wintypes . MSG . from_address ( message . __int__ ()) # Get the coordinates when the mouse moves. x = win32api . LOWORD ( LONG ( msg . lParam ) . value ) # type: ignore # converted an unsigned int to int (for dual monitor issue) if x & 32768 : x = x | - 65536 y = win32api . HIWORD ( LONG ( msg . lParam ) . value ) # type: ignore if y & 32768 : y = y | - 65536 x -= self . frameGeometry () . x () y -= self . frameGeometry () . y () # Determine whether there are other widgets at the mouse position. if self . childAt ( x , y ) is not None and self . childAt ( x , y ) is not self . findChild ( widgets . Widget , \"ControlWidget\" ): # passing if ( self . width () - self . BORDER_WIDTH > x > self . BORDER_WIDTH and y < self . height () - self . BORDER_WIDTH ): return return_value , result if msg . message == WM_NCCALCSIZE : # Remove system title return True , 0 if msg . message == WM_NCHITTEST : w , h = self . width (), self . height () lx = x < self . BORDER_WIDTH rx = x > w - self . BORDER_WIDTH ty = y < self . BORDER_WIDTH by = y > h - self . BORDER_WIDTH if lx and ty : return True , HTTOPLEFT if rx and by : return True , HTBOTTOMRIGHT if rx and ty : return True , HTTOPRIGHT if lx and by : return True , HTBOTTOMLEFT if ty : return True , HTTOP if by : return True , HTBOTTOM if lx : return True , HTLEFT if rx : return True , HTRIGHT # Title return True , HTCAPTION return return_value , result changeEvent ( self , event ) changeEvent(self, event: PySide6.QtCore.QEvent) -> None Source code in prettyqt/custom_widgets/framelesswindow.py def changeEvent ( self , event ): # not sure if this should be done on non-windows if event . type () == event . WindowStateChange : if self . windowState () & QtCore . Qt . WindowState . WindowMaximized : # type: ignore margin = abs ( self . mapToGlobal ( self . rect () . topLeft ()) . y ()) self . setContentsMargins ( margin , margin , margin , margin ) else : self . setContentsMargins ( 0 , 0 , 0 , 0 ) return super () . changeEvent ( event ) nativeEvent ( self , event , message ) nativeEvent(self, eventType: Union[PySide6.QtCore.QByteArray, bytes], message: int) -> object Source code in prettyqt/custom_widgets/framelesswindow.py def nativeEvent ( self , event , message ): return_value , result = super () . nativeEvent ( event , message ) if sys . platform != \"win32\" : return return_value , result # if you use Windows OS if event == b \"windows_generic_MSG\" : msg = ctypes . wintypes . MSG . from_address ( message . __int__ ()) # Get the coordinates when the mouse moves. x = win32api . LOWORD ( LONG ( msg . lParam ) . value ) # type: ignore # converted an unsigned int to int (for dual monitor issue) if x & 32768 : x = x | - 65536 y = win32api . HIWORD ( LONG ( msg . lParam ) . value ) # type: ignore if y & 32768 : y = y | - 65536 x -= self . frameGeometry () . x () y -= self . frameGeometry () . y () # Determine whether there are other widgets at the mouse position. if self . childAt ( x , y ) is not None and self . childAt ( x , y ) is not self . findChild ( widgets . Widget , \"ControlWidget\" ): # passing if ( self . width () - self . BORDER_WIDTH > x > self . BORDER_WIDTH and y < self . height () - self . BORDER_WIDTH ): return return_value , result if msg . message == WM_NCCALCSIZE : # Remove system title return True , 0 if msg . message == WM_NCHITTEST : w , h = self . width (), self . height () lx = x < self . BORDER_WIDTH rx = x > w - self . BORDER_WIDTH ty = y < self . BORDER_WIDTH by = y > h - self . BORDER_WIDTH if lx and ty : return True , HTTOPLEFT if rx and by : return True , HTBOTTOMRIGHT if rx and ty : return True , HTTOPRIGHT if lx and by : return True , HTBOTTOMLEFT if ty : return True , HTTOP if by : return True , HTBOTTOM if lx : return True , HTLEFT if rx : return True , HTRIGHT # Title return True , HTCAPTION return return_value , result iconbrowser IconListView ( ListView ) Source code in prettyqt/custom_widgets/iconbrowser.py class IconListView ( widgets . ListView ): \"\"\"A QListView that scales its grid size to always show same amount of items.\"\"\" def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) self . set_vertical_scrollbar_policy ( \"always_on\" ) self . VIEW_COLUMNS = 5 def resizeEvent ( self , event ): \"\"\"Re-calculate the grid size to provide scaling icons.\"\"\" width = self . viewport () . width () - 30 # The minus 30 above ensures we don't end up with an item width that # can't be drawn the expected number of times across the view without # being wrapped. Without this, the view can flicker during resize tile_width = int ( width / self . VIEW_COLUMNS ) icon_width = int ( tile_width * 0.8 ) self . set_grid_size (( tile_width , tile_width )) self . set_icon_size (( icon_width , icon_width )) return super () . resizeEvent ( event ) resizeEvent ( self , event ) Re-calculate the grid size to provide scaling icons. Source code in prettyqt/custom_widgets/iconbrowser.py def resizeEvent ( self , event ): \"\"\"Re-calculate the grid size to provide scaling icons.\"\"\" width = self . viewport () . width () - 30 # The minus 30 above ensures we don't end up with an item width that # can't be drawn the expected number of times across the view without # being wrapped. Without this, the view can flicker during resize tile_width = int ( width / self . VIEW_COLUMNS ) icon_width = int ( tile_width * 0.8 ) self . set_grid_size (( tile_width , tile_width )) self . set_icon_size (( icon_width , icon_width )) return super () . resizeEvent ( event ) IconModel ( StringListModel ) Source code in prettyqt/custom_widgets/iconbrowser.py class IconModel ( core . StringListModel ): def __init__ ( self , icon_color : QtGui . QColor ): super () . __init__ () self . _icon_color = icon_color def flags ( self , index ): return constants . IS_ENABLED | constants . IS_SELECTABLE # type: ignore def data ( self , index , role ): if role == constants . DECORATION_ROLE : icon_string = self . data ( index , role = constants . DISPLAY_ROLE ) return iconprovider . _icon ( icon_string , color = self . _icon_color ) return super () . data ( index , role ) data ( self , index , role ) data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_widgets/iconbrowser.py def data ( self , index , role ): if role == constants . DECORATION_ROLE : icon_string = self . data ( index , role = constants . DISPLAY_ROLE ) return iconprovider . _icon ( icon_string , color = self . _icon_color ) return super () . data ( index , role ) flags ( self , index ) flags(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.Qt.ItemFlag Source code in prettyqt/custom_widgets/iconbrowser.py def flags ( self , index ): return constants . IS_ENABLED | constants . IS_SELECTABLE # type: ignore iconwidget IconWidget ( Label ) Source code in prettyqt/custom_widgets/iconwidget.py class IconWidget ( widgets . Label ): \"\"\"IconWidget gives the ability to display an icon as a widget. if supports the same arguments as icon() for example music_icon = qta.IconWidget('fa5s.music', color='blue', color_active='orange') it also have setIcon() and setIconSize() functions \"\"\" def __init__ ( self , * names , parent : QtWidgets . QWidget | None = None , ** kwargs ): super () . __init__ ( parent = parent ) self . _icon : QtGui . QIcon | None = None self . _size = core . Size ( 16 , 16 ) self . set_icon ( iconprovider . _icon ( * names , ** kwargs )) def set_icon ( self , _icon : types . IconType ): \"\"\"Set a new icon(). Parameters ---------- _icon: qtawesome.icon icon to set \"\"\" self . _icon = iconprovider . get_icon ( _icon ) self . setPixmap ( self . _icon . pixmap ( self . _size )) def set_icon_size ( self , size : int | types . SizeType ): if isinstance ( size , tuple ): size = QtCore . QSize ( * size ) elif isinstance ( size , int ): size = QtCore . QSize ( size , size ) self . _size = size self . update () def update ( self , * args , ** kwargs ): if self . _icon : self . setPixmap ( self . _icon . pixmap ( self . _size )) return super () . update ( * args , ** kwargs ) set_icon ( self , _icon : types . IconType ) Set a new icon(). Parameters qtawesome.icon icon to set Source code in prettyqt/custom_widgets/iconwidget.py def set_icon ( self , _icon : types . IconType ): \"\"\"Set a new icon(). Parameters ---------- _icon: qtawesome.icon icon to set \"\"\" self . _icon = iconprovider . get_icon ( _icon ) self . setPixmap ( self . _icon . pixmap ( self . _size )) update ( self , * args , ** kwargs ) update(self) -> None update(self, arg__1: PySide6.QtCore.QRect) -> None update(self, arg__1: Union[PySide6.QtGui.QRegion, PySide6.QtGui.QBitmap, PySide6.QtGui.QPolygon, PySide6.QtCore.QRect]) -> None update(self, x: int, y: int, w: int, h: int) -> None Source code in prettyqt/custom_widgets/iconwidget.py def update ( self , * args , ** kwargs ): if self . _icon : self . setPixmap ( self . _icon . pixmap ( self . _size )) return super () . update ( * args , ** kwargs ) joystickbutton JoystickButton ( PushButton ) Source code in prettyqt/custom_widgets/joystickbutton.py class JoystickButton ( widgets . PushButton ): state_changed = core . Signal ( object ) def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) self . radius = 200 self . setCheckable ( True ) self . state = [ 0 , 0 ] self . set_state ( 0 , 0 ) self . setFixedWidth ( 50 ) self . setFixedHeight ( 50 ) def mousePressEvent ( self , ev ): self . setChecked ( True ) self . press_pos = ev . position () ev . accept () def mouseMoveEvent ( self , ev ): dif = ev . position () - self . press_pos self . set_state ( dif . x (), - dif . y ()) def mouseReleaseEvent ( self , ev ): self . setChecked ( False ) self . set_state ( 0 , 0 ) def wheelEvent ( self , ev ): ev . accept () def doubleClickEvent ( self , ev ): ev . accept () def get_state ( self ): return self . state def set_state ( self , x , y ): xy = [ x , y ] d = hypot ( xy [ 0 ], xy [ 1 ]) # length nxy = [ 0 , 0 ] for i in [ 0 , 1 ]: if xy [ i ] == 0 : nxy [ i ] = 0 else : nxy [ i ] = xy [ i ] / d if d > self . radius : d = self . radius d = ( d / self . radius ) ** 2 xy = [ nxy [ 0 ] * d , nxy [ 1 ] * d ] w2 = self . width () / 2 h2 = self . height () / 2 self . spot_pos = core . Point ( int ( w2 * ( 1 + xy [ 0 ])), int ( h2 * ( 1 - xy [ 1 ]))) self . update () if self . state == xy : return self . state = xy self . state_changed . emit ( self . state ) def paintEvent ( self , ev ): super () . paintEvent ( ev ) p = QtGui . QPainter ( self ) p . setBrush ( QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ))) p . drawEllipse ( self . spot_pos . x () - 3 , self . spot_pos . y () - 3 , 6 , 6 ) def resizeEvent ( self , ev ): self . set_state ( * self . state ) super () . resizeEvent ( ev ) mouseMoveEvent ( self , ev ) mouseMoveEvent(self, arg__1: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def mouseMoveEvent ( self , ev ): dif = ev . position () - self . press_pos self . set_state ( dif . x (), - dif . y ()) mousePressEvent ( self , ev ) mousePressEvent(self, e: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def mousePressEvent ( self , ev ): self . setChecked ( True ) self . press_pos = ev . position () ev . accept () mouseReleaseEvent ( self , ev ) mouseReleaseEvent(self, e: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def mouseReleaseEvent ( self , ev ): self . setChecked ( False ) self . set_state ( 0 , 0 ) paintEvent ( self , ev ) paintEvent(self, arg__1: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def paintEvent ( self , ev ): super () . paintEvent ( ev ) p = QtGui . QPainter ( self ) p . setBrush ( QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ))) p . drawEllipse ( self . spot_pos . x () - 3 , self . spot_pos . y () - 3 , 6 , 6 ) resizeEvent ( self , ev ) resizeEvent(self, event: PySide6.QtGui.QResizeEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def resizeEvent ( self , ev ): self . set_state ( * self . state ) super () . resizeEvent ( ev ) wheelEvent ( self , ev ) wheelEvent(self, event: PySide6.QtGui.QWheelEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def wheelEvent ( self , ev ): ev . accept () labeledslider LabeledSlider ( Widget ) Source code in prettyqt/custom_widgets/labeledslider.py class LabeledSlider ( widgets . Widget ): value_changed = core . Signal ( int ) def __init__ ( self , labels : Sequence [ str ], orientation : constants . OrientationStr = \"horizontal\" , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( parent = parent ) if not isinstance ( labels , Sequence ): raise ValueError ( \"<labels> must be a sequence.\" ) self . levels = list ( enumerate ( labels )) self . set_layout ( orientation ) # gives some space to print labels self . left_margin = 10 self . top_margin = 10 self . right_margin = 10 self . bottom_margin = 10 self . box . set_margin ( 10 ) self . sl = widgets . Slider ( orientation ) self . sl . value_changed . connect ( self . value_changed ) self . sl . set_range ( 0 , len ( self . levels ) - 1 ) self . sl . set_value ( 0 ) if orientation == \"horizontal\" : self . sl . set_tick_position ( \"below\" ) self . sl . setMinimumWidth ( 300 ) else : self . sl . set_tick_position ( \"left\" ) self . sl . setMinimumHeight ( 300 ) self . sl . setTickInterval ( 1 ) self . sl . setSingleStep ( 1 ) self . box . add ( self . sl ) def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PixelMetric . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PixelMetric . PM_SliderSpaceAvailable , st_slider , self . sl ) painter = gui . Painter ( self ) for v , v_str in self . levels : # get the size of the label rect = painter . get_text_rect ( v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc self . bottom_margin = max ( self . bottom_margin , rect . height ()) self . adjust_margins () if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . adjust_margins () else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . adjust_margins () painter . drawText ( left , bottom , v_str ) def adjust_margins ( self ): self . box . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) paintEvent ( self , e ) paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/labeledslider.py def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PixelMetric . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PixelMetric . PM_SliderSpaceAvailable , st_slider , self . sl ) painter = gui . Painter ( self ) for v , v_str in self . levels : # get the size of the label rect = painter . get_text_rect ( v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc self . bottom_margin = max ( self . bottom_margin , rect . height ()) self . adjust_margins () if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . adjust_margins () else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . adjust_margins () painter . drawText ( left , bottom , v_str ) menurecentfiles Provides a menu that display the list of recent files and a RecentFilesManager. Application's QSettings are used to store the list of recent files. MenuRecentFiles ( Menu ) Source code in prettyqt/custom_widgets/menurecentfiles.py class MenuRecentFiles ( widgets . Menu ): \"\"\"Menu that manage the list of recent files. To use the menu, simply connect to the open_requested signal. \"\"\" #: Signal emitted when the user clicked on a recent file action. #: The parameter is the path of the file to open. open_requested = core . Signal ( str ) clear_requested = core . Signal () def __init__ ( self , parent , recent_files_manager = None , title = \"Recent files\" , icon_provider = None , clear_icon = None , ): \"\"\"Init. :param parent: parent object :param icon_provider: Object that provides icon based on the file path. :type icon_provider: QtWidgets.QFileIconProvider :param clear_icon: Clear action icon. This parameter is a tuple made up of the icon theme name and the fallback icon path (from your resources). Default is None, clear action has no icons. \"\"\" super () . __init__ ( title , parent ) if icon_provider is None : self . icon_provider = widgets . FileIconProvider () else : self . icon_provider = icon_provider self . clear_icon = clear_icon #: Recent files manager self . manager = recent_files_manager #: List of recent files actions self . recent_files_actions = [] self . update_actions () def update_actions ( self ): \"\"\"Updates the list of actions.\"\"\" self . clear () self . recent_files_actions [:] = [] for file in self . manager . get_recent_files (): action = widgets . Action ( self ) action . setText ( os . path . split ( file )[ 1 ]) action . setToolTip ( file ) action . setStatusTip ( file ) action . setData ( file ) action . setIcon ( self . icon_provider . icon ( core . FileInfo ( file ))) action . triggered . connect ( self . _on_action_triggered ) self . addAction ( action ) self . recent_files_actions . append ( action ) self . addSeparator () action_clear = widgets . Action ( parent = self , text = \"Clear list\" ) action_clear . triggered . connect ( self . clear_recent_files ) action_clear . setIcon ( iconprovider . get_icon ( \"fa.times-circle\" )) self . addAction ( action_clear ) def clear_recent_files ( self ): \"\"\"Clear recent files and menu.\"\"\" self . manager . clear () self . update_actions () self . clear_requested . emit () def _on_action_triggered ( self ): \"\"\"Emits open_requested when a recent file action has been triggered.\"\"\" action = self . sender () assert isinstance ( action , widgets . Action ) path = action . data () self . open_requested . emit ( path ) self . update_actions () __init__ ( self , parent , recent_files_manager = None , title = 'Recent files' , icon_provider = None , clear_icon = None ) special Init. :param parent: parent object :param icon_provider: Object that provides icon based on the file path. :type icon_provider: QtWidgets.QFileIconProvider :param clear_icon: Clear action icon. This parameter is a tuple made up of the icon theme name and the fallback icon path (from your resources). Default is None, clear action has no icons. Source code in prettyqt/custom_widgets/menurecentfiles.py def __init__ ( self , parent , recent_files_manager = None , title = \"Recent files\" , icon_provider = None , clear_icon = None , ): \"\"\"Init. :param parent: parent object :param icon_provider: Object that provides icon based on the file path. :type icon_provider: QtWidgets.QFileIconProvider :param clear_icon: Clear action icon. This parameter is a tuple made up of the icon theme name and the fallback icon path (from your resources). Default is None, clear action has no icons. \"\"\" super () . __init__ ( title , parent ) if icon_provider is None : self . icon_provider = widgets . FileIconProvider () else : self . icon_provider = icon_provider self . clear_icon = clear_icon #: Recent files manager self . manager = recent_files_manager #: List of recent files actions self . recent_files_actions = [] self . update_actions () clear_recent_files ( self ) Clear recent files and menu. Source code in prettyqt/custom_widgets/menurecentfiles.py def clear_recent_files ( self ): \"\"\"Clear recent files and menu.\"\"\" self . manager . clear () self . update_actions () self . clear_requested . emit () update_actions ( self ) Updates the list of actions. Source code in prettyqt/custom_widgets/menurecentfiles.py def update_actions ( self ): \"\"\"Updates the list of actions.\"\"\" self . clear () self . recent_files_actions [:] = [] for file in self . manager . get_recent_files (): action = widgets . Action ( self ) action . setText ( os . path . split ( file )[ 1 ]) action . setToolTip ( file ) action . setStatusTip ( file ) action . setData ( file ) action . setIcon ( self . icon_provider . icon ( core . FileInfo ( file ))) action . triggered . connect ( self . _on_action_triggered ) self . addAction ( action ) self . recent_files_actions . append ( action ) self . addSeparator () action_clear = widgets . Action ( parent = self , text = \"Clear list\" ) action_clear . triggered . connect ( self . clear_recent_files ) action_clear . setIcon ( iconprovider . get_icon ( \"fa.times-circle\" )) self . addAction ( action_clear ) RecentFilesManager ( Object ) Source code in prettyqt/custom_widgets/menurecentfiles.py class RecentFilesManager ( core . Object ): \"\"\"Manages a list of recent files. The list of files is stored in QSettings.\"\"\" #: Maximum number of files kept in the list. max_recent_files = 15 updated = core . Signal () def __init__ ( self , organisation , application , qsettings = None ): super () . __init__ () if qsettings is None : self . _settings = core . Settings ( organisation , application ) else : self . _settings = qsettings def clear ( self ): \"\"\"Clears recent files in QSettings.\"\"\" self . set_value ( \"list\" , []) self . updated . emit () def remove ( self , filename ): \"\"\"Remove a file path from the list of recent files. :param filename: Path of the file to remove \"\"\" files = self . get_value ( \"list\" , []) files . remove ( filename ) self . set_value ( \"list\" , files ) self . updated . emit () def get_value ( self , key , default = None ): \"\"\"Reads value from QSettings. :param key: value key :param default: default value. :return: value \"\"\" def unique ( seq , idfun = None ): if idfun is None : def idfun ( x ): return x # order preserving seen = {} result = [] for item in seq : marker = idfun ( item ) if marker in seen : continue seen [ marker ] = 1 result . append ( item ) return result val = self . _settings . value ( \"recent_files/ %s \" % key , default ) if val is None : lst : list [ str ] = [] elif isinstance ( val , str ): lst = [ val ] else : lst = val # type: ignore return unique ([ os . path . normpath ( pth ) for pth in lst ]) def set_value ( self , key , value ): \"\"\"Set the recent files value in QSettings. :param key: value key :param value: new value \"\"\" if value is None : value = [] value = [ os . path . normpath ( pth ) for pth in value ] self . _settings . setValue ( \"recent_files/ %s \" % key , value ) def get_recent_files ( self ): \"\"\"Gets the list of recent files. Files that do not exists anymore are automatically filtered \"\"\" ret_val = [] files = self . get_value ( \"list\" , []) # filter files, remove files that do not exist anymore for file in files : if file is not None and os . path . exists ( file ): if ( os . path . ismount ( file ) and sys . platform == \"win32\" and not file . endswith ( \" \\\\ \" ) ): file += \" \\\\ \" if file not in ret_val : ret_val . append ( file ) return ret_val def open_file ( self , file ): \"\"\"Adds a file to the list (and move it to top if the file already exists). :param file: file path to add the list of recent files. \"\"\" files = self . get_recent_files () try : files . remove ( file ) except ValueError : pass files . insert ( 0 , file ) # discard old files del files [ self . max_recent_files :] self . set_value ( \"list\" , files ) self . updated . emit () def last_file ( self ): \"\"\"Returns the path to the last opened file.\"\"\" files = self . get_recent_files () try : return files [ 0 ] except IndexError : return None clear ( self ) Clears recent files in QSettings. Source code in prettyqt/custom_widgets/menurecentfiles.py def clear ( self ): \"\"\"Clears recent files in QSettings.\"\"\" self . set_value ( \"list\" , []) self . updated . emit () get_recent_files ( self ) Gets the list of recent files. Files that do not exists anymore are automatically filtered Source code in prettyqt/custom_widgets/menurecentfiles.py def get_recent_files ( self ): \"\"\"Gets the list of recent files. Files that do not exists anymore are automatically filtered \"\"\" ret_val = [] files = self . get_value ( \"list\" , []) # filter files, remove files that do not exist anymore for file in files : if file is not None and os . path . exists ( file ): if ( os . path . ismount ( file ) and sys . platform == \"win32\" and not file . endswith ( \" \\\\ \" ) ): file += \" \\\\ \" if file not in ret_val : ret_val . append ( file ) return ret_val get_value ( self , key , default = None ) Reads value from QSettings. :param key: value key :param default: default value. :return: value Source code in prettyqt/custom_widgets/menurecentfiles.py def get_value ( self , key , default = None ): \"\"\"Reads value from QSettings. :param key: value key :param default: default value. :return: value \"\"\" def unique ( seq , idfun = None ): if idfun is None : def idfun ( x ): return x # order preserving seen = {} result = [] for item in seq : marker = idfun ( item ) if marker in seen : continue seen [ marker ] = 1 result . append ( item ) return result val = self . _settings . value ( \"recent_files/ %s \" % key , default ) if val is None : lst : list [ str ] = [] elif isinstance ( val , str ): lst = [ val ] else : lst = val # type: ignore return unique ([ os . path . normpath ( pth ) for pth in lst ]) last_file ( self ) Returns the path to the last opened file. Source code in prettyqt/custom_widgets/menurecentfiles.py def last_file ( self ): \"\"\"Returns the path to the last opened file.\"\"\" files = self . get_recent_files () try : return files [ 0 ] except IndexError : return None open_file ( self , file ) Adds a file to the list (and move it to top if the file already exists). :param file: file path to add the list of recent files. Source code in prettyqt/custom_widgets/menurecentfiles.py def open_file ( self , file ): \"\"\"Adds a file to the list (and move it to top if the file already exists). :param file: file path to add the list of recent files. \"\"\" files = self . get_recent_files () try : files . remove ( file ) except ValueError : pass files . insert ( 0 , file ) # discard old files del files [ self . max_recent_files :] self . set_value ( \"list\" , files ) self . updated . emit () remove ( self , filename ) Remove a file path from the list of recent files. :param filename: Path of the file to remove Source code in prettyqt/custom_widgets/menurecentfiles.py def remove ( self , filename ): \"\"\"Remove a file path from the list of recent files. :param filename: Path of the file to remove \"\"\" files = self . get_value ( \"list\" , []) files . remove ( filename ) self . set_value ( \"list\" , files ) self . updated . emit () set_value ( self , key , value ) Set the recent files value in QSettings. :param key: value key :param value: new value Source code in prettyqt/custom_widgets/menurecentfiles.py def set_value ( self , key , value ): \"\"\"Set the recent files value in QSettings. :param key: value key :param value: new value \"\"\" if value is None : value = [] value = [ os . path . normpath ( pth ) for pth in value ] self . _settings . setValue ( \"recent_files/ %s \" % key , value ) notification MessageLabel ( Label ) Source code in prettyqt/custom_widgets/notification.py class MessageLabel ( widgets . Label ): \"\"\"Subclass of QLabel, which reimplements the resizeEvent() function. This is necessary because otherwise the notifications take up too much vertical space when texts they display become longer. This is because normally the height of a notification is calculated as the minimum height necessary for the text when the widget is horizontally resized to its minimum. \"\"\" def resizeEvent ( self , event ): super () . resizeEvent ( event ) if ( self . wordWrap () and self . sizePolicy () . verticalPolicy () == widgets . SizePolicy . Minimum ): new_height = self . heightForWidth ( self . width ()) if new_height < 1 : return self . setMaximumHeight ( new_height ) resizeEvent ( self , event ) resizeEvent(self, event: PySide6.QtGui.QResizeEvent) -> None Source code in prettyqt/custom_widgets/notification.py def resizeEvent ( self , event ): super () . resizeEvent ( event ) if ( self . wordWrap () and self . sizePolicy () . verticalPolicy () == widgets . SizePolicy . Minimum ): new_height = self . heightForWidth ( self . width ()) if new_height < 1 : return self . setMaximumHeight ( new_height ) Notification ( Widget ) Source code in prettyqt/custom_widgets/notification.py class Notification ( widgets . Widget ): \"\"\"Class representing a single notification.\"\"\" close_clicked = core . Signal () def __init__ ( self , message : str , category : CategoryStr , timeout = None , autohide : bool = False , buttontext : str | None = None , * args , ** kwargs , ): super () . __init__ ( * args , ** kwargs ) # Store instance variables self . message = message self . category = category self . timeout = timeout self . autohide = autohide # Set Object name for reference self . setObjectName ( category ) self . set_layout ( \"horizontal\" , margin = 0 ) # Create a message area message_area = widgets . BoxLayout ( \"horizontal\" ) message_area . set_margin ( 0 ) # Create the layout self . message_display = MessageLabel () self . message_display . setObjectName ( \"message\" ) self . message_display . set_size_policy ( \"minimum\" , \"minimum\" ) self . message_display . setWordWrap ( True ) # Create a button that can close notifications if not buttontext : close_button = widgets . PushButton ( \" \\u2715 \" ) else : close_button = widgets . PushButton ( buttontext ) close_button . setStyleSheet ( \"text-decoration: underline;\" ) close_button . set_size_policy ( \"fixed\" , \"fixed\" ) close_button . setFlat ( True ) close_button . setObjectName ( \"closeButton\" ) close_button . clicked . connect ( self . close_clicked ) # Add everything together message_area . addWidget ( self . message_display ) # message_area.addStretch(1) message_area . addWidget ( close_button ) self . layout () . addLayout ( message_area ) # Initialize some variables # self.setStyle(category) self . setVisible ( False ) # Flag that is set if notification is being removed. This can be used to # make sure that even though the notification has not been really removed # yet (because it is for example in a fade out animation), it is in the # process of being removed self . is_being_removed = False self . is_fading_in = False self . opacity_effect = widgets . GraphicsOpacityEffect ( self ) # Fade in animation self . fade_in_anim = core . PropertyAnimation () self . fade_in_anim . apply_to ( self . opacity_effect , \"opacity\" ) self . fade_in_anim . set_range ( 0.0 , 1.0 ) # Fade out animation self . fade_out_anim = core . PropertyAnimation () self . fade_out_anim . apply_to ( self . opacity_effect , \"opacity\" ) self . fade_in_anim . set_range ( 1.0 , 0.0 ) def display ( self ): \"\"\"Display the notification.\"\"\" self . message_display . setText ( self . message ) self . show () self . raise_ () def close ( self ): \"\"\"Close the notification.\"\"\" super () . close () self . deleteLater () def fade_in ( self , duration : int ): \"\"\"Fade in the notification. Arguments: duration : int The desired duration of the animation Raises: TypeError: duration is not an integer \"\"\" if type ( duration ) != int : raise TypeError ( \"duration should be an integer\" ) self . setGraphicsEffect ( self . opacity_effect ) self . fade_in_anim . setDuration ( duration ) self . is_fading_in = True self . fade_in_anim . finished . connect ( self . on_fade_in_finished ) self . display () self . fade_in_anim . start () def on_fade_in_finished ( self ): self . is_fading_in = False def fade_out ( self , finished_callback : Callable , duration : int ): \"\"\"Fade out the notification. Parameters ---------- finished_callback : callable The function to call after the animation has finished (to for instance clean up the notification) duration : int The desired duration of the animation Raises ------ TypeError: the wrong datatype is specified for any of the parameters. \"\"\" if not callable ( finished_callback ): raise TypeError ( \"finished_callback should be a callable\" ) if type ( duration ) != int : raise TypeError ( \"duration should be an integer\" ) self . setGraphicsEffect ( self . opacity_effect ) self . fade_out_anim . setDuration ( duration ) self . fade_out_anim . finished . connect ( lambda : finished_callback ( self )) self . is_being_removed = True self . fade_out_anim . start () def paintEvent ( self , pe ): \"\"\"Redefinition of paintEvent, do not call directly. Makes class Notification available in style sheets. Interal Qt function. Should not be called directly. \"\"\" o = widgets . StyleOption . based_on ( self ) p = gui . Painter ( self ) self . style () . drawPrimitive ( widgets . Style . PE_Widget , o , p , self ) @property def message ( self ) -> str : \"\"\"The currently set message to display.\"\"\" return self . _message @message . setter def message ( self , value : str ): \"\"\"Set the message to display.\"\"\" self . _message = value @property def category ( self ) -> CategoryStr : \"\"\"The currently set category of this notification.\"\"\" return self . _category @category . setter def category ( self , value : CategoryStr ): \"\"\"Set the category of this notification. Arguments: value : {'primary','success','info','warning','danger'} The category specification Raises: ValueError: The category is other than one of the expected values. \"\"\" allowed_values = [ \"primary\" , \"success\" , \"info\" , \"warning\" , \"danger\" ] if value not in allowed_values : raise ValueError ( f \" { value !r} is not a valid value. Should be one of { allowed_values } \" ) self . _category = value def enterEvent ( self , e ): \"\"\"When the notification is set to auto-hide, mouseover closes it.\"\"\" if self . autohide : self . close_clicked . emit () category : CategoryStr property writable The currently set category of this notification. message : str property writable The currently set message to display. close ( self ) Close the notification. Source code in prettyqt/custom_widgets/notification.py def close ( self ): \"\"\"Close the notification.\"\"\" super () . close () self . deleteLater () display ( self ) Display the notification. Source code in prettyqt/custom_widgets/notification.py def display ( self ): \"\"\"Display the notification.\"\"\" self . message_display . setText ( self . message ) self . show () self . raise_ () enterEvent ( self , e ) When the notification is set to auto-hide, mouseover closes it. Source code in prettyqt/custom_widgets/notification.py def enterEvent ( self , e ): \"\"\"When the notification is set to auto-hide, mouseover closes it.\"\"\" if self . autohide : self . close_clicked . emit () fade_in ( self , duration : int ) Fade in the notification. Parameters: Name Type Description Default duration int The desired duration of the animation required Exceptions: Type Description TypeError duration is not an integer Source code in prettyqt/custom_widgets/notification.py def fade_in ( self , duration : int ): \"\"\"Fade in the notification. Arguments: duration : int The desired duration of the animation Raises: TypeError: duration is not an integer \"\"\" if type ( duration ) != int : raise TypeError ( \"duration should be an integer\" ) self . setGraphicsEffect ( self . opacity_effect ) self . fade_in_anim . setDuration ( duration ) self . is_fading_in = True self . fade_in_anim . finished . connect ( self . on_fade_in_finished ) self . display () self . fade_in_anim . start () fade_out ( self , finished_callback : Callable , duration : int ) Fade out the notification. Parameters finished_callback : callable The function to call after the animation has finished (to for instance clean up the notification) duration : int The desired duration of the animation Raises TypeError: the wrong datatype is specified for any of the parameters. Source code in prettyqt/custom_widgets/notification.py def fade_out ( self , finished_callback : Callable , duration : int ): \"\"\"Fade out the notification. Parameters ---------- finished_callback : callable The function to call after the animation has finished (to for instance clean up the notification) duration : int The desired duration of the animation Raises ------ TypeError: the wrong datatype is specified for any of the parameters. \"\"\" if not callable ( finished_callback ): raise TypeError ( \"finished_callback should be a callable\" ) if type ( duration ) != int : raise TypeError ( \"duration should be an integer\" ) self . setGraphicsEffect ( self . opacity_effect ) self . fade_out_anim . setDuration ( duration ) self . fade_out_anim . finished . connect ( lambda : finished_callback ( self )) self . is_being_removed = True self . fade_out_anim . start () paintEvent ( self , pe ) Redefinition of paintEvent, do not call directly. Makes class Notification available in style sheets. Interal Qt function. Should not be called directly. Source code in prettyqt/custom_widgets/notification.py def paintEvent ( self , pe ): \"\"\"Redefinition of paintEvent, do not call directly. Makes class Notification available in style sheets. Interal Qt function. Should not be called directly. \"\"\" o = widgets . StyleOption . based_on ( self ) p = gui . Painter ( self ) self . style () . drawPrimitive ( widgets . Style . PE_Widget , o , p , self ) NotificationArea ( Widget ) Source code in prettyqt/custom_widgets/notification.py class NotificationArea ( widgets . Widget ): \"\"\"Notification area to show notifications in. Will be projected on top of another QWidget which should be passed as an argument to this class. \"\"\" def __init__ ( self , target_widget : QtWidgets . QWidget , use_global_css : bool = False , use_queue : bool = True , max_messages : int = 2 , ): \"\"\"Constructor. Arguments: target_widget : QtWidgets.QWidget The widget to project the notifications on use_global_css : bool (default: False) Flag which indicates whether global style sheets should be used (which have been set at app-level). If False, the default style sheets stored at DEFAULT_NOTIFICATION_STYLES will be loaded. use_queue : bool (default: True) Indicates whether a message queue should be implemented. This will only show *max_messages* at the same time and will put all other messages in a queue. Once a message disappears, the next one in the queue will be shown (up to max_messages at the same time) max_messages : int (default: 2) The number of messages to display at the same time. Raises: TypeError : target_widget is not an object that inherits QWidget \"\"\" if not isinstance ( target_widget , QtWidgets . QWidget ): raise TypeError ( \"target_widget is not a QWidget (or child of it\" ) # Pop some variables from kwargs. self . use_queue = use_queue self . max_messages = max_messages super () . __init__ ( parent = target_widget ) if not use_global_css : self . setStyleSheet ( DEFAULT_NOTIFICATION_STYLES ) if self . use_queue : self . queue : Queue [ Notification ] = Queue () self . target_widget = target_widget self . set_margin ( 0 ) notification_area_layout = widgets . BoxLayout ( \"vertical\" ) self . setLayout ( notification_area_layout ) # Init effects to None self . entry_effect : FadeInValue = None self . entry_effect_duration = 250 self . exit_effect : FadeOutValue = None self . exit_effect_duration = 500 # Store original target classes resizeEvent to be called in our own # function self . target_resize_event = target_widget . resizeEvent # Overwrite resizeEvent function of target_widget to capture it ourself # (parent's resizeEvent will be called in our function too) self . target_widget . resizeEvent = self . resizeEvent # type: ignore self . hide () def __delete_notification ( self , notification : Notification ): \"\"\"Close and destroy the supplied notification.\"\"\" notification . close () self . layout () . removeWidget ( notification ) self . adjustSize () # Hide notification area if it doesn't contain any items if self . layout () . count () == 0 : self . hide () if self . use_queue : try : notification = self . queue . get ( False ) self . _show_notification ( notification ) except Empty : pass # Public functions def set_entry_effect ( self , effect : FadeInValue , duration : int = 250 ): \"\"\"Set the effect with which the notifications are to appear. Arguments: effect : {'fade_in', None} The effect which should be used (for now only 'fade_in' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. duration : int (default: 250 ms) The duration of the effect in milliseconds Raises: TypeError: the object passed for duration is not an int ValueError: duration is less than 0, or effect has an invalid value \"\"\" if effect not in [ \"fade_in\" , None ]: raise ValueError ( \"Invalid entry effect\" ) if not isinstance ( duration , int ): raise TypeError ( \"Duration should be an int\" ) if duration < 0 : raise ValueError ( \"Duration should be larger than 0\" ) self . entry_effect = effect self . entry_effect_duration = duration def set_exit_effect ( self , effect : FadeOutValue , duration : int = 500 ): \"\"\"Set the effect with which the notifications are to disappear. Arguments: effect : {'fade_out', None} the effect which should be used (for now only 'fade_out' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. duration : int (default: 1000 ms) The duration of the effect in milliseconds Raises: TypeError: the object passed for duration is not an int ValueError: duration is less than 0, or effect has an invalid value \"\"\" if effect not in [ \"fade_out\" , None ]: raise ValueError ( \"Invalid exit effect\" ) if not isinstance ( duration , int ): raise TypeError ( \"Duration should be an int\" ) if duration < 0 : raise ValueError ( \"Duration should be larger than 0\" ) self . exit_effect = effect self . exit_effect_duration = duration @core . Slot ( str , str , int , bool ) @core . Slot ( str , str , int , bool , str ) def display ( self , message : str , category : CategoryStr , timeout : int = 5000 , autohide : bool = False , buttontext : str | None = None , ): \"\"\"Display a notification. If a queue is used, then the notification will only be shown directly if the number of notifications shown is smaller than max_messages. Arguments: message : str The message to display category : {'primary', 'success', 'info', 'warning', 'danger'} The type of notification that should be shown. Adheres to bootstrap standards which are primary, success, info, warning and danger timeout : int, optional The duration for which the notification should be shown. If None then the notification will be shown indefinitely buttontext : str, optional The text to display on the closing button. If not provided a cross will be shown. Raises: ValueError: the category is other than one of the expected values. \"\"\" notification = Notification ( message , category , timeout , autohide , buttontext , self ) notification . close_clicked . connect ( self . remove ) # Queue if max amount of notifications is shown if self . use_queue and self . layout () . count () >= self . max_messages : self . queue . put ( notification ) else : self . _show_notification ( notification ) def _cursor_in_area ( self ) -> bool : geom = self . geometry () top_left = self . mapToGlobal ( geom . topLeft ()) bottom_right = self . mapToGlobal ( geom . bottomRight ()) geom = core . Rect ( top_left , bottom_right ) geom . setTop ( geom . top () - CURSOR_MARGIN_TOP ) geom . setBottom ( geom . bottom () + CURSOR_MARGIN_BOTTOM ) geom . setLeft ( geom . left () - CURSOR_MARGIN_LEFT ) geom . setRight ( geom . right () + CURSOR_MARGIN_RIGHT ) cursor_pos = gui . Cursor . get_position () return geom . contains ( cursor_pos ) def _show_notification ( self , notification : Notification ): if self . _cursor_in_area (): core . Timer . singleShot ( 1000 , lambda : self . _show_notification ( notification )) return if not self . isVisible (): self . show () self . raise_ () self . layout () . addWidget ( notification ) # Check for entry effects if self . entry_effect is not None : if self . entry_effect == \"fade_in\" : notification . fade_in ( self . entry_effect_duration ) else : notification . display () self . adjustSize () if notification . timeout is not None and notification . timeout > 0 : core . Timer . singleShot ( notification . timeout , lambda : self . remove ( notification )) @core . Slot () def remove ( self , notification : Notification | None = None ): \"\"\"Removes a notification. Arguments: notification : Notification (default: None) The notification to remove. This function also serves as a PyQt slot for signals emitted from a Notification. In this case, the Notification object is retrieved by using self.sender() Raises: ValueError: notification is not None or a Notification \"\"\" # This function also functions as a pyqt slot. In that case, no # notification argument is passed, but this is set as self.sender() if notification is None : notification = self . sender () if notification . is_being_removed or notification . is_fading_in : return notification . is_being_removed = True # Check if notification is still present (and has not manually been # closed before this function is called by a timeout) if notification not in self . layout (): return # Implement animation here if self . exit_effect == \"fade_out\" : notification . fade_out ( self . __delete_notification , self . exit_effect_duration ) else : self . __delete_notification ( notification ) # Internal Qt functions def resizeEvent ( self , event ): \"\"\"Internal QT function (do not call directly).\"\"\" self . target_resize_event ( event ) newsize = event . size () self . setFixedWidth ( newsize . width ()) self . adjustSize () def paintEvent ( self , pe ): \"\"\"Redefinition of paintEvent. Makes class NotificationArea available in style sheets. Internal QT function (do not call directly). \"\"\" o = widgets . StyleOption . based_on ( self ) p = gui . Painter ( self ) self . style () . drawPrimitive ( widgets . Style . PE_Widget , o , p , self ) __init__ ( self , target_widget : QtWidgets . QWidget , use_global_css : bool = False , use_queue : bool = True , max_messages : int = 2 ) special Constructor. Parameters: Name Type Description Default target_widget QtWidgets.QWidget The widget to project the notifications on required use_global_css bool (default: False) Flag which indicates whether global style sheets should be used (which have been set at app-level). If False, the default style sheets stored at DEFAULT_NOTIFICATION_STYLES will be loaded. False use_queue bool (default: True) Indicates whether a message queue should be implemented. This will only show max_messages at the same time and will put all other messages in a queue. Once a message disappears, the next one in the queue will be shown (up to max_messages at the same time) True max_messages int (default: 2) The number of messages to display at the same time. 2 Exceptions: Type Description TypeError target_widget is not an object that inherits QWidget Source code in prettyqt/custom_widgets/notification.py def __init__ ( self , target_widget : QtWidgets . QWidget , use_global_css : bool = False , use_queue : bool = True , max_messages : int = 2 , ): \"\"\"Constructor. Arguments: target_widget : QtWidgets.QWidget The widget to project the notifications on use_global_css : bool (default: False) Flag which indicates whether global style sheets should be used (which have been set at app-level). If False, the default style sheets stored at DEFAULT_NOTIFICATION_STYLES will be loaded. use_queue : bool (default: True) Indicates whether a message queue should be implemented. This will only show *max_messages* at the same time and will put all other messages in a queue. Once a message disappears, the next one in the queue will be shown (up to max_messages at the same time) max_messages : int (default: 2) The number of messages to display at the same time. Raises: TypeError : target_widget is not an object that inherits QWidget \"\"\" if not isinstance ( target_widget , QtWidgets . QWidget ): raise TypeError ( \"target_widget is not a QWidget (or child of it\" ) # Pop some variables from kwargs. self . use_queue = use_queue self . max_messages = max_messages super () . __init__ ( parent = target_widget ) if not use_global_css : self . setStyleSheet ( DEFAULT_NOTIFICATION_STYLES ) if self . use_queue : self . queue : Queue [ Notification ] = Queue () self . target_widget = target_widget self . set_margin ( 0 ) notification_area_layout = widgets . BoxLayout ( \"vertical\" ) self . setLayout ( notification_area_layout ) # Init effects to None self . entry_effect : FadeInValue = None self . entry_effect_duration = 250 self . exit_effect : FadeOutValue = None self . exit_effect_duration = 500 # Store original target classes resizeEvent to be called in our own # function self . target_resize_event = target_widget . resizeEvent # Overwrite resizeEvent function of target_widget to capture it ourself # (parent's resizeEvent will be called in our function too) self . target_widget . resizeEvent = self . resizeEvent # type: ignore self . hide () display ( self , message : str , category : CategoryStr , timeout : int = 5000 , autohide : bool = False , buttontext : str | None = None ) Display a notification. If a queue is used, then the notification will only be shown directly if the number of notifications shown is smaller than max_messages. Parameters: Name Type Description Default message str The message to display required category {'primary', 'success', 'info', 'warning', 'danger'} The type of notification that should be shown. Adheres to bootstrap standards which are primary, success, info, warning and danger required timeout int, optional The duration for which the notification should be shown. If None then the notification will be shown indefinitely 5000 buttontext str, optional The text to display on the closing button. If not provided a cross will be shown. None Exceptions: Type Description ValueError the category is other than one of the expected values. Source code in prettyqt/custom_widgets/notification.py @core . Slot ( str , str , int , bool ) @core . Slot ( str , str , int , bool , str ) def display ( self , message : str , category : CategoryStr , timeout : int = 5000 , autohide : bool = False , buttontext : str | None = None , ): \"\"\"Display a notification. If a queue is used, then the notification will only be shown directly if the number of notifications shown is smaller than max_messages. Arguments: message : str The message to display category : {'primary', 'success', 'info', 'warning', 'danger'} The type of notification that should be shown. Adheres to bootstrap standards which are primary, success, info, warning and danger timeout : int, optional The duration for which the notification should be shown. If None then the notification will be shown indefinitely buttontext : str, optional The text to display on the closing button. If not provided a cross will be shown. Raises: ValueError: the category is other than one of the expected values. \"\"\" notification = Notification ( message , category , timeout , autohide , buttontext , self ) notification . close_clicked . connect ( self . remove ) # Queue if max amount of notifications is shown if self . use_queue and self . layout () . count () >= self . max_messages : self . queue . put ( notification ) else : self . _show_notification ( notification ) paintEvent ( self , pe ) Redefinition of paintEvent. Makes class NotificationArea available in style sheets. Internal QT function (do not call directly). Source code in prettyqt/custom_widgets/notification.py def paintEvent ( self , pe ): \"\"\"Redefinition of paintEvent. Makes class NotificationArea available in style sheets. Internal QT function (do not call directly). \"\"\" o = widgets . StyleOption . based_on ( self ) p = gui . Painter ( self ) self . style () . drawPrimitive ( widgets . Style . PE_Widget , o , p , self ) remove ( self , notification : Notification | None = None ) Removes a notification. Parameters: Name Type Description Default notification Notification (default: None) The notification to remove. This function also serves as a PyQt slot for signals emitted from a Notification. In this case, the Notification object is retrieved by using self.sender() None Exceptions: Type Description ValueError notification is not None or a Notification Source code in prettyqt/custom_widgets/notification.py @core . Slot () def remove ( self , notification : Notification | None = None ): \"\"\"Removes a notification. Arguments: notification : Notification (default: None) The notification to remove. This function also serves as a PyQt slot for signals emitted from a Notification. In this case, the Notification object is retrieved by using self.sender() Raises: ValueError: notification is not None or a Notification \"\"\" # This function also functions as a pyqt slot. In that case, no # notification argument is passed, but this is set as self.sender() if notification is None : notification = self . sender () if notification . is_being_removed or notification . is_fading_in : return notification . is_being_removed = True # Check if notification is still present (and has not manually been # closed before this function is called by a timeout) if notification not in self . layout (): return # Implement animation here if self . exit_effect == \"fade_out\" : notification . fade_out ( self . __delete_notification , self . exit_effect_duration ) else : self . __delete_notification ( notification ) resizeEvent ( self , event ) Internal QT function (do not call directly). Source code in prettyqt/custom_widgets/notification.py def resizeEvent ( self , event ): \"\"\"Internal QT function (do not call directly).\"\"\" self . target_resize_event ( event ) newsize = event . size () self . setFixedWidth ( newsize . width ()) self . adjustSize () set_entry_effect ( self , effect : FadeInValue , duration : int = 250 ) Set the effect with which the notifications are to appear. Parameters: Name Type Description Default effect {'fade_in', None} The effect which should be used (for now only 'fade_in' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. required duration int (default: 250 ms) The duration of the effect in milliseconds 250 Exceptions: Type Description TypeError the object passed for duration is not an int ValueError duration is less than 0, or effect has an invalid value Source code in prettyqt/custom_widgets/notification.py def set_entry_effect ( self , effect : FadeInValue , duration : int = 250 ): \"\"\"Set the effect with which the notifications are to appear. Arguments: effect : {'fade_in', None} The effect which should be used (for now only 'fade_in' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. duration : int (default: 250 ms) The duration of the effect in milliseconds Raises: TypeError: the object passed for duration is not an int ValueError: duration is less than 0, or effect has an invalid value \"\"\" if effect not in [ \"fade_in\" , None ]: raise ValueError ( \"Invalid entry effect\" ) if not isinstance ( duration , int ): raise TypeError ( \"Duration should be an int\" ) if duration < 0 : raise ValueError ( \"Duration should be larger than 0\" ) self . entry_effect = effect self . entry_effect_duration = duration set_exit_effect ( self , effect : FadeOutValue , duration : int = 500 ) Set the effect with which the notifications are to disappear. Parameters: Name Type Description Default effect {'fade_out', None} the effect which should be used (for now only 'fade_out' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. required duration int (default: 1000 ms) The duration of the effect in milliseconds 500 Exceptions: Type Description TypeError the object passed for duration is not an int ValueError duration is less than 0, or effect has an invalid value Source code in prettyqt/custom_widgets/notification.py def set_exit_effect ( self , effect : FadeOutValue , duration : int = 500 ): \"\"\"Set the effect with which the notifications are to disappear. Arguments: effect : {'fade_out', None} the effect which should be used (for now only 'fade_out' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. duration : int (default: 1000 ms) The duration of the effect in milliseconds Raises: TypeError: the object passed for duration is not an int ValueError: duration is less than 0, or effect has an invalid value \"\"\" if effect not in [ \"fade_out\" , None ]: raise ValueError ( \"Invalid exit effect\" ) if not isinstance ( duration , int ): raise TypeError ( \"Duration should be an int\" ) if duration < 0 : raise ValueError ( \"Duration should be larger than 0\" ) self . exit_effect = effect self . exit_effect_duration = duration popupinfo PopupInfo ( Dialog ) Source code in prettyqt/custom_widgets/popupinfo.py class PopupInfo ( widgets . Dialog ): \"\"\"Dialog overlay to show some info to user.\"\"\" def __init__ ( self , parent : QtWidgets . QWidget | None = None , text : str | None = None ): super () . __init__ ( parent = parent ) self . timer = core . Timer . single_shot ( callback = self . close ) self . label = widgets . Label () self . set_flags ( stay_on_top = True , frameless = True , tool = True ) layout = widgets . BoxLayout ( \"vertical\" ) layout . set_margin ( 20 ) self . set_layout ( layout ) self . set_background_color ( \"black\" ) self . label . set_color ( \"white\" ) layout . add ( self . label ) # signals.signals.popup_info.connect(self.popup) def show ( self ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) // 2 y = ( screen_geo . height () - size . height ()) // 2 self . move ( x , y - 200 ) super () . show () self . timer . start ( 2500 ) def show_popup ( self , text : str ): self . label . setText ( text ) self . show () show ( self ) show(self) -> None Source code in prettyqt/custom_widgets/popupinfo.py def show ( self ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) // 2 y = ( screen_geo . height () - size . height ()) // 2 self . move ( x , y - 200 ) super () . show () self . timer . start ( 2500 ) regexeditor special Module containing classes related to the RegEx editor. __main__ special This module contains the editor widget implementation. quick_ref Contains the quick reference widget. regexeditorwidget This module contains the editor widget implementation. roundprogressbar RoundProgressBar ( Widget ) Source code in prettyqt/custom_widgets/roundprogressbar.py class RoundProgressBar ( widgets . Widget ): # CONSTANTS POSITION_LEFT = 180.0 POSITION_TOP = 90.0 POSITION_RIGHT = 0.0 POSITION_BOTTOM = - 90.0 def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) self . _min_value = 0.0 self . _max_value = 100.0 self . current_value = 0.0 self . null_pos = self . POSITION_TOP self . bar_style : BarStyleStr = \"donut\" self . outline_pen_width = 1.0 self . data_pen_width = 1.0 self . _rebuild_brush = False self . number_format = \"%p%\" self . decimals = 1 self . _update_flags : ValueTypeStr = \"percent\" self . gradient_data : list [ QtGui . QColor ] = list () def minimum ( self ): return self . _min_value def maximum ( self ): return self . _max_value # SETTERS ------------------------------------------------------- def set_null_position ( self , position : float ): if position != self . null_pos : self . null_pos = position self . _rebuild_brush = True self . update () def set_bar_style ( self , style : BarStyleStr ): if style not in BAR_STYLE : raise InvalidParamError ( style , BAR_STYLE ) if style != self . bar_style : self . bar_style = style self . _rebuild_brush = True self . update () def set_outline_pen_width ( self , width : float ): if width != self . outline_pen_width : self . outline_pen_width = width self . update () def set_data_pen_width ( self , width : float ): if width != self . data_pen_width : self . data_pen_width = width self . update () def set_data_colors ( self , stop_points : list [ QtGui . QColor ]): if stop_points != self . gradient_data : self . gradient_data = stop_points self . _rebuild_brush = True self . update () def set_format ( self , val : str ): if val != self . number_format : self . number_format = val self . _value_format_changed () def set_decimals ( self , count : int ): if count >= 0 and count != self . decimals : self . decimals = count self . _value_format_changed () # SLOTS --------------------------------------------------------- @core . Slot ( float , float ) def set_range ( self , minval : float , maxval : float ): self . _min_value = min ( minval , maxval ) self . _max_value = max ( minval , maxval ) self . current_value = min ( self . _max_value , max ( self . _min_value , self . current_value ) ) self . _rebuild_brush = True self . update () @core . Slot ( float ) def setMinimum ( self , val : float ): self . set_range ( val , self . _max_value ) @core . Slot ( float ) def setMaximum ( self , val : float ): self . set_range ( self . _min_value , val ) @core . Slot ( float ) def set_value ( self , val : float ): if self . current_value != val : self . current_value = min ( self . _max_value , max ( self . _min_value , val )) self . update () def get_value ( self ) -> float : return self . current_value # PAINTING ------------------------------------------------------ def paintEvent ( self , event : gui . PaintEvent ): outer_radius = min ( self . width (), self . height ()) rect = core . RectF ( 1 , 1 , outer_radius - 2 , outer_radius - 2 ) with gui . Painter ( self ) as painter : painter . use_antialiasing () if self . bar_style != \"line\" : self . _rebuild_data_brush_if_needed () painter . fillRect ( 0 , 0 , outer_radius , outer_radius , self . palette () . window ()) self . _draw_base ( painter , rect ) self . _draw_value ( painter , rect , self . current_value ) inner_rect , inner_radius = self . _calculate_inner_rect ( outer_radius ) self . _draw_inner_background ( painter , inner_rect ) self . _draw_text ( painter , inner_rect , inner_radius , self . current_value ) def _draw_base ( self , painter : gui . Painter , rect : core . RectF ): if self . bar_style == \"donut\" : color = self . palette () . shadow () . color () painter . set_pen ( color = color , width = self . outline_pen_width ) painter . setBrush ( self . palette () . base ()) painter . drawEllipse ( rect ) elif self . bar_style == \"line\" : base_color = self . palette () . base () . color () painter . set_pen ( color = base_color , width = self . outline_pen_width ) painter . setBrush ( QtCore . Qt . BrushStyle . NoBrush ) width = self . outline_pen_width / 2 adjusted = rect . adjusted ( width , width , - width , - width ) painter . drawEllipse ( adjusted ) elif self . bar_style in ( \"pie\" , \"expand\" ): base_color = self . palette () . base () . color () painter . set_pen ( color = base_color , width = self . outline_pen_width ) painter . setBrush ( self . palette () . base ()) painter . drawEllipse ( rect ) def _draw_value ( self , painter : gui . Painter , rect : core . RectF , value : float ): if value == self . _min_value : return diff = self . current_value - self . _min_value value_range = self . _max_value - self . _min_value delta = max ( value_range / diff , 0 ) if self . bar_style == \"expand\" : painter . setBrush ( self . palette () . highlight ()) color = self . palette () . shadow () . color () painter . set_pen ( color = color , width = self . data_pen_width ) radius = ( rect . height () / 2 ) / delta painter . drawEllipse ( rect . center (), radius , radius ) elif self . bar_style == \"line\" : color = self . palette () . highlight () . color () painter . set_pen ( color = color , width = self . data_pen_width ) painter . setBrush ( QtCore . Qt . BrushStyle . NoBrush ) pen_width = self . outline_pen_width / 2 adjusted = rect . adjusted ( pen_width , pen_width , - pen_width , - pen_width ) if value == self . _max_value : painter . drawEllipse ( adjusted ) else : arc_length = 360 / delta painter . drawArc ( adjusted , int ( self . null_pos * 16 ), int ( - arc_length * 16 )) elif self . bar_style in [ \"donut\" , \"pie\" ]: data_path = gui . PainterPath () data_path . set_fill_rule ( \"winding\" ) if value == self . _max_value : data_path . addEllipse ( rect ) else : arc_length = 360 / delta center_point = rect . center () data_path . moveTo ( center_point ) data_path . arcTo ( rect , self . null_pos , - arc_length ) data_path . lineTo ( center_point ) painter . setBrush ( self . palette () . highlight ()) shadow_color = self . palette () . shadow () . color () painter . set_pen ( color = shadow_color , width = self . data_pen_width ) painter . drawPath ( data_path ) def _calculate_inner_rect ( self , outer_radius : float ) -> tuple [ core . RectF , float ]: if self . bar_style in ( \"line\" , \"expand\" ): inner_radius = outer_radius - self . outline_pen_width else : inner_radius = outer_radius * 0.75 delta = ( outer_radius - inner_radius ) / 2 inner_rect = core . RectF ( delta , delta , inner_radius , inner_radius ) return inner_rect , inner_radius def _draw_inner_background ( self , painter : gui . Painter , inner_rect : core . RectF ): if self . bar_style == \"donut\" : painter . setBrush ( self . palette () . base ()) painter . drawEllipse ( inner_rect ) def _draw_text ( self , painter : gui . Painter , inner_rect : core . RectF , inner_radius : float , value : float , ): if not self . number_format : return font = self . get_font () font . setPixelSize ( 10 ) metrics = gui . FontMetricsF ( font ) max_width = metrics . width ( self . _value_to_text ( self . _max_value )) delta = inner_radius / max_width font_size = int ( font . pixelSize () * delta * 0.75 ) font . setPixelSize ( max ( font_size , 1 )) painter . setFont ( font ) painter . setPen ( self . palette () . text () . color ()) text = self . _value_to_text ( value ) painter . drawText ( inner_rect , constants . ALIGN_CENTER , text ) # type: ignore def _value_to_text ( self , value : float ) -> str : text_to_draw = self . number_format if self . _update_flags == \"value\" : val = round ( value , self . decimals ) return text_to_draw . replace ( r \"%v\" , str ( val )) elif self . _update_flags == \"percent\" : pct = ( value - self . _min_value ) / ( self . _max_value - self . _min_value ) * 100 val = round ( pct , self . decimals ) return text_to_draw . replace ( r \"%p\" , str ( val )) elif self . _update_flags == \"max\" : val = round ( self . _max_value - self . _min_value + 1 , self . decimals ) return text_to_draw . replace ( r \"%m\" , str ( val )) else : return ValueError () def _value_format_changed ( self ): for k , v in VALUE_MAP . items (): if k in self . number_format : self . _update_flags = v self . update () def _rebuild_data_brush_if_needed ( self ): if not self . _rebuild_brush or not self . gradient_data : return self . _rebuild_brush = False if self . bar_style == \"expand\" : data_brush = gui . RadialGradient ( 0.5 , 0.5 , 0.5 , 0.5 , 0.5 ) for i in self . gradient_data : data_brush [ i [ 0 ]] = i [ 1 ] else : data_brush = gui . ConicalGradient ( 0.5 , 0.5 , self . null_pos ) for i in self . gradient_data : data_brush [ 1 - i [ 0 ]] = i [ 1 ] data_brush . set_coordinate_mode ( \"stretch_to_device\" ) with self . edit_palette () as palette : palette . set_brush ( \"highlight\" , data_brush ) paintEvent ( self , event : gui . PaintEvent ) paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/roundprogressbar.py def paintEvent ( self , event : gui . PaintEvent ): outer_radius = min ( self . width (), self . height ()) rect = core . RectF ( 1 , 1 , outer_radius - 2 , outer_radius - 2 ) with gui . Painter ( self ) as painter : painter . use_antialiasing () if self . bar_style != \"line\" : self . _rebuild_data_brush_if_needed () painter . fillRect ( 0 , 0 , outer_radius , outer_radius , self . palette () . window ()) self . _draw_base ( painter , rect ) self . _draw_value ( painter , rect , self . current_value ) inner_rect , inner_radius = self . _calculate_inner_rect ( outer_radius ) self . _draw_inner_background ( painter , inner_rect ) self . _draw_text ( painter , inner_rect , inner_radius , self . current_value ) spanslider SpanSlider ( Slider ) Source code in prettyqt/custom_widgets/spanslider.py class SpanSlider ( widgets . Slider ): value_changed = core . Signal ( object ) lower_pos_changed = core . Signal ( float ) upper_pos_changed = core . Signal ( float ) slider_pressed = core . Signal ( object ) def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( \"horizontal\" , parent ) self . rangeChanged . connect ( self . update_range ) self . sliderReleased . connect ( self . _move_pressed_handle ) self . lower_val = 0.0 self . upper_val = 0.0 self . lower_pos = 0.0 self . upper_pos = 0.0 self . offset = 0 self . position = 0.0 self . last_pressed : str | None = None self . upper_pressed = widgets . Style . SubControl . SC_None self . lower_pressed = widgets . Style . SubControl . SC_None self . movement : MovementModeStr = \"no_crossing\" self . _main_control : Literal [ \"lower\" , \"upper\" ] = \"lower\" self . _first_movement = False self . _block_tracking = False dark_color = self . palette () . color ( gui . Palette . ColorRole . Dark ) self . gradient_left = dark_color . lighter ( 110 ) self . gradient_right = dark_color . lighter ( 110 ) def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . _handle_mouse_press ( event . position (), self . upper_pressed , self . upper_val , \"upper\" ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . _handle_mouse_press ( event . position (), self . lower_pressed , self . lower_val , \"lower\" ) self . _first_movement = True event . accept () def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PixelMetric . PM_MaximumDragDistance , opt , self ) pixel_pos = self . pick ( event . position ()) - self . offset new_pos = float ( self . _pixel_pos_to_value ( pixel_pos )) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . position ()): new_pos = self . position # pick the preferred handle on the first movement if self . _first_movement : if self . lower_val == self . upper_val : if new_pos < self . lower_value : self . _swap_controls () self . _first_movement = False else : self . _first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper_val ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper_val - 1 ) if self . movement == \"free\" and new_pos > self . upper_val : self . _swap_controls () self . set_upper_pos ( new_pos ) else : # movement \"none\" self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower_val : self . _swap_controls () self . set_lower_pos ( new_pos ) else : # movement \"none\" self . set_upper_pos ( new_pos ) event . accept () def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SubControl . SC_None self . update () def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SubControl . SC_SliderTickmarks painter . draw_complex_control ( \"slider\" , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . draw_complex_control ( \"slider\" , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () if self . is_horizontal (): rect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) else : rect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) self . _draw_span ( painter , rect ) # handles if self . last_pressed == \"lower\" : self . draw_handle ( painter , \"upper\" ) self . draw_handle ( painter , \"lower\" ) else : self . draw_handle ( painter , \"lower\" ) self . draw_handle ( painter , \"upper\" ) @core . Property ( float ) def lower_value ( self ) -> float : return min ( self . lower_val , self . upper_val ) def set_lower_value ( self , lower : float ): self . set_span ( lower , self . upper_val ) @core . Property ( float ) def upper_value ( self ) -> float : return max ( self . lower_val , self . upper_val ) def set_upper_value ( self , upper : float ): self . set_span ( self . lower_val , upper ) def on_value_change ( self ): self . value_changed . emit (( self . lower_val , self . upper_val )) def get_value ( self ) -> tuple [ float , float ]: return ( self . lower_val , self . upper_val ) def set_value ( self , value : tuple [ float , float ]): self . set_lower_value ( value [ 0 ]) self . set_upper_value ( value [ 1 ]) def get_movement_mode ( self ) -> MovementModeStr : return self . movement def set_movement_mode ( self , mode : MovementModeStr ): \"\"\"Set movement mode. Args: mode: movement mode for the main window Raises: ValueError: movement mode type does not exist \"\"\" if mode not in MOVEMENT_MODE : raise ValueError ( \"Invalid movement mode\" ) self . movement = mode def set_span ( self , lower : float , upper : float ): low = clamp ( min ( lower , upper ), self . minimum (), self . maximum ()) upp = clamp ( max ( lower , upper ), self . minimum (), self . maximum ()) changed = False if low != self . lower_val : self . lower_val = low self . lower_pos = low changed = True if upp != self . upper_val : self . upper_val = upp self . upper_pos = upp changed = True if changed : self . on_value_change () self . update () def set_lower_pos ( self , lower : float ): if self . lower_pos == lower : return self . lower_pos = lower if not self . hasTracking (): self . update () if self . isSliderDown (): self . lower_pos_changed . emit ( lower ) if self . hasTracking () and not self . _block_tracking : main = self . _main_control == \"lower\" self . trigger_action ( \"move\" , main ) def set_upper_pos ( self , upper : float ): if self . upper_pos == upper : return self . upper_pos = upper if not self . hasTracking (): self . update () if self . isSliderDown (): self . upper_pos_changed . emit ( upper ) if self . hasTracking () and not self . _block_tracking : main = self . _main_control == \"upper\" self . trigger_action ( \"move\" , main ) def set_left_color ( self , color : types . ColorType ): self . gradient_left = colors . get_color ( color ) self . update () def set_right_color ( self , color : types . ColorType ): self . gradient_right = colors . get_color ( color ) self . update () def _move_pressed_handle ( self ): if self . last_pressed == \"lower\" : if self . lower_pos != self . lower_val : main = self . _main_control == \"lower\" self . trigger_action ( \"move\" , main ) elif self . last_pressed == \"upper\" : if self . upper_pos != self . upper_val : main = self . _main_control == \"upper\" self . trigger_action ( \"move\" , main ) def pick ( self , p : types . PointType ) -> int : if isinstance ( p , tuple ): return p [ 0 ] if self . is_horizontal () else p [ 1 ] else : return p . x () if self . is_horizontal () else p . y () def trigger_action ( self , action : ActionStr , main : bool ): value = 0.0 no = False up = False my_min = self . minimum () my_max = self . maximum () self . _block_tracking = True main_control = main and self . _main_control == \"upper\" alt_control = not main and self . _main_control == \"lower\" is_upper_handle = main_control or alt_control val = self . upper_val if is_upper_handle else self . lower_val if action == \"single_step_add\" : up = is_upper_handle value = clamp ( val + self . singleStep (), my_min , my_max ) elif action == \"single_step_sub\" : up = is_upper_handle value = clamp ( val - self . singleStep (), my_min , my_max ) elif action == \"to_minimum\" : up = is_upper_handle value = my_min elif action == \"to_maximum\" : up = is_upper_handle value = my_max elif action == \"move\" : up = is_upper_handle no = True elif action == \"none\" : no = True if not no and not up : if self . movement == \"no_crossing\" : value = min ( value , self . upper_val ) elif self . movement == \"no_overlap\" : value = min ( value , self . upper_val - 1 ) if self . movement == \"free\" and value > self . upper_val : self . _swap_controls () self . set_upper_pos ( value ) else : self . set_lower_pos ( value ) elif not no : if self . movement == \"no_crossing\" : value = max ( value , self . lower_val ) elif self . movement == \"no_overlap\" : value = max ( value , self . lower_val + 1 ) if self . movement == \"free\" and value < self . lower_val : self . _swap_controls () self . set_lower_pos ( value ) else : self . set_upper_pos ( value ) self . _block_tracking = False self . set_lower_value ( self . lower_pos ) self . set_upper_value ( self . upper_pos ) def _swap_controls ( self ): self . lower_val , self . upper_val = self . upper_val , self . lower_val self . lower_pressed , self . upper_pressed = self . upper_pressed , self . lower_pressed self . last_pressed = \"upper\" if self . last_pressed == \"lower\" else \"lower\" self . _main_control = \"upper\" if self . _main_control == \"lower\" else \"lower\" def update_range ( self , min_ , max_ ): # set_span() takes care of keeping span in range self . set_span ( self . lower_val , self . upper_val ) def _setup_painter ( self , painter : widgets . StylePainter , orientation : Literal [ \"horizontal\" , \"vertical\" ], x1 : int , y1 : int , x2 : int , y2 : int , ): highlight = self . palette () . color ( gui . Palette . ColorRole . Highlight ) gradient = gui . LinearGradient ( x1 , y1 , x2 , y2 ) gradient [ 0 ] = highlight . darker ( 120 ) gradient [ 1 ] = highlight . lighter ( 108 ) painter . setBrush ( gradient ) val = 130 if orientation == \"horizontal\" else 150 painter . set_pen ( color = highlight . darker ( val ), width = 0 ) def _draw_span ( self , painter : widgets . StylePainter , rect : core . Rect ): opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) painter . set_pen ( color = self . gradient_left , width = 0 ) groove = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) if opt . is_horizontal (): groove . adjust ( 0 , 0 , - 1 , 0 ) self . _setup_painter ( painter , opt . get_orientation (), groove . center () . x (), groove . top (), groove . center () . x (), groove . bottom (), ) else : groove . adjust ( 0 , 0 , 0 , - 1 ) self . _setup_painter ( painter , opt . get_orientation (), groove . left (), groove . center () . y (), groove . right (), groove . center () . y (), ) # draw groove intersected = core . RectF ( rect . intersected ( groove )) gradient = gui . LinearGradient ( intersected . topLeft (), intersected . topRight ()) gradient [ 0 ] = self . gradient_left gradient [ 1 ] = self . gradient_right painter . fillRect ( intersected , gradient ) def draw_handle ( self , painter : widgets . StylePainter , handle : HandleStr ): opt = self . get_style_option ( handle ) opt . subControls = HANDLE_STYLE pressed = self . upper_pressed if handle == \"lower\" : pressed = self . lower_pressed if pressed == HANDLE_STYLE : opt . activeSubControls = pressed opt . state |= widgets . Style . StateFlag . State_Sunken painter . draw_complex_control ( \"slider\" , opt ) def get_style_option ( self , handle : HandleStr ) -> widgets . StyleOptionSlider : option = widgets . StyleOptionSlider () self . initStyleOption ( option ) if handle == \"lower\" : option . sliderPosition = self . lower_pos option . sliderValue = self . lower_val else : option . sliderPosition = self . upper_pos option . sliderValue = self . upper_val return option def _handle_mouse_press ( self , pos : QtCore . QPoint , control , value : float , handle : HandleStr ): opt = self . get_style_option ( handle ) old_control = control control = self . style () . hitTestComplexControl ( SLIDER_STYLE , opt , pos , self ) sr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) if control == HANDLE_STYLE : self . position = value self . offset = self . pick ( pos - sr . topLeft ()) self . last_pressed = handle self . setSliderDown ( True ) self . slider_pressed . emit ( handle ) if control != old_control : self . update ( sr ) return control def _pixel_pos_to_value ( self , pos : int ) -> int : opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) gr = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) sr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) if self . is_horizontal (): len_slider = sr . width () slider_min = gr . x () slider_end = gr . right () else : len_slider = sr . height () slider_min = gr . y () slider_end = gr . bottom () return widgets . Style . sliderValueFromPosition ( self . minimum (), self . maximum (), pos - slider_min , slider_end - len_slider + 1 - slider_min , opt . upsideDown , ) mouseMoveEvent ( self , event ) mouseMoveEvent(self, ev: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/spanslider.py def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PixelMetric . PM_MaximumDragDistance , opt , self ) pixel_pos = self . pick ( event . position ()) - self . offset new_pos = float ( self . _pixel_pos_to_value ( pixel_pos )) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . position ()): new_pos = self . position # pick the preferred handle on the first movement if self . _first_movement : if self . lower_val == self . upper_val : if new_pos < self . lower_value : self . _swap_controls () self . _first_movement = False else : self . _first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper_val ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper_val - 1 ) if self . movement == \"free\" and new_pos > self . upper_val : self . _swap_controls () self . set_upper_pos ( new_pos ) else : # movement \"none\" self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower_val : self . _swap_controls () self . set_lower_pos ( new_pos ) else : # movement \"none\" self . set_upper_pos ( new_pos ) event . accept () mousePressEvent ( self , event ) mousePressEvent(self, ev: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/spanslider.py def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . _handle_mouse_press ( event . position (), self . upper_pressed , self . upper_val , \"upper\" ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . _handle_mouse_press ( event . position (), self . lower_pressed , self . lower_val , \"lower\" ) self . _first_movement = True event . accept () mouseReleaseEvent ( self , event ) mouseReleaseEvent(self, ev: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/spanslider.py def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SubControl . SC_None self . update () paintEvent ( self , event ) paintEvent(self, ev: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/spanslider.py def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SubControl . SC_SliderTickmarks painter . draw_complex_control ( \"slider\" , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . draw_complex_control ( \"slider\" , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () if self . is_horizontal (): rect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) else : rect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) self . _draw_span ( painter , rect ) # handles if self . last_pressed == \"lower\" : self . draw_handle ( painter , \"upper\" ) self . draw_handle ( painter , \"lower\" ) else : self . draw_handle ( painter , \"lower\" ) self . draw_handle ( painter , \"upper\" ) set_movement_mode ( self , mode : MovementModeStr ) Set movement mode. Parameters: Name Type Description Default mode MovementModeStr movement mode for the main window required Exceptions: Type Description ValueError movement mode type does not exist Source code in prettyqt/custom_widgets/spanslider.py def set_movement_mode ( self , mode : MovementModeStr ): \"\"\"Set movement mode. Args: mode: movement mode for the main window Raises: ValueError: movement mode type does not exist \"\"\" if mode not in MOVEMENT_MODE : raise ValueError ( \"Invalid movement mode\" ) self . movement = mode trigger_action ( self , action : ActionStr , main : bool ) Trigger slider action. Source code in prettyqt/custom_widgets/spanslider.py def trigger_action ( self , action : ActionStr , main : bool ): value = 0.0 no = False up = False my_min = self . minimum () my_max = self . maximum () self . _block_tracking = True main_control = main and self . _main_control == \"upper\" alt_control = not main and self . _main_control == \"lower\" is_upper_handle = main_control or alt_control val = self . upper_val if is_upper_handle else self . lower_val if action == \"single_step_add\" : up = is_upper_handle value = clamp ( val + self . singleStep (), my_min , my_max ) elif action == \"single_step_sub\" : up = is_upper_handle value = clamp ( val - self . singleStep (), my_min , my_max ) elif action == \"to_minimum\" : up = is_upper_handle value = my_min elif action == \"to_maximum\" : up = is_upper_handle value = my_max elif action == \"move\" : up = is_upper_handle no = True elif action == \"none\" : no = True if not no and not up : if self . movement == \"no_crossing\" : value = min ( value , self . upper_val ) elif self . movement == \"no_overlap\" : value = min ( value , self . upper_val - 1 ) if self . movement == \"free\" and value > self . upper_val : self . _swap_controls () self . set_upper_pos ( value ) else : self . set_lower_pos ( value ) elif not no : if self . movement == \"no_crossing\" : value = max ( value , self . lower_val ) elif self . movement == \"no_overlap\" : value = max ( value , self . lower_val + 1 ) if self . movement == \"free\" and value < self . lower_val : self . _swap_controls () self . set_lower_pos ( value ) else : self . set_upper_pos ( value ) self . _block_tracking = False self . set_lower_value ( self . lower_pos ) self . set_upper_value ( self . upper_pos ) subsequencecompleter SubsequenceCompleter ( Completer ) Source code in prettyqt/custom_widgets/subsequencecompleter.py class SubsequenceCompleter ( widgets . Completer ): \"\"\"QCompleter specialised for subsequence matching.\"\"\" def __init__ ( self , * args ): super () . __init__ ( * args ) self . local_completion_prefix = \"\" self . source_model = None self . proxy_model = custom_models . SubsequenceSortFilterProxyModel ( self . is_case_sensitive (), parent = self ) self . proxy_model . set_sort_role ( \"user\" ) self . _force_next_update = True def setModel ( self , model : QtCore . QAbstractItemModel ): self . source_model = model self . proxy_model = custom_models . SubsequenceSortFilterProxyModel ( self . is_case_sensitive (), parent = self ) self . proxy_model . set_sort_role ( \"user\" ) self . proxy_model . set_prefix ( self . local_completion_prefix ) self . proxy_model . setSourceModel ( self . source_model ) super () . setModel ( self . proxy_model ) self . proxy_model . invalidate () self . proxy_model . sort ( 0 ) self . _force_next_update = True def update_model ( self ): count = self . completionCount () if count or len ( self . local_completion_prefix ) <= 1 or self . _force_next_update : self . proxy_model . set_prefix ( self . local_completion_prefix ) self . proxy_model . invalidate () # force sorting/filtering if count > 1 : self . proxy_model . sort ( 0 ) self . _force_next_update = False def splitPath ( self , path : str ) -> list [ str ]: self . local_completion_prefix = path self . update_model () return [ \"\" ] setModel ( self , model : QtCore . QAbstractItemModel ) setModel(self, c: PySide6.QtCore.QAbstractItemModel) -> None Source code in prettyqt/custom_widgets/subsequencecompleter.py def setModel ( self , model : QtCore . QAbstractItemModel ): self . source_model = model self . proxy_model = custom_models . SubsequenceSortFilterProxyModel ( self . is_case_sensitive (), parent = self ) self . proxy_model . set_sort_role ( \"user\" ) self . proxy_model . set_prefix ( self . local_completion_prefix ) self . proxy_model . setSourceModel ( self . source_model ) super () . setModel ( self . proxy_model ) self . proxy_model . invalidate () self . proxy_model . sort ( 0 ) self . _force_next_update = True splitPath ( self , path : str ) -> list [ str ] splitPath(self, path: str) -> List[str] Source code in prettyqt/custom_widgets/subsequencecompleter.py def splitPath ( self , path : str ) -> list [ str ]: self . local_completion_prefix = path self . update_model () return [ \"\" ] timeline Timeline ( Widget ) Source code in prettyqt/custom_widgets/timeline.py class Timeline ( widgets . Widget ): position_changed = core . Signal ( int ) selection_changed = core . Signal ( VideoSample ) def __init__ ( self , duration : int , length : int ): super () . __init__ () self . set_title ( \"Timeline\" ) self . duration = duration self . length = length # Set variables self . set_background_color ( BACKGROUND_COLOR ) self . set_text_color ( TEXT_COLOR ) self . set_text_font ( FONT ) self . _position = None self . pointer_time_pos = 0.0 self . selected_sample = None self . _clicking = False # Check if mouse left button is being pressed self . _is_in = False # check if user is in the widget self . video_samples : list [ VideoSample ] = [] # List of video samples self . setMouseTracking ( True ) # Mouse events self . setAutoFillBackground ( True ) # background self . setGeometry ( 300 , 300 , self . length , 200 ) # Set Background with self . edit_palette () as pal : pal . set_color ( \"window\" , self . background_color ) def __len__ ( self ): return len ( self . video_samples ) def __getitem__ ( self , index : int ) -> VideoSample : return self . video_samples [ index ] def __setitem__ ( self , index : int , value : VideoSample ): self . video_samples [ index ] = value def __add__ ( self , other : VideoSample ) -> Timeline : self . add ( other ) return self def add_sample ( self , duration : int , color : types . ColorType = \"yellow\" , picture : QtGui . QPixmap | None = None , ) -> VideoSample : sample = VideoSample ( duration , color , picture ) self . add ( sample ) return sample def add ( self , sample : VideoSample ): self . video_samples . append ( sample ) def paintEvent ( self , event ): # Draw time scale = self . get_scale () with gui . Painter ( self ) as qp : qp . set_color ( self . text_color ) qp . setFont ( self . text_font ) qp . use_antialiasing () w = 0 while ( w := w + 100 ) <= self . width (): time_string = helpers . format_seconds ( w * scale ) rect = core . Rect ( w - 50 , 0 , 100 , 100 ) qp . drawText ( rect , constants . ALIGN_H_CENTER , time_string ) # Draw down line qp . set_pen ( color = PEN_COLOR , width = 5 ) qp . drawLine ( 0 , 40 , self . width (), 40 ) # Draw dash lines point = 0 qp . set_pen ( color = self . text_color ) qp . drawLine ( 0 , 40 , self . width (), 40 ) while point <= self . width (): y2 = 30 if point % 30 != 0 else 20 qp . drawLine ( 3 * point , 40 , 3 * point , y2 ) point += 10 if self . _position is not None and self . _is_in : qp . drawLine ( self . _position . x (), 0 , self . _position . x (), 40 ) poly = gui . Polygon () if self . _position is not None : val = self . pointer_time_pos / self . get_scale () line = core . Line ( val , 40 , val , self . height ()) poly . add_points (( val - 10 , 20 ), ( val + 10 , 20 ), ( val , 40 )) else : line = core . Line ( 0 , 0 , 0 , self . height ()) poly . add_points (( - 10 , 20 ), ( 10 , 20 ), ( 0 , 40 )) # Draw samples t = 0.0 for sample in self . video_samples : scaled_dur = sample . duration / scale scaled_t = t / scale t += sample . duration # Clear clip path with qp . clip_path () as path : rect = core . RectF ( scaled_t , 50 , scaled_dur , 200 ) path . addRoundedRect ( rect , 10 , 10 ) # Draw sample path = gui . PainterPath () qp . set_pen ( color = sample . color ) rect = core . RectF ( scaled_t , 50 , scaled_dur , 50 ) path . addRoundedRect ( rect , 10 , 10 ) sample . start_pos = scaled_t sample . end_pos = scaled_t + scaled_dur qp . fillPath ( path , sample . color ) qp . drawPath ( path ) # Draw preview pictures if sample . picture is None : continue pic_width = sample . picture . size () . width () if pic_width < scaled_dur : width = float ( pic_width ) pic = sample . picture else : width = scaled_dur pic = sample . picture . copy ( 0 , 0 , int ( scaled_dur ), 45 ) with qp . clip_path () as path : rect = core . RectF ( scaled_t , 52.5 , width , 45 ) path . addRoundedRect ( rect , 10 , 10 ) qp . drawPixmap ( int ( scaled_t ), int ( 52.5 ), int ( width ), 45 , pic ) # Clear clip path with qp . clip_path () as path : path . add_rect ( self . rect ()) # Draw pointer qp . set_color ( PEN_COLOR ) qp . set_brush ( PEN_COLOR ) qp . drawPolygon ( poly ) qp . drawLine ( line ) def mouseMoveEvent ( self , e ): self . _position = e . position () # if mouse is being pressed, update pointer if self . _clicking : x = self . _position . x () self . position_changed . emit ( x ) self . _check_selection ( x ) self . pointer_time_pos = x * self . get_scale () self . update () def mousePressEvent ( self , e ): if e . button () == QtCore . Qt . MouseButton . LeftButton : x = e . position () . x () self . position_changed . emit ( x ) self . pointer_time_pos = x * self . get_scale () self . _check_selection ( x ) self . update () self . _clicking = True # Set clicking check to true def mouseReleaseEvent ( self , e ): if e . button () == QtCore . Qt . MouseButton . LeftButton : self . _clicking = False # Set clicking check to false def enterEvent ( self , e ): self . _is_in = True def leaveEvent ( self , e ): self . _is_in = False self . update () def _check_selection ( self , x : int ): # Check if user clicked in video sample for sample in self . video_samples : if sample . start_pos < x < sample . end_pos : sample . color = gui . Color ( PEN_COLOR ) if self . selected_sample is not sample : self . selected_sample = sample self . selection_changed . emit ( sample ) else : sample . color = sample . def_color def get_scale ( self ) -> float : return self . duration / self . width () def set_background_color ( self , color : types . ColorType ): color = colors . get_color ( color ) self . background_color = color def set_text_color ( self , color : types . ColorType ): color = colors . get_color ( color ) self . text_color = color def set_text_font ( self , font : QtGui . QFont ): self . text_font = font enterEvent ( self , e ) enterEvent(self, event: PySide6.QtGui.QEnterEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def enterEvent ( self , e ): self . _is_in = True leaveEvent ( self , e ) leaveEvent(self, event: PySide6.QtCore.QEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def leaveEvent ( self , e ): self . _is_in = False self . update () mouseMoveEvent ( self , e ) mouseMoveEvent(self, event: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def mouseMoveEvent ( self , e ): self . _position = e . position () # if mouse is being pressed, update pointer if self . _clicking : x = self . _position . x () self . position_changed . emit ( x ) self . _check_selection ( x ) self . pointer_time_pos = x * self . get_scale () self . update () mousePressEvent ( self , e ) mousePressEvent(self, event: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def mousePressEvent ( self , e ): if e . button () == QtCore . Qt . MouseButton . LeftButton : x = e . position () . x () self . position_changed . emit ( x ) self . pointer_time_pos = x * self . get_scale () self . _check_selection ( x ) self . update () self . _clicking = True # Set clicking check to true mouseReleaseEvent ( self , e ) mouseReleaseEvent(self, event: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def mouseReleaseEvent ( self , e ): if e . button () == QtCore . Qt . MouseButton . LeftButton : self . _clicking = False # Set clicking check to false paintEvent ( self , event ) paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def paintEvent ( self , event ): # Draw time scale = self . get_scale () with gui . Painter ( self ) as qp : qp . set_color ( self . text_color ) qp . setFont ( self . text_font ) qp . use_antialiasing () w = 0 while ( w := w + 100 ) <= self . width (): time_string = helpers . format_seconds ( w * scale ) rect = core . Rect ( w - 50 , 0 , 100 , 100 ) qp . drawText ( rect , constants . ALIGN_H_CENTER , time_string ) # Draw down line qp . set_pen ( color = PEN_COLOR , width = 5 ) qp . drawLine ( 0 , 40 , self . width (), 40 ) # Draw dash lines point = 0 qp . set_pen ( color = self . text_color ) qp . drawLine ( 0 , 40 , self . width (), 40 ) while point <= self . width (): y2 = 30 if point % 30 != 0 else 20 qp . drawLine ( 3 * point , 40 , 3 * point , y2 ) point += 10 if self . _position is not None and self . _is_in : qp . drawLine ( self . _position . x (), 0 , self . _position . x (), 40 ) poly = gui . Polygon () if self . _position is not None : val = self . pointer_time_pos / self . get_scale () line = core . Line ( val , 40 , val , self . height ()) poly . add_points (( val - 10 , 20 ), ( val + 10 , 20 ), ( val , 40 )) else : line = core . Line ( 0 , 0 , 0 , self . height ()) poly . add_points (( - 10 , 20 ), ( 10 , 20 ), ( 0 , 40 )) # Draw samples t = 0.0 for sample in self . video_samples : scaled_dur = sample . duration / scale scaled_t = t / scale t += sample . duration # Clear clip path with qp . clip_path () as path : rect = core . RectF ( scaled_t , 50 , scaled_dur , 200 ) path . addRoundedRect ( rect , 10 , 10 ) # Draw sample path = gui . PainterPath () qp . set_pen ( color = sample . color ) rect = core . RectF ( scaled_t , 50 , scaled_dur , 50 ) path . addRoundedRect ( rect , 10 , 10 ) sample . start_pos = scaled_t sample . end_pos = scaled_t + scaled_dur qp . fillPath ( path , sample . color ) qp . drawPath ( path ) # Draw preview pictures if sample . picture is None : continue pic_width = sample . picture . size () . width () if pic_width < scaled_dur : width = float ( pic_width ) pic = sample . picture else : width = scaled_dur pic = sample . picture . copy ( 0 , 0 , int ( scaled_dur ), 45 ) with qp . clip_path () as path : rect = core . RectF ( scaled_t , 52.5 , width , 45 ) path . addRoundedRect ( rect , 10 , 10 ) qp . drawPixmap ( int ( scaled_t ), int ( 52.5 ), int ( width ), 45 , pic ) # Clear clip path with qp . clip_path () as path : path . add_rect ( self . rect ()) # Draw pointer qp . set_color ( PEN_COLOR ) qp . set_brush ( PEN_COLOR ) qp . drawPolygon ( poly ) qp . drawLine ( line ) waitingspinner The MIT License (MIT). Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. BaseWaitingSpinner ( Widget ) Source code in prettyqt/custom_widgets/waitingspinner.py class BaseWaitingSpinner ( widgets . Widget ): def __init__ ( self , parent : QtWidgets . QWidget | None , modality : constants . ModalityStr = \"none\" , ): super () . __init__ ( parent = parent ) # WAS IN initialize() self . _color = self . get_palette () . get_color ( \"text\" ) self . _roundness = 100.0 self . _minimum_trail_opacity = 3.14159265358979323846 self . _trail_fade_percentage = 80.0 self . _revolutions_per_second = 1.57079632679489661923 self . _line_num = 20 self . _line_length = 10 self . _line_width = 2 self . _inner_radius = 10 self . _current_counter = 0 self . _timer = core . Timer ( self ) self . _timer . timeout . connect ( self . _rotate ) self . _update_size () self . _update_timer () self . hide () # END initialize() self . set_modality ( modality ) # self.setAttribute(QtCore.Qt.WA_TranslucentBackground) def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( style = \"none\" ) painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length ) rect = core . RectF ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) for i in range ( self . _line_num ): with painter . backup_state (): rotate_angle = 360 * i / self . _line_num painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . _current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . SizeMode . RelativeSize , ) def start ( self ): self . show () if not self . _timer . isActive (): self . _timer . start () self . _current_counter = 0 def stop ( self ): self . hide () if self . _timer . isActive (): self . _timer . stop () self . _current_counter = 0 def set_line_num ( self , lines : int ): self . _line_num = lines self . _current_counter = 0 self . _update_timer () def set_line_length ( self , length : int ): self . _line_length = length self . _update_size () def set_line_width ( self , width : int ): self . _line_width = width def set_inner_radius ( self , radius : int ): self . _inner_radius = radius self . _update_size () def color ( self ) -> gui . Color : return self . _color def roundness ( self ) -> float : return self . _roundness def minimum_trail_opacity ( self ) -> float : return self . _minimum_trail_opacity def trail_fade_percentage ( self ) -> float : return self . _trail_fade_percentage def revolutions_per_second ( self ) -> float : return self . _revolutions_per_second def line_num ( self ) -> int : return self . _line_num def line_length ( self ) -> int : return self . _line_length def line_width ( self ) -> int : return self . _line_width def inner_radius ( self ) -> int : return self . _inner_radius def is_spinning ( self ) -> bool : return self . _timer . isActive () def set_roundness ( self , roundness : float ): self . _roundness = max ( 0.0 , min ( 100.0 , roundness )) def set_color ( self , color : types . ColorType = \"black\" ): self . _color = colors . get_color ( color ) def set_revolutions_per_second ( self , _revolutions_per_second : float ): self . _revolutions_per_second = _revolutions_per_second self . _update_timer () def set_trail_fade_percentage ( self , trail : float ): self . _trail_fade_percentage = trail def set_minimum_trail_opacity ( self , minimum_trail_opacity : float ): self . _minimum_trail_opacity = minimum_trail_opacity def _rotate ( self ): self . _current_counter += 1 if self . _current_counter >= self . _line_num : self . _current_counter = 0 self . update () def _update_size ( self ): size = ( self . _inner_radius + self . _line_length ) * 2 self . setFixedSize ( size , size ) def _update_timer ( self ): divider = int ( self . _line_num * self . _revolutions_per_second ) self . _timer . setInterval ( 1000 // divider ) def linecount_distance_from_primary ( self , current : int , primary : int , total_lines : int ) -> int : distance = primary - current if distance < 0 : distance += total_lines return distance def _current_line_color ( self , count_distance : int , total_lines : int , fade_perc : float , min_opacity : float , color : gui . Color , ) -> gui . Color : color = gui . Color ( color ) if count_distance == 0 : return color min_alpha_f = min_opacity / 100 dist_threshold = int ( math . ceil (( total_lines - 1 ) * fade_perc / 100 )) if count_distance > dist_threshold : color . setAlphaF ( min_alpha_f ) else : alpha = color . alphaF () alpha_diff = alpha - min_alpha_f gradient = alpha_diff / ( dist_threshold + 1 ) result_alpha = alpha - gradient * count_distance # If alpha is out of bounds, clip it. result_alpha = min ( 1.0 , max ( 0.0 , result_alpha )) color . setAlphaF ( result_alpha ) return color paintEvent ( self , event ) paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( style = \"none\" ) painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length ) rect = core . RectF ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) for i in range ( self . _line_num ): with painter . backup_state (): rotate_angle = 360 * i / self . _line_num painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . _current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . SizeMode . RelativeSize , ) WaitingSpinner ( BaseWaitingSpinner ) Source code in prettyqt/custom_widgets/waitingspinner.py class WaitingSpinner ( BaseWaitingSpinner ): def __init__ ( self , parent : QtWidgets . QWidget | None , center_on_parent : bool = True , disable_parent : bool = True , modality : constants . ModalityStr = \"none\" , additional_disabled = None , ): super () . __init__ ( parent = parent , modality = modality ) self . _center_on_parent = center_on_parent self . _disable_parent = disable_parent self . additional_disabled = additional_disabled if additional_disabled else [] def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event ) def start ( self ): self . _update_position () super () . start () if self . parentWidget and self . _disable_parent : self . parentWidget () . setEnabled ( False ) for item in self . additional_disabled : item . setEnabled ( False ) def stop ( self ): super () . stop () if self . parentWidget () and self . _disable_parent : self . parentWidget () . setEnabled ( True ) for item in self . additional_disabled : item . setEnabled ( True ) def _update_position ( self ): parent = self . parentWidget () if parent and self . _center_on_parent : self . move ( parent . width () // 2 - self . width () // 2 , parent . height () // 2 - self . height () // 2 , ) paintEvent ( self , event ) paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event )","title":"custom_widgets"},{"location":"api/custom_widgets.html#custom_widgets-module","text":"Module containing custom widget classes.","title":"custom_widgets module"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout","text":"","title":"borderlayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout","text":"Source code in prettyqt/custom_widgets/borderlayout.py class BorderLayout ( widgets . Layout ): class Position ( enum . IntEnum ): \"\"\"Item position.\"\"\" West = 0 North = 1 South = 2 East = 3 Center = 4 QtCore . QEnum ( Position ) def __init__ ( self , parent : QtWidgets . QWidget | None = None , margin : int = 0 , spacing : int | None = None , ): super () . __init__ ( parent ) # type: ignore self . set_margin ( margin ) self . setSpacing ( spacing if spacing is not None else - 1 ) self . items : list [ ItemWrapper ] = [] def __del__ ( self ): item = self . takeAt ( 0 ) while item : item = self . takeAt ( 0 ) def addItem ( self , item : QtWidgets . QWidgetItem ): self . add_widgetitem ( item , BorderLayout . Position . West ) def addWidget ( self , widget : QtWidgets . QWidget , position : Position = Position . West , ): self . add_widgetitem ( widgets . WidgetItem ( widget ), position ) def expandingDirections ( self ): return constants . HORIZONTAL | constants . VERTICAL # type: ignore def hasHeightForWidth ( self ) -> bool : return False def count ( self ) -> int : return len ( self . items ) def itemAt ( self , index : int ) -> QtWidgets . QWidgetItem | None : # type: ignore if index < len ( self . items ): return self . items [ index ] . item return None def minimumSize ( self ): return self . calculate_size ( \"minimum\" ) def setGeometry ( self , rect : QtCore . QRect ): center = None east_width = 0 west_width = 0 north_height = 0 south_height = 0 super () . setGeometry ( rect ) for wrapper in self . items : item = wrapper . item position = wrapper . position if position == BorderLayout . Position . North : geom = core . Rect ( rect . x (), north_height , rect . width (), item . sizeHint () . height () ) item . setGeometry ( geom ) north_height += item . geometry () . height () + self . spacing () elif position == BorderLayout . Position . South : geom = core . Rect ( item . geometry () . x (), item . geometry () . y (), rect . width (), item . sizeHint () . height (), ) item . setGeometry ( geom ) south_height += item . geometry () . height () + self . spacing () geom = core . Rect ( rect . x (), rect . y () + rect . height () - south_height + self . spacing (), item . geometry () . width (), item . geometry () . height (), ) item . setGeometry ( geom ) elif position == BorderLayout . Position . Center : center = wrapper center_height = rect . height () - north_height - south_height for wrapper in self . items : item = wrapper . item position = wrapper . position if position == BorderLayout . Position . West : geom = core . Rect ( rect . x () + west_width , north_height , item . sizeHint () . width (), center_height , ) item . setGeometry ( geom ) west_width += item . geometry () . width () + self . spacing () elif position == BorderLayout . Position . East : geom = core . Rect ( item . geometry () . x (), item . geometry () . y (), item . sizeHint () . width (), center_height , ) item . setGeometry ( geom ) east_width += item . geometry () . width () + self . spacing () geom = core . Rect ( rect . x () + rect . width () - east_width + self . spacing (), north_height , item . geometry () . width (), item . geometry () . height (), ) item . setGeometry ( geom ) if center : rect = core . Rect ( west_width , north_height , rect . width () - east_width - west_width , center_height , ) center . item . setGeometry ( rect ) def sizeHint ( self ) -> core . Size : return self . calculate_size ( \"size_hint\" ) def takeAt ( self , index : int ) -> QtWidgets . QWidgetItem | None : # type: ignore if 0 <= index < len ( self . items ): layout_struct = self . items . pop ( index ) return layout_struct . item return None def add_widgetitem ( self , item : QtWidgets . QWidgetItem , position : Position ): self . items . append ( ItemWrapper ( item , position )) def calculate_size ( self , size_type : Literal [ \"minimum\" , \"size_hint\" ]) -> core . Size : total_size = core . Size () for wrapper in self . items : position = wrapper . position if size_type == \"minimum\" : item_size = wrapper . item . minimumSize () else : # size_type == \"size_hint\" item_size = wrapper . item . sizeHint () if position in ( BorderLayout . Position . North , BorderLayout . Position . South , BorderLayout . Position . Center , ): total_size . setHeight ( total_size . height () + item_size . height ()) if position in ( BorderLayout . Position . West , BorderLayout . Position . East , BorderLayout . Position . Center , ): total_size . setWidth ( total_size . width () + item_size . width ()) return total_size","title":"BorderLayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.Position","text":"Item position. Source code in prettyqt/custom_widgets/borderlayout.py class Position ( enum . IntEnum ): \"\"\"Item position.\"\"\" West = 0 North = 1 South = 2 East = 3 Center = 4","title":"Position"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.addItem","text":"addItem(self, arg__1: PySide6.QtWidgets.QLayoutItem) -> None Source code in prettyqt/custom_widgets/borderlayout.py def addItem ( self , item : QtWidgets . QWidgetItem ): self . add_widgetitem ( item , BorderLayout . Position . West )","title":"addItem()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.addWidget","text":"addWidget(self, w: PySide6.QtWidgets.QWidget) -> None Source code in prettyqt/custom_widgets/borderlayout.py def addWidget ( self , widget : QtWidgets . QWidget , position : Position = Position . West , ): self . add_widgetitem ( widgets . WidgetItem ( widget ), position )","title":"addWidget()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.count","text":"count(self) -> int Source code in prettyqt/custom_widgets/borderlayout.py def count ( self ) -> int : return len ( self . items )","title":"count()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.expandingDirections","text":"expandingDirections(self) -> PySide6.QtCore.Qt.Orientation Source code in prettyqt/custom_widgets/borderlayout.py def expandingDirections ( self ): return constants . HORIZONTAL | constants . VERTICAL # type: ignore","title":"expandingDirections()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.hasHeightForWidth","text":"hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/borderlayout.py def hasHeightForWidth ( self ) -> bool : return False","title":"hasHeightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.itemAt","text":"itemAt(self, index: int) -> PySide6.QtWidgets.QLayoutItem Source code in prettyqt/custom_widgets/borderlayout.py def itemAt ( self , index : int ) -> QtWidgets . QWidgetItem | None : # type: ignore if index < len ( self . items ): return self . items [ index ] . item return None","title":"itemAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.minimumSize","text":"minimumSize(self) -> PySide6.QtCore.QSize Source code in prettyqt/custom_widgets/borderlayout.py def minimumSize ( self ): return self . calculate_size ( \"minimum\" )","title":"minimumSize()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.setGeometry","text":"setGeometry(self, arg__1: PySide6.QtCore.QRect) -> None Source code in prettyqt/custom_widgets/borderlayout.py def setGeometry ( self , rect : QtCore . QRect ): center = None east_width = 0 west_width = 0 north_height = 0 south_height = 0 super () . setGeometry ( rect ) for wrapper in self . items : item = wrapper . item position = wrapper . position if position == BorderLayout . Position . North : geom = core . Rect ( rect . x (), north_height , rect . width (), item . sizeHint () . height () ) item . setGeometry ( geom ) north_height += item . geometry () . height () + self . spacing () elif position == BorderLayout . Position . South : geom = core . Rect ( item . geometry () . x (), item . geometry () . y (), rect . width (), item . sizeHint () . height (), ) item . setGeometry ( geom ) south_height += item . geometry () . height () + self . spacing () geom = core . Rect ( rect . x (), rect . y () + rect . height () - south_height + self . spacing (), item . geometry () . width (), item . geometry () . height (), ) item . setGeometry ( geom ) elif position == BorderLayout . Position . Center : center = wrapper center_height = rect . height () - north_height - south_height for wrapper in self . items : item = wrapper . item position = wrapper . position if position == BorderLayout . Position . West : geom = core . Rect ( rect . x () + west_width , north_height , item . sizeHint () . width (), center_height , ) item . setGeometry ( geom ) west_width += item . geometry () . width () + self . spacing () elif position == BorderLayout . Position . East : geom = core . Rect ( item . geometry () . x (), item . geometry () . y (), item . sizeHint () . width (), center_height , ) item . setGeometry ( geom ) east_width += item . geometry () . width () + self . spacing () geom = core . Rect ( rect . x () + rect . width () - east_width + self . spacing (), north_height , item . geometry () . width (), item . geometry () . height (), ) item . setGeometry ( geom ) if center : rect = core . Rect ( west_width , north_height , rect . width () - east_width - west_width , center_height , ) center . item . setGeometry ( rect )","title":"setGeometry()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.sizeHint","text":"sizeHint(self) -> PySide6.QtCore.QSize Source code in prettyqt/custom_widgets/borderlayout.py def sizeHint ( self ) -> core . Size : return self . calculate_size ( \"size_hint\" )","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.takeAt","text":"takeAt(self, index: int) -> PySide6.QtWidgets.QLayoutItem Source code in prettyqt/custom_widgets/borderlayout.py def takeAt ( self , index : int ) -> QtWidgets . QWidgetItem | None : # type: ignore if 0 <= index < len ( self . items ): layout_struct = self . items . pop ( index ) return layout_struct . item return None","title":"takeAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.ItemWrapper","text":"ItemWrapper(item: 'QtWidgets.QWidgetItem', position: 'BorderLayout.Position') Source code in prettyqt/custom_widgets/borderlayout.py @dataclass class ItemWrapper : item : QtWidgets . QWidgetItem position : BorderLayout . Position","title":"ItemWrapper"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor","text":"","title":"codeeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor","text":"Source code in prettyqt/custom_widgets/codeeditor.py class CodeEditor ( widgets . PlainTextEdit ): def __init__ ( self , language : str = \"python\" , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent = parent ) self . line_area = LineNumberArea ( self ) self . blockCountChanged . connect ( self . update_line_area_width ) self . updateRequest . connect ( self . update_line_area ) self . cursorPositionChanged . connect ( self . highlight_current_line ) self . set_font ( \"Consolas\" ) self . update_line_area_width ( 0 ) self . highlight_current_line () self . set_syntaxhighlighter ( language ) def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect ) def text ( self ) -> str : return self . toPlainText () def line_area_width ( self ) -> int : digits = len ( str ( self . blockCount ())) return 3 + self . fontMetrics () . boundingRect ( \"9\" ) . width () * digits def update_line_area_width ( self , _ ): self . setViewportMargins ( self . line_area_width (), 0 , 0 , 0 ) def update_line_area ( self , rect : QtCore . QRect , dy : int ): if dy : self . line_area . scroll ( 0 , dy ) else : self . line_area . update ( 0 , rect . y (), self . line_area . width (), rect . height ()) if rect . contains ( self . viewport () . rect ()): self . update_line_area_width ( 0 ) def line_area_paintevent ( self , event ): with gui . Painter ( self . line_area ) as painter : painter . fill_rect ( event . rect (), \"lightgray\" ) block = self . firstVisibleBlock () block_number = block . blockNumber () top = self . blockBoundingGeometry ( block ) . translated ( self . contentOffset ()) . top () bottom = top + self . blockBoundingRect ( block ) . height () width = self . line_area . width () height = self . fontMetrics () . height () painter . set_color ( \"black\" ) while block . isValid () and ( top <= event . rect () . bottom ()): if block . isVisible () and ( bottom >= event . rect () . top ()): number = str ( block_number + 1 ) painter . drawText ( 0 , int ( top ), width , height , constants . ALIGN_RIGHT , number ) block = block . next () top = bottom bottom = top + self . blockBoundingRect ( block ) . height () block_number += 1","title":"CodeEditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor.resizeEvent","text":"resizeEvent(self, e: PySide6.QtGui.QResizeEvent) -> None Source code in prettyqt/custom_widgets/codeeditor.py def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea","text":"Source code in prettyqt/custom_widgets/codeeditor.py class LineNumberArea ( widgets . Widget ): def __init__ ( self , editor : CodeEditor ): super () . __init__ ( editor ) self . editor = editor def sizeHint ( self ) -> core . Size : return core . Size ( self . editor . line_area_width (), 0 ) def paintEvent ( self , event ): self . editor . line_area_paintevent ( event )","title":"LineNumberArea"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.paintEvent","text":"paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/codeeditor.py def paintEvent ( self , event ): self . editor . line_area_paintevent ( event )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.sizeHint","text":"sizeHint(self) -> PySide6.QtCore.QSize Source code in prettyqt/custom_widgets/codeeditor.py def sizeHint ( self ) -> core . Size : return core . Size ( self . editor . line_area_width (), 0 )","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget","text":"A dropdown completer widget for the text edits.","title":"completionwidget"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget","text":"Source code in prettyqt/custom_widgets/completionwidget.py class CompletionWidget ( widgets . ListWidget ): def __init__ ( self , textedit : QtWidgets . QTextEdit | QtWidgets . QPlainTextEdit ): super () . __init__ ( parent = textedit ) self . _text_edit = textedit self . set_edit_triggers ( \"none\" ) self . set_selection_behaviour ( \"rows\" ) self . set_selection_mode ( \"single\" ) # We need Popup style to ensure correct mouse interaction # (dialog would dissappear on mouse click with ToolTip style) self . setWindowFlags ( QtCore . Qt . WindowType . Popup ) # type: ignore self . setAttribute ( QtCore . Qt . WidgetAttribute . WA_StaticContents ) original_policy = self . _text_edit . focusPolicy () self . set_focus_policy ( \"none\" ) self . _text_edit . setFocusPolicy ( original_policy ) # Ensure that the text edit keeps focus when widget is displayed. self . setFocusProxy ( self . _text_edit ) self . set_frame_shadow ( \"plain\" ) self . set_frame_shape ( \"styled_panel\" ) self . itemActivated . connect ( self . _complete_current ) def eventFilter ( self , obj , event ): \"\"\"Handle mouse input and to auto-hide when losing focus.\"\"\" if obj is self : if event . type () == QtCore . QEvent . Type . MouseButtonPress : pos = self . mapToGlobal ( event . pos ()) target = QtWidgets . QApplication . widgetAt ( pos ) if target and self . isAncestorOf ( target ) or target is self : return False else : self . cancel_completion () return super () . eventFilter ( obj , event ) def keyPressEvent ( self , event ): key = event . key () if key in ( QtCore . Qt . Key . Key_Return , QtCore . Qt . Key . Key_Enter , QtCore . Qt . Key . Key_Tab , ): self . _complete_current () elif key == QtCore . Qt . Key . Key_Escape : self . hide () elif key in ( QtCore . Qt . Key . Key_Up , QtCore . Qt . Key . Key_Down , QtCore . Qt . Key . Key_PageUp , QtCore . Qt . Key . Key_PageDown , QtCore . Qt . Key . Key_Home , QtCore . Qt . Key . Key_End , ): return super () . keyPressEvent ( event ) else : QtWidgets . QApplication . sendEvent ( self . _text_edit , event ) # 'QWidget' interface def hideEvent ( self , event ): \"\"\"Disconnect signal handlers and event filter.\"\"\" super () . hideEvent ( event ) try : self . _text_edit . cursorPositionChanged . disconnect ( self . _update_current ) except TypeError : pass self . removeEventFilter ( self ) def showEvent ( self , event ): \"\"\"Connect signal handlers and event filter.\"\"\" super () . showEvent ( event ) self . _text_edit . cursorPositionChanged . connect ( self . _update_current ) self . installEventFilter ( self ) # 'CompletionWidget' interface def show_items ( self , cursor , items : list [ str ], prefix_length : int = 0 ): \"\"\"Show the widget with 'items' at the position specified by 'cursor'.\"\"\" point = self . _get_top_left_position ( cursor ) self . clear () path_items = [] for item in items : # Check if the item could refer to a file or dir. The replacing # of '\"' is needed for items on Windows path = os . path . abspath ( item . replace ( '\"' , \"\" )) if os . path . isfile ( path ) or os . path . isdir ( path ): path_items . append ( item . replace ( '\"' , \"\" )) else : list_item = widgets . ListWidgetItem () list_item . setData ( QtCore . Qt . ItemDataRole . UserRole , item ) # type: ignore # Need to split to only show last element of a dot completion list_item . setText ( item . split ( \".\" )[ - 1 ]) self . addItem ( list_item ) common_prefix = os . path . dirname ( os . path . commonprefix ( path_items )) for path_item in path_items : list_item = widgets . ListWidgetItem () list_item . setData ( QtCore . Qt . ItemDataRole . UserRole , path_item ) # type: ignore text = path_item . split ( common_prefix )[ - 1 ] if common_prefix else path_item list_item . setText ( text ) self . addItem ( list_item ) height = self . sizeHint () . height () screen_rect = self . get_screen () . availableGeometry () if screen_rect . size () . height () + screen_rect . y () - point . y () - height < 0 : point = self . _text_edit . mapToGlobal ( self . _text_edit . cursorRect () . topRight ()) point . setY ( int ( point . y () - height )) scrollbar_width = self . verticalScrollBar () . sizeHint () . width () w = self . sizeHintForColumn ( 0 ) + scrollbar_width + 2 * self . frameWidth () self . setGeometry ( point . x (), point . y (), w , height ) # Move cursor to start of the prefix to replace it # when a item is selected cursor . movePosition ( QtGui . QTextCursor . MoveOperation . Left , n = prefix_length ) self . _start_position = cursor . position () self . setCurrentRow ( 0 ) self . raise_ () self . show () # Protected interface def _get_top_left_position ( self , cursor : QtGui . QTextCursor ) -> QtCore . QPoint : \"\"\"Get top left position for this widget.\"\"\" point = self . _text_edit . cursorRect ( cursor ) . center () point_size = self . _text_edit . font () . pointSize () factor = 1.05 if os . name == \"nt\" else 0.98 delta = int (( point_size * 1.20 ) ** factor ) y = delta - ( point_size // 2 ) point . setY ( int ( point . y () + y )) point = self . _text_edit . mapToGlobal ( point ) return point def _complete_current ( self ): \"\"\"Perform the completion with the currently selected item.\"\"\" text = self . currentItem () . data ( QtCore . Qt . ItemDataRole . UserRole ) # type: ignore self . _current_text_cursor () . insertText ( text ) self . hide () def _current_text_cursor ( self ) -> gui . TextCursor : \"\"\"Return a cursor with text between the start and currentposition selected.\"\"\" cursor = self . _text_edit . get_text_cursor () if cursor . position () >= self . _start_position : cursor . setPosition ( self . _start_position , gui . TextCursor . MoveMode . KeepAnchor ) return cursor def _update_current ( self ): \"\"\"Update the current item based on the current text and the widget position.\"\"\" # Update widget position cursor = self . _text_edit . get_text_cursor () point = self . _get_top_left_position ( cursor ) self . move ( point ) # Update current item prefix = self . _current_text_cursor () . selection () . toPlainText () if prefix : flags = ( QtCore . Qt . MatchFlag . MatchStartsWith # type: ignore | QtCore . Qt . MatchFlag . MatchCaseSensitive ) items = self . findItems ( prefix , flags ) if items : self . setCurrentItem ( items [ 0 ]) else : self . hide () else : self . hide () def cancel_completion ( self ): self . hide ()","title":"CompletionWidget"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.eventFilter","text":"Handle mouse input and to auto-hide when losing focus. Source code in prettyqt/custom_widgets/completionwidget.py def eventFilter ( self , obj , event ): \"\"\"Handle mouse input and to auto-hide when losing focus.\"\"\" if obj is self : if event . type () == QtCore . QEvent . Type . MouseButtonPress : pos = self . mapToGlobal ( event . pos ()) target = QtWidgets . QApplication . widgetAt ( pos ) if target and self . isAncestorOf ( target ) or target is self : return False else : self . cancel_completion () return super () . eventFilter ( obj , event )","title":"eventFilter()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.hideEvent","text":"Disconnect signal handlers and event filter. Source code in prettyqt/custom_widgets/completionwidget.py def hideEvent ( self , event ): \"\"\"Disconnect signal handlers and event filter.\"\"\" super () . hideEvent ( event ) try : self . _text_edit . cursorPositionChanged . disconnect ( self . _update_current ) except TypeError : pass self . removeEventFilter ( self )","title":"hideEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.keyPressEvent","text":"keyPressEvent(self, event: PySide6.QtGui.QKeyEvent) -> None Source code in prettyqt/custom_widgets/completionwidget.py def keyPressEvent ( self , event ): key = event . key () if key in ( QtCore . Qt . Key . Key_Return , QtCore . Qt . Key . Key_Enter , QtCore . Qt . Key . Key_Tab , ): self . _complete_current () elif key == QtCore . Qt . Key . Key_Escape : self . hide () elif key in ( QtCore . Qt . Key . Key_Up , QtCore . Qt . Key . Key_Down , QtCore . Qt . Key . Key_PageUp , QtCore . Qt . Key . Key_PageDown , QtCore . Qt . Key . Key_Home , QtCore . Qt . Key . Key_End , ): return super () . keyPressEvent ( event ) else : QtWidgets . QApplication . sendEvent ( self . _text_edit , event )","title":"keyPressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.showEvent","text":"Connect signal handlers and event filter. Source code in prettyqt/custom_widgets/completionwidget.py def showEvent ( self , event ): \"\"\"Connect signal handlers and event filter.\"\"\" super () . showEvent ( event ) self . _text_edit . cursorPositionChanged . connect ( self . _update_current ) self . installEventFilter ( self )","title":"showEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.show_items","text":"Show the widget with 'items' at the position specified by 'cursor'. Source code in prettyqt/custom_widgets/completionwidget.py def show_items ( self , cursor , items : list [ str ], prefix_length : int = 0 ): \"\"\"Show the widget with 'items' at the position specified by 'cursor'.\"\"\" point = self . _get_top_left_position ( cursor ) self . clear () path_items = [] for item in items : # Check if the item could refer to a file or dir. The replacing # of '\"' is needed for items on Windows path = os . path . abspath ( item . replace ( '\"' , \"\" )) if os . path . isfile ( path ) or os . path . isdir ( path ): path_items . append ( item . replace ( '\"' , \"\" )) else : list_item = widgets . ListWidgetItem () list_item . setData ( QtCore . Qt . ItemDataRole . UserRole , item ) # type: ignore # Need to split to only show last element of a dot completion list_item . setText ( item . split ( \".\" )[ - 1 ]) self . addItem ( list_item ) common_prefix = os . path . dirname ( os . path . commonprefix ( path_items )) for path_item in path_items : list_item = widgets . ListWidgetItem () list_item . setData ( QtCore . Qt . ItemDataRole . UserRole , path_item ) # type: ignore text = path_item . split ( common_prefix )[ - 1 ] if common_prefix else path_item list_item . setText ( text ) self . addItem ( list_item ) height = self . sizeHint () . height () screen_rect = self . get_screen () . availableGeometry () if screen_rect . size () . height () + screen_rect . y () - point . y () - height < 0 : point = self . _text_edit . mapToGlobal ( self . _text_edit . cursorRect () . topRight ()) point . setY ( int ( point . y () - height )) scrollbar_width = self . verticalScrollBar () . sizeHint () . width () w = self . sizeHintForColumn ( 0 ) + scrollbar_width + 2 * self . frameWidth () self . setGeometry ( point . x (), point . y (), w , height ) # Move cursor to start of the prefix to replace it # when a item is selected cursor . movePosition ( QtGui . QTextCursor . MoveOperation . Left , n = prefix_length ) self . _start_position = cursor . position () self . setCurrentRow ( 0 ) self . raise_ () self . show ()","title":"show_items()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset","text":"","title":"dataset"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem","text":"Source code in prettyqt/custom_widgets/dataset.py class DataItem : def __init__ ( self , label : str , value = None , optional : str | None = None , include : bool = True , enabled_on = None , disabled_on = None , ): self . set_value ( value ) self . enabled_on = [ enabled_on ] if enabled_on else list () self . disabled_on = [ disabled_on ] if disabled_on else list () self . name = None self . label = label self . optional = optional self . include = include self . colspan = 1 self . label_col = 0 self . is_enabled = True def __get__ ( self , instance , owner ): return self . value def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self def set_value ( self , value ): self . value = value def store ( self , prop ): # self.set_prop(\"display\", store=prop) return self def is_valid ( self ): return True def create_widget ( self ): widget = self . _create_widget () if self . optional : return custom_widgets . OptionalWidget ( widget , self . optional ) return widget def _create_widget ( self ): return None","title":"DataItem"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem.set_pos","text":"Set data item's position on a GUI layout. Source code in prettyqt/custom_widgets/dataset.py def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self","title":"set_pos()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta","text":"Source code in prettyqt/custom_widgets/dataset.py class DataSetMeta ( type ): def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct )","title":"DataSetMeta"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct )","title":"__new__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.elidedlabel","text":"","title":"elidedlabel"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.elidedlabel.ElidedLabel","text":"Source code in prettyqt/custom_widgets/elidedlabel.py class ElidedLabel ( widgets . Frame ): elision_changed = core . Signal ( bool ) def __init__ ( self , text : str = \"\" , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( parent = parent ) self . elided = False self . content = text self . set_size_policy ( \"expanding\" , \"preferred\" ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . text () !r} )\" def set_text ( self , text : str ): self . content = text self . update () def paintEvent ( self , event ): super () . paintEvent ( event ) painter = gui . Painter ( self ) metrics = painter . get_font_metrics () did_elide = False line_spacing = metrics . lineSpacing () y = 0 layout = gui . TextLayout ( self . content , painter . font ()) with layout . process_layout (): while True : line = layout . createLine () if not line . isValid (): break line . setLineWidth ( self . width ()) next_line_y = y + line_spacing if self . height () >= next_line_y + line_spacing : line . draw ( painter , core . Point ( 0 , y )) y = next_line_y else : last_line = self . content [ line . textStart () :] elided_line = metrics . elided_text ( last_line , \"right\" , self . width ()) painter . drawText ( 0 , y + metrics . ascent (), elided_line ) line = layout . createLine () did_elide = line . isValid () break if did_elide != self . elided : self . elided = did_elide self . elision_changed . emit ( did_elide ) # def paintEvent(self, event): # painter = gui.Painter(self) # metrics = gui.FontMetrics(self.font()) # elided = metrics.elided_text(self.text(), \"right\", self.width()) # painter.drawText(self.rect(), self.alignment(), elided)","title":"ElidedLabel"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.elidedlabel.ElidedLabel.paintEvent","text":"paintEvent(self, arg__1: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/elidedlabel.py def paintEvent ( self , event ): super () . paintEvent ( event ) painter = gui . Painter ( self ) metrics = painter . get_font_metrics () did_elide = False line_spacing = metrics . lineSpacing () y = 0 layout = gui . TextLayout ( self . content , painter . font ()) with layout . process_layout (): while True : line = layout . createLine () if not line . isValid (): break line . setLineWidth ( self . width ()) next_line_y = y + line_spacing if self . height () >= next_line_y + line_spacing : line . draw ( painter , core . Point ( 0 , y )) y = next_line_y else : last_line = self . content [ line . textStart () :] elided_line = metrics . elided_text ( last_line , \"right\" , self . width ()) painter . drawText ( 0 , y + metrics . ascent (), elided_line ) line = layout . createLine () did_elide = line . isValid () break if did_elide != self . elided : self . elided = did_elide self . elision_changed . emit ( did_elide )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton","text":"","title":"filechooserbutton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton","text":"Source code in prettyqt/custom_widgets/filechooserbutton.py class FileChooserButton ( widgets . Widget ): value_changed = core . Signal ( pathlib . Path ) def __init__ ( self , extensions : dict [ str , list [ str ]] | None = None , mode : widgets . filedialog . AcceptModeStr = \"save\" , file_mode : widgets . filedialog . FileModeStr = \"existing_files\" , root : None | str | pathlib . Path = None , parent : QtWidgets . QWidget | None = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : pathlib . Path | None = None self . extensions = extensions self . mode : widgets . filedialog . AcceptModeStr = mode self . file_mode : widgets . filedialog . FileModeStr = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout . add ( self . lineedit ) action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout . add ( self . button ) def serialize_fields ( self ): return dict ( path = self . path , extensions = self . extensions , enabled = self . isEnabled ()) def __setstate__ ( self , state ): self . set_path ( state [ \"path\" ]) self . set_enabled ( state . get ( \"enabled\" , True )) def __reduce__ ( self ): return type ( self ), ( self . extensions ,), self . __getstate__ () @core . Slot () def open_file ( self ): dialog = widgets . FileDialog ( parent = self , path_id = \"file_path\" , mode = self . mode , path = self . root , file_mode = self . file_mode , ) if self . extensions : dialog . set_extension_filter ( self . extensions ) if not dialog . choose (): return self . set_path ( dialog . selected_file ()) self . value_changed . emit ( self . path ) def set_path ( self , path : types . PathType | None ): if path is None : self . path = None self . lineedit . set_text ( \"\" ) else : self . path = pathlib . Path ( path ) self . lineedit . set_text ( os . fspath ( path )) def get_value ( self ) -> pathlib . Path | None : return self . path def set_value ( self , value : types . PathType | None ): self . set_path ( value )","title":"FileChooserButton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton.__init__","text":"Initialize FileChooserButton. Parameters: Name Type Description Default extensions dict[str, list[str]] | None dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode widgets.filedialog.AcceptModeStr Accept mode (\"save\" or \"load\") 'save' file_mode widgets.filedialog.FileModeStr File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' root None | str | pathlib.Path Root path None parent QtWidgets.QWidget | None parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py def __init__ ( self , extensions : dict [ str , list [ str ]] | None = None , mode : widgets . filedialog . AcceptModeStr = \"save\" , file_mode : widgets . filedialog . FileModeStr = \"existing_files\" , root : None | str | pathlib . Path = None , parent : QtWidgets . QWidget | None = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : pathlib . Path | None = None self . extensions = extensions self . mode : widgets . filedialog . AcceptModeStr = mode self . file_mode : widgets . filedialog . FileModeStr = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout . add ( self . lineedit ) action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout . add ( self . button )","title":"__init__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout","text":"","title":"flowlayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout","text":"Source code in prettyqt/custom_widgets/flowlayout.py class FlowLayout ( widgets . Layout ): def __init__ ( self , parent : QtWidgets . QWidget | None = None , margin : int | None = None , spacing : int = - 1 , ): super () . __init__ ( parent ) # type: ignore if margin is not None : self . set_margin ( margin ) self . set_spacing ( spacing ) self . items : list [ QtWidgets . QLayoutItem ] = [] def serialize_fields ( self ): return dict ( items = self . get_children ()) def __add__ ( self , other : QtWidgets . QWidget | QtWidgets . QLayout ) -> FlowLayout : if not isinstance ( other , ( QtWidgets . QWidget , QtWidgets . QLayout )): raise TypeError () self . add ( other ) return self def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __setstate__ ( self , state ): for item in state [ \"items\" ]: self . add ( item ) def __del__ ( self ): item = self . takeAt ( 0 ) while item : item = self . takeAt ( 0 ) def addItem ( self , item : QtWidgets . QLayoutItem ): self . items . append ( item ) def count ( self ) -> int : return len ( self . items ) def itemAt ( self , index : int ) -> QtWidgets . QLayoutItem | None : # type: ignore if 0 <= index < len ( self . items ): return self . items [ index ] return None def takeAt ( self , index : int ) -> QtWidgets . QLayoutItem | None : # type: ignore if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None # def expandingDirections(self) -> QtCore.Qt.Orientations: # return QtCore.Qt.Orientations(0) def hasHeightForWidth ( self ) -> bool : return True def heightForWidth ( self , width : int ) -> int : rect = QtCore . QRect ( 0 , 0 , width , 0 ) return self . do_layout ( rect , True ) def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False ) def sizeHint ( self ) -> QtCore . QSize : return self . minimumSize () def minimumSize ( self ) -> QtCore . QSize : size = QtCore . QSize () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += QtCore . QSize ( margin_width , margin_width ) return size def do_layout ( self , rect : QtCore . QRect , test_only : bool ) -> int : x = rect . x () y = rect . y () line_height = 0 space = self . spacing () pb = widgets . SizePolicy . ControlType . PushButton for item in self . items : wid = item . widget () space_x = space + wid . style () . layoutSpacing ( pb , pb , constants . HORIZONTAL ) next_x = x + item . sizeHint () . width () + space_x if next_x - space_x > rect . right () and line_height > 0 : x = rect . x () space_y = space + wid . style () . layoutSpacing ( pb , pb , constants . VERTICAL ) y = y + line_height + space_y next_x = x + item . sizeHint () . width () + space_x line_height = 0 if not test_only : item . setGeometry ( core . Rect ( core . Point ( x , y ), item . sizeHint ())) x = next_x line_height = max ( line_height , item . sizeHint () . height ()) return y + line_height - rect . y ()","title":"FlowLayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.addItem","text":"addItem(self, arg__1: PySide6.QtWidgets.QLayoutItem) -> None Source code in prettyqt/custom_widgets/flowlayout.py def addItem ( self , item : QtWidgets . QLayoutItem ): self . items . append ( item )","title":"addItem()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.count","text":"count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py def count ( self ) -> int : return len ( self . items )","title":"count()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.hasHeightForWidth","text":"hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py def hasHeightForWidth ( self ) -> bool : return True","title":"hasHeightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.heightForWidth","text":"heightForWidth(self, arg__1: int) -> int Source code in prettyqt/custom_widgets/flowlayout.py def heightForWidth ( self , width : int ) -> int : rect = QtCore . QRect ( 0 , 0 , width , 0 ) return self . do_layout ( rect , True )","title":"heightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.itemAt","text":"itemAt(self, index: int) -> PySide6.QtWidgets.QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def itemAt ( self , index : int ) -> QtWidgets . QLayoutItem | None : # type: ignore if 0 <= index < len ( self . items ): return self . items [ index ] return None","title":"itemAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.minimumSize","text":"minimumSize(self) -> PySide6.QtCore.QSize Source code in prettyqt/custom_widgets/flowlayout.py def minimumSize ( self ) -> QtCore . QSize : size = QtCore . QSize () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += QtCore . QSize ( margin_width , margin_width ) return size","title":"minimumSize()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.setGeometry","text":"setGeometry(self, arg__1: PySide6.QtCore.QRect) -> None Source code in prettyqt/custom_widgets/flowlayout.py def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False )","title":"setGeometry()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.sizeHint","text":"sizeHint(self) -> PySide6.QtCore.QSize Source code in prettyqt/custom_widgets/flowlayout.py def sizeHint ( self ) -> QtCore . QSize : return self . minimumSize ()","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.takeAt","text":"takeAt(self, index: int) -> PySide6.QtWidgets.QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def takeAt ( self , index : int ) -> QtWidgets . QLayoutItem | None : # type: ignore if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None","title":"takeAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow","text":"","title":"framelesswindow"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.CustomTitleBar","text":"Source code in prettyqt/custom_widgets/framelesswindow.py class CustomTitleBar ( widgets . Frame ): def __init__ ( self , window_widget : QtWidgets . QWidget ): super () . __init__ ( window_widget ) self . window_widget = window_widget self . minimize_button = TitleBarIcon ( \"\ud83d\uddd5\" ) self . maximize_button = TitleBarIcon ( \"\ud83d\uddd6\" ) self . exit_button = TitleBarIcon ( \"\u2715\" ) self . setObjectName ( \"ControlWidget\" ) state = QtCore . Qt . WindowState . WindowMinimized self . minimize_button . clicked . connect ( lambda : window_widget . setWindowState ( state ) # type: ignore ) self . maximize_button . clicked . connect ( lambda : ( window_widget . showNormal () if window_widget . isMaximized () else window_widget . showMaximized () ) ) self . exit_button . clicked . connect ( window_widget . close ) self . set_layout ( \"horizontal\" ) spacer_item = QtWidgets . QSpacerItem ( 0 , 0 , QtWidgets . QSizePolicy . Expanding ) self . box . addSpacerItem ( spacer_item ) for widget in [ self . minimize_button , self . maximize_button , self . exit_button , ]: self . box . addWidget ( widget ) self . setStyleSheet ( \"width: 100%;\" \"padding: 0;\" \"margin: 0;\" ) self . setContentsMargins ( 0 , 0 , 0 , 0 ) self . box . setContentsMargins ( 0 , 0 , 0 , 0 ) self . box . setSpacing ( 0 ) def mousePressEvent ( self , a0 : QtGui . QMouseEvent ) -> None : self . window_widget . windowHandle () . startSystemMove ()","title":"CustomTitleBar"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.CustomTitleBar.mousePressEvent","text":"mousePressEvent(self, event: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/framelesswindow.py def mousePressEvent ( self , a0 : QtGui . QMouseEvent ) -> None : self . window_widget . windowHandle () . startSystemMove ()","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.EdgeGrip","text":"Source code in prettyqt/custom_widgets/framelesswindow.py class EdgeGrip ( widgets . Widget ): def __init__ ( self , edges : str , grip_size = 6 , parent = None ): super () . __init__ ( parent ) self . edges = edges self . grip_size = grip_size # Sides if edges == \"top\" : self . setCursor ( QtCore . Qt . SizeVerCursor ) self . setFixedHeight ( self . grip_size ) elif edges == \"right\" : self . setCursor ( QtCore . Qt . SizeHorCursor ) self . setFixedWidth ( self . grip_size ) elif edges == \"bottom\" : self . setCursor ( QtCore . Qt . SizeVerCursor ) self . setFixedHeight ( self . grip_size ) elif edges == \"left\" : self . setCursor ( QtCore . Qt . SizeHorCursor ) self . setFixedWidth ( self . grip_size ) # Corners elif edges == \"top_left\" : self . setCursor ( QtCore . Qt . SizeFDiagCursor ) elif edges == \"top_right\" : self . setCursor ( QtCore . Qt . SizeBDiagCursor ) elif edges == \"bottom_left\" : self . setCursor ( QtCore . Qt . SizeBDiagCursor ) elif edges == \"bottom_right\" : self . setCursor ( QtCore . Qt . SizeFDiagCursor ) def mousePressEvent ( self , event ): if event . button () == QtCore . Qt . LeftButton : self . parent () . windowHandle () . startSystemResize ( self . edges )","title":"EdgeGrip"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.EdgeGrip.mousePressEvent","text":"mousePressEvent(self, event: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/framelesswindow.py def mousePressEvent ( self , event ): if event . button () == QtCore . Qt . LeftButton : self . parent () . windowHandle () . startSystemResize ( self . edges )","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.FramelessWindow","text":"Source code in prettyqt/custom_widgets/framelesswindow.py class FramelessWindow ( widgets . Widget ): BORDER_WIDTH = 5 def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) # Remove window title bar and frame self . setWindowFlags ( QtCore . Qt . WindowFlag . Window # type: ignore | QtCore . Qt . WindowFlag . FramelessWindowHint ) self . title_bar = CustomTitleBar ( self ) self . main_widget = widgets . MainWindow () # Set up layout self . main_layout = widgets . BoxLayout ( \"vertical\" ) self . main_layout . addWidget ( self . title_bar ) self . main_layout . addWidget ( self . main_widget ) self . main_layout . setContentsMargins ( 0 , 0 , 0 , 0 ) self . main_layout . setSpacing ( 0 ) self . grip_layout = widgets . GridLayout () self . grip_layout . addLayout ( self . main_layout , 1 , 1 ) self . grip_layout . addWidget ( EdgeGrip ( \"top\" ), 0 , 1 ) self . grip_layout . addWidget ( EdgeGrip ( \"right\" ), 1 , 2 ) self . grip_layout . addWidget ( EdgeGrip ( \"bottom\" ), 2 , 1 ) self . grip_layout . addWidget ( EdgeGrip ( \"left\" ), 1 , 0 ) self . grip_layout . addWidget ( EdgeGrip ( \"top_left\" ), 0 , 0 ) self . grip_layout . addWidget ( EdgeGrip ( \"top_right\" ), 0 , 2 ) self . grip_layout . addWidget ( EdgeGrip ( \"bottom_left\" ), 2 , 0 ) self . grip_layout . addWidget ( EdgeGrip ( \"bottom_right\" ), 2 , 2 ) self . grip_layout . setContentsMargins ( 0 , 0 , 0 , 0 ) self . grip_layout . setSpacing ( 0 ) self . setLayout ( self . grip_layout ) if sys . platform == \"win32\" : self . hwnd = self . winId () . __int__ () window_style = win32gui . GetWindowLong ( self . hwnd , GWL_STYLE ) win32gui . SetWindowLong ( self . hwnd , GWL_STYLE , window_style | WS_POPUP | WS_THICKFRAME | WS_CAPTION | WS_SYSMENU | WS_MAXIMIZEBOX | WS_MINIMIZEBOX , ) # if QtWin.isCompositionEnabled(): # # Aero Shadow # QtWin.extendFrameIntoClientArea(self, -1, -1, -1, -1) # else: # QtWin.resetExtendedFrame(self) def __getattr__ ( self , attr : str ): return getattr ( self . main_widget , attr ) def changeEvent ( self , event ): # not sure if this should be done on non-windows if event . type () == event . WindowStateChange : if self . windowState () & QtCore . Qt . WindowState . WindowMaximized : # type: ignore margin = abs ( self . mapToGlobal ( self . rect () . topLeft ()) . y ()) self . setContentsMargins ( margin , margin , margin , margin ) else : self . setContentsMargins ( 0 , 0 , 0 , 0 ) return super () . changeEvent ( event ) def nativeEvent ( self , event , message ): return_value , result = super () . nativeEvent ( event , message ) if sys . platform != \"win32\" : return return_value , result # if you use Windows OS if event == b \"windows_generic_MSG\" : msg = ctypes . wintypes . MSG . from_address ( message . __int__ ()) # Get the coordinates when the mouse moves. x = win32api . LOWORD ( LONG ( msg . lParam ) . value ) # type: ignore # converted an unsigned int to int (for dual monitor issue) if x & 32768 : x = x | - 65536 y = win32api . HIWORD ( LONG ( msg . lParam ) . value ) # type: ignore if y & 32768 : y = y | - 65536 x -= self . frameGeometry () . x () y -= self . frameGeometry () . y () # Determine whether there are other widgets at the mouse position. if self . childAt ( x , y ) is not None and self . childAt ( x , y ) is not self . findChild ( widgets . Widget , \"ControlWidget\" ): # passing if ( self . width () - self . BORDER_WIDTH > x > self . BORDER_WIDTH and y < self . height () - self . BORDER_WIDTH ): return return_value , result if msg . message == WM_NCCALCSIZE : # Remove system title return True , 0 if msg . message == WM_NCHITTEST : w , h = self . width (), self . height () lx = x < self . BORDER_WIDTH rx = x > w - self . BORDER_WIDTH ty = y < self . BORDER_WIDTH by = y > h - self . BORDER_WIDTH if lx and ty : return True , HTTOPLEFT if rx and by : return True , HTBOTTOMRIGHT if rx and ty : return True , HTTOPRIGHT if lx and by : return True , HTBOTTOMLEFT if ty : return True , HTTOP if by : return True , HTBOTTOM if lx : return True , HTLEFT if rx : return True , HTRIGHT # Title return True , HTCAPTION return return_value , result","title":"FramelessWindow"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.FramelessWindow.changeEvent","text":"changeEvent(self, event: PySide6.QtCore.QEvent) -> None Source code in prettyqt/custom_widgets/framelesswindow.py def changeEvent ( self , event ): # not sure if this should be done on non-windows if event . type () == event . WindowStateChange : if self . windowState () & QtCore . Qt . WindowState . WindowMaximized : # type: ignore margin = abs ( self . mapToGlobal ( self . rect () . topLeft ()) . y ()) self . setContentsMargins ( margin , margin , margin , margin ) else : self . setContentsMargins ( 0 , 0 , 0 , 0 ) return super () . changeEvent ( event )","title":"changeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.FramelessWindow.nativeEvent","text":"nativeEvent(self, eventType: Union[PySide6.QtCore.QByteArray, bytes], message: int) -> object Source code in prettyqt/custom_widgets/framelesswindow.py def nativeEvent ( self , event , message ): return_value , result = super () . nativeEvent ( event , message ) if sys . platform != \"win32\" : return return_value , result # if you use Windows OS if event == b \"windows_generic_MSG\" : msg = ctypes . wintypes . MSG . from_address ( message . __int__ ()) # Get the coordinates when the mouse moves. x = win32api . LOWORD ( LONG ( msg . lParam ) . value ) # type: ignore # converted an unsigned int to int (for dual monitor issue) if x & 32768 : x = x | - 65536 y = win32api . HIWORD ( LONG ( msg . lParam ) . value ) # type: ignore if y & 32768 : y = y | - 65536 x -= self . frameGeometry () . x () y -= self . frameGeometry () . y () # Determine whether there are other widgets at the mouse position. if self . childAt ( x , y ) is not None and self . childAt ( x , y ) is not self . findChild ( widgets . Widget , \"ControlWidget\" ): # passing if ( self . width () - self . BORDER_WIDTH > x > self . BORDER_WIDTH and y < self . height () - self . BORDER_WIDTH ): return return_value , result if msg . message == WM_NCCALCSIZE : # Remove system title return True , 0 if msg . message == WM_NCHITTEST : w , h = self . width (), self . height () lx = x < self . BORDER_WIDTH rx = x > w - self . BORDER_WIDTH ty = y < self . BORDER_WIDTH by = y > h - self . BORDER_WIDTH if lx and ty : return True , HTTOPLEFT if rx and by : return True , HTBOTTOMRIGHT if rx and ty : return True , HTTOPRIGHT if lx and by : return True , HTBOTTOMLEFT if ty : return True , HTTOP if by : return True , HTBOTTOM if lx : return True , HTLEFT if rx : return True , HTRIGHT # Title return True , HTCAPTION return return_value , result","title":"nativeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser","text":"","title":"iconbrowser"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconListView","text":"Source code in prettyqt/custom_widgets/iconbrowser.py class IconListView ( widgets . ListView ): \"\"\"A QListView that scales its grid size to always show same amount of items.\"\"\" def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) self . set_vertical_scrollbar_policy ( \"always_on\" ) self . VIEW_COLUMNS = 5 def resizeEvent ( self , event ): \"\"\"Re-calculate the grid size to provide scaling icons.\"\"\" width = self . viewport () . width () - 30 # The minus 30 above ensures we don't end up with an item width that # can't be drawn the expected number of times across the view without # being wrapped. Without this, the view can flicker during resize tile_width = int ( width / self . VIEW_COLUMNS ) icon_width = int ( tile_width * 0.8 ) self . set_grid_size (( tile_width , tile_width )) self . set_icon_size (( icon_width , icon_width )) return super () . resizeEvent ( event )","title":"IconListView"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconListView.resizeEvent","text":"Re-calculate the grid size to provide scaling icons. Source code in prettyqt/custom_widgets/iconbrowser.py def resizeEvent ( self , event ): \"\"\"Re-calculate the grid size to provide scaling icons.\"\"\" width = self . viewport () . width () - 30 # The minus 30 above ensures we don't end up with an item width that # can't be drawn the expected number of times across the view without # being wrapped. Without this, the view can flicker during resize tile_width = int ( width / self . VIEW_COLUMNS ) icon_width = int ( tile_width * 0.8 ) self . set_grid_size (( tile_width , tile_width )) self . set_icon_size (( icon_width , icon_width )) return super () . resizeEvent ( event )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconModel","text":"Source code in prettyqt/custom_widgets/iconbrowser.py class IconModel ( core . StringListModel ): def __init__ ( self , icon_color : QtGui . QColor ): super () . __init__ () self . _icon_color = icon_color def flags ( self , index ): return constants . IS_ENABLED | constants . IS_SELECTABLE # type: ignore def data ( self , index , role ): if role == constants . DECORATION_ROLE : icon_string = self . data ( index , role = constants . DISPLAY_ROLE ) return iconprovider . _icon ( icon_string , color = self . _icon_color ) return super () . data ( index , role )","title":"IconModel"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconModel.data","text":"data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/custom_widgets/iconbrowser.py def data ( self , index , role ): if role == constants . DECORATION_ROLE : icon_string = self . data ( index , role = constants . DISPLAY_ROLE ) return iconprovider . _icon ( icon_string , color = self . _icon_color ) return super () . data ( index , role )","title":"data()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconModel.flags","text":"flags(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.Qt.ItemFlag Source code in prettyqt/custom_widgets/iconbrowser.py def flags ( self , index ): return constants . IS_ENABLED | constants . IS_SELECTABLE # type: ignore","title":"flags()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget","text":"","title":"iconwidget"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget","text":"Source code in prettyqt/custom_widgets/iconwidget.py class IconWidget ( widgets . Label ): \"\"\"IconWidget gives the ability to display an icon as a widget. if supports the same arguments as icon() for example music_icon = qta.IconWidget('fa5s.music', color='blue', color_active='orange') it also have setIcon() and setIconSize() functions \"\"\" def __init__ ( self , * names , parent : QtWidgets . QWidget | None = None , ** kwargs ): super () . __init__ ( parent = parent ) self . _icon : QtGui . QIcon | None = None self . _size = core . Size ( 16 , 16 ) self . set_icon ( iconprovider . _icon ( * names , ** kwargs )) def set_icon ( self , _icon : types . IconType ): \"\"\"Set a new icon(). Parameters ---------- _icon: qtawesome.icon icon to set \"\"\" self . _icon = iconprovider . get_icon ( _icon ) self . setPixmap ( self . _icon . pixmap ( self . _size )) def set_icon_size ( self , size : int | types . SizeType ): if isinstance ( size , tuple ): size = QtCore . QSize ( * size ) elif isinstance ( size , int ): size = QtCore . QSize ( size , size ) self . _size = size self . update () def update ( self , * args , ** kwargs ): if self . _icon : self . setPixmap ( self . _icon . pixmap ( self . _size )) return super () . update ( * args , ** kwargs )","title":"IconWidget"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.set_icon","text":"Set a new icon().","title":"set_icon()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.set_icon--parameters","text":"qtawesome.icon icon to set Source code in prettyqt/custom_widgets/iconwidget.py def set_icon ( self , _icon : types . IconType ): \"\"\"Set a new icon(). Parameters ---------- _icon: qtawesome.icon icon to set \"\"\" self . _icon = iconprovider . get_icon ( _icon ) self . setPixmap ( self . _icon . pixmap ( self . _size ))","title":"Parameters"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.update","text":"update(self) -> None update(self, arg__1: PySide6.QtCore.QRect) -> None update(self, arg__1: Union[PySide6.QtGui.QRegion, PySide6.QtGui.QBitmap, PySide6.QtGui.QPolygon, PySide6.QtCore.QRect]) -> None update(self, x: int, y: int, w: int, h: int) -> None Source code in prettyqt/custom_widgets/iconwidget.py def update ( self , * args , ** kwargs ): if self . _icon : self . setPixmap ( self . _icon . pixmap ( self . _size )) return super () . update ( * args , ** kwargs )","title":"update()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton","text":"","title":"joystickbutton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton","text":"Source code in prettyqt/custom_widgets/joystickbutton.py class JoystickButton ( widgets . PushButton ): state_changed = core . Signal ( object ) def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) self . radius = 200 self . setCheckable ( True ) self . state = [ 0 , 0 ] self . set_state ( 0 , 0 ) self . setFixedWidth ( 50 ) self . setFixedHeight ( 50 ) def mousePressEvent ( self , ev ): self . setChecked ( True ) self . press_pos = ev . position () ev . accept () def mouseMoveEvent ( self , ev ): dif = ev . position () - self . press_pos self . set_state ( dif . x (), - dif . y ()) def mouseReleaseEvent ( self , ev ): self . setChecked ( False ) self . set_state ( 0 , 0 ) def wheelEvent ( self , ev ): ev . accept () def doubleClickEvent ( self , ev ): ev . accept () def get_state ( self ): return self . state def set_state ( self , x , y ): xy = [ x , y ] d = hypot ( xy [ 0 ], xy [ 1 ]) # length nxy = [ 0 , 0 ] for i in [ 0 , 1 ]: if xy [ i ] == 0 : nxy [ i ] = 0 else : nxy [ i ] = xy [ i ] / d if d > self . radius : d = self . radius d = ( d / self . radius ) ** 2 xy = [ nxy [ 0 ] * d , nxy [ 1 ] * d ] w2 = self . width () / 2 h2 = self . height () / 2 self . spot_pos = core . Point ( int ( w2 * ( 1 + xy [ 0 ])), int ( h2 * ( 1 - xy [ 1 ]))) self . update () if self . state == xy : return self . state = xy self . state_changed . emit ( self . state ) def paintEvent ( self , ev ): super () . paintEvent ( ev ) p = QtGui . QPainter ( self ) p . setBrush ( QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ))) p . drawEllipse ( self . spot_pos . x () - 3 , self . spot_pos . y () - 3 , 6 , 6 ) def resizeEvent ( self , ev ): self . set_state ( * self . state ) super () . resizeEvent ( ev )","title":"JoystickButton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.mouseMoveEvent","text":"mouseMoveEvent(self, arg__1: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def mouseMoveEvent ( self , ev ): dif = ev . position () - self . press_pos self . set_state ( dif . x (), - dif . y ())","title":"mouseMoveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.mousePressEvent","text":"mousePressEvent(self, e: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def mousePressEvent ( self , ev ): self . setChecked ( True ) self . press_pos = ev . position () ev . accept ()","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.mouseReleaseEvent","text":"mouseReleaseEvent(self, e: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def mouseReleaseEvent ( self , ev ): self . setChecked ( False ) self . set_state ( 0 , 0 )","title":"mouseReleaseEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.paintEvent","text":"paintEvent(self, arg__1: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def paintEvent ( self , ev ): super () . paintEvent ( ev ) p = QtGui . QPainter ( self ) p . setBrush ( QtGui . QBrush ( QtGui . QColor ( 0 , 0 , 0 ))) p . drawEllipse ( self . spot_pos . x () - 3 , self . spot_pos . y () - 3 , 6 , 6 )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.resizeEvent","text":"resizeEvent(self, event: PySide6.QtGui.QResizeEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def resizeEvent ( self , ev ): self . set_state ( * self . state ) super () . resizeEvent ( ev )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.wheelEvent","text":"wheelEvent(self, event: PySide6.QtGui.QWheelEvent) -> None Source code in prettyqt/custom_widgets/joystickbutton.py def wheelEvent ( self , ev ): ev . accept ()","title":"wheelEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider","text":"","title":"labeledslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider","text":"Source code in prettyqt/custom_widgets/labeledslider.py class LabeledSlider ( widgets . Widget ): value_changed = core . Signal ( int ) def __init__ ( self , labels : Sequence [ str ], orientation : constants . OrientationStr = \"horizontal\" , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( parent = parent ) if not isinstance ( labels , Sequence ): raise ValueError ( \"<labels> must be a sequence.\" ) self . levels = list ( enumerate ( labels )) self . set_layout ( orientation ) # gives some space to print labels self . left_margin = 10 self . top_margin = 10 self . right_margin = 10 self . bottom_margin = 10 self . box . set_margin ( 10 ) self . sl = widgets . Slider ( orientation ) self . sl . value_changed . connect ( self . value_changed ) self . sl . set_range ( 0 , len ( self . levels ) - 1 ) self . sl . set_value ( 0 ) if orientation == \"horizontal\" : self . sl . set_tick_position ( \"below\" ) self . sl . setMinimumWidth ( 300 ) else : self . sl . set_tick_position ( \"left\" ) self . sl . setMinimumHeight ( 300 ) self . sl . setTickInterval ( 1 ) self . sl . setSingleStep ( 1 ) self . box . add ( self . sl ) def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PixelMetric . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PixelMetric . PM_SliderSpaceAvailable , st_slider , self . sl ) painter = gui . Painter ( self ) for v , v_str in self . levels : # get the size of the label rect = painter . get_text_rect ( v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc self . bottom_margin = max ( self . bottom_margin , rect . height ()) self . adjust_margins () if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . adjust_margins () else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . adjust_margins () painter . drawText ( left , bottom , v_str ) def adjust_margins ( self ): self . box . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , )","title":"LabeledSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider.paintEvent","text":"paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/labeledslider.py def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PixelMetric . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PixelMetric . PM_SliderSpaceAvailable , st_slider , self . sl ) painter = gui . Painter ( self ) for v , v_str in self . levels : # get the size of the label rect = painter . get_text_rect ( v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc self . bottom_margin = max ( self . bottom_margin , rect . height ()) self . adjust_margins () if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . adjust_margins () else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . adjust_margins () painter . drawText ( left , bottom , v_str )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles","text":"Provides a menu that display the list of recent files and a RecentFilesManager. Application's QSettings are used to store the list of recent files.","title":"menurecentfiles"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.MenuRecentFiles","text":"Source code in prettyqt/custom_widgets/menurecentfiles.py class MenuRecentFiles ( widgets . Menu ): \"\"\"Menu that manage the list of recent files. To use the menu, simply connect to the open_requested signal. \"\"\" #: Signal emitted when the user clicked on a recent file action. #: The parameter is the path of the file to open. open_requested = core . Signal ( str ) clear_requested = core . Signal () def __init__ ( self , parent , recent_files_manager = None , title = \"Recent files\" , icon_provider = None , clear_icon = None , ): \"\"\"Init. :param parent: parent object :param icon_provider: Object that provides icon based on the file path. :type icon_provider: QtWidgets.QFileIconProvider :param clear_icon: Clear action icon. This parameter is a tuple made up of the icon theme name and the fallback icon path (from your resources). Default is None, clear action has no icons. \"\"\" super () . __init__ ( title , parent ) if icon_provider is None : self . icon_provider = widgets . FileIconProvider () else : self . icon_provider = icon_provider self . clear_icon = clear_icon #: Recent files manager self . manager = recent_files_manager #: List of recent files actions self . recent_files_actions = [] self . update_actions () def update_actions ( self ): \"\"\"Updates the list of actions.\"\"\" self . clear () self . recent_files_actions [:] = [] for file in self . manager . get_recent_files (): action = widgets . Action ( self ) action . setText ( os . path . split ( file )[ 1 ]) action . setToolTip ( file ) action . setStatusTip ( file ) action . setData ( file ) action . setIcon ( self . icon_provider . icon ( core . FileInfo ( file ))) action . triggered . connect ( self . _on_action_triggered ) self . addAction ( action ) self . recent_files_actions . append ( action ) self . addSeparator () action_clear = widgets . Action ( parent = self , text = \"Clear list\" ) action_clear . triggered . connect ( self . clear_recent_files ) action_clear . setIcon ( iconprovider . get_icon ( \"fa.times-circle\" )) self . addAction ( action_clear ) def clear_recent_files ( self ): \"\"\"Clear recent files and menu.\"\"\" self . manager . clear () self . update_actions () self . clear_requested . emit () def _on_action_triggered ( self ): \"\"\"Emits open_requested when a recent file action has been triggered.\"\"\" action = self . sender () assert isinstance ( action , widgets . Action ) path = action . data () self . open_requested . emit ( path ) self . update_actions ()","title":"MenuRecentFiles"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.MenuRecentFiles.__init__","text":"Init. :param parent: parent object :param icon_provider: Object that provides icon based on the file path. :type icon_provider: QtWidgets.QFileIconProvider :param clear_icon: Clear action icon. This parameter is a tuple made up of the icon theme name and the fallback icon path (from your resources). Default is None, clear action has no icons. Source code in prettyqt/custom_widgets/menurecentfiles.py def __init__ ( self , parent , recent_files_manager = None , title = \"Recent files\" , icon_provider = None , clear_icon = None , ): \"\"\"Init. :param parent: parent object :param icon_provider: Object that provides icon based on the file path. :type icon_provider: QtWidgets.QFileIconProvider :param clear_icon: Clear action icon. This parameter is a tuple made up of the icon theme name and the fallback icon path (from your resources). Default is None, clear action has no icons. \"\"\" super () . __init__ ( title , parent ) if icon_provider is None : self . icon_provider = widgets . FileIconProvider () else : self . icon_provider = icon_provider self . clear_icon = clear_icon #: Recent files manager self . manager = recent_files_manager #: List of recent files actions self . recent_files_actions = [] self . update_actions ()","title":"__init__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.MenuRecentFiles.clear_recent_files","text":"Clear recent files and menu. Source code in prettyqt/custom_widgets/menurecentfiles.py def clear_recent_files ( self ): \"\"\"Clear recent files and menu.\"\"\" self . manager . clear () self . update_actions () self . clear_requested . emit ()","title":"clear_recent_files()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.MenuRecentFiles.update_actions","text":"Updates the list of actions. Source code in prettyqt/custom_widgets/menurecentfiles.py def update_actions ( self ): \"\"\"Updates the list of actions.\"\"\" self . clear () self . recent_files_actions [:] = [] for file in self . manager . get_recent_files (): action = widgets . Action ( self ) action . setText ( os . path . split ( file )[ 1 ]) action . setToolTip ( file ) action . setStatusTip ( file ) action . setData ( file ) action . setIcon ( self . icon_provider . icon ( core . FileInfo ( file ))) action . triggered . connect ( self . _on_action_triggered ) self . addAction ( action ) self . recent_files_actions . append ( action ) self . addSeparator () action_clear = widgets . Action ( parent = self , text = \"Clear list\" ) action_clear . triggered . connect ( self . clear_recent_files ) action_clear . setIcon ( iconprovider . get_icon ( \"fa.times-circle\" )) self . addAction ( action_clear )","title":"update_actions()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager","text":"Source code in prettyqt/custom_widgets/menurecentfiles.py class RecentFilesManager ( core . Object ): \"\"\"Manages a list of recent files. The list of files is stored in QSettings.\"\"\" #: Maximum number of files kept in the list. max_recent_files = 15 updated = core . Signal () def __init__ ( self , organisation , application , qsettings = None ): super () . __init__ () if qsettings is None : self . _settings = core . Settings ( organisation , application ) else : self . _settings = qsettings def clear ( self ): \"\"\"Clears recent files in QSettings.\"\"\" self . set_value ( \"list\" , []) self . updated . emit () def remove ( self , filename ): \"\"\"Remove a file path from the list of recent files. :param filename: Path of the file to remove \"\"\" files = self . get_value ( \"list\" , []) files . remove ( filename ) self . set_value ( \"list\" , files ) self . updated . emit () def get_value ( self , key , default = None ): \"\"\"Reads value from QSettings. :param key: value key :param default: default value. :return: value \"\"\" def unique ( seq , idfun = None ): if idfun is None : def idfun ( x ): return x # order preserving seen = {} result = [] for item in seq : marker = idfun ( item ) if marker in seen : continue seen [ marker ] = 1 result . append ( item ) return result val = self . _settings . value ( \"recent_files/ %s \" % key , default ) if val is None : lst : list [ str ] = [] elif isinstance ( val , str ): lst = [ val ] else : lst = val # type: ignore return unique ([ os . path . normpath ( pth ) for pth in lst ]) def set_value ( self , key , value ): \"\"\"Set the recent files value in QSettings. :param key: value key :param value: new value \"\"\" if value is None : value = [] value = [ os . path . normpath ( pth ) for pth in value ] self . _settings . setValue ( \"recent_files/ %s \" % key , value ) def get_recent_files ( self ): \"\"\"Gets the list of recent files. Files that do not exists anymore are automatically filtered \"\"\" ret_val = [] files = self . get_value ( \"list\" , []) # filter files, remove files that do not exist anymore for file in files : if file is not None and os . path . exists ( file ): if ( os . path . ismount ( file ) and sys . platform == \"win32\" and not file . endswith ( \" \\\\ \" ) ): file += \" \\\\ \" if file not in ret_val : ret_val . append ( file ) return ret_val def open_file ( self , file ): \"\"\"Adds a file to the list (and move it to top if the file already exists). :param file: file path to add the list of recent files. \"\"\" files = self . get_recent_files () try : files . remove ( file ) except ValueError : pass files . insert ( 0 , file ) # discard old files del files [ self . max_recent_files :] self . set_value ( \"list\" , files ) self . updated . emit () def last_file ( self ): \"\"\"Returns the path to the last opened file.\"\"\" files = self . get_recent_files () try : return files [ 0 ] except IndexError : return None","title":"RecentFilesManager"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.clear","text":"Clears recent files in QSettings. Source code in prettyqt/custom_widgets/menurecentfiles.py def clear ( self ): \"\"\"Clears recent files in QSettings.\"\"\" self . set_value ( \"list\" , []) self . updated . emit ()","title":"clear()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.get_recent_files","text":"Gets the list of recent files. Files that do not exists anymore are automatically filtered Source code in prettyqt/custom_widgets/menurecentfiles.py def get_recent_files ( self ): \"\"\"Gets the list of recent files. Files that do not exists anymore are automatically filtered \"\"\" ret_val = [] files = self . get_value ( \"list\" , []) # filter files, remove files that do not exist anymore for file in files : if file is not None and os . path . exists ( file ): if ( os . path . ismount ( file ) and sys . platform == \"win32\" and not file . endswith ( \" \\\\ \" ) ): file += \" \\\\ \" if file not in ret_val : ret_val . append ( file ) return ret_val","title":"get_recent_files()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.get_value","text":"Reads value from QSettings. :param key: value key :param default: default value. :return: value Source code in prettyqt/custom_widgets/menurecentfiles.py def get_value ( self , key , default = None ): \"\"\"Reads value from QSettings. :param key: value key :param default: default value. :return: value \"\"\" def unique ( seq , idfun = None ): if idfun is None : def idfun ( x ): return x # order preserving seen = {} result = [] for item in seq : marker = idfun ( item ) if marker in seen : continue seen [ marker ] = 1 result . append ( item ) return result val = self . _settings . value ( \"recent_files/ %s \" % key , default ) if val is None : lst : list [ str ] = [] elif isinstance ( val , str ): lst = [ val ] else : lst = val # type: ignore return unique ([ os . path . normpath ( pth ) for pth in lst ])","title":"get_value()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.last_file","text":"Returns the path to the last opened file. Source code in prettyqt/custom_widgets/menurecentfiles.py def last_file ( self ): \"\"\"Returns the path to the last opened file.\"\"\" files = self . get_recent_files () try : return files [ 0 ] except IndexError : return None","title":"last_file()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.open_file","text":"Adds a file to the list (and move it to top if the file already exists). :param file: file path to add the list of recent files. Source code in prettyqt/custom_widgets/menurecentfiles.py def open_file ( self , file ): \"\"\"Adds a file to the list (and move it to top if the file already exists). :param file: file path to add the list of recent files. \"\"\" files = self . get_recent_files () try : files . remove ( file ) except ValueError : pass files . insert ( 0 , file ) # discard old files del files [ self . max_recent_files :] self . set_value ( \"list\" , files ) self . updated . emit ()","title":"open_file()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.remove","text":"Remove a file path from the list of recent files. :param filename: Path of the file to remove Source code in prettyqt/custom_widgets/menurecentfiles.py def remove ( self , filename ): \"\"\"Remove a file path from the list of recent files. :param filename: Path of the file to remove \"\"\" files = self . get_value ( \"list\" , []) files . remove ( filename ) self . set_value ( \"list\" , files ) self . updated . emit ()","title":"remove()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.set_value","text":"Set the recent files value in QSettings. :param key: value key :param value: new value Source code in prettyqt/custom_widgets/menurecentfiles.py def set_value ( self , key , value ): \"\"\"Set the recent files value in QSettings. :param key: value key :param value: new value \"\"\" if value is None : value = [] value = [ os . path . normpath ( pth ) for pth in value ] self . _settings . setValue ( \"recent_files/ %s \" % key , value )","title":"set_value()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification","text":"","title":"notification"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.MessageLabel","text":"Source code in prettyqt/custom_widgets/notification.py class MessageLabel ( widgets . Label ): \"\"\"Subclass of QLabel, which reimplements the resizeEvent() function. This is necessary because otherwise the notifications take up too much vertical space when texts they display become longer. This is because normally the height of a notification is calculated as the minimum height necessary for the text when the widget is horizontally resized to its minimum. \"\"\" def resizeEvent ( self , event ): super () . resizeEvent ( event ) if ( self . wordWrap () and self . sizePolicy () . verticalPolicy () == widgets . SizePolicy . Minimum ): new_height = self . heightForWidth ( self . width ()) if new_height < 1 : return self . setMaximumHeight ( new_height )","title":"MessageLabel"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.MessageLabel.resizeEvent","text":"resizeEvent(self, event: PySide6.QtGui.QResizeEvent) -> None Source code in prettyqt/custom_widgets/notification.py def resizeEvent ( self , event ): super () . resizeEvent ( event ) if ( self . wordWrap () and self . sizePolicy () . verticalPolicy () == widgets . SizePolicy . Minimum ): new_height = self . heightForWidth ( self . width ()) if new_height < 1 : return self . setMaximumHeight ( new_height )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification","text":"Source code in prettyqt/custom_widgets/notification.py class Notification ( widgets . Widget ): \"\"\"Class representing a single notification.\"\"\" close_clicked = core . Signal () def __init__ ( self , message : str , category : CategoryStr , timeout = None , autohide : bool = False , buttontext : str | None = None , * args , ** kwargs , ): super () . __init__ ( * args , ** kwargs ) # Store instance variables self . message = message self . category = category self . timeout = timeout self . autohide = autohide # Set Object name for reference self . setObjectName ( category ) self . set_layout ( \"horizontal\" , margin = 0 ) # Create a message area message_area = widgets . BoxLayout ( \"horizontal\" ) message_area . set_margin ( 0 ) # Create the layout self . message_display = MessageLabel () self . message_display . setObjectName ( \"message\" ) self . message_display . set_size_policy ( \"minimum\" , \"minimum\" ) self . message_display . setWordWrap ( True ) # Create a button that can close notifications if not buttontext : close_button = widgets . PushButton ( \" \\u2715 \" ) else : close_button = widgets . PushButton ( buttontext ) close_button . setStyleSheet ( \"text-decoration: underline;\" ) close_button . set_size_policy ( \"fixed\" , \"fixed\" ) close_button . setFlat ( True ) close_button . setObjectName ( \"closeButton\" ) close_button . clicked . connect ( self . close_clicked ) # Add everything together message_area . addWidget ( self . message_display ) # message_area.addStretch(1) message_area . addWidget ( close_button ) self . layout () . addLayout ( message_area ) # Initialize some variables # self.setStyle(category) self . setVisible ( False ) # Flag that is set if notification is being removed. This can be used to # make sure that even though the notification has not been really removed # yet (because it is for example in a fade out animation), it is in the # process of being removed self . is_being_removed = False self . is_fading_in = False self . opacity_effect = widgets . GraphicsOpacityEffect ( self ) # Fade in animation self . fade_in_anim = core . PropertyAnimation () self . fade_in_anim . apply_to ( self . opacity_effect , \"opacity\" ) self . fade_in_anim . set_range ( 0.0 , 1.0 ) # Fade out animation self . fade_out_anim = core . PropertyAnimation () self . fade_out_anim . apply_to ( self . opacity_effect , \"opacity\" ) self . fade_in_anim . set_range ( 1.0 , 0.0 ) def display ( self ): \"\"\"Display the notification.\"\"\" self . message_display . setText ( self . message ) self . show () self . raise_ () def close ( self ): \"\"\"Close the notification.\"\"\" super () . close () self . deleteLater () def fade_in ( self , duration : int ): \"\"\"Fade in the notification. Arguments: duration : int The desired duration of the animation Raises: TypeError: duration is not an integer \"\"\" if type ( duration ) != int : raise TypeError ( \"duration should be an integer\" ) self . setGraphicsEffect ( self . opacity_effect ) self . fade_in_anim . setDuration ( duration ) self . is_fading_in = True self . fade_in_anim . finished . connect ( self . on_fade_in_finished ) self . display () self . fade_in_anim . start () def on_fade_in_finished ( self ): self . is_fading_in = False def fade_out ( self , finished_callback : Callable , duration : int ): \"\"\"Fade out the notification. Parameters ---------- finished_callback : callable The function to call after the animation has finished (to for instance clean up the notification) duration : int The desired duration of the animation Raises ------ TypeError: the wrong datatype is specified for any of the parameters. \"\"\" if not callable ( finished_callback ): raise TypeError ( \"finished_callback should be a callable\" ) if type ( duration ) != int : raise TypeError ( \"duration should be an integer\" ) self . setGraphicsEffect ( self . opacity_effect ) self . fade_out_anim . setDuration ( duration ) self . fade_out_anim . finished . connect ( lambda : finished_callback ( self )) self . is_being_removed = True self . fade_out_anim . start () def paintEvent ( self , pe ): \"\"\"Redefinition of paintEvent, do not call directly. Makes class Notification available in style sheets. Interal Qt function. Should not be called directly. \"\"\" o = widgets . StyleOption . based_on ( self ) p = gui . Painter ( self ) self . style () . drawPrimitive ( widgets . Style . PE_Widget , o , p , self ) @property def message ( self ) -> str : \"\"\"The currently set message to display.\"\"\" return self . _message @message . setter def message ( self , value : str ): \"\"\"Set the message to display.\"\"\" self . _message = value @property def category ( self ) -> CategoryStr : \"\"\"The currently set category of this notification.\"\"\" return self . _category @category . setter def category ( self , value : CategoryStr ): \"\"\"Set the category of this notification. Arguments: value : {'primary','success','info','warning','danger'} The category specification Raises: ValueError: The category is other than one of the expected values. \"\"\" allowed_values = [ \"primary\" , \"success\" , \"info\" , \"warning\" , \"danger\" ] if value not in allowed_values : raise ValueError ( f \" { value !r} is not a valid value. Should be one of { allowed_values } \" ) self . _category = value def enterEvent ( self , e ): \"\"\"When the notification is set to auto-hide, mouseover closes it.\"\"\" if self . autohide : self . close_clicked . emit ()","title":"Notification"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.category","text":"The currently set category of this notification.","title":"category"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.message","text":"The currently set message to display.","title":"message"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.close","text":"Close the notification. Source code in prettyqt/custom_widgets/notification.py def close ( self ): \"\"\"Close the notification.\"\"\" super () . close () self . deleteLater ()","title":"close()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.display","text":"Display the notification. Source code in prettyqt/custom_widgets/notification.py def display ( self ): \"\"\"Display the notification.\"\"\" self . message_display . setText ( self . message ) self . show () self . raise_ ()","title":"display()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.enterEvent","text":"When the notification is set to auto-hide, mouseover closes it. Source code in prettyqt/custom_widgets/notification.py def enterEvent ( self , e ): \"\"\"When the notification is set to auto-hide, mouseover closes it.\"\"\" if self . autohide : self . close_clicked . emit ()","title":"enterEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.fade_in","text":"Fade in the notification. Parameters: Name Type Description Default duration int The desired duration of the animation required Exceptions: Type Description TypeError duration is not an integer Source code in prettyqt/custom_widgets/notification.py def fade_in ( self , duration : int ): \"\"\"Fade in the notification. Arguments: duration : int The desired duration of the animation Raises: TypeError: duration is not an integer \"\"\" if type ( duration ) != int : raise TypeError ( \"duration should be an integer\" ) self . setGraphicsEffect ( self . opacity_effect ) self . fade_in_anim . setDuration ( duration ) self . is_fading_in = True self . fade_in_anim . finished . connect ( self . on_fade_in_finished ) self . display () self . fade_in_anim . start ()","title":"fade_in()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.fade_out","text":"Fade out the notification.","title":"fade_out()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.fade_out--parameters","text":"finished_callback : callable The function to call after the animation has finished (to for instance clean up the notification) duration : int The desired duration of the animation","title":"Parameters"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.fade_out--raises","text":"TypeError: the wrong datatype is specified for any of the parameters. Source code in prettyqt/custom_widgets/notification.py def fade_out ( self , finished_callback : Callable , duration : int ): \"\"\"Fade out the notification. Parameters ---------- finished_callback : callable The function to call after the animation has finished (to for instance clean up the notification) duration : int The desired duration of the animation Raises ------ TypeError: the wrong datatype is specified for any of the parameters. \"\"\" if not callable ( finished_callback ): raise TypeError ( \"finished_callback should be a callable\" ) if type ( duration ) != int : raise TypeError ( \"duration should be an integer\" ) self . setGraphicsEffect ( self . opacity_effect ) self . fade_out_anim . setDuration ( duration ) self . fade_out_anim . finished . connect ( lambda : finished_callback ( self )) self . is_being_removed = True self . fade_out_anim . start ()","title":"Raises"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.paintEvent","text":"Redefinition of paintEvent, do not call directly. Makes class Notification available in style sheets. Interal Qt function. Should not be called directly. Source code in prettyqt/custom_widgets/notification.py def paintEvent ( self , pe ): \"\"\"Redefinition of paintEvent, do not call directly. Makes class Notification available in style sheets. Interal Qt function. Should not be called directly. \"\"\" o = widgets . StyleOption . based_on ( self ) p = gui . Painter ( self ) self . style () . drawPrimitive ( widgets . Style . PE_Widget , o , p , self )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea","text":"Source code in prettyqt/custom_widgets/notification.py class NotificationArea ( widgets . Widget ): \"\"\"Notification area to show notifications in. Will be projected on top of another QWidget which should be passed as an argument to this class. \"\"\" def __init__ ( self , target_widget : QtWidgets . QWidget , use_global_css : bool = False , use_queue : bool = True , max_messages : int = 2 , ): \"\"\"Constructor. Arguments: target_widget : QtWidgets.QWidget The widget to project the notifications on use_global_css : bool (default: False) Flag which indicates whether global style sheets should be used (which have been set at app-level). If False, the default style sheets stored at DEFAULT_NOTIFICATION_STYLES will be loaded. use_queue : bool (default: True) Indicates whether a message queue should be implemented. This will only show *max_messages* at the same time and will put all other messages in a queue. Once a message disappears, the next one in the queue will be shown (up to max_messages at the same time) max_messages : int (default: 2) The number of messages to display at the same time. Raises: TypeError : target_widget is not an object that inherits QWidget \"\"\" if not isinstance ( target_widget , QtWidgets . QWidget ): raise TypeError ( \"target_widget is not a QWidget (or child of it\" ) # Pop some variables from kwargs. self . use_queue = use_queue self . max_messages = max_messages super () . __init__ ( parent = target_widget ) if not use_global_css : self . setStyleSheet ( DEFAULT_NOTIFICATION_STYLES ) if self . use_queue : self . queue : Queue [ Notification ] = Queue () self . target_widget = target_widget self . set_margin ( 0 ) notification_area_layout = widgets . BoxLayout ( \"vertical\" ) self . setLayout ( notification_area_layout ) # Init effects to None self . entry_effect : FadeInValue = None self . entry_effect_duration = 250 self . exit_effect : FadeOutValue = None self . exit_effect_duration = 500 # Store original target classes resizeEvent to be called in our own # function self . target_resize_event = target_widget . resizeEvent # Overwrite resizeEvent function of target_widget to capture it ourself # (parent's resizeEvent will be called in our function too) self . target_widget . resizeEvent = self . resizeEvent # type: ignore self . hide () def __delete_notification ( self , notification : Notification ): \"\"\"Close and destroy the supplied notification.\"\"\" notification . close () self . layout () . removeWidget ( notification ) self . adjustSize () # Hide notification area if it doesn't contain any items if self . layout () . count () == 0 : self . hide () if self . use_queue : try : notification = self . queue . get ( False ) self . _show_notification ( notification ) except Empty : pass # Public functions def set_entry_effect ( self , effect : FadeInValue , duration : int = 250 ): \"\"\"Set the effect with which the notifications are to appear. Arguments: effect : {'fade_in', None} The effect which should be used (for now only 'fade_in' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. duration : int (default: 250 ms) The duration of the effect in milliseconds Raises: TypeError: the object passed for duration is not an int ValueError: duration is less than 0, or effect has an invalid value \"\"\" if effect not in [ \"fade_in\" , None ]: raise ValueError ( \"Invalid entry effect\" ) if not isinstance ( duration , int ): raise TypeError ( \"Duration should be an int\" ) if duration < 0 : raise ValueError ( \"Duration should be larger than 0\" ) self . entry_effect = effect self . entry_effect_duration = duration def set_exit_effect ( self , effect : FadeOutValue , duration : int = 500 ): \"\"\"Set the effect with which the notifications are to disappear. Arguments: effect : {'fade_out', None} the effect which should be used (for now only 'fade_out' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. duration : int (default: 1000 ms) The duration of the effect in milliseconds Raises: TypeError: the object passed for duration is not an int ValueError: duration is less than 0, or effect has an invalid value \"\"\" if effect not in [ \"fade_out\" , None ]: raise ValueError ( \"Invalid exit effect\" ) if not isinstance ( duration , int ): raise TypeError ( \"Duration should be an int\" ) if duration < 0 : raise ValueError ( \"Duration should be larger than 0\" ) self . exit_effect = effect self . exit_effect_duration = duration @core . Slot ( str , str , int , bool ) @core . Slot ( str , str , int , bool , str ) def display ( self , message : str , category : CategoryStr , timeout : int = 5000 , autohide : bool = False , buttontext : str | None = None , ): \"\"\"Display a notification. If a queue is used, then the notification will only be shown directly if the number of notifications shown is smaller than max_messages. Arguments: message : str The message to display category : {'primary', 'success', 'info', 'warning', 'danger'} The type of notification that should be shown. Adheres to bootstrap standards which are primary, success, info, warning and danger timeout : int, optional The duration for which the notification should be shown. If None then the notification will be shown indefinitely buttontext : str, optional The text to display on the closing button. If not provided a cross will be shown. Raises: ValueError: the category is other than one of the expected values. \"\"\" notification = Notification ( message , category , timeout , autohide , buttontext , self ) notification . close_clicked . connect ( self . remove ) # Queue if max amount of notifications is shown if self . use_queue and self . layout () . count () >= self . max_messages : self . queue . put ( notification ) else : self . _show_notification ( notification ) def _cursor_in_area ( self ) -> bool : geom = self . geometry () top_left = self . mapToGlobal ( geom . topLeft ()) bottom_right = self . mapToGlobal ( geom . bottomRight ()) geom = core . Rect ( top_left , bottom_right ) geom . setTop ( geom . top () - CURSOR_MARGIN_TOP ) geom . setBottom ( geom . bottom () + CURSOR_MARGIN_BOTTOM ) geom . setLeft ( geom . left () - CURSOR_MARGIN_LEFT ) geom . setRight ( geom . right () + CURSOR_MARGIN_RIGHT ) cursor_pos = gui . Cursor . get_position () return geom . contains ( cursor_pos ) def _show_notification ( self , notification : Notification ): if self . _cursor_in_area (): core . Timer . singleShot ( 1000 , lambda : self . _show_notification ( notification )) return if not self . isVisible (): self . show () self . raise_ () self . layout () . addWidget ( notification ) # Check for entry effects if self . entry_effect is not None : if self . entry_effect == \"fade_in\" : notification . fade_in ( self . entry_effect_duration ) else : notification . display () self . adjustSize () if notification . timeout is not None and notification . timeout > 0 : core . Timer . singleShot ( notification . timeout , lambda : self . remove ( notification )) @core . Slot () def remove ( self , notification : Notification | None = None ): \"\"\"Removes a notification. Arguments: notification : Notification (default: None) The notification to remove. This function also serves as a PyQt slot for signals emitted from a Notification. In this case, the Notification object is retrieved by using self.sender() Raises: ValueError: notification is not None or a Notification \"\"\" # This function also functions as a pyqt slot. In that case, no # notification argument is passed, but this is set as self.sender() if notification is None : notification = self . sender () if notification . is_being_removed or notification . is_fading_in : return notification . is_being_removed = True # Check if notification is still present (and has not manually been # closed before this function is called by a timeout) if notification not in self . layout (): return # Implement animation here if self . exit_effect == \"fade_out\" : notification . fade_out ( self . __delete_notification , self . exit_effect_duration ) else : self . __delete_notification ( notification ) # Internal Qt functions def resizeEvent ( self , event ): \"\"\"Internal QT function (do not call directly).\"\"\" self . target_resize_event ( event ) newsize = event . size () self . setFixedWidth ( newsize . width ()) self . adjustSize () def paintEvent ( self , pe ): \"\"\"Redefinition of paintEvent. Makes class NotificationArea available in style sheets. Internal QT function (do not call directly). \"\"\" o = widgets . StyleOption . based_on ( self ) p = gui . Painter ( self ) self . style () . drawPrimitive ( widgets . Style . PE_Widget , o , p , self )","title":"NotificationArea"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.__init__","text":"Constructor. Parameters: Name Type Description Default target_widget QtWidgets.QWidget The widget to project the notifications on required use_global_css bool (default: False) Flag which indicates whether global style sheets should be used (which have been set at app-level). If False, the default style sheets stored at DEFAULT_NOTIFICATION_STYLES will be loaded. False use_queue bool (default: True) Indicates whether a message queue should be implemented. This will only show max_messages at the same time and will put all other messages in a queue. Once a message disappears, the next one in the queue will be shown (up to max_messages at the same time) True max_messages int (default: 2) The number of messages to display at the same time. 2 Exceptions: Type Description TypeError target_widget is not an object that inherits QWidget Source code in prettyqt/custom_widgets/notification.py def __init__ ( self , target_widget : QtWidgets . QWidget , use_global_css : bool = False , use_queue : bool = True , max_messages : int = 2 , ): \"\"\"Constructor. Arguments: target_widget : QtWidgets.QWidget The widget to project the notifications on use_global_css : bool (default: False) Flag which indicates whether global style sheets should be used (which have been set at app-level). If False, the default style sheets stored at DEFAULT_NOTIFICATION_STYLES will be loaded. use_queue : bool (default: True) Indicates whether a message queue should be implemented. This will only show *max_messages* at the same time and will put all other messages in a queue. Once a message disappears, the next one in the queue will be shown (up to max_messages at the same time) max_messages : int (default: 2) The number of messages to display at the same time. Raises: TypeError : target_widget is not an object that inherits QWidget \"\"\" if not isinstance ( target_widget , QtWidgets . QWidget ): raise TypeError ( \"target_widget is not a QWidget (or child of it\" ) # Pop some variables from kwargs. self . use_queue = use_queue self . max_messages = max_messages super () . __init__ ( parent = target_widget ) if not use_global_css : self . setStyleSheet ( DEFAULT_NOTIFICATION_STYLES ) if self . use_queue : self . queue : Queue [ Notification ] = Queue () self . target_widget = target_widget self . set_margin ( 0 ) notification_area_layout = widgets . BoxLayout ( \"vertical\" ) self . setLayout ( notification_area_layout ) # Init effects to None self . entry_effect : FadeInValue = None self . entry_effect_duration = 250 self . exit_effect : FadeOutValue = None self . exit_effect_duration = 500 # Store original target classes resizeEvent to be called in our own # function self . target_resize_event = target_widget . resizeEvent # Overwrite resizeEvent function of target_widget to capture it ourself # (parent's resizeEvent will be called in our function too) self . target_widget . resizeEvent = self . resizeEvent # type: ignore self . hide ()","title":"__init__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.display","text":"Display a notification. If a queue is used, then the notification will only be shown directly if the number of notifications shown is smaller than max_messages. Parameters: Name Type Description Default message str The message to display required category {'primary', 'success', 'info', 'warning', 'danger'} The type of notification that should be shown. Adheres to bootstrap standards which are primary, success, info, warning and danger required timeout int, optional The duration for which the notification should be shown. If None then the notification will be shown indefinitely 5000 buttontext str, optional The text to display on the closing button. If not provided a cross will be shown. None Exceptions: Type Description ValueError the category is other than one of the expected values. Source code in prettyqt/custom_widgets/notification.py @core . Slot ( str , str , int , bool ) @core . Slot ( str , str , int , bool , str ) def display ( self , message : str , category : CategoryStr , timeout : int = 5000 , autohide : bool = False , buttontext : str | None = None , ): \"\"\"Display a notification. If a queue is used, then the notification will only be shown directly if the number of notifications shown is smaller than max_messages. Arguments: message : str The message to display category : {'primary', 'success', 'info', 'warning', 'danger'} The type of notification that should be shown. Adheres to bootstrap standards which are primary, success, info, warning and danger timeout : int, optional The duration for which the notification should be shown. If None then the notification will be shown indefinitely buttontext : str, optional The text to display on the closing button. If not provided a cross will be shown. Raises: ValueError: the category is other than one of the expected values. \"\"\" notification = Notification ( message , category , timeout , autohide , buttontext , self ) notification . close_clicked . connect ( self . remove ) # Queue if max amount of notifications is shown if self . use_queue and self . layout () . count () >= self . max_messages : self . queue . put ( notification ) else : self . _show_notification ( notification )","title":"display()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.paintEvent","text":"Redefinition of paintEvent. Makes class NotificationArea available in style sheets. Internal QT function (do not call directly). Source code in prettyqt/custom_widgets/notification.py def paintEvent ( self , pe ): \"\"\"Redefinition of paintEvent. Makes class NotificationArea available in style sheets. Internal QT function (do not call directly). \"\"\" o = widgets . StyleOption . based_on ( self ) p = gui . Painter ( self ) self . style () . drawPrimitive ( widgets . Style . PE_Widget , o , p , self )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.remove","text":"Removes a notification. Parameters: Name Type Description Default notification Notification (default: None) The notification to remove. This function also serves as a PyQt slot for signals emitted from a Notification. In this case, the Notification object is retrieved by using self.sender() None Exceptions: Type Description ValueError notification is not None or a Notification Source code in prettyqt/custom_widgets/notification.py @core . Slot () def remove ( self , notification : Notification | None = None ): \"\"\"Removes a notification. Arguments: notification : Notification (default: None) The notification to remove. This function also serves as a PyQt slot for signals emitted from a Notification. In this case, the Notification object is retrieved by using self.sender() Raises: ValueError: notification is not None or a Notification \"\"\" # This function also functions as a pyqt slot. In that case, no # notification argument is passed, but this is set as self.sender() if notification is None : notification = self . sender () if notification . is_being_removed or notification . is_fading_in : return notification . is_being_removed = True # Check if notification is still present (and has not manually been # closed before this function is called by a timeout) if notification not in self . layout (): return # Implement animation here if self . exit_effect == \"fade_out\" : notification . fade_out ( self . __delete_notification , self . exit_effect_duration ) else : self . __delete_notification ( notification )","title":"remove()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.resizeEvent","text":"Internal QT function (do not call directly). Source code in prettyqt/custom_widgets/notification.py def resizeEvent ( self , event ): \"\"\"Internal QT function (do not call directly).\"\"\" self . target_resize_event ( event ) newsize = event . size () self . setFixedWidth ( newsize . width ()) self . adjustSize ()","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.set_entry_effect","text":"Set the effect with which the notifications are to appear. Parameters: Name Type Description Default effect {'fade_in', None} The effect which should be used (for now only 'fade_in' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. required duration int (default: 250 ms) The duration of the effect in milliseconds 250 Exceptions: Type Description TypeError the object passed for duration is not an int ValueError duration is less than 0, or effect has an invalid value Source code in prettyqt/custom_widgets/notification.py def set_entry_effect ( self , effect : FadeInValue , duration : int = 250 ): \"\"\"Set the effect with which the notifications are to appear. Arguments: effect : {'fade_in', None} The effect which should be used (for now only 'fade_in' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. duration : int (default: 250 ms) The duration of the effect in milliseconds Raises: TypeError: the object passed for duration is not an int ValueError: duration is less than 0, or effect has an invalid value \"\"\" if effect not in [ \"fade_in\" , None ]: raise ValueError ( \"Invalid entry effect\" ) if not isinstance ( duration , int ): raise TypeError ( \"Duration should be an int\" ) if duration < 0 : raise ValueError ( \"Duration should be larger than 0\" ) self . entry_effect = effect self . entry_effect_duration = duration","title":"set_entry_effect()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.set_exit_effect","text":"Set the effect with which the notifications are to disappear. Parameters: Name Type Description Default effect {'fade_out', None} the effect which should be used (for now only 'fade_out' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. required duration int (default: 1000 ms) The duration of the effect in milliseconds 500 Exceptions: Type Description TypeError the object passed for duration is not an int ValueError duration is less than 0, or effect has an invalid value Source code in prettyqt/custom_widgets/notification.py def set_exit_effect ( self , effect : FadeOutValue , duration : int = 500 ): \"\"\"Set the effect with which the notifications are to disappear. Arguments: effect : {'fade_out', None} the effect which should be used (for now only 'fade_out' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly. duration : int (default: 1000 ms) The duration of the effect in milliseconds Raises: TypeError: the object passed for duration is not an int ValueError: duration is less than 0, or effect has an invalid value \"\"\" if effect not in [ \"fade_out\" , None ]: raise ValueError ( \"Invalid exit effect\" ) if not isinstance ( duration , int ): raise TypeError ( \"Duration should be an int\" ) if duration < 0 : raise ValueError ( \"Duration should be larger than 0\" ) self . exit_effect = effect self . exit_effect_duration = duration","title":"set_exit_effect()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo","text":"","title":"popupinfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo","text":"Source code in prettyqt/custom_widgets/popupinfo.py class PopupInfo ( widgets . Dialog ): \"\"\"Dialog overlay to show some info to user.\"\"\" def __init__ ( self , parent : QtWidgets . QWidget | None = None , text : str | None = None ): super () . __init__ ( parent = parent ) self . timer = core . Timer . single_shot ( callback = self . close ) self . label = widgets . Label () self . set_flags ( stay_on_top = True , frameless = True , tool = True ) layout = widgets . BoxLayout ( \"vertical\" ) layout . set_margin ( 20 ) self . set_layout ( layout ) self . set_background_color ( \"black\" ) self . label . set_color ( \"white\" ) layout . add ( self . label ) # signals.signals.popup_info.connect(self.popup) def show ( self ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) // 2 y = ( screen_geo . height () - size . height ()) // 2 self . move ( x , y - 200 ) super () . show () self . timer . start ( 2500 ) def show_popup ( self , text : str ): self . label . setText ( text ) self . show ()","title":"PopupInfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo.show","text":"show(self) -> None Source code in prettyqt/custom_widgets/popupinfo.py def show ( self ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) // 2 y = ( screen_geo . height () - size . height ()) // 2 self . move ( x , y - 200 ) super () . show () self . timer . start ( 2500 )","title":"show()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor","text":"Module containing classes related to the RegEx editor.","title":"regexeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.__main__","text":"This module contains the editor widget implementation.","title":"__main__"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.quick_ref","text":"Contains the quick reference widget.","title":"quick_ref"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.regexeditorwidget","text":"This module contains the editor widget implementation.","title":"regexeditorwidget"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar","text":"","title":"roundprogressbar"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar.RoundProgressBar","text":"Source code in prettyqt/custom_widgets/roundprogressbar.py class RoundProgressBar ( widgets . Widget ): # CONSTANTS POSITION_LEFT = 180.0 POSITION_TOP = 90.0 POSITION_RIGHT = 0.0 POSITION_BOTTOM = - 90.0 def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) self . _min_value = 0.0 self . _max_value = 100.0 self . current_value = 0.0 self . null_pos = self . POSITION_TOP self . bar_style : BarStyleStr = \"donut\" self . outline_pen_width = 1.0 self . data_pen_width = 1.0 self . _rebuild_brush = False self . number_format = \"%p%\" self . decimals = 1 self . _update_flags : ValueTypeStr = \"percent\" self . gradient_data : list [ QtGui . QColor ] = list () def minimum ( self ): return self . _min_value def maximum ( self ): return self . _max_value # SETTERS ------------------------------------------------------- def set_null_position ( self , position : float ): if position != self . null_pos : self . null_pos = position self . _rebuild_brush = True self . update () def set_bar_style ( self , style : BarStyleStr ): if style not in BAR_STYLE : raise InvalidParamError ( style , BAR_STYLE ) if style != self . bar_style : self . bar_style = style self . _rebuild_brush = True self . update () def set_outline_pen_width ( self , width : float ): if width != self . outline_pen_width : self . outline_pen_width = width self . update () def set_data_pen_width ( self , width : float ): if width != self . data_pen_width : self . data_pen_width = width self . update () def set_data_colors ( self , stop_points : list [ QtGui . QColor ]): if stop_points != self . gradient_data : self . gradient_data = stop_points self . _rebuild_brush = True self . update () def set_format ( self , val : str ): if val != self . number_format : self . number_format = val self . _value_format_changed () def set_decimals ( self , count : int ): if count >= 0 and count != self . decimals : self . decimals = count self . _value_format_changed () # SLOTS --------------------------------------------------------- @core . Slot ( float , float ) def set_range ( self , minval : float , maxval : float ): self . _min_value = min ( minval , maxval ) self . _max_value = max ( minval , maxval ) self . current_value = min ( self . _max_value , max ( self . _min_value , self . current_value ) ) self . _rebuild_brush = True self . update () @core . Slot ( float ) def setMinimum ( self , val : float ): self . set_range ( val , self . _max_value ) @core . Slot ( float ) def setMaximum ( self , val : float ): self . set_range ( self . _min_value , val ) @core . Slot ( float ) def set_value ( self , val : float ): if self . current_value != val : self . current_value = min ( self . _max_value , max ( self . _min_value , val )) self . update () def get_value ( self ) -> float : return self . current_value # PAINTING ------------------------------------------------------ def paintEvent ( self , event : gui . PaintEvent ): outer_radius = min ( self . width (), self . height ()) rect = core . RectF ( 1 , 1 , outer_radius - 2 , outer_radius - 2 ) with gui . Painter ( self ) as painter : painter . use_antialiasing () if self . bar_style != \"line\" : self . _rebuild_data_brush_if_needed () painter . fillRect ( 0 , 0 , outer_radius , outer_radius , self . palette () . window ()) self . _draw_base ( painter , rect ) self . _draw_value ( painter , rect , self . current_value ) inner_rect , inner_radius = self . _calculate_inner_rect ( outer_radius ) self . _draw_inner_background ( painter , inner_rect ) self . _draw_text ( painter , inner_rect , inner_radius , self . current_value ) def _draw_base ( self , painter : gui . Painter , rect : core . RectF ): if self . bar_style == \"donut\" : color = self . palette () . shadow () . color () painter . set_pen ( color = color , width = self . outline_pen_width ) painter . setBrush ( self . palette () . base ()) painter . drawEllipse ( rect ) elif self . bar_style == \"line\" : base_color = self . palette () . base () . color () painter . set_pen ( color = base_color , width = self . outline_pen_width ) painter . setBrush ( QtCore . Qt . BrushStyle . NoBrush ) width = self . outline_pen_width / 2 adjusted = rect . adjusted ( width , width , - width , - width ) painter . drawEllipse ( adjusted ) elif self . bar_style in ( \"pie\" , \"expand\" ): base_color = self . palette () . base () . color () painter . set_pen ( color = base_color , width = self . outline_pen_width ) painter . setBrush ( self . palette () . base ()) painter . drawEllipse ( rect ) def _draw_value ( self , painter : gui . Painter , rect : core . RectF , value : float ): if value == self . _min_value : return diff = self . current_value - self . _min_value value_range = self . _max_value - self . _min_value delta = max ( value_range / diff , 0 ) if self . bar_style == \"expand\" : painter . setBrush ( self . palette () . highlight ()) color = self . palette () . shadow () . color () painter . set_pen ( color = color , width = self . data_pen_width ) radius = ( rect . height () / 2 ) / delta painter . drawEllipse ( rect . center (), radius , radius ) elif self . bar_style == \"line\" : color = self . palette () . highlight () . color () painter . set_pen ( color = color , width = self . data_pen_width ) painter . setBrush ( QtCore . Qt . BrushStyle . NoBrush ) pen_width = self . outline_pen_width / 2 adjusted = rect . adjusted ( pen_width , pen_width , - pen_width , - pen_width ) if value == self . _max_value : painter . drawEllipse ( adjusted ) else : arc_length = 360 / delta painter . drawArc ( adjusted , int ( self . null_pos * 16 ), int ( - arc_length * 16 )) elif self . bar_style in [ \"donut\" , \"pie\" ]: data_path = gui . PainterPath () data_path . set_fill_rule ( \"winding\" ) if value == self . _max_value : data_path . addEllipse ( rect ) else : arc_length = 360 / delta center_point = rect . center () data_path . moveTo ( center_point ) data_path . arcTo ( rect , self . null_pos , - arc_length ) data_path . lineTo ( center_point ) painter . setBrush ( self . palette () . highlight ()) shadow_color = self . palette () . shadow () . color () painter . set_pen ( color = shadow_color , width = self . data_pen_width ) painter . drawPath ( data_path ) def _calculate_inner_rect ( self , outer_radius : float ) -> tuple [ core . RectF , float ]: if self . bar_style in ( \"line\" , \"expand\" ): inner_radius = outer_radius - self . outline_pen_width else : inner_radius = outer_radius * 0.75 delta = ( outer_radius - inner_radius ) / 2 inner_rect = core . RectF ( delta , delta , inner_radius , inner_radius ) return inner_rect , inner_radius def _draw_inner_background ( self , painter : gui . Painter , inner_rect : core . RectF ): if self . bar_style == \"donut\" : painter . setBrush ( self . palette () . base ()) painter . drawEllipse ( inner_rect ) def _draw_text ( self , painter : gui . Painter , inner_rect : core . RectF , inner_radius : float , value : float , ): if not self . number_format : return font = self . get_font () font . setPixelSize ( 10 ) metrics = gui . FontMetricsF ( font ) max_width = metrics . width ( self . _value_to_text ( self . _max_value )) delta = inner_radius / max_width font_size = int ( font . pixelSize () * delta * 0.75 ) font . setPixelSize ( max ( font_size , 1 )) painter . setFont ( font ) painter . setPen ( self . palette () . text () . color ()) text = self . _value_to_text ( value ) painter . drawText ( inner_rect , constants . ALIGN_CENTER , text ) # type: ignore def _value_to_text ( self , value : float ) -> str : text_to_draw = self . number_format if self . _update_flags == \"value\" : val = round ( value , self . decimals ) return text_to_draw . replace ( r \"%v\" , str ( val )) elif self . _update_flags == \"percent\" : pct = ( value - self . _min_value ) / ( self . _max_value - self . _min_value ) * 100 val = round ( pct , self . decimals ) return text_to_draw . replace ( r \"%p\" , str ( val )) elif self . _update_flags == \"max\" : val = round ( self . _max_value - self . _min_value + 1 , self . decimals ) return text_to_draw . replace ( r \"%m\" , str ( val )) else : return ValueError () def _value_format_changed ( self ): for k , v in VALUE_MAP . items (): if k in self . number_format : self . _update_flags = v self . update () def _rebuild_data_brush_if_needed ( self ): if not self . _rebuild_brush or not self . gradient_data : return self . _rebuild_brush = False if self . bar_style == \"expand\" : data_brush = gui . RadialGradient ( 0.5 , 0.5 , 0.5 , 0.5 , 0.5 ) for i in self . gradient_data : data_brush [ i [ 0 ]] = i [ 1 ] else : data_brush = gui . ConicalGradient ( 0.5 , 0.5 , self . null_pos ) for i in self . gradient_data : data_brush [ 1 - i [ 0 ]] = i [ 1 ] data_brush . set_coordinate_mode ( \"stretch_to_device\" ) with self . edit_palette () as palette : palette . set_brush ( \"highlight\" , data_brush )","title":"RoundProgressBar"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar.RoundProgressBar.paintEvent","text":"paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/roundprogressbar.py def paintEvent ( self , event : gui . PaintEvent ): outer_radius = min ( self . width (), self . height ()) rect = core . RectF ( 1 , 1 , outer_radius - 2 , outer_radius - 2 ) with gui . Painter ( self ) as painter : painter . use_antialiasing () if self . bar_style != \"line\" : self . _rebuild_data_brush_if_needed () painter . fillRect ( 0 , 0 , outer_radius , outer_radius , self . palette () . window ()) self . _draw_base ( painter , rect ) self . _draw_value ( painter , rect , self . current_value ) inner_rect , inner_radius = self . _calculate_inner_rect ( outer_radius ) self . _draw_inner_background ( painter , inner_rect ) self . _draw_text ( painter , inner_rect , inner_radius , self . current_value )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider","text":"","title":"spanslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider","text":"Source code in prettyqt/custom_widgets/spanslider.py class SpanSlider ( widgets . Slider ): value_changed = core . Signal ( object ) lower_pos_changed = core . Signal ( float ) upper_pos_changed = core . Signal ( float ) slider_pressed = core . Signal ( object ) def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( \"horizontal\" , parent ) self . rangeChanged . connect ( self . update_range ) self . sliderReleased . connect ( self . _move_pressed_handle ) self . lower_val = 0.0 self . upper_val = 0.0 self . lower_pos = 0.0 self . upper_pos = 0.0 self . offset = 0 self . position = 0.0 self . last_pressed : str | None = None self . upper_pressed = widgets . Style . SubControl . SC_None self . lower_pressed = widgets . Style . SubControl . SC_None self . movement : MovementModeStr = \"no_crossing\" self . _main_control : Literal [ \"lower\" , \"upper\" ] = \"lower\" self . _first_movement = False self . _block_tracking = False dark_color = self . palette () . color ( gui . Palette . ColorRole . Dark ) self . gradient_left = dark_color . lighter ( 110 ) self . gradient_right = dark_color . lighter ( 110 ) def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . _handle_mouse_press ( event . position (), self . upper_pressed , self . upper_val , \"upper\" ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . _handle_mouse_press ( event . position (), self . lower_pressed , self . lower_val , \"lower\" ) self . _first_movement = True event . accept () def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PixelMetric . PM_MaximumDragDistance , opt , self ) pixel_pos = self . pick ( event . position ()) - self . offset new_pos = float ( self . _pixel_pos_to_value ( pixel_pos )) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . position ()): new_pos = self . position # pick the preferred handle on the first movement if self . _first_movement : if self . lower_val == self . upper_val : if new_pos < self . lower_value : self . _swap_controls () self . _first_movement = False else : self . _first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper_val ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper_val - 1 ) if self . movement == \"free\" and new_pos > self . upper_val : self . _swap_controls () self . set_upper_pos ( new_pos ) else : # movement \"none\" self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower_val : self . _swap_controls () self . set_lower_pos ( new_pos ) else : # movement \"none\" self . set_upper_pos ( new_pos ) event . accept () def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SubControl . SC_None self . update () def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SubControl . SC_SliderTickmarks painter . draw_complex_control ( \"slider\" , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . draw_complex_control ( \"slider\" , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () if self . is_horizontal (): rect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) else : rect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) self . _draw_span ( painter , rect ) # handles if self . last_pressed == \"lower\" : self . draw_handle ( painter , \"upper\" ) self . draw_handle ( painter , \"lower\" ) else : self . draw_handle ( painter , \"lower\" ) self . draw_handle ( painter , \"upper\" ) @core . Property ( float ) def lower_value ( self ) -> float : return min ( self . lower_val , self . upper_val ) def set_lower_value ( self , lower : float ): self . set_span ( lower , self . upper_val ) @core . Property ( float ) def upper_value ( self ) -> float : return max ( self . lower_val , self . upper_val ) def set_upper_value ( self , upper : float ): self . set_span ( self . lower_val , upper ) def on_value_change ( self ): self . value_changed . emit (( self . lower_val , self . upper_val )) def get_value ( self ) -> tuple [ float , float ]: return ( self . lower_val , self . upper_val ) def set_value ( self , value : tuple [ float , float ]): self . set_lower_value ( value [ 0 ]) self . set_upper_value ( value [ 1 ]) def get_movement_mode ( self ) -> MovementModeStr : return self . movement def set_movement_mode ( self , mode : MovementModeStr ): \"\"\"Set movement mode. Args: mode: movement mode for the main window Raises: ValueError: movement mode type does not exist \"\"\" if mode not in MOVEMENT_MODE : raise ValueError ( \"Invalid movement mode\" ) self . movement = mode def set_span ( self , lower : float , upper : float ): low = clamp ( min ( lower , upper ), self . minimum (), self . maximum ()) upp = clamp ( max ( lower , upper ), self . minimum (), self . maximum ()) changed = False if low != self . lower_val : self . lower_val = low self . lower_pos = low changed = True if upp != self . upper_val : self . upper_val = upp self . upper_pos = upp changed = True if changed : self . on_value_change () self . update () def set_lower_pos ( self , lower : float ): if self . lower_pos == lower : return self . lower_pos = lower if not self . hasTracking (): self . update () if self . isSliderDown (): self . lower_pos_changed . emit ( lower ) if self . hasTracking () and not self . _block_tracking : main = self . _main_control == \"lower\" self . trigger_action ( \"move\" , main ) def set_upper_pos ( self , upper : float ): if self . upper_pos == upper : return self . upper_pos = upper if not self . hasTracking (): self . update () if self . isSliderDown (): self . upper_pos_changed . emit ( upper ) if self . hasTracking () and not self . _block_tracking : main = self . _main_control == \"upper\" self . trigger_action ( \"move\" , main ) def set_left_color ( self , color : types . ColorType ): self . gradient_left = colors . get_color ( color ) self . update () def set_right_color ( self , color : types . ColorType ): self . gradient_right = colors . get_color ( color ) self . update () def _move_pressed_handle ( self ): if self . last_pressed == \"lower\" : if self . lower_pos != self . lower_val : main = self . _main_control == \"lower\" self . trigger_action ( \"move\" , main ) elif self . last_pressed == \"upper\" : if self . upper_pos != self . upper_val : main = self . _main_control == \"upper\" self . trigger_action ( \"move\" , main ) def pick ( self , p : types . PointType ) -> int : if isinstance ( p , tuple ): return p [ 0 ] if self . is_horizontal () else p [ 1 ] else : return p . x () if self . is_horizontal () else p . y () def trigger_action ( self , action : ActionStr , main : bool ): value = 0.0 no = False up = False my_min = self . minimum () my_max = self . maximum () self . _block_tracking = True main_control = main and self . _main_control == \"upper\" alt_control = not main and self . _main_control == \"lower\" is_upper_handle = main_control or alt_control val = self . upper_val if is_upper_handle else self . lower_val if action == \"single_step_add\" : up = is_upper_handle value = clamp ( val + self . singleStep (), my_min , my_max ) elif action == \"single_step_sub\" : up = is_upper_handle value = clamp ( val - self . singleStep (), my_min , my_max ) elif action == \"to_minimum\" : up = is_upper_handle value = my_min elif action == \"to_maximum\" : up = is_upper_handle value = my_max elif action == \"move\" : up = is_upper_handle no = True elif action == \"none\" : no = True if not no and not up : if self . movement == \"no_crossing\" : value = min ( value , self . upper_val ) elif self . movement == \"no_overlap\" : value = min ( value , self . upper_val - 1 ) if self . movement == \"free\" and value > self . upper_val : self . _swap_controls () self . set_upper_pos ( value ) else : self . set_lower_pos ( value ) elif not no : if self . movement == \"no_crossing\" : value = max ( value , self . lower_val ) elif self . movement == \"no_overlap\" : value = max ( value , self . lower_val + 1 ) if self . movement == \"free\" and value < self . lower_val : self . _swap_controls () self . set_lower_pos ( value ) else : self . set_upper_pos ( value ) self . _block_tracking = False self . set_lower_value ( self . lower_pos ) self . set_upper_value ( self . upper_pos ) def _swap_controls ( self ): self . lower_val , self . upper_val = self . upper_val , self . lower_val self . lower_pressed , self . upper_pressed = self . upper_pressed , self . lower_pressed self . last_pressed = \"upper\" if self . last_pressed == \"lower\" else \"lower\" self . _main_control = \"upper\" if self . _main_control == \"lower\" else \"lower\" def update_range ( self , min_ , max_ ): # set_span() takes care of keeping span in range self . set_span ( self . lower_val , self . upper_val ) def _setup_painter ( self , painter : widgets . StylePainter , orientation : Literal [ \"horizontal\" , \"vertical\" ], x1 : int , y1 : int , x2 : int , y2 : int , ): highlight = self . palette () . color ( gui . Palette . ColorRole . Highlight ) gradient = gui . LinearGradient ( x1 , y1 , x2 , y2 ) gradient [ 0 ] = highlight . darker ( 120 ) gradient [ 1 ] = highlight . lighter ( 108 ) painter . setBrush ( gradient ) val = 130 if orientation == \"horizontal\" else 150 painter . set_pen ( color = highlight . darker ( val ), width = 0 ) def _draw_span ( self , painter : widgets . StylePainter , rect : core . Rect ): opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) painter . set_pen ( color = self . gradient_left , width = 0 ) groove = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) if opt . is_horizontal (): groove . adjust ( 0 , 0 , - 1 , 0 ) self . _setup_painter ( painter , opt . get_orientation (), groove . center () . x (), groove . top (), groove . center () . x (), groove . bottom (), ) else : groove . adjust ( 0 , 0 , 0 , - 1 ) self . _setup_painter ( painter , opt . get_orientation (), groove . left (), groove . center () . y (), groove . right (), groove . center () . y (), ) # draw groove intersected = core . RectF ( rect . intersected ( groove )) gradient = gui . LinearGradient ( intersected . topLeft (), intersected . topRight ()) gradient [ 0 ] = self . gradient_left gradient [ 1 ] = self . gradient_right painter . fillRect ( intersected , gradient ) def draw_handle ( self , painter : widgets . StylePainter , handle : HandleStr ): opt = self . get_style_option ( handle ) opt . subControls = HANDLE_STYLE pressed = self . upper_pressed if handle == \"lower\" : pressed = self . lower_pressed if pressed == HANDLE_STYLE : opt . activeSubControls = pressed opt . state |= widgets . Style . StateFlag . State_Sunken painter . draw_complex_control ( \"slider\" , opt ) def get_style_option ( self , handle : HandleStr ) -> widgets . StyleOptionSlider : option = widgets . StyleOptionSlider () self . initStyleOption ( option ) if handle == \"lower\" : option . sliderPosition = self . lower_pos option . sliderValue = self . lower_val else : option . sliderPosition = self . upper_pos option . sliderValue = self . upper_val return option def _handle_mouse_press ( self , pos : QtCore . QPoint , control , value : float , handle : HandleStr ): opt = self . get_style_option ( handle ) old_control = control control = self . style () . hitTestComplexControl ( SLIDER_STYLE , opt , pos , self ) sr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) if control == HANDLE_STYLE : self . position = value self . offset = self . pick ( pos - sr . topLeft ()) self . last_pressed = handle self . setSliderDown ( True ) self . slider_pressed . emit ( handle ) if control != old_control : self . update ( sr ) return control def _pixel_pos_to_value ( self , pos : int ) -> int : opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) gr = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) sr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) if self . is_horizontal (): len_slider = sr . width () slider_min = gr . x () slider_end = gr . right () else : len_slider = sr . height () slider_min = gr . y () slider_end = gr . bottom () return widgets . Style . sliderValueFromPosition ( self . minimum (), self . maximum (), pos - slider_min , slider_end - len_slider + 1 - slider_min , opt . upsideDown , )","title":"SpanSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseMoveEvent","text":"mouseMoveEvent(self, ev: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/spanslider.py def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PixelMetric . PM_MaximumDragDistance , opt , self ) pixel_pos = self . pick ( event . position ()) - self . offset new_pos = float ( self . _pixel_pos_to_value ( pixel_pos )) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . position ()): new_pos = self . position # pick the preferred handle on the first movement if self . _first_movement : if self . lower_val == self . upper_val : if new_pos < self . lower_value : self . _swap_controls () self . _first_movement = False else : self . _first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper_val ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper_val - 1 ) if self . movement == \"free\" and new_pos > self . upper_val : self . _swap_controls () self . set_upper_pos ( new_pos ) else : # movement \"none\" self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower_val : self . _swap_controls () self . set_lower_pos ( new_pos ) else : # movement \"none\" self . set_upper_pos ( new_pos ) event . accept ()","title":"mouseMoveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mousePressEvent","text":"mousePressEvent(self, ev: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/spanslider.py def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . _handle_mouse_press ( event . position (), self . upper_pressed , self . upper_val , \"upper\" ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . _handle_mouse_press ( event . position (), self . lower_pressed , self . lower_val , \"lower\" ) self . _first_movement = True event . accept ()","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseReleaseEvent","text":"mouseReleaseEvent(self, ev: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/spanslider.py def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SubControl . SC_None self . update ()","title":"mouseReleaseEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.paintEvent","text":"paintEvent(self, ev: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/spanslider.py def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SubControl . SC_SliderTickmarks painter . draw_complex_control ( \"slider\" , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . draw_complex_control ( \"slider\" , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () if self . is_horizontal (): rect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) else : rect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) self . _draw_span ( painter , rect ) # handles if self . last_pressed == \"lower\" : self . draw_handle ( painter , \"upper\" ) self . draw_handle ( painter , \"lower\" ) else : self . draw_handle ( painter , \"lower\" ) self . draw_handle ( painter , \"upper\" )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.set_movement_mode","text":"Set movement mode. Parameters: Name Type Description Default mode MovementModeStr movement mode for the main window required Exceptions: Type Description ValueError movement mode type does not exist Source code in prettyqt/custom_widgets/spanslider.py def set_movement_mode ( self , mode : MovementModeStr ): \"\"\"Set movement mode. Args: mode: movement mode for the main window Raises: ValueError: movement mode type does not exist \"\"\" if mode not in MOVEMENT_MODE : raise ValueError ( \"Invalid movement mode\" ) self . movement = mode","title":"set_movement_mode()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.trigger_action","text":"Trigger slider action. Source code in prettyqt/custom_widgets/spanslider.py def trigger_action ( self , action : ActionStr , main : bool ): value = 0.0 no = False up = False my_min = self . minimum () my_max = self . maximum () self . _block_tracking = True main_control = main and self . _main_control == \"upper\" alt_control = not main and self . _main_control == \"lower\" is_upper_handle = main_control or alt_control val = self . upper_val if is_upper_handle else self . lower_val if action == \"single_step_add\" : up = is_upper_handle value = clamp ( val + self . singleStep (), my_min , my_max ) elif action == \"single_step_sub\" : up = is_upper_handle value = clamp ( val - self . singleStep (), my_min , my_max ) elif action == \"to_minimum\" : up = is_upper_handle value = my_min elif action == \"to_maximum\" : up = is_upper_handle value = my_max elif action == \"move\" : up = is_upper_handle no = True elif action == \"none\" : no = True if not no and not up : if self . movement == \"no_crossing\" : value = min ( value , self . upper_val ) elif self . movement == \"no_overlap\" : value = min ( value , self . upper_val - 1 ) if self . movement == \"free\" and value > self . upper_val : self . _swap_controls () self . set_upper_pos ( value ) else : self . set_lower_pos ( value ) elif not no : if self . movement == \"no_crossing\" : value = max ( value , self . lower_val ) elif self . movement == \"no_overlap\" : value = max ( value , self . lower_val + 1 ) if self . movement == \"free\" and value < self . lower_val : self . _swap_controls () self . set_lower_pos ( value ) else : self . set_upper_pos ( value ) self . _block_tracking = False self . set_lower_value ( self . lower_pos ) self . set_upper_value ( self . upper_pos )","title":"trigger_action()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.subsequencecompleter","text":"","title":"subsequencecompleter"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.subsequencecompleter.SubsequenceCompleter","text":"Source code in prettyqt/custom_widgets/subsequencecompleter.py class SubsequenceCompleter ( widgets . Completer ): \"\"\"QCompleter specialised for subsequence matching.\"\"\" def __init__ ( self , * args ): super () . __init__ ( * args ) self . local_completion_prefix = \"\" self . source_model = None self . proxy_model = custom_models . SubsequenceSortFilterProxyModel ( self . is_case_sensitive (), parent = self ) self . proxy_model . set_sort_role ( \"user\" ) self . _force_next_update = True def setModel ( self , model : QtCore . QAbstractItemModel ): self . source_model = model self . proxy_model = custom_models . SubsequenceSortFilterProxyModel ( self . is_case_sensitive (), parent = self ) self . proxy_model . set_sort_role ( \"user\" ) self . proxy_model . set_prefix ( self . local_completion_prefix ) self . proxy_model . setSourceModel ( self . source_model ) super () . setModel ( self . proxy_model ) self . proxy_model . invalidate () self . proxy_model . sort ( 0 ) self . _force_next_update = True def update_model ( self ): count = self . completionCount () if count or len ( self . local_completion_prefix ) <= 1 or self . _force_next_update : self . proxy_model . set_prefix ( self . local_completion_prefix ) self . proxy_model . invalidate () # force sorting/filtering if count > 1 : self . proxy_model . sort ( 0 ) self . _force_next_update = False def splitPath ( self , path : str ) -> list [ str ]: self . local_completion_prefix = path self . update_model () return [ \"\" ]","title":"SubsequenceCompleter"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.subsequencecompleter.SubsequenceCompleter.setModel","text":"setModel(self, c: PySide6.QtCore.QAbstractItemModel) -> None Source code in prettyqt/custom_widgets/subsequencecompleter.py def setModel ( self , model : QtCore . QAbstractItemModel ): self . source_model = model self . proxy_model = custom_models . SubsequenceSortFilterProxyModel ( self . is_case_sensitive (), parent = self ) self . proxy_model . set_sort_role ( \"user\" ) self . proxy_model . set_prefix ( self . local_completion_prefix ) self . proxy_model . setSourceModel ( self . source_model ) super () . setModel ( self . proxy_model ) self . proxy_model . invalidate () self . proxy_model . sort ( 0 ) self . _force_next_update = True","title":"setModel()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.subsequencecompleter.SubsequenceCompleter.splitPath","text":"splitPath(self, path: str) -> List[str] Source code in prettyqt/custom_widgets/subsequencecompleter.py def splitPath ( self , path : str ) -> list [ str ]: self . local_completion_prefix = path self . update_model () return [ \"\" ]","title":"splitPath()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline","text":"","title":"timeline"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline","text":"Source code in prettyqt/custom_widgets/timeline.py class Timeline ( widgets . Widget ): position_changed = core . Signal ( int ) selection_changed = core . Signal ( VideoSample ) def __init__ ( self , duration : int , length : int ): super () . __init__ () self . set_title ( \"Timeline\" ) self . duration = duration self . length = length # Set variables self . set_background_color ( BACKGROUND_COLOR ) self . set_text_color ( TEXT_COLOR ) self . set_text_font ( FONT ) self . _position = None self . pointer_time_pos = 0.0 self . selected_sample = None self . _clicking = False # Check if mouse left button is being pressed self . _is_in = False # check if user is in the widget self . video_samples : list [ VideoSample ] = [] # List of video samples self . setMouseTracking ( True ) # Mouse events self . setAutoFillBackground ( True ) # background self . setGeometry ( 300 , 300 , self . length , 200 ) # Set Background with self . edit_palette () as pal : pal . set_color ( \"window\" , self . background_color ) def __len__ ( self ): return len ( self . video_samples ) def __getitem__ ( self , index : int ) -> VideoSample : return self . video_samples [ index ] def __setitem__ ( self , index : int , value : VideoSample ): self . video_samples [ index ] = value def __add__ ( self , other : VideoSample ) -> Timeline : self . add ( other ) return self def add_sample ( self , duration : int , color : types . ColorType = \"yellow\" , picture : QtGui . QPixmap | None = None , ) -> VideoSample : sample = VideoSample ( duration , color , picture ) self . add ( sample ) return sample def add ( self , sample : VideoSample ): self . video_samples . append ( sample ) def paintEvent ( self , event ): # Draw time scale = self . get_scale () with gui . Painter ( self ) as qp : qp . set_color ( self . text_color ) qp . setFont ( self . text_font ) qp . use_antialiasing () w = 0 while ( w := w + 100 ) <= self . width (): time_string = helpers . format_seconds ( w * scale ) rect = core . Rect ( w - 50 , 0 , 100 , 100 ) qp . drawText ( rect , constants . ALIGN_H_CENTER , time_string ) # Draw down line qp . set_pen ( color = PEN_COLOR , width = 5 ) qp . drawLine ( 0 , 40 , self . width (), 40 ) # Draw dash lines point = 0 qp . set_pen ( color = self . text_color ) qp . drawLine ( 0 , 40 , self . width (), 40 ) while point <= self . width (): y2 = 30 if point % 30 != 0 else 20 qp . drawLine ( 3 * point , 40 , 3 * point , y2 ) point += 10 if self . _position is not None and self . _is_in : qp . drawLine ( self . _position . x (), 0 , self . _position . x (), 40 ) poly = gui . Polygon () if self . _position is not None : val = self . pointer_time_pos / self . get_scale () line = core . Line ( val , 40 , val , self . height ()) poly . add_points (( val - 10 , 20 ), ( val + 10 , 20 ), ( val , 40 )) else : line = core . Line ( 0 , 0 , 0 , self . height ()) poly . add_points (( - 10 , 20 ), ( 10 , 20 ), ( 0 , 40 )) # Draw samples t = 0.0 for sample in self . video_samples : scaled_dur = sample . duration / scale scaled_t = t / scale t += sample . duration # Clear clip path with qp . clip_path () as path : rect = core . RectF ( scaled_t , 50 , scaled_dur , 200 ) path . addRoundedRect ( rect , 10 , 10 ) # Draw sample path = gui . PainterPath () qp . set_pen ( color = sample . color ) rect = core . RectF ( scaled_t , 50 , scaled_dur , 50 ) path . addRoundedRect ( rect , 10 , 10 ) sample . start_pos = scaled_t sample . end_pos = scaled_t + scaled_dur qp . fillPath ( path , sample . color ) qp . drawPath ( path ) # Draw preview pictures if sample . picture is None : continue pic_width = sample . picture . size () . width () if pic_width < scaled_dur : width = float ( pic_width ) pic = sample . picture else : width = scaled_dur pic = sample . picture . copy ( 0 , 0 , int ( scaled_dur ), 45 ) with qp . clip_path () as path : rect = core . RectF ( scaled_t , 52.5 , width , 45 ) path . addRoundedRect ( rect , 10 , 10 ) qp . drawPixmap ( int ( scaled_t ), int ( 52.5 ), int ( width ), 45 , pic ) # Clear clip path with qp . clip_path () as path : path . add_rect ( self . rect ()) # Draw pointer qp . set_color ( PEN_COLOR ) qp . set_brush ( PEN_COLOR ) qp . drawPolygon ( poly ) qp . drawLine ( line ) def mouseMoveEvent ( self , e ): self . _position = e . position () # if mouse is being pressed, update pointer if self . _clicking : x = self . _position . x () self . position_changed . emit ( x ) self . _check_selection ( x ) self . pointer_time_pos = x * self . get_scale () self . update () def mousePressEvent ( self , e ): if e . button () == QtCore . Qt . MouseButton . LeftButton : x = e . position () . x () self . position_changed . emit ( x ) self . pointer_time_pos = x * self . get_scale () self . _check_selection ( x ) self . update () self . _clicking = True # Set clicking check to true def mouseReleaseEvent ( self , e ): if e . button () == QtCore . Qt . MouseButton . LeftButton : self . _clicking = False # Set clicking check to false def enterEvent ( self , e ): self . _is_in = True def leaveEvent ( self , e ): self . _is_in = False self . update () def _check_selection ( self , x : int ): # Check if user clicked in video sample for sample in self . video_samples : if sample . start_pos < x < sample . end_pos : sample . color = gui . Color ( PEN_COLOR ) if self . selected_sample is not sample : self . selected_sample = sample self . selection_changed . emit ( sample ) else : sample . color = sample . def_color def get_scale ( self ) -> float : return self . duration / self . width () def set_background_color ( self , color : types . ColorType ): color = colors . get_color ( color ) self . background_color = color def set_text_color ( self , color : types . ColorType ): color = colors . get_color ( color ) self . text_color = color def set_text_font ( self , font : QtGui . QFont ): self . text_font = font","title":"Timeline"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.enterEvent","text":"enterEvent(self, event: PySide6.QtGui.QEnterEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def enterEvent ( self , e ): self . _is_in = True","title":"enterEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.leaveEvent","text":"leaveEvent(self, event: PySide6.QtCore.QEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def leaveEvent ( self , e ): self . _is_in = False self . update ()","title":"leaveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mouseMoveEvent","text":"mouseMoveEvent(self, event: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def mouseMoveEvent ( self , e ): self . _position = e . position () # if mouse is being pressed, update pointer if self . _clicking : x = self . _position . x () self . position_changed . emit ( x ) self . _check_selection ( x ) self . pointer_time_pos = x * self . get_scale () self . update ()","title":"mouseMoveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mousePressEvent","text":"mousePressEvent(self, event: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def mousePressEvent ( self , e ): if e . button () == QtCore . Qt . MouseButton . LeftButton : x = e . position () . x () self . position_changed . emit ( x ) self . pointer_time_pos = x * self . get_scale () self . _check_selection ( x ) self . update () self . _clicking = True # Set clicking check to true","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mouseReleaseEvent","text":"mouseReleaseEvent(self, event: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def mouseReleaseEvent ( self , e ): if e . button () == QtCore . Qt . MouseButton . LeftButton : self . _clicking = False # Set clicking check to false","title":"mouseReleaseEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.paintEvent","text":"paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/timeline.py def paintEvent ( self , event ): # Draw time scale = self . get_scale () with gui . Painter ( self ) as qp : qp . set_color ( self . text_color ) qp . setFont ( self . text_font ) qp . use_antialiasing () w = 0 while ( w := w + 100 ) <= self . width (): time_string = helpers . format_seconds ( w * scale ) rect = core . Rect ( w - 50 , 0 , 100 , 100 ) qp . drawText ( rect , constants . ALIGN_H_CENTER , time_string ) # Draw down line qp . set_pen ( color = PEN_COLOR , width = 5 ) qp . drawLine ( 0 , 40 , self . width (), 40 ) # Draw dash lines point = 0 qp . set_pen ( color = self . text_color ) qp . drawLine ( 0 , 40 , self . width (), 40 ) while point <= self . width (): y2 = 30 if point % 30 != 0 else 20 qp . drawLine ( 3 * point , 40 , 3 * point , y2 ) point += 10 if self . _position is not None and self . _is_in : qp . drawLine ( self . _position . x (), 0 , self . _position . x (), 40 ) poly = gui . Polygon () if self . _position is not None : val = self . pointer_time_pos / self . get_scale () line = core . Line ( val , 40 , val , self . height ()) poly . add_points (( val - 10 , 20 ), ( val + 10 , 20 ), ( val , 40 )) else : line = core . Line ( 0 , 0 , 0 , self . height ()) poly . add_points (( - 10 , 20 ), ( 10 , 20 ), ( 0 , 40 )) # Draw samples t = 0.0 for sample in self . video_samples : scaled_dur = sample . duration / scale scaled_t = t / scale t += sample . duration # Clear clip path with qp . clip_path () as path : rect = core . RectF ( scaled_t , 50 , scaled_dur , 200 ) path . addRoundedRect ( rect , 10 , 10 ) # Draw sample path = gui . PainterPath () qp . set_pen ( color = sample . color ) rect = core . RectF ( scaled_t , 50 , scaled_dur , 50 ) path . addRoundedRect ( rect , 10 , 10 ) sample . start_pos = scaled_t sample . end_pos = scaled_t + scaled_dur qp . fillPath ( path , sample . color ) qp . drawPath ( path ) # Draw preview pictures if sample . picture is None : continue pic_width = sample . picture . size () . width () if pic_width < scaled_dur : width = float ( pic_width ) pic = sample . picture else : width = scaled_dur pic = sample . picture . copy ( 0 , 0 , int ( scaled_dur ), 45 ) with qp . clip_path () as path : rect = core . RectF ( scaled_t , 52.5 , width , 45 ) path . addRoundedRect ( rect , 10 , 10 ) qp . drawPixmap ( int ( scaled_t ), int ( 52.5 ), int ( width ), 45 , pic ) # Clear clip path with qp . clip_path () as path : path . add_rect ( self . rect ()) # Draw pointer qp . set_color ( PEN_COLOR ) qp . set_brush ( PEN_COLOR ) qp . drawPolygon ( poly ) qp . drawLine ( line )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner","text":"The MIT License (MIT). Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"waitingspinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner","text":"Source code in prettyqt/custom_widgets/waitingspinner.py class BaseWaitingSpinner ( widgets . Widget ): def __init__ ( self , parent : QtWidgets . QWidget | None , modality : constants . ModalityStr = \"none\" , ): super () . __init__ ( parent = parent ) # WAS IN initialize() self . _color = self . get_palette () . get_color ( \"text\" ) self . _roundness = 100.0 self . _minimum_trail_opacity = 3.14159265358979323846 self . _trail_fade_percentage = 80.0 self . _revolutions_per_second = 1.57079632679489661923 self . _line_num = 20 self . _line_length = 10 self . _line_width = 2 self . _inner_radius = 10 self . _current_counter = 0 self . _timer = core . Timer ( self ) self . _timer . timeout . connect ( self . _rotate ) self . _update_size () self . _update_timer () self . hide () # END initialize() self . set_modality ( modality ) # self.setAttribute(QtCore.Qt.WA_TranslucentBackground) def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( style = \"none\" ) painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length ) rect = core . RectF ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) for i in range ( self . _line_num ): with painter . backup_state (): rotate_angle = 360 * i / self . _line_num painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . _current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . SizeMode . RelativeSize , ) def start ( self ): self . show () if not self . _timer . isActive (): self . _timer . start () self . _current_counter = 0 def stop ( self ): self . hide () if self . _timer . isActive (): self . _timer . stop () self . _current_counter = 0 def set_line_num ( self , lines : int ): self . _line_num = lines self . _current_counter = 0 self . _update_timer () def set_line_length ( self , length : int ): self . _line_length = length self . _update_size () def set_line_width ( self , width : int ): self . _line_width = width def set_inner_radius ( self , radius : int ): self . _inner_radius = radius self . _update_size () def color ( self ) -> gui . Color : return self . _color def roundness ( self ) -> float : return self . _roundness def minimum_trail_opacity ( self ) -> float : return self . _minimum_trail_opacity def trail_fade_percentage ( self ) -> float : return self . _trail_fade_percentage def revolutions_per_second ( self ) -> float : return self . _revolutions_per_second def line_num ( self ) -> int : return self . _line_num def line_length ( self ) -> int : return self . _line_length def line_width ( self ) -> int : return self . _line_width def inner_radius ( self ) -> int : return self . _inner_radius def is_spinning ( self ) -> bool : return self . _timer . isActive () def set_roundness ( self , roundness : float ): self . _roundness = max ( 0.0 , min ( 100.0 , roundness )) def set_color ( self , color : types . ColorType = \"black\" ): self . _color = colors . get_color ( color ) def set_revolutions_per_second ( self , _revolutions_per_second : float ): self . _revolutions_per_second = _revolutions_per_second self . _update_timer () def set_trail_fade_percentage ( self , trail : float ): self . _trail_fade_percentage = trail def set_minimum_trail_opacity ( self , minimum_trail_opacity : float ): self . _minimum_trail_opacity = minimum_trail_opacity def _rotate ( self ): self . _current_counter += 1 if self . _current_counter >= self . _line_num : self . _current_counter = 0 self . update () def _update_size ( self ): size = ( self . _inner_radius + self . _line_length ) * 2 self . setFixedSize ( size , size ) def _update_timer ( self ): divider = int ( self . _line_num * self . _revolutions_per_second ) self . _timer . setInterval ( 1000 // divider ) def linecount_distance_from_primary ( self , current : int , primary : int , total_lines : int ) -> int : distance = primary - current if distance < 0 : distance += total_lines return distance def _current_line_color ( self , count_distance : int , total_lines : int , fade_perc : float , min_opacity : float , color : gui . Color , ) -> gui . Color : color = gui . Color ( color ) if count_distance == 0 : return color min_alpha_f = min_opacity / 100 dist_threshold = int ( math . ceil (( total_lines - 1 ) * fade_perc / 100 )) if count_distance > dist_threshold : color . setAlphaF ( min_alpha_f ) else : alpha = color . alphaF () alpha_diff = alpha - min_alpha_f gradient = alpha_diff / ( dist_threshold + 1 ) result_alpha = alpha - gradient * count_distance # If alpha is out of bounds, clip it. result_alpha = min ( 1.0 , max ( 0.0 , result_alpha )) color . setAlphaF ( result_alpha ) return color","title":"BaseWaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner.paintEvent","text":"paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( style = \"none\" ) painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length ) rect = core . RectF ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) for i in range ( self . _line_num ): with painter . backup_state (): rotate_angle = 360 * i / self . _line_num painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . _current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . SizeMode . RelativeSize , )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner","text":"Source code in prettyqt/custom_widgets/waitingspinner.py class WaitingSpinner ( BaseWaitingSpinner ): def __init__ ( self , parent : QtWidgets . QWidget | None , center_on_parent : bool = True , disable_parent : bool = True , modality : constants . ModalityStr = \"none\" , additional_disabled = None , ): super () . __init__ ( parent = parent , modality = modality ) self . _center_on_parent = center_on_parent self . _disable_parent = disable_parent self . additional_disabled = additional_disabled if additional_disabled else [] def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event ) def start ( self ): self . _update_position () super () . start () if self . parentWidget and self . _disable_parent : self . parentWidget () . setEnabled ( False ) for item in self . additional_disabled : item . setEnabled ( False ) def stop ( self ): super () . stop () if self . parentWidget () and self . _disable_parent : self . parentWidget () . setEnabled ( True ) for item in self . additional_disabled : item . setEnabled ( True ) def _update_position ( self ): parent = self . parentWidget () if parent and self . _center_on_parent : self . move ( parent . width () // 2 - self . width () // 2 , parent . height () // 2 - self . height () // 2 , )","title":"WaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner.paintEvent","text":"paintEvent(self, event: PySide6.QtGui.QPaintEvent) -> None Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event )","title":"paintEvent()"},{"location":"api/gui.html","text":"gui module Gui module. Contains QtGui-based classes color Color ( QColor ) Source code in prettyqt/gui/color.py class Color ( QtGui . QColor ): def __init__ ( self , * args ): # PySide2 workaround if len ( args ) == 1 : if isinstance ( args [ 0 ], QtGui . QColor ): super () . __init__ ( args [ 0 ] . name ()) elif isinstance ( args [ 0 ], str ): super () . __init__ () self . set_color ( args [ 0 ]) else : super () . __init__ ( * args ) else : super () . __init__ ( * args ) def __repr__ ( self ): return ( f \" { type ( self ) . __name__ } ( { self . red () } , { self . green () } , \" f \" { self . blue () } , { self . alpha () } )\" ) def __str__ ( self ): return self . name () if self . alpha () == 255 else self . name ( self . NameFormat . HexArgb ) def __reduce__ ( self ): return type ( self ), ( self . red (), self . green (), self . blue (), self . alpha ()) def serialize_fields ( self ): return dict ( color = self . toString ()) def serialize ( self ) -> dict [ str , Any ]: return self . serialize_fields () def set_color ( self , color : str | tuple ): if isinstance ( color , str ): self . setNamedColor ( color ) else : self . setRgb ( * color ) @classmethod def from_text ( cls , text : str ) -> Color : \"\"\"Create a QColor from specified string.\"\"\" color = cls () if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color @classmethod def from_cmyk ( cls , c : float , m : float , y : float , k : float , a : float = 1.0 ) -> Color : return cls ( cls . fromCmykF ( c , m , y , k , a )) @classmethod def from_hsv ( cls , h : float , s : float , v : float , a : float = 1.0 ) -> Color : return cls ( cls . fromHsvF ( h , s , v , a )) @classmethod def interpolate_color ( cls , start : QtGui . QColor , end : QtGui . QColor , percent : int , colorspace : SpecStr | None = \"rgb\" , ) -> Color : \"\"\"Get an interpolated color value. Args: start: The start color. end: The end color. percent: Which value to get (0 - 100) colorspace: The desired interpolation color system, QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum) If None, start is used except when percent is 100. Return: The interpolated QColor, with the same spec as the given start color. \"\"\" if colorspace is None : if percent == 100 : return cls ( * end . getRgb ()) else : return cls ( * start . getRgb ()) if colorspace not in SPEC : raise InvalidParamError ( colorspace , SPEC ) out = cls () if colorspace == \"rgb\" : components = helpers . get_color_percentage ( start . getRgb (), end . getRgb (), percent # type: ignore ) out . setRgb ( * components ) elif colorspace == \"hsv\" : components = helpers . get_color_percentage ( start . getHsv (), end . getHsv (), percent # type: ignore ) out . setHsv ( * components ) elif colorspace == \"hsl\" : components = helpers . get_color_percentage ( start . getHsl (), end . getHsl (), percent # type: ignore ) out . setHsl ( * components ) else : raise ValueError ( \"Invalid colorspace!\" ) out = out . convertTo ( start . spec ()) return out def is_dark ( self ) -> bool : \"\"\"Check whether a color is 'dark'.\"\"\" return self . lightness () < 128 def get_name ( self , name_format : NameStr = \"hex_argb\" ) -> str : if name_format == \"svg_rgb\" : if not self . isValid (): return 'fill=\"\"' return f 'fill=\"rgb( { self . red () } , { self . green () } , { self . blue () } )\"' elif name_format == \"svg_argb\" : if not self . isValid (): return 'fill=\"\"' fill_str = f \"rgb( { self . red () } , { self . green () } , { self . blue () } )\" return f 'fill=\" { fill_str } \" fill-opacity=\" { self . alpha () } \"' elif name_format == \"qcss_argb\" : return f \"rgba( { self . red () } , { self . green () } , { self . blue () } , { self . alpha () } )\" elif name_format == \"qcss_rgb\" : return f \"rgb( { self . red () } , { self . green () } , { self . blue () } )\" else : return self . name ( NAME_FORMAT [ name_format ]) @deprecated ( reason = \"This method is deprecated, use Color.get_name instead.\" ) def to_qsscolor ( self ) -> str : \"\"\"Convert Color to a string that can be used in a QStyleSheet.\"\"\" return f \"rgba( { self . red () } , { self . green () } , { self . blue () } , { self . alpha () } )\" def as_qt ( self ) -> QtGui . QColor : return QtGui . QColor ( self ) def inverted ( self , invert_alpha : bool = False ) -> Color : return Color ( 255 - self . red (), 255 - self . green (), 255 - self . blue (), 255 - self . alpha () if invert_alpha else self . alpha (), ) @classmethod def drift_color ( cls , color : types . ColorAndBrushType , factor : int = 110 ): \"\"\"Return color that is lighter or darker than the base color. If base_color.lightness is higher than 128, the returned color is darker otherwise is is lighter. :param base_color: The base color to drift from ;:param factor: drift factor (%) :return A lighter or darker color. \"\"\" base_color = cls ( color ) if base_color . lightness () > 128 : return base_color . darker ( factor ) else : if base_color == Color ( \"#000000\" ): return cls . drift_color ( cls ( \"#101010\" ), factor + 20 ) else : return base_color . lighter ( factor + 10 ) drift_color ( color : types . ColorAndBrushType , factor : int = 110 ) classmethod Return color that is lighter or darker than the base color. If base_color.lightness is higher than 128, the returned color is darker otherwise is is lighter. :param base_color: The base color to drift from ;:param factor: drift factor (%) :return A lighter or darker color. Source code in prettyqt/gui/color.py @classmethod def drift_color ( cls , color : types . ColorAndBrushType , factor : int = 110 ): \"\"\"Return color that is lighter or darker than the base color. If base_color.lightness is higher than 128, the returned color is darker otherwise is is lighter. :param base_color: The base color to drift from ;:param factor: drift factor (%) :return A lighter or darker color. \"\"\" base_color = cls ( color ) if base_color . lightness () > 128 : return base_color . darker ( factor ) else : if base_color == Color ( \"#000000\" ): return cls . drift_color ( cls ( \"#101010\" ), factor + 20 ) else : return base_color . lighter ( factor + 10 ) from_text ( text : str ) -> Color classmethod Create a QColor from specified string. Source code in prettyqt/gui/color.py @classmethod def from_text ( cls , text : str ) -> Color : \"\"\"Create a QColor from specified string.\"\"\" color = cls () if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color interpolate_color ( start : QtGui . QColor , end : QtGui . QColor , percent : int , colorspace : SpecStr | None = 'rgb' ) -> Color classmethod Get an interpolated color value. Parameters: Name Type Description Default start QtGui.QColor The start color. required end QtGui.QColor The end color. required percent int Which value to get (0 - 100) required colorspace SpecStr | None The desired interpolation color system, QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum) If None, start is used except when percent is 100. 'rgb' Returns: Type Description Color The interpolated QColor, with the same spec as the given start color. Source code in prettyqt/gui/color.py @classmethod def interpolate_color ( cls , start : QtGui . QColor , end : QtGui . QColor , percent : int , colorspace : SpecStr | None = \"rgb\" , ) -> Color : \"\"\"Get an interpolated color value. Args: start: The start color. end: The end color. percent: Which value to get (0 - 100) colorspace: The desired interpolation color system, QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum) If None, start is used except when percent is 100. Return: The interpolated QColor, with the same spec as the given start color. \"\"\" if colorspace is None : if percent == 100 : return cls ( * end . getRgb ()) else : return cls ( * start . getRgb ()) if colorspace not in SPEC : raise InvalidParamError ( colorspace , SPEC ) out = cls () if colorspace == \"rgb\" : components = helpers . get_color_percentage ( start . getRgb (), end . getRgb (), percent # type: ignore ) out . setRgb ( * components ) elif colorspace == \"hsv\" : components = helpers . get_color_percentage ( start . getHsv (), end . getHsv (), percent # type: ignore ) out . setHsv ( * components ) elif colorspace == \"hsl\" : components = helpers . get_color_percentage ( start . getHsl (), end . getHsl (), percent # type: ignore ) out . setHsl ( * components ) else : raise ValueError ( \"Invalid colorspace!\" ) out = out . convertTo ( start . spec ()) return out is_dark ( self ) -> bool Check whether a color is 'dark'. Source code in prettyqt/gui/color.py def is_dark ( self ) -> bool : \"\"\"Check whether a color is 'dark'.\"\"\" return self . lightness () < 128 to_qsscolor ( self ) -> str Convert Color to a string that can be used in a QStyleSheet. Source code in prettyqt/gui/color.py @deprecated ( reason = \"This method is deprecated, use Color.get_name instead.\" ) def to_qsscolor ( self ) -> str : \"\"\"Convert Color to a string that can be used in a QStyleSheet.\"\"\" return f \"rgba( { self . red () } , { self . green () } , { self . blue () } , { self . alpha () } )\" colorspace ColorSpace ( QColorSpace ) Source code in prettyqt/gui/colorspace.py class ColorSpace ( QtGui . QColorSpace ): def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): super () . __init__ () core . DataStream . write_bytearray ( ba , self ) def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __bool__ ( self ): return self . isValid () def set_primaries ( self , primaries : PrimariesStr ): \"\"\"Set primaries. Args: primaries: primaries to use Raises: InvalidParamError: primaries do not exist \"\"\" if primaries not in PRIMARIES : raise InvalidParamError ( primaries , PRIMARIES ) self . setPrimaries ( PRIMARIES [ primaries ]) def get_primaries ( self ) -> PrimariesStr : \"\"\"Return current primaries. Returns: primaries \"\"\" return PRIMARIES . inverse [ self . primaries ()] def set_transfer_function ( self , fn : TransformFunctionStr , gamma : float = 0.0 ): \"\"\"Set transfer function. Args: fn: transfer function to use Raises: InvalidParamError: transfer function do not exist \"\"\" if fn not in TRANSFER_FUNCTION : raise InvalidParamError ( fn , TRANSFER_FUNCTION ) self . setTransferFunction ( TRANSFER_FUNCTION [ fn ], gamma ) def get_transfer_function ( self ) -> TransformFunctionStr : \"\"\"Return current transfer function. Returns: transfer function \"\"\" return TRANSFER_FUNCTION . inverse [ self . transferFunction ()] get_primaries ( self ) -> PrimariesStr Return current primaries. Returns: Type Description PrimariesStr primaries Source code in prettyqt/gui/colorspace.py def get_primaries ( self ) -> PrimariesStr : \"\"\"Return current primaries. Returns: primaries \"\"\" return PRIMARIES . inverse [ self . primaries ()] get_transfer_function ( self ) -> TransformFunctionStr Return current transfer function. Returns: Type Description TransformFunctionStr transfer function Source code in prettyqt/gui/colorspace.py def get_transfer_function ( self ) -> TransformFunctionStr : \"\"\"Return current transfer function. Returns: transfer function \"\"\" return TRANSFER_FUNCTION . inverse [ self . transferFunction ()] set_primaries ( self , primaries : PrimariesStr ) Set primaries. Parameters: Name Type Description Default primaries PrimariesStr primaries to use required Exceptions: Type Description InvalidParamError primaries do not exist Source code in prettyqt/gui/colorspace.py def set_primaries ( self , primaries : PrimariesStr ): \"\"\"Set primaries. Args: primaries: primaries to use Raises: InvalidParamError: primaries do not exist \"\"\" if primaries not in PRIMARIES : raise InvalidParamError ( primaries , PRIMARIES ) self . setPrimaries ( PRIMARIES [ primaries ]) set_transfer_function ( self , fn : TransformFunctionStr , gamma : float = 0.0 ) Set transfer function. Parameters: Name Type Description Default fn TransformFunctionStr transfer function to use required Exceptions: Type Description InvalidParamError transfer function do not exist Source code in prettyqt/gui/colorspace.py def set_transfer_function ( self , fn : TransformFunctionStr , gamma : float = 0.0 ): \"\"\"Set transfer function. Args: fn: transfer function to use Raises: InvalidParamError: transfer function do not exist \"\"\" if fn not in TRANSFER_FUNCTION : raise InvalidParamError ( fn , TRANSFER_FUNCTION ) self . setTransferFunction ( TRANSFER_FUNCTION [ fn ], gamma ) cursor Cursor ( QCursor ) Source code in prettyqt/gui/cursor.py class Cursor ( QtGui . QCursor ): def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): super () . __init__ () core . DataStream . write_bytearray ( ba , self ) def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def serialize_fields ( self ) -> dict [ str , Any ]: return dict ( shape = self . get_shape ()) def set_shape ( self , shape : constants . CursorShapeStr ): \"\"\"Set cursor shape. Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in constants . CURSOR_SHAPE : raise InvalidParamError ( shape , constants . CURSOR_SHAPE ) self . setShape ( constants . CURSOR_SHAPE [ shape ]) def get_shape ( self ) -> constants . CursorShapeStr : \"\"\"Return current cursor shape. Returns: cursor shape \"\"\" return constants . CURSOR_SHAPE . inverse [ self . shape ()] @classmethod def get_position ( cls ) -> core . Point : return core . Point ( cls . pos ()) get_shape ( self ) -> constants . CursorShapeStr Return current cursor shape. Returns: Type Description constants.CursorShapeStr cursor shape Source code in prettyqt/gui/cursor.py def get_shape ( self ) -> constants . CursorShapeStr : \"\"\"Return current cursor shape. Returns: cursor shape \"\"\" return constants . CURSOR_SHAPE . inverse [ self . shape ()] set_shape ( self , shape : constants . CursorShapeStr ) Set cursor shape. Parameters: Name Type Description Default shape constants.CursorShapeStr shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/gui/cursor.py def set_shape ( self , shape : constants . CursorShapeStr ): \"\"\"Set cursor shape. Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in constants . CURSOR_SHAPE : raise InvalidParamError ( shape , constants . CURSOR_SHAPE ) self . setShape ( constants . CURSOR_SHAPE [ shape ]) font Font ( PrettyPrinter , QFont ) Source code in prettyqt/gui/font.py class Font ( prettyprinter . PrettyPrinter , QtGui . QFont ): def __repr__ ( self ): return ( f \" { type ( self ) . __name__ } ( { self . family () !r} , { self . pointSize () } , \" f \" { self . weight () } , { self . italic () } )\" ) def __getstate__ ( self ): return dict ( family = self . family (), pointsize = self . pointSize (), weight = self . weight (), italic = self . italic (), ) def __setstate__ ( self , state ): self . setFamily ( state [ \"family\" ]) if state [ \"pointsize\" ] > - 1 : self . setPointSize ( state [ \"pointsize\" ]) self . setWeight ( state [ \"weight\" ]) self . setItalic ( state [ \"italic\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def serialize ( self ) -> dict [ str , Any ]: return self . __getstate__ () @property def metrics ( self ): return gui . FontMetrics ( self ) def set_size ( self , size : int ): self . setPointSize ( size ) @classmethod def mono ( cls , size = 8 ): return cls ( \"Consolas\" , size ) # font.setStyleHint() def set_style_hint ( self , hint : StyleHintStr ): \"\"\"Set the style hint. Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ]) def set_weight ( self , weight : WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHT : raise InvalidParamError ( weight , WEIGHT ) self . setWeight ( WEIGHT [ weight ]) def get_weight ( self ) -> WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return WEIGHT . inverse [ self . weight ()] def set_capitalization ( self , capitalization : CapitalizationStr ): \"\"\"Set the font capitalization. Args: capitalization: font capitalization Raises: InvalidParamError: invalid font capitalization \"\"\" if capitalization not in CAPITALIZATION : raise InvalidParamError ( capitalization , CAPITALIZATION ) self . setCapitalization ( CAPITALIZATION [ capitalization ]) def get_capitalization ( self ) -> CapitalizationStr : \"\"\"Get current font capitalization. Returns: current font capitalization \"\"\" return CAPITALIZATION . inverse [ self . capitalization ()] def set_hinting_preference ( self , preference : HintingPreferenceStr ): \"\"\"Set the hinting preference. Args: preference: hinting preference Raises: InvalidParamError: invalid hinting preference \"\"\" if preference not in HINTING_PREFERENCE : raise InvalidParamError ( preference , HINTING_PREFERENCE ) self . setHintingPreference ( HINTING_PREFERENCE [ preference ]) def get_hinting_preference ( self ) -> HintingPreferenceStr : \"\"\"Get current hinting preference. Returns: current hinting preference \"\"\" return HINTING_PREFERENCE . inverse [ self . hintingPreference ()] def set_letter_spacing ( self , typ : SpacingTypeStr , spacing : float ): \"\"\"Set the letter spacing. Args: typ: letter spacing type spacing: spacing Raises: InvalidParamError: invalid letter spacing type \"\"\" if typ not in SPACING_TYPE : raise InvalidParamError ( typ , SPACING_TYPE ) self . setLetterSpacing ( SPACING_TYPE [ typ ], spacing ) def get_letter_spacing_type ( self ) -> SpacingTypeStr : \"\"\"Get current letter spacing type. Returns: current letter spacing type \"\"\" return SPACING_TYPE . inverse [ self . letterSpacingType ()] def set_style ( self , style : StyleStr ): \"\"\"Set the font style. Args: style: font style Raises: InvalidParamError: invalid font style \"\"\" if style not in STYLE : raise InvalidParamError ( style , STYLE ) self . setStyle ( STYLE [ style ]) def get_style ( self ) -> StyleStr : \"\"\"Get current font style. Returns: current font style \"\"\" return STYLE . inverse [ self . style ()] def set_family ( self , family : str , fallback : str | None = None ): \"\"\"Set the font family. Args: family: font family fallback: fallback font family \"\"\" self . setFamily ( family ) font_info = gui . FontInfo ( self ) if fallback is not None and font_info . family () != family : self . setFamily ( fallback ) get_capitalization ( self ) -> CapitalizationStr Get current font capitalization. Returns: Type Description CapitalizationStr current font capitalization Source code in prettyqt/gui/font.py def get_capitalization ( self ) -> CapitalizationStr : \"\"\"Get current font capitalization. Returns: current font capitalization \"\"\" return CAPITALIZATION . inverse [ self . capitalization ()] get_hinting_preference ( self ) -> HintingPreferenceStr Get current hinting preference. Returns: Type Description HintingPreferenceStr current hinting preference Source code in prettyqt/gui/font.py def get_hinting_preference ( self ) -> HintingPreferenceStr : \"\"\"Get current hinting preference. Returns: current hinting preference \"\"\" return HINTING_PREFERENCE . inverse [ self . hintingPreference ()] get_letter_spacing_type ( self ) -> SpacingTypeStr Get current letter spacing type. Returns: Type Description SpacingTypeStr current letter spacing type Source code in prettyqt/gui/font.py def get_letter_spacing_type ( self ) -> SpacingTypeStr : \"\"\"Get current letter spacing type. Returns: current letter spacing type \"\"\" return SPACING_TYPE . inverse [ self . letterSpacingType ()] get_style ( self ) -> StyleStr Get current font style. Returns: Type Description StyleStr current font style Source code in prettyqt/gui/font.py def get_style ( self ) -> StyleStr : \"\"\"Get current font style. Returns: current font style \"\"\" return STYLE . inverse [ self . style ()] get_weight ( self ) -> WeightStr Get current font weight. Returns: Type Description WeightStr current font weight Source code in prettyqt/gui/font.py def get_weight ( self ) -> WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return WEIGHT . inverse [ self . weight ()] set_capitalization ( self , capitalization : CapitalizationStr ) Set the font capitalization. Parameters: Name Type Description Default capitalization CapitalizationStr font capitalization required Exceptions: Type Description InvalidParamError invalid font capitalization Source code in prettyqt/gui/font.py def set_capitalization ( self , capitalization : CapitalizationStr ): \"\"\"Set the font capitalization. Args: capitalization: font capitalization Raises: InvalidParamError: invalid font capitalization \"\"\" if capitalization not in CAPITALIZATION : raise InvalidParamError ( capitalization , CAPITALIZATION ) self . setCapitalization ( CAPITALIZATION [ capitalization ]) set_family ( self , family : str , fallback : str | None = None ) Set the font family. Parameters: Name Type Description Default family str font family required fallback str | None fallback font family None Source code in prettyqt/gui/font.py def set_family ( self , family : str , fallback : str | None = None ): \"\"\"Set the font family. Args: family: font family fallback: fallback font family \"\"\" self . setFamily ( family ) font_info = gui . FontInfo ( self ) if fallback is not None and font_info . family () != family : self . setFamily ( fallback ) set_hinting_preference ( self , preference : HintingPreferenceStr ) Set the hinting preference. Parameters: Name Type Description Default preference HintingPreferenceStr hinting preference required Exceptions: Type Description InvalidParamError invalid hinting preference Source code in prettyqt/gui/font.py def set_hinting_preference ( self , preference : HintingPreferenceStr ): \"\"\"Set the hinting preference. Args: preference: hinting preference Raises: InvalidParamError: invalid hinting preference \"\"\" if preference not in HINTING_PREFERENCE : raise InvalidParamError ( preference , HINTING_PREFERENCE ) self . setHintingPreference ( HINTING_PREFERENCE [ preference ]) set_letter_spacing ( self , typ : SpacingTypeStr , spacing : float ) Set the letter spacing. Parameters: Name Type Description Default typ SpacingTypeStr letter spacing type required spacing float spacing required Exceptions: Type Description InvalidParamError invalid letter spacing type Source code in prettyqt/gui/font.py def set_letter_spacing ( self , typ : SpacingTypeStr , spacing : float ): \"\"\"Set the letter spacing. Args: typ: letter spacing type spacing: spacing Raises: InvalidParamError: invalid letter spacing type \"\"\" if typ not in SPACING_TYPE : raise InvalidParamError ( typ , SPACING_TYPE ) self . setLetterSpacing ( SPACING_TYPE [ typ ], spacing ) set_style ( self , style : StyleStr ) Set the font style. Parameters: Name Type Description Default style StyleStr font style required Exceptions: Type Description InvalidParamError invalid font style Source code in prettyqt/gui/font.py def set_style ( self , style : StyleStr ): \"\"\"Set the font style. Args: style: font style Raises: InvalidParamError: invalid font style \"\"\" if style not in STYLE : raise InvalidParamError ( style , STYLE ) self . setStyle ( STYLE [ style ]) set_style_hint ( self , hint : StyleHintStr ) Set the style hint. Parameters: Name Type Description Default hint StyleHintStr style hint required Exceptions: Type Description InvalidParamError invalid style hint Source code in prettyqt/gui/font.py def set_style_hint ( self , hint : StyleHintStr ): \"\"\"Set the style hint. Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ]) set_weight ( self , weight : WeightStr ) Set the font weight. Parameters: Name Type Description Default weight WeightStr font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/font.py def set_weight ( self , weight : WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHT : raise InvalidParamError ( weight , WEIGHT ) self . setWeight ( WEIGHT [ weight ]) gradient Gradient ( PrettyPrinter , QGradient ) Source code in prettyqt/gui/gradient.py class Gradient ( prettyprinter . PrettyPrinter , QtGui . QGradient ): def __setitem__ ( self , key : float , value ): self . setColorAt ( key , value ) def serialize_fields ( self ): return dict ( coordinate_mode = self . get_coordinate_mode (), spread = self . get_spread (), stops = self . get_stops (), ) def serialize ( self ) -> dict [ str , Any ]: return self . serialize_fields () def set_coordinate_mode ( self , mode : CoordinateModeStr ): \"\"\"Set the coordinate mode. Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODE : raise InvalidParamError ( mode , COORDINATE_MODE ) self . setCoordinateMode ( COORDINATE_MODE [ mode ]) def get_coordinate_mode ( self ) -> CoordinateModeStr : \"\"\"Return current coordinate mode. Returns: coordinate mode \"\"\" return COORDINATE_MODE . inverse [ self . coordinateMode ()] def set_spread ( self , method : SpreadStr ): \"\"\"Set the spread method. Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREAD : raise InvalidParamError ( method , SPREAD ) self . setSpread ( SPREAD [ method ]) def get_spread ( self ) -> SpreadStr : \"\"\"Return current spread method. Returns: spread method \"\"\" return SPREAD . inverse [ self . spread ()] def get_type ( self ) -> TypeStr : \"\"\"Return current gradient type. Returns: gradient type \"\"\" return TYPE . inverse [ self . type ()] def get_stops ( self ) -> list [ tuple [ float , gui . Color ]]: return [( i , gui . Color ( j )) for ( i , j ) in self . stops ()] get_coordinate_mode ( self ) -> CoordinateModeStr Return current coordinate mode. Returns: Type Description CoordinateModeStr coordinate mode Source code in prettyqt/gui/gradient.py def get_coordinate_mode ( self ) -> CoordinateModeStr : \"\"\"Return current coordinate mode. Returns: coordinate mode \"\"\" return COORDINATE_MODE . inverse [ self . coordinateMode ()] get_spread ( self ) -> SpreadStr Return current spread method. Returns: Type Description SpreadStr spread method Source code in prettyqt/gui/gradient.py def get_spread ( self ) -> SpreadStr : \"\"\"Return current spread method. Returns: spread method \"\"\" return SPREAD . inverse [ self . spread ()] get_type ( self ) -> TypeStr Return current gradient type. Returns: Type Description TypeStr gradient type Source code in prettyqt/gui/gradient.py def get_type ( self ) -> TypeStr : \"\"\"Return current gradient type. Returns: gradient type \"\"\" return TYPE . inverse [ self . type ()] set_coordinate_mode ( self , mode : CoordinateModeStr ) Set the coordinate mode. Parameters: Name Type Description Default mode CoordinateModeStr coordinate mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/gradient.py def set_coordinate_mode ( self , mode : CoordinateModeStr ): \"\"\"Set the coordinate mode. Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODE : raise InvalidParamError ( mode , COORDINATE_MODE ) self . setCoordinateMode ( COORDINATE_MODE [ mode ]) set_spread ( self , method : SpreadStr ) Set the spread method. Parameters: Name Type Description Default method SpreadStr spread method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/gui/gradient.py def set_spread ( self , method : SpreadStr ): \"\"\"Set the spread method. Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREAD : raise InvalidParamError ( method , SPREAD ) self . setSpread ( SPREAD [ method ]) guiapplication GuiApplication ( QGuiApplication ) Source code in prettyqt/gui/guiapplication.py class GuiApplication ( QtGui . QGuiApplication ): def serialize_fields ( self ): return dict ( icon = self . get_icon ()) @classmethod @contextlib . contextmanager def override_cursor ( cls , cursor : constants . CursorShapeStr ): cls . set_override_cursor ( cursor ) yield cursor cls . restore_override_cursor () @classmethod def set_override_cursor ( cls , cursor : constants . CursorShapeStr ): crs = gui . Cursor ( constants . CURSOR_SHAPE [ cursor ]) cls . setOverrideCursor ( crs ) @classmethod def restore_override_cursor ( cls ): cls . restoreOverrideCursor () @classmethod def get_clipboard ( cls ) -> gui . Clipboard : return gui . Clipboard ( cls . clipboard ()) @classmethod @contextlib . contextmanager def edit_palette ( cls ) -> Iterator [ gui . Palette ]: palette = gui . Palette ( cls . palette ()) yield palette cls . setPalette ( palette ) def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ]) def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()] @classmethod def set_high_dpi_scale_factor_rounding_policy ( cls , policy : constants . HighDpiScaleFactorRoundingPolicyStr ): \"\"\"Set high dpi scale factor rounding policy. Args: policy: rounding policy Raises: InvalidParamError: rounding policy does not exist \"\"\" if policy not in constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY : raise InvalidParamError ( policy , constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY ) cls . setHighDpiScaleFactorRoundingPolicy ( constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY [ policy ] ) @classmethod def get_high_dpi_scale_factor_rounding_policy ( cls , ) -> constants . HighDpiScaleFactorRoundingPolicyStr : \"\"\"Get the current high dpi scale factor rounding policy. Returns: rounding policy \"\"\" return constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY . inverse [ cls . highDpiScaleFactorRoundingPolicy () ] @classmethod def get_application_state ( cls ) -> list [ constants . ApplicationStateStr ]: \"\"\"Get the current application state. Returns: application state \"\"\" return [ k for k , v in constants . APPLICATION_STATES . items () if v & cls . applicationState () # type: ignore ] def get_primary_screen ( self ) -> gui . Screen : return gui . Screen ( self . primaryScreen ()) def get_screen_at ( self , point : types . PointType ) -> gui . Screen : if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) return gui . Screen ( self . screenAt ( point )) def get_screens ( self ) -> list [ gui . Screen ]: return [ gui . Screen ( i ) for i in self . screens ()] @classmethod def get_input_method ( cls ) -> gui . InputMethod : return gui . InputMethod ( cls . inputMethod ()) @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Mode . Clipboard ) cb . setText ( text , mode = cb . Mode . Clipboard ) @classmethod def get_font ( cls ) -> gui . Font : return gui . Font ( cls . font ()) def set_icon ( self , icon : types . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) def get_icon ( self ) -> gui . Icon | None : icon = self . windowIcon () if icon . isNull (): return None return gui . Icon ( self . windowIcon ()) @classmethod def set_palette ( cls , palette : constants . ThemeStr | QtGui . QPalette ): if palette == \"default\" : pal = gui . Palette () elif palette == \"dark\" : pal = gui . Palette . create_dark_palette () else : pal = palette cls . setPalette ( pal ) @classmethod def get_palette ( cls ) -> gui . Palette : return gui . Palette ( cls . palette ()) copy_to_clipboard ( text : str ) classmethod Sets clipboard to supplied text. Source code in prettyqt/gui/guiapplication.py @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Mode . Clipboard ) cb . setText ( text , mode = cb . Mode . Clipboard ) get_application_state () -> list [ constants . ApplicationStateStr ] classmethod Get the current application state. Returns: Type Description list[constants.ApplicationStateStr] application state Source code in prettyqt/gui/guiapplication.py @classmethod def get_application_state ( cls ) -> list [ constants . ApplicationStateStr ]: \"\"\"Get the current application state. Returns: application state \"\"\" return [ k for k , v in constants . APPLICATION_STATES . items () if v & cls . applicationState () # type: ignore ] get_high_dpi_scale_factor_rounding_policy () -> constants . HighDpiScaleFactorRoundingPolicyStr classmethod Get the current high dpi scale factor rounding policy. Returns: Type Description constants.HighDpiScaleFactorRoundingPolicyStr rounding policy Source code in prettyqt/gui/guiapplication.py @classmethod def get_high_dpi_scale_factor_rounding_policy ( cls , ) -> constants . HighDpiScaleFactorRoundingPolicyStr : \"\"\"Get the current high dpi scale factor rounding policy. Returns: rounding policy \"\"\" return constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY . inverse [ cls . highDpiScaleFactorRoundingPolicy () ] get_layout_direction ( self ) -> constants . LayoutDirectionStr Get the current layout direction. Returns: Type Description constants.LayoutDirectionStr layout direction Source code in prettyqt/gui/guiapplication.py def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()] set_high_dpi_scale_factor_rounding_policy ( policy : constants . HighDpiScaleFactorRoundingPolicyStr ) classmethod Set high dpi scale factor rounding policy. Parameters: Name Type Description Default policy constants.HighDpiScaleFactorRoundingPolicyStr rounding policy required Exceptions: Type Description InvalidParamError rounding policy does not exist Source code in prettyqt/gui/guiapplication.py @classmethod def set_high_dpi_scale_factor_rounding_policy ( cls , policy : constants . HighDpiScaleFactorRoundingPolicyStr ): \"\"\"Set high dpi scale factor rounding policy. Args: policy: rounding policy Raises: InvalidParamError: rounding policy does not exist \"\"\" if policy not in constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY : raise InvalidParamError ( policy , constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY ) cls . setHighDpiScaleFactorRoundingPolicy ( constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY [ policy ] ) set_icon ( self , icon : types . IconType ) Set the default window icon. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/gui/guiapplication.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) set_layout_direction ( self , direction : constants . LayoutDirectionStr ) Set layout direction. Parameters: Name Type Description Default direction constants.LayoutDirectionStr layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/guiapplication.py def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ]) icon Icon ( QIcon ) Source code in prettyqt/gui/icon.py class Icon ( QtGui . QIcon ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def __bool__ ( self ): return not self . isNull () def __getstate__ ( self ): pixmap = self . pixmap ( 256 , 256 ) return bytes ( core . DataStream . create_bytearray ( pixmap )) def __setstate__ ( self , ba ): px = QtGui . QPixmap () core . DataStream . write_bytearray ( ba , px ) super () . __init__ ( px ) @classmethod def for_color ( cls , color_str : str ) -> Icon : color = gui . Color . from_text ( color_str ) if not color . isValid (): raise TypeError () bitmap = gui . Pixmap ( 16 , 16 ) bitmap . fill ( color ) return cls ( bitmap ) @classmethod def from_char ( cls , char : str , background = \"black\" , color = \"white\" ): \"\"\"Create a QIcon with a given character.\"\"\" icon = cls () for size in ( 16 , 32 , 64 ): px = gui . Pixmap . create_char ( char , background = background , color = color , size = size ) icon . addPixmap ( px ) return icon @classmethod def from_image ( cls , image : QtGui . QImage ): return cls ( gui . Pixmap . fromImage ( image )) def get_available_sizes ( self , mode : ModeStr = \"normal\" , state : StateStr = \"off\" ) -> list [ core . Size ]: if mode not in MODE : raise InvalidParamError ( mode , MODE ) if state not in STATE : raise InvalidParamError ( state , STATE ) return [ core . Size ( i ) for i in self . availableSizes ( MODE [ mode ], STATE [ state ])] def add_pixmap ( self , data : QtCore . QByteArray | QtGui . QPixmap | bytes , mode : ModeStr = \"normal\" , state : StateStr = \"off\" , ): if mode not in MODE : raise InvalidParamError ( mode , MODE ) if state not in STATE : raise InvalidParamError ( state , STATE ) if isinstance ( data , bytes ): data = QtCore . QByteArray ( data ) if isinstance ( data , QtCore . QByteArray ): pixmap = QtGui . QPixmap () pixmap . loadFromData ( data ) else : pixmap = data self . addPixmap ( pixmap , MODE [ mode ], STATE [ state ]) def get_pixmap ( self , size : types . SizeType | int , mode : ModeStr = \"normal\" , state : StateStr = \"off\" , ) -> QtGui . QPixmap : if mode not in MODE : raise InvalidParamError ( mode , MODE ) if state not in STATE : raise InvalidParamError ( state , STATE ) if isinstance ( size , tuple ): size = core . Size ( * size ) elif isinstance ( size , int ): size = core . Size ( size , size ) return self . pixmap ( size , MODE [ mode ], STATE [ state ]) def get_actual_size ( self , size : types . SizeType | int , mode : ModeStr = \"normal\" , state : StateStr = \"off\" , ) -> core . Size : if mode not in MODE : raise InvalidParamError ( mode , MODE ) if state not in STATE : raise InvalidParamError ( state , STATE ) if isinstance ( size , tuple ): size = core . Size ( * size ) elif isinstance ( size , int ): size = core . Size ( size , size ) return core . Size ( self . actualSize ( size , MODE [ mode ], STATE [ state ])) from_char ( char : str , background = 'black' , color = 'white' ) classmethod Create a QIcon with a given character. Source code in prettyqt/gui/icon.py @classmethod def from_char ( cls , char : str , background = \"black\" , color = \"white\" ): \"\"\"Create a QIcon with a given character.\"\"\" icon = cls () for size in ( 16 , 32 , 64 ): px = gui . Pixmap . create_char ( char , background = background , color = color , size = size ) icon . addPixmap ( px ) return icon imageiohandler ImageIOHandler ( QImageIOHandler ) Source code in prettyqt/gui/imageiohandler.py class ImageIOHandler ( mod ): def __getitem__ ( self , key : ImageOptionStr ) -> types . Variant : return self . get_option ( key ) def __setitem__ ( self , key : ImageOptionStr , value : types . Variant ): self . set_option ( key , value ) def get_format ( self ) -> str : return bytes ( self . format ()) . decode () def set_option ( self , option : ImageOptionStr , value : types . Variant ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) self . setOption ( IMAGE_OPTION [ option ], value ) def get_option ( self , option : ImageOptionStr ) -> types . Variant : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . option ( IMAGE_OPTION [ option ]) def supports_option ( self , option : ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . supportsOption ( IMAGE_OPTION [ option ]) get_option ( self , option : ImageOptionStr ) -> types . Variant Return the value assigned to option. Parameters: Name Type Description Default option ImageOptionStr option to get required Returns: Type Description types.Variant option Source code in prettyqt/gui/imageiohandler.py def get_option ( self , option : ImageOptionStr ) -> types . Variant : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . option ( IMAGE_OPTION [ option ]) set_option ( self , option : ImageOptionStr , value : types . Variant ) Set option to given value. Parameters: Name Type Description Default option ImageOptionStr option to use required value types.Variant value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/gui/imageiohandler.py def set_option ( self , option : ImageOptionStr , value : types . Variant ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) self . setOption ( IMAGE_OPTION [ option ], value ) supports_option ( self , option : ImageOptionStr ) -> bool Return whether the image handler supports given option. Parameters: Name Type Description Default option ImageOptionStr option to check required Returns: Type Description bool option Source code in prettyqt/gui/imageiohandler.py def supports_option ( self , option : ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . supportsOption ( IMAGE_OPTION [ option ]) imagereader ImageReader ( QImageReader ) Source code in prettyqt/gui/imagereader.py class ImageReader ( QtGui . QImageReader ): def __getitem__ ( self , key : str ) -> str : return self . text ( key ) def get_error ( self ) -> ImageReaderErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_READER_ERROR . inverse [ self . error ()] def get_background_color ( self ) -> gui . Color : return gui . Color ( self . backgroundColor ()) def get_clip_rect ( self ) -> core . Rect : return core . Rect ( self . clipRect ()) def get_current_image_rect ( self ) -> core . Rect : return core . Rect ( self . currentImageRect ()) def get_scaled_clip_rect ( self ) -> core . Rect : return core . Rect ( self . scaledClipRect ()) def get_size ( self ) -> core . Size : return core . Size ( self . size ()) def get_scaled_size ( self ) -> core . Size : return core . Size ( self . scaledSize ()) def get_format ( self ) -> str : return bytes ( self . format ()) . decode () def get_subtype ( self ) -> str : return bytes ( self . subType ()) . decode () def get_supported_subtypes ( self ) -> list [ str ]: return [ bytes ( i ) . decode () for i in self . supportedSubTypes ()] def set_format ( self , fmt : types . ByteArrayType ): if isinstance ( fmt , str ): fmt = fmt . encode () if isinstance ( fmt , bytes ): fmt = QtCore . QByteArray ( fmt ) self . setFormat ( fmt ) def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()] def read_image ( self ) -> gui . Image : return gui . Image ( self . read ()) def supports_option ( self , option : gui . imageiohandler . ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in gui . imageiohandler . IMAGE_OPTION : raise InvalidParamError ( option , gui . imageiohandler . IMAGE_OPTION ) return self . supportsOption ( gui . imageiohandler . IMAGE_OPTION [ option ]) @staticmethod def get_image_format ( obj : str | QtCore . QIODevice ) -> str : return bytes ( ImageReader . imageFormat ( obj )) . decode () @staticmethod def get_supported_image_formats () -> list [ str ]: return [ bytes ( i ) . decode () for i in ImageReader . supportedImageFormats ()] @staticmethod def get_supported_mime_types () -> list [ str ]: return [ bytes ( i ) . decode () for i in ImageReader . supportedMimeTypes ()] @staticmethod def get_image_formats_for_mime_type ( typ : types . ByteArrayType ) -> list [ str ]: if isinstance ( typ , str ): typ = typ . encode () if isinstance ( typ , bytes ): typ = QtCore . QByteArray ( typ ) return [ bytes ( i ) . decode () for i in ImageReader . imageFormatsForMimeType ( typ )] get_error ( self ) -> ImageReaderErrorStr Return error type. Returns: Type Description ImageReaderErrorStr error type Source code in prettyqt/gui/imagereader.py def get_error ( self ) -> ImageReaderErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_READER_ERROR . inverse [ self . error ()] get_transformation ( self ) -> gui . imageiohandler . TransformationStr Return the transformation and orientation the image has been set to. Returns: Type Description gui.imageiohandler.TransformationStr transformation Source code in prettyqt/gui/imagereader.py def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()] supports_option ( self , option : gui . imageiohandler . ImageOptionStr ) -> bool Return whether the image handler supports given option. Parameters: Name Type Description Default option gui.imageiohandler.ImageOptionStr option to check required Returns: Type Description bool option Source code in prettyqt/gui/imagereader.py def supports_option ( self , option : gui . imageiohandler . ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in gui . imageiohandler . IMAGE_OPTION : raise InvalidParamError ( option , gui . imageiohandler . IMAGE_OPTION ) return self . supportsOption ( gui . imageiohandler . IMAGE_OPTION [ option ]) imagewriter ImageWriter ( QImageWriter ) Source code in prettyqt/gui/imagewriter.py class ImageWriter ( QtGui . QImageWriter ): def __setitem__ ( self , key : str , val : str ): self . setText ( key , val ) def get_error ( self ) -> ImageWriterErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_WRITER_ERROR . inverse [ self . error ()] def get_format ( self ) -> str : return bytes ( self . format ()) . decode () def get_subtype ( self ) -> str : return bytes ( self . subType ()) . decode () def get_supported_image_formats ( self ) -> list [ str ]: return [ bytes ( i ) . decode () for i in self . supportedImageFormats ()] def get_supported_subtypes ( self ) -> list [ str ]: return [ bytes ( i ) . decode () for i in self . supportedSubTypes ()] def set_subtype ( self , subtype : types . ByteArrayType ): if isinstance ( subtype , str ): subtype = subtype . encode () if isinstance ( subtype , bytes ): subtype = QtCore . QByteArray ( subtype ) self . setSubType ( subtype ) def set_format ( self , fmt : types . ByteArrayType ): if isinstance ( fmt , str ): fmt = fmt . encode () if isinstance ( fmt , bytes ): fmt = QtCore . QByteArray ( fmt ) self . setFormat ( fmt ) def set_transformation ( self , origin : gui . imageiohandler . TransformationStr ): \"\"\"Set the image transformations metadata including orientation. Args: origin: transformation to use Raises: InvalidParamError: transformation does not exist \"\"\" if origin not in gui . imageiohandler . TRANSFORMATION : raise InvalidParamError ( origin , gui . imageiohandler . TRANSFORMATION ) self . setTransformation ( gui . imageiohandler . TRANSFORMATION [ origin ]) def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()] get_error ( self ) -> ImageWriterErrorStr Return error type. Returns: Type Description ImageWriterErrorStr error type Source code in prettyqt/gui/imagewriter.py def get_error ( self ) -> ImageWriterErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_WRITER_ERROR . inverse [ self . error ()] get_transformation ( self ) -> gui . imageiohandler . TransformationStr Return the transformation and orientation the image has been set to. Returns: Type Description gui.imageiohandler.TransformationStr transformation Source code in prettyqt/gui/imagewriter.py def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()] set_transformation ( self , origin : gui . imageiohandler . TransformationStr ) Set the image transformations metadata including orientation. Parameters: Name Type Description Default origin gui.imageiohandler.TransformationStr transformation to use required Exceptions: Type Description InvalidParamError transformation does not exist Source code in prettyqt/gui/imagewriter.py def set_transformation ( self , origin : gui . imageiohandler . TransformationStr ): \"\"\"Set the image transformations metadata including orientation. Args: origin: transformation to use Raises: InvalidParamError: transformation does not exist \"\"\" if origin not in gui . imageiohandler . TRANSFORMATION : raise InvalidParamError ( origin , gui . imageiohandler . TRANSFORMATION ) self . setTransformation ( gui . imageiohandler . TRANSFORMATION [ origin ]) movie Movie ( QMovie ) Source code in prettyqt/gui/movie.py class Movie ( QtGui . QMovie ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . fileName () !r} , { self . get_format () !r} )\" def serialize_fields ( self ): return dict ( speed = self . speed (), cache_mode = self . get_cache_mode (), scaled_size = self . scaledSize (), background_color = self . backgroundColor (), ) def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set cache mode. Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODE : raise InvalidParamError ( mode , CACHE_MODE ) self . setCacheMode ( CACHE_MODE [ mode ]) def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Get the current cache mode. Returns: cache mode \"\"\" return CACHE_MODE . inverse [ self . cacheMode ()] def get_state ( self ) -> MovieStateStr : \"\"\"Get the current state. Returns: state \"\"\" return MOVIE_STATE . inverse [ self . state ()] def get_format ( self ) -> bytes : return bytes ( self . format ()) @classmethod def get_supported_formats ( cls ) -> list [ str ]: return [ bytes ( i ) . decode () for i in cls . supportedFormats ()] get_cache_mode ( self ) -> CacheModeStr Get the current cache mode. Returns: Type Description CacheModeStr cache mode Source code in prettyqt/gui/movie.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Get the current cache mode. Returns: cache mode \"\"\" return CACHE_MODE . inverse [ self . cacheMode ()] get_state ( self ) -> MovieStateStr Get the current state. Returns: Type Description MovieStateStr state Source code in prettyqt/gui/movie.py def get_state ( self ) -> MovieStateStr : \"\"\"Get the current state. Returns: state \"\"\" return MOVIE_STATE . inverse [ self . state ()] set_cache_mode ( self , mode : CacheModeStr ) Set cache mode. Parameters: Name Type Description Default mode CacheModeStr cache mode required Exceptions: Type Description InvalidParamError cache mode does not exist Source code in prettyqt/gui/movie.py def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set cache mode. Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODE : raise InvalidParamError ( mode , CACHE_MODE ) self . setCacheMode ( CACHE_MODE [ mode ]) pagelayout PageLayout ( QPageLayout ) Source code in prettyqt/gui/pagelayout.py class PageLayout ( QtGui . QPageLayout ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def serialize_fields ( self ): return dict ( margins = self . margins (), minimum_margins = self . minimumMargins (), mode = self . get_mode (), orientation = self . get_orientation (), page_size = self . get_page_size (), units = self . get_units (), ) def set_units ( self , unit : UnitStr ): \"\"\"Set unit. Args: unit: unit Raises: InvalidParamError: unit does not exist \"\"\" if unit not in UNITS : raise InvalidParamError ( unit , UNITS ) self . setUnits ( UNITS [ unit ]) def get_units ( self ) -> UnitStr : \"\"\"Get the current unit. Returns: unit \"\"\" return UNITS . inverse [ self . units ()] def set_mode ( self , mode : ModeStr ): \"\"\"Set mode. Args: mode: mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setMode ( MODES [ mode ]) def get_mode ( self ) -> ModeStr : \"\"\"Get the current mode. Returns: mode \"\"\" return MODES . inverse [ self . mode ()] def set_orientation ( self , orientation : OrientationStr ): \"\"\"Set orientation. Args: orientation: orientation Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) def get_orientation ( self ) -> OrientationStr : \"\"\"Get the current orientation. Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()] def get_page_size ( self ) -> gui . PageSize : return gui . PageSize ( self . pageSize ()) get_mode ( self ) -> ModeStr Get the current mode. Returns: Type Description ModeStr mode Source code in prettyqt/gui/pagelayout.py def get_mode ( self ) -> ModeStr : \"\"\"Get the current mode. Returns: mode \"\"\" return MODES . inverse [ self . mode ()] get_orientation ( self ) -> OrientationStr Get the current orientation. Returns: Type Description OrientationStr orientation Source code in prettyqt/gui/pagelayout.py def get_orientation ( self ) -> OrientationStr : \"\"\"Get the current orientation. Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()] get_units ( self ) -> UnitStr Get the current unit. Returns: Type Description UnitStr unit Source code in prettyqt/gui/pagelayout.py def get_units ( self ) -> UnitStr : \"\"\"Get the current unit. Returns: unit \"\"\" return UNITS . inverse [ self . units ()] set_mode ( self , mode : ModeStr ) Set mode. Parameters: Name Type Description Default mode ModeStr mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/pagelayout.py def set_mode ( self , mode : ModeStr ): \"\"\"Set mode. Args: mode: mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setMode ( MODES [ mode ]) set_orientation ( self , orientation : OrientationStr ) Set orientation. Parameters: Name Type Description Default orientation OrientationStr orientation required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/gui/pagelayout.py def set_orientation ( self , orientation : OrientationStr ): \"\"\"Set orientation. Args: orientation: orientation Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) set_units ( self , unit : UnitStr ) Set unit. Parameters: Name Type Description Default unit UnitStr unit required Exceptions: Type Description InvalidParamError unit does not exist Source code in prettyqt/gui/pagelayout.py def set_units ( self , unit : UnitStr ): \"\"\"Set unit. Args: unit: unit Raises: InvalidParamError: unit does not exist \"\"\" if unit not in UNITS : raise InvalidParamError ( unit , UNITS ) self . setUnits ( UNITS [ unit ]) pagesize PageSize ( QPageSize ) Source code in prettyqt/gui/pagesize.py class PageSize ( QtGui . QPageSize ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_id () !r} )\" def __reduce__ ( self ): return type ( self ), ( self . id (),) def get_definition_units ( self ) -> UnitStr : \"\"\"Get the definition unit. Returns: unit \"\"\" units = self . definitionUnits () if qt . flag_to_int ( units ) == - 1 : raise ValueError ( \"Invalid page size\" ) return UNITS . inverse [ units ] def get_id ( self ) -> str : \"\"\"Get the standard page size id. Returns: page size id \"\"\" return PAGE_SIZE_ID . inverse [ self . id ()] get_definition_units ( self ) -> UnitStr Get the definition unit. Returns: Type Description UnitStr unit Source code in prettyqt/gui/pagesize.py def get_definition_units ( self ) -> UnitStr : \"\"\"Get the definition unit. Returns: unit \"\"\" units = self . definitionUnits () if qt . flag_to_int ( units ) == - 1 : raise ValueError ( \"Invalid page size\" ) return UNITS . inverse [ units ] get_id ( self ) -> str Get the standard page size id. Returns: Type Description str page size id Source code in prettyqt/gui/pagesize.py def get_id ( self ) -> str : \"\"\"Get the standard page size id. Returns: page size id \"\"\" return PAGE_SIZE_ID . inverse [ self . id ()] paintdevice PaintDevice ( QPaintDevice ) Source code in prettyqt/gui/paintdevice.py class PaintDevice ( QtGui . QPaintDevice ): def get_metric ( self , metric : MetricStr ) -> int : \"\"\"Return metric information. Args: metric: metric information to get Returns: metric information \"\"\" if metric not in METRICS : raise InvalidParamError ( metric , METRICS ) return self . metric ( METRICS [ metric ]) get_metric ( self , metric : MetricStr ) -> int Return metric information. Parameters: Name Type Description Default metric MetricStr metric information to get required Returns: Type Description int metric information Source code in prettyqt/gui/paintdevice.py def get_metric ( self , metric : MetricStr ) -> int : \"\"\"Return metric information. Args: metric: metric information to get Returns: metric information \"\"\" if metric not in METRICS : raise InvalidParamError ( metric , METRICS ) return self . metric ( METRICS [ metric ]) painter Painter ( QPainter ) Source code in prettyqt/gui/painter.py class Painter ( QtGui . QPainter ): def __enter__ ( self ): return self def __exit__ ( self , typ , value , traceback ): self . end () @contextlib . contextmanager def paint_on ( self , obj ) -> Iterator [ Painter ]: self . begin ( obj ) yield self self . end () @contextlib . contextmanager def backup_state ( self ) -> Iterator [ Painter ]: self . save () yield self self . restore () @contextlib . contextmanager def native_mode ( self ) -> Iterator [ Painter ]: self . beginNativePainting () yield self self . endNativePainting () @contextlib . contextmanager def edit_pen ( self ) -> Iterator [ gui . Pen ]: pen = gui . Pen ( self . pen ()) yield pen self . setPen ( pen ) def draw_image ( self , target : QtCore . QPoint | QtCore . QPointF | QtCore . QRect | QtCore . QRectF , frame_buffer : QtGui . QImage , ): self . set_composition_mode ( \"source_atop\" ) self . drawImage ( target , frame_buffer ) def draw_polygon ( self , points : ( QtGui . QPolygon | QtGui . QPolygonF | list [ QtCore . QPoint ] | list [ QtCore . QPointF ] ), fill_rule : constants . FillRuleStr = \"odd_even\" , ): if fill_rule not in constants . FILL_RULE : raise InvalidParamError ( fill_rule , constants . FILL_RULE ) self . drawPolygon ( points , fillRule = constants . FILL_RULE [ fill_rule ]) # type: ignore def use_antialiasing ( self ): self . setRenderHint ( self . RenderHint . Antialiasing , True ) def fill_rect ( self , rect : types . RectType | types . RectFType , color : types . ColorType , pattern : constants . PatternStr = \"solid\" , ): if pattern not in constants . PATTERN : raise InvalidParamError ( pattern , constants . PATTERN ) if isinstance ( rect , tuple ): rect = core . RectF ( * rect ) color = colors . get_color ( color ) if pattern != \"solid\" : color = gui . Brush ( color , constants . PATTERN [ pattern ]) self . fillRect ( rect , color ) def set_pen ( self , style : constants . PenStyleStr | None = \"solid\" , width : float = 1.0 , color : types . ColorType = \"black\" , brush : QtGui . QBrush | None = None , miter_limit : float = 2.0 , join_style : constants . JoinStyleStr = \"bevel\" , cap_style : constants . CapStyleStr = \"square\" , ) -> gui . Pen : \"\"\"Set pen to use. Args: style: pen style width: pen width color: pen color brush: pen brush miter_limit: miter limit join_style: pen join style cap_style: pen cap style \"\"\" pen = gui . Pen () pen . set_style ( style ) if style in [ \"none\" , None ]: self . setPen ( pen ) return pen pen . set_cap_style ( cap_style ) pen . set_join_style ( join_style ) pen . setMiterLimit ( miter_limit ) pen . setWidthF ( width ) if brush is not None : pen . setBrush ( brush ) pen . set_color ( color ) self . setPen ( pen ) return pen def get_pen ( self ) -> gui . Pen : \"\"\"Return current pen. Returns: current pen \"\"\" return gui . Pen ( self . pen ()) def set_color ( self , color : types . ColorType ): color = colors . get_color ( color ) self . setPen ( color ) def set_brush ( self , brush : QtGui . QBrush | types . ColorType ): if not isinstance ( brush , QtGui . QBrush ): brush = colors . get_color ( brush ) self . setBrush ( brush ) def set_transparent_background ( self , transparent : bool = True ): mode = ( QtCore . Qt . BGMode . TransparentMode if transparent else QtCore . Qt . BGMode . OpaqueMode ) self . setBackgroundMode ( mode ) def set_composition_mode ( self , mode : CompositionModeStr ): \"\"\"Set the current composition mode. Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMPOSITION_MODE : raise InvalidParamError ( mode , COMPOSITION_MODE ) self . setCompositionMode ( COMPOSITION_MODE [ mode ]) def get_composition_mode ( self ) -> CompositionModeStr : \"\"\"Get the current composition mode. Returns: composition mode \"\"\" return COMPOSITION_MODE . inverse [ self . compositionMode ()] def get_font_metrics ( self ) -> gui . FontMetrics : return gui . FontMetrics ( self . fontMetrics ()) def set_clip_path ( self , path : QtGui . QPainterPath , operation : constants . ClipOperationStr = \"replace\" ): if operation not in constants . CLIP_OPERATION : raise InvalidParamError ( operation , constants . CLIP_OPERATION ) self . setClipPath ( path , constants . CLIP_OPERATION [ operation ]) def get_text_rect ( self , text : str ) -> core . Rect : return self . drawText ( core . Rect (), QtCore . Qt . TextFlag . TextDontPrint , text ) # type: ignore @contextlib . contextmanager def clip_path ( self , operation : constants . ClipOperationStr = \"replace\" ) -> Iterator [ gui . PainterPath ]: path = gui . PainterPath () yield path self . set_clip_path ( path , operation ) @contextlib . contextmanager def apply_transform ( self , combine : bool = True ) -> Iterator [ gui . Transform ]: transform = gui . Transform () yield transform self . setTransform ( transform , combine ) @contextlib . contextmanager def offset_by ( self , x : int = 0 , y : int = 0 ) -> Iterator [ Painter ]: self . translate ( x , y ) yield self self . translate ( - x , - y ) get_composition_mode ( self ) -> CompositionModeStr Get the current composition mode. Returns: Type Description CompositionModeStr composition mode Source code in prettyqt/gui/painter.py def get_composition_mode ( self ) -> CompositionModeStr : \"\"\"Get the current composition mode. Returns: composition mode \"\"\" return COMPOSITION_MODE . inverse [ self . compositionMode ()] get_pen ( self ) -> gui . Pen Return current pen. Returns: Type Description gui.Pen current pen Source code in prettyqt/gui/painter.py def get_pen ( self ) -> gui . Pen : \"\"\"Return current pen. Returns: current pen \"\"\" return gui . Pen ( self . pen ()) set_composition_mode ( self , mode : CompositionModeStr ) Set the current composition mode. Exceptions: Type Description InvalidParamError composition mode does not exist Source code in prettyqt/gui/painter.py def set_composition_mode ( self , mode : CompositionModeStr ): \"\"\"Set the current composition mode. Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMPOSITION_MODE : raise InvalidParamError ( mode , COMPOSITION_MODE ) self . setCompositionMode ( COMPOSITION_MODE [ mode ]) set_pen ( self , style : constants . PenStyleStr | None = 'solid' , width : float = 1.0 , color : types . ColorType = 'black' , brush : QtGui . QBrush | None = None , miter_limit : float = 2.0 , join_style : constants . JoinStyleStr = 'bevel' , cap_style : constants . CapStyleStr = 'square' ) -> gui . Pen Set pen to use. Parameters: Name Type Description Default style constants.PenStyleStr | None pen style 'solid' width float pen width 1.0 color types.ColorType pen color 'black' brush QtGui.QBrush | None pen brush None miter_limit float miter limit 2.0 join_style constants.JoinStyleStr pen join style 'bevel' cap_style constants.CapStyleStr pen cap style 'square' Source code in prettyqt/gui/painter.py def set_pen ( self , style : constants . PenStyleStr | None = \"solid\" , width : float = 1.0 , color : types . ColorType = \"black\" , brush : QtGui . QBrush | None = None , miter_limit : float = 2.0 , join_style : constants . JoinStyleStr = \"bevel\" , cap_style : constants . CapStyleStr = \"square\" , ) -> gui . Pen : \"\"\"Set pen to use. Args: style: pen style width: pen width color: pen color brush: pen brush miter_limit: miter limit join_style: pen join style cap_style: pen cap style \"\"\" pen = gui . Pen () pen . set_style ( style ) if style in [ \"none\" , None ]: self . setPen ( pen ) return pen pen . set_cap_style ( cap_style ) pen . set_join_style ( join_style ) pen . setMiterLimit ( miter_limit ) pen . setWidthF ( width ) if brush is not None : pen . setBrush ( brush ) pen . set_color ( color ) self . setPen ( pen ) return pen painterpath PainterPath ( QPainterPath ) Source code in prettyqt/gui/painterpath.py class PainterPath ( QtGui . QPainterPath ): def serialize_fields ( self ): return dict ( fill_rule = self . get_fill_rule (), elements = list ( self )) def __len__ ( self ): return self . elementCount () def __getitem__ ( self , index : int ) -> QtGui . QPainterPath . Element : return self . elementAt ( index ) def __iter__ ( self ) -> Iterator [ QtGui . QPainterPath . Element ]: return iter ( self . elementAt ( i ) for i in range ( self . elementCount ())) def __setitem__ ( self , index : int , value : tuple [ int , int ]): self . setElementPositionAt ( index , * value ) def __bool__ ( self ): return not self . isEmpty () def __contains__ ( self , item : QtCore . QPointF | QtCore . QRectF | QtGui . QPainterPath ): return self . contains ( item ) def add_rect ( self , rect : types . RectType | types . RectFType ): if isinstance ( rect , QtCore . QRect ): rect = QtCore . QRectF ( rect ) elif isinstance ( rect , tuple ): rect = QtCore . QRectF ( * rect ) self . addRect ( rect ) def set_fill_rule ( self , rule : constants . FillRuleStr ): \"\"\"Set fill rule. Args: rule: fill rule to use Raises: InvalidParamError: fill rule does not exist \"\"\" if rule not in constants . FILL_RULE : raise InvalidParamError ( rule , constants . FILL_RULE ) self . setFillRule ( constants . FILL_RULE [ rule ]) def get_fill_rule ( self ) -> constants . FillRuleStr : \"\"\"Return current fill rule. Returns: fill rule \"\"\" return constants . FILL_RULE . inverse [ self . fillRule ()] def get_bounding_rect ( self ) -> core . RectF : return core . RectF ( self . boundingRect ()) get_fill_rule ( self ) -> constants . FillRuleStr Return current fill rule. Returns: Type Description constants.FillRuleStr fill rule Source code in prettyqt/gui/painterpath.py def get_fill_rule ( self ) -> constants . FillRuleStr : \"\"\"Return current fill rule. Returns: fill rule \"\"\" return constants . FILL_RULE . inverse [ self . fillRule ()] set_fill_rule ( self , rule : constants . FillRuleStr ) Set fill rule. Parameters: Name Type Description Default rule constants.FillRuleStr fill rule to use required Exceptions: Type Description InvalidParamError fill rule does not exist Source code in prettyqt/gui/painterpath.py def set_fill_rule ( self , rule : constants . FillRuleStr ): \"\"\"Set fill rule. Args: rule: fill rule to use Raises: InvalidParamError: fill rule does not exist \"\"\" if rule not in constants . FILL_RULE : raise InvalidParamError ( rule , constants . FILL_RULE ) self . setFillRule ( constants . FILL_RULE [ rule ]) painterpathstroker PainterPathStroker ( QPainterPathStroker ) Source code in prettyqt/gui/painterpathstroker.py class PainterPathStroker ( QtGui . QPainterPathStroker ): def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ]) def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()] def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ]) def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()] def create_stroke ( self , path : QtGui . QPainterPath ) -> gui . PainterPath : return gui . PainterPath ( self . createStroke ( path )) get_cap_style ( self ) -> constants . CapStyleStr Return current cap style. Returns: Type Description constants.CapStyleStr cap style Source code in prettyqt/gui/painterpathstroker.py def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()] get_join_style ( self ) -> constants . JoinStyleStr Return current join style. Returns: Type Description constants.JoinStyleStr join style Source code in prettyqt/gui/painterpathstroker.py def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()] set_cap_style ( self , style : constants . CapStyleStr ) Set cap style to use. Parameters: Name Type Description Default style constants.CapStyleStr cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ]) set_join_style ( self , style : constants . JoinStyleStr ) Set join style to use. Parameters: Name Type Description Default style constants.JoinStyleStr join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ]) palette Palette ( QPalette ) Source code in prettyqt/gui/palette.py class Palette ( QtGui . QPalette ): def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __getitem__ ( self , index : RoleStr ) -> gui . Color : return self . get_color ( index ) def __setitem__ ( self , index : RoleStr , value : types . ColorType ): self . set_color ( index , value ) def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self [ 'button' ] } , { self [ 'window' ] } )\" def highlight_inactive ( self ): color = self . color ( self . ColorGroup . Active , self . ColorRole . Highlight ) self . setColor ( self . ColorGroup . Inactive , self . ColorRole . Highlight , color ) def set_color ( self , role : RoleStr , color : types . ColorType , group : GroupStr = \"active\" ): color = colors . get_color ( color ) self . setColor ( GROUP [ group ], ROLE [ role ], color ) def get_colors ( self , group : GroupStr = \"active\" ) -> dict [ str , gui . Color ]: return { k : self . get_color ( k , group ) for k in ROLE . keys ()} def get_color ( self , role : RoleStr , group : GroupStr = \"active\" ) -> gui . Color : return gui . Color ( self . color ( GROUP [ group ], ROLE [ role ])) def set_brush ( self , role : RoleStr , brush : types . ColorAndBrushType , group : GroupStr = \"active\" ): if not isinstance ( brush , QtGui . QBrush ): brush = gui . Brush ( colors . get_color ( brush )) self . setBrush ( GROUP [ group ], ROLE [ role ], brush ) def get_brushes ( self , group : GroupStr = \"active\" ) -> dict [ str , gui . Brush ]: return { k : self . get_brush ( k , group ) for k in ROLE . keys ()} def get_brush ( self , role : RoleStr , group : GroupStr = \"active\" ) -> gui . Brush : return gui . Brush ( self . brush ( GROUP [ group ], ROLE [ role ])) def set_color_group ( self , group : GroupStr , * args , ** kwargs ): \"\"\"Set the color group. Args: group: color group to use Raises: InvalidParamError: invalid color group \"\"\" if group not in GROUP : raise InvalidParamError ( group , GROUP ) self . setColorGroup ( GROUP [ group ], * args , ** kwargs ) def get_color_group ( self ) -> GroupStr : \"\"\"Return color group. Returns: color group \"\"\" return GROUP . inverse [ self . colorGroup ()] def inverted ( self ) -> Palette : pal = Palette () for group in GROUP : for role in ROLE : color = self . get_color ( role , group ) pal . set_color ( role , color . inverted (), group ) return pal @classmethod def create_dark_palette ( cls ) -> Palette : pal = cls () pal . set_color ( \"window\" , gui . Color ( 53 , 53 , 53 )) pal . set_color ( \"window_text\" , \"white\" ) pal . set_color ( \"window_text\" , \"grey\" , group = \"disabled\" ) pal . set_color ( \"base\" , gui . Color ( 25 , 25 , 25 )) pal . set_color ( \"alternate_base\" , gui . Color ( 53 , 53 , 53 )) pal . set_color ( \"tool_tip_base\" , \"slategrey\" ) pal . set_color ( \"tool_tip_base\" , \"slategrey\" , group = \"inactive\" ) pal . set_color ( \"tool_tip_text\" , \"white\" ) pal . set_color ( \"tool_tip_text\" , \"white\" , group = \"inactive\" ) pal . set_color ( \"text\" , \"white\" ) pal . set_color ( \"text\" , \"grey\" , group = \"disabled\" ) pal . set_color ( \"button\" , gui . Color ( 53 , 53 , 53 )) pal . set_color ( \"button_text\" , \"white\" ) pal . set_color ( \"button_text\" , \"grey\" , group = \"disabled\" ) pal . set_color ( \"bright_text\" , \"red\" ) pal . set_color ( \"link\" , \"dodgerblue\" ) pal . set_color ( \"highlight\" , \"dodgerblue\" ) pal . set_color ( \"highlight\" , gui . Color ( 80 , 80 , 80 ), group = \"disabled\" ) pal . set_color ( \"highlighted_text\" , \"black\" ) pal . set_color ( \"highlighted_text\" , \"grey\" , group = \"disabled\" ) return pal get_color_group ( self ) -> GroupStr Return color group. Returns: Type Description GroupStr color group Source code in prettyqt/gui/palette.py def get_color_group ( self ) -> GroupStr : \"\"\"Return color group. Returns: color group \"\"\" return GROUP . inverse [ self . colorGroup ()] set_color_group ( self , group : GroupStr , * args , ** kwargs ) Set the color group. Parameters: Name Type Description Default group GroupStr color group to use required Exceptions: Type Description InvalidParamError invalid color group Source code in prettyqt/gui/palette.py def set_color_group ( self , group : GroupStr , * args , ** kwargs ): \"\"\"Set the color group. Args: group: color group to use Raises: InvalidParamError: invalid color group \"\"\" if group not in GROUP : raise InvalidParamError ( group , GROUP ) self . setColorGroup ( GROUP [ group ], * args , ** kwargs ) pen Pen ( QPen ) Source code in prettyqt/gui/pen.py class Pen ( QtGui . QPen ): def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_color () } )\" def set_color ( self , color : types . ColorType ): color = colors . get_color ( color ) self . setColor ( color ) def get_color ( self ) -> gui . Color : return gui . Color ( self . color ()) def get_brush ( self ) -> gui . Brush : return gui . Brush ( self . brush ()) def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ]) def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()] def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ]) def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()] def set_style ( self , style : constants . PenStyleStr | list [ float ] | None ): \"\"\"Set pen style to use. Args: style: pen style to use Raises: InvalidParamError: pen style does not exist \"\"\" if isinstance ( style , list ): self . setDashPattern ( style ) else : if style is None : style = \"none\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setStyle ( constants . PEN_STYLE [ style ]) def get_style ( self ) -> constants . PenStyleStr : \"\"\"Return current pen style. Returns: pen style \"\"\" return constants . PEN_STYLE . inverse [ self . style ()] get_cap_style ( self ) -> constants . CapStyleStr Return current cap style. Returns: Type Description constants.CapStyleStr cap style Source code in prettyqt/gui/pen.py def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()] get_join_style ( self ) -> constants . JoinStyleStr Return current join style. Returns: Type Description constants.JoinStyleStr join style Source code in prettyqt/gui/pen.py def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()] get_style ( self ) -> constants . PenStyleStr Return current pen style. Returns: Type Description constants.PenStyleStr pen style Source code in prettyqt/gui/pen.py def get_style ( self ) -> constants . PenStyleStr : \"\"\"Return current pen style. Returns: pen style \"\"\" return constants . PEN_STYLE . inverse [ self . style ()] set_cap_style ( self , style : constants . CapStyleStr ) Set cap style to use. Parameters: Name Type Description Default style constants.CapStyleStr cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/pen.py def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ]) set_join_style ( self , style : constants . JoinStyleStr ) Set join style to use. Parameters: Name Type Description Default style constants.JoinStyleStr join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/pen.py def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ]) set_style ( self , style : constants . PenStyleStr | list [ float ] | None ) Set pen style to use. Parameters: Name Type Description Default style constants.PenStyleStr | list[float] | None pen style to use required Exceptions: Type Description InvalidParamError pen style does not exist Source code in prettyqt/gui/pen.py def set_style ( self , style : constants . PenStyleStr | list [ float ] | None ): \"\"\"Set pen style to use. Args: style: pen style to use Raises: InvalidParamError: pen style does not exist \"\"\" if isinstance ( style , list ): self . setDashPattern ( style ) else : if style is None : style = \"none\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setStyle ( constants . PEN_STYLE [ style ]) pixmap Pixmap ( QPixmap ) Source code in prettyqt/gui/pixmap.py class Pixmap ( QtGui . QPixmap ): def __bool__ ( self ): return not self . isNull () def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __eq__ ( self , other ): if not isinstance ( other , Pixmap ): return False # return bytes(self) == bytes(other) return self . toImage () == other . toImage () def __hash__ ( self ): return self . cacheKey () @classmethod def from_file ( cls , path : types . PathType ) -> Pixmap : path = pathlib . Path ( path ) with path . open ( mode = \"rb\" ) as f : data = f . read () # Create widget pixmap = cls () pixmap . loadFromData ( QtCore . QByteArray ( data )) return pixmap @classmethod def from_image ( cls , img : QtGui . QImage , flags ) -> Pixmap : return cls ( cls . fromImage ( img , flags )) def get_size ( self ) -> core . Size : return core . Size ( self . size ()) def get_rect ( self ) -> core . Rect : return core . Rect ( self . rect ()) def to_image ( self ) -> gui . Image : return gui . Image ( self . toImage ()) def rotated ( self , rotation : int ) -> Pixmap : w , h = self . width (), self . height () pixmap = self . transformed ( gui . Transform () . rotate ( rotation )) new_w , new_h = pixmap . width (), pixmap . height () return pixmap . copy (( new_w - w ) // 2 , ( new_h - h ) // 2 , w , h ) def get_image_data_url ( self ): \"\"\"Render the contents of the pixmap as a data URL (RFC-2397). Returns: datauri : str \"\"\" device = core . Buffer () assert device . open_file ( \"read_write\" ) self . save ( device , b \"png\" ) device . close () data = bytes ( device . data ()) payload = base64 . b64encode ( data ) . decode ( \"ascii\" ) return \"data:image/png;base64,\" + payload @classmethod def create_dot ( cls , color : types . ColorType = \"black\" , size : int = 16 ) -> Pixmap : col = colors . get_color ( color ) px = cls ( size , size ) px . fill ( QtCore . Qt . GlobalColor . transparent ) # type: ignore px_size = px . rect () . adjusted ( 1 , 1 , - 1 , - 1 ) with gui . Painter ( px ) as painter : painter . use_antialiasing () painter . setBrush ( col ) pen_color = gui . Color ( 15 , 15 , 15 ) painter . set_pen ( color = pen_color , width = 1 ) painter . drawEllipse ( px_size ) return px @classmethod def create_checkerboard_pattern ( cls , n : int , color_1 : types . ColorType , color_2 : types . ColorType ): \"\"\"Construct tileable checkerboard pattern for paint events.\"\"\" # Brush will be an n\u00d7n checkerboard pattern pat = gui . Pixmap ( 2 * n , 2 * n ) bg0 = colors . get_color ( color_1 ) bg1 = colors . get_color ( color_2 ) with gui . Painter ( pat ) as p : p . setPen ( QtCore . Qt . PenStyle . NoPen ) # Paint a checkerboard pattern for the color to be overlaid on p . fillRect ( pat . rect (), bg0 ) p . fillRect ( 0 , 0 , n , n , bg1 ) p . fillRect ( n , n , 2 * n , 2 * n , bg1 ) return pat @classmethod def create_char ( cls , char : str , size : int , background : types . ColorType = \"black\" , color : types . ColorType = \"white\" , ): pixmap = cls ( size , size ) pixmap . fill ( QtCore . Qt . transparent ) with gui . Painter ( pixmap ) as painter : painter . setRenderHints ( painter . Antialiasing | painter . TextAntialiasing | painter . SmoothPixmapTransform ) bg_color = colors . get_color ( background ) painter . setPen ( bg_color ) painter . setBrush ( bg_color ) margin = 1 + size // 16 text_margin = size // 20 rect = QtCore . QRectF ( margin , margin , size - 2 * margin , size - 2 * margin ) painter . drawRoundedRect ( rect , 30.0 , 30.0 , QtCore . Qt . RelativeSize ) painter . setPen ( colors . get_color ( color )) font = painter . font () # type: QtGui.QFont font . setPixelSize ( size - 2 * margin - 2 * text_margin ) painter . setFont ( font ) painter . drawText ( rect , QtCore . Qt . AlignCenter , char ) return pixmap create_checkerboard_pattern ( n : int , color_1 : types . ColorType , color_2 : types . ColorType ) classmethod Construct tileable checkerboard pattern for paint events. Source code in prettyqt/gui/pixmap.py @classmethod def create_checkerboard_pattern ( cls , n : int , color_1 : types . ColorType , color_2 : types . ColorType ): \"\"\"Construct tileable checkerboard pattern for paint events.\"\"\" # Brush will be an n\u00d7n checkerboard pattern pat = gui . Pixmap ( 2 * n , 2 * n ) bg0 = colors . get_color ( color_1 ) bg1 = colors . get_color ( color_2 ) with gui . Painter ( pat ) as p : p . setPen ( QtCore . Qt . PenStyle . NoPen ) # Paint a checkerboard pattern for the color to be overlaid on p . fillRect ( pat . rect (), bg0 ) p . fillRect ( 0 , 0 , n , n , bg1 ) p . fillRect ( n , n , 2 * n , 2 * n , bg1 ) return pat get_image_data_url ( self ) Render the contents of the pixmap as a data URL (RFC-2397). Returns: Type Description datauri str Source code in prettyqt/gui/pixmap.py def get_image_data_url ( self ): \"\"\"Render the contents of the pixmap as a data URL (RFC-2397). Returns: datauri : str \"\"\" device = core . Buffer () assert device . open_file ( \"read_write\" ) self . save ( device , b \"png\" ) device . close () data = bytes ( device . data ()) payload = base64 . b64encode ( data ) . decode ( \"ascii\" ) return \"data:image/png;base64,\" + payload sessionmanager SessionManager Source code in prettyqt/gui/sessionmanager.py class SessionManager : def __init__ ( self , item : QtGui . QSessionManager ): self . item = item def __getattr__ ( self , val ): return getattr ( self . item , val ) def set_restart_hint ( self , style : RestartHintStr ): \"\"\"Set the restart hint. Args: style: restart hint Raises: InvalidParamError: restart hint does not exist \"\"\" if style not in RESTART_HINT : raise InvalidParamError ( style , RESTART_HINT ) self . setRestartHint ( RESTART_HINT [ style ]) def get_restart_hint ( self ) -> RestartHintStr : \"\"\"Return current restart hint. Returns: restart hint \"\"\" return RESTART_HINT . inverse [ self . restartHint ()] get_restart_hint ( self ) -> RestartHintStr Return current restart hint. Returns: Type Description RestartHintStr restart hint Source code in prettyqt/gui/sessionmanager.py def get_restart_hint ( self ) -> RestartHintStr : \"\"\"Return current restart hint. Returns: restart hint \"\"\" return RESTART_HINT . inverse [ self . restartHint ()] set_restart_hint ( self , style : RestartHintStr ) Set the restart hint. Parameters: Name Type Description Default style RestartHintStr restart hint required Exceptions: Type Description InvalidParamError restart hint does not exist Source code in prettyqt/gui/sessionmanager.py def set_restart_hint ( self , style : RestartHintStr ): \"\"\"Set the restart hint. Args: style: restart hint Raises: InvalidParamError: restart hint does not exist \"\"\" if style not in RESTART_HINT : raise InvalidParamError ( style , RESTART_HINT ) self . setRestartHint ( RESTART_HINT [ style ]) standarditem StandardItem ( QStandardItem ) Source code in prettyqt/gui/standarditem.py class StandardItem ( QtGui . QStandardItem ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_icon () } , { self . text () !r} )\" def serialize_fields ( self ): return dict ( text = self . text (), tool_tip = self . toolTip (), status_tip = self . statusTip (), icon = self . get_icon (), data = self . data (), ) def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __getitem__ ( self , index : int | tuple [ int , int ] | QtCore . QModelIndex ) -> QtGui . QStandardItem : if isinstance ( index , int ): return self . child ( index ) elif isinstance ( index , tuple ): return self . child ( * index ) else : raise KeyError ( index ) def __delitem__ ( self , index : int | tuple [ int , int ]): if isinstance ( index , int ): item = self . takeRow ( index ) else : item = self . takeChild ( * index ) if item is None : raise KeyError ( index ) return item def __iter__ ( self ) -> Iterator [ QtGui . QStandardItem ]: return iter ( self . get_children ()) def __add__ ( self , other : str | QtGui . QStandardItem ) -> StandardItem : if isinstance ( other , ( QtGui . QStandardItem , str )): self . add ( other ) return self raise TypeError ( \"wrong type for addition\" ) def get_children ( self ) -> list [ QtGui . QStandardItem ]: return [ self . child ( index ) for index in range ( self . rowCount ())] def add ( self , * item : str | QtGui . QStandardItem ): for i in item : if isinstance ( i , str ): i = gui . StandardItem ( i ) self . appendRow ([ i ]) def clone ( self ): item = type ( self )() core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] def get_background ( self ) -> gui . Brush : return gui . Brush ( self . background ()) def get_foreground ( self ) -> gui . Brush : return gui . Brush ( self . foreground ()) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_tooltip ( self , tooltip : str | types . PathType , size : types . SizeType | None = None , ): if isinstance ( tooltip , os . PathLike ): path = os . fspath ( tooltip ) if size is None : tooltip = f \"<img src= { path !r} >\" else : if isinstance ( size , QtCore . QSize ): size = ( size . width (), size . height ()) tooltip = f '<img src= { path !r} width=\" { size [ 0 ] } \" height=\" { size [ 1 ] } \">' self . setToolTip ( tooltip ) def set_size_hint ( self , hint : types . SizeType ): if isinstance ( hint , tuple ): hint = QtCore . QSize ( * hint ) self . setSizeHint ( hint ) def add_item ( self , name : str = \"\" , icon : types . IconType = None , data : dict | None = None , foreground : QtGui . QBrush | None = None , background : QtGui . QBrush | None = None , font : QtGui . QFont | None = None , selectable : bool = True , enabled : bool = True , editable : bool = False , status_tip : str | None = None , tool_tip : str | None = None , whats_this : str | None = None , # text_alignment: Optional[str] = None, checkstate : constants . StateStr | None = None , flags : QtCore . Qt . ItemFlags | None = None , size_hint : types . SizeType | None = None , is_user_type : bool = False , ) -> StandardItem : item = StandardItem ( name ) if icon is not None : icon = iconprovider . get_icon ( icon ) item . setIcon ( icon ) if data is not None : for k , v in data . items (): item . setData ( v , k ) if foreground is not None : item . setForeground ( foreground ) if background is not None : item . setBackground ( background ) if font is not None : item . setFont ( font ) if flags is not None : item . setFlags ( flags ) if enabled : item . setEnabled ( enabled ) if editable : item . setEditable ( editable ) if selectable : item . setSelectable ( selectable ) if status_tip : item . setStatusTip ( status_tip ) if tool_tip : item . setToolTip ( tool_tip ) if whats_this : item . setWhatsThis ( whats_this ) if size_hint is not None : item . set_size_hint ( size_hint ) if checkstate is not None : item . set_checkstate ( checkstate ) self . appendRow ([ item ]) return item clone ( self ) clone(self) -> PySide6.QtGui.QStandardItem Source code in prettyqt/gui/standarditem.py def clone ( self ): item = type ( self )() core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item get_checkstate ( self ) -> constants . StateStr Return checkstate. Returns: Type Description constants.StateStr checkstate Source code in prettyqt/gui/standarditem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] set_checkstate ( self , state : constants . StateStr ) Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/gui/standarditem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) set_icon ( self , icon : types . IconType ) Set the icon for the action. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/gui/standarditem.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) statictext StaticText ( QStaticText ) Source code in prettyqt/gui/statictext.py class StaticText ( QtGui . QStaticText ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . text () !r} )\" def __str__ ( self ): return self . text () def get_size ( self ) -> core . Size : return core . Size ( self . size ()) def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] def set_performance_hint ( self , hint : PerformanceHintStr ): \"\"\"Set the performance hint. Args: hint: performance hint to use Raises: InvalidParamError: performance hint does not exist \"\"\" if hint not in PERFORMANCE_HINT : raise InvalidParamError ( hint , PERFORMANCE_HINT ) self . setPerformanceHint ( PERFORMANCE_HINT [ hint ]) def get_performance_hint ( self ) -> PerformanceHintStr : \"\"\"Return current performance hint. Returns: performance hint \"\"\" return PERFORMANCE_HINT . inverse [ self . performanceHint ()] get_performance_hint ( self ) -> PerformanceHintStr Return current performance hint. Returns: Type Description PerformanceHintStr performance hint Source code in prettyqt/gui/statictext.py def get_performance_hint ( self ) -> PerformanceHintStr : \"\"\"Return current performance hint. Returns: performance hint \"\"\" return PERFORMANCE_HINT . inverse [ self . performanceHint ()] get_text_format ( self ) -> str Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str text format Source code in prettyqt/gui/statictext.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] set_performance_hint ( self , hint : PerformanceHintStr ) Set the performance hint. Parameters: Name Type Description Default hint PerformanceHintStr performance hint to use required Exceptions: Type Description InvalidParamError performance hint does not exist Source code in prettyqt/gui/statictext.py def set_performance_hint ( self , hint : PerformanceHintStr ): \"\"\"Set the performance hint. Args: hint: performance hint to use Raises: InvalidParamError: performance hint does not exist \"\"\" if hint not in PERFORMANCE_HINT : raise InvalidParamError ( hint , PERFORMANCE_HINT ) self . setPerformanceHint ( PERFORMANCE_HINT [ hint ]) set_text_format ( self , text_format : str ) Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/gui/statictext.py def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) surface Surface ( QSurface ) Source code in prettyqt/gui/surface.py class Surface ( QtGui . QSurface ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def get_surface_class ( self ) -> SurfaceClassStr : \"\"\"Get the current surface class. Returns: surface class \"\"\" return SURFACE_CLASS . inverse [ self . surfaceClass ()] def get_surface_type ( self ) -> SurfaceTypeStr : \"\"\"Get the current surface type. Returns: surface type \"\"\" return SURFACE_TYPES . inverse [ self . surfaceType ()] get_surface_class ( self ) -> SurfaceClassStr Get the current surface class. Returns: Type Description SurfaceClassStr surface class Source code in prettyqt/gui/surface.py def get_surface_class ( self ) -> SurfaceClassStr : \"\"\"Get the current surface class. Returns: surface class \"\"\" return SURFACE_CLASS . inverse [ self . surfaceClass ()] get_surface_type ( self ) -> SurfaceTypeStr Get the current surface type. Returns: Type Description SurfaceTypeStr surface type Source code in prettyqt/gui/surface.py def get_surface_type ( self ) -> SurfaceTypeStr : \"\"\"Get the current surface type. Returns: surface type \"\"\" return SURFACE_TYPES . inverse [ self . surfaceType ()] syntaxhighlighter SyntaxHighlighter ( QSyntaxHighlighter ) Source code in prettyqt/gui/syntaxhighlighter.py class SyntaxHighlighter ( QtGui . QSyntaxHighlighter ): RULES : list = [] def __init__ ( self , parent : QtCore . QObject | None = None ): super () . __init__ ( parent ) # type: ignore def get_current_block ( self ) -> gui . TextBlock : return gui . TextBlock ( self . currentBlock ()) def get_format ( self , position : int ) -> gui . TextBlock : return gui . TextCharFormat ( self . format ( position )) @classmethod def yield_rules ( cls ) -> Iterator [ tuple [ Pattern , int , gui . TextCharFormat ]]: for Rule in cls . RULES : if isinstance ( Rule . compiled , list ): for i in Rule . compiled : yield ( i , Rule . nth , Rule . fmt ) else : yield ( Rule . compiled , Rule . nth , Rule . fmt ) def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt ) highlightBlock ( self , text : str ) Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt ) textblock TextBlock ( QTextBlock ) Source code in prettyqt/gui/textblock.py class TextBlock ( QtGui . QTextBlock ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . text () !r} )\" def __contains__ ( self , position : int ): return self . contains ( position ) def __bool__ ( self ): return self . isValid () def __str__ ( self ): return self . text () def get_previous ( self ) -> TextBlock : return TextBlock ( self . previous ()) def get_next ( self ) -> TextBlock : return TextBlock ( self . next ()) def get_text_direction ( self ) -> constants . LayoutDirectionStr : return constants . LAYOUT_DIRECTION . inv [ self . textDirection ()] def set_user_data ( self , data ): if isinstance ( data , QtGui . QTextBlockUserData ): self . setUserData ( data ) return None user_data = UserData ( data ) self . setUserData ( user_data ) def get_user_data ( self ): user_data = self . userData () if isinstance ( user_data , UserData ): print ( user_data . data ) return user_data . data return user_data @contextlib . contextmanager def edit_user_state ( self ): state = self . userState () yield state self . setUserState ( state ) def get_state ( self ) -> int : \"\"\"Get the user state, generally used for syntax highlighting. :return: The block state \"\"\" state = self . userState () if state == - 1 : return state return state & 0x0000FFFF def set_state ( self , state : int ): \"\"\"Set the user state, generally used for syntax highlighting. :param state: new state value. \"\"\" user_state = self . userState () if user_state == - 1 : user_state = 0 higher_part = user_state & 0x7FFF0000 state &= 0x0000FFFF state |= higher_part self . setUserState ( state ) def get_fold_level ( self ) -> int : \"\"\"Get the block fold level. :return: The block fold level \"\"\" state = self . userState () if state == - 1 : state = 0 return ( state & 0x03FF0000 ) >> 16 def set_fold_level ( self , val : int ): \"\"\"Set the block fold level. :param val: The new fold level [0-7] \"\"\" state = self . userState () if state == - 1 : state = 0 if val >= 0x3FF : val = 0x3FF state &= 0x7C00FFFF state |= val << 16 self . setUserState ( state ) def is_fold_trigger ( self ) -> bool : \"\"\"Check if the block is a fold trigger. :return: True if the block is a fold trigger (represented as a node in the fold panel) \"\"\" state = self . userState () if state == - 1 : state = 0 return bool ( state & 0x04000000 ) def set_fold_trigger ( self , val : int ): \"\"\"Set the block fold trigger flag (True means the block is a fold trigger). :param val: value to set \"\"\" state = self . userState () if state == - 1 : state = 0 state &= 0x7BFFFFFF state |= int ( val ) << 26 self . setUserState ( state ) def is_collapsed ( self ) -> bool : \"\"\"Check if the block is expanded or collased. :return: False for an open trigger, True for for closed trigger \"\"\" state = self . userState () if state == - 1 : state = 0 return bool ( state & 0x08000000 ) def set_collapsed ( self , val : int ): \"\"\"Set the fold trigger state (collapsed or expanded). :param val: The new trigger state (True=collapsed, False=expanded) \"\"\" state = self . userState () if state == - 1 : state = 0 state &= 0x77FFFFFF state |= int ( val ) << 27 self . setUserState ( state ) def find_parent_scope ( self , limit : int = 5000 ) -> TextBlock | None : \"\"\"Find parent scope, if the block is not a fold trigger.\"\"\" # if we moved up for more than n lines, just give up otherwise this # would take too much time. counter = 0 original = TextBlock ( self ) start = TextBlock ( self ) if not self . is_fold_trigger (): # search level of next non blank line while start . text () . strip () == \"\" and start . isValid (): start = start . next () ref_level = self . get_fold_level () - 1 start = original while ( start . blockNumber () and counter < limit and ( not self . is_fold_trigger () or self . get_fold_level () > ref_level ) ): counter += 1 start = start . previous () if counter < limit : return TextBlock ( start ) return None find_parent_scope ( self , limit : int = 5000 ) -> TextBlock | None Find parent scope, if the block is not a fold trigger. Source code in prettyqt/gui/textblock.py def find_parent_scope ( self , limit : int = 5000 ) -> TextBlock | None : \"\"\"Find parent scope, if the block is not a fold trigger.\"\"\" # if we moved up for more than n lines, just give up otherwise this # would take too much time. counter = 0 original = TextBlock ( self ) start = TextBlock ( self ) if not self . is_fold_trigger (): # search level of next non blank line while start . text () . strip () == \"\" and start . isValid (): start = start . next () ref_level = self . get_fold_level () - 1 start = original while ( start . blockNumber () and counter < limit and ( not self . is_fold_trigger () or self . get_fold_level () > ref_level ) ): counter += 1 start = start . previous () if counter < limit : return TextBlock ( start ) return None get_fold_level ( self ) -> int Get the block fold level. :return: The block fold level Source code in prettyqt/gui/textblock.py def get_fold_level ( self ) -> int : \"\"\"Get the block fold level. :return: The block fold level \"\"\" state = self . userState () if state == - 1 : state = 0 return ( state & 0x03FF0000 ) >> 16 get_state ( self ) -> int Get the user state, generally used for syntax highlighting. :return: The block state Source code in prettyqt/gui/textblock.py def get_state ( self ) -> int : \"\"\"Get the user state, generally used for syntax highlighting. :return: The block state \"\"\" state = self . userState () if state == - 1 : return state return state & 0x0000FFFF is_collapsed ( self ) -> bool Check if the block is expanded or collased. :return: False for an open trigger, True for for closed trigger Source code in prettyqt/gui/textblock.py def is_collapsed ( self ) -> bool : \"\"\"Check if the block is expanded or collased. :return: False for an open trigger, True for for closed trigger \"\"\" state = self . userState () if state == - 1 : state = 0 return bool ( state & 0x08000000 ) is_fold_trigger ( self ) -> bool Check if the block is a fold trigger. :return: True if the block is a fold trigger (represented as a node in the fold panel) Source code in prettyqt/gui/textblock.py def is_fold_trigger ( self ) -> bool : \"\"\"Check if the block is a fold trigger. :return: True if the block is a fold trigger (represented as a node in the fold panel) \"\"\" state = self . userState () if state == - 1 : state = 0 return bool ( state & 0x04000000 ) set_collapsed ( self , val : int ) Set the fold trigger state (collapsed or expanded). :param val: The new trigger state (True=collapsed, False=expanded) Source code in prettyqt/gui/textblock.py def set_collapsed ( self , val : int ): \"\"\"Set the fold trigger state (collapsed or expanded). :param val: The new trigger state (True=collapsed, False=expanded) \"\"\" state = self . userState () if state == - 1 : state = 0 state &= 0x77FFFFFF state |= int ( val ) << 27 self . setUserState ( state ) set_fold_level ( self , val : int ) Set the block fold level. :param val: The new fold level [0-7] Source code in prettyqt/gui/textblock.py def set_fold_level ( self , val : int ): \"\"\"Set the block fold level. :param val: The new fold level [0-7] \"\"\" state = self . userState () if state == - 1 : state = 0 if val >= 0x3FF : val = 0x3FF state &= 0x7C00FFFF state |= val << 16 self . setUserState ( state ) set_fold_trigger ( self , val : int ) Set the block fold trigger flag (True means the block is a fold trigger). :param val: value to set Source code in prettyqt/gui/textblock.py def set_fold_trigger ( self , val : int ): \"\"\"Set the block fold trigger flag (True means the block is a fold trigger). :param val: value to set \"\"\" state = self . userState () if state == - 1 : state = 0 state &= 0x7BFFFFFF state |= int ( val ) << 26 self . setUserState ( state ) set_state ( self , state : int ) Set the user state, generally used for syntax highlighting. :param state: new state value. Source code in prettyqt/gui/textblock.py def set_state ( self , state : int ): \"\"\"Set the user state, generally used for syntax highlighting. :param state: new state value. \"\"\" user_state = self . userState () if user_state == - 1 : user_state = 0 higher_part = user_state & 0x7FFF0000 state &= 0x0000FFFF state |= higher_part self . setUserState ( state ) textcharformat TextCharFormat ( QTextCharFormat ) Source code in prettyqt/gui/textcharformat.py class TextCharFormat ( QtGui . QTextCharFormat ): def __init__ ( self , text_color : types . ColorType | QtGui . QBrush = None , bold : bool = False , italic : bool = False , ): super () . __init__ () if text_color is not None : self . set_foreground_color ( text_color ) if bold : self . set_font_weight ( \"bold\" ) self . setFontItalic ( italic ) def set_foreground_color ( self , color : types . ColorType | QtGui . QBrush ): if not isinstance ( color , QtGui . QBrush ): color = colors . get_color ( color ) self . setForeground ( color ) def set_background_color ( self , color : types . ColorType | QtGui . QBrush ): if not isinstance ( color , QtGui . QBrush ): color = colors . get_color ( color ) self . setBackground ( color ) def set_font_weight ( self , weight : gui . font . WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) self . setFontWeight ( gui . font . WEIGHT [ weight ]) def get_font_weight ( self ) -> gui . font . WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return gui . font . WEIGHT . inverse [ self . fontWeight ()] def set_underline_style ( self , style : UnderlineStyleStr ): \"\"\"Set the underline style. Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLE : raise InvalidParamError ( style , UNDERLINE_STYLE ) self . setUnderlineStyle ( UNDERLINE_STYLE [ style ]) def get_underline_style ( self ) -> UnderlineStyleStr : \"\"\"Get current underline style. Returns: current underline style \"\"\" return UNDERLINE_STYLE . inverse [ self . underlineStyle ()] def set_vertical_alignment ( self , alignment : VerticalAlignmentStr ): \"\"\"Set the vertical alignment. Args: alignment: vertical alignment Raises: InvalidParamError: invalid vertical alignment \"\"\" if alignment not in VERTICAL_ALIGNMENT : raise InvalidParamError ( alignment , VERTICAL_ALIGNMENT ) self . setVerticalAlignment ( VERTICAL_ALIGNMENT [ alignment ]) def get_vertical_alignment ( self ) -> VerticalAlignmentStr : \"\"\"Get current vertical alignment. Returns: current vertical alignment \"\"\" return VERTICAL_ALIGNMENT . inverse [ self . verticalAlignment ()] def set_font_style_hint ( self , hint : gui . font . StyleHintStr ): \"\"\"Set the font style hint. Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in gui . font . STYLE_HINTS : raise InvalidParamError ( hint , gui . font . STYLE_HINTS ) self . setFontStyleHint ( gui . font . STYLE_HINTS [ hint ]) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) get_font_weight ( self ) -> gui . font . WeightStr Get current font weight. Returns: Type Description gui.font.WeightStr current font weight Source code in prettyqt/gui/textcharformat.py def get_font_weight ( self ) -> gui . font . WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return gui . font . WEIGHT . inverse [ self . fontWeight ()] get_underline_style ( self ) -> UnderlineStyleStr Get current underline style. Returns: Type Description UnderlineStyleStr current underline style Source code in prettyqt/gui/textcharformat.py def get_underline_style ( self ) -> UnderlineStyleStr : \"\"\"Get current underline style. Returns: current underline style \"\"\" return UNDERLINE_STYLE . inverse [ self . underlineStyle ()] get_vertical_alignment ( self ) -> VerticalAlignmentStr Get current vertical alignment. Returns: Type Description VerticalAlignmentStr current vertical alignment Source code in prettyqt/gui/textcharformat.py def get_vertical_alignment ( self ) -> VerticalAlignmentStr : \"\"\"Get current vertical alignment. Returns: current vertical alignment \"\"\" return VERTICAL_ALIGNMENT . inverse [ self . verticalAlignment ()] set_font_style_hint ( self , hint : gui . font . StyleHintStr ) Set the font style hint. Parameters: Name Type Description Default hint gui.font.StyleHintStr font style hint required Exceptions: Type Description InvalidParamError invalid font style hint Source code in prettyqt/gui/textcharformat.py def set_font_style_hint ( self , hint : gui . font . StyleHintStr ): \"\"\"Set the font style hint. Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in gui . font . STYLE_HINTS : raise InvalidParamError ( hint , gui . font . STYLE_HINTS ) self . setFontStyleHint ( gui . font . STYLE_HINTS [ hint ]) set_font_weight ( self , weight : gui . font . WeightStr ) Set the font weight. Parameters: Name Type Description Default weight gui.font.WeightStr font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/textcharformat.py def set_font_weight ( self , weight : gui . font . WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) self . setFontWeight ( gui . font . WEIGHT [ weight ]) set_underline_style ( self , style : UnderlineStyleStr ) Set the underline style. Parameters: Name Type Description Default style UnderlineStyleStr underline style required Exceptions: Type Description InvalidParamError invalid underline style Source code in prettyqt/gui/textcharformat.py def set_underline_style ( self , style : UnderlineStyleStr ): \"\"\"Set the underline style. Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLE : raise InvalidParamError ( style , UNDERLINE_STYLE ) self . setUnderlineStyle ( UNDERLINE_STYLE [ style ]) set_vertical_alignment ( self , alignment : VerticalAlignmentStr ) Set the vertical alignment. Parameters: Name Type Description Default alignment VerticalAlignmentStr vertical alignment required Exceptions: Type Description InvalidParamError invalid vertical alignment Source code in prettyqt/gui/textcharformat.py def set_vertical_alignment ( self , alignment : VerticalAlignmentStr ): \"\"\"Set the vertical alignment. Args: alignment: vertical alignment Raises: InvalidParamError: invalid vertical alignment \"\"\" if alignment not in VERTICAL_ALIGNMENT : raise InvalidParamError ( alignment , VERTICAL_ALIGNMENT ) self . setVerticalAlignment ( VERTICAL_ALIGNMENT [ alignment ]) textcursor TextCursor ( QTextCursor ) Source code in prettyqt/gui/textcursor.py class TextCursor ( QtGui . QTextCursor ): def __str__ ( self ): return self . selectedText () . replace ( \" \\u2029 \" , \" \\n \" ) def move_position ( self , operation : MoveOperationStr , mode : MoveModeStr = \"move\" , n : int = 1 ) -> bool : return self . movePosition ( MOVE_OPERATION [ operation ], MOVE_MODE [ mode ], n ) def set_position ( self , pos : int , mode : MoveModeStr = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODE [ mode ]) def select ( self , selection : SelectionTypeStr | QtGui . QTextCursor . SelectionType ): if isinstance ( selection , QtGui . QTextCursor . SelectionType ): sel = selection else : sel = SELECTION_TYPE [ selection ] super () . select ( sel ) def span ( self ) -> tuple [ int , int ]: return ( self . anchor (), self . position ()) def get_cursor_position ( self ) -> tuple [ int , int ]: \"\"\"Return the QTextCursor position. The position is a tuple made up of the line number (0 based) and the column number (0 based). :return: tuple(line, column) \"\"\" return ( self . blockNumber (), self . columnNumber ()) def get_selection ( self ) -> gui . TextDocumentFragment : return gui . TextDocumentFragment ( self . selection ()) def select_text ( self , start_pos : int | MoveOperationStr , end_pos : int | MoveOperationStr , ) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText () def replace_text ( self , start_pos : int , end_pos : MoveOperationStr | int , to_replace : str , ): self . set_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) self . insertText ( to_replace ) self . select_text ( start_pos , start_pos + len ( to_replace )) @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock () edit_block ( self ) Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock () get_cursor_position ( self ) -> tuple [ int , int ] Return the QTextCursor position. The position is a tuple made up of the line number (0 based) and the column number (0 based). :return: tuple(line, column) Source code in prettyqt/gui/textcursor.py def get_cursor_position ( self ) -> tuple [ int , int ]: \"\"\"Return the QTextCursor position. The position is a tuple made up of the line number (0 based) and the column number (0 based). :return: tuple(line, column) \"\"\" return ( self . blockNumber (), self . columnNumber ()) select ( self , selection : SelectionTypeStr | QtGui . QTextCursor . SelectionType ) select(self, selection: PySide6.QtGui.QTextCursor.SelectionType) -> None Source code in prettyqt/gui/textcursor.py def select ( self , selection : SelectionTypeStr | QtGui . QTextCursor . SelectionType ): if isinstance ( selection , QtGui . QTextCursor . SelectionType ): sel = selection else : sel = SELECTION_TYPE [ selection ] super () . select ( sel ) select_text ( self , start_pos : int | MoveOperationStr , end_pos : int | MoveOperationStr ) -> str Select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos int | MoveOperationStr Start position required end_pos int | MoveOperationStr End position required Source code in prettyqt/gui/textcursor.py def select_text ( self , start_pos : int | MoveOperationStr , end_pos : int | MoveOperationStr , ) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText () set_position ( self , pos : int , mode : MoveModeStr = 'move' ) Set cursor to given position. Parameters: Name Type Description Default pos int Cursor position required mode MoveModeStr Move mode 'move' Source code in prettyqt/gui/textcursor.py def set_position ( self , pos : int , mode : MoveModeStr = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODE [ mode ]) textdocument TextDocument ( QTextDocument ) Source code in prettyqt/gui/textdocument.py class TextDocument ( QtGui . QTextDocument ): def __getitem__ ( self , index : int ) -> gui . TextBlock : return gui . TextBlock ( self . findBlockByNumber ( index )) def __len__ ( self ) -> int : return self . blockCount () def __iter__ ( self ) -> Iterator [ gui . TextBlock ]: return iter ( gui . TextBlock ( self . findBlockByNumber ( i )) for i in range ( self . blockCount ()) ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . toPlainText () !r} )\" def get_first_block ( self ) -> gui . TextBlock : return gui . TextBlock ( self . firstBlock ()) def get_last_block ( self ) -> gui . TextBlock : return gui . TextBlock ( self . lastBlock ()) def find_block_by_number ( self , number : int ) -> gui . TextBlock : block = self . findBlockByNumber ( number ) if not block . isValid (): raise ValueError ( f \" { number } not a valid block index. Block count: { self . blockCount () } \" ) return gui . TextBlock ( block ) def find_block_by_line_number ( self , line_number : int ) -> gui . TextBlock : block = self . findBlockByLineNumber ( line_number ) if not block . isValid (): raise ValueError ( f \" { line_number } not a valid line index. Line count: { self . lineCount () } \" ) return gui . TextBlock ( block ) def set_text ( self , text : str ): self . setPlainText ( text ) def serialize_fields ( self ): return dict ( base_url = self . get_base_url (), default_font = self . get_default_font (), default_stylesheet = self . defaultStyleSheet (), default_text_option = self . get_default_text_option (), document_margin = self . documentMargin (), maximum_block_count = self . maximumBlockCount (), is_modified = self . isModified (), page_size = self . pageSize (), text_width = self . textWidth (), indent_width = self . indentWidth (), undo_redo_enabled = self . isUndoRedoEnabled (), use_design_metrics = self . useDesignMetrics (), ) def get_base_url ( self ) -> core . Url : return core . Url ( self . baseUrl ()) def get_default_font ( self ) -> gui . Font : return gui . Font ( self . defaultFont ()) def set_default_text_option ( self , opt : QtGui . QTextOption ): self . setDefaultTextOption ( gui . TextOption ( opt )) def get_default_text_option ( self ) -> gui . TextOption : return gui . TextOption ( self . defaultTextOption ()) def set_flags ( self , ** flags ): current = self . flags () for k , v in flags . items (): if v : current = current | gui . textoption . FLAG [ k ] else : current = current & ~ gui . textoption . FLAG [ k ] self . setFlags ( current ) # if show: # self.setFlags(self.flags() | QtGui.QTextOption.ShowTabsAndSpaces) # else: # self.setFlags(self.flags() & ~QtGui.QTextOption.ShowTabsAndSpaces) def clear_stacks ( self , stack : StackStr ): \"\"\"Clear undo / redo stack. Args: stack: stack to clear Raises: InvalidParamError: stack type does not exist \"\"\" if stack not in STACKS : raise InvalidParamError ( stack , STACKS ) self . clearUndoRedoStacks ( STACKS [ stack ]) def set_default_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set the cursor move style. Args: style: cursor move style Raises: InvalidParamError: cursor move style does not exist \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setDefaultCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ]) def get_default_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return current cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . defaultCursorMoveStyle ()] def add_resource ( self , resource_type : ResourceTypeStr , name : types . PathType , resource ): if resource_type not in RESOURCE_TYPES : raise InvalidParamError ( resource_type , RESOURCE_TYPES ) url = core . Url ( name ) self . addResource ( RESOURCE_TYPES [ resource_type ], url , resource ) @contextlib . contextmanager def edit_default_stylesheet ( self ) -> Iterator [ qstylizer . style . StyleSheet ]: ss = self . get_default_stylesheet () yield ss self . set_default_stylesheet ( ss ) def set_default_stylesheet ( self , ss : None | str | qstylizer . style . StyleSheet | types . PathType ): if isinstance ( ss , os . PathLike ): ss = pathlib . Path ( ss ) . read_text () elif ss is None : ss = \"\" self . setDefaultStyleSheet ( str ( ss )) def get_default_stylesheet ( self ) -> qstylizer . style . StyleSheet : return qstylizer . parser . parse ( self . defaultStyleSheet ()) def find_line_position ( self , line_no : int ) -> int : lines = self . blockCount () assert 1 <= line_no <= lines return self . findBlockByLineNumber ( line_no - 1 ) . position () def write_to_file ( self , path : types . PathType , fmt : gui . textdocumentwriter . FormatStr | bytes | QtCore . QByteArray = \"plaintext\" , ): writer = gui . TextDocumentWriter () writer . set_format ( fmt ) writer . set_file_name ( path ) return writer . write ( self ) def show_whitespace_and_tabs ( self , show : bool ): \"\"\"Set show white spaces flag.\"\"\" options = self . get_default_text_option () flag = QtGui . QTextOption . Flag . ShowTabsAndSpaces if show : options . setFlags ( options . flags () | flag ) # type: ignore else : options . setFlags ( options . flags () & ~ flag ) # type: ignore self . setDefaultTextOption ( options ) clear_stacks ( self , stack : StackStr ) Clear undo / redo stack. Parameters: Name Type Description Default stack StackStr stack to clear required Exceptions: Type Description InvalidParamError stack type does not exist Source code in prettyqt/gui/textdocument.py def clear_stacks ( self , stack : StackStr ): \"\"\"Clear undo / redo stack. Args: stack: stack to clear Raises: InvalidParamError: stack type does not exist \"\"\" if stack not in STACKS : raise InvalidParamError ( stack , STACKS ) self . clearUndoRedoStacks ( STACKS [ stack ]) get_default_cursor_move_style ( self ) -> constants . CursorMoveStyleStr Return current cursor move style. Returns: Type Description constants.CursorMoveStyleStr cursor move style Source code in prettyqt/gui/textdocument.py def get_default_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return current cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . defaultCursorMoveStyle ()] set_default_cursor_move_style ( self , style : constants . CursorMoveStyleStr ) Set the cursor move style. Parameters: Name Type Description Default style constants.CursorMoveStyleStr cursor move style required Exceptions: Type Description InvalidParamError cursor move style does not exist Source code in prettyqt/gui/textdocument.py def set_default_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set the cursor move style. Args: style: cursor move style Raises: InvalidParamError: cursor move style does not exist \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setDefaultCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ]) show_whitespace_and_tabs ( self , show : bool ) Set show white spaces flag. Source code in prettyqt/gui/textdocument.py def show_whitespace_and_tabs ( self , show : bool ): \"\"\"Set show white spaces flag.\"\"\" options = self . get_default_text_option () flag = QtGui . QTextOption . Flag . ShowTabsAndSpaces if show : options . setFlags ( options . flags () | flag ) # type: ignore else : options . setFlags ( options . flags () & ~ flag ) # type: ignore self . setDefaultTextOption ( options ) textformat TextFormat ( QTextFormat ) Source code in prettyqt/gui/textformat.py class TextFormat ( QtGui . QTextFormat ): def __getitem__ ( self , key : int ): return self . property ( key ) def __setitem__ ( self , key : int , value ): self . setProperty ( key , value ) def __contains__ ( self , key : int ): return self . hasProperty ( key ) def __bool__ ( self ): return self . isValid () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . type () } )\" def get_background ( self ) -> gui . Brush : return gui . Brush ( self . background ()) def get_foreground ( self ) -> gui . Brush : return gui . Brush ( self . foreground ()) def get_brush_property ( self , property_id : int ) -> gui . Brush : return gui . Brush ( self . brushProperty ( property_id )) def get_color_property ( self , property_id : int ) -> gui . Color : return gui . Color ( self . colorProperty ( property_id )) def get_pen_property ( self , property_id : int ) -> gui . Pen : return gui . Pen ( self . penProperty ( property_id )) def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ]) def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()] def select_full_width ( self , value : bool = True ): prop = QtGui . QTextFormat . Property . FullWidthSelection self . setProperty ( prop , value ) # type: ignore get_layout_direction ( self ) -> constants . LayoutDirectionStr Get the current layout direction. Returns: Type Description constants.LayoutDirectionStr layout direction Source code in prettyqt/gui/textformat.py def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()] set_layout_direction ( self , direction : constants . LayoutDirectionStr ) Set layout direction. Parameters: Name Type Description Default direction constants.LayoutDirectionStr layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/textformat.py def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ]) textframeformat TextFrameFormat ( QTextFrameFormat ) Source code in prettyqt/gui/textframeformat.py class TextFrameFormat ( QtGui . QTextFrameFormat ): def get_height ( self ) -> gui . TextLength : length = self . height () return gui . TextLength ( length . type (), length . rawValue ()) def get_width ( self ) -> gui . TextLength : length = self . width () return gui . TextLength ( length . type (), length . rawValue ()) def get_border_brush ( self ) -> gui . Brush : return gui . Brush ( self . borderBrush ()) def set_border_style ( self , style : BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in BORDER_STYLES : raise InvalidParamError ( style , BORDER_STYLES ) self . setBorderStyle ( BORDER_STYLES [ style ]) def get_border_style ( self ) -> BorderStyleStr : \"\"\"Get the current border style. Returns: border style \"\"\" return BORDER_STYLES . inverse [ self . borderStyle ()] def set_page_break_policy ( self , policy : gui . textformat . PageBreakFlagStr ): \"\"\"Set page break policy. Args: policy: page break policy Raises: InvalidParamError: page break policy does not exist \"\"\" if policy not in gui . textformat . PAGE_BREAK_FLAG : raise InvalidParamError ( policy , gui . textformat . PAGE_BREAK_FLAG ) self . setPageBreakPolicy ( gui . textformat . PAGE_BREAK_FLAG [ policy ]) def get_page_break_policy ( self ) -> gui . textformat . PageBreakFlagStr : \"\"\"Get the current page break policy. Returns: page break policy \"\"\" return gui . textformat . PAGE_BREAK_FLAG . inverse [ self . pageBreakPolicy ()] def set_position ( self , position : PositionStr ): \"\"\"Set position. Args: position: position Raises: InvalidParamError: position does not exist \"\"\" if position not in POSITIONS : raise InvalidParamError ( position , POSITIONS ) self . setPosition ( POSITIONS [ position ]) def get_position ( self ) -> PositionStr : \"\"\"Get the current position. Returns: position \"\"\" return POSITIONS . inverse [ self . position ()] get_border_style ( self ) -> BorderStyleStr Get the current border style. Returns: Type Description BorderStyleStr border style Source code in prettyqt/gui/textframeformat.py def get_border_style ( self ) -> BorderStyleStr : \"\"\"Get the current border style. Returns: border style \"\"\" return BORDER_STYLES . inverse [ self . borderStyle ()] get_page_break_policy ( self ) -> gui . textformat . PageBreakFlagStr Get the current page break policy. Returns: Type Description gui.textformat.PageBreakFlagStr page break policy Source code in prettyqt/gui/textframeformat.py def get_page_break_policy ( self ) -> gui . textformat . PageBreakFlagStr : \"\"\"Get the current page break policy. Returns: page break policy \"\"\" return gui . textformat . PAGE_BREAK_FLAG . inverse [ self . pageBreakPolicy ()] get_position ( self ) -> PositionStr Get the current position. Returns: Type Description PositionStr position Source code in prettyqt/gui/textframeformat.py def get_position ( self ) -> PositionStr : \"\"\"Get the current position. Returns: position \"\"\" return POSITIONS . inverse [ self . position ()] set_border_style ( self , style : BorderStyleStr ) Set border style. Parameters: Name Type Description Default style BorderStyleStr border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/textframeformat.py def set_border_style ( self , style : BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in BORDER_STYLES : raise InvalidParamError ( style , BORDER_STYLES ) self . setBorderStyle ( BORDER_STYLES [ style ]) set_page_break_policy ( self , policy : gui . textformat . PageBreakFlagStr ) Set page break policy. Parameters: Name Type Description Default policy gui.textformat.PageBreakFlagStr page break policy required Exceptions: Type Description InvalidParamError page break policy does not exist Source code in prettyqt/gui/textframeformat.py def set_page_break_policy ( self , policy : gui . textformat . PageBreakFlagStr ): \"\"\"Set page break policy. Args: policy: page break policy Raises: InvalidParamError: page break policy does not exist \"\"\" if policy not in gui . textformat . PAGE_BREAK_FLAG : raise InvalidParamError ( policy , gui . textformat . PAGE_BREAK_FLAG ) self . setPageBreakPolicy ( gui . textformat . PAGE_BREAK_FLAG [ policy ]) set_position ( self , position : PositionStr ) Set position. Parameters: Name Type Description Default position PositionStr position required Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/gui/textframeformat.py def set_position ( self , position : PositionStr ): \"\"\"Set position. Args: position: position Raises: InvalidParamError: position does not exist \"\"\" if position not in POSITIONS : raise InvalidParamError ( position , POSITIONS ) self . setPosition ( POSITIONS [ position ]) textlength TextLength ( QTextLength ) Source code in prettyqt/gui/textlength.py class TextLength ( QtGui . QTextLength ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . type () } , { self . rawValue () } )\" def get_type ( self ) -> TypeStr : \"\"\"Return type of this length object. Returns: timer type \"\"\" return TYPES . inverse [ self . type ()] get_type ( self ) -> TypeStr Return type of this length object. Returns: Type Description TypeStr timer type Source code in prettyqt/gui/textlength.py def get_type ( self ) -> TypeStr : \"\"\"Return type of this length object. Returns: timer type \"\"\" return TYPES . inverse [ self . type ()] textlistformat TextListFormat ( QTextListFormat ) Source code in prettyqt/gui/textlistformat.py class TextListFormat ( QtGui . QTextListFormat ): def set_style ( self , style : StyleStr ): \"\"\"Set the style. Args: style: style Raises: InvalidParamError: invalid style \"\"\" if style not in STYLES : raise InvalidParamError ( style , STYLES ) self . setStyle ( STYLES [ style ]) def get_style ( self ) -> StyleStr : \"\"\"Get current style. Returns: current style \"\"\" return STYLES . inverse [ self . style ()] get_style ( self ) -> StyleStr Get current style. Returns: Type Description StyleStr current style Source code in prettyqt/gui/textlistformat.py def get_style ( self ) -> StyleStr : \"\"\"Get current style. Returns: current style \"\"\" return STYLES . inverse [ self . style ()] set_style ( self , style : StyleStr ) Set the style. Parameters: Name Type Description Default style StyleStr style required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/gui/textlistformat.py def set_style ( self , style : StyleStr ): \"\"\"Set the style. Args: style: style Raises: InvalidParamError: invalid style \"\"\" if style not in STYLES : raise InvalidParamError ( style , STYLES ) self . setStyle ( STYLES [ style ]) texttablecellformat TextTableCellFormat ( QTextTableCellFormat ) Source code in prettyqt/gui/texttablecellformat.py class TextTableCellFormat ( QtGui . QTextTableCellFormat ): def get_bottom_border_brush ( self ) -> gui . Brush : return gui . Brush ( self . bottomBorderBrush ()) def set_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) def set_bottom_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set bottom border style. Args: style: bottom border style Raises: InvalidParamError: bottom border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBottomBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) def get_bottom_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current bottom border style. Returns: bottom border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . bottomBorderStyle ()] def get_left_border_brush ( self ) -> gui . Brush : return gui . Brush ( self . leftBorderBrush ()) def set_left_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set left border style. Args: style: left border style Raises: InvalidParamError: left border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setLeftBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) def get_left_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current left border style. Returns: left border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . leftBorderStyle ()] def get_right_border_brush ( self ) -> gui . Brush : return gui . Brush ( self . rightBorderBrush ()) def set_right_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set right border style. Args: style: right border style Raises: InvalidParamError: right border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setRightBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) def get_right_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current right border style. Returns: right border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . rightBorderStyle ()] def get_top_border_brush ( self ) -> gui . Brush : return gui . Brush ( self . topBorderBrush ()) def set_top_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set top border style. Args: style: top border style Raises: InvalidParamError: top border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setTopBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) def get_top_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current top border style. Returns: top border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . topBorderStyle ()] get_bottom_border_style ( self ) -> gui . textframeformat . BorderStyleStr Get the current bottom border style. Returns: Type Description gui.textframeformat.BorderStyleStr bottom border style Source code in prettyqt/gui/texttablecellformat.py def get_bottom_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current bottom border style. Returns: bottom border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . bottomBorderStyle ()] get_left_border_style ( self ) -> gui . textframeformat . BorderStyleStr Get the current left border style. Returns: Type Description gui.textframeformat.BorderStyleStr left border style Source code in prettyqt/gui/texttablecellformat.py def get_left_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current left border style. Returns: left border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . leftBorderStyle ()] get_right_border_style ( self ) -> gui . textframeformat . BorderStyleStr Get the current right border style. Returns: Type Description gui.textframeformat.BorderStyleStr right border style Source code in prettyqt/gui/texttablecellformat.py def get_right_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current right border style. Returns: right border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . rightBorderStyle ()] get_top_border_style ( self ) -> gui . textframeformat . BorderStyleStr Get the current top border style. Returns: Type Description gui.textframeformat.BorderStyleStr top border style Source code in prettyqt/gui/texttablecellformat.py def get_top_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current top border style. Returns: top border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . topBorderStyle ()] set_border_style ( self , style : gui . textframeformat . BorderStyleStr ) Set border style. Parameters: Name Type Description Default style gui.textframeformat.BorderStyleStr border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_bottom_border_style ( self , style : gui . textframeformat . BorderStyleStr ) Set bottom border style. Parameters: Name Type Description Default style gui.textframeformat.BorderStyleStr bottom border style required Exceptions: Type Description InvalidParamError bottom border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_bottom_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set bottom border style. Args: style: bottom border style Raises: InvalidParamError: bottom border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBottomBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_left_border_style ( self , style : gui . textframeformat . BorderStyleStr ) Set left border style. Parameters: Name Type Description Default style gui.textframeformat.BorderStyleStr left border style required Exceptions: Type Description InvalidParamError left border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_left_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set left border style. Args: style: left border style Raises: InvalidParamError: left border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setLeftBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_right_border_style ( self , style : gui . textframeformat . BorderStyleStr ) Set right border style. Parameters: Name Type Description Default style gui.textframeformat.BorderStyleStr right border style required Exceptions: Type Description InvalidParamError right border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_right_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set right border style. Args: style: right border style Raises: InvalidParamError: right border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setRightBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_top_border_style ( self , style : gui . textframeformat . BorderStyleStr ) Set top border style. Parameters: Name Type Description Default style gui.textframeformat.BorderStyleStr top border style required Exceptions: Type Description InvalidParamError top border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_top_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set top border style. Args: style: top border style Raises: InvalidParamError: top border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setTopBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) validator Validator ( QValidator ) Source code in prettyqt/gui/validator.py class Validator ( QtGui . QValidator ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def __add__ ( self , other : Validator ): from prettyqt import custom_validators return custom_validators . CompositeValidator ([ self , other ]) def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other ) def is_valid_value ( self , value : str , pos : int = 0 ) -> bool : val = self . validate ( value , pos ) return val [ 0 ] == self . State . Acceptable # type: ignore __radd__ ( self , other : QtGui . QValidator ) special Needed for sum(). Source code in prettyqt/gui/validator.py def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other ) window Window ( QWindow ) Source code in prettyqt/gui/window.py class Window ( QtGui . QWindow ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" # def serialize_fields(self): # return dict( # speed=self.speed(), # visibility=self.get_visibility(), # scaled_size=self.scaledSize(), # background_color=self.backgroundColor(), # ) def set_visibility ( self , visibility : VisibilityStr ): \"\"\"Set window visibility. Args: visibility: window visibility Raises: InvalidParamError: window visibility does not exist \"\"\" if visibility not in VISIBILITY : raise InvalidParamError ( visibility , VISIBILITY ) self . setVisibility ( VISIBILITY [ visibility ]) def get_visibility ( self ) -> VisibilityStr : \"\"\"Get the current window visibility. Returns: window visibility \"\"\" return VISIBILITY . inverse [ self . visibility ()] def start_system_resize ( self , edge : constants . EdgeStr ) -> bool : \"\"\"Start system resize. Args: edge: edge to resize Raises: InvalidParamError: edge does not exist \"\"\" if edge not in constants . EDGES : raise InvalidParamError ( edge , constants . EDGES ) return self . startSystemResize ( constants . EDGES [ edge ]) def get_screen ( self ) -> gui . Screen : return gui . Screen ( self . screen ()) get_visibility ( self ) -> VisibilityStr Get the current window visibility. Returns: Type Description VisibilityStr window visibility Source code in prettyqt/gui/window.py def get_visibility ( self ) -> VisibilityStr : \"\"\"Get the current window visibility. Returns: window visibility \"\"\" return VISIBILITY . inverse [ self . visibility ()] set_visibility ( self , visibility : VisibilityStr ) Set window visibility. Parameters: Name Type Description Default visibility VisibilityStr window visibility required Exceptions: Type Description InvalidParamError window visibility does not exist Source code in prettyqt/gui/window.py def set_visibility ( self , visibility : VisibilityStr ): \"\"\"Set window visibility. Args: visibility: window visibility Raises: InvalidParamError: window visibility does not exist \"\"\" if visibility not in VISIBILITY : raise InvalidParamError ( visibility , VISIBILITY ) self . setVisibility ( VISIBILITY [ visibility ]) start_system_resize ( self , edge : constants . EdgeStr ) -> bool Start system resize. Parameters: Name Type Description Default edge constants.EdgeStr edge to resize required Exceptions: Type Description InvalidParamError edge does not exist Source code in prettyqt/gui/window.py def start_system_resize ( self , edge : constants . EdgeStr ) -> bool : \"\"\"Start system resize. Args: edge: edge to resize Raises: InvalidParamError: edge does not exist \"\"\" if edge not in constants . EDGES : raise InvalidParamError ( edge , constants . EDGES ) return self . startSystemResize ( constants . EDGES [ edge ])","title":"gui"},{"location":"api/gui.html#gui-module","text":"Gui module. Contains QtGui-based classes","title":"gui module"},{"location":"api/gui.html#prettyqt.gui.color","text":"","title":"color"},{"location":"api/gui.html#prettyqt.gui.color.Color","text":"Source code in prettyqt/gui/color.py class Color ( QtGui . QColor ): def __init__ ( self , * args ): # PySide2 workaround if len ( args ) == 1 : if isinstance ( args [ 0 ], QtGui . QColor ): super () . __init__ ( args [ 0 ] . name ()) elif isinstance ( args [ 0 ], str ): super () . __init__ () self . set_color ( args [ 0 ]) else : super () . __init__ ( * args ) else : super () . __init__ ( * args ) def __repr__ ( self ): return ( f \" { type ( self ) . __name__ } ( { self . red () } , { self . green () } , \" f \" { self . blue () } , { self . alpha () } )\" ) def __str__ ( self ): return self . name () if self . alpha () == 255 else self . name ( self . NameFormat . HexArgb ) def __reduce__ ( self ): return type ( self ), ( self . red (), self . green (), self . blue (), self . alpha ()) def serialize_fields ( self ): return dict ( color = self . toString ()) def serialize ( self ) -> dict [ str , Any ]: return self . serialize_fields () def set_color ( self , color : str | tuple ): if isinstance ( color , str ): self . setNamedColor ( color ) else : self . setRgb ( * color ) @classmethod def from_text ( cls , text : str ) -> Color : \"\"\"Create a QColor from specified string.\"\"\" color = cls () if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color @classmethod def from_cmyk ( cls , c : float , m : float , y : float , k : float , a : float = 1.0 ) -> Color : return cls ( cls . fromCmykF ( c , m , y , k , a )) @classmethod def from_hsv ( cls , h : float , s : float , v : float , a : float = 1.0 ) -> Color : return cls ( cls . fromHsvF ( h , s , v , a )) @classmethod def interpolate_color ( cls , start : QtGui . QColor , end : QtGui . QColor , percent : int , colorspace : SpecStr | None = \"rgb\" , ) -> Color : \"\"\"Get an interpolated color value. Args: start: The start color. end: The end color. percent: Which value to get (0 - 100) colorspace: The desired interpolation color system, QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum) If None, start is used except when percent is 100. Return: The interpolated QColor, with the same spec as the given start color. \"\"\" if colorspace is None : if percent == 100 : return cls ( * end . getRgb ()) else : return cls ( * start . getRgb ()) if colorspace not in SPEC : raise InvalidParamError ( colorspace , SPEC ) out = cls () if colorspace == \"rgb\" : components = helpers . get_color_percentage ( start . getRgb (), end . getRgb (), percent # type: ignore ) out . setRgb ( * components ) elif colorspace == \"hsv\" : components = helpers . get_color_percentage ( start . getHsv (), end . getHsv (), percent # type: ignore ) out . setHsv ( * components ) elif colorspace == \"hsl\" : components = helpers . get_color_percentage ( start . getHsl (), end . getHsl (), percent # type: ignore ) out . setHsl ( * components ) else : raise ValueError ( \"Invalid colorspace!\" ) out = out . convertTo ( start . spec ()) return out def is_dark ( self ) -> bool : \"\"\"Check whether a color is 'dark'.\"\"\" return self . lightness () < 128 def get_name ( self , name_format : NameStr = \"hex_argb\" ) -> str : if name_format == \"svg_rgb\" : if not self . isValid (): return 'fill=\"\"' return f 'fill=\"rgb( { self . red () } , { self . green () } , { self . blue () } )\"' elif name_format == \"svg_argb\" : if not self . isValid (): return 'fill=\"\"' fill_str = f \"rgb( { self . red () } , { self . green () } , { self . blue () } )\" return f 'fill=\" { fill_str } \" fill-opacity=\" { self . alpha () } \"' elif name_format == \"qcss_argb\" : return f \"rgba( { self . red () } , { self . green () } , { self . blue () } , { self . alpha () } )\" elif name_format == \"qcss_rgb\" : return f \"rgb( { self . red () } , { self . green () } , { self . blue () } )\" else : return self . name ( NAME_FORMAT [ name_format ]) @deprecated ( reason = \"This method is deprecated, use Color.get_name instead.\" ) def to_qsscolor ( self ) -> str : \"\"\"Convert Color to a string that can be used in a QStyleSheet.\"\"\" return f \"rgba( { self . red () } , { self . green () } , { self . blue () } , { self . alpha () } )\" def as_qt ( self ) -> QtGui . QColor : return QtGui . QColor ( self ) def inverted ( self , invert_alpha : bool = False ) -> Color : return Color ( 255 - self . red (), 255 - self . green (), 255 - self . blue (), 255 - self . alpha () if invert_alpha else self . alpha (), ) @classmethod def drift_color ( cls , color : types . ColorAndBrushType , factor : int = 110 ): \"\"\"Return color that is lighter or darker than the base color. If base_color.lightness is higher than 128, the returned color is darker otherwise is is lighter. :param base_color: The base color to drift from ;:param factor: drift factor (%) :return A lighter or darker color. \"\"\" base_color = cls ( color ) if base_color . lightness () > 128 : return base_color . darker ( factor ) else : if base_color == Color ( \"#000000\" ): return cls . drift_color ( cls ( \"#101010\" ), factor + 20 ) else : return base_color . lighter ( factor + 10 )","title":"Color"},{"location":"api/gui.html#prettyqt.gui.color.Color.drift_color","text":"Return color that is lighter or darker than the base color. If base_color.lightness is higher than 128, the returned color is darker otherwise is is lighter. :param base_color: The base color to drift from ;:param factor: drift factor (%) :return A lighter or darker color. Source code in prettyqt/gui/color.py @classmethod def drift_color ( cls , color : types . ColorAndBrushType , factor : int = 110 ): \"\"\"Return color that is lighter or darker than the base color. If base_color.lightness is higher than 128, the returned color is darker otherwise is is lighter. :param base_color: The base color to drift from ;:param factor: drift factor (%) :return A lighter or darker color. \"\"\" base_color = cls ( color ) if base_color . lightness () > 128 : return base_color . darker ( factor ) else : if base_color == Color ( \"#000000\" ): return cls . drift_color ( cls ( \"#101010\" ), factor + 20 ) else : return base_color . lighter ( factor + 10 )","title":"drift_color()"},{"location":"api/gui.html#prettyqt.gui.color.Color.from_text","text":"Create a QColor from specified string. Source code in prettyqt/gui/color.py @classmethod def from_text ( cls , text : str ) -> Color : \"\"\"Create a QColor from specified string.\"\"\" color = cls () if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color","title":"from_text()"},{"location":"api/gui.html#prettyqt.gui.color.Color.interpolate_color","text":"Get an interpolated color value. Parameters: Name Type Description Default start QtGui.QColor The start color. required end QtGui.QColor The end color. required percent int Which value to get (0 - 100) required colorspace SpecStr | None The desired interpolation color system, QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum) If None, start is used except when percent is 100. 'rgb' Returns: Type Description Color The interpolated QColor, with the same spec as the given start color. Source code in prettyqt/gui/color.py @classmethod def interpolate_color ( cls , start : QtGui . QColor , end : QtGui . QColor , percent : int , colorspace : SpecStr | None = \"rgb\" , ) -> Color : \"\"\"Get an interpolated color value. Args: start: The start color. end: The end color. percent: Which value to get (0 - 100) colorspace: The desired interpolation color system, QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum) If None, start is used except when percent is 100. Return: The interpolated QColor, with the same spec as the given start color. \"\"\" if colorspace is None : if percent == 100 : return cls ( * end . getRgb ()) else : return cls ( * start . getRgb ()) if colorspace not in SPEC : raise InvalidParamError ( colorspace , SPEC ) out = cls () if colorspace == \"rgb\" : components = helpers . get_color_percentage ( start . getRgb (), end . getRgb (), percent # type: ignore ) out . setRgb ( * components ) elif colorspace == \"hsv\" : components = helpers . get_color_percentage ( start . getHsv (), end . getHsv (), percent # type: ignore ) out . setHsv ( * components ) elif colorspace == \"hsl\" : components = helpers . get_color_percentage ( start . getHsl (), end . getHsl (), percent # type: ignore ) out . setHsl ( * components ) else : raise ValueError ( \"Invalid colorspace!\" ) out = out . convertTo ( start . spec ()) return out","title":"interpolate_color()"},{"location":"api/gui.html#prettyqt.gui.color.Color.is_dark","text":"Check whether a color is 'dark'. Source code in prettyqt/gui/color.py def is_dark ( self ) -> bool : \"\"\"Check whether a color is 'dark'.\"\"\" return self . lightness () < 128","title":"is_dark()"},{"location":"api/gui.html#prettyqt.gui.color.Color.to_qsscolor","text":"Convert Color to a string that can be used in a QStyleSheet. Source code in prettyqt/gui/color.py @deprecated ( reason = \"This method is deprecated, use Color.get_name instead.\" ) def to_qsscolor ( self ) -> str : \"\"\"Convert Color to a string that can be used in a QStyleSheet.\"\"\" return f \"rgba( { self . red () } , { self . green () } , { self . blue () } , { self . alpha () } )\"","title":"to_qsscolor()"},{"location":"api/gui.html#prettyqt.gui.colorspace","text":"","title":"colorspace"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace","text":"Source code in prettyqt/gui/colorspace.py class ColorSpace ( QtGui . QColorSpace ): def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): super () . __init__ () core . DataStream . write_bytearray ( ba , self ) def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __bool__ ( self ): return self . isValid () def set_primaries ( self , primaries : PrimariesStr ): \"\"\"Set primaries. Args: primaries: primaries to use Raises: InvalidParamError: primaries do not exist \"\"\" if primaries not in PRIMARIES : raise InvalidParamError ( primaries , PRIMARIES ) self . setPrimaries ( PRIMARIES [ primaries ]) def get_primaries ( self ) -> PrimariesStr : \"\"\"Return current primaries. Returns: primaries \"\"\" return PRIMARIES . inverse [ self . primaries ()] def set_transfer_function ( self , fn : TransformFunctionStr , gamma : float = 0.0 ): \"\"\"Set transfer function. Args: fn: transfer function to use Raises: InvalidParamError: transfer function do not exist \"\"\" if fn not in TRANSFER_FUNCTION : raise InvalidParamError ( fn , TRANSFER_FUNCTION ) self . setTransferFunction ( TRANSFER_FUNCTION [ fn ], gamma ) def get_transfer_function ( self ) -> TransformFunctionStr : \"\"\"Return current transfer function. Returns: transfer function \"\"\" return TRANSFER_FUNCTION . inverse [ self . transferFunction ()]","title":"ColorSpace"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_primaries","text":"Return current primaries. Returns: Type Description PrimariesStr primaries Source code in prettyqt/gui/colorspace.py def get_primaries ( self ) -> PrimariesStr : \"\"\"Return current primaries. Returns: primaries \"\"\" return PRIMARIES . inverse [ self . primaries ()]","title":"get_primaries()"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_transfer_function","text":"Return current transfer function. Returns: Type Description TransformFunctionStr transfer function Source code in prettyqt/gui/colorspace.py def get_transfer_function ( self ) -> TransformFunctionStr : \"\"\"Return current transfer function. Returns: transfer function \"\"\" return TRANSFER_FUNCTION . inverse [ self . transferFunction ()]","title":"get_transfer_function()"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_primaries","text":"Set primaries. Parameters: Name Type Description Default primaries PrimariesStr primaries to use required Exceptions: Type Description InvalidParamError primaries do not exist Source code in prettyqt/gui/colorspace.py def set_primaries ( self , primaries : PrimariesStr ): \"\"\"Set primaries. Args: primaries: primaries to use Raises: InvalidParamError: primaries do not exist \"\"\" if primaries not in PRIMARIES : raise InvalidParamError ( primaries , PRIMARIES ) self . setPrimaries ( PRIMARIES [ primaries ])","title":"set_primaries()"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_transfer_function","text":"Set transfer function. Parameters: Name Type Description Default fn TransformFunctionStr transfer function to use required Exceptions: Type Description InvalidParamError transfer function do not exist Source code in prettyqt/gui/colorspace.py def set_transfer_function ( self , fn : TransformFunctionStr , gamma : float = 0.0 ): \"\"\"Set transfer function. Args: fn: transfer function to use Raises: InvalidParamError: transfer function do not exist \"\"\" if fn not in TRANSFER_FUNCTION : raise InvalidParamError ( fn , TRANSFER_FUNCTION ) self . setTransferFunction ( TRANSFER_FUNCTION [ fn ], gamma )","title":"set_transfer_function()"},{"location":"api/gui.html#prettyqt.gui.cursor","text":"","title":"cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor","text":"Source code in prettyqt/gui/cursor.py class Cursor ( QtGui . QCursor ): def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): super () . __init__ () core . DataStream . write_bytearray ( ba , self ) def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def serialize_fields ( self ) -> dict [ str , Any ]: return dict ( shape = self . get_shape ()) def set_shape ( self , shape : constants . CursorShapeStr ): \"\"\"Set cursor shape. Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in constants . CURSOR_SHAPE : raise InvalidParamError ( shape , constants . CURSOR_SHAPE ) self . setShape ( constants . CURSOR_SHAPE [ shape ]) def get_shape ( self ) -> constants . CursorShapeStr : \"\"\"Return current cursor shape. Returns: cursor shape \"\"\" return constants . CURSOR_SHAPE . inverse [ self . shape ()] @classmethod def get_position ( cls ) -> core . Point : return core . Point ( cls . pos ())","title":"Cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.get_shape","text":"Return current cursor shape. Returns: Type Description constants.CursorShapeStr cursor shape Source code in prettyqt/gui/cursor.py def get_shape ( self ) -> constants . CursorShapeStr : \"\"\"Return current cursor shape. Returns: cursor shape \"\"\" return constants . CURSOR_SHAPE . inverse [ self . shape ()]","title":"get_shape()"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.set_shape","text":"Set cursor shape. Parameters: Name Type Description Default shape constants.CursorShapeStr shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/gui/cursor.py def set_shape ( self , shape : constants . CursorShapeStr ): \"\"\"Set cursor shape. Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in constants . CURSOR_SHAPE : raise InvalidParamError ( shape , constants . CURSOR_SHAPE ) self . setShape ( constants . CURSOR_SHAPE [ shape ])","title":"set_shape()"},{"location":"api/gui.html#prettyqt.gui.font","text":"","title":"font"},{"location":"api/gui.html#prettyqt.gui.font.Font","text":"Source code in prettyqt/gui/font.py class Font ( prettyprinter . PrettyPrinter , QtGui . QFont ): def __repr__ ( self ): return ( f \" { type ( self ) . __name__ } ( { self . family () !r} , { self . pointSize () } , \" f \" { self . weight () } , { self . italic () } )\" ) def __getstate__ ( self ): return dict ( family = self . family (), pointsize = self . pointSize (), weight = self . weight (), italic = self . italic (), ) def __setstate__ ( self , state ): self . setFamily ( state [ \"family\" ]) if state [ \"pointsize\" ] > - 1 : self . setPointSize ( state [ \"pointsize\" ]) self . setWeight ( state [ \"weight\" ]) self . setItalic ( state [ \"italic\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def serialize ( self ) -> dict [ str , Any ]: return self . __getstate__ () @property def metrics ( self ): return gui . FontMetrics ( self ) def set_size ( self , size : int ): self . setPointSize ( size ) @classmethod def mono ( cls , size = 8 ): return cls ( \"Consolas\" , size ) # font.setStyleHint() def set_style_hint ( self , hint : StyleHintStr ): \"\"\"Set the style hint. Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ]) def set_weight ( self , weight : WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHT : raise InvalidParamError ( weight , WEIGHT ) self . setWeight ( WEIGHT [ weight ]) def get_weight ( self ) -> WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return WEIGHT . inverse [ self . weight ()] def set_capitalization ( self , capitalization : CapitalizationStr ): \"\"\"Set the font capitalization. Args: capitalization: font capitalization Raises: InvalidParamError: invalid font capitalization \"\"\" if capitalization not in CAPITALIZATION : raise InvalidParamError ( capitalization , CAPITALIZATION ) self . setCapitalization ( CAPITALIZATION [ capitalization ]) def get_capitalization ( self ) -> CapitalizationStr : \"\"\"Get current font capitalization. Returns: current font capitalization \"\"\" return CAPITALIZATION . inverse [ self . capitalization ()] def set_hinting_preference ( self , preference : HintingPreferenceStr ): \"\"\"Set the hinting preference. Args: preference: hinting preference Raises: InvalidParamError: invalid hinting preference \"\"\" if preference not in HINTING_PREFERENCE : raise InvalidParamError ( preference , HINTING_PREFERENCE ) self . setHintingPreference ( HINTING_PREFERENCE [ preference ]) def get_hinting_preference ( self ) -> HintingPreferenceStr : \"\"\"Get current hinting preference. Returns: current hinting preference \"\"\" return HINTING_PREFERENCE . inverse [ self . hintingPreference ()] def set_letter_spacing ( self , typ : SpacingTypeStr , spacing : float ): \"\"\"Set the letter spacing. Args: typ: letter spacing type spacing: spacing Raises: InvalidParamError: invalid letter spacing type \"\"\" if typ not in SPACING_TYPE : raise InvalidParamError ( typ , SPACING_TYPE ) self . setLetterSpacing ( SPACING_TYPE [ typ ], spacing ) def get_letter_spacing_type ( self ) -> SpacingTypeStr : \"\"\"Get current letter spacing type. Returns: current letter spacing type \"\"\" return SPACING_TYPE . inverse [ self . letterSpacingType ()] def set_style ( self , style : StyleStr ): \"\"\"Set the font style. Args: style: font style Raises: InvalidParamError: invalid font style \"\"\" if style not in STYLE : raise InvalidParamError ( style , STYLE ) self . setStyle ( STYLE [ style ]) def get_style ( self ) -> StyleStr : \"\"\"Get current font style. Returns: current font style \"\"\" return STYLE . inverse [ self . style ()] def set_family ( self , family : str , fallback : str | None = None ): \"\"\"Set the font family. Args: family: font family fallback: fallback font family \"\"\" self . setFamily ( family ) font_info = gui . FontInfo ( self ) if fallback is not None and font_info . family () != family : self . setFamily ( fallback )","title":"Font"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_capitalization","text":"Get current font capitalization. Returns: Type Description CapitalizationStr current font capitalization Source code in prettyqt/gui/font.py def get_capitalization ( self ) -> CapitalizationStr : \"\"\"Get current font capitalization. Returns: current font capitalization \"\"\" return CAPITALIZATION . inverse [ self . capitalization ()]","title":"get_capitalization()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_hinting_preference","text":"Get current hinting preference. Returns: Type Description HintingPreferenceStr current hinting preference Source code in prettyqt/gui/font.py def get_hinting_preference ( self ) -> HintingPreferenceStr : \"\"\"Get current hinting preference. Returns: current hinting preference \"\"\" return HINTING_PREFERENCE . inverse [ self . hintingPreference ()]","title":"get_hinting_preference()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_letter_spacing_type","text":"Get current letter spacing type. Returns: Type Description SpacingTypeStr current letter spacing type Source code in prettyqt/gui/font.py def get_letter_spacing_type ( self ) -> SpacingTypeStr : \"\"\"Get current letter spacing type. Returns: current letter spacing type \"\"\" return SPACING_TYPE . inverse [ self . letterSpacingType ()]","title":"get_letter_spacing_type()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_style","text":"Get current font style. Returns: Type Description StyleStr current font style Source code in prettyqt/gui/font.py def get_style ( self ) -> StyleStr : \"\"\"Get current font style. Returns: current font style \"\"\" return STYLE . inverse [ self . style ()]","title":"get_style()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_weight","text":"Get current font weight. Returns: Type Description WeightStr current font weight Source code in prettyqt/gui/font.py def get_weight ( self ) -> WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return WEIGHT . inverse [ self . weight ()]","title":"get_weight()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_capitalization","text":"Set the font capitalization. Parameters: Name Type Description Default capitalization CapitalizationStr font capitalization required Exceptions: Type Description InvalidParamError invalid font capitalization Source code in prettyqt/gui/font.py def set_capitalization ( self , capitalization : CapitalizationStr ): \"\"\"Set the font capitalization. Args: capitalization: font capitalization Raises: InvalidParamError: invalid font capitalization \"\"\" if capitalization not in CAPITALIZATION : raise InvalidParamError ( capitalization , CAPITALIZATION ) self . setCapitalization ( CAPITALIZATION [ capitalization ])","title":"set_capitalization()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_family","text":"Set the font family. Parameters: Name Type Description Default family str font family required fallback str | None fallback font family None Source code in prettyqt/gui/font.py def set_family ( self , family : str , fallback : str | None = None ): \"\"\"Set the font family. Args: family: font family fallback: fallback font family \"\"\" self . setFamily ( family ) font_info = gui . FontInfo ( self ) if fallback is not None and font_info . family () != family : self . setFamily ( fallback )","title":"set_family()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_hinting_preference","text":"Set the hinting preference. Parameters: Name Type Description Default preference HintingPreferenceStr hinting preference required Exceptions: Type Description InvalidParamError invalid hinting preference Source code in prettyqt/gui/font.py def set_hinting_preference ( self , preference : HintingPreferenceStr ): \"\"\"Set the hinting preference. Args: preference: hinting preference Raises: InvalidParamError: invalid hinting preference \"\"\" if preference not in HINTING_PREFERENCE : raise InvalidParamError ( preference , HINTING_PREFERENCE ) self . setHintingPreference ( HINTING_PREFERENCE [ preference ])","title":"set_hinting_preference()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_letter_spacing","text":"Set the letter spacing. Parameters: Name Type Description Default typ SpacingTypeStr letter spacing type required spacing float spacing required Exceptions: Type Description InvalidParamError invalid letter spacing type Source code in prettyqt/gui/font.py def set_letter_spacing ( self , typ : SpacingTypeStr , spacing : float ): \"\"\"Set the letter spacing. Args: typ: letter spacing type spacing: spacing Raises: InvalidParamError: invalid letter spacing type \"\"\" if typ not in SPACING_TYPE : raise InvalidParamError ( typ , SPACING_TYPE ) self . setLetterSpacing ( SPACING_TYPE [ typ ], spacing )","title":"set_letter_spacing()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style","text":"Set the font style. Parameters: Name Type Description Default style StyleStr font style required Exceptions: Type Description InvalidParamError invalid font style Source code in prettyqt/gui/font.py def set_style ( self , style : StyleStr ): \"\"\"Set the font style. Args: style: font style Raises: InvalidParamError: invalid font style \"\"\" if style not in STYLE : raise InvalidParamError ( style , STYLE ) self . setStyle ( STYLE [ style ])","title":"set_style()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style_hint","text":"Set the style hint. Parameters: Name Type Description Default hint StyleHintStr style hint required Exceptions: Type Description InvalidParamError invalid style hint Source code in prettyqt/gui/font.py def set_style_hint ( self , hint : StyleHintStr ): \"\"\"Set the style hint. Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ])","title":"set_style_hint()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_weight","text":"Set the font weight. Parameters: Name Type Description Default weight WeightStr font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/font.py def set_weight ( self , weight : WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHT : raise InvalidParamError ( weight , WEIGHT ) self . setWeight ( WEIGHT [ weight ])","title":"set_weight()"},{"location":"api/gui.html#prettyqt.gui.gradient","text":"","title":"gradient"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient","text":"Source code in prettyqt/gui/gradient.py class Gradient ( prettyprinter . PrettyPrinter , QtGui . QGradient ): def __setitem__ ( self , key : float , value ): self . setColorAt ( key , value ) def serialize_fields ( self ): return dict ( coordinate_mode = self . get_coordinate_mode (), spread = self . get_spread (), stops = self . get_stops (), ) def serialize ( self ) -> dict [ str , Any ]: return self . serialize_fields () def set_coordinate_mode ( self , mode : CoordinateModeStr ): \"\"\"Set the coordinate mode. Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODE : raise InvalidParamError ( mode , COORDINATE_MODE ) self . setCoordinateMode ( COORDINATE_MODE [ mode ]) def get_coordinate_mode ( self ) -> CoordinateModeStr : \"\"\"Return current coordinate mode. Returns: coordinate mode \"\"\" return COORDINATE_MODE . inverse [ self . coordinateMode ()] def set_spread ( self , method : SpreadStr ): \"\"\"Set the spread method. Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREAD : raise InvalidParamError ( method , SPREAD ) self . setSpread ( SPREAD [ method ]) def get_spread ( self ) -> SpreadStr : \"\"\"Return current spread method. Returns: spread method \"\"\" return SPREAD . inverse [ self . spread ()] def get_type ( self ) -> TypeStr : \"\"\"Return current gradient type. Returns: gradient type \"\"\" return TYPE . inverse [ self . type ()] def get_stops ( self ) -> list [ tuple [ float , gui . Color ]]: return [( i , gui . Color ( j )) for ( i , j ) in self . stops ()]","title":"Gradient"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_coordinate_mode","text":"Return current coordinate mode. Returns: Type Description CoordinateModeStr coordinate mode Source code in prettyqt/gui/gradient.py def get_coordinate_mode ( self ) -> CoordinateModeStr : \"\"\"Return current coordinate mode. Returns: coordinate mode \"\"\" return COORDINATE_MODE . inverse [ self . coordinateMode ()]","title":"get_coordinate_mode()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_spread","text":"Return current spread method. Returns: Type Description SpreadStr spread method Source code in prettyqt/gui/gradient.py def get_spread ( self ) -> SpreadStr : \"\"\"Return current spread method. Returns: spread method \"\"\" return SPREAD . inverse [ self . spread ()]","title":"get_spread()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_type","text":"Return current gradient type. Returns: Type Description TypeStr gradient type Source code in prettyqt/gui/gradient.py def get_type ( self ) -> TypeStr : \"\"\"Return current gradient type. Returns: gradient type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.set_coordinate_mode","text":"Set the coordinate mode. Parameters: Name Type Description Default mode CoordinateModeStr coordinate mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/gradient.py def set_coordinate_mode ( self , mode : CoordinateModeStr ): \"\"\"Set the coordinate mode. Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODE : raise InvalidParamError ( mode , COORDINATE_MODE ) self . setCoordinateMode ( COORDINATE_MODE [ mode ])","title":"set_coordinate_mode()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.set_spread","text":"Set the spread method. Parameters: Name Type Description Default method SpreadStr spread method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/gui/gradient.py def set_spread ( self , method : SpreadStr ): \"\"\"Set the spread method. Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREAD : raise InvalidParamError ( method , SPREAD ) self . setSpread ( SPREAD [ method ])","title":"set_spread()"},{"location":"api/gui.html#prettyqt.gui.guiapplication","text":"","title":"guiapplication"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication","text":"Source code in prettyqt/gui/guiapplication.py class GuiApplication ( QtGui . QGuiApplication ): def serialize_fields ( self ): return dict ( icon = self . get_icon ()) @classmethod @contextlib . contextmanager def override_cursor ( cls , cursor : constants . CursorShapeStr ): cls . set_override_cursor ( cursor ) yield cursor cls . restore_override_cursor () @classmethod def set_override_cursor ( cls , cursor : constants . CursorShapeStr ): crs = gui . Cursor ( constants . CURSOR_SHAPE [ cursor ]) cls . setOverrideCursor ( crs ) @classmethod def restore_override_cursor ( cls ): cls . restoreOverrideCursor () @classmethod def get_clipboard ( cls ) -> gui . Clipboard : return gui . Clipboard ( cls . clipboard ()) @classmethod @contextlib . contextmanager def edit_palette ( cls ) -> Iterator [ gui . Palette ]: palette = gui . Palette ( cls . palette ()) yield palette cls . setPalette ( palette ) def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ]) def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()] @classmethod def set_high_dpi_scale_factor_rounding_policy ( cls , policy : constants . HighDpiScaleFactorRoundingPolicyStr ): \"\"\"Set high dpi scale factor rounding policy. Args: policy: rounding policy Raises: InvalidParamError: rounding policy does not exist \"\"\" if policy not in constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY : raise InvalidParamError ( policy , constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY ) cls . setHighDpiScaleFactorRoundingPolicy ( constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY [ policy ] ) @classmethod def get_high_dpi_scale_factor_rounding_policy ( cls , ) -> constants . HighDpiScaleFactorRoundingPolicyStr : \"\"\"Get the current high dpi scale factor rounding policy. Returns: rounding policy \"\"\" return constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY . inverse [ cls . highDpiScaleFactorRoundingPolicy () ] @classmethod def get_application_state ( cls ) -> list [ constants . ApplicationStateStr ]: \"\"\"Get the current application state. Returns: application state \"\"\" return [ k for k , v in constants . APPLICATION_STATES . items () if v & cls . applicationState () # type: ignore ] def get_primary_screen ( self ) -> gui . Screen : return gui . Screen ( self . primaryScreen ()) def get_screen_at ( self , point : types . PointType ) -> gui . Screen : if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) return gui . Screen ( self . screenAt ( point )) def get_screens ( self ) -> list [ gui . Screen ]: return [ gui . Screen ( i ) for i in self . screens ()] @classmethod def get_input_method ( cls ) -> gui . InputMethod : return gui . InputMethod ( cls . inputMethod ()) @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Mode . Clipboard ) cb . setText ( text , mode = cb . Mode . Clipboard ) @classmethod def get_font ( cls ) -> gui . Font : return gui . Font ( cls . font ()) def set_icon ( self , icon : types . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) def get_icon ( self ) -> gui . Icon | None : icon = self . windowIcon () if icon . isNull (): return None return gui . Icon ( self . windowIcon ()) @classmethod def set_palette ( cls , palette : constants . ThemeStr | QtGui . QPalette ): if palette == \"default\" : pal = gui . Palette () elif palette == \"dark\" : pal = gui . Palette . create_dark_palette () else : pal = palette cls . setPalette ( pal ) @classmethod def get_palette ( cls ) -> gui . Palette : return gui . Palette ( cls . palette ())","title":"GuiApplication"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.copy_to_clipboard","text":"Sets clipboard to supplied text. Source code in prettyqt/gui/guiapplication.py @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Mode . Clipboard ) cb . setText ( text , mode = cb . Mode . Clipboard )","title":"copy_to_clipboard()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.get_application_state","text":"Get the current application state. Returns: Type Description list[constants.ApplicationStateStr] application state Source code in prettyqt/gui/guiapplication.py @classmethod def get_application_state ( cls ) -> list [ constants . ApplicationStateStr ]: \"\"\"Get the current application state. Returns: application state \"\"\" return [ k for k , v in constants . APPLICATION_STATES . items () if v & cls . applicationState () # type: ignore ]","title":"get_application_state()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.get_high_dpi_scale_factor_rounding_policy","text":"Get the current high dpi scale factor rounding policy. Returns: Type Description constants.HighDpiScaleFactorRoundingPolicyStr rounding policy Source code in prettyqt/gui/guiapplication.py @classmethod def get_high_dpi_scale_factor_rounding_policy ( cls , ) -> constants . HighDpiScaleFactorRoundingPolicyStr : \"\"\"Get the current high dpi scale factor rounding policy. Returns: rounding policy \"\"\" return constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY . inverse [ cls . highDpiScaleFactorRoundingPolicy () ]","title":"get_high_dpi_scale_factor_rounding_policy()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.get_layout_direction","text":"Get the current layout direction. Returns: Type Description constants.LayoutDirectionStr layout direction Source code in prettyqt/gui/guiapplication.py def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()]","title":"get_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.set_high_dpi_scale_factor_rounding_policy","text":"Set high dpi scale factor rounding policy. Parameters: Name Type Description Default policy constants.HighDpiScaleFactorRoundingPolicyStr rounding policy required Exceptions: Type Description InvalidParamError rounding policy does not exist Source code in prettyqt/gui/guiapplication.py @classmethod def set_high_dpi_scale_factor_rounding_policy ( cls , policy : constants . HighDpiScaleFactorRoundingPolicyStr ): \"\"\"Set high dpi scale factor rounding policy. Args: policy: rounding policy Raises: InvalidParamError: rounding policy does not exist \"\"\" if policy not in constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY : raise InvalidParamError ( policy , constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY ) cls . setHighDpiScaleFactorRoundingPolicy ( constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY [ policy ] )","title":"set_high_dpi_scale_factor_rounding_policy()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.set_icon","text":"Set the default window icon. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/gui/guiapplication.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.set_layout_direction","text":"Set layout direction. Parameters: Name Type Description Default direction constants.LayoutDirectionStr layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/guiapplication.py def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ])","title":"set_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.icon","text":"","title":"icon"},{"location":"api/gui.html#prettyqt.gui.icon.Icon","text":"Source code in prettyqt/gui/icon.py class Icon ( QtGui . QIcon ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def __bool__ ( self ): return not self . isNull () def __getstate__ ( self ): pixmap = self . pixmap ( 256 , 256 ) return bytes ( core . DataStream . create_bytearray ( pixmap )) def __setstate__ ( self , ba ): px = QtGui . QPixmap () core . DataStream . write_bytearray ( ba , px ) super () . __init__ ( px ) @classmethod def for_color ( cls , color_str : str ) -> Icon : color = gui . Color . from_text ( color_str ) if not color . isValid (): raise TypeError () bitmap = gui . Pixmap ( 16 , 16 ) bitmap . fill ( color ) return cls ( bitmap ) @classmethod def from_char ( cls , char : str , background = \"black\" , color = \"white\" ): \"\"\"Create a QIcon with a given character.\"\"\" icon = cls () for size in ( 16 , 32 , 64 ): px = gui . Pixmap . create_char ( char , background = background , color = color , size = size ) icon . addPixmap ( px ) return icon @classmethod def from_image ( cls , image : QtGui . QImage ): return cls ( gui . Pixmap . fromImage ( image )) def get_available_sizes ( self , mode : ModeStr = \"normal\" , state : StateStr = \"off\" ) -> list [ core . Size ]: if mode not in MODE : raise InvalidParamError ( mode , MODE ) if state not in STATE : raise InvalidParamError ( state , STATE ) return [ core . Size ( i ) for i in self . availableSizes ( MODE [ mode ], STATE [ state ])] def add_pixmap ( self , data : QtCore . QByteArray | QtGui . QPixmap | bytes , mode : ModeStr = \"normal\" , state : StateStr = \"off\" , ): if mode not in MODE : raise InvalidParamError ( mode , MODE ) if state not in STATE : raise InvalidParamError ( state , STATE ) if isinstance ( data , bytes ): data = QtCore . QByteArray ( data ) if isinstance ( data , QtCore . QByteArray ): pixmap = QtGui . QPixmap () pixmap . loadFromData ( data ) else : pixmap = data self . addPixmap ( pixmap , MODE [ mode ], STATE [ state ]) def get_pixmap ( self , size : types . SizeType | int , mode : ModeStr = \"normal\" , state : StateStr = \"off\" , ) -> QtGui . QPixmap : if mode not in MODE : raise InvalidParamError ( mode , MODE ) if state not in STATE : raise InvalidParamError ( state , STATE ) if isinstance ( size , tuple ): size = core . Size ( * size ) elif isinstance ( size , int ): size = core . Size ( size , size ) return self . pixmap ( size , MODE [ mode ], STATE [ state ]) def get_actual_size ( self , size : types . SizeType | int , mode : ModeStr = \"normal\" , state : StateStr = \"off\" , ) -> core . Size : if mode not in MODE : raise InvalidParamError ( mode , MODE ) if state not in STATE : raise InvalidParamError ( state , STATE ) if isinstance ( size , tuple ): size = core . Size ( * size ) elif isinstance ( size , int ): size = core . Size ( size , size ) return core . Size ( self . actualSize ( size , MODE [ mode ], STATE [ state ]))","title":"Icon"},{"location":"api/gui.html#prettyqt.gui.icon.Icon.from_char","text":"Create a QIcon with a given character. Source code in prettyqt/gui/icon.py @classmethod def from_char ( cls , char : str , background = \"black\" , color = \"white\" ): \"\"\"Create a QIcon with a given character.\"\"\" icon = cls () for size in ( 16 , 32 , 64 ): px = gui . Pixmap . create_char ( char , background = background , color = color , size = size ) icon . addPixmap ( px ) return icon","title":"from_char()"},{"location":"api/gui.html#prettyqt.gui.imageiohandler","text":"","title":"imageiohandler"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler","text":"Source code in prettyqt/gui/imageiohandler.py class ImageIOHandler ( mod ): def __getitem__ ( self , key : ImageOptionStr ) -> types . Variant : return self . get_option ( key ) def __setitem__ ( self , key : ImageOptionStr , value : types . Variant ): self . set_option ( key , value ) def get_format ( self ) -> str : return bytes ( self . format ()) . decode () def set_option ( self , option : ImageOptionStr , value : types . Variant ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) self . setOption ( IMAGE_OPTION [ option ], value ) def get_option ( self , option : ImageOptionStr ) -> types . Variant : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . option ( IMAGE_OPTION [ option ]) def supports_option ( self , option : ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . supportsOption ( IMAGE_OPTION [ option ])","title":"ImageIOHandler"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.get_option","text":"Return the value assigned to option. Parameters: Name Type Description Default option ImageOptionStr option to get required Returns: Type Description types.Variant option Source code in prettyqt/gui/imageiohandler.py def get_option ( self , option : ImageOptionStr ) -> types . Variant : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . option ( IMAGE_OPTION [ option ])","title":"get_option()"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.set_option","text":"Set option to given value. Parameters: Name Type Description Default option ImageOptionStr option to use required value types.Variant value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/gui/imageiohandler.py def set_option ( self , option : ImageOptionStr , value : types . Variant ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) self . setOption ( IMAGE_OPTION [ option ], value )","title":"set_option()"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.supports_option","text":"Return whether the image handler supports given option. Parameters: Name Type Description Default option ImageOptionStr option to check required Returns: Type Description bool option Source code in prettyqt/gui/imageiohandler.py def supports_option ( self , option : ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . supportsOption ( IMAGE_OPTION [ option ])","title":"supports_option()"},{"location":"api/gui.html#prettyqt.gui.imagereader","text":"","title":"imagereader"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader","text":"Source code in prettyqt/gui/imagereader.py class ImageReader ( QtGui . QImageReader ): def __getitem__ ( self , key : str ) -> str : return self . text ( key ) def get_error ( self ) -> ImageReaderErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_READER_ERROR . inverse [ self . error ()] def get_background_color ( self ) -> gui . Color : return gui . Color ( self . backgroundColor ()) def get_clip_rect ( self ) -> core . Rect : return core . Rect ( self . clipRect ()) def get_current_image_rect ( self ) -> core . Rect : return core . Rect ( self . currentImageRect ()) def get_scaled_clip_rect ( self ) -> core . Rect : return core . Rect ( self . scaledClipRect ()) def get_size ( self ) -> core . Size : return core . Size ( self . size ()) def get_scaled_size ( self ) -> core . Size : return core . Size ( self . scaledSize ()) def get_format ( self ) -> str : return bytes ( self . format ()) . decode () def get_subtype ( self ) -> str : return bytes ( self . subType ()) . decode () def get_supported_subtypes ( self ) -> list [ str ]: return [ bytes ( i ) . decode () for i in self . supportedSubTypes ()] def set_format ( self , fmt : types . ByteArrayType ): if isinstance ( fmt , str ): fmt = fmt . encode () if isinstance ( fmt , bytes ): fmt = QtCore . QByteArray ( fmt ) self . setFormat ( fmt ) def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()] def read_image ( self ) -> gui . Image : return gui . Image ( self . read ()) def supports_option ( self , option : gui . imageiohandler . ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in gui . imageiohandler . IMAGE_OPTION : raise InvalidParamError ( option , gui . imageiohandler . IMAGE_OPTION ) return self . supportsOption ( gui . imageiohandler . IMAGE_OPTION [ option ]) @staticmethod def get_image_format ( obj : str | QtCore . QIODevice ) -> str : return bytes ( ImageReader . imageFormat ( obj )) . decode () @staticmethod def get_supported_image_formats () -> list [ str ]: return [ bytes ( i ) . decode () for i in ImageReader . supportedImageFormats ()] @staticmethod def get_supported_mime_types () -> list [ str ]: return [ bytes ( i ) . decode () for i in ImageReader . supportedMimeTypes ()] @staticmethod def get_image_formats_for_mime_type ( typ : types . ByteArrayType ) -> list [ str ]: if isinstance ( typ , str ): typ = typ . encode () if isinstance ( typ , bytes ): typ = QtCore . QByteArray ( typ ) return [ bytes ( i ) . decode () for i in ImageReader . imageFormatsForMimeType ( typ )]","title":"ImageReader"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_error","text":"Return error type. Returns: Type Description ImageReaderErrorStr error type Source code in prettyqt/gui/imagereader.py def get_error ( self ) -> ImageReaderErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_READER_ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_transformation","text":"Return the transformation and orientation the image has been set to. Returns: Type Description gui.imageiohandler.TransformationStr transformation Source code in prettyqt/gui/imagereader.py def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()]","title":"get_transformation()"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.supports_option","text":"Return whether the image handler supports given option. Parameters: Name Type Description Default option gui.imageiohandler.ImageOptionStr option to check required Returns: Type Description bool option Source code in prettyqt/gui/imagereader.py def supports_option ( self , option : gui . imageiohandler . ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in gui . imageiohandler . IMAGE_OPTION : raise InvalidParamError ( option , gui . imageiohandler . IMAGE_OPTION ) return self . supportsOption ( gui . imageiohandler . IMAGE_OPTION [ option ])","title":"supports_option()"},{"location":"api/gui.html#prettyqt.gui.imagewriter","text":"","title":"imagewriter"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter","text":"Source code in prettyqt/gui/imagewriter.py class ImageWriter ( QtGui . QImageWriter ): def __setitem__ ( self , key : str , val : str ): self . setText ( key , val ) def get_error ( self ) -> ImageWriterErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_WRITER_ERROR . inverse [ self . error ()] def get_format ( self ) -> str : return bytes ( self . format ()) . decode () def get_subtype ( self ) -> str : return bytes ( self . subType ()) . decode () def get_supported_image_formats ( self ) -> list [ str ]: return [ bytes ( i ) . decode () for i in self . supportedImageFormats ()] def get_supported_subtypes ( self ) -> list [ str ]: return [ bytes ( i ) . decode () for i in self . supportedSubTypes ()] def set_subtype ( self , subtype : types . ByteArrayType ): if isinstance ( subtype , str ): subtype = subtype . encode () if isinstance ( subtype , bytes ): subtype = QtCore . QByteArray ( subtype ) self . setSubType ( subtype ) def set_format ( self , fmt : types . ByteArrayType ): if isinstance ( fmt , str ): fmt = fmt . encode () if isinstance ( fmt , bytes ): fmt = QtCore . QByteArray ( fmt ) self . setFormat ( fmt ) def set_transformation ( self , origin : gui . imageiohandler . TransformationStr ): \"\"\"Set the image transformations metadata including orientation. Args: origin: transformation to use Raises: InvalidParamError: transformation does not exist \"\"\" if origin not in gui . imageiohandler . TRANSFORMATION : raise InvalidParamError ( origin , gui . imageiohandler . TRANSFORMATION ) self . setTransformation ( gui . imageiohandler . TRANSFORMATION [ origin ]) def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()]","title":"ImageWriter"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_error","text":"Return error type. Returns: Type Description ImageWriterErrorStr error type Source code in prettyqt/gui/imagewriter.py def get_error ( self ) -> ImageWriterErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_WRITER_ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_transformation","text":"Return the transformation and orientation the image has been set to. Returns: Type Description gui.imageiohandler.TransformationStr transformation Source code in prettyqt/gui/imagewriter.py def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()]","title":"get_transformation()"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.set_transformation","text":"Set the image transformations metadata including orientation. Parameters: Name Type Description Default origin gui.imageiohandler.TransformationStr transformation to use required Exceptions: Type Description InvalidParamError transformation does not exist Source code in prettyqt/gui/imagewriter.py def set_transformation ( self , origin : gui . imageiohandler . TransformationStr ): \"\"\"Set the image transformations metadata including orientation. Args: origin: transformation to use Raises: InvalidParamError: transformation does not exist \"\"\" if origin not in gui . imageiohandler . TRANSFORMATION : raise InvalidParamError ( origin , gui . imageiohandler . TRANSFORMATION ) self . setTransformation ( gui . imageiohandler . TRANSFORMATION [ origin ])","title":"set_transformation()"},{"location":"api/gui.html#prettyqt.gui.movie","text":"","title":"movie"},{"location":"api/gui.html#prettyqt.gui.movie.Movie","text":"Source code in prettyqt/gui/movie.py class Movie ( QtGui . QMovie ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . fileName () !r} , { self . get_format () !r} )\" def serialize_fields ( self ): return dict ( speed = self . speed (), cache_mode = self . get_cache_mode (), scaled_size = self . scaledSize (), background_color = self . backgroundColor (), ) def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set cache mode. Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODE : raise InvalidParamError ( mode , CACHE_MODE ) self . setCacheMode ( CACHE_MODE [ mode ]) def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Get the current cache mode. Returns: cache mode \"\"\" return CACHE_MODE . inverse [ self . cacheMode ()] def get_state ( self ) -> MovieStateStr : \"\"\"Get the current state. Returns: state \"\"\" return MOVIE_STATE . inverse [ self . state ()] def get_format ( self ) -> bytes : return bytes ( self . format ()) @classmethod def get_supported_formats ( cls ) -> list [ str ]: return [ bytes ( i ) . decode () for i in cls . supportedFormats ()]","title":"Movie"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_cache_mode","text":"Get the current cache mode. Returns: Type Description CacheModeStr cache mode Source code in prettyqt/gui/movie.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Get the current cache mode. Returns: cache mode \"\"\" return CACHE_MODE . inverse [ self . cacheMode ()]","title":"get_cache_mode()"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_state","text":"Get the current state. Returns: Type Description MovieStateStr state Source code in prettyqt/gui/movie.py def get_state ( self ) -> MovieStateStr : \"\"\"Get the current state. Returns: state \"\"\" return MOVIE_STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.set_cache_mode","text":"Set cache mode. Parameters: Name Type Description Default mode CacheModeStr cache mode required Exceptions: Type Description InvalidParamError cache mode does not exist Source code in prettyqt/gui/movie.py def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set cache mode. Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODE : raise InvalidParamError ( mode , CACHE_MODE ) self . setCacheMode ( CACHE_MODE [ mode ])","title":"set_cache_mode()"},{"location":"api/gui.html#prettyqt.gui.pagelayout","text":"","title":"pagelayout"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout","text":"Source code in prettyqt/gui/pagelayout.py class PageLayout ( QtGui . QPageLayout ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def serialize_fields ( self ): return dict ( margins = self . margins (), minimum_margins = self . minimumMargins (), mode = self . get_mode (), orientation = self . get_orientation (), page_size = self . get_page_size (), units = self . get_units (), ) def set_units ( self , unit : UnitStr ): \"\"\"Set unit. Args: unit: unit Raises: InvalidParamError: unit does not exist \"\"\" if unit not in UNITS : raise InvalidParamError ( unit , UNITS ) self . setUnits ( UNITS [ unit ]) def get_units ( self ) -> UnitStr : \"\"\"Get the current unit. Returns: unit \"\"\" return UNITS . inverse [ self . units ()] def set_mode ( self , mode : ModeStr ): \"\"\"Set mode. Args: mode: mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setMode ( MODES [ mode ]) def get_mode ( self ) -> ModeStr : \"\"\"Get the current mode. Returns: mode \"\"\" return MODES . inverse [ self . mode ()] def set_orientation ( self , orientation : OrientationStr ): \"\"\"Set orientation. Args: orientation: orientation Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) def get_orientation ( self ) -> OrientationStr : \"\"\"Get the current orientation. Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()] def get_page_size ( self ) -> gui . PageSize : return gui . PageSize ( self . pageSize ())","title":"PageLayout"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_mode","text":"Get the current mode. Returns: Type Description ModeStr mode Source code in prettyqt/gui/pagelayout.py def get_mode ( self ) -> ModeStr : \"\"\"Get the current mode. Returns: mode \"\"\" return MODES . inverse [ self . mode ()]","title":"get_mode()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_orientation","text":"Get the current orientation. Returns: Type Description OrientationStr orientation Source code in prettyqt/gui/pagelayout.py def get_orientation ( self ) -> OrientationStr : \"\"\"Get the current orientation. Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_units","text":"Get the current unit. Returns: Type Description UnitStr unit Source code in prettyqt/gui/pagelayout.py def get_units ( self ) -> UnitStr : \"\"\"Get the current unit. Returns: unit \"\"\" return UNITS . inverse [ self . units ()]","title":"get_units()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_mode","text":"Set mode. Parameters: Name Type Description Default mode ModeStr mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/pagelayout.py def set_mode ( self , mode : ModeStr ): \"\"\"Set mode. Args: mode: mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setMode ( MODES [ mode ])","title":"set_mode()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_orientation","text":"Set orientation. Parameters: Name Type Description Default orientation OrientationStr orientation required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/gui/pagelayout.py def set_orientation ( self , orientation : OrientationStr ): \"\"\"Set orientation. Args: orientation: orientation Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_units","text":"Set unit. Parameters: Name Type Description Default unit UnitStr unit required Exceptions: Type Description InvalidParamError unit does not exist Source code in prettyqt/gui/pagelayout.py def set_units ( self , unit : UnitStr ): \"\"\"Set unit. Args: unit: unit Raises: InvalidParamError: unit does not exist \"\"\" if unit not in UNITS : raise InvalidParamError ( unit , UNITS ) self . setUnits ( UNITS [ unit ])","title":"set_units()"},{"location":"api/gui.html#prettyqt.gui.pagesize","text":"","title":"pagesize"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize","text":"Source code in prettyqt/gui/pagesize.py class PageSize ( QtGui . QPageSize ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_id () !r} )\" def __reduce__ ( self ): return type ( self ), ( self . id (),) def get_definition_units ( self ) -> UnitStr : \"\"\"Get the definition unit. Returns: unit \"\"\" units = self . definitionUnits () if qt . flag_to_int ( units ) == - 1 : raise ValueError ( \"Invalid page size\" ) return UNITS . inverse [ units ] def get_id ( self ) -> str : \"\"\"Get the standard page size id. Returns: page size id \"\"\" return PAGE_SIZE_ID . inverse [ self . id ()]","title":"PageSize"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_definition_units","text":"Get the definition unit. Returns: Type Description UnitStr unit Source code in prettyqt/gui/pagesize.py def get_definition_units ( self ) -> UnitStr : \"\"\"Get the definition unit. Returns: unit \"\"\" units = self . definitionUnits () if qt . flag_to_int ( units ) == - 1 : raise ValueError ( \"Invalid page size\" ) return UNITS . inverse [ units ]","title":"get_definition_units()"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_id","text":"Get the standard page size id. Returns: Type Description str page size id Source code in prettyqt/gui/pagesize.py def get_id ( self ) -> str : \"\"\"Get the standard page size id. Returns: page size id \"\"\" return PAGE_SIZE_ID . inverse [ self . id ()]","title":"get_id()"},{"location":"api/gui.html#prettyqt.gui.paintdevice","text":"","title":"paintdevice"},{"location":"api/gui.html#prettyqt.gui.paintdevice.PaintDevice","text":"Source code in prettyqt/gui/paintdevice.py class PaintDevice ( QtGui . QPaintDevice ): def get_metric ( self , metric : MetricStr ) -> int : \"\"\"Return metric information. Args: metric: metric information to get Returns: metric information \"\"\" if metric not in METRICS : raise InvalidParamError ( metric , METRICS ) return self . metric ( METRICS [ metric ])","title":"PaintDevice"},{"location":"api/gui.html#prettyqt.gui.paintdevice.PaintDevice.get_metric","text":"Return metric information. Parameters: Name Type Description Default metric MetricStr metric information to get required Returns: Type Description int metric information Source code in prettyqt/gui/paintdevice.py def get_metric ( self , metric : MetricStr ) -> int : \"\"\"Return metric information. Args: metric: metric information to get Returns: metric information \"\"\" if metric not in METRICS : raise InvalidParamError ( metric , METRICS ) return self . metric ( METRICS [ metric ])","title":"get_metric()"},{"location":"api/gui.html#prettyqt.gui.painter","text":"","title":"painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter","text":"Source code in prettyqt/gui/painter.py class Painter ( QtGui . QPainter ): def __enter__ ( self ): return self def __exit__ ( self , typ , value , traceback ): self . end () @contextlib . contextmanager def paint_on ( self , obj ) -> Iterator [ Painter ]: self . begin ( obj ) yield self self . end () @contextlib . contextmanager def backup_state ( self ) -> Iterator [ Painter ]: self . save () yield self self . restore () @contextlib . contextmanager def native_mode ( self ) -> Iterator [ Painter ]: self . beginNativePainting () yield self self . endNativePainting () @contextlib . contextmanager def edit_pen ( self ) -> Iterator [ gui . Pen ]: pen = gui . Pen ( self . pen ()) yield pen self . setPen ( pen ) def draw_image ( self , target : QtCore . QPoint | QtCore . QPointF | QtCore . QRect | QtCore . QRectF , frame_buffer : QtGui . QImage , ): self . set_composition_mode ( \"source_atop\" ) self . drawImage ( target , frame_buffer ) def draw_polygon ( self , points : ( QtGui . QPolygon | QtGui . QPolygonF | list [ QtCore . QPoint ] | list [ QtCore . QPointF ] ), fill_rule : constants . FillRuleStr = \"odd_even\" , ): if fill_rule not in constants . FILL_RULE : raise InvalidParamError ( fill_rule , constants . FILL_RULE ) self . drawPolygon ( points , fillRule = constants . FILL_RULE [ fill_rule ]) # type: ignore def use_antialiasing ( self ): self . setRenderHint ( self . RenderHint . Antialiasing , True ) def fill_rect ( self , rect : types . RectType | types . RectFType , color : types . ColorType , pattern : constants . PatternStr = \"solid\" , ): if pattern not in constants . PATTERN : raise InvalidParamError ( pattern , constants . PATTERN ) if isinstance ( rect , tuple ): rect = core . RectF ( * rect ) color = colors . get_color ( color ) if pattern != \"solid\" : color = gui . Brush ( color , constants . PATTERN [ pattern ]) self . fillRect ( rect , color ) def set_pen ( self , style : constants . PenStyleStr | None = \"solid\" , width : float = 1.0 , color : types . ColorType = \"black\" , brush : QtGui . QBrush | None = None , miter_limit : float = 2.0 , join_style : constants . JoinStyleStr = \"bevel\" , cap_style : constants . CapStyleStr = \"square\" , ) -> gui . Pen : \"\"\"Set pen to use. Args: style: pen style width: pen width color: pen color brush: pen brush miter_limit: miter limit join_style: pen join style cap_style: pen cap style \"\"\" pen = gui . Pen () pen . set_style ( style ) if style in [ \"none\" , None ]: self . setPen ( pen ) return pen pen . set_cap_style ( cap_style ) pen . set_join_style ( join_style ) pen . setMiterLimit ( miter_limit ) pen . setWidthF ( width ) if brush is not None : pen . setBrush ( brush ) pen . set_color ( color ) self . setPen ( pen ) return pen def get_pen ( self ) -> gui . Pen : \"\"\"Return current pen. Returns: current pen \"\"\" return gui . Pen ( self . pen ()) def set_color ( self , color : types . ColorType ): color = colors . get_color ( color ) self . setPen ( color ) def set_brush ( self , brush : QtGui . QBrush | types . ColorType ): if not isinstance ( brush , QtGui . QBrush ): brush = colors . get_color ( brush ) self . setBrush ( brush ) def set_transparent_background ( self , transparent : bool = True ): mode = ( QtCore . Qt . BGMode . TransparentMode if transparent else QtCore . Qt . BGMode . OpaqueMode ) self . setBackgroundMode ( mode ) def set_composition_mode ( self , mode : CompositionModeStr ): \"\"\"Set the current composition mode. Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMPOSITION_MODE : raise InvalidParamError ( mode , COMPOSITION_MODE ) self . setCompositionMode ( COMPOSITION_MODE [ mode ]) def get_composition_mode ( self ) -> CompositionModeStr : \"\"\"Get the current composition mode. Returns: composition mode \"\"\" return COMPOSITION_MODE . inverse [ self . compositionMode ()] def get_font_metrics ( self ) -> gui . FontMetrics : return gui . FontMetrics ( self . fontMetrics ()) def set_clip_path ( self , path : QtGui . QPainterPath , operation : constants . ClipOperationStr = \"replace\" ): if operation not in constants . CLIP_OPERATION : raise InvalidParamError ( operation , constants . CLIP_OPERATION ) self . setClipPath ( path , constants . CLIP_OPERATION [ operation ]) def get_text_rect ( self , text : str ) -> core . Rect : return self . drawText ( core . Rect (), QtCore . Qt . TextFlag . TextDontPrint , text ) # type: ignore @contextlib . contextmanager def clip_path ( self , operation : constants . ClipOperationStr = \"replace\" ) -> Iterator [ gui . PainterPath ]: path = gui . PainterPath () yield path self . set_clip_path ( path , operation ) @contextlib . contextmanager def apply_transform ( self , combine : bool = True ) -> Iterator [ gui . Transform ]: transform = gui . Transform () yield transform self . setTransform ( transform , combine ) @contextlib . contextmanager def offset_by ( self , x : int = 0 , y : int = 0 ) -> Iterator [ Painter ]: self . translate ( x , y ) yield self self . translate ( - x , - y )","title":"Painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_composition_mode","text":"Get the current composition mode. Returns: Type Description CompositionModeStr composition mode Source code in prettyqt/gui/painter.py def get_composition_mode ( self ) -> CompositionModeStr : \"\"\"Get the current composition mode. Returns: composition mode \"\"\" return COMPOSITION_MODE . inverse [ self . compositionMode ()]","title":"get_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_pen","text":"Return current pen. Returns: Type Description gui.Pen current pen Source code in prettyqt/gui/painter.py def get_pen ( self ) -> gui . Pen : \"\"\"Return current pen. Returns: current pen \"\"\" return gui . Pen ( self . pen ())","title":"get_pen()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_composition_mode","text":"Set the current composition mode. Exceptions: Type Description InvalidParamError composition mode does not exist Source code in prettyqt/gui/painter.py def set_composition_mode ( self , mode : CompositionModeStr ): \"\"\"Set the current composition mode. Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMPOSITION_MODE : raise InvalidParamError ( mode , COMPOSITION_MODE ) self . setCompositionMode ( COMPOSITION_MODE [ mode ])","title":"set_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_pen","text":"Set pen to use. Parameters: Name Type Description Default style constants.PenStyleStr | None pen style 'solid' width float pen width 1.0 color types.ColorType pen color 'black' brush QtGui.QBrush | None pen brush None miter_limit float miter limit 2.0 join_style constants.JoinStyleStr pen join style 'bevel' cap_style constants.CapStyleStr pen cap style 'square' Source code in prettyqt/gui/painter.py def set_pen ( self , style : constants . PenStyleStr | None = \"solid\" , width : float = 1.0 , color : types . ColorType = \"black\" , brush : QtGui . QBrush | None = None , miter_limit : float = 2.0 , join_style : constants . JoinStyleStr = \"bevel\" , cap_style : constants . CapStyleStr = \"square\" , ) -> gui . Pen : \"\"\"Set pen to use. Args: style: pen style width: pen width color: pen color brush: pen brush miter_limit: miter limit join_style: pen join style cap_style: pen cap style \"\"\" pen = gui . Pen () pen . set_style ( style ) if style in [ \"none\" , None ]: self . setPen ( pen ) return pen pen . set_cap_style ( cap_style ) pen . set_join_style ( join_style ) pen . setMiterLimit ( miter_limit ) pen . setWidthF ( width ) if brush is not None : pen . setBrush ( brush ) pen . set_color ( color ) self . setPen ( pen ) return pen","title":"set_pen()"},{"location":"api/gui.html#prettyqt.gui.painterpath","text":"","title":"painterpath"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath","text":"Source code in prettyqt/gui/painterpath.py class PainterPath ( QtGui . QPainterPath ): def serialize_fields ( self ): return dict ( fill_rule = self . get_fill_rule (), elements = list ( self )) def __len__ ( self ): return self . elementCount () def __getitem__ ( self , index : int ) -> QtGui . QPainterPath . Element : return self . elementAt ( index ) def __iter__ ( self ) -> Iterator [ QtGui . QPainterPath . Element ]: return iter ( self . elementAt ( i ) for i in range ( self . elementCount ())) def __setitem__ ( self , index : int , value : tuple [ int , int ]): self . setElementPositionAt ( index , * value ) def __bool__ ( self ): return not self . isEmpty () def __contains__ ( self , item : QtCore . QPointF | QtCore . QRectF | QtGui . QPainterPath ): return self . contains ( item ) def add_rect ( self , rect : types . RectType | types . RectFType ): if isinstance ( rect , QtCore . QRect ): rect = QtCore . QRectF ( rect ) elif isinstance ( rect , tuple ): rect = QtCore . QRectF ( * rect ) self . addRect ( rect ) def set_fill_rule ( self , rule : constants . FillRuleStr ): \"\"\"Set fill rule. Args: rule: fill rule to use Raises: InvalidParamError: fill rule does not exist \"\"\" if rule not in constants . FILL_RULE : raise InvalidParamError ( rule , constants . FILL_RULE ) self . setFillRule ( constants . FILL_RULE [ rule ]) def get_fill_rule ( self ) -> constants . FillRuleStr : \"\"\"Return current fill rule. Returns: fill rule \"\"\" return constants . FILL_RULE . inverse [ self . fillRule ()] def get_bounding_rect ( self ) -> core . RectF : return core . RectF ( self . boundingRect ())","title":"PainterPath"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.get_fill_rule","text":"Return current fill rule. Returns: Type Description constants.FillRuleStr fill rule Source code in prettyqt/gui/painterpath.py def get_fill_rule ( self ) -> constants . FillRuleStr : \"\"\"Return current fill rule. Returns: fill rule \"\"\" return constants . FILL_RULE . inverse [ self . fillRule ()]","title":"get_fill_rule()"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.set_fill_rule","text":"Set fill rule. Parameters: Name Type Description Default rule constants.FillRuleStr fill rule to use required Exceptions: Type Description InvalidParamError fill rule does not exist Source code in prettyqt/gui/painterpath.py def set_fill_rule ( self , rule : constants . FillRuleStr ): \"\"\"Set fill rule. Args: rule: fill rule to use Raises: InvalidParamError: fill rule does not exist \"\"\" if rule not in constants . FILL_RULE : raise InvalidParamError ( rule , constants . FILL_RULE ) self . setFillRule ( constants . FILL_RULE [ rule ])","title":"set_fill_rule()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker","text":"","title":"painterpathstroker"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker","text":"Source code in prettyqt/gui/painterpathstroker.py class PainterPathStroker ( QtGui . QPainterPathStroker ): def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ]) def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()] def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ]) def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()] def create_stroke ( self , path : QtGui . QPainterPath ) -> gui . PainterPath : return gui . PainterPath ( self . createStroke ( path ))","title":"PainterPathStroker"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_cap_style","text":"Return current cap style. Returns: Type Description constants.CapStyleStr cap style Source code in prettyqt/gui/painterpathstroker.py def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()]","title":"get_cap_style()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_join_style","text":"Return current join style. Returns: Type Description constants.JoinStyleStr join style Source code in prettyqt/gui/painterpathstroker.py def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()]","title":"get_join_style()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_cap_style","text":"Set cap style to use. Parameters: Name Type Description Default style constants.CapStyleStr cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ])","title":"set_cap_style()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_join_style","text":"Set join style to use. Parameters: Name Type Description Default style constants.JoinStyleStr join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ])","title":"set_join_style()"},{"location":"api/gui.html#prettyqt.gui.palette","text":"","title":"palette"},{"location":"api/gui.html#prettyqt.gui.palette.Palette","text":"Source code in prettyqt/gui/palette.py class Palette ( QtGui . QPalette ): def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __getitem__ ( self , index : RoleStr ) -> gui . Color : return self . get_color ( index ) def __setitem__ ( self , index : RoleStr , value : types . ColorType ): self . set_color ( index , value ) def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self [ 'button' ] } , { self [ 'window' ] } )\" def highlight_inactive ( self ): color = self . color ( self . ColorGroup . Active , self . ColorRole . Highlight ) self . setColor ( self . ColorGroup . Inactive , self . ColorRole . Highlight , color ) def set_color ( self , role : RoleStr , color : types . ColorType , group : GroupStr = \"active\" ): color = colors . get_color ( color ) self . setColor ( GROUP [ group ], ROLE [ role ], color ) def get_colors ( self , group : GroupStr = \"active\" ) -> dict [ str , gui . Color ]: return { k : self . get_color ( k , group ) for k in ROLE . keys ()} def get_color ( self , role : RoleStr , group : GroupStr = \"active\" ) -> gui . Color : return gui . Color ( self . color ( GROUP [ group ], ROLE [ role ])) def set_brush ( self , role : RoleStr , brush : types . ColorAndBrushType , group : GroupStr = \"active\" ): if not isinstance ( brush , QtGui . QBrush ): brush = gui . Brush ( colors . get_color ( brush )) self . setBrush ( GROUP [ group ], ROLE [ role ], brush ) def get_brushes ( self , group : GroupStr = \"active\" ) -> dict [ str , gui . Brush ]: return { k : self . get_brush ( k , group ) for k in ROLE . keys ()} def get_brush ( self , role : RoleStr , group : GroupStr = \"active\" ) -> gui . Brush : return gui . Brush ( self . brush ( GROUP [ group ], ROLE [ role ])) def set_color_group ( self , group : GroupStr , * args , ** kwargs ): \"\"\"Set the color group. Args: group: color group to use Raises: InvalidParamError: invalid color group \"\"\" if group not in GROUP : raise InvalidParamError ( group , GROUP ) self . setColorGroup ( GROUP [ group ], * args , ** kwargs ) def get_color_group ( self ) -> GroupStr : \"\"\"Return color group. Returns: color group \"\"\" return GROUP . inverse [ self . colorGroup ()] def inverted ( self ) -> Palette : pal = Palette () for group in GROUP : for role in ROLE : color = self . get_color ( role , group ) pal . set_color ( role , color . inverted (), group ) return pal @classmethod def create_dark_palette ( cls ) -> Palette : pal = cls () pal . set_color ( \"window\" , gui . Color ( 53 , 53 , 53 )) pal . set_color ( \"window_text\" , \"white\" ) pal . set_color ( \"window_text\" , \"grey\" , group = \"disabled\" ) pal . set_color ( \"base\" , gui . Color ( 25 , 25 , 25 )) pal . set_color ( \"alternate_base\" , gui . Color ( 53 , 53 , 53 )) pal . set_color ( \"tool_tip_base\" , \"slategrey\" ) pal . set_color ( \"tool_tip_base\" , \"slategrey\" , group = \"inactive\" ) pal . set_color ( \"tool_tip_text\" , \"white\" ) pal . set_color ( \"tool_tip_text\" , \"white\" , group = \"inactive\" ) pal . set_color ( \"text\" , \"white\" ) pal . set_color ( \"text\" , \"grey\" , group = \"disabled\" ) pal . set_color ( \"button\" , gui . Color ( 53 , 53 , 53 )) pal . set_color ( \"button_text\" , \"white\" ) pal . set_color ( \"button_text\" , \"grey\" , group = \"disabled\" ) pal . set_color ( \"bright_text\" , \"red\" ) pal . set_color ( \"link\" , \"dodgerblue\" ) pal . set_color ( \"highlight\" , \"dodgerblue\" ) pal . set_color ( \"highlight\" , gui . Color ( 80 , 80 , 80 ), group = \"disabled\" ) pal . set_color ( \"highlighted_text\" , \"black\" ) pal . set_color ( \"highlighted_text\" , \"grey\" , group = \"disabled\" ) return pal","title":"Palette"},{"location":"api/gui.html#prettyqt.gui.palette.Palette.get_color_group","text":"Return color group. Returns: Type Description GroupStr color group Source code in prettyqt/gui/palette.py def get_color_group ( self ) -> GroupStr : \"\"\"Return color group. Returns: color group \"\"\" return GROUP . inverse [ self . colorGroup ()]","title":"get_color_group()"},{"location":"api/gui.html#prettyqt.gui.palette.Palette.set_color_group","text":"Set the color group. Parameters: Name Type Description Default group GroupStr color group to use required Exceptions: Type Description InvalidParamError invalid color group Source code in prettyqt/gui/palette.py def set_color_group ( self , group : GroupStr , * args , ** kwargs ): \"\"\"Set the color group. Args: group: color group to use Raises: InvalidParamError: invalid color group \"\"\" if group not in GROUP : raise InvalidParamError ( group , GROUP ) self . setColorGroup ( GROUP [ group ], * args , ** kwargs )","title":"set_color_group()"},{"location":"api/gui.html#prettyqt.gui.pen","text":"","title":"pen"},{"location":"api/gui.html#prettyqt.gui.pen.Pen","text":"Source code in prettyqt/gui/pen.py class Pen ( QtGui . QPen ): def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_color () } )\" def set_color ( self , color : types . ColorType ): color = colors . get_color ( color ) self . setColor ( color ) def get_color ( self ) -> gui . Color : return gui . Color ( self . color ()) def get_brush ( self ) -> gui . Brush : return gui . Brush ( self . brush ()) def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ]) def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()] def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ]) def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()] def set_style ( self , style : constants . PenStyleStr | list [ float ] | None ): \"\"\"Set pen style to use. Args: style: pen style to use Raises: InvalidParamError: pen style does not exist \"\"\" if isinstance ( style , list ): self . setDashPattern ( style ) else : if style is None : style = \"none\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setStyle ( constants . PEN_STYLE [ style ]) def get_style ( self ) -> constants . PenStyleStr : \"\"\"Return current pen style. Returns: pen style \"\"\" return constants . PEN_STYLE . inverse [ self . style ()]","title":"Pen"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_cap_style","text":"Return current cap style. Returns: Type Description constants.CapStyleStr cap style Source code in prettyqt/gui/pen.py def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()]","title":"get_cap_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_join_style","text":"Return current join style. Returns: Type Description constants.JoinStyleStr join style Source code in prettyqt/gui/pen.py def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()]","title":"get_join_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_style","text":"Return current pen style. Returns: Type Description constants.PenStyleStr pen style Source code in prettyqt/gui/pen.py def get_style ( self ) -> constants . PenStyleStr : \"\"\"Return current pen style. Returns: pen style \"\"\" return constants . PEN_STYLE . inverse [ self . style ()]","title":"get_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_cap_style","text":"Set cap style to use. Parameters: Name Type Description Default style constants.CapStyleStr cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/pen.py def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ])","title":"set_cap_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_join_style","text":"Set join style to use. Parameters: Name Type Description Default style constants.JoinStyleStr join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/pen.py def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ])","title":"set_join_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_style","text":"Set pen style to use. Parameters: Name Type Description Default style constants.PenStyleStr | list[float] | None pen style to use required Exceptions: Type Description InvalidParamError pen style does not exist Source code in prettyqt/gui/pen.py def set_style ( self , style : constants . PenStyleStr | list [ float ] | None ): \"\"\"Set pen style to use. Args: style: pen style to use Raises: InvalidParamError: pen style does not exist \"\"\" if isinstance ( style , list ): self . setDashPattern ( style ) else : if style is None : style = \"none\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setStyle ( constants . PEN_STYLE [ style ])","title":"set_style()"},{"location":"api/gui.html#prettyqt.gui.pixmap","text":"","title":"pixmap"},{"location":"api/gui.html#prettyqt.gui.pixmap.Pixmap","text":"Source code in prettyqt/gui/pixmap.py class Pixmap ( QtGui . QPixmap ): def __bool__ ( self ): return not self . isNull () def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __eq__ ( self , other ): if not isinstance ( other , Pixmap ): return False # return bytes(self) == bytes(other) return self . toImage () == other . toImage () def __hash__ ( self ): return self . cacheKey () @classmethod def from_file ( cls , path : types . PathType ) -> Pixmap : path = pathlib . Path ( path ) with path . open ( mode = \"rb\" ) as f : data = f . read () # Create widget pixmap = cls () pixmap . loadFromData ( QtCore . QByteArray ( data )) return pixmap @classmethod def from_image ( cls , img : QtGui . QImage , flags ) -> Pixmap : return cls ( cls . fromImage ( img , flags )) def get_size ( self ) -> core . Size : return core . Size ( self . size ()) def get_rect ( self ) -> core . Rect : return core . Rect ( self . rect ()) def to_image ( self ) -> gui . Image : return gui . Image ( self . toImage ()) def rotated ( self , rotation : int ) -> Pixmap : w , h = self . width (), self . height () pixmap = self . transformed ( gui . Transform () . rotate ( rotation )) new_w , new_h = pixmap . width (), pixmap . height () return pixmap . copy (( new_w - w ) // 2 , ( new_h - h ) // 2 , w , h ) def get_image_data_url ( self ): \"\"\"Render the contents of the pixmap as a data URL (RFC-2397). Returns: datauri : str \"\"\" device = core . Buffer () assert device . open_file ( \"read_write\" ) self . save ( device , b \"png\" ) device . close () data = bytes ( device . data ()) payload = base64 . b64encode ( data ) . decode ( \"ascii\" ) return \"data:image/png;base64,\" + payload @classmethod def create_dot ( cls , color : types . ColorType = \"black\" , size : int = 16 ) -> Pixmap : col = colors . get_color ( color ) px = cls ( size , size ) px . fill ( QtCore . Qt . GlobalColor . transparent ) # type: ignore px_size = px . rect () . adjusted ( 1 , 1 , - 1 , - 1 ) with gui . Painter ( px ) as painter : painter . use_antialiasing () painter . setBrush ( col ) pen_color = gui . Color ( 15 , 15 , 15 ) painter . set_pen ( color = pen_color , width = 1 ) painter . drawEllipse ( px_size ) return px @classmethod def create_checkerboard_pattern ( cls , n : int , color_1 : types . ColorType , color_2 : types . ColorType ): \"\"\"Construct tileable checkerboard pattern for paint events.\"\"\" # Brush will be an n\u00d7n checkerboard pattern pat = gui . Pixmap ( 2 * n , 2 * n ) bg0 = colors . get_color ( color_1 ) bg1 = colors . get_color ( color_2 ) with gui . Painter ( pat ) as p : p . setPen ( QtCore . Qt . PenStyle . NoPen ) # Paint a checkerboard pattern for the color to be overlaid on p . fillRect ( pat . rect (), bg0 ) p . fillRect ( 0 , 0 , n , n , bg1 ) p . fillRect ( n , n , 2 * n , 2 * n , bg1 ) return pat @classmethod def create_char ( cls , char : str , size : int , background : types . ColorType = \"black\" , color : types . ColorType = \"white\" , ): pixmap = cls ( size , size ) pixmap . fill ( QtCore . Qt . transparent ) with gui . Painter ( pixmap ) as painter : painter . setRenderHints ( painter . Antialiasing | painter . TextAntialiasing | painter . SmoothPixmapTransform ) bg_color = colors . get_color ( background ) painter . setPen ( bg_color ) painter . setBrush ( bg_color ) margin = 1 + size // 16 text_margin = size // 20 rect = QtCore . QRectF ( margin , margin , size - 2 * margin , size - 2 * margin ) painter . drawRoundedRect ( rect , 30.0 , 30.0 , QtCore . Qt . RelativeSize ) painter . setPen ( colors . get_color ( color )) font = painter . font () # type: QtGui.QFont font . setPixelSize ( size - 2 * margin - 2 * text_margin ) painter . setFont ( font ) painter . drawText ( rect , QtCore . Qt . AlignCenter , char ) return pixmap","title":"Pixmap"},{"location":"api/gui.html#prettyqt.gui.pixmap.Pixmap.create_checkerboard_pattern","text":"Construct tileable checkerboard pattern for paint events. Source code in prettyqt/gui/pixmap.py @classmethod def create_checkerboard_pattern ( cls , n : int , color_1 : types . ColorType , color_2 : types . ColorType ): \"\"\"Construct tileable checkerboard pattern for paint events.\"\"\" # Brush will be an n\u00d7n checkerboard pattern pat = gui . Pixmap ( 2 * n , 2 * n ) bg0 = colors . get_color ( color_1 ) bg1 = colors . get_color ( color_2 ) with gui . Painter ( pat ) as p : p . setPen ( QtCore . Qt . PenStyle . NoPen ) # Paint a checkerboard pattern for the color to be overlaid on p . fillRect ( pat . rect (), bg0 ) p . fillRect ( 0 , 0 , n , n , bg1 ) p . fillRect ( n , n , 2 * n , 2 * n , bg1 ) return pat","title":"create_checkerboard_pattern()"},{"location":"api/gui.html#prettyqt.gui.pixmap.Pixmap.get_image_data_url","text":"Render the contents of the pixmap as a data URL (RFC-2397). Returns: Type Description datauri str Source code in prettyqt/gui/pixmap.py def get_image_data_url ( self ): \"\"\"Render the contents of the pixmap as a data URL (RFC-2397). Returns: datauri : str \"\"\" device = core . Buffer () assert device . open_file ( \"read_write\" ) self . save ( device , b \"png\" ) device . close () data = bytes ( device . data ()) payload = base64 . b64encode ( data ) . decode ( \"ascii\" ) return \"data:image/png;base64,\" + payload","title":"get_image_data_url()"},{"location":"api/gui.html#prettyqt.gui.sessionmanager","text":"","title":"sessionmanager"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager","text":"Source code in prettyqt/gui/sessionmanager.py class SessionManager : def __init__ ( self , item : QtGui . QSessionManager ): self . item = item def __getattr__ ( self , val ): return getattr ( self . item , val ) def set_restart_hint ( self , style : RestartHintStr ): \"\"\"Set the restart hint. Args: style: restart hint Raises: InvalidParamError: restart hint does not exist \"\"\" if style not in RESTART_HINT : raise InvalidParamError ( style , RESTART_HINT ) self . setRestartHint ( RESTART_HINT [ style ]) def get_restart_hint ( self ) -> RestartHintStr : \"\"\"Return current restart hint. Returns: restart hint \"\"\" return RESTART_HINT . inverse [ self . restartHint ()]","title":"SessionManager"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.get_restart_hint","text":"Return current restart hint. Returns: Type Description RestartHintStr restart hint Source code in prettyqt/gui/sessionmanager.py def get_restart_hint ( self ) -> RestartHintStr : \"\"\"Return current restart hint. Returns: restart hint \"\"\" return RESTART_HINT . inverse [ self . restartHint ()]","title":"get_restart_hint()"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.set_restart_hint","text":"Set the restart hint. Parameters: Name Type Description Default style RestartHintStr restart hint required Exceptions: Type Description InvalidParamError restart hint does not exist Source code in prettyqt/gui/sessionmanager.py def set_restart_hint ( self , style : RestartHintStr ): \"\"\"Set the restart hint. Args: style: restart hint Raises: InvalidParamError: restart hint does not exist \"\"\" if style not in RESTART_HINT : raise InvalidParamError ( style , RESTART_HINT ) self . setRestartHint ( RESTART_HINT [ style ])","title":"set_restart_hint()"},{"location":"api/gui.html#prettyqt.gui.standarditem","text":"","title":"standarditem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem","text":"Source code in prettyqt/gui/standarditem.py class StandardItem ( QtGui . QStandardItem ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_icon () } , { self . text () !r} )\" def serialize_fields ( self ): return dict ( text = self . text (), tool_tip = self . toolTip (), status_tip = self . statusTip (), icon = self . get_icon (), data = self . data (), ) def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __getitem__ ( self , index : int | tuple [ int , int ] | QtCore . QModelIndex ) -> QtGui . QStandardItem : if isinstance ( index , int ): return self . child ( index ) elif isinstance ( index , tuple ): return self . child ( * index ) else : raise KeyError ( index ) def __delitem__ ( self , index : int | tuple [ int , int ]): if isinstance ( index , int ): item = self . takeRow ( index ) else : item = self . takeChild ( * index ) if item is None : raise KeyError ( index ) return item def __iter__ ( self ) -> Iterator [ QtGui . QStandardItem ]: return iter ( self . get_children ()) def __add__ ( self , other : str | QtGui . QStandardItem ) -> StandardItem : if isinstance ( other , ( QtGui . QStandardItem , str )): self . add ( other ) return self raise TypeError ( \"wrong type for addition\" ) def get_children ( self ) -> list [ QtGui . QStandardItem ]: return [ self . child ( index ) for index in range ( self . rowCount ())] def add ( self , * item : str | QtGui . QStandardItem ): for i in item : if isinstance ( i , str ): i = gui . StandardItem ( i ) self . appendRow ([ i ]) def clone ( self ): item = type ( self )() core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] def get_background ( self ) -> gui . Brush : return gui . Brush ( self . background ()) def get_foreground ( self ) -> gui . Brush : return gui . Brush ( self . foreground ()) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_tooltip ( self , tooltip : str | types . PathType , size : types . SizeType | None = None , ): if isinstance ( tooltip , os . PathLike ): path = os . fspath ( tooltip ) if size is None : tooltip = f \"<img src= { path !r} >\" else : if isinstance ( size , QtCore . QSize ): size = ( size . width (), size . height ()) tooltip = f '<img src= { path !r} width=\" { size [ 0 ] } \" height=\" { size [ 1 ] } \">' self . setToolTip ( tooltip ) def set_size_hint ( self , hint : types . SizeType ): if isinstance ( hint , tuple ): hint = QtCore . QSize ( * hint ) self . setSizeHint ( hint ) def add_item ( self , name : str = \"\" , icon : types . IconType = None , data : dict | None = None , foreground : QtGui . QBrush | None = None , background : QtGui . QBrush | None = None , font : QtGui . QFont | None = None , selectable : bool = True , enabled : bool = True , editable : bool = False , status_tip : str | None = None , tool_tip : str | None = None , whats_this : str | None = None , # text_alignment: Optional[str] = None, checkstate : constants . StateStr | None = None , flags : QtCore . Qt . ItemFlags | None = None , size_hint : types . SizeType | None = None , is_user_type : bool = False , ) -> StandardItem : item = StandardItem ( name ) if icon is not None : icon = iconprovider . get_icon ( icon ) item . setIcon ( icon ) if data is not None : for k , v in data . items (): item . setData ( v , k ) if foreground is not None : item . setForeground ( foreground ) if background is not None : item . setBackground ( background ) if font is not None : item . setFont ( font ) if flags is not None : item . setFlags ( flags ) if enabled : item . setEnabled ( enabled ) if editable : item . setEditable ( editable ) if selectable : item . setSelectable ( selectable ) if status_tip : item . setStatusTip ( status_tip ) if tool_tip : item . setToolTip ( tool_tip ) if whats_this : item . setWhatsThis ( whats_this ) if size_hint is not None : item . set_size_hint ( size_hint ) if checkstate is not None : item . set_checkstate ( checkstate ) self . appendRow ([ item ]) return item","title":"StandardItem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.clone","text":"clone(self) -> PySide6.QtGui.QStandardItem Source code in prettyqt/gui/standarditem.py def clone ( self ): item = type ( self )() core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item","title":"clone()"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.get_checkstate","text":"Return checkstate. Returns: Type Description constants.StateStr checkstate Source code in prettyqt/gui/standarditem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/gui/standarditem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ])","title":"set_checkstate()"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/gui/standarditem.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/gui.html#prettyqt.gui.statictext","text":"","title":"statictext"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText","text":"Source code in prettyqt/gui/statictext.py class StaticText ( QtGui . QStaticText ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . text () !r} )\" def __str__ ( self ): return self . text () def get_size ( self ) -> core . Size : return core . Size ( self . size ()) def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] def set_performance_hint ( self , hint : PerformanceHintStr ): \"\"\"Set the performance hint. Args: hint: performance hint to use Raises: InvalidParamError: performance hint does not exist \"\"\" if hint not in PERFORMANCE_HINT : raise InvalidParamError ( hint , PERFORMANCE_HINT ) self . setPerformanceHint ( PERFORMANCE_HINT [ hint ]) def get_performance_hint ( self ) -> PerformanceHintStr : \"\"\"Return current performance hint. Returns: performance hint \"\"\" return PERFORMANCE_HINT . inverse [ self . performanceHint ()]","title":"StaticText"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_performance_hint","text":"Return current performance hint. Returns: Type Description PerformanceHintStr performance hint Source code in prettyqt/gui/statictext.py def get_performance_hint ( self ) -> PerformanceHintStr : \"\"\"Return current performance hint. Returns: performance hint \"\"\" return PERFORMANCE_HINT . inverse [ self . performanceHint ()]","title":"get_performance_hint()"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_text_format","text":"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str text format Source code in prettyqt/gui/statictext.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_performance_hint","text":"Set the performance hint. Parameters: Name Type Description Default hint PerformanceHintStr performance hint to use required Exceptions: Type Description InvalidParamError performance hint does not exist Source code in prettyqt/gui/statictext.py def set_performance_hint ( self , hint : PerformanceHintStr ): \"\"\"Set the performance hint. Args: hint: performance hint to use Raises: InvalidParamError: performance hint does not exist \"\"\" if hint not in PERFORMANCE_HINT : raise InvalidParamError ( hint , PERFORMANCE_HINT ) self . setPerformanceHint ( PERFORMANCE_HINT [ hint ])","title":"set_performance_hint()"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_text_format","text":"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/gui/statictext.py def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ])","title":"set_text_format()"},{"location":"api/gui.html#prettyqt.gui.surface","text":"","title":"surface"},{"location":"api/gui.html#prettyqt.gui.surface.Surface","text":"Source code in prettyqt/gui/surface.py class Surface ( QtGui . QSurface ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def get_surface_class ( self ) -> SurfaceClassStr : \"\"\"Get the current surface class. Returns: surface class \"\"\" return SURFACE_CLASS . inverse [ self . surfaceClass ()] def get_surface_type ( self ) -> SurfaceTypeStr : \"\"\"Get the current surface type. Returns: surface type \"\"\" return SURFACE_TYPES . inverse [ self . surfaceType ()]","title":"Surface"},{"location":"api/gui.html#prettyqt.gui.surface.Surface.get_surface_class","text":"Get the current surface class. Returns: Type Description SurfaceClassStr surface class Source code in prettyqt/gui/surface.py def get_surface_class ( self ) -> SurfaceClassStr : \"\"\"Get the current surface class. Returns: surface class \"\"\" return SURFACE_CLASS . inverse [ self . surfaceClass ()]","title":"get_surface_class()"},{"location":"api/gui.html#prettyqt.gui.surface.Surface.get_surface_type","text":"Get the current surface type. Returns: Type Description SurfaceTypeStr surface type Source code in prettyqt/gui/surface.py def get_surface_type ( self ) -> SurfaceTypeStr : \"\"\"Get the current surface type. Returns: surface type \"\"\" return SURFACE_TYPES . inverse [ self . surfaceType ()]","title":"get_surface_type()"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter","text":"","title":"syntaxhighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter","text":"Source code in prettyqt/gui/syntaxhighlighter.py class SyntaxHighlighter ( QtGui . QSyntaxHighlighter ): RULES : list = [] def __init__ ( self , parent : QtCore . QObject | None = None ): super () . __init__ ( parent ) # type: ignore def get_current_block ( self ) -> gui . TextBlock : return gui . TextBlock ( self . currentBlock ()) def get_format ( self , position : int ) -> gui . TextBlock : return gui . TextCharFormat ( self . format ( position )) @classmethod def yield_rules ( cls ) -> Iterator [ tuple [ Pattern , int , gui . TextCharFormat ]]: for Rule in cls . RULES : if isinstance ( Rule . compiled , list ): for i in Rule . compiled : yield ( i , Rule . nth , Rule . fmt ) else : yield ( Rule . compiled , Rule . nth , Rule . fmt ) def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt )","title":"SyntaxHighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt )","title":"highlightBlock()"},{"location":"api/gui.html#prettyqt.gui.textblock","text":"","title":"textblock"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock","text":"Source code in prettyqt/gui/textblock.py class TextBlock ( QtGui . QTextBlock ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . text () !r} )\" def __contains__ ( self , position : int ): return self . contains ( position ) def __bool__ ( self ): return self . isValid () def __str__ ( self ): return self . text () def get_previous ( self ) -> TextBlock : return TextBlock ( self . previous ()) def get_next ( self ) -> TextBlock : return TextBlock ( self . next ()) def get_text_direction ( self ) -> constants . LayoutDirectionStr : return constants . LAYOUT_DIRECTION . inv [ self . textDirection ()] def set_user_data ( self , data ): if isinstance ( data , QtGui . QTextBlockUserData ): self . setUserData ( data ) return None user_data = UserData ( data ) self . setUserData ( user_data ) def get_user_data ( self ): user_data = self . userData () if isinstance ( user_data , UserData ): print ( user_data . data ) return user_data . data return user_data @contextlib . contextmanager def edit_user_state ( self ): state = self . userState () yield state self . setUserState ( state ) def get_state ( self ) -> int : \"\"\"Get the user state, generally used for syntax highlighting. :return: The block state \"\"\" state = self . userState () if state == - 1 : return state return state & 0x0000FFFF def set_state ( self , state : int ): \"\"\"Set the user state, generally used for syntax highlighting. :param state: new state value. \"\"\" user_state = self . userState () if user_state == - 1 : user_state = 0 higher_part = user_state & 0x7FFF0000 state &= 0x0000FFFF state |= higher_part self . setUserState ( state ) def get_fold_level ( self ) -> int : \"\"\"Get the block fold level. :return: The block fold level \"\"\" state = self . userState () if state == - 1 : state = 0 return ( state & 0x03FF0000 ) >> 16 def set_fold_level ( self , val : int ): \"\"\"Set the block fold level. :param val: The new fold level [0-7] \"\"\" state = self . userState () if state == - 1 : state = 0 if val >= 0x3FF : val = 0x3FF state &= 0x7C00FFFF state |= val << 16 self . setUserState ( state ) def is_fold_trigger ( self ) -> bool : \"\"\"Check if the block is a fold trigger. :return: True if the block is a fold trigger (represented as a node in the fold panel) \"\"\" state = self . userState () if state == - 1 : state = 0 return bool ( state & 0x04000000 ) def set_fold_trigger ( self , val : int ): \"\"\"Set the block fold trigger flag (True means the block is a fold trigger). :param val: value to set \"\"\" state = self . userState () if state == - 1 : state = 0 state &= 0x7BFFFFFF state |= int ( val ) << 26 self . setUserState ( state ) def is_collapsed ( self ) -> bool : \"\"\"Check if the block is expanded or collased. :return: False for an open trigger, True for for closed trigger \"\"\" state = self . userState () if state == - 1 : state = 0 return bool ( state & 0x08000000 ) def set_collapsed ( self , val : int ): \"\"\"Set the fold trigger state (collapsed or expanded). :param val: The new trigger state (True=collapsed, False=expanded) \"\"\" state = self . userState () if state == - 1 : state = 0 state &= 0x77FFFFFF state |= int ( val ) << 27 self . setUserState ( state ) def find_parent_scope ( self , limit : int = 5000 ) -> TextBlock | None : \"\"\"Find parent scope, if the block is not a fold trigger.\"\"\" # if we moved up for more than n lines, just give up otherwise this # would take too much time. counter = 0 original = TextBlock ( self ) start = TextBlock ( self ) if not self . is_fold_trigger (): # search level of next non blank line while start . text () . strip () == \"\" and start . isValid (): start = start . next () ref_level = self . get_fold_level () - 1 start = original while ( start . blockNumber () and counter < limit and ( not self . is_fold_trigger () or self . get_fold_level () > ref_level ) ): counter += 1 start = start . previous () if counter < limit : return TextBlock ( start ) return None","title":"TextBlock"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.find_parent_scope","text":"Find parent scope, if the block is not a fold trigger. Source code in prettyqt/gui/textblock.py def find_parent_scope ( self , limit : int = 5000 ) -> TextBlock | None : \"\"\"Find parent scope, if the block is not a fold trigger.\"\"\" # if we moved up for more than n lines, just give up otherwise this # would take too much time. counter = 0 original = TextBlock ( self ) start = TextBlock ( self ) if not self . is_fold_trigger (): # search level of next non blank line while start . text () . strip () == \"\" and start . isValid (): start = start . next () ref_level = self . get_fold_level () - 1 start = original while ( start . blockNumber () and counter < limit and ( not self . is_fold_trigger () or self . get_fold_level () > ref_level ) ): counter += 1 start = start . previous () if counter < limit : return TextBlock ( start ) return None","title":"find_parent_scope()"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.get_fold_level","text":"Get the block fold level. :return: The block fold level Source code in prettyqt/gui/textblock.py def get_fold_level ( self ) -> int : \"\"\"Get the block fold level. :return: The block fold level \"\"\" state = self . userState () if state == - 1 : state = 0 return ( state & 0x03FF0000 ) >> 16","title":"get_fold_level()"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.get_state","text":"Get the user state, generally used for syntax highlighting. :return: The block state Source code in prettyqt/gui/textblock.py def get_state ( self ) -> int : \"\"\"Get the user state, generally used for syntax highlighting. :return: The block state \"\"\" state = self . userState () if state == - 1 : return state return state & 0x0000FFFF","title":"get_state()"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.is_collapsed","text":"Check if the block is expanded or collased. :return: False for an open trigger, True for for closed trigger Source code in prettyqt/gui/textblock.py def is_collapsed ( self ) -> bool : \"\"\"Check if the block is expanded or collased. :return: False for an open trigger, True for for closed trigger \"\"\" state = self . userState () if state == - 1 : state = 0 return bool ( state & 0x08000000 )","title":"is_collapsed()"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.is_fold_trigger","text":"Check if the block is a fold trigger. :return: True if the block is a fold trigger (represented as a node in the fold panel) Source code in prettyqt/gui/textblock.py def is_fold_trigger ( self ) -> bool : \"\"\"Check if the block is a fold trigger. :return: True if the block is a fold trigger (represented as a node in the fold panel) \"\"\" state = self . userState () if state == - 1 : state = 0 return bool ( state & 0x04000000 )","title":"is_fold_trigger()"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_collapsed","text":"Set the fold trigger state (collapsed or expanded). :param val: The new trigger state (True=collapsed, False=expanded) Source code in prettyqt/gui/textblock.py def set_collapsed ( self , val : int ): \"\"\"Set the fold trigger state (collapsed or expanded). :param val: The new trigger state (True=collapsed, False=expanded) \"\"\" state = self . userState () if state == - 1 : state = 0 state &= 0x77FFFFFF state |= int ( val ) << 27 self . setUserState ( state )","title":"set_collapsed()"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_fold_level","text":"Set the block fold level. :param val: The new fold level [0-7] Source code in prettyqt/gui/textblock.py def set_fold_level ( self , val : int ): \"\"\"Set the block fold level. :param val: The new fold level [0-7] \"\"\" state = self . userState () if state == - 1 : state = 0 if val >= 0x3FF : val = 0x3FF state &= 0x7C00FFFF state |= val << 16 self . setUserState ( state )","title":"set_fold_level()"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_fold_trigger","text":"Set the block fold trigger flag (True means the block is a fold trigger). :param val: value to set Source code in prettyqt/gui/textblock.py def set_fold_trigger ( self , val : int ): \"\"\"Set the block fold trigger flag (True means the block is a fold trigger). :param val: value to set \"\"\" state = self . userState () if state == - 1 : state = 0 state &= 0x7BFFFFFF state |= int ( val ) << 26 self . setUserState ( state )","title":"set_fold_trigger()"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_state","text":"Set the user state, generally used for syntax highlighting. :param state: new state value. Source code in prettyqt/gui/textblock.py def set_state ( self , state : int ): \"\"\"Set the user state, generally used for syntax highlighting. :param state: new state value. \"\"\" user_state = self . userState () if user_state == - 1 : user_state = 0 higher_part = user_state & 0x7FFF0000 state &= 0x0000FFFF state |= higher_part self . setUserState ( state )","title":"set_state()"},{"location":"api/gui.html#prettyqt.gui.textcharformat","text":"","title":"textcharformat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat","text":"Source code in prettyqt/gui/textcharformat.py class TextCharFormat ( QtGui . QTextCharFormat ): def __init__ ( self , text_color : types . ColorType | QtGui . QBrush = None , bold : bool = False , italic : bool = False , ): super () . __init__ () if text_color is not None : self . set_foreground_color ( text_color ) if bold : self . set_font_weight ( \"bold\" ) self . setFontItalic ( italic ) def set_foreground_color ( self , color : types . ColorType | QtGui . QBrush ): if not isinstance ( color , QtGui . QBrush ): color = colors . get_color ( color ) self . setForeground ( color ) def set_background_color ( self , color : types . ColorType | QtGui . QBrush ): if not isinstance ( color , QtGui . QBrush ): color = colors . get_color ( color ) self . setBackground ( color ) def set_font_weight ( self , weight : gui . font . WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) self . setFontWeight ( gui . font . WEIGHT [ weight ]) def get_font_weight ( self ) -> gui . font . WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return gui . font . WEIGHT . inverse [ self . fontWeight ()] def set_underline_style ( self , style : UnderlineStyleStr ): \"\"\"Set the underline style. Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLE : raise InvalidParamError ( style , UNDERLINE_STYLE ) self . setUnderlineStyle ( UNDERLINE_STYLE [ style ]) def get_underline_style ( self ) -> UnderlineStyleStr : \"\"\"Get current underline style. Returns: current underline style \"\"\" return UNDERLINE_STYLE . inverse [ self . underlineStyle ()] def set_vertical_alignment ( self , alignment : VerticalAlignmentStr ): \"\"\"Set the vertical alignment. Args: alignment: vertical alignment Raises: InvalidParamError: invalid vertical alignment \"\"\" if alignment not in VERTICAL_ALIGNMENT : raise InvalidParamError ( alignment , VERTICAL_ALIGNMENT ) self . setVerticalAlignment ( VERTICAL_ALIGNMENT [ alignment ]) def get_vertical_alignment ( self ) -> VerticalAlignmentStr : \"\"\"Get current vertical alignment. Returns: current vertical alignment \"\"\" return VERTICAL_ALIGNMENT . inverse [ self . verticalAlignment ()] def set_font_style_hint ( self , hint : gui . font . StyleHintStr ): \"\"\"Set the font style hint. Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in gui . font . STYLE_HINTS : raise InvalidParamError ( hint , gui . font . STYLE_HINTS ) self . setFontStyleHint ( gui . font . STYLE_HINTS [ hint ]) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ())","title":"TextCharFormat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_font_weight","text":"Get current font weight. Returns: Type Description gui.font.WeightStr current font weight Source code in prettyqt/gui/textcharformat.py def get_font_weight ( self ) -> gui . font . WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return gui . font . WEIGHT . inverse [ self . fontWeight ()]","title":"get_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_underline_style","text":"Get current underline style. Returns: Type Description UnderlineStyleStr current underline style Source code in prettyqt/gui/textcharformat.py def get_underline_style ( self ) -> UnderlineStyleStr : \"\"\"Get current underline style. Returns: current underline style \"\"\" return UNDERLINE_STYLE . inverse [ self . underlineStyle ()]","title":"get_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_vertical_alignment","text":"Get current vertical alignment. Returns: Type Description VerticalAlignmentStr current vertical alignment Source code in prettyqt/gui/textcharformat.py def get_vertical_alignment ( self ) -> VerticalAlignmentStr : \"\"\"Get current vertical alignment. Returns: current vertical alignment \"\"\" return VERTICAL_ALIGNMENT . inverse [ self . verticalAlignment ()]","title":"get_vertical_alignment()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_style_hint","text":"Set the font style hint. Parameters: Name Type Description Default hint gui.font.StyleHintStr font style hint required Exceptions: Type Description InvalidParamError invalid font style hint Source code in prettyqt/gui/textcharformat.py def set_font_style_hint ( self , hint : gui . font . StyleHintStr ): \"\"\"Set the font style hint. Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in gui . font . STYLE_HINTS : raise InvalidParamError ( hint , gui . font . STYLE_HINTS ) self . setFontStyleHint ( gui . font . STYLE_HINTS [ hint ])","title":"set_font_style_hint()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_weight","text":"Set the font weight. Parameters: Name Type Description Default weight gui.font.WeightStr font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/textcharformat.py def set_font_weight ( self , weight : gui . font . WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) self . setFontWeight ( gui . font . WEIGHT [ weight ])","title":"set_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_underline_style","text":"Set the underline style. Parameters: Name Type Description Default style UnderlineStyleStr underline style required Exceptions: Type Description InvalidParamError invalid underline style Source code in prettyqt/gui/textcharformat.py def set_underline_style ( self , style : UnderlineStyleStr ): \"\"\"Set the underline style. Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLE : raise InvalidParamError ( style , UNDERLINE_STYLE ) self . setUnderlineStyle ( UNDERLINE_STYLE [ style ])","title":"set_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_vertical_alignment","text":"Set the vertical alignment. Parameters: Name Type Description Default alignment VerticalAlignmentStr vertical alignment required Exceptions: Type Description InvalidParamError invalid vertical alignment Source code in prettyqt/gui/textcharformat.py def set_vertical_alignment ( self , alignment : VerticalAlignmentStr ): \"\"\"Set the vertical alignment. Args: alignment: vertical alignment Raises: InvalidParamError: invalid vertical alignment \"\"\" if alignment not in VERTICAL_ALIGNMENT : raise InvalidParamError ( alignment , VERTICAL_ALIGNMENT ) self . setVerticalAlignment ( VERTICAL_ALIGNMENT [ alignment ])","title":"set_vertical_alignment()"},{"location":"api/gui.html#prettyqt.gui.textcursor","text":"","title":"textcursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor","text":"Source code in prettyqt/gui/textcursor.py class TextCursor ( QtGui . QTextCursor ): def __str__ ( self ): return self . selectedText () . replace ( \" \\u2029 \" , \" \\n \" ) def move_position ( self , operation : MoveOperationStr , mode : MoveModeStr = \"move\" , n : int = 1 ) -> bool : return self . movePosition ( MOVE_OPERATION [ operation ], MOVE_MODE [ mode ], n ) def set_position ( self , pos : int , mode : MoveModeStr = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODE [ mode ]) def select ( self , selection : SelectionTypeStr | QtGui . QTextCursor . SelectionType ): if isinstance ( selection , QtGui . QTextCursor . SelectionType ): sel = selection else : sel = SELECTION_TYPE [ selection ] super () . select ( sel ) def span ( self ) -> tuple [ int , int ]: return ( self . anchor (), self . position ()) def get_cursor_position ( self ) -> tuple [ int , int ]: \"\"\"Return the QTextCursor position. The position is a tuple made up of the line number (0 based) and the column number (0 based). :return: tuple(line, column) \"\"\" return ( self . blockNumber (), self . columnNumber ()) def get_selection ( self ) -> gui . TextDocumentFragment : return gui . TextDocumentFragment ( self . selection ()) def select_text ( self , start_pos : int | MoveOperationStr , end_pos : int | MoveOperationStr , ) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText () def replace_text ( self , start_pos : int , end_pos : MoveOperationStr | int , to_replace : str , ): self . set_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) self . insertText ( to_replace ) self . select_text ( start_pos , start_pos + len ( to_replace )) @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock ()","title":"TextCursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.edit_block","text":"Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock ()","title":"edit_block()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.get_cursor_position","text":"Return the QTextCursor position. The position is a tuple made up of the line number (0 based) and the column number (0 based). :return: tuple(line, column) Source code in prettyqt/gui/textcursor.py def get_cursor_position ( self ) -> tuple [ int , int ]: \"\"\"Return the QTextCursor position. The position is a tuple made up of the line number (0 based) and the column number (0 based). :return: tuple(line, column) \"\"\" return ( self . blockNumber (), self . columnNumber ())","title":"get_cursor_position()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select","text":"select(self, selection: PySide6.QtGui.QTextCursor.SelectionType) -> None Source code in prettyqt/gui/textcursor.py def select ( self , selection : SelectionTypeStr | QtGui . QTextCursor . SelectionType ): if isinstance ( selection , QtGui . QTextCursor . SelectionType ): sel = selection else : sel = SELECTION_TYPE [ selection ] super () . select ( sel )","title":"select()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select_text","text":"Select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos int | MoveOperationStr Start position required end_pos int | MoveOperationStr End position required Source code in prettyqt/gui/textcursor.py def select_text ( self , start_pos : int | MoveOperationStr , end_pos : int | MoveOperationStr , ) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText ()","title":"select_text()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.set_position","text":"Set cursor to given position. Parameters: Name Type Description Default pos int Cursor position required mode MoveModeStr Move mode 'move' Source code in prettyqt/gui/textcursor.py def set_position ( self , pos : int , mode : MoveModeStr = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODE [ mode ])","title":"set_position()"},{"location":"api/gui.html#prettyqt.gui.textdocument","text":"","title":"textdocument"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument","text":"Source code in prettyqt/gui/textdocument.py class TextDocument ( QtGui . QTextDocument ): def __getitem__ ( self , index : int ) -> gui . TextBlock : return gui . TextBlock ( self . findBlockByNumber ( index )) def __len__ ( self ) -> int : return self . blockCount () def __iter__ ( self ) -> Iterator [ gui . TextBlock ]: return iter ( gui . TextBlock ( self . findBlockByNumber ( i )) for i in range ( self . blockCount ()) ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . toPlainText () !r} )\" def get_first_block ( self ) -> gui . TextBlock : return gui . TextBlock ( self . firstBlock ()) def get_last_block ( self ) -> gui . TextBlock : return gui . TextBlock ( self . lastBlock ()) def find_block_by_number ( self , number : int ) -> gui . TextBlock : block = self . findBlockByNumber ( number ) if not block . isValid (): raise ValueError ( f \" { number } not a valid block index. Block count: { self . blockCount () } \" ) return gui . TextBlock ( block ) def find_block_by_line_number ( self , line_number : int ) -> gui . TextBlock : block = self . findBlockByLineNumber ( line_number ) if not block . isValid (): raise ValueError ( f \" { line_number } not a valid line index. Line count: { self . lineCount () } \" ) return gui . TextBlock ( block ) def set_text ( self , text : str ): self . setPlainText ( text ) def serialize_fields ( self ): return dict ( base_url = self . get_base_url (), default_font = self . get_default_font (), default_stylesheet = self . defaultStyleSheet (), default_text_option = self . get_default_text_option (), document_margin = self . documentMargin (), maximum_block_count = self . maximumBlockCount (), is_modified = self . isModified (), page_size = self . pageSize (), text_width = self . textWidth (), indent_width = self . indentWidth (), undo_redo_enabled = self . isUndoRedoEnabled (), use_design_metrics = self . useDesignMetrics (), ) def get_base_url ( self ) -> core . Url : return core . Url ( self . baseUrl ()) def get_default_font ( self ) -> gui . Font : return gui . Font ( self . defaultFont ()) def set_default_text_option ( self , opt : QtGui . QTextOption ): self . setDefaultTextOption ( gui . TextOption ( opt )) def get_default_text_option ( self ) -> gui . TextOption : return gui . TextOption ( self . defaultTextOption ()) def set_flags ( self , ** flags ): current = self . flags () for k , v in flags . items (): if v : current = current | gui . textoption . FLAG [ k ] else : current = current & ~ gui . textoption . FLAG [ k ] self . setFlags ( current ) # if show: # self.setFlags(self.flags() | QtGui.QTextOption.ShowTabsAndSpaces) # else: # self.setFlags(self.flags() & ~QtGui.QTextOption.ShowTabsAndSpaces) def clear_stacks ( self , stack : StackStr ): \"\"\"Clear undo / redo stack. Args: stack: stack to clear Raises: InvalidParamError: stack type does not exist \"\"\" if stack not in STACKS : raise InvalidParamError ( stack , STACKS ) self . clearUndoRedoStacks ( STACKS [ stack ]) def set_default_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set the cursor move style. Args: style: cursor move style Raises: InvalidParamError: cursor move style does not exist \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setDefaultCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ]) def get_default_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return current cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . defaultCursorMoveStyle ()] def add_resource ( self , resource_type : ResourceTypeStr , name : types . PathType , resource ): if resource_type not in RESOURCE_TYPES : raise InvalidParamError ( resource_type , RESOURCE_TYPES ) url = core . Url ( name ) self . addResource ( RESOURCE_TYPES [ resource_type ], url , resource ) @contextlib . contextmanager def edit_default_stylesheet ( self ) -> Iterator [ qstylizer . style . StyleSheet ]: ss = self . get_default_stylesheet () yield ss self . set_default_stylesheet ( ss ) def set_default_stylesheet ( self , ss : None | str | qstylizer . style . StyleSheet | types . PathType ): if isinstance ( ss , os . PathLike ): ss = pathlib . Path ( ss ) . read_text () elif ss is None : ss = \"\" self . setDefaultStyleSheet ( str ( ss )) def get_default_stylesheet ( self ) -> qstylizer . style . StyleSheet : return qstylizer . parser . parse ( self . defaultStyleSheet ()) def find_line_position ( self , line_no : int ) -> int : lines = self . blockCount () assert 1 <= line_no <= lines return self . findBlockByLineNumber ( line_no - 1 ) . position () def write_to_file ( self , path : types . PathType , fmt : gui . textdocumentwriter . FormatStr | bytes | QtCore . QByteArray = \"plaintext\" , ): writer = gui . TextDocumentWriter () writer . set_format ( fmt ) writer . set_file_name ( path ) return writer . write ( self ) def show_whitespace_and_tabs ( self , show : bool ): \"\"\"Set show white spaces flag.\"\"\" options = self . get_default_text_option () flag = QtGui . QTextOption . Flag . ShowTabsAndSpaces if show : options . setFlags ( options . flags () | flag ) # type: ignore else : options . setFlags ( options . flags () & ~ flag ) # type: ignore self . setDefaultTextOption ( options )","title":"TextDocument"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.clear_stacks","text":"Clear undo / redo stack. Parameters: Name Type Description Default stack StackStr stack to clear required Exceptions: Type Description InvalidParamError stack type does not exist Source code in prettyqt/gui/textdocument.py def clear_stacks ( self , stack : StackStr ): \"\"\"Clear undo / redo stack. Args: stack: stack to clear Raises: InvalidParamError: stack type does not exist \"\"\" if stack not in STACKS : raise InvalidParamError ( stack , STACKS ) self . clearUndoRedoStacks ( STACKS [ stack ])","title":"clear_stacks()"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.get_default_cursor_move_style","text":"Return current cursor move style. Returns: Type Description constants.CursorMoveStyleStr cursor move style Source code in prettyqt/gui/textdocument.py def get_default_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return current cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . defaultCursorMoveStyle ()]","title":"get_default_cursor_move_style()"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.set_default_cursor_move_style","text":"Set the cursor move style. Parameters: Name Type Description Default style constants.CursorMoveStyleStr cursor move style required Exceptions: Type Description InvalidParamError cursor move style does not exist Source code in prettyqt/gui/textdocument.py def set_default_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set the cursor move style. Args: style: cursor move style Raises: InvalidParamError: cursor move style does not exist \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setDefaultCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ])","title":"set_default_cursor_move_style()"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.show_whitespace_and_tabs","text":"Set show white spaces flag. Source code in prettyqt/gui/textdocument.py def show_whitespace_and_tabs ( self , show : bool ): \"\"\"Set show white spaces flag.\"\"\" options = self . get_default_text_option () flag = QtGui . QTextOption . Flag . ShowTabsAndSpaces if show : options . setFlags ( options . flags () | flag ) # type: ignore else : options . setFlags ( options . flags () & ~ flag ) # type: ignore self . setDefaultTextOption ( options )","title":"show_whitespace_and_tabs()"},{"location":"api/gui.html#prettyqt.gui.textformat","text":"","title":"textformat"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormat","text":"Source code in prettyqt/gui/textformat.py class TextFormat ( QtGui . QTextFormat ): def __getitem__ ( self , key : int ): return self . property ( key ) def __setitem__ ( self , key : int , value ): self . setProperty ( key , value ) def __contains__ ( self , key : int ): return self . hasProperty ( key ) def __bool__ ( self ): return self . isValid () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . type () } )\" def get_background ( self ) -> gui . Brush : return gui . Brush ( self . background ()) def get_foreground ( self ) -> gui . Brush : return gui . Brush ( self . foreground ()) def get_brush_property ( self , property_id : int ) -> gui . Brush : return gui . Brush ( self . brushProperty ( property_id )) def get_color_property ( self , property_id : int ) -> gui . Color : return gui . Color ( self . colorProperty ( property_id )) def get_pen_property ( self , property_id : int ) -> gui . Pen : return gui . Pen ( self . penProperty ( property_id )) def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ]) def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()] def select_full_width ( self , value : bool = True ): prop = QtGui . QTextFormat . Property . FullWidthSelection self . setProperty ( prop , value ) # type: ignore","title":"TextFormat"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormat.get_layout_direction","text":"Get the current layout direction. Returns: Type Description constants.LayoutDirectionStr layout direction Source code in prettyqt/gui/textformat.py def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()]","title":"get_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormat.set_layout_direction","text":"Set layout direction. Parameters: Name Type Description Default direction constants.LayoutDirectionStr layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/textformat.py def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ])","title":"set_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.textframeformat","text":"","title":"textframeformat"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat","text":"Source code in prettyqt/gui/textframeformat.py class TextFrameFormat ( QtGui . QTextFrameFormat ): def get_height ( self ) -> gui . TextLength : length = self . height () return gui . TextLength ( length . type (), length . rawValue ()) def get_width ( self ) -> gui . TextLength : length = self . width () return gui . TextLength ( length . type (), length . rawValue ()) def get_border_brush ( self ) -> gui . Brush : return gui . Brush ( self . borderBrush ()) def set_border_style ( self , style : BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in BORDER_STYLES : raise InvalidParamError ( style , BORDER_STYLES ) self . setBorderStyle ( BORDER_STYLES [ style ]) def get_border_style ( self ) -> BorderStyleStr : \"\"\"Get the current border style. Returns: border style \"\"\" return BORDER_STYLES . inverse [ self . borderStyle ()] def set_page_break_policy ( self , policy : gui . textformat . PageBreakFlagStr ): \"\"\"Set page break policy. Args: policy: page break policy Raises: InvalidParamError: page break policy does not exist \"\"\" if policy not in gui . textformat . PAGE_BREAK_FLAG : raise InvalidParamError ( policy , gui . textformat . PAGE_BREAK_FLAG ) self . setPageBreakPolicy ( gui . textformat . PAGE_BREAK_FLAG [ policy ]) def get_page_break_policy ( self ) -> gui . textformat . PageBreakFlagStr : \"\"\"Get the current page break policy. Returns: page break policy \"\"\" return gui . textformat . PAGE_BREAK_FLAG . inverse [ self . pageBreakPolicy ()] def set_position ( self , position : PositionStr ): \"\"\"Set position. Args: position: position Raises: InvalidParamError: position does not exist \"\"\" if position not in POSITIONS : raise InvalidParamError ( position , POSITIONS ) self . setPosition ( POSITIONS [ position ]) def get_position ( self ) -> PositionStr : \"\"\"Get the current position. Returns: position \"\"\" return POSITIONS . inverse [ self . position ()]","title":"TextFrameFormat"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_border_style","text":"Get the current border style. Returns: Type Description BorderStyleStr border style Source code in prettyqt/gui/textframeformat.py def get_border_style ( self ) -> BorderStyleStr : \"\"\"Get the current border style. Returns: border style \"\"\" return BORDER_STYLES . inverse [ self . borderStyle ()]","title":"get_border_style()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_page_break_policy","text":"Get the current page break policy. Returns: Type Description gui.textformat.PageBreakFlagStr page break policy Source code in prettyqt/gui/textframeformat.py def get_page_break_policy ( self ) -> gui . textformat . PageBreakFlagStr : \"\"\"Get the current page break policy. Returns: page break policy \"\"\" return gui . textformat . PAGE_BREAK_FLAG . inverse [ self . pageBreakPolicy ()]","title":"get_page_break_policy()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_position","text":"Get the current position. Returns: Type Description PositionStr position Source code in prettyqt/gui/textframeformat.py def get_position ( self ) -> PositionStr : \"\"\"Get the current position. Returns: position \"\"\" return POSITIONS . inverse [ self . position ()]","title":"get_position()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_border_style","text":"Set border style. Parameters: Name Type Description Default style BorderStyleStr border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/textframeformat.py def set_border_style ( self , style : BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in BORDER_STYLES : raise InvalidParamError ( style , BORDER_STYLES ) self . setBorderStyle ( BORDER_STYLES [ style ])","title":"set_border_style()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_page_break_policy","text":"Set page break policy. Parameters: Name Type Description Default policy gui.textformat.PageBreakFlagStr page break policy required Exceptions: Type Description InvalidParamError page break policy does not exist Source code in prettyqt/gui/textframeformat.py def set_page_break_policy ( self , policy : gui . textformat . PageBreakFlagStr ): \"\"\"Set page break policy. Args: policy: page break policy Raises: InvalidParamError: page break policy does not exist \"\"\" if policy not in gui . textformat . PAGE_BREAK_FLAG : raise InvalidParamError ( policy , gui . textformat . PAGE_BREAK_FLAG ) self . setPageBreakPolicy ( gui . textformat . PAGE_BREAK_FLAG [ policy ])","title":"set_page_break_policy()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_position","text":"Set position. Parameters: Name Type Description Default position PositionStr position required Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/gui/textframeformat.py def set_position ( self , position : PositionStr ): \"\"\"Set position. Args: position: position Raises: InvalidParamError: position does not exist \"\"\" if position not in POSITIONS : raise InvalidParamError ( position , POSITIONS ) self . setPosition ( POSITIONS [ position ])","title":"set_position()"},{"location":"api/gui.html#prettyqt.gui.textlength","text":"","title":"textlength"},{"location":"api/gui.html#prettyqt.gui.textlength.TextLength","text":"Source code in prettyqt/gui/textlength.py class TextLength ( QtGui . QTextLength ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . type () } , { self . rawValue () } )\" def get_type ( self ) -> TypeStr : \"\"\"Return type of this length object. Returns: timer type \"\"\" return TYPES . inverse [ self . type ()]","title":"TextLength"},{"location":"api/gui.html#prettyqt.gui.textlength.TextLength.get_type","text":"Return type of this length object. Returns: Type Description TypeStr timer type Source code in prettyqt/gui/textlength.py def get_type ( self ) -> TypeStr : \"\"\"Return type of this length object. Returns: timer type \"\"\" return TYPES . inverse [ self . type ()]","title":"get_type()"},{"location":"api/gui.html#prettyqt.gui.textlistformat","text":"","title":"textlistformat"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat","text":"Source code in prettyqt/gui/textlistformat.py class TextListFormat ( QtGui . QTextListFormat ): def set_style ( self , style : StyleStr ): \"\"\"Set the style. Args: style: style Raises: InvalidParamError: invalid style \"\"\" if style not in STYLES : raise InvalidParamError ( style , STYLES ) self . setStyle ( STYLES [ style ]) def get_style ( self ) -> StyleStr : \"\"\"Get current style. Returns: current style \"\"\" return STYLES . inverse [ self . style ()]","title":"TextListFormat"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.get_style","text":"Get current style. Returns: Type Description StyleStr current style Source code in prettyqt/gui/textlistformat.py def get_style ( self ) -> StyleStr : \"\"\"Get current style. Returns: current style \"\"\" return STYLES . inverse [ self . style ()]","title":"get_style()"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.set_style","text":"Set the style. Parameters: Name Type Description Default style StyleStr style required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/gui/textlistformat.py def set_style ( self , style : StyleStr ): \"\"\"Set the style. Args: style: style Raises: InvalidParamError: invalid style \"\"\" if style not in STYLES : raise InvalidParamError ( style , STYLES ) self . setStyle ( STYLES [ style ])","title":"set_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat","text":"","title":"texttablecellformat"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat","text":"Source code in prettyqt/gui/texttablecellformat.py class TextTableCellFormat ( QtGui . QTextTableCellFormat ): def get_bottom_border_brush ( self ) -> gui . Brush : return gui . Brush ( self . bottomBorderBrush ()) def set_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) def set_bottom_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set bottom border style. Args: style: bottom border style Raises: InvalidParamError: bottom border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBottomBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) def get_bottom_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current bottom border style. Returns: bottom border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . bottomBorderStyle ()] def get_left_border_brush ( self ) -> gui . Brush : return gui . Brush ( self . leftBorderBrush ()) def set_left_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set left border style. Args: style: left border style Raises: InvalidParamError: left border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setLeftBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) def get_left_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current left border style. Returns: left border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . leftBorderStyle ()] def get_right_border_brush ( self ) -> gui . Brush : return gui . Brush ( self . rightBorderBrush ()) def set_right_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set right border style. Args: style: right border style Raises: InvalidParamError: right border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setRightBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) def get_right_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current right border style. Returns: right border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . rightBorderStyle ()] def get_top_border_brush ( self ) -> gui . Brush : return gui . Brush ( self . topBorderBrush ()) def set_top_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set top border style. Args: style: top border style Raises: InvalidParamError: top border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setTopBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) def get_top_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current top border style. Returns: top border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . topBorderStyle ()]","title":"TextTableCellFormat"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_bottom_border_style","text":"Get the current bottom border style. Returns: Type Description gui.textframeformat.BorderStyleStr bottom border style Source code in prettyqt/gui/texttablecellformat.py def get_bottom_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current bottom border style. Returns: bottom border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . bottomBorderStyle ()]","title":"get_bottom_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_left_border_style","text":"Get the current left border style. Returns: Type Description gui.textframeformat.BorderStyleStr left border style Source code in prettyqt/gui/texttablecellformat.py def get_left_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current left border style. Returns: left border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . leftBorderStyle ()]","title":"get_left_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_right_border_style","text":"Get the current right border style. Returns: Type Description gui.textframeformat.BorderStyleStr right border style Source code in prettyqt/gui/texttablecellformat.py def get_right_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current right border style. Returns: right border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . rightBorderStyle ()]","title":"get_right_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_top_border_style","text":"Get the current top border style. Returns: Type Description gui.textframeformat.BorderStyleStr top border style Source code in prettyqt/gui/texttablecellformat.py def get_top_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current top border style. Returns: top border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . topBorderStyle ()]","title":"get_top_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_border_style","text":"Set border style. Parameters: Name Type Description Default style gui.textframeformat.BorderStyleStr border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_bottom_border_style","text":"Set bottom border style. Parameters: Name Type Description Default style gui.textframeformat.BorderStyleStr bottom border style required Exceptions: Type Description InvalidParamError bottom border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_bottom_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set bottom border style. Args: style: bottom border style Raises: InvalidParamError: bottom border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBottomBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_bottom_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_left_border_style","text":"Set left border style. Parameters: Name Type Description Default style gui.textframeformat.BorderStyleStr left border style required Exceptions: Type Description InvalidParamError left border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_left_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set left border style. Args: style: left border style Raises: InvalidParamError: left border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setLeftBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_left_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_right_border_style","text":"Set right border style. Parameters: Name Type Description Default style gui.textframeformat.BorderStyleStr right border style required Exceptions: Type Description InvalidParamError right border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_right_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set right border style. Args: style: right border style Raises: InvalidParamError: right border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setRightBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_right_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_top_border_style","text":"Set top border style. Parameters: Name Type Description Default style gui.textframeformat.BorderStyleStr top border style required Exceptions: Type Description InvalidParamError top border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_top_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set top border style. Args: style: top border style Raises: InvalidParamError: top border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setTopBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_top_border_style()"},{"location":"api/gui.html#prettyqt.gui.validator","text":"","title":"validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator","text":"Source code in prettyqt/gui/validator.py class Validator ( QtGui . QValidator ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def __add__ ( self , other : Validator ): from prettyqt import custom_validators return custom_validators . CompositeValidator ([ self , other ]) def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other ) def is_valid_value ( self , value : str , pos : int = 0 ) -> bool : val = self . validate ( value , pos ) return val [ 0 ] == self . State . Acceptable # type: ignore","title":"Validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator.__radd__","text":"Needed for sum(). Source code in prettyqt/gui/validator.py def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other )","title":"__radd__()"},{"location":"api/gui.html#prettyqt.gui.window","text":"","title":"window"},{"location":"api/gui.html#prettyqt.gui.window.Window","text":"Source code in prettyqt/gui/window.py class Window ( QtGui . QWindow ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" # def serialize_fields(self): # return dict( # speed=self.speed(), # visibility=self.get_visibility(), # scaled_size=self.scaledSize(), # background_color=self.backgroundColor(), # ) def set_visibility ( self , visibility : VisibilityStr ): \"\"\"Set window visibility. Args: visibility: window visibility Raises: InvalidParamError: window visibility does not exist \"\"\" if visibility not in VISIBILITY : raise InvalidParamError ( visibility , VISIBILITY ) self . setVisibility ( VISIBILITY [ visibility ]) def get_visibility ( self ) -> VisibilityStr : \"\"\"Get the current window visibility. Returns: window visibility \"\"\" return VISIBILITY . inverse [ self . visibility ()] def start_system_resize ( self , edge : constants . EdgeStr ) -> bool : \"\"\"Start system resize. Args: edge: edge to resize Raises: InvalidParamError: edge does not exist \"\"\" if edge not in constants . EDGES : raise InvalidParamError ( edge , constants . EDGES ) return self . startSystemResize ( constants . EDGES [ edge ]) def get_screen ( self ) -> gui . Screen : return gui . Screen ( self . screen ())","title":"Window"},{"location":"api/gui.html#prettyqt.gui.window.Window.get_visibility","text":"Get the current window visibility. Returns: Type Description VisibilityStr window visibility Source code in prettyqt/gui/window.py def get_visibility ( self ) -> VisibilityStr : \"\"\"Get the current window visibility. Returns: window visibility \"\"\" return VISIBILITY . inverse [ self . visibility ()]","title":"get_visibility()"},{"location":"api/gui.html#prettyqt.gui.window.Window.set_visibility","text":"Set window visibility. Parameters: Name Type Description Default visibility VisibilityStr window visibility required Exceptions: Type Description InvalidParamError window visibility does not exist Source code in prettyqt/gui/window.py def set_visibility ( self , visibility : VisibilityStr ): \"\"\"Set window visibility. Args: visibility: window visibility Raises: InvalidParamError: window visibility does not exist \"\"\" if visibility not in VISIBILITY : raise InvalidParamError ( visibility , VISIBILITY ) self . setVisibility ( VISIBILITY [ visibility ])","title":"set_visibility()"},{"location":"api/gui.html#prettyqt.gui.window.Window.start_system_resize","text":"Start system resize. Parameters: Name Type Description Default edge constants.EdgeStr edge to resize required Exceptions: Type Description InvalidParamError edge does not exist Source code in prettyqt/gui/window.py def start_system_resize ( self , edge : constants . EdgeStr ) -> bool : \"\"\"Start system resize. Args: edge: edge to resize Raises: InvalidParamError: edge does not exist \"\"\" if edge not in constants . EDGES : raise InvalidParamError ( edge , constants . EDGES ) return self . startSystemResize ( constants . EDGES [ edge ])","title":"start_system_resize()"},{"location":"api/network.html","text":"network module Network module. Contains QtNetWork-based classes abstractsocket AbstractSocket ( QAbstractSocket ) Source code in prettyqt/network/abstractsocket.py class AbstractSocket ( QtNetwork . QAbstractSocket ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def bind_to ( self , address : str | QtNetwork . QHostAddress , port : int = 0 , bind_mode : ( QtNetwork . QAbstractSocket . BindMode | BindModeStr ) = \"default_for_platform\" , ) -> bool : if isinstance ( address , str ): address = QtNetwork . QHostAddress ( address ) if bind_mode in BIND_MODE : mode = BIND_MODE [ bind_mode ] else : mode = bind_mode return self . bind ( address , port , mode ) def connect_to_host ( self , hostname : str , port : int , open_mode : ( QtCore . QIODevice . OpenMode | core . iodevice . OpenModeStr ) = \"read_write\" , protocol : ( QtNetwork . QAbstractSocket . NetworkLayerProtocol | NetworkLayerProtocolStr ) = \"any_ip\" , ): if isinstance ( open_mode , QtCore . QIODevice . OpenMode ): mode = open_mode else : mode = core . iodevice . OPEN_MODES [ open_mode ] if isinstance ( protocol , QtNetwork . QAbstractSocket . NetworkLayerProtocol ): prot = protocol else : prot = NETWORK_LAYER_PROTOCOL [ protocol ] self . connectToHost ( hostname , port , mode , prot ) def get_error ( self ) -> SocketErrorStr : return SOCKET_ERROR . inverse [ self . error ()] def set_pause_mode ( self , mode : PauseModeStr ): \"\"\"Set pause mode. Args: mode: pause mode Raises: InvalidParamError: pause mode does not exist \"\"\" if mode not in PAUSE_MODES : raise InvalidParamError ( mode , PAUSE_MODES ) self . setPauseMode ( PAUSE_MODES [ mode ]) def get_pause_mode ( self ) -> PauseModeStr : return PAUSE_MODES . inverse [ self . pauseMode ()] def get_proxy ( self ) -> network . NetworkProxy : return network . NetworkProxy ( self . proxy ()) # def set_socket_option(self, name: str, value): # if name not in SOCKET_OPTION: # raise InvalidParamError(name, SOCKET_OPTION) # self.setSocketOption(SOCKET_OPTION[name], value) # def get_socket_option(self, name: str): # return self.socketOption(SOCKET_OPTION[name]) # def set_type_of_service(self, typ: str): # if typ not in TYPE_OF_SERVICE: # raise InvalidParamError(typ, TYPE_OF_SERVICE) # self.set_socket_option(\"type_of_service\", TYPE_OF_SERVICE[typ]) # def get_type_of_service(self): # opt = self.get_socket_option(\"type_of_service\") # return TYPE_OF_SERVICE.inverse[opt] def get_socket_type ( self ) -> SocketTypeStr : return SOCKET_TYPE . inverse [ self . socketType ()] def get_state ( self ) -> SocketStateStr : return SOCKET_STATE . inverse [ self . state ()] def get_local_address ( self ) -> network . HostAddress : return network . HostAddress ( self . localAddress ()) set_pause_mode ( self , mode : PauseModeStr ) Set pause mode. Parameters: Name Type Description Default mode PauseModeStr pause mode required Exceptions: Type Description InvalidParamError pause mode does not exist Source code in prettyqt/network/abstractsocket.py def set_pause_mode ( self , mode : PauseModeStr ): \"\"\"Set pause mode. Args: mode: pause mode Raises: InvalidParamError: pause mode does not exist \"\"\" if mode not in PAUSE_MODES : raise InvalidParamError ( mode , PAUSE_MODES ) self . setPauseMode ( PAUSE_MODES [ mode ]) httpmultipart HttpMultiPart ( QHttpMultiPart ) Source code in prettyqt/network/httpmultipart.py class HttpMultiPart ( QtNetwork . QHttpMultiPart ): def __add__ ( self , other : QtNetwork . QHttpPart ): self . append ( other ) return self def set_content_type ( self , typ : ContentTypeStr ): \"\"\"Set content type. Args: typ: content type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in CONTENT_TYPES : raise InvalidParamError ( typ , CONTENT_TYPES ) self . setContentType ( CONTENT_TYPES [ typ ]) def set_boundary ( self , boundary : types . ByteArrayType ): if isinstance ( boundary , str ): boundary = boundary . encode () if isinstance ( boundary , bytes ): boundary = QtCore . QByteArray ( boundary ) self . setBoundary ( boundary ) def get_boundary ( self ) -> str : return bytes ( self . boundary ()) . decode () set_content_type ( self , typ : ContentTypeStr ) Set content type. Parameters: Name Type Description Default typ ContentTypeStr content type required Exceptions: Type Description InvalidParamError content type does not exist Source code in prettyqt/network/httpmultipart.py def set_content_type ( self , typ : ContentTypeStr ): \"\"\"Set content type. Args: typ: content type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in CONTENT_TYPES : raise InvalidParamError ( typ , CONTENT_TYPES ) self . setContentType ( CONTENT_TYPES [ typ ]) networkaccessmanager NetworkAccessManager ( QNetworkAccessManager ) Source code in prettyqt/network/networkaccessmanager.py class NetworkAccessManager ( QtNetwork . QNetworkAccessManager ): # def request( # self, # method, # url, # headers=None, # cookies=None, # files=None, # auth=None, # timeout=None, # allow_redirects=True, # ): # req = network.NetworkRequest() # if allow_redirects: # pass def get ( self , request : types . UrlType | QtNetwork . QNetworkRequest ): if isinstance ( request , str ): request = core . Url ( request ) request = network . NetworkRequest ( request ) return super () . get ( request ) # def post(self, url, data=None, json=None): # pass # def put(self, url, data=None, json=None): # pass # def patch(self, url, data=None): # pass # def delete(self, url): # pass def set_redirect_policy ( self , policy : network . networkrequest . RedirectPolicyStr ): \"\"\"Set redirect policy. Args: policy: redirect policy Raises: InvalidParamError: redirect policy does not exist \"\"\" if policy not in network . networkrequest . REDIRECT_POLICIES : raise InvalidParamError ( policy , network . networkrequest . REDIRECT_POLICIES ) self . setRedirectPolicy ( network . networkrequest . REDIRECT_POLICIES [ policy ]) def get_redirect_policy ( self ) -> network . networkrequest . RedirectPolicyStr : \"\"\"Get the current redirect policy. Returns: redirect policy \"\"\" return network . networkrequest . REDIRECT_POLICIES . inverse [ self . redirectPolicy ()] get ( self , request : types . UrlType | QtNetwork . QNetworkRequest ) get(self, request: PySide6.QtNetwork.QNetworkRequest) -> PySide6.QtNetwork.QNetworkReply Source code in prettyqt/network/networkaccessmanager.py def get ( self , request : types . UrlType | QtNetwork . QNetworkRequest ): if isinstance ( request , str ): request = core . Url ( request ) request = network . NetworkRequest ( request ) return super () . get ( request ) get_redirect_policy ( self ) -> network . networkrequest . RedirectPolicyStr Get the current redirect policy. Returns: Type Description network.networkrequest.RedirectPolicyStr redirect policy Source code in prettyqt/network/networkaccessmanager.py def get_redirect_policy ( self ) -> network . networkrequest . RedirectPolicyStr : \"\"\"Get the current redirect policy. Returns: redirect policy \"\"\" return network . networkrequest . REDIRECT_POLICIES . inverse [ self . redirectPolicy ()] set_redirect_policy ( self , policy : network . networkrequest . RedirectPolicyStr ) Set redirect policy. Parameters: Name Type Description Default policy network.networkrequest.RedirectPolicyStr redirect policy required Exceptions: Type Description InvalidParamError redirect policy does not exist Source code in prettyqt/network/networkaccessmanager.py def set_redirect_policy ( self , policy : network . networkrequest . RedirectPolicyStr ): \"\"\"Set redirect policy. Args: policy: redirect policy Raises: InvalidParamError: redirect policy does not exist \"\"\" if policy not in network . networkrequest . REDIRECT_POLICIES : raise InvalidParamError ( policy , network . networkrequest . REDIRECT_POLICIES ) self . setRedirectPolicy ( network . networkrequest . REDIRECT_POLICIES [ policy ]) networkaddressentry NetworkAddressEntry ( QNetworkAddressEntry ) Source code in prettyqt/network/networkaddressentry.py class NetworkAddressEntry ( QtNetwork . QNetworkAddressEntry ): def get_dns_eligibility ( self ) -> DnsEligibilityStatusStr : \"\"\"Return whether this address is eligible for publication in the DNS. Returns: DNS eligibility \"\"\" return DNS_ELIGIBILITY_STATUS . inverse [ self . dnsEligibility ()] def set_dns_eligibility ( self , status : DnsEligibilityStatusStr ): \"\"\"Set the DNS eligibility flag for this address to status. Args: status: DNS eligibility status Raises: InvalidParamError: dns eligibility status does not exist \"\"\" if status not in DNS_ELIGIBILITY_STATUS : raise InvalidParamError ( status , DNS_ELIGIBILITY_STATUS ) self . setDnsEligibility ( DNS_ELIGIBILITY_STATUS [ status ]) def get_ip ( self ) -> network . HostAddress : return network . HostAddress ( self . ip ()) def set_ip ( self , ip : QtNetwork . QHostAddress | str ): self . setIp ( network . HostAddress ( ip )) def get_netmask ( self ) -> network . HostAddress : return network . HostAddress ( self . netmask ()) def set_netmask ( self , netmask : QtNetwork . QHostAddress | str ): self . setNetmask ( network . HostAddress ( netmask )) def get_preferred_lifetime ( self ) -> core . DeadlineTimer : return core . DeadlineTimer ( self . preferredLifetime ()) def get_validity_lifetime ( self ) -> core . DeadlineTimer : return core . DeadlineTimer ( self . validityLifetime ()) get_dns_eligibility ( self ) -> DnsEligibilityStatusStr Return whether this address is eligible for publication in the DNS. Returns: Type Description DnsEligibilityStatusStr DNS eligibility Source code in prettyqt/network/networkaddressentry.py def get_dns_eligibility ( self ) -> DnsEligibilityStatusStr : \"\"\"Return whether this address is eligible for publication in the DNS. Returns: DNS eligibility \"\"\" return DNS_ELIGIBILITY_STATUS . inverse [ self . dnsEligibility ()] set_dns_eligibility ( self , status : DnsEligibilityStatusStr ) Set the DNS eligibility flag for this address to status. Parameters: Name Type Description Default status DnsEligibilityStatusStr DNS eligibility status required Exceptions: Type Description InvalidParamError dns eligibility status does not exist Source code in prettyqt/network/networkaddressentry.py def set_dns_eligibility ( self , status : DnsEligibilityStatusStr ): \"\"\"Set the DNS eligibility flag for this address to status. Args: status: DNS eligibility status Raises: InvalidParamError: dns eligibility status does not exist \"\"\" if status not in DNS_ELIGIBILITY_STATUS : raise InvalidParamError ( status , DNS_ELIGIBILITY_STATUS ) self . setDnsEligibility ( DNS_ELIGIBILITY_STATUS [ status ]) networkinterface NetworkInterface ( QNetworkInterface ) Source code in prettyqt/network/networkinterface.py class NetworkInterface ( QtNetwork . QNetworkInterface ): # def __bool__(self): # return self.isValid() def get_type ( self ) -> InterfaceTypeStr : \"\"\"Get the interface type. Returns: interface type \"\"\" return INTERFACE_TYPE . inverse [ self . type ()] def get_address_entries ( self ) -> list [ network . NetworkAddressEntry ]: return [ network . NetworkAddressEntry ( i ) for i in self . addressEntries ()] @staticmethod def get_all_addresses () -> list [ network . HostAddress ]: return [ network . HostAddress ( i ) for i in NetworkInterface . allAddresses ()] @staticmethod def get_all_interfaces () -> list [ network . HostAddress ]: return [ network . NetworkInterface ( i ) for i in NetworkInterface . allInterfaces ()] @staticmethod def get_interface_from_name ( name : str ) -> NetworkInterface : interface = NetworkInterface . interfaceFromName ( name ) # if not interface: # return None return NetworkInterface ( interface ) get_type ( self ) -> InterfaceTypeStr Get the interface type. Returns: Type Description InterfaceTypeStr interface type Source code in prettyqt/network/networkinterface.py def get_type ( self ) -> InterfaceTypeStr : \"\"\"Get the interface type. Returns: interface type \"\"\" return INTERFACE_TYPE . inverse [ self . type ()] networkproxy NetworkProxy ( QNetworkProxy ) Source code in prettyqt/network/networkproxy.py class NetworkProxy ( QtNetwork . QNetworkProxy ): def get_capabilities ( self ) -> list [ CapabilityStr ]: return [ k for k , v in CAPABILITIES . items () if v & self . capabilities ()] def set_capabilities ( self , * capability : CapabilityStr ): for item in capability : if item not in CAPABILITIES : raise InvalidParamError ( item , CAPABILITIES ) flags = helpers . merge_flags ( capability , CAPABILITIES ) self . setCapabilities ( flags ) def get_header ( self , name : network . networkrequest . KnownHeaderStr ) -> str : if name not in network . networkrequest . KNOWN_HEADER : raise InvalidParamError ( name , network . networkrequest . KNOWN_HEADER ) return self . header ( network . networkrequest . KNOWN_HEADER [ name ]) def set_header ( self , name : network . networkrequest . KnownHeaderStr , value : str ): if name not in network . networkrequest . KNOWN_HEADER : raise InvalidParamError ( name , network . networkrequest . KNOWN_HEADER ) self . setHeader ( network . networkrequest . KNOWN_HEADER [ name ], value ) def get_headers ( self ) -> dict [ str , str ]: return { bytes ( h ) . decode (): bytes ( self . rawHeader ( h )) . decode () for h in self . rawHeaderList () } def set_headers ( self , headers : dict [ str , str ]): for k , v in headers . items (): self . setRawHeader ( QtCore . QByteArray ( k . encode ()), QtCore . QByteArray ( v . encode ()) ) def set_type ( self , typ : ProxyTypeStr ): \"\"\"Set proxy type. Args: typ: proxy type Raises: InvalidParamError: proxy type does not exist \"\"\" if typ not in PROXY_TYPES : raise InvalidParamError ( typ , PROXY_TYPES ) self . setType ( PROXY_TYPES [ typ ]) def get_type ( self ) -> ProxyTypeStr : \"\"\"Get the proxy type. Returns: type \"\"\" return PROXY_TYPES . inverse [ self . type ()] get_type ( self ) -> ProxyTypeStr Get the proxy type. Returns: Type Description ProxyTypeStr type Source code in prettyqt/network/networkproxy.py def get_type ( self ) -> ProxyTypeStr : \"\"\"Get the proxy type. Returns: type \"\"\" return PROXY_TYPES . inverse [ self . type ()] set_type ( self , typ : ProxyTypeStr ) Set proxy type. Parameters: Name Type Description Default typ ProxyTypeStr proxy type required Exceptions: Type Description InvalidParamError proxy type does not exist Source code in prettyqt/network/networkproxy.py def set_type ( self , typ : ProxyTypeStr ): \"\"\"Set proxy type. Args: typ: proxy type Raises: InvalidParamError: proxy type does not exist \"\"\" if typ not in PROXY_TYPES : raise InvalidParamError ( typ , PROXY_TYPES ) self . setType ( PROXY_TYPES [ typ ]) networkrequest NetworkRequest ( QNetworkRequest ) Source code in prettyqt/network/networkrequest.py class NetworkRequest ( QtNetwork . QNetworkRequest ): def __init__ ( self , obj : types . UrlType | QtNetwork . QNetworkRequest | None = None ): if isinstance ( obj , QtNetwork . QNetworkRequest ): super () . __init__ ( obj ) else : super () . __init__ () if obj is not None : self . set_url ( obj ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_url () } )\" def set_header ( self , name : KnownHeaderStr , value : str ): if name not in KNOWN_HEADER : raise InvalidParamError ( name , KNOWN_HEADER ) self . setHeader ( KNOWN_HEADER [ name ], value ) def get_header ( self , name : KnownHeaderStr ) -> str : if name not in KNOWN_HEADER : raise InvalidParamError ( name , KNOWN_HEADER ) return self . header ( KNOWN_HEADER [ name ]) def set_headers ( self , headers : dict [ str , str ]): for k , v in headers . items (): self . setRawHeader ( QtCore . QByteArray ( k . encode ()), QtCore . QByteArray ( v . encode ()) ) def get_headers ( self ) -> dict [ str , str ]: return { bytes ( h ) . decode (): bytes ( self . rawHeader ( h )) . decode () for h in self . rawHeaderList () } def set_url ( self , url : str | QtCore . QUrl ): url = core . Url ( url ) self . setUrl ( url ) def get_url ( self ) -> core . Url : return core . Url ( self . url ()) def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority. Args: priority: priority Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITY : raise InvalidParamError ( priority , PRIORITY ) self . setPriority ( PRIORITY [ priority ]) def get_priority ( self ) -> PriorityStr : \"\"\"Get the current priority. Returns: priority \"\"\" return PRIORITY . inverse [ self . priority ()] get_priority ( self ) -> PriorityStr Get the current priority. Returns: Type Description PriorityStr priority Source code in prettyqt/network/networkrequest.py def get_priority ( self ) -> PriorityStr : \"\"\"Get the current priority. Returns: priority \"\"\" return PRIORITY . inverse [ self . priority ()] set_priority ( self , priority : PriorityStr ) Set priority. Parameters: Name Type Description Default priority PriorityStr priority required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/network/networkrequest.py def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority. Args: priority: priority Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITY : raise InvalidParamError ( priority , PRIORITY ) self . setPriority ( PRIORITY [ priority ]) tcpserver TcpServer ( QTcpServer ) Source code in prettyqt/network/tcpserver.py class TcpServer ( QtNetwork . QTcpServer ): def listen ( # type: ignore self , address : str | QtNetwork . QHostAddress , port : int = 0 ) -> bool : if isinstance ( address , str ): address = network . HostAddress ( address ) return super () . listen ( address , port ) def get_server_address ( self ) -> network . HostAddress : return network . HostAddress ( self . serverAddress ()) def get_proxy ( self ) -> network . NetworkProxy : return network . NetworkProxy ( self . proxy ()) def get_server_error ( self ) -> network . abstractsocket . SocketErrorStr : return network . abstractsocket . SOCKET_ERROR . inverse [ self . serverError ()] listen ( self , address : str | QtNetwork . QHostAddress , port : int = 0 ) -> bool listen(self, address: Union[PySide6.QtNetwork.QHostAddress, PySide6.QtNetwork.QHostAddress.SpecialAddress] = Instance(QHostAddress.Any), port: int = 0) -> bool Source code in prettyqt/network/tcpserver.py def listen ( # type: ignore self , address : str | QtNetwork . QHostAddress , port : int = 0 ) -> bool : if isinstance ( address , str ): address = network . HostAddress ( address ) return super () . listen ( address , port )","title":"network"},{"location":"api/network.html#network-module","text":"Network module. Contains QtNetWork-based classes","title":"network module"},{"location":"api/network.html#prettyqt.network.abstractsocket","text":"","title":"abstractsocket"},{"location":"api/network.html#prettyqt.network.abstractsocket.AbstractSocket","text":"Source code in prettyqt/network/abstractsocket.py class AbstractSocket ( QtNetwork . QAbstractSocket ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def bind_to ( self , address : str | QtNetwork . QHostAddress , port : int = 0 , bind_mode : ( QtNetwork . QAbstractSocket . BindMode | BindModeStr ) = \"default_for_platform\" , ) -> bool : if isinstance ( address , str ): address = QtNetwork . QHostAddress ( address ) if bind_mode in BIND_MODE : mode = BIND_MODE [ bind_mode ] else : mode = bind_mode return self . bind ( address , port , mode ) def connect_to_host ( self , hostname : str , port : int , open_mode : ( QtCore . QIODevice . OpenMode | core . iodevice . OpenModeStr ) = \"read_write\" , protocol : ( QtNetwork . QAbstractSocket . NetworkLayerProtocol | NetworkLayerProtocolStr ) = \"any_ip\" , ): if isinstance ( open_mode , QtCore . QIODevice . OpenMode ): mode = open_mode else : mode = core . iodevice . OPEN_MODES [ open_mode ] if isinstance ( protocol , QtNetwork . QAbstractSocket . NetworkLayerProtocol ): prot = protocol else : prot = NETWORK_LAYER_PROTOCOL [ protocol ] self . connectToHost ( hostname , port , mode , prot ) def get_error ( self ) -> SocketErrorStr : return SOCKET_ERROR . inverse [ self . error ()] def set_pause_mode ( self , mode : PauseModeStr ): \"\"\"Set pause mode. Args: mode: pause mode Raises: InvalidParamError: pause mode does not exist \"\"\" if mode not in PAUSE_MODES : raise InvalidParamError ( mode , PAUSE_MODES ) self . setPauseMode ( PAUSE_MODES [ mode ]) def get_pause_mode ( self ) -> PauseModeStr : return PAUSE_MODES . inverse [ self . pauseMode ()] def get_proxy ( self ) -> network . NetworkProxy : return network . NetworkProxy ( self . proxy ()) # def set_socket_option(self, name: str, value): # if name not in SOCKET_OPTION: # raise InvalidParamError(name, SOCKET_OPTION) # self.setSocketOption(SOCKET_OPTION[name], value) # def get_socket_option(self, name: str): # return self.socketOption(SOCKET_OPTION[name]) # def set_type_of_service(self, typ: str): # if typ not in TYPE_OF_SERVICE: # raise InvalidParamError(typ, TYPE_OF_SERVICE) # self.set_socket_option(\"type_of_service\", TYPE_OF_SERVICE[typ]) # def get_type_of_service(self): # opt = self.get_socket_option(\"type_of_service\") # return TYPE_OF_SERVICE.inverse[opt] def get_socket_type ( self ) -> SocketTypeStr : return SOCKET_TYPE . inverse [ self . socketType ()] def get_state ( self ) -> SocketStateStr : return SOCKET_STATE . inverse [ self . state ()] def get_local_address ( self ) -> network . HostAddress : return network . HostAddress ( self . localAddress ())","title":"AbstractSocket"},{"location":"api/network.html#prettyqt.network.abstractsocket.AbstractSocket.set_pause_mode","text":"Set pause mode. Parameters: Name Type Description Default mode PauseModeStr pause mode required Exceptions: Type Description InvalidParamError pause mode does not exist Source code in prettyqt/network/abstractsocket.py def set_pause_mode ( self , mode : PauseModeStr ): \"\"\"Set pause mode. Args: mode: pause mode Raises: InvalidParamError: pause mode does not exist \"\"\" if mode not in PAUSE_MODES : raise InvalidParamError ( mode , PAUSE_MODES ) self . setPauseMode ( PAUSE_MODES [ mode ])","title":"set_pause_mode()"},{"location":"api/network.html#prettyqt.network.httpmultipart","text":"","title":"httpmultipart"},{"location":"api/network.html#prettyqt.network.httpmultipart.HttpMultiPart","text":"Source code in prettyqt/network/httpmultipart.py class HttpMultiPart ( QtNetwork . QHttpMultiPart ): def __add__ ( self , other : QtNetwork . QHttpPart ): self . append ( other ) return self def set_content_type ( self , typ : ContentTypeStr ): \"\"\"Set content type. Args: typ: content type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in CONTENT_TYPES : raise InvalidParamError ( typ , CONTENT_TYPES ) self . setContentType ( CONTENT_TYPES [ typ ]) def set_boundary ( self , boundary : types . ByteArrayType ): if isinstance ( boundary , str ): boundary = boundary . encode () if isinstance ( boundary , bytes ): boundary = QtCore . QByteArray ( boundary ) self . setBoundary ( boundary ) def get_boundary ( self ) -> str : return bytes ( self . boundary ()) . decode ()","title":"HttpMultiPart"},{"location":"api/network.html#prettyqt.network.httpmultipart.HttpMultiPart.set_content_type","text":"Set content type. Parameters: Name Type Description Default typ ContentTypeStr content type required Exceptions: Type Description InvalidParamError content type does not exist Source code in prettyqt/network/httpmultipart.py def set_content_type ( self , typ : ContentTypeStr ): \"\"\"Set content type. Args: typ: content type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in CONTENT_TYPES : raise InvalidParamError ( typ , CONTENT_TYPES ) self . setContentType ( CONTENT_TYPES [ typ ])","title":"set_content_type()"},{"location":"api/network.html#prettyqt.network.networkaccessmanager","text":"","title":"networkaccessmanager"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager","text":"Source code in prettyqt/network/networkaccessmanager.py class NetworkAccessManager ( QtNetwork . QNetworkAccessManager ): # def request( # self, # method, # url, # headers=None, # cookies=None, # files=None, # auth=None, # timeout=None, # allow_redirects=True, # ): # req = network.NetworkRequest() # if allow_redirects: # pass def get ( self , request : types . UrlType | QtNetwork . QNetworkRequest ): if isinstance ( request , str ): request = core . Url ( request ) request = network . NetworkRequest ( request ) return super () . get ( request ) # def post(self, url, data=None, json=None): # pass # def put(self, url, data=None, json=None): # pass # def patch(self, url, data=None): # pass # def delete(self, url): # pass def set_redirect_policy ( self , policy : network . networkrequest . RedirectPolicyStr ): \"\"\"Set redirect policy. Args: policy: redirect policy Raises: InvalidParamError: redirect policy does not exist \"\"\" if policy not in network . networkrequest . REDIRECT_POLICIES : raise InvalidParamError ( policy , network . networkrequest . REDIRECT_POLICIES ) self . setRedirectPolicy ( network . networkrequest . REDIRECT_POLICIES [ policy ]) def get_redirect_policy ( self ) -> network . networkrequest . RedirectPolicyStr : \"\"\"Get the current redirect policy. Returns: redirect policy \"\"\" return network . networkrequest . REDIRECT_POLICIES . inverse [ self . redirectPolicy ()]","title":"NetworkAccessManager"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.get","text":"get(self, request: PySide6.QtNetwork.QNetworkRequest) -> PySide6.QtNetwork.QNetworkReply Source code in prettyqt/network/networkaccessmanager.py def get ( self , request : types . UrlType | QtNetwork . QNetworkRequest ): if isinstance ( request , str ): request = core . Url ( request ) request = network . NetworkRequest ( request ) return super () . get ( request )","title":"get()"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.get_redirect_policy","text":"Get the current redirect policy. Returns: Type Description network.networkrequest.RedirectPolicyStr redirect policy Source code in prettyqt/network/networkaccessmanager.py def get_redirect_policy ( self ) -> network . networkrequest . RedirectPolicyStr : \"\"\"Get the current redirect policy. Returns: redirect policy \"\"\" return network . networkrequest . REDIRECT_POLICIES . inverse [ self . redirectPolicy ()]","title":"get_redirect_policy()"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.set_redirect_policy","text":"Set redirect policy. Parameters: Name Type Description Default policy network.networkrequest.RedirectPolicyStr redirect policy required Exceptions: Type Description InvalidParamError redirect policy does not exist Source code in prettyqt/network/networkaccessmanager.py def set_redirect_policy ( self , policy : network . networkrequest . RedirectPolicyStr ): \"\"\"Set redirect policy. Args: policy: redirect policy Raises: InvalidParamError: redirect policy does not exist \"\"\" if policy not in network . networkrequest . REDIRECT_POLICIES : raise InvalidParamError ( policy , network . networkrequest . REDIRECT_POLICIES ) self . setRedirectPolicy ( network . networkrequest . REDIRECT_POLICIES [ policy ])","title":"set_redirect_policy()"},{"location":"api/network.html#prettyqt.network.networkaddressentry","text":"","title":"networkaddressentry"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry","text":"Source code in prettyqt/network/networkaddressentry.py class NetworkAddressEntry ( QtNetwork . QNetworkAddressEntry ): def get_dns_eligibility ( self ) -> DnsEligibilityStatusStr : \"\"\"Return whether this address is eligible for publication in the DNS. Returns: DNS eligibility \"\"\" return DNS_ELIGIBILITY_STATUS . inverse [ self . dnsEligibility ()] def set_dns_eligibility ( self , status : DnsEligibilityStatusStr ): \"\"\"Set the DNS eligibility flag for this address to status. Args: status: DNS eligibility status Raises: InvalidParamError: dns eligibility status does not exist \"\"\" if status not in DNS_ELIGIBILITY_STATUS : raise InvalidParamError ( status , DNS_ELIGIBILITY_STATUS ) self . setDnsEligibility ( DNS_ELIGIBILITY_STATUS [ status ]) def get_ip ( self ) -> network . HostAddress : return network . HostAddress ( self . ip ()) def set_ip ( self , ip : QtNetwork . QHostAddress | str ): self . setIp ( network . HostAddress ( ip )) def get_netmask ( self ) -> network . HostAddress : return network . HostAddress ( self . netmask ()) def set_netmask ( self , netmask : QtNetwork . QHostAddress | str ): self . setNetmask ( network . HostAddress ( netmask )) def get_preferred_lifetime ( self ) -> core . DeadlineTimer : return core . DeadlineTimer ( self . preferredLifetime ()) def get_validity_lifetime ( self ) -> core . DeadlineTimer : return core . DeadlineTimer ( self . validityLifetime ())","title":"NetworkAddressEntry"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.get_dns_eligibility","text":"Return whether this address is eligible for publication in the DNS. Returns: Type Description DnsEligibilityStatusStr DNS eligibility Source code in prettyqt/network/networkaddressentry.py def get_dns_eligibility ( self ) -> DnsEligibilityStatusStr : \"\"\"Return whether this address is eligible for publication in the DNS. Returns: DNS eligibility \"\"\" return DNS_ELIGIBILITY_STATUS . inverse [ self . dnsEligibility ()]","title":"get_dns_eligibility()"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.set_dns_eligibility","text":"Set the DNS eligibility flag for this address to status. Parameters: Name Type Description Default status DnsEligibilityStatusStr DNS eligibility status required Exceptions: Type Description InvalidParamError dns eligibility status does not exist Source code in prettyqt/network/networkaddressentry.py def set_dns_eligibility ( self , status : DnsEligibilityStatusStr ): \"\"\"Set the DNS eligibility flag for this address to status. Args: status: DNS eligibility status Raises: InvalidParamError: dns eligibility status does not exist \"\"\" if status not in DNS_ELIGIBILITY_STATUS : raise InvalidParamError ( status , DNS_ELIGIBILITY_STATUS ) self . setDnsEligibility ( DNS_ELIGIBILITY_STATUS [ status ])","title":"set_dns_eligibility()"},{"location":"api/network.html#prettyqt.network.networkinterface","text":"","title":"networkinterface"},{"location":"api/network.html#prettyqt.network.networkinterface.NetworkInterface","text":"Source code in prettyqt/network/networkinterface.py class NetworkInterface ( QtNetwork . QNetworkInterface ): # def __bool__(self): # return self.isValid() def get_type ( self ) -> InterfaceTypeStr : \"\"\"Get the interface type. Returns: interface type \"\"\" return INTERFACE_TYPE . inverse [ self . type ()] def get_address_entries ( self ) -> list [ network . NetworkAddressEntry ]: return [ network . NetworkAddressEntry ( i ) for i in self . addressEntries ()] @staticmethod def get_all_addresses () -> list [ network . HostAddress ]: return [ network . HostAddress ( i ) for i in NetworkInterface . allAddresses ()] @staticmethod def get_all_interfaces () -> list [ network . HostAddress ]: return [ network . NetworkInterface ( i ) for i in NetworkInterface . allInterfaces ()] @staticmethod def get_interface_from_name ( name : str ) -> NetworkInterface : interface = NetworkInterface . interfaceFromName ( name ) # if not interface: # return None return NetworkInterface ( interface )","title":"NetworkInterface"},{"location":"api/network.html#prettyqt.network.networkinterface.NetworkInterface.get_type","text":"Get the interface type. Returns: Type Description InterfaceTypeStr interface type Source code in prettyqt/network/networkinterface.py def get_type ( self ) -> InterfaceTypeStr : \"\"\"Get the interface type. Returns: interface type \"\"\" return INTERFACE_TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/network.html#prettyqt.network.networkproxy","text":"","title":"networkproxy"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy","text":"Source code in prettyqt/network/networkproxy.py class NetworkProxy ( QtNetwork . QNetworkProxy ): def get_capabilities ( self ) -> list [ CapabilityStr ]: return [ k for k , v in CAPABILITIES . items () if v & self . capabilities ()] def set_capabilities ( self , * capability : CapabilityStr ): for item in capability : if item not in CAPABILITIES : raise InvalidParamError ( item , CAPABILITIES ) flags = helpers . merge_flags ( capability , CAPABILITIES ) self . setCapabilities ( flags ) def get_header ( self , name : network . networkrequest . KnownHeaderStr ) -> str : if name not in network . networkrequest . KNOWN_HEADER : raise InvalidParamError ( name , network . networkrequest . KNOWN_HEADER ) return self . header ( network . networkrequest . KNOWN_HEADER [ name ]) def set_header ( self , name : network . networkrequest . KnownHeaderStr , value : str ): if name not in network . networkrequest . KNOWN_HEADER : raise InvalidParamError ( name , network . networkrequest . KNOWN_HEADER ) self . setHeader ( network . networkrequest . KNOWN_HEADER [ name ], value ) def get_headers ( self ) -> dict [ str , str ]: return { bytes ( h ) . decode (): bytes ( self . rawHeader ( h )) . decode () for h in self . rawHeaderList () } def set_headers ( self , headers : dict [ str , str ]): for k , v in headers . items (): self . setRawHeader ( QtCore . QByteArray ( k . encode ()), QtCore . QByteArray ( v . encode ()) ) def set_type ( self , typ : ProxyTypeStr ): \"\"\"Set proxy type. Args: typ: proxy type Raises: InvalidParamError: proxy type does not exist \"\"\" if typ not in PROXY_TYPES : raise InvalidParamError ( typ , PROXY_TYPES ) self . setType ( PROXY_TYPES [ typ ]) def get_type ( self ) -> ProxyTypeStr : \"\"\"Get the proxy type. Returns: type \"\"\" return PROXY_TYPES . inverse [ self . type ()]","title":"NetworkProxy"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.get_type","text":"Get the proxy type. Returns: Type Description ProxyTypeStr type Source code in prettyqt/network/networkproxy.py def get_type ( self ) -> ProxyTypeStr : \"\"\"Get the proxy type. Returns: type \"\"\" return PROXY_TYPES . inverse [ self . type ()]","title":"get_type()"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.set_type","text":"Set proxy type. Parameters: Name Type Description Default typ ProxyTypeStr proxy type required Exceptions: Type Description InvalidParamError proxy type does not exist Source code in prettyqt/network/networkproxy.py def set_type ( self , typ : ProxyTypeStr ): \"\"\"Set proxy type. Args: typ: proxy type Raises: InvalidParamError: proxy type does not exist \"\"\" if typ not in PROXY_TYPES : raise InvalidParamError ( typ , PROXY_TYPES ) self . setType ( PROXY_TYPES [ typ ])","title":"set_type()"},{"location":"api/network.html#prettyqt.network.networkrequest","text":"","title":"networkrequest"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest","text":"Source code in prettyqt/network/networkrequest.py class NetworkRequest ( QtNetwork . QNetworkRequest ): def __init__ ( self , obj : types . UrlType | QtNetwork . QNetworkRequest | None = None ): if isinstance ( obj , QtNetwork . QNetworkRequest ): super () . __init__ ( obj ) else : super () . __init__ () if obj is not None : self . set_url ( obj ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_url () } )\" def set_header ( self , name : KnownHeaderStr , value : str ): if name not in KNOWN_HEADER : raise InvalidParamError ( name , KNOWN_HEADER ) self . setHeader ( KNOWN_HEADER [ name ], value ) def get_header ( self , name : KnownHeaderStr ) -> str : if name not in KNOWN_HEADER : raise InvalidParamError ( name , KNOWN_HEADER ) return self . header ( KNOWN_HEADER [ name ]) def set_headers ( self , headers : dict [ str , str ]): for k , v in headers . items (): self . setRawHeader ( QtCore . QByteArray ( k . encode ()), QtCore . QByteArray ( v . encode ()) ) def get_headers ( self ) -> dict [ str , str ]: return { bytes ( h ) . decode (): bytes ( self . rawHeader ( h )) . decode () for h in self . rawHeaderList () } def set_url ( self , url : str | QtCore . QUrl ): url = core . Url ( url ) self . setUrl ( url ) def get_url ( self ) -> core . Url : return core . Url ( self . url ()) def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority. Args: priority: priority Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITY : raise InvalidParamError ( priority , PRIORITY ) self . setPriority ( PRIORITY [ priority ]) def get_priority ( self ) -> PriorityStr : \"\"\"Get the current priority. Returns: priority \"\"\" return PRIORITY . inverse [ self . priority ()]","title":"NetworkRequest"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.get_priority","text":"Get the current priority. Returns: Type Description PriorityStr priority Source code in prettyqt/network/networkrequest.py def get_priority ( self ) -> PriorityStr : \"\"\"Get the current priority. Returns: priority \"\"\" return PRIORITY . inverse [ self . priority ()]","title":"get_priority()"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.set_priority","text":"Set priority. Parameters: Name Type Description Default priority PriorityStr priority required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/network/networkrequest.py def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority. Args: priority: priority Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITY : raise InvalidParamError ( priority , PRIORITY ) self . setPriority ( PRIORITY [ priority ])","title":"set_priority()"},{"location":"api/network.html#prettyqt.network.tcpserver","text":"","title":"tcpserver"},{"location":"api/network.html#prettyqt.network.tcpserver.TcpServer","text":"Source code in prettyqt/network/tcpserver.py class TcpServer ( QtNetwork . QTcpServer ): def listen ( # type: ignore self , address : str | QtNetwork . QHostAddress , port : int = 0 ) -> bool : if isinstance ( address , str ): address = network . HostAddress ( address ) return super () . listen ( address , port ) def get_server_address ( self ) -> network . HostAddress : return network . HostAddress ( self . serverAddress ()) def get_proxy ( self ) -> network . NetworkProxy : return network . NetworkProxy ( self . proxy ()) def get_server_error ( self ) -> network . abstractsocket . SocketErrorStr : return network . abstractsocket . SOCKET_ERROR . inverse [ self . serverError ()]","title":"TcpServer"},{"location":"api/network.html#prettyqt.network.tcpserver.TcpServer.listen","text":"listen(self, address: Union[PySide6.QtNetwork.QHostAddress, PySide6.QtNetwork.QHostAddress.SpecialAddress] = Instance(QHostAddress.Any), port: int = 0) -> bool Source code in prettyqt/network/tcpserver.py def listen ( # type: ignore self , address : str | QtNetwork . QHostAddress , port : int = 0 ) -> bool : if isinstance ( address , str ): address = network . HostAddress ( address ) return super () . listen ( address , port )","title":"listen()"},{"location":"api/objbrowser.html","text":"objbrowser module Objbrowser package. attribute_model Module that defines AttributeModel. safe_data_fn ( obj_fn : Callable , log_exceptions : bool = False ) -> Callable Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function Source code in prettyqt/objbrowser/attribute_model.py def safe_data_fn ( obj_fn : Callable , log_exceptions : bool = False , ) -> Callable : \"\"\"Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function \"\"\" def data_fn ( tree_item : treeitem . TreeItem ) -> str : \"\"\"Call the obj_fn(tree_item.obj). Returns empty string in case of an error \"\"\" try : return str ( obj_fn ( tree_item . obj )) except Exception as ex : if log_exceptions : logger . exception ( ex ) return \"\" return data_fn objectbrowser Object browser GUI in Qt. ObjectBrowser ( MainWindow ) Source code in prettyqt/objbrowser/objectbrowser.py class ObjectBrowser ( widgets . MainWindow ): \"\"\"Object browser main application window.\"\"\" _app = None # Reference to the global application. _browsers : list [ ObjectBrowser | None ] = [] # Keep lists of browser windows. def __init__ ( self , obj , name : str = \"\" ): super () . __init__ () self . set_title ( \"Object browser\" ) self . _instance_nr = self . _add_instance () self . set_icon ( \"mdi.language-python\" ) self . _attr_cols = DEFAULT_ATTR_COLS self . _attr_details = DEFAULT_ATTR_DETAILS logger . debug ( \"Reading model settings for window: %d \" , self . _instance_nr ) with core . Settings ( settings_id = self . _settings_group_name ( \"model\" )) as settings : self . _auto_refresh = settings . get ( \"auto_refresh\" , False ) self . _refresh_rate = settings . get ( \"refresh_rate\" , 2 ) show_callable_attrs = settings . get ( \"show_callable_attrs\" , True ) show_special_attrs = settings . get ( \"show_special_attrs\" , True ) self . _tree_model = objectbrowsertreemodel . ObjectBrowserTreeModel ( obj , name , attr_cols = self . _attr_cols ) self . _proxy_tree_model = objectbrowsertreemodel . ObjectBrowserTreeProxyModel ( show_callable_attrs = show_callable_attrs , show_special_attrs = show_special_attrs , ) self . _proxy_tree_model . setSourceModel ( self . _tree_model ) # self._proxy_tree_model.setSortRole(RegistryTableModel.SORT_ROLE) self . _proxy_tree_model . setDynamicSortFilter ( True ) # self._proxy_tree_model.setSortCaseSensitivity(Qt.CaseInsensitive) # Views self . _setup_actions () self . central_splitter = widgets . Splitter ( parent = self , orientation = constants . VERTICAL ) self . setCentralWidget ( self . central_splitter ) # Tree widget self . obj_tree = widgets . TreeView () self . obj_tree . setRootIsDecorated ( True ) self . obj_tree . setAlternatingRowColors ( True ) self . obj_tree . set_model ( self . _proxy_tree_model ) self . obj_tree . set_selection_behaviour ( \"rows\" ) self . obj_tree . setUniformRowHeights ( True ) self . obj_tree . setAnimated ( True ) # Stretch last column? # It doesn't play nice when columns are hidden and then shown again. self . obj_tree . h_header . set_id ( \"table_header\" ) self . obj_tree . h_header . setSectionsMovable ( True ) self . obj_tree . h_header . setStretchLastSection ( False ) self . central_splitter . addWidget ( self . obj_tree ) # Bottom pane bottom_pane_widget = widgets . Widget () bottom_pane_widget . set_layout ( \"horizontal\" , spacing = 0 , margin = 5 ) self . central_splitter . addWidget ( bottom_pane_widget ) group_box = widgets . GroupBox ( \"Details\" ) bottom_pane_widget . box . addWidget ( group_box ) group_box . set_layout ( \"horizontal\" , margin = 2 ) # Radio buttons radio_widget = widgets . Widget () radio_widget . set_layout ( \"vertical\" , margin = 0 ) self . button_group = widgets . ButtonGroup ( self ) for button_id , attr_detail in enumerate ( self . _attr_details ): radio_button = widgets . RadioButton ( attr_detail . name ) radio_widget . box . addWidget ( radio_button ) self . button_group . addButton ( radio_button , button_id ) self . button_group . buttonClicked . connect ( self . _change_details_field ) self . button_group . button ( 0 ) . setChecked ( True ) radio_widget . box . addStretch ( 1 ) group_box . box . addWidget ( radio_widget ) # Editor widget font = gui . Font ( \"Courier\" ) font . setFixedPitch ( True ) # font.setPointSize(14) self . editor = widgets . PlainTextEdit () self . editor . setReadOnly ( True ) self . editor . setFont ( font ) group_box . box . addWidget ( self . editor ) # Splitter parameters self . central_splitter . setCollapsible ( 0 , False ) self . central_splitter . setCollapsible ( 1 , True ) self . central_splitter . setSizes ([ 400 , 200 ]) self . central_splitter . setStretchFactor ( 0 , 10 ) self . central_splitter . setStretchFactor ( 1 , 0 ) selection_model = self . obj_tree . selectionModel () selection_model . currentChanged . connect ( self . _update_details ) menubar = self . menuBar () file_menu = menubar . add_menu ( \"&File\" ) close_action = widgets . Action ( text = \"C&lose\" , callback = self . close , shortcut = \"Ctrl+W\" ) file_menu . addAction ( close_action ) exit_action = widgets . Action ( text = \"E&xit\" , callback = lambda : widgets . app () . closeAllWindows (), shortcut = \"Ctrl+Q\" , ) file_menu . addAction ( exit_action ) view_menu = menubar . add_menu ( \"&View\" ) refresh_action = widgets . Action ( text = \"&Refresh\" , callback = self . _tree_model . refresh_tree , shortcut = \"Ctrl+R\" , ) view_menu . addAction ( refresh_action ) view_menu . addAction ( self . toggle_auto_refresh_action ) view_menu . addSeparator () self . show_cols_submenu = widgets . Menu ( \"Table columns\" ) view_menu . add_menu ( self . show_cols_submenu ) actions = self . obj_tree . h_header . get_header_actions () self . show_cols_submenu . add_actions ( actions ) view_menu . addSeparator () view_menu . addAction ( self . toggle_callable_action ) view_menu . addAction ( self . toggle_special_attribute_action ) assert self . _refresh_rate > 0 self . _refresh_timer = core . Timer ( self ) self . _refresh_timer . setInterval ( self . _refresh_rate * 1000 ) self . _refresh_timer . timeout . connect ( self . _tree_model . refresh_tree ) # Update views with model self . toggle_special_attribute_action . setChecked ( show_special_attrs ) self . toggle_callable_action . setChecked ( show_callable_attrs ) self . toggle_auto_refresh_action . setChecked ( self . _auto_refresh ) # Select first row so that a hidden root node will not be selected. first_row_index = self . _proxy_tree_model . first_item_index () self . obj_tree . setCurrentIndex ( first_row_index ) if self . _tree_model . inspected_node_is_visible : self . obj_tree . expand ( first_row_index ) def _add_instance ( self ) -> int : \"\"\"Adds the browser window to the list of browser references. If a None is present in the list it is inserted at that position, otherwise it is appended to the list. The index number is returned. This mechanism is used so that repeatedly creating and closing windows does not increase the instance number, which is used in writing the persistent settings. \"\"\" try : idx = self . _browsers . index ( None ) except ValueError : self . _browsers . append ( self ) idx = len ( self . _browsers ) - 1 else : self . _browsers [ idx ] = self return idx def _setup_actions ( self ): \"\"\"Create the main window actions.\"\"\" # Show/hide callable objects self . toggle_callable_action = widgets . Action ( text = \"Show callable attributes\" , parent = self , checkable = True , shortcut = gui . KeySequence ( \"Alt+C\" ), statustip = \"Shows/hides callable attributes (functions, methods, etc.)\" , ) self . toggle_callable_action . toggled . connect ( self . _proxy_tree_model . set_show_callables ) # Show/hide special attributes self . toggle_special_attribute_action = widgets . Action ( text = \"Show __special__ attributes\" , parent = self , checkable = True , shortcut = gui . KeySequence ( \"Alt+S\" ), statustip = \"Shows or hides __special__ attributes\" , ) self . toggle_special_attribute_action . toggled . connect ( self . _proxy_tree_model . set_show_special_attrs ) # Toggle auto-refresh on/off self . toggle_auto_refresh_action = widgets . Action ( text = \"Auto-refresh\" , parent = self , checkable = True , statustip = f \"Auto refresh every { self . _refresh_rate } seconds\" , ) self . toggle_auto_refresh_action . toggled . connect ( self . toggle_auto_refresh ) # Add another refresh action with a different shortcut. An action must be added to # a visible widget for it to receive events. It is added to the main windows to # prevent it from being displayed again in the menu self . refresh_action_f5 = widgets . Action ( self , text = \"&Refresh2\" , shortcut = \"F5\" ) self . refresh_action_f5 . triggered . connect ( self . _tree_model . refresh_tree ) self . addAction ( self . refresh_action_f5 ) def _settings_group_name ( self , postfix : str ) -> str : \"\"\"Construct a group name for the persistent settings. Because the columns in the main table are extendible, we must store the settings in a different group if a different combination of columns is used. Therefore the settings group name contains a hash that is calculated from the used column names. Furthermore the window number is included in the settings group name. Finally a postfix string is appended. \"\"\" column_names = \",\" . join ([ col . name for col in self . _attr_cols ]) columns_hash = hashlib . md5 ( column_names . encode ( \"utf-8\" )) . hexdigest () return f \" { columns_hash } _win { self . _instance_nr } _ { postfix } \" def _write_model_settings ( self ): \"\"\"Write the model settings to the persistent store.\"\"\" logger . debug ( \"Writing model settings for window: %d \" , self . _instance_nr ) new = dict ( auto_refresh = self . _auto_refresh , refresh_rate = self . _refresh_rate , show_callable_attrs = self . _proxy_tree_model . get_show_callables (), show_special_attrs = self . _proxy_tree_model . get_show_special_attrs (), ) settings_id = self . _settings_group_name ( \"model\" ) logger . debug ( f \"New settings: { new } \" ) with core . Settings ( settings_id = settings_id ) as settings : settings . set_values ( new ) @core . Slot ( core . ModelIndex , core . ModelIndex ) def _update_details ( self , current_index : core . ModelIndex , _previous_index : core . ModelIndex ): \"\"\"Show the object details in the editor given an index.\"\"\" tree_item = self . _proxy_tree_model . tree_item ( current_index ) self . _update_details_for_item ( tree_item ) def _change_details_field ( self , _button_id = None ): \"\"\"Change the field that is displayed in the details pane.\"\"\" # logger.debug(\"_change_details_field: {}\".format(_button_id)) current_index = self . obj_tree . selectionModel () . currentIndex () tree_item = self . _proxy_tree_model . tree_item ( current_index ) self . _update_details_for_item ( tree_item ) def _update_details_for_item ( self , tree_item ): \"\"\"Show the object details in the editor given an tree_item.\"\"\" with self . editor . edit_stylesheet () as ss : ss . color . setValue ( \"black\" ) try : # obj = tree_item.obj button_id = self . button_group . checkedId () assert button_id >= 0 , \"No radio button selected. Please report this bug.\" attr_details = self . _attr_details [ button_id ] data = attr_details . get_label ( tree_item ) self . editor . set_text ( data ) self . editor . set_word_wrap_mode ( attr_details . line_wrap ) except Exception as ex : with self . editor . edit_stylesheet () as ss : ss . color . setValue ( \"red\" ) stack_trace = traceback . format_exc () self . editor . set_text ( f \" { ex } \\n\\n { stack_trace } \" ) self . editor . set_wrap_mode ( \"boundary_or_anywhere\" ) def toggle_auto_refresh ( self , checked ): \"\"\"Toggle auto-refresh on/off.\"\"\" if checked : logger . info ( \"Auto-refresh on. Rate %g seconds\" , self . _refresh_rate ) self . _refresh_timer . start () else : logger . info ( \"Auto-refresh off\" ) self . _refresh_timer . stop () self . _auto_refresh = checked def closeEvent ( self , event ): \"\"\"Called when the window is closed.\"\"\" logger . debug ( \"closeEvent\" ) self . _write_model_settings () self . _refresh_timer . stop () self . _refresh_timer . timeout . disconnect ( self . _tree_model . refresh_tree ) self . toggle_callable_action . toggled . disconnect ( self . _proxy_tree_model . set_show_callables ) self . toggle_special_attribute_action . toggled . disconnect ( self . _proxy_tree_model . set_show_special_attrs ) self . toggle_auto_refresh_action . toggled . disconnect ( self . toggle_auto_refresh ) self . refresh_action_f5 . triggered . disconnect ( self . _tree_model . refresh_tree ) self . button_group . buttonClicked . disconnect ( self . _change_details_field ) selection_model = self . obj_tree . selectionModel () selection_model . currentChanged . disconnect ( self . _update_details ) self . close () event . accept () \"\"\"Set the reference in the browser list to None.\"\"\" idx = self . _browsers . index ( self ) self . _browsers [ idx ] = None logger . debug ( \"Closed window %s \" , self . _instance_nr ) @classmethod def browse ( cls , * args , ** kwargs ): \"\"\"Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The *args and **kwargs will be passed to the ObjectBrowser constructor. \"\"\" cls . app = widgets . app () # keeping reference to prevent garbage collection. cls . app . setOrganizationName ( \"phil65\" ) cls . app . setApplicationName ( \"PrettyQt\" ) object_browser = cls ( * args , ** kwargs ) object_browser . show () object_browser . raise_ () return cls . app . main_loop () browse ( * args , ** kwargs ) classmethod Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The args and *kwargs will be passed to the ObjectBrowser constructor. Source code in prettyqt/objbrowser/objectbrowser.py @classmethod def browse ( cls , * args , ** kwargs ): \"\"\"Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The *args and **kwargs will be passed to the ObjectBrowser constructor. \"\"\" cls . app = widgets . app () # keeping reference to prevent garbage collection. cls . app . setOrganizationName ( \"phil65\" ) cls . app . setApplicationName ( \"PrettyQt\" ) object_browser = cls ( * args , ** kwargs ) object_browser . show () object_browser . raise_ () return cls . app . main_loop () closeEvent ( self , event ) Called when the window is closed. Source code in prettyqt/objbrowser/objectbrowser.py def closeEvent ( self , event ): \"\"\"Called when the window is closed.\"\"\" logger . debug ( \"closeEvent\" ) self . _write_model_settings () self . _refresh_timer . stop () self . _refresh_timer . timeout . disconnect ( self . _tree_model . refresh_tree ) self . toggle_callable_action . toggled . disconnect ( self . _proxy_tree_model . set_show_callables ) self . toggle_special_attribute_action . toggled . disconnect ( self . _proxy_tree_model . set_show_special_attrs ) self . toggle_auto_refresh_action . toggled . disconnect ( self . toggle_auto_refresh ) self . refresh_action_f5 . triggered . disconnect ( self . _tree_model . refresh_tree ) self . button_group . buttonClicked . disconnect ( self . _change_details_field ) selection_model = self . obj_tree . selectionModel () selection_model . currentChanged . disconnect ( self . _update_details ) self . close () event . accept () \"\"\"Set the reference in the browser list to None.\"\"\" idx = self . _browsers . index ( self ) self . _browsers [ idx ] = None logger . debug ( \"Closed window %s \" , self . _instance_nr ) toggle_auto_refresh ( self , checked ) Toggle auto-refresh on/off. Source code in prettyqt/objbrowser/objectbrowser.py def toggle_auto_refresh ( self , checked ): \"\"\"Toggle auto-refresh on/off.\"\"\" if checked : logger . info ( \"Auto-refresh on. Rate %g seconds\" , self . _refresh_rate ) self . _refresh_timer . start () else : logger . info ( \"Auto-refresh off\" ) self . _refresh_timer . stop () self . _auto_refresh = checked objectbrowsertreemodel Module that defines the TreeModel. Based on: PySide examples/itemviews/simpletreemodel See: https://github.com/PySide/Examples/blob/master/examples/itemviews/simpletreemodel /simpletreemodel.py ObjectBrowserTreeItem ( TreeItem ) Tree node class that can be used to build trees of objects. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py class ObjectBrowserTreeItem ( treeitem . TreeItem ): \"\"\"Tree node class that can be used to build trees of objects.\"\"\" def __init__ ( self , obj , name , obj_path , is_attribute , parent : ObjectBrowserTreeItem | None = None , ): super () . __init__ ( obj , parent = parent ) # self.parent_item = parent # self.obj = obj # self.child_items: List[ObjectBrowserTreeItem] = [] # self.has_children = True # self.children_fetched = False self . obj_name = str ( name ) self . obj_path = str ( obj_path ) self . is_attribute = is_attribute @property def is_special_attribute ( self ) -> bool : \"\"\"Return true if the item represents a dunder attribute.\"\"\" return ( self . is_attribute and self . obj_name . startswith ( \"__\" ) and self . obj_name . endswith ( \"__\" ) ) @property def is_callable_attribute ( self ) -> bool : \"\"\"Return true if the items is an attribute and it is callable.\"\"\" return self . is_attribute and callable ( self . obj ) is_callable_attribute : bool property readonly Return true if the items is an attribute and it is callable. is_special_attribute : bool property readonly Return true if the item represents a dunder attribute. ObjectBrowserTreeModel ( ColumnItemModel ) Source code in prettyqt/objbrowser/objectbrowsertreemodel.py class ObjectBrowserTreeModel ( custom_models . ColumnItemModel ): \"\"\"Model that provides an interface to an objectree that is build of tree items.\"\"\" def __init__ ( self , obj : Any , obj_name : str = \"\" , attr_cols : list [ custom_models . ColumnItem ] | None = None , parent : QtCore . QObject | None = None , ): \"\"\"Constructor. Args: obj (Any): Object to inspect obj_name (str, optional): Name of the object attr_cols (None, optional): List of Column items parent (None, optional): Description \"\"\" super () . __init__ ( attr_cols = attr_cols , parent = parent ) # The root_item is always invisible. If the obj_name is the empty string, the # inspectedItem will be the invisible root_item. If the obj_name is given, # an invisible root item will be added and the inspectedItem will be its # only child. In that case the inspected item will be visible. self . _inspected_node_is_visible = obj_name != \"\" if self . _inspected_node_is_visible : self . _root_item = ObjectBrowserTreeItem ( None , \"<invisible_root>\" , \"<invisible_root>\" , None ) self . _root_item . children_fetched = True self . inspected_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . _root_item . append_child ( self . inspected_item ) else : # The root itself will be invisible self . _root_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . inspected_item = self . _root_item # Fetch all items of the root so we can select the first row in the ctor. root_index = self . index ( 0 , 0 ) self . fetchMore ( root_index ) def flags ( self , index : core . ModelIndex ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE # type: ignore def index ( self , row : int , column : int , parent : core . ModelIndex | None = None ) -> core . ModelIndex : if parent is None : logger . debug ( \"parent is None\" ) parent = core . ModelIndex () parent_item = self . tree_item ( parent ) if not self . hasIndex ( row , column , parent ): logger . debug ( \"hasIndex is False: ( %s , %s ) %r \" , row , column , parent_item ) # logger.warn(\"Parent index model: {!r} != {!r}\".format(parent.model(), self)) return core . ModelIndex () child_item = parent_item . child ( row ) # logger.debug(\" {}\".format(child_item.obj_path)) if child_item : return self . createIndex ( row , column , child_item ) else : logger . warn ( \"no child_item\" ) return core . ModelIndex () def parent ( self , index : core . ModelIndex ) -> QtCore . QModelIndex : # type:ignore if not index . isValid (): return core . ModelIndex () child_item = index . internalPointer () parent_item = child_item . parent () # type: ignore if parent_item is None or parent_item == self . root_item : return core . ModelIndex () return self . createIndex ( parent_item . row (), 0 , parent_item ) def rowCount ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : # This is taken from the PyQt simpletreemodel example. return 0 else : return self . tree_item ( parent ) . child_count () def hasChildren ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : return self . tree_item ( parent ) . has_children def canFetchMore ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : result = not self . tree_item ( parent ) . children_fetched # logger.debug(\"canFetchMore: {} = {}\".format(parent, result)) return result def fetchMore ( self , parent : core . ModelIndex | None = None ): \"\"\"Fetches the children given the model index of a parent node. Adds the children to the parent. \"\"\" parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return parent_item = self . tree_item ( parent ) if parent_item . children_fetched : return tree_items = self . _fetch_object_children ( parent_item . obj , parent_item . obj_path ) with self . insert_rows ( 0 , len ( tree_items ) - 1 , parent ): for tree_item in tree_items : parent_item . append_child ( tree_item ) parent_item . children_fetched = True @property def inspected_node_is_visible ( self ): \"\"\"Return True if the inspected node is visible. In that case an invisible root node has been added. \"\"\" return self . _inspected_node_is_visible @property def root_item ( self ) -> ObjectBrowserTreeItem : \"\"\"The root ObjectBrowserTreeItem.\"\"\" return self . _root_item def root_index ( self ) -> core . ModelIndex : # TODO: needed? \"\"\"The index that returns the root element (same as an invalid index).\"\"\" return core . ModelIndex () def inspected_index ( self ) -> core . ModelIndex : \"\"\"The model index that point to the inspectedItem.\"\"\" if self . inspected_node_is_visible : return self . createIndex ( 0 , 0 , self . inspected_item ) else : return self . root_index () def tree_item ( self , index : core . ModelIndex ) -> ObjectBrowserTreeItem : if not index . isValid (): return self . root_item else : return index . internalPointer () # type: ignore def _fetch_object_children ( self , obj , obj_path ): # -> List[ObjectBrowserTreeItem]: \"\"\"Fetches the children of a Python object. Returns: list of ObjectBrowserTreeItems \"\"\" obj_children = [] path_strings = [] if isinstance ( obj , ( list , tuple , set , frozenset )): obj_children = [( str ( i ), j ) for i , j in sorted ( enumerate ( obj ))] path_strings = [ f \" { obj_path } [ { i [ 0 ] } ]\" if obj_path else i [ 0 ] for i in obj_children ] # elif isinstance(obj, (set, frozenset)): # obj_children = [(\"pop()\", elem) for elem in obj] # path_strings = [ # \"{0}.pop()\".format(obj_path) if obj_path else item[0] # for item in obj_children # ] elif hasattr ( obj , \"items\" ) and callable ( getattr ( obj , \"items\" )): # dicts etc. try : obj_children = list ( obj . items ()) except Exception as ex : # Can happen if the items method expects an argument, for instance the # types.DictType.items method expects a dictionary. logger . warn ( \"No items expanded. Objects items() call failed: %s \" , ex ) obj_children = [] # Sort keys, except when the object is an OrderedDict. if not isinstance ( obj , OrderedDict ): try : obj_children = sorted ( obj . items ()) except Exception as ex : logger . debug ( \"Unable to sort dictionary keys: %s \" , ex ) path_strings = [ f \" { obj_path } [ { item [ 0 ] !r} ]\" if obj_path else item [ 0 ] for item in obj_children ] is_attr_list = [ False ] * len ( obj_children ) # Object attributes for attr_name , attr_value in sorted ( inspect . getmembers ( obj )): obj_children . append (( attr_name , attr_value )) path_strings . append ( f \" { obj_path } . { attr_name } \" if obj_path else attr_name ) is_attr_list . append ( True ) tree_items = [] for item , path_str , is_attr in zip ( obj_children , path_strings , is_attr_list ): name , child_obj = item tree_items . append ( ObjectBrowserTreeItem ( child_obj , name , path_str , is_attr )) return tree_items def _aux_refresh_tree ( self , tree_index : core . ModelIndex ): \"\"\"Auxiliary function for refresh_tree that recursively refreshes the tree nodes. If the underlying Python object has been changed, we don't want to delete the old tree model and create a new one from scratch because this loses all information about which nodes are fetched and expanded. Instead the old tree model is updated. Using the difflib from the standard library it is determined for a parent node which child nodes should be added or removed. This is done based on the node names only, not on the node contents (the underlying Python objects). Testing the underlying nodes for equality is potentially slow. It is faster to let the refreshNode function emit the dataChanged signal for all cells. \"\"\" tree_item = self . tree_item ( tree_index ) logger . debug ( \"_aux_refresh_tree( %s ): %s%s \" , tree_index , tree_item . obj_path , \"*\" if tree_item . children_fetched else \"\" , ) if not tree_item . children_fetched : return None old_items = tree_item . child_items new_items = self . _fetch_object_children ( tree_item . obj , tree_item . obj_path ) old_item_names = [( item . obj_name , item . is_attribute ) for item in old_items ] new_item_names = [( item . obj_name , item . is_attribute ) for item in new_items ] seqMatcher = SequenceMatcher ( isjunk = None , a = old_item_names , b = new_item_names , autojunk = False ) opcodes = seqMatcher . get_opcodes () logger . debug ( \"(reversed) opcodes: %s \" , list ( reversed ( opcodes ))) for tag , i1 , i2 , j1 , j2 in reversed ( opcodes ): if 1 or tag != \"equal\" : logger . debug ( \" {:7s} , a[ {} : {} ] ( {} ), b[ {} : {} ] ( {} )\" . format ( tag , i1 , i2 , old_item_names [ i1 : i2 ], j1 , j2 , new_item_names [ j1 : j2 ] ) ) if tag == \"equal\" : # Only when node names are equal is _aux_refresh_tree called recursively. assert ( i2 - i1 == j2 - j1 ), f \"equal sanity check failed { i2 - i1 } != { j2 - j1 } \" for old_row , new_row in zip ( range ( i1 , i2 ), range ( j1 , j2 )): old_items [ old_row ] . obj = new_items [ new_row ] . obj child_index = self . index ( old_row , 0 , parent = tree_index ) self . _aux_refresh_tree ( child_index ) elif tag == \"replace\" : # Explicitly remove the old item and insert the new. The old item may have # child nodes which indices must be removed by Qt, otherwise it crashes. assert ( i2 - i1 == j2 - j1 ), f \"replace sanity check failed { i2 - i1 } != { j2 - j1 } \" first = i1 # row number of first that will be removed last = i1 + i2 - 1 # row number of last element after insertion with self . remove_rows ( first , last , tree_index ): del tree_item . child_items [ i1 : i2 ] first = i1 # row number of first element after insertion last = i1 + j2 - j1 - 1 # row number of last element after insertion with self . insert_rows ( first , last , tree_index ): tree_item . insert_children ( i1 , new_items [ j1 : j2 ]) elif tag == \"delete\" : assert j1 == j2 , f \"delete sanity check failed. { j1 } != { j2 } \" first = i1 # row number of first that will be removed last = i1 + i2 - 1 # row number of last element after insertion with self . remove_rows ( first , last , tree_index ): del tree_item . child_items [ i1 : i2 ] elif tag == \"insert\" : assert i1 == i2 , f \"insert sanity check failed. { i1 } != { i2 } \" first = i1 last = i1 + j2 - j1 - 1 with self . insert_rows ( first , last , tree_index ): tree_item . insert_children ( i1 , new_items [ j1 : j2 ]) else : raise ValueError ( f \"Invalid tag: { tag } \" ) def refresh_tree ( self ): \"\"\"Refreshes the tree model from the underlying root object.\"\"\" logger . info ( \"\" ) logger . info ( \"refresh_tree: %s \" , self . root_item ) root_item = self . tree_item ( self . root_index ()) logger . info ( \" root_item: %s (idx= %s )\" , root_item , self . root_index ()) inspected_item = self . tree_item ( self . inspected_index ()) logger . info ( \" inspected_item: %s (idx= %s )\" , inspected_item , self . inspected_index () ) assert ( root_item is inspected_item ) != self . inspected_node_is_visible , \"sanity check\" self . _aux_refresh_tree ( self . inspected_index ()) logger . debug ( \"After _aux_refresh_tree, root_obj: %s \" , helpers . cut_off_str ( self . root_item . obj , 80 ), ) self . root_item . pretty_print () # Emit the dataChanged signal for all cells. This is faster than checking which # nodes have changed, which may be slow for some underlying Python objects. bottom_row = self . rowCount () - 1 right_column = self . columnCount () - 1 top_left = self . index ( 0 , 0 ) bottom_right = self . index ( bottom_row , right_column ) logger . debug ( f \"bottom_right: ( { bottom_row } , { right_column } )\" ) self . dataChanged . emit ( top_left , bottom_right ) inspected_node_is_visible property readonly Return True if the inspected node is visible. In that case an invisible root node has been added. root_item : ObjectBrowserTreeItem property readonly The root ObjectBrowserTreeItem. __init__ ( self , obj : Any , obj_name : str = '' , attr_cols : list [ custom_models . ColumnItem ] | None = None , parent : QtCore . QObject | None = None ) special Constructor. Parameters: Name Type Description Default obj Any Object to inspect required obj_name str Name of the object '' attr_cols None List of Column items None parent None Description None Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , obj : Any , obj_name : str = \"\" , attr_cols : list [ custom_models . ColumnItem ] | None = None , parent : QtCore . QObject | None = None , ): \"\"\"Constructor. Args: obj (Any): Object to inspect obj_name (str, optional): Name of the object attr_cols (None, optional): List of Column items parent (None, optional): Description \"\"\" super () . __init__ ( attr_cols = attr_cols , parent = parent ) # The root_item is always invisible. If the obj_name is the empty string, the # inspectedItem will be the invisible root_item. If the obj_name is given, # an invisible root item will be added and the inspectedItem will be its # only child. In that case the inspected item will be visible. self . _inspected_node_is_visible = obj_name != \"\" if self . _inspected_node_is_visible : self . _root_item = ObjectBrowserTreeItem ( None , \"<invisible_root>\" , \"<invisible_root>\" , None ) self . _root_item . children_fetched = True self . inspected_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . _root_item . append_child ( self . inspected_item ) else : # The root itself will be invisible self . _root_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . inspected_item = self . _root_item # Fetch all items of the root so we can select the first row in the ctor. root_index = self . index ( 0 , 0 ) self . fetchMore ( root_index ) canFetchMore ( self , parent : core . ModelIndex | None = None ) canFetchMore(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def canFetchMore ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : result = not self . tree_item ( parent ) . children_fetched # logger.debug(\"canFetchMore: {} = {}\".format(parent, result)) return result fetchMore ( self , parent : core . ModelIndex | None = None ) Fetches the children given the model index of a parent node. Adds the children to the parent. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def fetchMore ( self , parent : core . ModelIndex | None = None ): \"\"\"Fetches the children given the model index of a parent node. Adds the children to the parent. \"\"\" parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return parent_item = self . tree_item ( parent ) if parent_item . children_fetched : return tree_items = self . _fetch_object_children ( parent_item . obj , parent_item . obj_path ) with self . insert_rows ( 0 , len ( tree_items ) - 1 , parent ): for tree_item in tree_items : parent_item . append_child ( tree_item ) parent_item . children_fetched = True flags ( self , index : core . ModelIndex ) flags(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.Qt.ItemFlag Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def flags ( self , index : core . ModelIndex ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE # type: ignore hasChildren ( self , parent : core . ModelIndex | None = None ) hasChildren(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def hasChildren ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : return self . tree_item ( parent ) . has_children index ( self , row : int , column : int , parent : core . ModelIndex | None = None ) -> core . ModelIndex index(self, row: int, column: int, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> PySide6.QtCore.QModelIndex Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def index ( self , row : int , column : int , parent : core . ModelIndex | None = None ) -> core . ModelIndex : if parent is None : logger . debug ( \"parent is None\" ) parent = core . ModelIndex () parent_item = self . tree_item ( parent ) if not self . hasIndex ( row , column , parent ): logger . debug ( \"hasIndex is False: ( %s , %s ) %r \" , row , column , parent_item ) # logger.warn(\"Parent index model: {!r} != {!r}\".format(parent.model(), self)) return core . ModelIndex () child_item = parent_item . child ( row ) # logger.debug(\" {}\".format(child_item.obj_path)) if child_item : return self . createIndex ( row , column , child_item ) else : logger . warn ( \"no child_item\" ) return core . ModelIndex () inspected_index ( self ) -> core . ModelIndex The model index that point to the inspectedItem. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def inspected_index ( self ) -> core . ModelIndex : \"\"\"The model index that point to the inspectedItem.\"\"\" if self . inspected_node_is_visible : return self . createIndex ( 0 , 0 , self . inspected_item ) else : return self . root_index () parent ( self , index : core . ModelIndex ) -> QtCore . QModelIndex parent(self) -> PySide6.QtCore.QObject parent(self, child: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.QModelIndex Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def parent ( self , index : core . ModelIndex ) -> QtCore . QModelIndex : # type:ignore if not index . isValid (): return core . ModelIndex () child_item = index . internalPointer () parent_item = child_item . parent () # type: ignore if parent_item is None or parent_item == self . root_item : return core . ModelIndex () return self . createIndex ( parent_item . row (), 0 , parent_item ) refresh_tree ( self ) Refreshes the tree model from the underlying root object. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def refresh_tree ( self ): \"\"\"Refreshes the tree model from the underlying root object.\"\"\" logger . info ( \"\" ) logger . info ( \"refresh_tree: %s \" , self . root_item ) root_item = self . tree_item ( self . root_index ()) logger . info ( \" root_item: %s (idx= %s )\" , root_item , self . root_index ()) inspected_item = self . tree_item ( self . inspected_index ()) logger . info ( \" inspected_item: %s (idx= %s )\" , inspected_item , self . inspected_index () ) assert ( root_item is inspected_item ) != self . inspected_node_is_visible , \"sanity check\" self . _aux_refresh_tree ( self . inspected_index ()) logger . debug ( \"After _aux_refresh_tree, root_obj: %s \" , helpers . cut_off_str ( self . root_item . obj , 80 ), ) self . root_item . pretty_print () # Emit the dataChanged signal for all cells. This is faster than checking which # nodes have changed, which may be slow for some underlying Python objects. bottom_row = self . rowCount () - 1 right_column = self . columnCount () - 1 top_left = self . index ( 0 , 0 ) bottom_right = self . index ( bottom_row , right_column ) logger . debug ( f \"bottom_right: ( { bottom_row } , { right_column } )\" ) self . dataChanged . emit ( top_left , bottom_right ) root_index ( self ) -> core . ModelIndex The index that returns the root element (same as an invalid index). Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def root_index ( self ) -> core . ModelIndex : # TODO: needed? \"\"\"The index that returns the root element (same as an invalid index).\"\"\" return core . ModelIndex () rowCount ( self , parent : core . ModelIndex | None = None ) rowCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def rowCount ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : # This is taken from the PyQt simpletreemodel example. return 0 else : return self . tree_item ( parent ) . child_count () ObjectBrowserTreeProxyModel ( SortFilterProxyModel ) Source code in prettyqt/objbrowser/objectbrowsertreemodel.py class ObjectBrowserTreeProxyModel ( core . SortFilterProxyModel ): \"\"\"Proxy model that overrides the sorting and can filter out items.\"\"\" def __init__ ( self , show_callable_attrs : bool = True , show_special_attrs : bool = True , parent = None , ): \"\"\"Constructor. :param show_callable_attrs: if True the callables objects, i.e. objects (such as function) that a __call__ method, will be displayed (in brown). If False they are hidden. :param show_special_attrs: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget \"\"\" super () . __init__ ( parent ) self . _show_callables = show_callable_attrs self . _show_special_attrs = show_special_attrs def tree_item ( self , proxy_index : core . ModelIndex ) -> ObjectBrowserTreeItem : index = self . mapToSource ( proxy_index ) return self . sourceModel () . tree_item ( index ) def first_item_index ( self ) -> core . ModelIndex : \"\"\"Return the first child of the root item.\"\"\" # We cannot just call the same function of the source model because the first node # there may be hidden. source_root_index = self . sourceModel () . root_index () proxy_root_index = self . mapFromSource ( source_root_index ) first_item_index = self . index ( 0 , 0 , proxy_root_index ) return first_item_index def filterAcceptsRow ( self , source_row : int , source_parent_index : core . ModelIndex ): \"\"\"Return true if the item should be included in the model.\"\"\" parent_item = self . sourceModel () . tree_item ( source_parent_index ) tree_item = parent_item . child ( source_row ) accept = ( self . _show_special_attrs or not tree_item . is_special_attribute ) and ( self . _show_callables or not tree_item . is_callable_attribute ) # logger.debug(\"filterAcceptsRow = {}: {}\".format(accept, tree_item)) return accept def get_show_callables ( self ) -> bool : return self . _show_callables def set_show_callables ( self , show_callables : bool ): \"\"\"Show/hide show_callables which have a __call__ attribute.\"\"\" logger . debug ( \"set_show_callables: %s \" , show_callables ) self . _show_callables = show_callables self . invalidateFilter () def get_show_special_attrs ( self ) -> bool : return self . _show_special_attrs def set_show_special_attrs ( self , show_special_attrs : bool ): \"\"\"Show/hide special attributes which begin with an underscore.\"\"\" logger . debug ( \"set_show_special_attrs: %s \" , show_special_attrs ) self . _show_special_attrs = show_special_attrs self . invalidateFilter () __init__ ( self , show_callable_attrs : bool = True , show_special_attrs : bool = True , parent = None ) special Constructor. :param show_callable_attrs: if True the callables objects, i.e. objects (such as function) that a call method, will be displayed (in brown). If False they are hidden. :param show_special_attrs: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , show_callable_attrs : bool = True , show_special_attrs : bool = True , parent = None , ): \"\"\"Constructor. :param show_callable_attrs: if True the callables objects, i.e. objects (such as function) that a __call__ method, will be displayed (in brown). If False they are hidden. :param show_special_attrs: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget \"\"\" super () . __init__ ( parent ) self . _show_callables = show_callable_attrs self . _show_special_attrs = show_special_attrs filterAcceptsRow ( self , source_row : int , source_parent_index : core . ModelIndex ) Return true if the item should be included in the model. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def filterAcceptsRow ( self , source_row : int , source_parent_index : core . ModelIndex ): \"\"\"Return true if the item should be included in the model.\"\"\" parent_item = self . sourceModel () . tree_item ( source_parent_index ) tree_item = parent_item . child ( source_row ) accept = ( self . _show_special_attrs or not tree_item . is_special_attribute ) and ( self . _show_callables or not tree_item . is_callable_attribute ) # logger.debug(\"filterAcceptsRow = {}: {}\".format(accept, tree_item)) return accept first_item_index ( self ) -> core . ModelIndex Return the first child of the root item. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def first_item_index ( self ) -> core . ModelIndex : \"\"\"Return the first child of the root item.\"\"\" # We cannot just call the same function of the source model because the first node # there may be hidden. source_root_index = self . sourceModel () . root_index () proxy_root_index = self . mapFromSource ( source_root_index ) first_item_index = self . index ( 0 , 0 , proxy_root_index ) return first_item_index set_show_callables ( self , show_callables : bool ) Show/hide show_callables which have a call attribute. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_callables ( self , show_callables : bool ): \"\"\"Show/hide show_callables which have a __call__ attribute.\"\"\" logger . debug ( \"set_show_callables: %s \" , show_callables ) self . _show_callables = show_callables self . invalidateFilter () set_show_special_attrs ( self , show_special_attrs : bool ) Show/hide special attributes which begin with an underscore. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_special_attrs ( self , show_special_attrs : bool ): \"\"\"Show/hide special attributes which begin with an underscore.\"\"\" logger . debug ( \"set_show_special_attrs: %s \" , show_special_attrs ) self . _show_special_attrs = show_special_attrs self . invalidateFilter ()","title":"objbrowser"},{"location":"api/objbrowser.html#objbrowser-module","text":"Objbrowser package.","title":"objbrowser module"},{"location":"api/objbrowser.html#prettyqt.objbrowser.attribute_model","text":"Module that defines AttributeModel.","title":"attribute_model"},{"location":"api/objbrowser.html#prettyqt.objbrowser.attribute_model.safe_data_fn","text":"Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function Source code in prettyqt/objbrowser/attribute_model.py def safe_data_fn ( obj_fn : Callable , log_exceptions : bool = False , ) -> Callable : \"\"\"Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function \"\"\" def data_fn ( tree_item : treeitem . TreeItem ) -> str : \"\"\"Call the obj_fn(tree_item.obj). Returns empty string in case of an error \"\"\" try : return str ( obj_fn ( tree_item . obj )) except Exception as ex : if log_exceptions : logger . exception ( ex ) return \"\" return data_fn","title":"safe_data_fn()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser","text":"Object browser GUI in Qt.","title":"objectbrowser"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser","text":"Source code in prettyqt/objbrowser/objectbrowser.py class ObjectBrowser ( widgets . MainWindow ): \"\"\"Object browser main application window.\"\"\" _app = None # Reference to the global application. _browsers : list [ ObjectBrowser | None ] = [] # Keep lists of browser windows. def __init__ ( self , obj , name : str = \"\" ): super () . __init__ () self . set_title ( \"Object browser\" ) self . _instance_nr = self . _add_instance () self . set_icon ( \"mdi.language-python\" ) self . _attr_cols = DEFAULT_ATTR_COLS self . _attr_details = DEFAULT_ATTR_DETAILS logger . debug ( \"Reading model settings for window: %d \" , self . _instance_nr ) with core . Settings ( settings_id = self . _settings_group_name ( \"model\" )) as settings : self . _auto_refresh = settings . get ( \"auto_refresh\" , False ) self . _refresh_rate = settings . get ( \"refresh_rate\" , 2 ) show_callable_attrs = settings . get ( \"show_callable_attrs\" , True ) show_special_attrs = settings . get ( \"show_special_attrs\" , True ) self . _tree_model = objectbrowsertreemodel . ObjectBrowserTreeModel ( obj , name , attr_cols = self . _attr_cols ) self . _proxy_tree_model = objectbrowsertreemodel . ObjectBrowserTreeProxyModel ( show_callable_attrs = show_callable_attrs , show_special_attrs = show_special_attrs , ) self . _proxy_tree_model . setSourceModel ( self . _tree_model ) # self._proxy_tree_model.setSortRole(RegistryTableModel.SORT_ROLE) self . _proxy_tree_model . setDynamicSortFilter ( True ) # self._proxy_tree_model.setSortCaseSensitivity(Qt.CaseInsensitive) # Views self . _setup_actions () self . central_splitter = widgets . Splitter ( parent = self , orientation = constants . VERTICAL ) self . setCentralWidget ( self . central_splitter ) # Tree widget self . obj_tree = widgets . TreeView () self . obj_tree . setRootIsDecorated ( True ) self . obj_tree . setAlternatingRowColors ( True ) self . obj_tree . set_model ( self . _proxy_tree_model ) self . obj_tree . set_selection_behaviour ( \"rows\" ) self . obj_tree . setUniformRowHeights ( True ) self . obj_tree . setAnimated ( True ) # Stretch last column? # It doesn't play nice when columns are hidden and then shown again. self . obj_tree . h_header . set_id ( \"table_header\" ) self . obj_tree . h_header . setSectionsMovable ( True ) self . obj_tree . h_header . setStretchLastSection ( False ) self . central_splitter . addWidget ( self . obj_tree ) # Bottom pane bottom_pane_widget = widgets . Widget () bottom_pane_widget . set_layout ( \"horizontal\" , spacing = 0 , margin = 5 ) self . central_splitter . addWidget ( bottom_pane_widget ) group_box = widgets . GroupBox ( \"Details\" ) bottom_pane_widget . box . addWidget ( group_box ) group_box . set_layout ( \"horizontal\" , margin = 2 ) # Radio buttons radio_widget = widgets . Widget () radio_widget . set_layout ( \"vertical\" , margin = 0 ) self . button_group = widgets . ButtonGroup ( self ) for button_id , attr_detail in enumerate ( self . _attr_details ): radio_button = widgets . RadioButton ( attr_detail . name ) radio_widget . box . addWidget ( radio_button ) self . button_group . addButton ( radio_button , button_id ) self . button_group . buttonClicked . connect ( self . _change_details_field ) self . button_group . button ( 0 ) . setChecked ( True ) radio_widget . box . addStretch ( 1 ) group_box . box . addWidget ( radio_widget ) # Editor widget font = gui . Font ( \"Courier\" ) font . setFixedPitch ( True ) # font.setPointSize(14) self . editor = widgets . PlainTextEdit () self . editor . setReadOnly ( True ) self . editor . setFont ( font ) group_box . box . addWidget ( self . editor ) # Splitter parameters self . central_splitter . setCollapsible ( 0 , False ) self . central_splitter . setCollapsible ( 1 , True ) self . central_splitter . setSizes ([ 400 , 200 ]) self . central_splitter . setStretchFactor ( 0 , 10 ) self . central_splitter . setStretchFactor ( 1 , 0 ) selection_model = self . obj_tree . selectionModel () selection_model . currentChanged . connect ( self . _update_details ) menubar = self . menuBar () file_menu = menubar . add_menu ( \"&File\" ) close_action = widgets . Action ( text = \"C&lose\" , callback = self . close , shortcut = \"Ctrl+W\" ) file_menu . addAction ( close_action ) exit_action = widgets . Action ( text = \"E&xit\" , callback = lambda : widgets . app () . closeAllWindows (), shortcut = \"Ctrl+Q\" , ) file_menu . addAction ( exit_action ) view_menu = menubar . add_menu ( \"&View\" ) refresh_action = widgets . Action ( text = \"&Refresh\" , callback = self . _tree_model . refresh_tree , shortcut = \"Ctrl+R\" , ) view_menu . addAction ( refresh_action ) view_menu . addAction ( self . toggle_auto_refresh_action ) view_menu . addSeparator () self . show_cols_submenu = widgets . Menu ( \"Table columns\" ) view_menu . add_menu ( self . show_cols_submenu ) actions = self . obj_tree . h_header . get_header_actions () self . show_cols_submenu . add_actions ( actions ) view_menu . addSeparator () view_menu . addAction ( self . toggle_callable_action ) view_menu . addAction ( self . toggle_special_attribute_action ) assert self . _refresh_rate > 0 self . _refresh_timer = core . Timer ( self ) self . _refresh_timer . setInterval ( self . _refresh_rate * 1000 ) self . _refresh_timer . timeout . connect ( self . _tree_model . refresh_tree ) # Update views with model self . toggle_special_attribute_action . setChecked ( show_special_attrs ) self . toggle_callable_action . setChecked ( show_callable_attrs ) self . toggle_auto_refresh_action . setChecked ( self . _auto_refresh ) # Select first row so that a hidden root node will not be selected. first_row_index = self . _proxy_tree_model . first_item_index () self . obj_tree . setCurrentIndex ( first_row_index ) if self . _tree_model . inspected_node_is_visible : self . obj_tree . expand ( first_row_index ) def _add_instance ( self ) -> int : \"\"\"Adds the browser window to the list of browser references. If a None is present in the list it is inserted at that position, otherwise it is appended to the list. The index number is returned. This mechanism is used so that repeatedly creating and closing windows does not increase the instance number, which is used in writing the persistent settings. \"\"\" try : idx = self . _browsers . index ( None ) except ValueError : self . _browsers . append ( self ) idx = len ( self . _browsers ) - 1 else : self . _browsers [ idx ] = self return idx def _setup_actions ( self ): \"\"\"Create the main window actions.\"\"\" # Show/hide callable objects self . toggle_callable_action = widgets . Action ( text = \"Show callable attributes\" , parent = self , checkable = True , shortcut = gui . KeySequence ( \"Alt+C\" ), statustip = \"Shows/hides callable attributes (functions, methods, etc.)\" , ) self . toggle_callable_action . toggled . connect ( self . _proxy_tree_model . set_show_callables ) # Show/hide special attributes self . toggle_special_attribute_action = widgets . Action ( text = \"Show __special__ attributes\" , parent = self , checkable = True , shortcut = gui . KeySequence ( \"Alt+S\" ), statustip = \"Shows or hides __special__ attributes\" , ) self . toggle_special_attribute_action . toggled . connect ( self . _proxy_tree_model . set_show_special_attrs ) # Toggle auto-refresh on/off self . toggle_auto_refresh_action = widgets . Action ( text = \"Auto-refresh\" , parent = self , checkable = True , statustip = f \"Auto refresh every { self . _refresh_rate } seconds\" , ) self . toggle_auto_refresh_action . toggled . connect ( self . toggle_auto_refresh ) # Add another refresh action with a different shortcut. An action must be added to # a visible widget for it to receive events. It is added to the main windows to # prevent it from being displayed again in the menu self . refresh_action_f5 = widgets . Action ( self , text = \"&Refresh2\" , shortcut = \"F5\" ) self . refresh_action_f5 . triggered . connect ( self . _tree_model . refresh_tree ) self . addAction ( self . refresh_action_f5 ) def _settings_group_name ( self , postfix : str ) -> str : \"\"\"Construct a group name for the persistent settings. Because the columns in the main table are extendible, we must store the settings in a different group if a different combination of columns is used. Therefore the settings group name contains a hash that is calculated from the used column names. Furthermore the window number is included in the settings group name. Finally a postfix string is appended. \"\"\" column_names = \",\" . join ([ col . name for col in self . _attr_cols ]) columns_hash = hashlib . md5 ( column_names . encode ( \"utf-8\" )) . hexdigest () return f \" { columns_hash } _win { self . _instance_nr } _ { postfix } \" def _write_model_settings ( self ): \"\"\"Write the model settings to the persistent store.\"\"\" logger . debug ( \"Writing model settings for window: %d \" , self . _instance_nr ) new = dict ( auto_refresh = self . _auto_refresh , refresh_rate = self . _refresh_rate , show_callable_attrs = self . _proxy_tree_model . get_show_callables (), show_special_attrs = self . _proxy_tree_model . get_show_special_attrs (), ) settings_id = self . _settings_group_name ( \"model\" ) logger . debug ( f \"New settings: { new } \" ) with core . Settings ( settings_id = settings_id ) as settings : settings . set_values ( new ) @core . Slot ( core . ModelIndex , core . ModelIndex ) def _update_details ( self , current_index : core . ModelIndex , _previous_index : core . ModelIndex ): \"\"\"Show the object details in the editor given an index.\"\"\" tree_item = self . _proxy_tree_model . tree_item ( current_index ) self . _update_details_for_item ( tree_item ) def _change_details_field ( self , _button_id = None ): \"\"\"Change the field that is displayed in the details pane.\"\"\" # logger.debug(\"_change_details_field: {}\".format(_button_id)) current_index = self . obj_tree . selectionModel () . currentIndex () tree_item = self . _proxy_tree_model . tree_item ( current_index ) self . _update_details_for_item ( tree_item ) def _update_details_for_item ( self , tree_item ): \"\"\"Show the object details in the editor given an tree_item.\"\"\" with self . editor . edit_stylesheet () as ss : ss . color . setValue ( \"black\" ) try : # obj = tree_item.obj button_id = self . button_group . checkedId () assert button_id >= 0 , \"No radio button selected. Please report this bug.\" attr_details = self . _attr_details [ button_id ] data = attr_details . get_label ( tree_item ) self . editor . set_text ( data ) self . editor . set_word_wrap_mode ( attr_details . line_wrap ) except Exception as ex : with self . editor . edit_stylesheet () as ss : ss . color . setValue ( \"red\" ) stack_trace = traceback . format_exc () self . editor . set_text ( f \" { ex } \\n\\n { stack_trace } \" ) self . editor . set_wrap_mode ( \"boundary_or_anywhere\" ) def toggle_auto_refresh ( self , checked ): \"\"\"Toggle auto-refresh on/off.\"\"\" if checked : logger . info ( \"Auto-refresh on. Rate %g seconds\" , self . _refresh_rate ) self . _refresh_timer . start () else : logger . info ( \"Auto-refresh off\" ) self . _refresh_timer . stop () self . _auto_refresh = checked def closeEvent ( self , event ): \"\"\"Called when the window is closed.\"\"\" logger . debug ( \"closeEvent\" ) self . _write_model_settings () self . _refresh_timer . stop () self . _refresh_timer . timeout . disconnect ( self . _tree_model . refresh_tree ) self . toggle_callable_action . toggled . disconnect ( self . _proxy_tree_model . set_show_callables ) self . toggle_special_attribute_action . toggled . disconnect ( self . _proxy_tree_model . set_show_special_attrs ) self . toggle_auto_refresh_action . toggled . disconnect ( self . toggle_auto_refresh ) self . refresh_action_f5 . triggered . disconnect ( self . _tree_model . refresh_tree ) self . button_group . buttonClicked . disconnect ( self . _change_details_field ) selection_model = self . obj_tree . selectionModel () selection_model . currentChanged . disconnect ( self . _update_details ) self . close () event . accept () \"\"\"Set the reference in the browser list to None.\"\"\" idx = self . _browsers . index ( self ) self . _browsers [ idx ] = None logger . debug ( \"Closed window %s \" , self . _instance_nr ) @classmethod def browse ( cls , * args , ** kwargs ): \"\"\"Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The *args and **kwargs will be passed to the ObjectBrowser constructor. \"\"\" cls . app = widgets . app () # keeping reference to prevent garbage collection. cls . app . setOrganizationName ( \"phil65\" ) cls . app . setApplicationName ( \"PrettyQt\" ) object_browser = cls ( * args , ** kwargs ) object_browser . show () object_browser . raise_ () return cls . app . main_loop ()","title":"ObjectBrowser"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.browse","text":"Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The args and *kwargs will be passed to the ObjectBrowser constructor. Source code in prettyqt/objbrowser/objectbrowser.py @classmethod def browse ( cls , * args , ** kwargs ): \"\"\"Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The *args and **kwargs will be passed to the ObjectBrowser constructor. \"\"\" cls . app = widgets . app () # keeping reference to prevent garbage collection. cls . app . setOrganizationName ( \"phil65\" ) cls . app . setApplicationName ( \"PrettyQt\" ) object_browser = cls ( * args , ** kwargs ) object_browser . show () object_browser . raise_ () return cls . app . main_loop ()","title":"browse()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.closeEvent","text":"Called when the window is closed. Source code in prettyqt/objbrowser/objectbrowser.py def closeEvent ( self , event ): \"\"\"Called when the window is closed.\"\"\" logger . debug ( \"closeEvent\" ) self . _write_model_settings () self . _refresh_timer . stop () self . _refresh_timer . timeout . disconnect ( self . _tree_model . refresh_tree ) self . toggle_callable_action . toggled . disconnect ( self . _proxy_tree_model . set_show_callables ) self . toggle_special_attribute_action . toggled . disconnect ( self . _proxy_tree_model . set_show_special_attrs ) self . toggle_auto_refresh_action . toggled . disconnect ( self . toggle_auto_refresh ) self . refresh_action_f5 . triggered . disconnect ( self . _tree_model . refresh_tree ) self . button_group . buttonClicked . disconnect ( self . _change_details_field ) selection_model = self . obj_tree . selectionModel () selection_model . currentChanged . disconnect ( self . _update_details ) self . close () event . accept () \"\"\"Set the reference in the browser list to None.\"\"\" idx = self . _browsers . index ( self ) self . _browsers [ idx ] = None logger . debug ( \"Closed window %s \" , self . _instance_nr )","title":"closeEvent()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.toggle_auto_refresh","text":"Toggle auto-refresh on/off. Source code in prettyqt/objbrowser/objectbrowser.py def toggle_auto_refresh ( self , checked ): \"\"\"Toggle auto-refresh on/off.\"\"\" if checked : logger . info ( \"Auto-refresh on. Rate %g seconds\" , self . _refresh_rate ) self . _refresh_timer . start () else : logger . info ( \"Auto-refresh off\" ) self . _refresh_timer . stop () self . _auto_refresh = checked","title":"toggle_auto_refresh()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel","text":"Module that defines the TreeModel. Based on: PySide examples/itemviews/simpletreemodel See: https://github.com/PySide/Examples/blob/master/examples/itemviews/simpletreemodel /simpletreemodel.py","title":"objectbrowsertreemodel"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem","text":"Tree node class that can be used to build trees of objects. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py class ObjectBrowserTreeItem ( treeitem . TreeItem ): \"\"\"Tree node class that can be used to build trees of objects.\"\"\" def __init__ ( self , obj , name , obj_path , is_attribute , parent : ObjectBrowserTreeItem | None = None , ): super () . __init__ ( obj , parent = parent ) # self.parent_item = parent # self.obj = obj # self.child_items: List[ObjectBrowserTreeItem] = [] # self.has_children = True # self.children_fetched = False self . obj_name = str ( name ) self . obj_path = str ( obj_path ) self . is_attribute = is_attribute @property def is_special_attribute ( self ) -> bool : \"\"\"Return true if the item represents a dunder attribute.\"\"\" return ( self . is_attribute and self . obj_name . startswith ( \"__\" ) and self . obj_name . endswith ( \"__\" ) ) @property def is_callable_attribute ( self ) -> bool : \"\"\"Return true if the items is an attribute and it is callable.\"\"\" return self . is_attribute and callable ( self . obj )","title":"ObjectBrowserTreeItem"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem.is_callable_attribute","text":"Return true if the items is an attribute and it is callable.","title":"is_callable_attribute"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem.is_special_attribute","text":"Return true if the item represents a dunder attribute.","title":"is_special_attribute"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel","text":"Source code in prettyqt/objbrowser/objectbrowsertreemodel.py class ObjectBrowserTreeModel ( custom_models . ColumnItemModel ): \"\"\"Model that provides an interface to an objectree that is build of tree items.\"\"\" def __init__ ( self , obj : Any , obj_name : str = \"\" , attr_cols : list [ custom_models . ColumnItem ] | None = None , parent : QtCore . QObject | None = None , ): \"\"\"Constructor. Args: obj (Any): Object to inspect obj_name (str, optional): Name of the object attr_cols (None, optional): List of Column items parent (None, optional): Description \"\"\" super () . __init__ ( attr_cols = attr_cols , parent = parent ) # The root_item is always invisible. If the obj_name is the empty string, the # inspectedItem will be the invisible root_item. If the obj_name is given, # an invisible root item will be added and the inspectedItem will be its # only child. In that case the inspected item will be visible. self . _inspected_node_is_visible = obj_name != \"\" if self . _inspected_node_is_visible : self . _root_item = ObjectBrowserTreeItem ( None , \"<invisible_root>\" , \"<invisible_root>\" , None ) self . _root_item . children_fetched = True self . inspected_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . _root_item . append_child ( self . inspected_item ) else : # The root itself will be invisible self . _root_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . inspected_item = self . _root_item # Fetch all items of the root so we can select the first row in the ctor. root_index = self . index ( 0 , 0 ) self . fetchMore ( root_index ) def flags ( self , index : core . ModelIndex ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE # type: ignore def index ( self , row : int , column : int , parent : core . ModelIndex | None = None ) -> core . ModelIndex : if parent is None : logger . debug ( \"parent is None\" ) parent = core . ModelIndex () parent_item = self . tree_item ( parent ) if not self . hasIndex ( row , column , parent ): logger . debug ( \"hasIndex is False: ( %s , %s ) %r \" , row , column , parent_item ) # logger.warn(\"Parent index model: {!r} != {!r}\".format(parent.model(), self)) return core . ModelIndex () child_item = parent_item . child ( row ) # logger.debug(\" {}\".format(child_item.obj_path)) if child_item : return self . createIndex ( row , column , child_item ) else : logger . warn ( \"no child_item\" ) return core . ModelIndex () def parent ( self , index : core . ModelIndex ) -> QtCore . QModelIndex : # type:ignore if not index . isValid (): return core . ModelIndex () child_item = index . internalPointer () parent_item = child_item . parent () # type: ignore if parent_item is None or parent_item == self . root_item : return core . ModelIndex () return self . createIndex ( parent_item . row (), 0 , parent_item ) def rowCount ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : # This is taken from the PyQt simpletreemodel example. return 0 else : return self . tree_item ( parent ) . child_count () def hasChildren ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : return self . tree_item ( parent ) . has_children def canFetchMore ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : result = not self . tree_item ( parent ) . children_fetched # logger.debug(\"canFetchMore: {} = {}\".format(parent, result)) return result def fetchMore ( self , parent : core . ModelIndex | None = None ): \"\"\"Fetches the children given the model index of a parent node. Adds the children to the parent. \"\"\" parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return parent_item = self . tree_item ( parent ) if parent_item . children_fetched : return tree_items = self . _fetch_object_children ( parent_item . obj , parent_item . obj_path ) with self . insert_rows ( 0 , len ( tree_items ) - 1 , parent ): for tree_item in tree_items : parent_item . append_child ( tree_item ) parent_item . children_fetched = True @property def inspected_node_is_visible ( self ): \"\"\"Return True if the inspected node is visible. In that case an invisible root node has been added. \"\"\" return self . _inspected_node_is_visible @property def root_item ( self ) -> ObjectBrowserTreeItem : \"\"\"The root ObjectBrowserTreeItem.\"\"\" return self . _root_item def root_index ( self ) -> core . ModelIndex : # TODO: needed? \"\"\"The index that returns the root element (same as an invalid index).\"\"\" return core . ModelIndex () def inspected_index ( self ) -> core . ModelIndex : \"\"\"The model index that point to the inspectedItem.\"\"\" if self . inspected_node_is_visible : return self . createIndex ( 0 , 0 , self . inspected_item ) else : return self . root_index () def tree_item ( self , index : core . ModelIndex ) -> ObjectBrowserTreeItem : if not index . isValid (): return self . root_item else : return index . internalPointer () # type: ignore def _fetch_object_children ( self , obj , obj_path ): # -> List[ObjectBrowserTreeItem]: \"\"\"Fetches the children of a Python object. Returns: list of ObjectBrowserTreeItems \"\"\" obj_children = [] path_strings = [] if isinstance ( obj , ( list , tuple , set , frozenset )): obj_children = [( str ( i ), j ) for i , j in sorted ( enumerate ( obj ))] path_strings = [ f \" { obj_path } [ { i [ 0 ] } ]\" if obj_path else i [ 0 ] for i in obj_children ] # elif isinstance(obj, (set, frozenset)): # obj_children = [(\"pop()\", elem) for elem in obj] # path_strings = [ # \"{0}.pop()\".format(obj_path) if obj_path else item[0] # for item in obj_children # ] elif hasattr ( obj , \"items\" ) and callable ( getattr ( obj , \"items\" )): # dicts etc. try : obj_children = list ( obj . items ()) except Exception as ex : # Can happen if the items method expects an argument, for instance the # types.DictType.items method expects a dictionary. logger . warn ( \"No items expanded. Objects items() call failed: %s \" , ex ) obj_children = [] # Sort keys, except when the object is an OrderedDict. if not isinstance ( obj , OrderedDict ): try : obj_children = sorted ( obj . items ()) except Exception as ex : logger . debug ( \"Unable to sort dictionary keys: %s \" , ex ) path_strings = [ f \" { obj_path } [ { item [ 0 ] !r} ]\" if obj_path else item [ 0 ] for item in obj_children ] is_attr_list = [ False ] * len ( obj_children ) # Object attributes for attr_name , attr_value in sorted ( inspect . getmembers ( obj )): obj_children . append (( attr_name , attr_value )) path_strings . append ( f \" { obj_path } . { attr_name } \" if obj_path else attr_name ) is_attr_list . append ( True ) tree_items = [] for item , path_str , is_attr in zip ( obj_children , path_strings , is_attr_list ): name , child_obj = item tree_items . append ( ObjectBrowserTreeItem ( child_obj , name , path_str , is_attr )) return tree_items def _aux_refresh_tree ( self , tree_index : core . ModelIndex ): \"\"\"Auxiliary function for refresh_tree that recursively refreshes the tree nodes. If the underlying Python object has been changed, we don't want to delete the old tree model and create a new one from scratch because this loses all information about which nodes are fetched and expanded. Instead the old tree model is updated. Using the difflib from the standard library it is determined for a parent node which child nodes should be added or removed. This is done based on the node names only, not on the node contents (the underlying Python objects). Testing the underlying nodes for equality is potentially slow. It is faster to let the refreshNode function emit the dataChanged signal for all cells. \"\"\" tree_item = self . tree_item ( tree_index ) logger . debug ( \"_aux_refresh_tree( %s ): %s%s \" , tree_index , tree_item . obj_path , \"*\" if tree_item . children_fetched else \"\" , ) if not tree_item . children_fetched : return None old_items = tree_item . child_items new_items = self . _fetch_object_children ( tree_item . obj , tree_item . obj_path ) old_item_names = [( item . obj_name , item . is_attribute ) for item in old_items ] new_item_names = [( item . obj_name , item . is_attribute ) for item in new_items ] seqMatcher = SequenceMatcher ( isjunk = None , a = old_item_names , b = new_item_names , autojunk = False ) opcodes = seqMatcher . get_opcodes () logger . debug ( \"(reversed) opcodes: %s \" , list ( reversed ( opcodes ))) for tag , i1 , i2 , j1 , j2 in reversed ( opcodes ): if 1 or tag != \"equal\" : logger . debug ( \" {:7s} , a[ {} : {} ] ( {} ), b[ {} : {} ] ( {} )\" . format ( tag , i1 , i2 , old_item_names [ i1 : i2 ], j1 , j2 , new_item_names [ j1 : j2 ] ) ) if tag == \"equal\" : # Only when node names are equal is _aux_refresh_tree called recursively. assert ( i2 - i1 == j2 - j1 ), f \"equal sanity check failed { i2 - i1 } != { j2 - j1 } \" for old_row , new_row in zip ( range ( i1 , i2 ), range ( j1 , j2 )): old_items [ old_row ] . obj = new_items [ new_row ] . obj child_index = self . index ( old_row , 0 , parent = tree_index ) self . _aux_refresh_tree ( child_index ) elif tag == \"replace\" : # Explicitly remove the old item and insert the new. The old item may have # child nodes which indices must be removed by Qt, otherwise it crashes. assert ( i2 - i1 == j2 - j1 ), f \"replace sanity check failed { i2 - i1 } != { j2 - j1 } \" first = i1 # row number of first that will be removed last = i1 + i2 - 1 # row number of last element after insertion with self . remove_rows ( first , last , tree_index ): del tree_item . child_items [ i1 : i2 ] first = i1 # row number of first element after insertion last = i1 + j2 - j1 - 1 # row number of last element after insertion with self . insert_rows ( first , last , tree_index ): tree_item . insert_children ( i1 , new_items [ j1 : j2 ]) elif tag == \"delete\" : assert j1 == j2 , f \"delete sanity check failed. { j1 } != { j2 } \" first = i1 # row number of first that will be removed last = i1 + i2 - 1 # row number of last element after insertion with self . remove_rows ( first , last , tree_index ): del tree_item . child_items [ i1 : i2 ] elif tag == \"insert\" : assert i1 == i2 , f \"insert sanity check failed. { i1 } != { i2 } \" first = i1 last = i1 + j2 - j1 - 1 with self . insert_rows ( first , last , tree_index ): tree_item . insert_children ( i1 , new_items [ j1 : j2 ]) else : raise ValueError ( f \"Invalid tag: { tag } \" ) def refresh_tree ( self ): \"\"\"Refreshes the tree model from the underlying root object.\"\"\" logger . info ( \"\" ) logger . info ( \"refresh_tree: %s \" , self . root_item ) root_item = self . tree_item ( self . root_index ()) logger . info ( \" root_item: %s (idx= %s )\" , root_item , self . root_index ()) inspected_item = self . tree_item ( self . inspected_index ()) logger . info ( \" inspected_item: %s (idx= %s )\" , inspected_item , self . inspected_index () ) assert ( root_item is inspected_item ) != self . inspected_node_is_visible , \"sanity check\" self . _aux_refresh_tree ( self . inspected_index ()) logger . debug ( \"After _aux_refresh_tree, root_obj: %s \" , helpers . cut_off_str ( self . root_item . obj , 80 ), ) self . root_item . pretty_print () # Emit the dataChanged signal for all cells. This is faster than checking which # nodes have changed, which may be slow for some underlying Python objects. bottom_row = self . rowCount () - 1 right_column = self . columnCount () - 1 top_left = self . index ( 0 , 0 ) bottom_right = self . index ( bottom_row , right_column ) logger . debug ( f \"bottom_right: ( { bottom_row } , { right_column } )\" ) self . dataChanged . emit ( top_left , bottom_right )","title":"ObjectBrowserTreeModel"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.inspected_node_is_visible","text":"Return True if the inspected node is visible. In that case an invisible root node has been added.","title":"inspected_node_is_visible"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.root_item","text":"The root ObjectBrowserTreeItem.","title":"root_item"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.__init__","text":"Constructor. Parameters: Name Type Description Default obj Any Object to inspect required obj_name str Name of the object '' attr_cols None List of Column items None parent None Description None Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , obj : Any , obj_name : str = \"\" , attr_cols : list [ custom_models . ColumnItem ] | None = None , parent : QtCore . QObject | None = None , ): \"\"\"Constructor. Args: obj (Any): Object to inspect obj_name (str, optional): Name of the object attr_cols (None, optional): List of Column items parent (None, optional): Description \"\"\" super () . __init__ ( attr_cols = attr_cols , parent = parent ) # The root_item is always invisible. If the obj_name is the empty string, the # inspectedItem will be the invisible root_item. If the obj_name is given, # an invisible root item will be added and the inspectedItem will be its # only child. In that case the inspected item will be visible. self . _inspected_node_is_visible = obj_name != \"\" if self . _inspected_node_is_visible : self . _root_item = ObjectBrowserTreeItem ( None , \"<invisible_root>\" , \"<invisible_root>\" , None ) self . _root_item . children_fetched = True self . inspected_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . _root_item . append_child ( self . inspected_item ) else : # The root itself will be invisible self . _root_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . inspected_item = self . _root_item # Fetch all items of the root so we can select the first row in the ctor. root_index = self . index ( 0 , 0 ) self . fetchMore ( root_index )","title":"__init__()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.canFetchMore","text":"canFetchMore(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def canFetchMore ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : result = not self . tree_item ( parent ) . children_fetched # logger.debug(\"canFetchMore: {} = {}\".format(parent, result)) return result","title":"canFetchMore()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.fetchMore","text":"Fetches the children given the model index of a parent node. Adds the children to the parent. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def fetchMore ( self , parent : core . ModelIndex | None = None ): \"\"\"Fetches the children given the model index of a parent node. Adds the children to the parent. \"\"\" parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return parent_item = self . tree_item ( parent ) if parent_item . children_fetched : return tree_items = self . _fetch_object_children ( parent_item . obj , parent_item . obj_path ) with self . insert_rows ( 0 , len ( tree_items ) - 1 , parent ): for tree_item in tree_items : parent_item . append_child ( tree_item ) parent_item . children_fetched = True","title":"fetchMore()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.flags","text":"flags(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.Qt.ItemFlag Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def flags ( self , index : core . ModelIndex ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE # type: ignore","title":"flags()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.hasChildren","text":"hasChildren(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def hasChildren ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : return self . tree_item ( parent ) . has_children","title":"hasChildren()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.index","text":"index(self, row: int, column: int, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> PySide6.QtCore.QModelIndex Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def index ( self , row : int , column : int , parent : core . ModelIndex | None = None ) -> core . ModelIndex : if parent is None : logger . debug ( \"parent is None\" ) parent = core . ModelIndex () parent_item = self . tree_item ( parent ) if not self . hasIndex ( row , column , parent ): logger . debug ( \"hasIndex is False: ( %s , %s ) %r \" , row , column , parent_item ) # logger.warn(\"Parent index model: {!r} != {!r}\".format(parent.model(), self)) return core . ModelIndex () child_item = parent_item . child ( row ) # logger.debug(\" {}\".format(child_item.obj_path)) if child_item : return self . createIndex ( row , column , child_item ) else : logger . warn ( \"no child_item\" ) return core . ModelIndex ()","title":"index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.inspected_index","text":"The model index that point to the inspectedItem. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def inspected_index ( self ) -> core . ModelIndex : \"\"\"The model index that point to the inspectedItem.\"\"\" if self . inspected_node_is_visible : return self . createIndex ( 0 , 0 , self . inspected_item ) else : return self . root_index ()","title":"inspected_index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.parent","text":"parent(self) -> PySide6.QtCore.QObject parent(self, child: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -> PySide6.QtCore.QModelIndex Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def parent ( self , index : core . ModelIndex ) -> QtCore . QModelIndex : # type:ignore if not index . isValid (): return core . ModelIndex () child_item = index . internalPointer () parent_item = child_item . parent () # type: ignore if parent_item is None or parent_item == self . root_item : return core . ModelIndex () return self . createIndex ( parent_item . row (), 0 , parent_item )","title":"parent()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.refresh_tree","text":"Refreshes the tree model from the underlying root object. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def refresh_tree ( self ): \"\"\"Refreshes the tree model from the underlying root object.\"\"\" logger . info ( \"\" ) logger . info ( \"refresh_tree: %s \" , self . root_item ) root_item = self . tree_item ( self . root_index ()) logger . info ( \" root_item: %s (idx= %s )\" , root_item , self . root_index ()) inspected_item = self . tree_item ( self . inspected_index ()) logger . info ( \" inspected_item: %s (idx= %s )\" , inspected_item , self . inspected_index () ) assert ( root_item is inspected_item ) != self . inspected_node_is_visible , \"sanity check\" self . _aux_refresh_tree ( self . inspected_index ()) logger . debug ( \"After _aux_refresh_tree, root_obj: %s \" , helpers . cut_off_str ( self . root_item . obj , 80 ), ) self . root_item . pretty_print () # Emit the dataChanged signal for all cells. This is faster than checking which # nodes have changed, which may be slow for some underlying Python objects. bottom_row = self . rowCount () - 1 right_column = self . columnCount () - 1 top_left = self . index ( 0 , 0 ) bottom_right = self . index ( bottom_row , right_column ) logger . debug ( f \"bottom_right: ( { bottom_row } , { right_column } )\" ) self . dataChanged . emit ( top_left , bottom_right )","title":"refresh_tree()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.root_index","text":"The index that returns the root element (same as an invalid index). Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def root_index ( self ) -> core . ModelIndex : # TODO: needed? \"\"\"The index that returns the root element (same as an invalid index).\"\"\" return core . ModelIndex ()","title":"root_index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.rowCount","text":"rowCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -> int Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def rowCount ( self , parent : core . ModelIndex | None = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : # This is taken from the PyQt simpletreemodel example. return 0 else : return self . tree_item ( parent ) . child_count ()","title":"rowCount()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel","text":"Source code in prettyqt/objbrowser/objectbrowsertreemodel.py class ObjectBrowserTreeProxyModel ( core . SortFilterProxyModel ): \"\"\"Proxy model that overrides the sorting and can filter out items.\"\"\" def __init__ ( self , show_callable_attrs : bool = True , show_special_attrs : bool = True , parent = None , ): \"\"\"Constructor. :param show_callable_attrs: if True the callables objects, i.e. objects (such as function) that a __call__ method, will be displayed (in brown). If False they are hidden. :param show_special_attrs: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget \"\"\" super () . __init__ ( parent ) self . _show_callables = show_callable_attrs self . _show_special_attrs = show_special_attrs def tree_item ( self , proxy_index : core . ModelIndex ) -> ObjectBrowserTreeItem : index = self . mapToSource ( proxy_index ) return self . sourceModel () . tree_item ( index ) def first_item_index ( self ) -> core . ModelIndex : \"\"\"Return the first child of the root item.\"\"\" # We cannot just call the same function of the source model because the first node # there may be hidden. source_root_index = self . sourceModel () . root_index () proxy_root_index = self . mapFromSource ( source_root_index ) first_item_index = self . index ( 0 , 0 , proxy_root_index ) return first_item_index def filterAcceptsRow ( self , source_row : int , source_parent_index : core . ModelIndex ): \"\"\"Return true if the item should be included in the model.\"\"\" parent_item = self . sourceModel () . tree_item ( source_parent_index ) tree_item = parent_item . child ( source_row ) accept = ( self . _show_special_attrs or not tree_item . is_special_attribute ) and ( self . _show_callables or not tree_item . is_callable_attribute ) # logger.debug(\"filterAcceptsRow = {}: {}\".format(accept, tree_item)) return accept def get_show_callables ( self ) -> bool : return self . _show_callables def set_show_callables ( self , show_callables : bool ): \"\"\"Show/hide show_callables which have a __call__ attribute.\"\"\" logger . debug ( \"set_show_callables: %s \" , show_callables ) self . _show_callables = show_callables self . invalidateFilter () def get_show_special_attrs ( self ) -> bool : return self . _show_special_attrs def set_show_special_attrs ( self , show_special_attrs : bool ): \"\"\"Show/hide special attributes which begin with an underscore.\"\"\" logger . debug ( \"set_show_special_attrs: %s \" , show_special_attrs ) self . _show_special_attrs = show_special_attrs self . invalidateFilter ()","title":"ObjectBrowserTreeProxyModel"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.__init__","text":"Constructor. :param show_callable_attrs: if True the callables objects, i.e. objects (such as function) that a call method, will be displayed (in brown). If False they are hidden. :param show_special_attrs: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , show_callable_attrs : bool = True , show_special_attrs : bool = True , parent = None , ): \"\"\"Constructor. :param show_callable_attrs: if True the callables objects, i.e. objects (such as function) that a __call__ method, will be displayed (in brown). If False they are hidden. :param show_special_attrs: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget \"\"\" super () . __init__ ( parent ) self . _show_callables = show_callable_attrs self . _show_special_attrs = show_special_attrs","title":"__init__()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.filterAcceptsRow","text":"Return true if the item should be included in the model. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def filterAcceptsRow ( self , source_row : int , source_parent_index : core . ModelIndex ): \"\"\"Return true if the item should be included in the model.\"\"\" parent_item = self . sourceModel () . tree_item ( source_parent_index ) tree_item = parent_item . child ( source_row ) accept = ( self . _show_special_attrs or not tree_item . is_special_attribute ) and ( self . _show_callables or not tree_item . is_callable_attribute ) # logger.debug(\"filterAcceptsRow = {}: {}\".format(accept, tree_item)) return accept","title":"filterAcceptsRow()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.first_item_index","text":"Return the first child of the root item. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def first_item_index ( self ) -> core . ModelIndex : \"\"\"Return the first child of the root item.\"\"\" # We cannot just call the same function of the source model because the first node # there may be hidden. source_root_index = self . sourceModel () . root_index () proxy_root_index = self . mapFromSource ( source_root_index ) first_item_index = self . index ( 0 , 0 , proxy_root_index ) return first_item_index","title":"first_item_index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.set_show_callables","text":"Show/hide show_callables which have a call attribute. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_callables ( self , show_callables : bool ): \"\"\"Show/hide show_callables which have a __call__ attribute.\"\"\" logger . debug ( \"set_show_callables: %s \" , show_callables ) self . _show_callables = show_callables self . invalidateFilter ()","title":"set_show_callables()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.set_show_special_attrs","text":"Show/hide special attributes which begin with an underscore. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_special_attrs ( self , show_special_attrs : bool ): \"\"\"Show/hide special attributes which begin with an underscore.\"\"\" logger . debug ( \"set_show_special_attrs: %s \" , show_special_attrs ) self . _show_special_attrs = show_special_attrs self . invalidateFilter ()","title":"set_show_special_attrs()"},{"location":"api/positioning.html","text":"positioning module Positioning module. Contains QtPositioning-based classes geoareamonitorsource GeoAreaMonitorSource ( QGeoAreaMonitorSource ) Source code in prettyqt/positioning/geoareamonitorsource.py class GeoAreaMonitorSource ( QtPositioning . QGeoAreaMonitorSource ): def __str__ ( self ): return self . sourceName () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . name () !r} )\" def get_error ( self ) -> AreaMonitorFeatureStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()] get_error ( self ) -> AreaMonitorFeatureStr Return error type. Returns: Type Description AreaMonitorFeatureStr error type Source code in prettyqt/positioning/geoareamonitorsource.py def get_error ( self ) -> AreaMonitorFeatureStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()] geopositioninfosource GeoPositionInfoSource ( QGeoPositionInfoSource ) Source code in prettyqt/positioning/geopositioninfosource.py class GeoPositionInfoSource ( QtPositioning . QGeoPositionInfoSource ): def serialize_fields ( self ): return dict ( minimum_update_interval = self . minimumUpdateInterval (), source_name = self . sourceName (), update_interval = self . updateInterval (), ) def __str__ ( self ): return self . sourceName () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()] def set_preferred_positioning_methods ( self , * methods : PositioningMethodStr ): \"\"\"Set preferred positioning methods. Args: methods: positioning methods to use Raises: InvalidParamError: invalid positioning methods \"\"\" for item in methods : if item not in POSITIONING_METHODS : raise InvalidParamError ( item , POSITIONING_METHODS ) flags = helpers . merge_flags ( methods , POSITIONING_METHODS ) self . setPreferredPositioningMethods ( flags ) def get_preferred_positioning_methods ( self ) -> list [ PositioningMethodStr ]: \"\"\"Return list of preferred positioning methods. Returns: list of preferred positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . preferredPositioningMethods () ] def get_supported_positioning_methods ( self ) -> list [ PositioningMethodStr ]: \"\"\"Return list of supported positioning methods. Returns: list of supported positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . supportedPositioningMethods () ] get_error ( self ) -> ErrorStr Return error type. Returns: Type Description ErrorStr error type Source code in prettyqt/positioning/geopositioninfosource.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()] get_preferred_positioning_methods ( self ) -> list [ PositioningMethodStr ] Return list of preferred positioning methods. Returns: Type Description list[PositioningMethodStr] list of preferred positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_preferred_positioning_methods ( self ) -> list [ PositioningMethodStr ]: \"\"\"Return list of preferred positioning methods. Returns: list of preferred positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . preferredPositioningMethods () ] get_supported_positioning_methods ( self ) -> list [ PositioningMethodStr ] Return list of supported positioning methods. Returns: Type Description list[PositioningMethodStr] list of supported positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_supported_positioning_methods ( self ) -> list [ PositioningMethodStr ]: \"\"\"Return list of supported positioning methods. Returns: list of supported positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . supportedPositioningMethods () ] set_preferred_positioning_methods ( self , * methods : PositioningMethodStr ) Set preferred positioning methods. Parameters: Name Type Description Default methods PositioningMethodStr positioning methods to use () Exceptions: Type Description InvalidParamError invalid positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def set_preferred_positioning_methods ( self , * methods : PositioningMethodStr ): \"\"\"Set preferred positioning methods. Args: methods: positioning methods to use Raises: InvalidParamError: invalid positioning methods \"\"\" for item in methods : if item not in POSITIONING_METHODS : raise InvalidParamError ( item , POSITIONING_METHODS ) flags = helpers . merge_flags ( methods , POSITIONING_METHODS ) self . setPreferredPositioningMethods ( flags ) geosatelliteinfo GeoSatelliteInfo ( QGeoSatelliteInfo ) Source code in prettyqt/positioning/geosatelliteinfo.py class GeoSatelliteInfo ( QtPositioning . QGeoSatelliteInfo ): def __getitem__ ( self , index : AttributeStr ): return self . attribute ( ATTRIBUTE [ index ]) def __setitem__ ( self , index : AttributeStr , value : float ): self . setAttribute ( ATTRIBUTE [ index ], value ) def __delitem__ ( self , index : AttributeStr ): self . removeAttribute ( ATTRIBUTE [ index ]) def __contains__ ( self , value : AttributeStr ): return self . hasAttribute ( ATTRIBUTE [ value ]) def __int__ ( self ): return self . satelliteIdentifier () def set_satellite_system ( self , system : SatelliteSystemStr ): \"\"\"Set satellite system. Args: system: satellite system to use Raises: InvalidParamError: invalid system \"\"\" if system not in SATELLITE_SYSTEMS : raise InvalidParamError ( system , SATELLITE_SYSTEMS ) self . setSatelliteSystem ( SATELLITE_SYSTEMS [ system ]) def get_satellite_system ( self ) -> SatelliteSystemStr : \"\"\"Return satellite system. Returns: satellite system \"\"\" return SATELLITE_SYSTEMS . inverse [ self . satelliteSystem ()] get_satellite_system ( self ) -> SatelliteSystemStr Return satellite system. Returns: Type Description SatelliteSystemStr satellite system Source code in prettyqt/positioning/geosatelliteinfo.py def get_satellite_system ( self ) -> SatelliteSystemStr : \"\"\"Return satellite system. Returns: satellite system \"\"\" return SATELLITE_SYSTEMS . inverse [ self . satelliteSystem ()] set_satellite_system ( self , system : SatelliteSystemStr ) Set satellite system. Parameters: Name Type Description Default system SatelliteSystemStr satellite system to use required Exceptions: Type Description InvalidParamError invalid system Source code in prettyqt/positioning/geosatelliteinfo.py def set_satellite_system ( self , system : SatelliteSystemStr ): \"\"\"Set satellite system. Args: system: satellite system to use Raises: InvalidParamError: invalid system \"\"\" if system not in SATELLITE_SYSTEMS : raise InvalidParamError ( system , SATELLITE_SYSTEMS ) self . setSatelliteSystem ( SATELLITE_SYSTEMS [ system ]) geosatelliteinfosource GeoSatelliteInfoSource ( QGeoSatelliteInfoSource ) Source code in prettyqt/positioning/geosatelliteinfosource.py class GeoSatelliteInfoSource ( QtPositioning . QGeoSatelliteInfoSource ): def serialize_fields ( self ): return dict ( minimum_update_interval = self . minimumUpdateInterval (), update_interval = self . updateInterval (), ) def __str__ ( self ): return self . sourceName () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERROR . inverse [ self . error ()] get_error ( self ) -> ErrorStr Return error type. Returns: Type Description ErrorStr error type Source code in prettyqt/positioning/geosatelliteinfosource.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERROR . inverse [ self . error ()]","title":"positioning"},{"location":"api/positioning.html#positioning-module","text":"Positioning module. Contains QtPositioning-based classes","title":"positioning module"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource","text":"","title":"geoareamonitorsource"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource.GeoAreaMonitorSource","text":"Source code in prettyqt/positioning/geoareamonitorsource.py class GeoAreaMonitorSource ( QtPositioning . QGeoAreaMonitorSource ): def __str__ ( self ): return self . sourceName () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . name () !r} )\" def get_error ( self ) -> AreaMonitorFeatureStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()]","title":"GeoAreaMonitorSource"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource.GeoAreaMonitorSource.get_error","text":"Return error type. Returns: Type Description AreaMonitorFeatureStr error type Source code in prettyqt/positioning/geoareamonitorsource.py def get_error ( self ) -> AreaMonitorFeatureStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()]","title":"get_error()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource","text":"","title":"geopositioninfosource"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource","text":"Source code in prettyqt/positioning/geopositioninfosource.py class GeoPositionInfoSource ( QtPositioning . QGeoPositionInfoSource ): def serialize_fields ( self ): return dict ( minimum_update_interval = self . minimumUpdateInterval (), source_name = self . sourceName (), update_interval = self . updateInterval (), ) def __str__ ( self ): return self . sourceName () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()] def set_preferred_positioning_methods ( self , * methods : PositioningMethodStr ): \"\"\"Set preferred positioning methods. Args: methods: positioning methods to use Raises: InvalidParamError: invalid positioning methods \"\"\" for item in methods : if item not in POSITIONING_METHODS : raise InvalidParamError ( item , POSITIONING_METHODS ) flags = helpers . merge_flags ( methods , POSITIONING_METHODS ) self . setPreferredPositioningMethods ( flags ) def get_preferred_positioning_methods ( self ) -> list [ PositioningMethodStr ]: \"\"\"Return list of preferred positioning methods. Returns: list of preferred positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . preferredPositioningMethods () ] def get_supported_positioning_methods ( self ) -> list [ PositioningMethodStr ]: \"\"\"Return list of supported positioning methods. Returns: list of supported positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . supportedPositioningMethods () ]","title":"GeoPositionInfoSource"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.get_error","text":"Return error type. Returns: Type Description ErrorStr error type Source code in prettyqt/positioning/geopositioninfosource.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()]","title":"get_error()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.get_preferred_positioning_methods","text":"Return list of preferred positioning methods. Returns: Type Description list[PositioningMethodStr] list of preferred positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_preferred_positioning_methods ( self ) -> list [ PositioningMethodStr ]: \"\"\"Return list of preferred positioning methods. Returns: list of preferred positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . preferredPositioningMethods () ]","title":"get_preferred_positioning_methods()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.get_supported_positioning_methods","text":"Return list of supported positioning methods. Returns: Type Description list[PositioningMethodStr] list of supported positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_supported_positioning_methods ( self ) -> list [ PositioningMethodStr ]: \"\"\"Return list of supported positioning methods. Returns: list of supported positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . supportedPositioningMethods () ]","title":"get_supported_positioning_methods()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.set_preferred_positioning_methods","text":"Set preferred positioning methods. Parameters: Name Type Description Default methods PositioningMethodStr positioning methods to use () Exceptions: Type Description InvalidParamError invalid positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def set_preferred_positioning_methods ( self , * methods : PositioningMethodStr ): \"\"\"Set preferred positioning methods. Args: methods: positioning methods to use Raises: InvalidParamError: invalid positioning methods \"\"\" for item in methods : if item not in POSITIONING_METHODS : raise InvalidParamError ( item , POSITIONING_METHODS ) flags = helpers . merge_flags ( methods , POSITIONING_METHODS ) self . setPreferredPositioningMethods ( flags )","title":"set_preferred_positioning_methods()"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo","text":"","title":"geosatelliteinfo"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo","text":"Source code in prettyqt/positioning/geosatelliteinfo.py class GeoSatelliteInfo ( QtPositioning . QGeoSatelliteInfo ): def __getitem__ ( self , index : AttributeStr ): return self . attribute ( ATTRIBUTE [ index ]) def __setitem__ ( self , index : AttributeStr , value : float ): self . setAttribute ( ATTRIBUTE [ index ], value ) def __delitem__ ( self , index : AttributeStr ): self . removeAttribute ( ATTRIBUTE [ index ]) def __contains__ ( self , value : AttributeStr ): return self . hasAttribute ( ATTRIBUTE [ value ]) def __int__ ( self ): return self . satelliteIdentifier () def set_satellite_system ( self , system : SatelliteSystemStr ): \"\"\"Set satellite system. Args: system: satellite system to use Raises: InvalidParamError: invalid system \"\"\" if system not in SATELLITE_SYSTEMS : raise InvalidParamError ( system , SATELLITE_SYSTEMS ) self . setSatelliteSystem ( SATELLITE_SYSTEMS [ system ]) def get_satellite_system ( self ) -> SatelliteSystemStr : \"\"\"Return satellite system. Returns: satellite system \"\"\" return SATELLITE_SYSTEMS . inverse [ self . satelliteSystem ()]","title":"GeoSatelliteInfo"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.get_satellite_system","text":"Return satellite system. Returns: Type Description SatelliteSystemStr satellite system Source code in prettyqt/positioning/geosatelliteinfo.py def get_satellite_system ( self ) -> SatelliteSystemStr : \"\"\"Return satellite system. Returns: satellite system \"\"\" return SATELLITE_SYSTEMS . inverse [ self . satelliteSystem ()]","title":"get_satellite_system()"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.set_satellite_system","text":"Set satellite system. Parameters: Name Type Description Default system SatelliteSystemStr satellite system to use required Exceptions: Type Description InvalidParamError invalid system Source code in prettyqt/positioning/geosatelliteinfo.py def set_satellite_system ( self , system : SatelliteSystemStr ): \"\"\"Set satellite system. Args: system: satellite system to use Raises: InvalidParamError: invalid system \"\"\" if system not in SATELLITE_SYSTEMS : raise InvalidParamError ( system , SATELLITE_SYSTEMS ) self . setSatelliteSystem ( SATELLITE_SYSTEMS [ system ])","title":"set_satellite_system()"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource","text":"","title":"geosatelliteinfosource"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource.GeoSatelliteInfoSource","text":"Source code in prettyqt/positioning/geosatelliteinfosource.py class GeoSatelliteInfoSource ( QtPositioning . QGeoSatelliteInfoSource ): def serialize_fields ( self ): return dict ( minimum_update_interval = self . minimumUpdateInterval (), update_interval = self . updateInterval (), ) def __str__ ( self ): return self . sourceName () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERROR . inverse [ self . error ()]","title":"GeoSatelliteInfoSource"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource.GeoSatelliteInfoSource.get_error","text":"Return error type. Returns: Type Description ErrorStr error type Source code in prettyqt/positioning/geosatelliteinfosource.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/qml.html","text":"qml module Qml module. Contains QtQml-based classes jsvalue JSValue ( QJSValue ) Source code in prettyqt/qml/jsvalue.py class JSValue ( QtQml . QJSValue ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . toVariant () } )\" def __len__ ( self ): return self . property ( \"length\" ) . toVariant () def __getitem__ ( self , index : int | str ): return self . property ( index ) . toVariant () def __delitem__ ( self , index : str ): self . deleteProperty ( index ) def __setitem__ ( self , index : int | str , value ): self . setProperty ( index , value ) def __iter__ ( self ): iterator = qml . JSValueIterator ( self ) return iter ( list ( iterator )) def __contains__ ( self , index : str ): return self . hasProperty ( index ) def __call__ ( self , * args ) -> JSValue : result = self . call ( args ) return JSValue ( result ) def get_value ( self ): return self . toVariant () def get_error_type ( self ) -> str | None : error_type = self . errorType () return ERROR_TYPES . inverse . get ( error_type ) @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls () from_object ( obj , jsengine ) -> JSValue classmethod Convert any python object into a QJSValue (must happen in GUI thread). Source code in prettyqt/qml/jsvalue.py @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls () qmlengine QmlEngine ( QQmlEngine ) Source code in prettyqt/qml/qmlengine.py class QmlEngine ( QtQml . QQmlEngine ): def set_object_ownership ( self , obj : QtCore . QObject , mode : ObjectOwnershipStr ): \"\"\"Set the object ownership. Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIP : raise InvalidParamError ( mode , OBJECT_OWNERSHIP ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIP [ mode ]) def get_object_ownership ( self , obj : QtCore . QObject ) -> ObjectOwnershipStr : \"\"\"Return object ownership. Returns: object ownership \"\"\" return OBJECT_OWNERSHIP . inverse [ self . objectOwnership ( obj )] def add_import_path ( self , path : types . PathType ): self . addImportPath ( os . fspath ( path )) def add_plugin_path ( self , path : types . PathType ): self . addPluginPath ( os . fspath ( path )) def get_plugin_paths ( self ) -> list [ pathlib . Path ]: return [ pathlib . Path ( p ) for p in self . pluginPathList ()] def get_import_paths ( self ) -> list [ pathlib . Path ]: return [ pathlib . Path ( p ) for p in self . importPathList ()] def set_base_url ( self , url : str | QtCore . QUrl ): if isinstance ( url , str ): url = QtCore . QUrl ( url ) self . setBaseUrl ( url ) def get_base_url ( self ) -> core . Url : return core . Url ( self . baseUrl ()) def set_offline_storage_path ( self , path : types . PathType ): self . setOfflineStoragePath ( os . fspath ( path )) get_object_ownership ( self , obj : QtCore . QObject ) -> ObjectOwnershipStr Return object ownership. Returns: Type Description ObjectOwnershipStr object ownership Source code in prettyqt/qml/qmlengine.py def get_object_ownership ( self , obj : QtCore . QObject ) -> ObjectOwnershipStr : \"\"\"Return object ownership. Returns: object ownership \"\"\" return OBJECT_OWNERSHIP . inverse [ self . objectOwnership ( obj )] set_object_ownership ( self , obj : QtCore . QObject , mode : ObjectOwnershipStr ) Set the object ownership. Parameters: Name Type Description Default mode ObjectOwnershipStr object ownership to use required Exceptions: Type Description InvalidParamError invalid object ownership Source code in prettyqt/qml/qmlengine.py def set_object_ownership ( self , obj : QtCore . QObject , mode : ObjectOwnershipStr ): \"\"\"Set the object ownership. Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIP : raise InvalidParamError ( mode , OBJECT_OWNERSHIP ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIP [ mode ])","title":"qml"},{"location":"api/qml.html#qml-module","text":"Qml module. Contains QtQml-based classes","title":"qml module"},{"location":"api/qml.html#prettyqt.qml.jsvalue","text":"","title":"jsvalue"},{"location":"api/qml.html#prettyqt.qml.jsvalue.JSValue","text":"Source code in prettyqt/qml/jsvalue.py class JSValue ( QtQml . QJSValue ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . toVariant () } )\" def __len__ ( self ): return self . property ( \"length\" ) . toVariant () def __getitem__ ( self , index : int | str ): return self . property ( index ) . toVariant () def __delitem__ ( self , index : str ): self . deleteProperty ( index ) def __setitem__ ( self , index : int | str , value ): self . setProperty ( index , value ) def __iter__ ( self ): iterator = qml . JSValueIterator ( self ) return iter ( list ( iterator )) def __contains__ ( self , index : str ): return self . hasProperty ( index ) def __call__ ( self , * args ) -> JSValue : result = self . call ( args ) return JSValue ( result ) def get_value ( self ): return self . toVariant () def get_error_type ( self ) -> str | None : error_type = self . errorType () return ERROR_TYPES . inverse . get ( error_type ) @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls ()","title":"JSValue"},{"location":"api/qml.html#prettyqt.qml.jsvalue.JSValue.from_object","text":"Convert any python object into a QJSValue (must happen in GUI thread). Source code in prettyqt/qml/jsvalue.py @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls ()","title":"from_object()"},{"location":"api/qml.html#prettyqt.qml.qmlengine","text":"","title":"qmlengine"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngine","text":"Source code in prettyqt/qml/qmlengine.py class QmlEngine ( QtQml . QQmlEngine ): def set_object_ownership ( self , obj : QtCore . QObject , mode : ObjectOwnershipStr ): \"\"\"Set the object ownership. Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIP : raise InvalidParamError ( mode , OBJECT_OWNERSHIP ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIP [ mode ]) def get_object_ownership ( self , obj : QtCore . QObject ) -> ObjectOwnershipStr : \"\"\"Return object ownership. Returns: object ownership \"\"\" return OBJECT_OWNERSHIP . inverse [ self . objectOwnership ( obj )] def add_import_path ( self , path : types . PathType ): self . addImportPath ( os . fspath ( path )) def add_plugin_path ( self , path : types . PathType ): self . addPluginPath ( os . fspath ( path )) def get_plugin_paths ( self ) -> list [ pathlib . Path ]: return [ pathlib . Path ( p ) for p in self . pluginPathList ()] def get_import_paths ( self ) -> list [ pathlib . Path ]: return [ pathlib . Path ( p ) for p in self . importPathList ()] def set_base_url ( self , url : str | QtCore . QUrl ): if isinstance ( url , str ): url = QtCore . QUrl ( url ) self . setBaseUrl ( url ) def get_base_url ( self ) -> core . Url : return core . Url ( self . baseUrl ()) def set_offline_storage_path ( self , path : types . PathType ): self . setOfflineStoragePath ( os . fspath ( path ))","title":"QmlEngine"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngine.get_object_ownership","text":"Return object ownership. Returns: Type Description ObjectOwnershipStr object ownership Source code in prettyqt/qml/qmlengine.py def get_object_ownership ( self , obj : QtCore . QObject ) -> ObjectOwnershipStr : \"\"\"Return object ownership. Returns: object ownership \"\"\" return OBJECT_OWNERSHIP . inverse [ self . objectOwnership ( obj )]","title":"get_object_ownership()"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngine.set_object_ownership","text":"Set the object ownership. Parameters: Name Type Description Default mode ObjectOwnershipStr object ownership to use required Exceptions: Type Description InvalidParamError invalid object ownership Source code in prettyqt/qml/qmlengine.py def set_object_ownership ( self , obj : QtCore . QObject , mode : ObjectOwnershipStr ): \"\"\"Set the object ownership. Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIP : raise InvalidParamError ( mode , OBJECT_OWNERSHIP ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIP [ mode ])","title":"set_object_ownership()"},{"location":"api/qthelp.html","text":"qthelp module qthelp module. contains QtHelp-based classes","title":"qthelp"},{"location":"api/qthelp.html#qthelp-module","text":"qthelp module. contains QtHelp-based classes","title":"qthelp module"},{"location":"api/quick.html","text":"quick module quick module. contains QtQuick-based classes quickitem QuickItem ( QQuickItem ) Source code in prettyqt/quick/quickitem.py class QuickItem ( QtQuick . QQuickItem ): def get_children_rect ( self ) -> core . RectF : return core . RectF ( self . childrenRect ()) def get_cursor ( self ) -> gui . Cursor : return gui . Cursor ( self . cursor ()) def get_flags ( self ): pass def set_transform_origin ( self , origin : TransformOriginStr ): \"\"\"Set the origin point around which scale and rotation transform. The default is \"center\". Args: origin: transform origin to use Raises: InvalidParamError: transform origin does not exist \"\"\" if origin not in TRANSFORM_ORIGIN : raise InvalidParamError ( origin , TRANSFORM_ORIGIN ) self . setTransformOrigin ( TRANSFORM_ORIGIN [ origin ]) def get_transform_origin ( self ) -> TransformOriginStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: transform origin \"\"\" return TRANSFORM_ORIGIN . inverse [ self . transformOrigin ()] get_transform_origin ( self ) -> TransformOriginStr Return the render type of text-like elements in Qt Quick. Returns: Type Description TransformOriginStr transform origin Source code in prettyqt/quick/quickitem.py def get_transform_origin ( self ) -> TransformOriginStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: transform origin \"\"\" return TRANSFORM_ORIGIN . inverse [ self . transformOrigin ()] set_transform_origin ( self , origin : TransformOriginStr ) Set the origin point around which scale and rotation transform. The default is \"center\". Parameters: Name Type Description Default origin TransformOriginStr transform origin to use required Exceptions: Type Description InvalidParamError transform origin does not exist Source code in prettyqt/quick/quickitem.py def set_transform_origin ( self , origin : TransformOriginStr ): \"\"\"Set the origin point around which scale and rotation transform. The default is \"center\". Args: origin: transform origin to use Raises: InvalidParamError: transform origin does not exist \"\"\" if origin not in TRANSFORM_ORIGIN : raise InvalidParamError ( origin , TRANSFORM_ORIGIN ) self . setTransformOrigin ( TRANSFORM_ORIGIN [ origin ]) quickpainteditem QuickPaintedItem ( QQuickPaintedItem ) Source code in prettyqt/quick/quickpainteditem.py class QuickPaintedItem ( QtQuick . QQuickPaintedItem ): def get_fill_color ( self ) -> gui . Color : return gui . Color ( self . fillColor ()) def get_texture_size ( self ) -> core . Size : return core . Size ( self . textureSize ()) def set_render_target ( self , target : RenderTargetStr ): \"\"\"Set the render target. Args: target: render target to use Raises: InvalidParamError: render target does not exist \"\"\" if target not in RENDER_TARGET : raise InvalidParamError ( target , RENDER_TARGET ) self . setRenderTarget ( RENDER_TARGET [ target ]) def get_render_target ( self ) -> RenderTargetStr : \"\"\"Return the render target. Returns: render target \"\"\" return RENDER_TARGET . inverse [ self . renderTarget ()] get_render_target ( self ) -> RenderTargetStr Return the render target. Returns: Type Description RenderTargetStr render target Source code in prettyqt/quick/quickpainteditem.py def get_render_target ( self ) -> RenderTargetStr : \"\"\"Return the render target. Returns: render target \"\"\" return RENDER_TARGET . inverse [ self . renderTarget ()] set_render_target ( self , target : RenderTargetStr ) Set the render target. Parameters: Name Type Description Default target RenderTargetStr render target to use required Exceptions: Type Description InvalidParamError render target does not exist Source code in prettyqt/quick/quickpainteditem.py def set_render_target ( self , target : RenderTargetStr ): \"\"\"Set the render target. Args: target: render target to use Raises: InvalidParamError: render target does not exist \"\"\" if target not in RENDER_TARGET : raise InvalidParamError ( target , RENDER_TARGET ) self . setRenderTarget ( RENDER_TARGET [ target ]) quickwindow QuickWindow ( QQuickWindow ) Source code in prettyqt/quick/quickwindow.py class QuickWindow ( QtQuick . QQuickWindow ): def create_texture_from_image ( self , image : QtGui . QImage , ** kwargs ): flag = self . CreateTextureOption ( 0 ) for key , val in kwargs . items (): if val is True : v = CREATE_TEXTURE_OPTION [ key ] flag |= v return self . createTextureFromImage ( image , flag ) # type: ignore def grab_window ( self ) -> gui . Image : return gui . Image ( self . grabWindow ()) def get_color ( self ) -> gui . Color : return gui . Color ( self . color ()) @staticmethod def set_text_render_type ( typ : TextRenderTypeStr ): \"\"\"Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Args: typ: text render type to use Raises: InvalidParamError: text render type does not exist \"\"\" if typ not in TEXT_RENDER_TYPE : raise InvalidParamError ( typ , TEXT_RENDER_TYPE ) QuickWindow . setTextRenderType ( TEXT_RENDER_TYPE [ typ ]) @staticmethod def get_text_render_type () -> TextRenderTypeStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: text render type \"\"\" return TEXT_RENDER_TYPE . inverse [ QuickWindow . textRenderType ()] @contextlib . contextmanager def external_commands ( self ): self . beginExternalCommands () yield self self . endExternalCommands () def schedule_render_job ( self , job : QtCore . QRunnable , render_stage : RenderStageStr ): if render_stage not in RENDER_STAGE : raise InvalidParamError ( render_stage , RENDER_STAGE ) self . scheduleRenderJob ( job , RENDER_STAGE [ render_stage ]) get_text_render_type () -> TextRenderTypeStr staticmethod Return the render type of text-like elements in Qt Quick. Returns: Type Description TextRenderTypeStr text render type Source code in prettyqt/quick/quickwindow.py @staticmethod def get_text_render_type () -> TextRenderTypeStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: text render type \"\"\" return TEXT_RENDER_TYPE . inverse [ QuickWindow . textRenderType ()] set_text_render_type ( typ : TextRenderTypeStr ) staticmethod Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Parameters: Name Type Description Default typ TextRenderTypeStr text render type to use required Exceptions: Type Description InvalidParamError text render type does not exist Source code in prettyqt/quick/quickwindow.py @staticmethod def set_text_render_type ( typ : TextRenderTypeStr ): \"\"\"Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Args: typ: text render type to use Raises: InvalidParamError: text render type does not exist \"\"\" if typ not in TEXT_RENDER_TYPE : raise InvalidParamError ( typ , TEXT_RENDER_TYPE ) QuickWindow . setTextRenderType ( TEXT_RENDER_TYPE [ typ ])","title":"quick"},{"location":"api/quick.html#quick-module","text":"quick module. contains QtQuick-based classes","title":"quick module"},{"location":"api/quick.html#prettyqt.quick.quickitem","text":"","title":"quickitem"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItem","text":"Source code in prettyqt/quick/quickitem.py class QuickItem ( QtQuick . QQuickItem ): def get_children_rect ( self ) -> core . RectF : return core . RectF ( self . childrenRect ()) def get_cursor ( self ) -> gui . Cursor : return gui . Cursor ( self . cursor ()) def get_flags ( self ): pass def set_transform_origin ( self , origin : TransformOriginStr ): \"\"\"Set the origin point around which scale and rotation transform. The default is \"center\". Args: origin: transform origin to use Raises: InvalidParamError: transform origin does not exist \"\"\" if origin not in TRANSFORM_ORIGIN : raise InvalidParamError ( origin , TRANSFORM_ORIGIN ) self . setTransformOrigin ( TRANSFORM_ORIGIN [ origin ]) def get_transform_origin ( self ) -> TransformOriginStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: transform origin \"\"\" return TRANSFORM_ORIGIN . inverse [ self . transformOrigin ()]","title":"QuickItem"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItem.get_transform_origin","text":"Return the render type of text-like elements in Qt Quick. Returns: Type Description TransformOriginStr transform origin Source code in prettyqt/quick/quickitem.py def get_transform_origin ( self ) -> TransformOriginStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: transform origin \"\"\" return TRANSFORM_ORIGIN . inverse [ self . transformOrigin ()]","title":"get_transform_origin()"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItem.set_transform_origin","text":"Set the origin point around which scale and rotation transform. The default is \"center\". Parameters: Name Type Description Default origin TransformOriginStr transform origin to use required Exceptions: Type Description InvalidParamError transform origin does not exist Source code in prettyqt/quick/quickitem.py def set_transform_origin ( self , origin : TransformOriginStr ): \"\"\"Set the origin point around which scale and rotation transform. The default is \"center\". Args: origin: transform origin to use Raises: InvalidParamError: transform origin does not exist \"\"\" if origin not in TRANSFORM_ORIGIN : raise InvalidParamError ( origin , TRANSFORM_ORIGIN ) self . setTransformOrigin ( TRANSFORM_ORIGIN [ origin ])","title":"set_transform_origin()"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem","text":"","title":"quickpainteditem"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem","text":"Source code in prettyqt/quick/quickpainteditem.py class QuickPaintedItem ( QtQuick . QQuickPaintedItem ): def get_fill_color ( self ) -> gui . Color : return gui . Color ( self . fillColor ()) def get_texture_size ( self ) -> core . Size : return core . Size ( self . textureSize ()) def set_render_target ( self , target : RenderTargetStr ): \"\"\"Set the render target. Args: target: render target to use Raises: InvalidParamError: render target does not exist \"\"\" if target not in RENDER_TARGET : raise InvalidParamError ( target , RENDER_TARGET ) self . setRenderTarget ( RENDER_TARGET [ target ]) def get_render_target ( self ) -> RenderTargetStr : \"\"\"Return the render target. Returns: render target \"\"\" return RENDER_TARGET . inverse [ self . renderTarget ()]","title":"QuickPaintedItem"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.get_render_target","text":"Return the render target. Returns: Type Description RenderTargetStr render target Source code in prettyqt/quick/quickpainteditem.py def get_render_target ( self ) -> RenderTargetStr : \"\"\"Return the render target. Returns: render target \"\"\" return RENDER_TARGET . inverse [ self . renderTarget ()]","title":"get_render_target()"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.set_render_target","text":"Set the render target. Parameters: Name Type Description Default target RenderTargetStr render target to use required Exceptions: Type Description InvalidParamError render target does not exist Source code in prettyqt/quick/quickpainteditem.py def set_render_target ( self , target : RenderTargetStr ): \"\"\"Set the render target. Args: target: render target to use Raises: InvalidParamError: render target does not exist \"\"\" if target not in RENDER_TARGET : raise InvalidParamError ( target , RENDER_TARGET ) self . setRenderTarget ( RENDER_TARGET [ target ])","title":"set_render_target()"},{"location":"api/quick.html#prettyqt.quick.quickwindow","text":"","title":"quickwindow"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow","text":"Source code in prettyqt/quick/quickwindow.py class QuickWindow ( QtQuick . QQuickWindow ): def create_texture_from_image ( self , image : QtGui . QImage , ** kwargs ): flag = self . CreateTextureOption ( 0 ) for key , val in kwargs . items (): if val is True : v = CREATE_TEXTURE_OPTION [ key ] flag |= v return self . createTextureFromImage ( image , flag ) # type: ignore def grab_window ( self ) -> gui . Image : return gui . Image ( self . grabWindow ()) def get_color ( self ) -> gui . Color : return gui . Color ( self . color ()) @staticmethod def set_text_render_type ( typ : TextRenderTypeStr ): \"\"\"Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Args: typ: text render type to use Raises: InvalidParamError: text render type does not exist \"\"\" if typ not in TEXT_RENDER_TYPE : raise InvalidParamError ( typ , TEXT_RENDER_TYPE ) QuickWindow . setTextRenderType ( TEXT_RENDER_TYPE [ typ ]) @staticmethod def get_text_render_type () -> TextRenderTypeStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: text render type \"\"\" return TEXT_RENDER_TYPE . inverse [ QuickWindow . textRenderType ()] @contextlib . contextmanager def external_commands ( self ): self . beginExternalCommands () yield self self . endExternalCommands () def schedule_render_job ( self , job : QtCore . QRunnable , render_stage : RenderStageStr ): if render_stage not in RENDER_STAGE : raise InvalidParamError ( render_stage , RENDER_STAGE ) self . scheduleRenderJob ( job , RENDER_STAGE [ render_stage ])","title":"QuickWindow"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow.get_text_render_type","text":"Return the render type of text-like elements in Qt Quick. Returns: Type Description TextRenderTypeStr text render type Source code in prettyqt/quick/quickwindow.py @staticmethod def get_text_render_type () -> TextRenderTypeStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: text render type \"\"\" return TEXT_RENDER_TYPE . inverse [ QuickWindow . textRenderType ()]","title":"get_text_render_type()"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow.set_text_render_type","text":"Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Parameters: Name Type Description Default typ TextRenderTypeStr text render type to use required Exceptions: Type Description InvalidParamError text render type does not exist Source code in prettyqt/quick/quickwindow.py @staticmethod def set_text_render_type ( typ : TextRenderTypeStr ): \"\"\"Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Args: typ: text render type to use Raises: InvalidParamError: text render type does not exist \"\"\" if typ not in TEXT_RENDER_TYPE : raise InvalidParamError ( typ , TEXT_RENDER_TYPE ) QuickWindow . setTextRenderType ( TEXT_RENDER_TYPE [ typ ])","title":"set_text_render_type()"},{"location":"api/svg.html","text":"svg module svg module. contains QtSvg-based classes svgrenderer SvgRenderer ( QSvgRenderer ) Source code in prettyqt/svg/svgrenderer.py class SvgRenderer ( QtSvg . QSvgRenderer ): def load_file ( self , path : types . PathType ): result = self . load ( os . fspath ( path )) if not result : raise ValueError ( \"invalid path\" ) def set_aspect_ratio_mode ( self , mode : constants . AspectRatioModeStr ): \"\"\"Set the aspect ratio mode. Args: mode: aspect ratio mode Raises: InvalidParamError: aspect ratio mode does not exist \"\"\" if mode not in constants . ASPECT_RATIO_MODE : raise InvalidParamError ( mode , constants . ASPECT_RATIO_MODE ) self . setAspectRatioMode ( constants . ASPECT_RATIO_MODE [ mode ]) def get_aspect_ratio_mode ( self ) -> constants . AspectRatioModeStr : \"\"\"Return current aspect ratio mode. Returns: aspect ratio mode \"\"\" return constants . ASPECT_RATIO_MODE . inverse [ self . aspectRatioMode ()] get_aspect_ratio_mode ( self ) -> constants . AspectRatioModeStr Return current aspect ratio mode. Returns: Type Description constants.AspectRatioModeStr aspect ratio mode Source code in prettyqt/svg/svgrenderer.py def get_aspect_ratio_mode ( self ) -> constants . AspectRatioModeStr : \"\"\"Return current aspect ratio mode. Returns: aspect ratio mode \"\"\" return constants . ASPECT_RATIO_MODE . inverse [ self . aspectRatioMode ()] set_aspect_ratio_mode ( self , mode : constants . AspectRatioModeStr ) Set the aspect ratio mode. Parameters: Name Type Description Default mode constants.AspectRatioModeStr aspect ratio mode required Exceptions: Type Description InvalidParamError aspect ratio mode does not exist Source code in prettyqt/svg/svgrenderer.py def set_aspect_ratio_mode ( self , mode : constants . AspectRatioModeStr ): \"\"\"Set the aspect ratio mode. Args: mode: aspect ratio mode Raises: InvalidParamError: aspect ratio mode does not exist \"\"\" if mode not in constants . ASPECT_RATIO_MODE : raise InvalidParamError ( mode , constants . ASPECT_RATIO_MODE ) self . setAspectRatioMode ( constants . ASPECT_RATIO_MODE [ mode ])","title":"svg"},{"location":"api/svg.html#svg-module","text":"svg module. contains QtSvg-based classes","title":"svg module"},{"location":"api/svg.html#prettyqt.svg.svgrenderer","text":"","title":"svgrenderer"},{"location":"api/svg.html#prettyqt.svg.svgrenderer.SvgRenderer","text":"Source code in prettyqt/svg/svgrenderer.py class SvgRenderer ( QtSvg . QSvgRenderer ): def load_file ( self , path : types . PathType ): result = self . load ( os . fspath ( path )) if not result : raise ValueError ( \"invalid path\" ) def set_aspect_ratio_mode ( self , mode : constants . AspectRatioModeStr ): \"\"\"Set the aspect ratio mode. Args: mode: aspect ratio mode Raises: InvalidParamError: aspect ratio mode does not exist \"\"\" if mode not in constants . ASPECT_RATIO_MODE : raise InvalidParamError ( mode , constants . ASPECT_RATIO_MODE ) self . setAspectRatioMode ( constants . ASPECT_RATIO_MODE [ mode ]) def get_aspect_ratio_mode ( self ) -> constants . AspectRatioModeStr : \"\"\"Return current aspect ratio mode. Returns: aspect ratio mode \"\"\" return constants . ASPECT_RATIO_MODE . inverse [ self . aspectRatioMode ()]","title":"SvgRenderer"},{"location":"api/svg.html#prettyqt.svg.svgrenderer.SvgRenderer.get_aspect_ratio_mode","text":"Return current aspect ratio mode. Returns: Type Description constants.AspectRatioModeStr aspect ratio mode Source code in prettyqt/svg/svgrenderer.py def get_aspect_ratio_mode ( self ) -> constants . AspectRatioModeStr : \"\"\"Return current aspect ratio mode. Returns: aspect ratio mode \"\"\" return constants . ASPECT_RATIO_MODE . inverse [ self . aspectRatioMode ()]","title":"get_aspect_ratio_mode()"},{"location":"api/svg.html#prettyqt.svg.svgrenderer.SvgRenderer.set_aspect_ratio_mode","text":"Set the aspect ratio mode. Parameters: Name Type Description Default mode constants.AspectRatioModeStr aspect ratio mode required Exceptions: Type Description InvalidParamError aspect ratio mode does not exist Source code in prettyqt/svg/svgrenderer.py def set_aspect_ratio_mode ( self , mode : constants . AspectRatioModeStr ): \"\"\"Set the aspect ratio mode. Args: mode: aspect ratio mode Raises: InvalidParamError: aspect ratio mode does not exist \"\"\" if mode not in constants . ASPECT_RATIO_MODE : raise InvalidParamError ( mode , constants . ASPECT_RATIO_MODE ) self . setAspectRatioMode ( constants . ASPECT_RATIO_MODE [ mode ])","title":"set_aspect_ratio_mode()"},{"location":"api/syntaxhighlighters.html","text":"syntaxhighlighters module syntaxhighlighters module. contains some custom syntax highlighers highlightrule HighlightRule dataclass HighlightRule(regex: 'str | list[str]' = '', color: 'str' = 'black', italic: 'bool' = False, bold: 'bool' = False, minimal: 'bool' = False, font_size: 'float | None' = None, nth: 'int' = 0, fmt: 'gui.TextCharFormat' = TextCharFormat(2)) Source code in prettyqt/syntaxhighlighters/highlightrule.py @dataclass class HighlightRule : regex : str | list [ str ] = \"\" color : str = \"black\" italic : bool = False bold : bool = False minimal : bool = False font_size : float | None = None nth : int = 0 compiled = None fmt : gui . TextCharFormat = gui . TextCharFormat () def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format () @classmethod def get_format ( cls ) -> gui . TextCharFormat : fmt = gui . TextCharFormat () fmt . setFontItalic ( cls . italic ) fmt . set_foreground_color ( cls . color ) if cls . font_size : fmt . setFontPointSize ( cls . font_size ) if cls . bold : fmt . set_font_weight ( \"bold\" ) return fmt __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format () jsonhighlighter JsonHighlighter ( SyntaxHighlighter ) Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py class JsonHighlighter ( gui . SyntaxHighlighter ): def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT ) highlightBlock ( self , text : str ) Highlight a block of code using the rules outlined in the Constructor. Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT ) markdownhighlighter Syntax highlighter for Markdown markup language. MarkdownHighlighter ( SyntaxHighlighter ) Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py class MarkdownHighlighter ( gui . SyntaxHighlighter ): RULES = Rule . __subclasses__ () def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE ) def _match_multiline ( self , text : str , delimiter : core . RegularExpression , style : gui . TextCharFormat ): # If inside triple-single quotes, start at 0 if self . previousBlockState () == 1 : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : match = delimiter . match ( text ) if not match . hasMatch (): return start = match . capturedStart () add = match . capturedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter match = delimiter . match ( text , start + add ) end = match . capturedStart () # Ending delimiter on this line? if end >= add : length = end + match . capturedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( 1 ) length = len ( text ) self . setFormat ( start , length - start + add , style ) # Look for the next match start = delimiter . match ( text , start + length ) . capturedStart () highlightBlock ( self , text : str ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE ) pygmentshighlighter PygmentsHighlighter ( SyntaxHighlighter ) Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py class PygmentsHighlighter ( gui . SyntaxHighlighter ): \"\"\"Syntax highlighter that uses Pygments for parsing.\"\"\" # --------------------------------------------------------------------------- # \"QSyntaxHighlighter\" interface # --------------------------------------------------------------------------- def __init__ ( self , parent : QtGui . QTextDocument , lexer : str , style : str = \"default\" ): super () . __init__ ( parent ) self . _document = self . document () self . _formatter = HtmlFormatter ( nowrap = True ) self . set_style ( style ) if lexer == \"regex\" : self . _lexer = load_lexer_from_file ( str ( paths . RE_LEXER_PATH )) else : self . _lexer = get_lexer_by_name ( lexer ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } (lexer= { self . _lexer . aliases [ 0 ] !r} )\" def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack # --------------------------------------------------------------------------- # \"PygmentsHighlighter\" interface # --------------------------------------------------------------------------- def set_style ( self , style : None | str | Style ): if style is None : style = get_style_by_name ( \"default\" ) elif isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches () def set_style_sheet ( self , stylesheet : str ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches () # --------------------------------------------------------------------------- # Protected interface # --------------------------------------------------------------------------- def _clear_caches ( self ): \"\"\"Clear caches for brushes and formats.\"\"\" self . _get_brush . cache_clear () self . _get_format . cache_clear () @functools . cache def _get_format ( self , token : str ) -> QtGui . QTextCharFormat : \"\"\"Returns a QTextCharFormat for token or None.\"\"\" if self . _style is None : return self . _get_format_from_document ( token , self . _document ) else : return self . _get_format_from_style ( token , self . _style ) def _get_format_from_document ( self , token : str , document : QtGui . QTextDocument ) -> QtGui . QTextCharFormat : \"\"\"Return a QTextCharFormat for token from document.\"\"\" code , html = next ( self . _formatter . _format_lines ([( token , \"dummy\" )])) self . _document . setHtml ( html ) return gui . TextCursor ( self . _document ) . charFormat () def _get_format_from_style ( self , token : str , style : Style ) -> gui . TextCharFormat : \"\"\"Return a QTextCharFormat for token by reading a Pygments style.\"\"\" result = gui . TextCharFormat () try : token_style = style . style_for_token ( token ) except KeyError : return result for key , value in token_style . items (): if value : if key == \"color\" : result . set_foreground_color ( self . _get_brush ( value )) elif key == \"bgcolor\" : result . set_background_color ( self . _get_brush ( value )) elif key == \"bold\" : result . set_font_weight ( \"bold\" ) elif key == \"italic\" : result . setFontItalic ( True ) elif key == \"underline\" : result . set_underline_style ( \"single\" ) elif key == \"sans\" : result . set_font_style_hint ( \"sans_serif\" ) elif key == \"roman\" : result . set_font_style_hint ( \"serif\" ) elif key == \"mono\" : result . set_font_style_hint ( \"typewriter\" ) return result @functools . cache def _get_brush ( self , color : str ) -> gui . Brush : \"\"\"Return a brush for the color.\"\"\" qcolor = gui . Color ( f \"# { color [: 6 ] } \" ) return gui . Brush ( qcolor ) highlightBlock ( self , string ) Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack set_style_sheet ( self , stylesheet : str ) Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style_sheet ( self , stylesheet : str ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches () get_tokens_unprocessed ( self , text : str , stack = ( 'root' ,)) Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def get_tokens_unprocessed ( self , text : str , stack = ( \"root\" ,)): \"\"\"Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while True : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if isinstance ( action , _TokenType ): yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , f \"wrong state def: { new_state !r} \" statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos + 1 , Text , \" \\n \" else : yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack ) qstring_length ( text : str ) -> int Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def qstring_length ( text : str ) -> int : \"\"\"Tries to compute what the length of an utf16-encoded QString would be.\"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length pythonhighlighter Syntax highlighter for the programming language Python. PythonHighlighter ( SyntaxHighlighter ) Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py class PythonHighlighter ( gui . SyntaxHighlighter ): \"\"\"Syntax highlighter for the Python language.\"\"\" RULES = Rule . __subclasses__ () def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE ) def match_multiline ( self , text : str , delimiter : core . RegularExpression , in_state : int , style : gui . TextCharFormat , ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : match = delimiter . match ( text ) if not match . hasMatch (): return start = match . capturedStart () add = match . capturedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter match = delimiter . match ( text , start + add ) end = match . capturedStart () # Ending delimiter on this line? if end >= add : length = end - start + add + match . capturedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . match ( text , start + length ) . capturedStart () # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state highlightBlock ( self , text : str ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE ) match_multiline ( self , text : str , delimiter : core . RegularExpression , in_state : int , style : gui . TextCharFormat ) Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def match_multiline ( self , text : str , delimiter : core . RegularExpression , in_state : int , style : gui . TextCharFormat , ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : match = delimiter . match ( text ) if not match . hasMatch (): return start = match . capturedStart () add = match . capturedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter match = delimiter . match ( text , start + add ) end = match . capturedStart () # Ending delimiter on this line? if end >= add : length = end - start + add + match . capturedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . match ( text , start + length ) . capturedStart () # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state regexmatchhighlighter RegexMatchHighlighter ( SyntaxHighlighter ) Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py class RegexMatchHighlighter ( gui . SyntaxHighlighter ): def __init__ ( self , document = None ): super () . __init__ ( document ) self . spans : list [ tuple [ int , int ]] | None = [] def set_spans ( self , spans : list [ tuple [ int , int ]] | None ): self . spans = spans # print(self.spans) self . rehighlight () def _colorize ( self , line_pos : int , match_len : int , match_num : int ): fmt = FORMAT_1 if match_num % 2 == 0 else FORMAT_2 self . setFormat ( line_pos , match_len , fmt ) def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i ) highlightBlock ( self , text : str ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i ) xmlhighlighter Based on http://www.yasinuludag.com/blog/?p=49 . XmlHighlighter ( SyntaxHighlighter ) Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py class XmlHighlighter ( gui . SyntaxHighlighter ): RULES = Rule . __subclasses__ () def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . match ( text ) . capturedStart () while start_index >= 0 : match = VALUE_END_EXPRESSION . match ( text , start_index ) end_index = match . capturedStart () if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : comment_len = end_index - start_index + match . capturedLength () self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . match ( text , start_index + comment_len ) . capturedStart () highlightBlock ( self , text : str ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . match ( text ) . capturedStart () while start_index >= 0 : match = VALUE_END_EXPRESSION . match ( text , start_index ) end_index = match . capturedStart () if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : comment_len = end_index - start_index + match . capturedLength () self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . match ( text , start_index + comment_len ) . capturedStart () yamlhighlighter YamlHighlighter ( SyntaxHighlighter ) Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py class YamlHighlighter ( gui . SyntaxHighlighter ): RULES = Rule . __subclasses__ () def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . match ( text ) . capturedStart () if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT ) highlightBlock ( self , text : str ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . match ( text ) . capturedStart () if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"syntaxhighlighters"},{"location":"api/syntaxhighlighters.html#syntaxhighlighters-module","text":"syntaxhighlighters module. contains some custom syntax highlighers","title":"syntaxhighlighters module"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule","text":"","title":"highlightrule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule","text":"HighlightRule(regex: 'str | list[str]' = '', color: 'str' = 'black', italic: 'bool' = False, bold: 'bool' = False, minimal: 'bool' = False, font_size: 'float | None' = None, nth: 'int' = 0, fmt: 'gui.TextCharFormat' = TextCharFormat(2)) Source code in prettyqt/syntaxhighlighters/highlightrule.py @dataclass class HighlightRule : regex : str | list [ str ] = \"\" color : str = \"black\" italic : bool = False bold : bool = False minimal : bool = False font_size : float | None = None nth : int = 0 compiled = None fmt : gui . TextCharFormat = gui . TextCharFormat () def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format () @classmethod def get_format ( cls ) -> gui . TextCharFormat : fmt = gui . TextCharFormat () fmt . setFontItalic ( cls . italic ) fmt . set_foreground_color ( cls . color ) if cls . font_size : fmt . setFontPointSize ( cls . font_size ) if cls . bold : fmt . set_font_weight ( \"bold\" ) return fmt","title":"HighlightRule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format ()","title":"__init_subclass__()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter","text":"","title":"jsonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter","text":"Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py class JsonHighlighter ( gui . SyntaxHighlighter ): def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT )","title":"JsonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter.highlightBlock","text":"Highlight a block of code using the rules outlined in the Constructor. Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter","text":"Syntax highlighter for Markdown markup language.","title":"markdownhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter","text":"Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py class MarkdownHighlighter ( gui . SyntaxHighlighter ): RULES = Rule . __subclasses__ () def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE ) def _match_multiline ( self , text : str , delimiter : core . RegularExpression , style : gui . TextCharFormat ): # If inside triple-single quotes, start at 0 if self . previousBlockState () == 1 : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : match = delimiter . match ( text ) if not match . hasMatch (): return start = match . capturedStart () add = match . capturedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter match = delimiter . match ( text , start + add ) end = match . capturedStart () # Ending delimiter on this line? if end >= add : length = end + match . capturedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( 1 ) length = len ( text ) self . setFormat ( start , length - start + add , style ) # Look for the next match start = delimiter . match ( text , start + length ) . capturedStart ()","title":"MarkdownHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter","text":"","title":"pygmentshighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter","text":"Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py class PygmentsHighlighter ( gui . SyntaxHighlighter ): \"\"\"Syntax highlighter that uses Pygments for parsing.\"\"\" # --------------------------------------------------------------------------- # \"QSyntaxHighlighter\" interface # --------------------------------------------------------------------------- def __init__ ( self , parent : QtGui . QTextDocument , lexer : str , style : str = \"default\" ): super () . __init__ ( parent ) self . _document = self . document () self . _formatter = HtmlFormatter ( nowrap = True ) self . set_style ( style ) if lexer == \"regex\" : self . _lexer = load_lexer_from_file ( str ( paths . RE_LEXER_PATH )) else : self . _lexer = get_lexer_by_name ( lexer ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } (lexer= { self . _lexer . aliases [ 0 ] !r} )\" def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack # --------------------------------------------------------------------------- # \"PygmentsHighlighter\" interface # --------------------------------------------------------------------------- def set_style ( self , style : None | str | Style ): if style is None : style = get_style_by_name ( \"default\" ) elif isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches () def set_style_sheet ( self , stylesheet : str ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches () # --------------------------------------------------------------------------- # Protected interface # --------------------------------------------------------------------------- def _clear_caches ( self ): \"\"\"Clear caches for brushes and formats.\"\"\" self . _get_brush . cache_clear () self . _get_format . cache_clear () @functools . cache def _get_format ( self , token : str ) -> QtGui . QTextCharFormat : \"\"\"Returns a QTextCharFormat for token or None.\"\"\" if self . _style is None : return self . _get_format_from_document ( token , self . _document ) else : return self . _get_format_from_style ( token , self . _style ) def _get_format_from_document ( self , token : str , document : QtGui . QTextDocument ) -> QtGui . QTextCharFormat : \"\"\"Return a QTextCharFormat for token from document.\"\"\" code , html = next ( self . _formatter . _format_lines ([( token , \"dummy\" )])) self . _document . setHtml ( html ) return gui . TextCursor ( self . _document ) . charFormat () def _get_format_from_style ( self , token : str , style : Style ) -> gui . TextCharFormat : \"\"\"Return a QTextCharFormat for token by reading a Pygments style.\"\"\" result = gui . TextCharFormat () try : token_style = style . style_for_token ( token ) except KeyError : return result for key , value in token_style . items (): if value : if key == \"color\" : result . set_foreground_color ( self . _get_brush ( value )) elif key == \"bgcolor\" : result . set_background_color ( self . _get_brush ( value )) elif key == \"bold\" : result . set_font_weight ( \"bold\" ) elif key == \"italic\" : result . setFontItalic ( True ) elif key == \"underline\" : result . set_underline_style ( \"single\" ) elif key == \"sans\" : result . set_font_style_hint ( \"sans_serif\" ) elif key == \"roman\" : result . set_font_style_hint ( \"serif\" ) elif key == \"mono\" : result . set_font_style_hint ( \"typewriter\" ) return result @functools . cache def _get_brush ( self , color : str ) -> gui . Brush : \"\"\"Return a brush for the color.\"\"\" qcolor = gui . Color ( f \"# { color [: 6 ] } \" ) return gui . Brush ( qcolor )","title":"PygmentsHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.highlightBlock","text":"Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style_sheet","text":"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style_sheet ( self , stylesheet : str ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches ()","title":"set_style_sheet()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.get_tokens_unprocessed","text":"Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def get_tokens_unprocessed ( self , text : str , stack = ( \"root\" ,)): \"\"\"Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while True : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if isinstance ( action , _TokenType ): yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , f \"wrong state def: { new_state !r} \" statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos + 1 , Text , \" \\n \" else : yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack )","title":"get_tokens_unprocessed()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.qstring_length","text":"Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def qstring_length ( text : str ) -> int : \"\"\"Tries to compute what the length of an utf16-encoded QString would be.\"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length","title":"qstring_length()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter","text":"Syntax highlighter for the programming language Python.","title":"pythonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter","text":"Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py class PythonHighlighter ( gui . SyntaxHighlighter ): \"\"\"Syntax highlighter for the Python language.\"\"\" RULES = Rule . __subclasses__ () def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE ) def match_multiline ( self , text : str , delimiter : core . RegularExpression , in_state : int , style : gui . TextCharFormat , ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : match = delimiter . match ( text ) if not match . hasMatch (): return start = match . capturedStart () add = match . capturedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter match = delimiter . match ( text , start + add ) end = match . capturedStart () # Ending delimiter on this line? if end >= add : length = end - start + add + match . capturedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . match ( text , start + length ) . capturedStart () # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state","title":"PythonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.match_multiline","text":"Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def match_multiline ( self , text : str , delimiter : core . RegularExpression , in_state : int , style : gui . TextCharFormat , ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : match = delimiter . match ( text ) if not match . hasMatch (): return start = match . capturedStart () add = match . capturedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter match = delimiter . match ( text , start + add ) end = match . capturedStart () # Ending delimiter on this line? if end >= add : length = end - start + add + match . capturedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . match ( text , start + length ) . capturedStart () # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state","title":"match_multiline()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter","text":"","title":"regexmatchhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter","text":"Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py class RegexMatchHighlighter ( gui . SyntaxHighlighter ): def __init__ ( self , document = None ): super () . __init__ ( document ) self . spans : list [ tuple [ int , int ]] | None = [] def set_spans ( self , spans : list [ tuple [ int , int ]] | None ): self . spans = spans # print(self.spans) self . rehighlight () def _colorize ( self , line_pos : int , match_len : int , match_num : int ): fmt = FORMAT_1 if match_num % 2 == 0 else FORMAT_2 self . setFormat ( line_pos , match_len , fmt ) def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i )","title":"RegexMatchHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter","text":"Based on http://www.yasinuludag.com/blog/?p=49 .","title":"xmlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter","text":"Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py class XmlHighlighter ( gui . SyntaxHighlighter ): RULES = Rule . __subclasses__ () def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . match ( text ) . capturedStart () while start_index >= 0 : match = VALUE_END_EXPRESSION . match ( text , start_index ) end_index = match . capturedStart () if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : comment_len = end_index - start_index + match . capturedLength () self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . match ( text , start_index + comment_len ) . capturedStart ()","title":"XmlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . match ( text ) . capturedStart () while start_index >= 0 : match = VALUE_END_EXPRESSION . match ( text , start_index ) end_index = match . capturedStart () if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : comment_len = end_index - start_index + match . capturedLength () self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . match ( text , start_index + comment_len ) . capturedStart ()","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter","text":"","title":"yamlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter","text":"Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py class YamlHighlighter ( gui . SyntaxHighlighter ): RULES = Rule . __subclasses__ () def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . match ( text ) . capturedStart () if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"YamlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . match ( text ) . capturedStart () if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"highlightBlock()"},{"location":"api/webenginecore.html","text":"webenginecore module Webenginewidgets module. contains QtWebEngineCore-based classes webenginedownloadrequest WebEngineDownloadRequest Source code in prettyqt/webenginecore/webenginedownloadrequest.py class WebEngineDownloadRequest : def __init__ ( self , item : QtWebEngineCore . QWebEngineDownloadRequest ): self . item = item def __getattr__ ( self , val ): return getattr ( self . item , val ) def get_interrupt_reason ( self ) -> DownloadInterruptReasonStr : return DOWNLOAD_INTERRUPT_REASONS . inverse [ self . item . interruptReason ()] def get_state ( self ) -> DownloadStateStr : return DOWNLOAD_STATE . inverse [ self . item . state ()] def set_save_page_format ( self , fmt : SavePageFormatStr ): \"\"\"Set the save page format. Args: fmt: save page format for the layout Raises: InvalidParamError: save page format does not exist \"\"\" if fmt not in SAVE_PAGE_FORMAT : raise InvalidParamError ( fmt , SAVE_PAGE_FORMAT ) self . item . setSavePageFormat ( SAVE_PAGE_FORMAT [ fmt ]) def get_save_page_format ( self ) -> SavePageFormatStr : \"\"\"Return current save page format. Returns: Save page format \"\"\" return SAVE_PAGE_FORMAT . inverse [ self . item . savePageFormat ()] get_save_page_format ( self ) -> SavePageFormatStr Return current save page format. Returns: Type Description SavePageFormatStr Save page format Source code in prettyqt/webenginecore/webenginedownloadrequest.py def get_save_page_format ( self ) -> SavePageFormatStr : \"\"\"Return current save page format. Returns: Save page format \"\"\" return SAVE_PAGE_FORMAT . inverse [ self . item . savePageFormat ()] set_save_page_format ( self , fmt : SavePageFormatStr ) Set the save page format. Parameters: Name Type Description Default fmt SavePageFormatStr save page format for the layout required Exceptions: Type Description InvalidParamError save page format does not exist Source code in prettyqt/webenginecore/webenginedownloadrequest.py def set_save_page_format ( self , fmt : SavePageFormatStr ): \"\"\"Set the save page format. Args: fmt: save page format for the layout Raises: InvalidParamError: save page format does not exist \"\"\" if fmt not in SAVE_PAGE_FORMAT : raise InvalidParamError ( fmt , SAVE_PAGE_FORMAT ) self . item . setSavePageFormat ( SAVE_PAGE_FORMAT [ fmt ]) webenginehttprequest WebEngineHttpRequest ( QWebEngineHttpRequest ) Source code in prettyqt/webenginecore/webenginehttprequest.py class WebEngineHttpRequest ( QtWebEngineCore . QWebEngineHttpRequest ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_url () } )\" def set_headers ( self , headers : dict [ str , str ]): for k , v in headers . items (): self . setHeader ( QtCore . QByteArray ( k . encode ()), QtCore . QByteArray ( v . encode ())) def get_headers ( self ) -> dict [ str , str ]: return { bytes ( h ) . decode (): bytes ( self . header ( h )) . decode () for h in self . headers ()} def set_url ( self , url : types . UrlType ): url = core . Url ( url ) self . setUrl ( url ) def get_url ( self ) -> core . Url : return core . Url ( self . url ()) def get_post_data ( self ) -> str : return bytes ( self . postData ()) . decode () def set_method ( self , method : MethodStr ): \"\"\"Set method this WebEngine request is using. Args: method: method Raises: InvalidParamError: method does not exist \"\"\" if method not in METHODS : raise InvalidParamError ( method , METHODS ) self . setMethod ( METHODS [ method ]) def get_method ( self ) -> MethodStr : \"\"\"Get the method this WebEngine request is using. Returns: method \"\"\" return METHODS . inverse [ self . method ()] get_method ( self ) -> MethodStr Get the method this WebEngine request is using. Returns: Type Description MethodStr method Source code in prettyqt/webenginecore/webenginehttprequest.py def get_method ( self ) -> MethodStr : \"\"\"Get the method this WebEngine request is using. Returns: method \"\"\" return METHODS . inverse [ self . method ()] set_method ( self , method : MethodStr ) Set method this WebEngine request is using. Parameters: Name Type Description Default method MethodStr method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/webenginecore/webenginehttprequest.py def set_method ( self , method : MethodStr ): \"\"\"Set method this WebEngine request is using. Args: method: method Raises: InvalidParamError: method does not exist \"\"\" if method not in METHODS : raise InvalidParamError ( method , METHODS ) self . setMethod ( METHODS [ method ]) webenginepage WebEnginePage ( QWebEnginePage ) Source code in prettyqt/webenginecore/webenginepage.py class WebEnginePage ( QtWebEngineCore . QWebEnginePage ): \"\"\"A web engine page holds the HTML document contents, link history + actions.\"\"\" def serialize_fields ( self ): return dict ( audio_muted = self . isAudioMuted (), background_color = self . backgroundColor (), # has_selection=self.hasSelection(), lifecycle_state = self . get_lifecycle_state (), # scroll_position=self.scrollPosition(), url = core . Url ( self . url ()), visible = self . isVisible (), history = core . DataStream . create_bytearray ( self . history ()), zoom_factor = self . zoomFactor (), ) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_url ( self , url : types . PathType ): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) def get_url ( self ) -> core . Url : return core . Url ( self . url ()) def get_icon_url ( self ) -> core . Url : return core . Url ( self . iconUrl ()) def get_requested_url ( self ) -> core . Url : return core . Url ( self . requestedUrl ()) def get_scroll_position ( self ) -> core . PointF : return core . PointF ( self . scrollPosition ()) def get_contents_size ( self ) -> core . SizeF : return core . SizeF ( self . contentsSize ()) def load_url ( self , url : types . UrlType | types . PathType ): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom ) def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] | None = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineCore . QWebEnginePage . FindFlag ( 0 ) if case_sensitive : flag |= self . FindFlag . FindCaseSensitively if backward : flag |= self . FindFlag . FindBackward self . findText ( string , flag , callback ) def set_lifecycle_state ( self , state : LifecycleStateStr ): \"\"\"Set lifecycle state. Args: state: lifecycle state Raises: InvalidParamError: lifecycle state does not exist \"\"\" if state not in LIFECYCLE_STATE : raise InvalidParamError ( state , LIFECYCLE_STATE ) self . setLifecycleState ( LIFECYCLE_STATE [ state ]) def get_lifecycle_state ( self ) -> LifecycleStateStr : \"\"\"Get the current lifecycle state. Returns: lifecycle state \"\"\" return LIFECYCLE_STATE . inverse [ self . lifecycleState ()] def trigger_action ( self , action : WebActionStr , checked : bool = False ): self . triggerAction ( WEB_ACTION [ action ], checked ) def set_feature_permission ( self , url : types . UrlType , feature : FeatureStr , policy : PermissionPolicyStr , ): url = core . Url ( url ) self . setFeaturePermission ( url , FEATURE [ feature ], PERMISSION_POLICY [ policy ]) def get_history ( self ) -> webenginecore . WebEngineHistory : hist = self . history () return webenginecore . WebEngineHistory ( hist ) def get_settings ( self ) -> webenginecore . WebEngineSettings : settings = self . settings () return webenginecore . WebEngineSettings ( settings ) def set_setting ( self , setting_name : webenginecore . webenginesettings . WebAttributeStr , value : bool , ): self . get_settings ()[ setting_name ] = value def get_setting ( self , setting_name : webenginecore . webenginesettings . WebAttributeStr ) -> bool : return self . get_settings ()[ setting_name ] def get_scripts ( self ) -> webenginecore . WebEngineScriptCollection : return webenginecore . WebEngineScriptCollection ( self . scripts ()) def get_context_menu_data ( self ) -> webenginecore . WebEngineContextMenuRequest : return webenginecore . WebEngineContextMenuRequest ( self . contextMenuData ()) def open_in_browser ( self ): try : webbrowser . open ( self . getUrl () . toString ()) except ValueError as e : logger . exception ( e ) # def choose_files( # self, # mode: FileSelectionModeStr, # old_files: List[str], # mimetypes: List[str], # ) -> List[str]: # if mode not in FILE_SELECTION_MODE: # raise InvalidParamError(mode, FILE_SELECTION_MODE) # return self.chooseFiles(FILE_SELECTION_MODE[mode], old_files, mimetypes) def mousedown ( self , selector : str , btn : int = 0 ): \"\"\"Simulate a mousedown event on the targeted element. :param selector: A CSS3 selector to targeted element. :param btn: The number of mouse button. 0 - left button, 1 - middle button, 2 - right button \"\"\" return self . runJavaScript ( f \"\"\" (function () {{ var element = document.querySelector( { selector !r} ); var evt = document.createEvent(\"MouseEvents\"); evt.initMouseEvent(\"mousedown\", true, true, window, 1, 1, 1, 1, 1, false, false, false, false, { btn !r} , element); return element.dispatchEvent(evt); }} )(); \"\"\" ) def set_input_value ( self , selector : str , value ): \"\"\"Set the value of the input matched by given selector.\"\"\" script = f 'document.querySelector( { selector !r} ).setAttribute(\"value\", \" { value } \")' self . runJavaScript ( script ) find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] | None = None ) Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable[[bool], None] | None result callback None Source code in prettyqt/webenginecore/webenginepage.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] | None = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineCore . QWebEnginePage . FindFlag ( 0 ) if case_sensitive : flag |= self . FindFlag . FindCaseSensitively if backward : flag |= self . FindFlag . FindBackward self . findText ( string , flag , callback ) get_lifecycle_state ( self ) -> LifecycleStateStr Get the current lifecycle state. Returns: Type Description LifecycleStateStr lifecycle state Source code in prettyqt/webenginecore/webenginepage.py def get_lifecycle_state ( self ) -> LifecycleStateStr : \"\"\"Get the current lifecycle state. Returns: lifecycle state \"\"\" return LIFECYCLE_STATE . inverse [ self . lifecycleState ()] load_url ( self , url : types . UrlType | types . PathType ) Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url types.UrlType | types.PathType URL to load required Source code in prettyqt/webenginecore/webenginepage.py def load_url ( self , url : types . UrlType | types . PathType ): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) mousedown ( self , selector : str , btn : int = 0 ) Simulate a mousedown event on the targeted element. :param selector: A CSS3 selector to targeted element. :param btn: The number of mouse button. 0 - left button, 1 - middle button, 2 - right button Source code in prettyqt/webenginecore/webenginepage.py def mousedown ( self , selector : str , btn : int = 0 ): \"\"\"Simulate a mousedown event on the targeted element. :param selector: A CSS3 selector to targeted element. :param btn: The number of mouse button. 0 - left button, 1 - middle button, 2 - right button \"\"\" return self . runJavaScript ( f \"\"\" (function () {{ var element = document.querySelector( { selector !r} ); var evt = document.createEvent(\"MouseEvents\"); evt.initMouseEvent(\"mousedown\", true, true, window, 1, 1, 1, 1, 1, false, false, false, false, { btn !r} , element); return element.dispatchEvent(evt); }} )(); \"\"\" ) set_input_value ( self , selector : str , value ) Set the value of the input matched by given selector. Source code in prettyqt/webenginecore/webenginepage.py def set_input_value ( self , selector : str , value ): \"\"\"Set the value of the input matched by given selector.\"\"\" script = f 'document.querySelector( { selector !r} ).setAttribute(\"value\", \" { value } \")' self . runJavaScript ( script ) set_lifecycle_state ( self , state : LifecycleStateStr ) Set lifecycle state. Parameters: Name Type Description Default state LifecycleStateStr lifecycle state required Exceptions: Type Description InvalidParamError lifecycle state does not exist Source code in prettyqt/webenginecore/webenginepage.py def set_lifecycle_state ( self , state : LifecycleStateStr ): \"\"\"Set lifecycle state. Args: state: lifecycle state Raises: InvalidParamError: lifecycle state does not exist \"\"\" if state not in LIFECYCLE_STATE : raise InvalidParamError ( state , LIFECYCLE_STATE ) self . setLifecycleState ( LIFECYCLE_STATE [ state ]) set_url ( self , url : types . PathType ) Set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url types.PathType URL to set required Source code in prettyqt/webenginecore/webenginepage.py def set_url ( self , url : types . PathType ): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom : float ) Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginecore/webenginepage.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom ) webengineprofile WebEngineProfile ( QWebEngineProfile ) Source code in prettyqt/webenginecore/webengineprofile.py class WebEngineProfile ( QtWebEngineCore . QWebEngineProfile ): def set_persistent_cookie_policy ( self , policy : PersistentCookiePolicyStr ): \"\"\"Set the persistent cookie policy. Args: policy: persistent cookie policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in PERSISTENT_COOKIE_POLICY : raise InvalidParamError ( policy , PERSISTENT_COOKIE_POLICY ) self . setPersistentCookiesPolicy ( PERSISTENT_COOKIE_POLICY [ policy ]) def get_persistent_cookie_policy ( self ) -> PersistentCookiePolicyStr : \"\"\"Return current persistent cookie policy. Returns: Persistent cookie policy \"\"\" return PERSISTENT_COOKIE_POLICY . inverse [ self . persistentCookiesPolicy ()] def set_http_cache_type ( self , typ : HttpCacheTypeStr ): \"\"\"Set the http cache type. Args: typ: http cache type Raises: InvalidParamError: Cache type does not exist \"\"\" if typ not in HTTP_CACHE_TYPE : raise InvalidParamError ( typ , HTTP_CACHE_TYPE ) self . setHttpCacheType ( HTTP_CACHE_TYPE [ typ ]) def get_http_cache_type ( self ) -> HttpCacheTypeStr : \"\"\"Return current http cache type. Returns: Http cache type \"\"\" return HTTP_CACHE_TYPE . inverse [ self . httpCacheType ()] def get_scripts ( self ) -> webenginecore . WebEngineScriptCollection : return webenginecore . WebEngineScriptCollection ( self . scripts ()) get_http_cache_type ( self ) -> HttpCacheTypeStr Return current http cache type. Returns: Type Description HttpCacheTypeStr Http cache type Source code in prettyqt/webenginecore/webengineprofile.py def get_http_cache_type ( self ) -> HttpCacheTypeStr : \"\"\"Return current http cache type. Returns: Http cache type \"\"\" return HTTP_CACHE_TYPE . inverse [ self . httpCacheType ()] get_persistent_cookie_policy ( self ) -> PersistentCookiePolicyStr Return current persistent cookie policy. Returns: Type Description PersistentCookiePolicyStr Persistent cookie policy Source code in prettyqt/webenginecore/webengineprofile.py def get_persistent_cookie_policy ( self ) -> PersistentCookiePolicyStr : \"\"\"Return current persistent cookie policy. Returns: Persistent cookie policy \"\"\" return PERSISTENT_COOKIE_POLICY . inverse [ self . persistentCookiesPolicy ()] set_http_cache_type ( self , typ : HttpCacheTypeStr ) Set the http cache type. Parameters: Name Type Description Default typ HttpCacheTypeStr http cache type required Exceptions: Type Description InvalidParamError Cache type does not exist Source code in prettyqt/webenginecore/webengineprofile.py def set_http_cache_type ( self , typ : HttpCacheTypeStr ): \"\"\"Set the http cache type. Args: typ: http cache type Raises: InvalidParamError: Cache type does not exist \"\"\" if typ not in HTTP_CACHE_TYPE : raise InvalidParamError ( typ , HTTP_CACHE_TYPE ) self . setHttpCacheType ( HTTP_CACHE_TYPE [ typ ]) set_persistent_cookie_policy ( self , policy : PersistentCookiePolicyStr ) Set the persistent cookie policy. Parameters: Name Type Description Default policy PersistentCookiePolicyStr persistent cookie policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginecore/webengineprofile.py def set_persistent_cookie_policy ( self , policy : PersistentCookiePolicyStr ): \"\"\"Set the persistent cookie policy. Args: policy: persistent cookie policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in PERSISTENT_COOKIE_POLICY : raise InvalidParamError ( policy , PERSISTENT_COOKIE_POLICY ) self . setPersistentCookiesPolicy ( PERSISTENT_COOKIE_POLICY [ policy ]) webenginescript WebEngineScript ( QWebEngineScript ) Source code in prettyqt/webenginecore/webenginescript.py class WebEngineScript ( QtWebEngineCore . QWebEngineScript ): def set_injection_point ( self , point : InjectionPointStr ): \"\"\"Set injection point. Args: point: injection point to use Raises: InvalidParamError: injection point does not exist \"\"\" if point not in INJECTION_POINT : raise InvalidParamError ( point , INJECTION_POINT ) self . setInjectionPoint ( INJECTION_POINT [ point ]) def get_injection_point ( self ) -> InjectionPointStr : \"\"\"Return injection point. Returns: injection point \"\"\" return INJECTION_POINT . inverse [ self . injectionPoint ()] get_injection_point ( self ) -> InjectionPointStr Return injection point. Returns: Type Description InjectionPointStr injection point Source code in prettyqt/webenginecore/webenginescript.py def get_injection_point ( self ) -> InjectionPointStr : \"\"\"Return injection point. Returns: injection point \"\"\" return INJECTION_POINT . inverse [ self . injectionPoint ()] set_injection_point ( self , point : InjectionPointStr ) Set injection point. Parameters: Name Type Description Default point InjectionPointStr injection point to use required Exceptions: Type Description InvalidParamError injection point does not exist Source code in prettyqt/webenginecore/webenginescript.py def set_injection_point ( self , point : InjectionPointStr ): \"\"\"Set injection point. Args: point: injection point to use Raises: InvalidParamError: injection point does not exist \"\"\" if point not in INJECTION_POINT : raise InvalidParamError ( point , INJECTION_POINT ) self . setInjectionPoint ( INJECTION_POINT [ point ]) webenginesettings WebEngineSettings Source code in prettyqt/webenginecore/webenginesettings.py class WebEngineSettings : def __init__ ( self , item : QtWebEngineCore . QWebEngineSettings ): self . item = item def __getattr__ ( self , val ): return getattr ( self . item , val ) def __setitem__ ( self , index : WebAttributeStr , value : bool ): self . item . setAttribute ( WEB_ATTRIBUTES [ index ], value ) def __getitem__ ( self , index : WebAttributeStr ) -> bool : return self . item . testAttribute ( WEB_ATTRIBUTES [ index ]) def __delitem__ ( self , index : WebAttributeStr ): return self . item . resetAttribute ( WEB_ATTRIBUTES [ index ]) def set_unknown_url_scheme_policy ( self , policy : UnknownUrlSchemePolicyStr ): \"\"\"Set the unknown url scheme policy. Args: policy: unknown url scheme policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in UNKNOWN_URL_SCHEME_POLICY : raise InvalidParamError ( policy , UNKNOWN_URL_SCHEME_POLICY ) self . item . setUnknownUrlSchemePolicy ( UNKNOWN_URL_SCHEME_POLICY [ policy ]) def get_unknown_url_scheme_policy ( self ) -> UnknownUrlSchemePolicyStr : \"\"\"Return current unknown url scheme policy. Returns: Unknown url scheme policy \"\"\" return UNKNOWN_URL_SCHEME_POLICY . inverse [ self . item . unknownUrlSchemePolicy ()] def set_font_family ( self , which : FontFamilyStr , family : str ): \"\"\"Set the actual font family to family for the specified generic family, which. Args: which: family to set family: generic family Raises: InvalidParamError: Font family does not exist \"\"\" if which not in FONT_FAMILY : raise InvalidParamError ( which , FONT_FAMILY ) self . item . setFontFamily ( FONT_FAMILY [ which ], family ) def get_font_family ( self , family : FontFamilyStr ) -> str : \"\"\"Return the actual font family for the specified generic font family. Args: family: generic font family Returns: Font family \"\"\" return self . item . fontFamily ( FONT_FAMILY [ family ]) def set_font_size ( self , typ : FontSizeStr , size : int ): \"\"\"Set the font size for type to size in pixels. Args: typ: font size type size: size in pixels Raises: InvalidParamError: Font size does not exist \"\"\" if typ not in FONT_SIZE : raise InvalidParamError ( typ , FONT_SIZE ) self . item . setFontSize ( FONT_SIZE [ typ ], size ) def get_font_size ( self , typ : FontSizeStr ) -> int : \"\"\"Return the default font size for type in pixels. Args: typ: font size type Returns: Font size \"\"\" return self . item . fontSize ( FONT_SIZE [ typ ]) get_font_family ( self , family : FontFamilyStr ) -> str Return the actual font family for the specified generic font family. Parameters: Name Type Description Default family FontFamilyStr generic font family required Returns: Type Description str Font family Source code in prettyqt/webenginecore/webenginesettings.py def get_font_family ( self , family : FontFamilyStr ) -> str : \"\"\"Return the actual font family for the specified generic font family. Args: family: generic font family Returns: Font family \"\"\" return self . item . fontFamily ( FONT_FAMILY [ family ]) get_font_size ( self , typ : FontSizeStr ) -> int Return the default font size for type in pixels. Parameters: Name Type Description Default typ FontSizeStr font size type required Returns: Type Description int Font size Source code in prettyqt/webenginecore/webenginesettings.py def get_font_size ( self , typ : FontSizeStr ) -> int : \"\"\"Return the default font size for type in pixels. Args: typ: font size type Returns: Font size \"\"\" return self . item . fontSize ( FONT_SIZE [ typ ]) get_unknown_url_scheme_policy ( self ) -> UnknownUrlSchemePolicyStr Return current unknown url scheme policy. Returns: Type Description UnknownUrlSchemePolicyStr Unknown url scheme policy Source code in prettyqt/webenginecore/webenginesettings.py def get_unknown_url_scheme_policy ( self ) -> UnknownUrlSchemePolicyStr : \"\"\"Return current unknown url scheme policy. Returns: Unknown url scheme policy \"\"\" return UNKNOWN_URL_SCHEME_POLICY . inverse [ self . item . unknownUrlSchemePolicy ()] set_font_family ( self , which : FontFamilyStr , family : str ) Set the actual font family to family for the specified generic family, which. Parameters: Name Type Description Default which FontFamilyStr family to set required family str generic family required Exceptions: Type Description InvalidParamError Font family does not exist Source code in prettyqt/webenginecore/webenginesettings.py def set_font_family ( self , which : FontFamilyStr , family : str ): \"\"\"Set the actual font family to family for the specified generic family, which. Args: which: family to set family: generic family Raises: InvalidParamError: Font family does not exist \"\"\" if which not in FONT_FAMILY : raise InvalidParamError ( which , FONT_FAMILY ) self . item . setFontFamily ( FONT_FAMILY [ which ], family ) set_font_size ( self , typ : FontSizeStr , size : int ) Set the font size for type to size in pixels. Parameters: Name Type Description Default typ FontSizeStr font size type required size int size in pixels required Exceptions: Type Description InvalidParamError Font size does not exist Source code in prettyqt/webenginecore/webenginesettings.py def set_font_size ( self , typ : FontSizeStr , size : int ): \"\"\"Set the font size for type to size in pixels. Args: typ: font size type size: size in pixels Raises: InvalidParamError: Font size does not exist \"\"\" if typ not in FONT_SIZE : raise InvalidParamError ( typ , FONT_SIZE ) self . item . setFontSize ( FONT_SIZE [ typ ], size ) set_unknown_url_scheme_policy ( self , policy : UnknownUrlSchemePolicyStr ) Set the unknown url scheme policy. Parameters: Name Type Description Default policy UnknownUrlSchemePolicyStr unknown url scheme policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginecore/webenginesettings.py def set_unknown_url_scheme_policy ( self , policy : UnknownUrlSchemePolicyStr ): \"\"\"Set the unknown url scheme policy. Args: policy: unknown url scheme policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in UNKNOWN_URL_SCHEME_POLICY : raise InvalidParamError ( policy , UNKNOWN_URL_SCHEME_POLICY ) self . item . setUnknownUrlSchemePolicy ( UNKNOWN_URL_SCHEME_POLICY [ policy ]) webengineurlscheme WebEngineUrlScheme ( QWebEngineUrlScheme ) Source code in prettyqt/webenginecore/webengineurlscheme.py class WebEngineUrlScheme ( QtWebEngineCore . QWebEngineUrlScheme ): def get_name ( self ) -> str : return bytes ( self . name ()) . decode () @classmethod def get_scheme_by_name ( cls , name : str ) -> WebEngineUrlScheme : scheme = cls . schemeByName ( QtCore . QByteArray ( name . encode ())) return cls ( scheme ) def set_name ( self , name : str ): self . setName ( QtCore . QByteArray ( name . encode ())) def set_syntax ( self , syntax : SyntaxStr ): \"\"\"Set syntax. Args: syntax: syntax to use Raises: InvalidParamError: syntax does not exist \"\"\" if syntax not in SYNTAX : raise InvalidParamError ( syntax , SYNTAX ) self . setSyntax ( SYNTAX [ syntax ]) def get_syntax ( self ) -> SyntaxStr : \"\"\"Return syntax. Returns: syntax \"\"\" return SYNTAX . inverse [ self . syntax ()] get_syntax ( self ) -> SyntaxStr Return syntax. Returns: Type Description SyntaxStr syntax Source code in prettyqt/webenginecore/webengineurlscheme.py def get_syntax ( self ) -> SyntaxStr : \"\"\"Return syntax. Returns: syntax \"\"\" return SYNTAX . inverse [ self . syntax ()] set_syntax ( self , syntax : SyntaxStr ) Set syntax. Parameters: Name Type Description Default syntax SyntaxStr syntax to use required Exceptions: Type Description InvalidParamError syntax does not exist Source code in prettyqt/webenginecore/webengineurlscheme.py def set_syntax ( self , syntax : SyntaxStr ): \"\"\"Set syntax. Args: syntax: syntax to use Raises: InvalidParamError: syntax does not exist \"\"\" if syntax not in SYNTAX : raise InvalidParamError ( syntax , SYNTAX ) self . setSyntax ( SYNTAX [ syntax ])","title":"webenginecore"},{"location":"api/webenginecore.html#webenginecore-module","text":"Webenginewidgets module. contains QtWebEngineCore-based classes","title":"webenginecore module"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest","text":"","title":"webenginedownloadrequest"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest","text":"Source code in prettyqt/webenginecore/webenginedownloadrequest.py class WebEngineDownloadRequest : def __init__ ( self , item : QtWebEngineCore . QWebEngineDownloadRequest ): self . item = item def __getattr__ ( self , val ): return getattr ( self . item , val ) def get_interrupt_reason ( self ) -> DownloadInterruptReasonStr : return DOWNLOAD_INTERRUPT_REASONS . inverse [ self . item . interruptReason ()] def get_state ( self ) -> DownloadStateStr : return DOWNLOAD_STATE . inverse [ self . item . state ()] def set_save_page_format ( self , fmt : SavePageFormatStr ): \"\"\"Set the save page format. Args: fmt: save page format for the layout Raises: InvalidParamError: save page format does not exist \"\"\" if fmt not in SAVE_PAGE_FORMAT : raise InvalidParamError ( fmt , SAVE_PAGE_FORMAT ) self . item . setSavePageFormat ( SAVE_PAGE_FORMAT [ fmt ]) def get_save_page_format ( self ) -> SavePageFormatStr : \"\"\"Return current save page format. Returns: Save page format \"\"\" return SAVE_PAGE_FORMAT . inverse [ self . item . savePageFormat ()]","title":"WebEngineDownloadRequest"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest.get_save_page_format","text":"Return current save page format. Returns: Type Description SavePageFormatStr Save page format Source code in prettyqt/webenginecore/webenginedownloadrequest.py def get_save_page_format ( self ) -> SavePageFormatStr : \"\"\"Return current save page format. Returns: Save page format \"\"\" return SAVE_PAGE_FORMAT . inverse [ self . item . savePageFormat ()]","title":"get_save_page_format()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest.set_save_page_format","text":"Set the save page format. Parameters: Name Type Description Default fmt SavePageFormatStr save page format for the layout required Exceptions: Type Description InvalidParamError save page format does not exist Source code in prettyqt/webenginecore/webenginedownloadrequest.py def set_save_page_format ( self , fmt : SavePageFormatStr ): \"\"\"Set the save page format. Args: fmt: save page format for the layout Raises: InvalidParamError: save page format does not exist \"\"\" if fmt not in SAVE_PAGE_FORMAT : raise InvalidParamError ( fmt , SAVE_PAGE_FORMAT ) self . item . setSavePageFormat ( SAVE_PAGE_FORMAT [ fmt ])","title":"set_save_page_format()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest","text":"","title":"webenginehttprequest"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest","text":"Source code in prettyqt/webenginecore/webenginehttprequest.py class WebEngineHttpRequest ( QtWebEngineCore . QWebEngineHttpRequest ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . get_url () } )\" def set_headers ( self , headers : dict [ str , str ]): for k , v in headers . items (): self . setHeader ( QtCore . QByteArray ( k . encode ()), QtCore . QByteArray ( v . encode ())) def get_headers ( self ) -> dict [ str , str ]: return { bytes ( h ) . decode (): bytes ( self . header ( h )) . decode () for h in self . headers ()} def set_url ( self , url : types . UrlType ): url = core . Url ( url ) self . setUrl ( url ) def get_url ( self ) -> core . Url : return core . Url ( self . url ()) def get_post_data ( self ) -> str : return bytes ( self . postData ()) . decode () def set_method ( self , method : MethodStr ): \"\"\"Set method this WebEngine request is using. Args: method: method Raises: InvalidParamError: method does not exist \"\"\" if method not in METHODS : raise InvalidParamError ( method , METHODS ) self . setMethod ( METHODS [ method ]) def get_method ( self ) -> MethodStr : \"\"\"Get the method this WebEngine request is using. Returns: method \"\"\" return METHODS . inverse [ self . method ()]","title":"WebEngineHttpRequest"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.get_method","text":"Get the method this WebEngine request is using. Returns: Type Description MethodStr method Source code in prettyqt/webenginecore/webenginehttprequest.py def get_method ( self ) -> MethodStr : \"\"\"Get the method this WebEngine request is using. Returns: method \"\"\" return METHODS . inverse [ self . method ()]","title":"get_method()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.set_method","text":"Set method this WebEngine request is using. Parameters: Name Type Description Default method MethodStr method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/webenginecore/webenginehttprequest.py def set_method ( self , method : MethodStr ): \"\"\"Set method this WebEngine request is using. Args: method: method Raises: InvalidParamError: method does not exist \"\"\" if method not in METHODS : raise InvalidParamError ( method , METHODS ) self . setMethod ( METHODS [ method ])","title":"set_method()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage","text":"","title":"webenginepage"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage","text":"Source code in prettyqt/webenginecore/webenginepage.py class WebEnginePage ( QtWebEngineCore . QWebEnginePage ): \"\"\"A web engine page holds the HTML document contents, link history + actions.\"\"\" def serialize_fields ( self ): return dict ( audio_muted = self . isAudioMuted (), background_color = self . backgroundColor (), # has_selection=self.hasSelection(), lifecycle_state = self . get_lifecycle_state (), # scroll_position=self.scrollPosition(), url = core . Url ( self . url ()), visible = self . isVisible (), history = core . DataStream . create_bytearray ( self . history ()), zoom_factor = self . zoomFactor (), ) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_url ( self , url : types . PathType ): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) def get_url ( self ) -> core . Url : return core . Url ( self . url ()) def get_icon_url ( self ) -> core . Url : return core . Url ( self . iconUrl ()) def get_requested_url ( self ) -> core . Url : return core . Url ( self . requestedUrl ()) def get_scroll_position ( self ) -> core . PointF : return core . PointF ( self . scrollPosition ()) def get_contents_size ( self ) -> core . SizeF : return core . SizeF ( self . contentsSize ()) def load_url ( self , url : types . UrlType | types . PathType ): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom ) def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] | None = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineCore . QWebEnginePage . FindFlag ( 0 ) if case_sensitive : flag |= self . FindFlag . FindCaseSensitively if backward : flag |= self . FindFlag . FindBackward self . findText ( string , flag , callback ) def set_lifecycle_state ( self , state : LifecycleStateStr ): \"\"\"Set lifecycle state. Args: state: lifecycle state Raises: InvalidParamError: lifecycle state does not exist \"\"\" if state not in LIFECYCLE_STATE : raise InvalidParamError ( state , LIFECYCLE_STATE ) self . setLifecycleState ( LIFECYCLE_STATE [ state ]) def get_lifecycle_state ( self ) -> LifecycleStateStr : \"\"\"Get the current lifecycle state. Returns: lifecycle state \"\"\" return LIFECYCLE_STATE . inverse [ self . lifecycleState ()] def trigger_action ( self , action : WebActionStr , checked : bool = False ): self . triggerAction ( WEB_ACTION [ action ], checked ) def set_feature_permission ( self , url : types . UrlType , feature : FeatureStr , policy : PermissionPolicyStr , ): url = core . Url ( url ) self . setFeaturePermission ( url , FEATURE [ feature ], PERMISSION_POLICY [ policy ]) def get_history ( self ) -> webenginecore . WebEngineHistory : hist = self . history () return webenginecore . WebEngineHistory ( hist ) def get_settings ( self ) -> webenginecore . WebEngineSettings : settings = self . settings () return webenginecore . WebEngineSettings ( settings ) def set_setting ( self , setting_name : webenginecore . webenginesettings . WebAttributeStr , value : bool , ): self . get_settings ()[ setting_name ] = value def get_setting ( self , setting_name : webenginecore . webenginesettings . WebAttributeStr ) -> bool : return self . get_settings ()[ setting_name ] def get_scripts ( self ) -> webenginecore . WebEngineScriptCollection : return webenginecore . WebEngineScriptCollection ( self . scripts ()) def get_context_menu_data ( self ) -> webenginecore . WebEngineContextMenuRequest : return webenginecore . WebEngineContextMenuRequest ( self . contextMenuData ()) def open_in_browser ( self ): try : webbrowser . open ( self . getUrl () . toString ()) except ValueError as e : logger . exception ( e ) # def choose_files( # self, # mode: FileSelectionModeStr, # old_files: List[str], # mimetypes: List[str], # ) -> List[str]: # if mode not in FILE_SELECTION_MODE: # raise InvalidParamError(mode, FILE_SELECTION_MODE) # return self.chooseFiles(FILE_SELECTION_MODE[mode], old_files, mimetypes) def mousedown ( self , selector : str , btn : int = 0 ): \"\"\"Simulate a mousedown event on the targeted element. :param selector: A CSS3 selector to targeted element. :param btn: The number of mouse button. 0 - left button, 1 - middle button, 2 - right button \"\"\" return self . runJavaScript ( f \"\"\" (function () {{ var element = document.querySelector( { selector !r} ); var evt = document.createEvent(\"MouseEvents\"); evt.initMouseEvent(\"mousedown\", true, true, window, 1, 1, 1, 1, 1, false, false, false, false, { btn !r} , element); return element.dispatchEvent(evt); }} )(); \"\"\" ) def set_input_value ( self , selector : str , value ): \"\"\"Set the value of the input matched by given selector.\"\"\" script = f 'document.querySelector( { selector !r} ).setAttribute(\"value\", \" { value } \")' self . runJavaScript ( script )","title":"WebEnginePage"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.find_text","text":"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable[[bool], None] | None result callback None Source code in prettyqt/webenginecore/webenginepage.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] | None = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineCore . QWebEnginePage . FindFlag ( 0 ) if case_sensitive : flag |= self . FindFlag . FindCaseSensitively if backward : flag |= self . FindFlag . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.get_lifecycle_state","text":"Get the current lifecycle state. Returns: Type Description LifecycleStateStr lifecycle state Source code in prettyqt/webenginecore/webenginepage.py def get_lifecycle_state ( self ) -> LifecycleStateStr : \"\"\"Get the current lifecycle state. Returns: lifecycle state \"\"\" return LIFECYCLE_STATE . inverse [ self . lifecycleState ()]","title":"get_lifecycle_state()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.load_url","text":"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url types.UrlType | types.PathType URL to load required Source code in prettyqt/webenginecore/webenginepage.py def load_url ( self , url : types . UrlType | types . PathType ): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.mousedown","text":"Simulate a mousedown event on the targeted element. :param selector: A CSS3 selector to targeted element. :param btn: The number of mouse button. 0 - left button, 1 - middle button, 2 - right button Source code in prettyqt/webenginecore/webenginepage.py def mousedown ( self , selector : str , btn : int = 0 ): \"\"\"Simulate a mousedown event on the targeted element. :param selector: A CSS3 selector to targeted element. :param btn: The number of mouse button. 0 - left button, 1 - middle button, 2 - right button \"\"\" return self . runJavaScript ( f \"\"\" (function () {{ var element = document.querySelector( { selector !r} ); var evt = document.createEvent(\"MouseEvents\"); evt.initMouseEvent(\"mousedown\", true, true, window, 1, 1, 1, 1, 1, false, false, false, false, { btn !r} , element); return element.dispatchEvent(evt); }} )(); \"\"\" )","title":"mousedown()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_input_value","text":"Set the value of the input matched by given selector. Source code in prettyqt/webenginecore/webenginepage.py def set_input_value ( self , selector : str , value ): \"\"\"Set the value of the input matched by given selector.\"\"\" script = f 'document.querySelector( { selector !r} ).setAttribute(\"value\", \" { value } \")' self . runJavaScript ( script )","title":"set_input_value()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_lifecycle_state","text":"Set lifecycle state. Parameters: Name Type Description Default state LifecycleStateStr lifecycle state required Exceptions: Type Description InvalidParamError lifecycle state does not exist Source code in prettyqt/webenginecore/webenginepage.py def set_lifecycle_state ( self , state : LifecycleStateStr ): \"\"\"Set lifecycle state. Args: state: lifecycle state Raises: InvalidParamError: lifecycle state does not exist \"\"\" if state not in LIFECYCLE_STATE : raise InvalidParamError ( state , LIFECYCLE_STATE ) self . setLifecycleState ( LIFECYCLE_STATE [ state ])","title":"set_lifecycle_state()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_url","text":"Set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url types.PathType URL to set required Source code in prettyqt/webenginecore/webenginepage.py def set_url ( self , url : types . PathType ): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_zoom","text":"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginecore/webenginepage.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile","text":"","title":"webengineprofile"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile","text":"Source code in prettyqt/webenginecore/webengineprofile.py class WebEngineProfile ( QtWebEngineCore . QWebEngineProfile ): def set_persistent_cookie_policy ( self , policy : PersistentCookiePolicyStr ): \"\"\"Set the persistent cookie policy. Args: policy: persistent cookie policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in PERSISTENT_COOKIE_POLICY : raise InvalidParamError ( policy , PERSISTENT_COOKIE_POLICY ) self . setPersistentCookiesPolicy ( PERSISTENT_COOKIE_POLICY [ policy ]) def get_persistent_cookie_policy ( self ) -> PersistentCookiePolicyStr : \"\"\"Return current persistent cookie policy. Returns: Persistent cookie policy \"\"\" return PERSISTENT_COOKIE_POLICY . inverse [ self . persistentCookiesPolicy ()] def set_http_cache_type ( self , typ : HttpCacheTypeStr ): \"\"\"Set the http cache type. Args: typ: http cache type Raises: InvalidParamError: Cache type does not exist \"\"\" if typ not in HTTP_CACHE_TYPE : raise InvalidParamError ( typ , HTTP_CACHE_TYPE ) self . setHttpCacheType ( HTTP_CACHE_TYPE [ typ ]) def get_http_cache_type ( self ) -> HttpCacheTypeStr : \"\"\"Return current http cache type. Returns: Http cache type \"\"\" return HTTP_CACHE_TYPE . inverse [ self . httpCacheType ()] def get_scripts ( self ) -> webenginecore . WebEngineScriptCollection : return webenginecore . WebEngineScriptCollection ( self . scripts ())","title":"WebEngineProfile"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.get_http_cache_type","text":"Return current http cache type. Returns: Type Description HttpCacheTypeStr Http cache type Source code in prettyqt/webenginecore/webengineprofile.py def get_http_cache_type ( self ) -> HttpCacheTypeStr : \"\"\"Return current http cache type. Returns: Http cache type \"\"\" return HTTP_CACHE_TYPE . inverse [ self . httpCacheType ()]","title":"get_http_cache_type()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.get_persistent_cookie_policy","text":"Return current persistent cookie policy. Returns: Type Description PersistentCookiePolicyStr Persistent cookie policy Source code in prettyqt/webenginecore/webengineprofile.py def get_persistent_cookie_policy ( self ) -> PersistentCookiePolicyStr : \"\"\"Return current persistent cookie policy. Returns: Persistent cookie policy \"\"\" return PERSISTENT_COOKIE_POLICY . inverse [ self . persistentCookiesPolicy ()]","title":"get_persistent_cookie_policy()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.set_http_cache_type","text":"Set the http cache type. Parameters: Name Type Description Default typ HttpCacheTypeStr http cache type required Exceptions: Type Description InvalidParamError Cache type does not exist Source code in prettyqt/webenginecore/webengineprofile.py def set_http_cache_type ( self , typ : HttpCacheTypeStr ): \"\"\"Set the http cache type. Args: typ: http cache type Raises: InvalidParamError: Cache type does not exist \"\"\" if typ not in HTTP_CACHE_TYPE : raise InvalidParamError ( typ , HTTP_CACHE_TYPE ) self . setHttpCacheType ( HTTP_CACHE_TYPE [ typ ])","title":"set_http_cache_type()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.set_persistent_cookie_policy","text":"Set the persistent cookie policy. Parameters: Name Type Description Default policy PersistentCookiePolicyStr persistent cookie policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginecore/webengineprofile.py def set_persistent_cookie_policy ( self , policy : PersistentCookiePolicyStr ): \"\"\"Set the persistent cookie policy. Args: policy: persistent cookie policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in PERSISTENT_COOKIE_POLICY : raise InvalidParamError ( policy , PERSISTENT_COOKIE_POLICY ) self . setPersistentCookiesPolicy ( PERSISTENT_COOKIE_POLICY [ policy ])","title":"set_persistent_cookie_policy()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript","text":"","title":"webenginescript"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript.WebEngineScript","text":"Source code in prettyqt/webenginecore/webenginescript.py class WebEngineScript ( QtWebEngineCore . QWebEngineScript ): def set_injection_point ( self , point : InjectionPointStr ): \"\"\"Set injection point. Args: point: injection point to use Raises: InvalidParamError: injection point does not exist \"\"\" if point not in INJECTION_POINT : raise InvalidParamError ( point , INJECTION_POINT ) self . setInjectionPoint ( INJECTION_POINT [ point ]) def get_injection_point ( self ) -> InjectionPointStr : \"\"\"Return injection point. Returns: injection point \"\"\" return INJECTION_POINT . inverse [ self . injectionPoint ()]","title":"WebEngineScript"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript.WebEngineScript.get_injection_point","text":"Return injection point. Returns: Type Description InjectionPointStr injection point Source code in prettyqt/webenginecore/webenginescript.py def get_injection_point ( self ) -> InjectionPointStr : \"\"\"Return injection point. Returns: injection point \"\"\" return INJECTION_POINT . inverse [ self . injectionPoint ()]","title":"get_injection_point()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript.WebEngineScript.set_injection_point","text":"Set injection point. Parameters: Name Type Description Default point InjectionPointStr injection point to use required Exceptions: Type Description InvalidParamError injection point does not exist Source code in prettyqt/webenginecore/webenginescript.py def set_injection_point ( self , point : InjectionPointStr ): \"\"\"Set injection point. Args: point: injection point to use Raises: InvalidParamError: injection point does not exist \"\"\" if point not in INJECTION_POINT : raise InvalidParamError ( point , INJECTION_POINT ) self . setInjectionPoint ( INJECTION_POINT [ point ])","title":"set_injection_point()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings","text":"","title":"webenginesettings"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings","text":"Source code in prettyqt/webenginecore/webenginesettings.py class WebEngineSettings : def __init__ ( self , item : QtWebEngineCore . QWebEngineSettings ): self . item = item def __getattr__ ( self , val ): return getattr ( self . item , val ) def __setitem__ ( self , index : WebAttributeStr , value : bool ): self . item . setAttribute ( WEB_ATTRIBUTES [ index ], value ) def __getitem__ ( self , index : WebAttributeStr ) -> bool : return self . item . testAttribute ( WEB_ATTRIBUTES [ index ]) def __delitem__ ( self , index : WebAttributeStr ): return self . item . resetAttribute ( WEB_ATTRIBUTES [ index ]) def set_unknown_url_scheme_policy ( self , policy : UnknownUrlSchemePolicyStr ): \"\"\"Set the unknown url scheme policy. Args: policy: unknown url scheme policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in UNKNOWN_URL_SCHEME_POLICY : raise InvalidParamError ( policy , UNKNOWN_URL_SCHEME_POLICY ) self . item . setUnknownUrlSchemePolicy ( UNKNOWN_URL_SCHEME_POLICY [ policy ]) def get_unknown_url_scheme_policy ( self ) -> UnknownUrlSchemePolicyStr : \"\"\"Return current unknown url scheme policy. Returns: Unknown url scheme policy \"\"\" return UNKNOWN_URL_SCHEME_POLICY . inverse [ self . item . unknownUrlSchemePolicy ()] def set_font_family ( self , which : FontFamilyStr , family : str ): \"\"\"Set the actual font family to family for the specified generic family, which. Args: which: family to set family: generic family Raises: InvalidParamError: Font family does not exist \"\"\" if which not in FONT_FAMILY : raise InvalidParamError ( which , FONT_FAMILY ) self . item . setFontFamily ( FONT_FAMILY [ which ], family ) def get_font_family ( self , family : FontFamilyStr ) -> str : \"\"\"Return the actual font family for the specified generic font family. Args: family: generic font family Returns: Font family \"\"\" return self . item . fontFamily ( FONT_FAMILY [ family ]) def set_font_size ( self , typ : FontSizeStr , size : int ): \"\"\"Set the font size for type to size in pixels. Args: typ: font size type size: size in pixels Raises: InvalidParamError: Font size does not exist \"\"\" if typ not in FONT_SIZE : raise InvalidParamError ( typ , FONT_SIZE ) self . item . setFontSize ( FONT_SIZE [ typ ], size ) def get_font_size ( self , typ : FontSizeStr ) -> int : \"\"\"Return the default font size for type in pixels. Args: typ: font size type Returns: Font size \"\"\" return self . item . fontSize ( FONT_SIZE [ typ ])","title":"WebEngineSettings"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_font_family","text":"Return the actual font family for the specified generic font family. Parameters: Name Type Description Default family FontFamilyStr generic font family required Returns: Type Description str Font family Source code in prettyqt/webenginecore/webenginesettings.py def get_font_family ( self , family : FontFamilyStr ) -> str : \"\"\"Return the actual font family for the specified generic font family. Args: family: generic font family Returns: Font family \"\"\" return self . item . fontFamily ( FONT_FAMILY [ family ])","title":"get_font_family()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_font_size","text":"Return the default font size for type in pixels. Parameters: Name Type Description Default typ FontSizeStr font size type required Returns: Type Description int Font size Source code in prettyqt/webenginecore/webenginesettings.py def get_font_size ( self , typ : FontSizeStr ) -> int : \"\"\"Return the default font size for type in pixels. Args: typ: font size type Returns: Font size \"\"\" return self . item . fontSize ( FONT_SIZE [ typ ])","title":"get_font_size()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_unknown_url_scheme_policy","text":"Return current unknown url scheme policy. Returns: Type Description UnknownUrlSchemePolicyStr Unknown url scheme policy Source code in prettyqt/webenginecore/webenginesettings.py def get_unknown_url_scheme_policy ( self ) -> UnknownUrlSchemePolicyStr : \"\"\"Return current unknown url scheme policy. Returns: Unknown url scheme policy \"\"\" return UNKNOWN_URL_SCHEME_POLICY . inverse [ self . item . unknownUrlSchemePolicy ()]","title":"get_unknown_url_scheme_policy()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_font_family","text":"Set the actual font family to family for the specified generic family, which. Parameters: Name Type Description Default which FontFamilyStr family to set required family str generic family required Exceptions: Type Description InvalidParamError Font family does not exist Source code in prettyqt/webenginecore/webenginesettings.py def set_font_family ( self , which : FontFamilyStr , family : str ): \"\"\"Set the actual font family to family for the specified generic family, which. Args: which: family to set family: generic family Raises: InvalidParamError: Font family does not exist \"\"\" if which not in FONT_FAMILY : raise InvalidParamError ( which , FONT_FAMILY ) self . item . setFontFamily ( FONT_FAMILY [ which ], family )","title":"set_font_family()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_font_size","text":"Set the font size for type to size in pixels. Parameters: Name Type Description Default typ FontSizeStr font size type required size int size in pixels required Exceptions: Type Description InvalidParamError Font size does not exist Source code in prettyqt/webenginecore/webenginesettings.py def set_font_size ( self , typ : FontSizeStr , size : int ): \"\"\"Set the font size for type to size in pixels. Args: typ: font size type size: size in pixels Raises: InvalidParamError: Font size does not exist \"\"\" if typ not in FONT_SIZE : raise InvalidParamError ( typ , FONT_SIZE ) self . item . setFontSize ( FONT_SIZE [ typ ], size )","title":"set_font_size()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_unknown_url_scheme_policy","text":"Set the unknown url scheme policy. Parameters: Name Type Description Default policy UnknownUrlSchemePolicyStr unknown url scheme policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginecore/webenginesettings.py def set_unknown_url_scheme_policy ( self , policy : UnknownUrlSchemePolicyStr ): \"\"\"Set the unknown url scheme policy. Args: policy: unknown url scheme policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in UNKNOWN_URL_SCHEME_POLICY : raise InvalidParamError ( policy , UNKNOWN_URL_SCHEME_POLICY ) self . item . setUnknownUrlSchemePolicy ( UNKNOWN_URL_SCHEME_POLICY [ policy ])","title":"set_unknown_url_scheme_policy()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme","text":"","title":"webengineurlscheme"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme","text":"Source code in prettyqt/webenginecore/webengineurlscheme.py class WebEngineUrlScheme ( QtWebEngineCore . QWebEngineUrlScheme ): def get_name ( self ) -> str : return bytes ( self . name ()) . decode () @classmethod def get_scheme_by_name ( cls , name : str ) -> WebEngineUrlScheme : scheme = cls . schemeByName ( QtCore . QByteArray ( name . encode ())) return cls ( scheme ) def set_name ( self , name : str ): self . setName ( QtCore . QByteArray ( name . encode ())) def set_syntax ( self , syntax : SyntaxStr ): \"\"\"Set syntax. Args: syntax: syntax to use Raises: InvalidParamError: syntax does not exist \"\"\" if syntax not in SYNTAX : raise InvalidParamError ( syntax , SYNTAX ) self . setSyntax ( SYNTAX [ syntax ]) def get_syntax ( self ) -> SyntaxStr : \"\"\"Return syntax. Returns: syntax \"\"\" return SYNTAX . inverse [ self . syntax ()]","title":"WebEngineUrlScheme"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.get_syntax","text":"Return syntax. Returns: Type Description SyntaxStr syntax Source code in prettyqt/webenginecore/webengineurlscheme.py def get_syntax ( self ) -> SyntaxStr : \"\"\"Return syntax. Returns: syntax \"\"\" return SYNTAX . inverse [ self . syntax ()]","title":"get_syntax()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.set_syntax","text":"Set syntax. Parameters: Name Type Description Default syntax SyntaxStr syntax to use required Exceptions: Type Description InvalidParamError syntax does not exist Source code in prettyqt/webenginecore/webengineurlscheme.py def set_syntax ( self , syntax : SyntaxStr ): \"\"\"Set syntax. Args: syntax: syntax to use Raises: InvalidParamError: syntax does not exist \"\"\" if syntax not in SYNTAX : raise InvalidParamError ( syntax , SYNTAX ) self . setSyntax ( SYNTAX [ syntax ])","title":"set_syntax()"},{"location":"api/webenginewidgets.html","text":"webenginewidgets module Webenginewidgets module. contains QtWebEngineWidgets-based classes webengineview WebEngineView ( QWebEngineView ) Source code in prettyqt/webenginewidgets/webengineview.py class WebEngineView ( QtWebEngineWidgets . QWebEngineView ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setPage ( webenginecore . WebEnginePage ( self )) def set_url ( self , url : types . UrlType | types . PathType ): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) def get_url ( self ) -> core . Url : return core . Url ( self . url ()) def load_url ( self , url : types . UrlType | types . PathType ): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom ) def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = webenginecore . WebEnginePage . FindFlag ( 0 ) if case_sensitive : flag |= webenginecore . WebEnginePage . FindFlag . FindCaseSensitively if backward : flag |= webenginecore . WebEnginePage . FindFlag . FindBackward self . findText ( string , flag , callback ) def get_settings ( self ) -> webenginecore . WebEngineSettings : settings = self . settings () return webenginecore . WebEngineSettings ( settings ) def set_setting ( self , setting_name : webenginecore . webenginesettings . WebAttributeStr , value : bool , ): self . get_settings ()[ setting_name ] = value def get_setting ( self , setting_name : webenginecore . webenginesettings . WebAttributeStr ) -> bool : return self . get_settings ()[ setting_name ] @classmethod def register_as_browser ( cls , tabwidget : widgets . TabWidget ): class BuiltInBrowser ( webbrowser . BaseBrowser ): def open ( self , url : str , new : int = 0 , autoraise : bool = True ): # logger.info(f\"opening {url} with builtin browser..\") webview = cls () webview . load_url ( url ) if new == 1 : webview . show () else : tabwidget . add_tab ( webview , str ( url ), show = autoraise ) webbrowser . register ( \"BuiltInBrowser\" , BuiltInBrowser ) find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] = None ) Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable[[bool], None] result callback None Source code in prettyqt/webenginewidgets/webengineview.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = webenginecore . WebEnginePage . FindFlag ( 0 ) if case_sensitive : flag |= webenginecore . WebEnginePage . FindFlag . FindCaseSensitively if backward : flag |= webenginecore . WebEnginePage . FindFlag . FindBackward self . findText ( string , flag , callback ) load_url ( self , url : types . UrlType | types . PathType ) Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url types.UrlType | types.PathType URL to load required Source code in prettyqt/webenginewidgets/webengineview.py def load_url ( self , url : types . UrlType | types . PathType ): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) set_url ( self , url : types . UrlType | types . PathType ) Set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url types.UrlType | types.PathType URL to set required Source code in prettyqt/webenginewidgets/webengineview.py def set_url ( self , url : types . UrlType | types . PathType ): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom : float ) Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"webenginewidgets"},{"location":"api/webenginewidgets.html#webenginewidgets-module","text":"Webenginewidgets module. contains QtWebEngineWidgets-based classes","title":"webenginewidgets module"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview","text":"","title":"webengineview"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView","text":"Source code in prettyqt/webenginewidgets/webengineview.py class WebEngineView ( QtWebEngineWidgets . QWebEngineView ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setPage ( webenginecore . WebEnginePage ( self )) def set_url ( self , url : types . UrlType | types . PathType ): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) def get_url ( self ) -> core . Url : return core . Url ( self . url ()) def load_url ( self , url : types . UrlType | types . PathType ): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom ) def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = webenginecore . WebEnginePage . FindFlag ( 0 ) if case_sensitive : flag |= webenginecore . WebEnginePage . FindFlag . FindCaseSensitively if backward : flag |= webenginecore . WebEnginePage . FindFlag . FindBackward self . findText ( string , flag , callback ) def get_settings ( self ) -> webenginecore . WebEngineSettings : settings = self . settings () return webenginecore . WebEngineSettings ( settings ) def set_setting ( self , setting_name : webenginecore . webenginesettings . WebAttributeStr , value : bool , ): self . get_settings ()[ setting_name ] = value def get_setting ( self , setting_name : webenginecore . webenginesettings . WebAttributeStr ) -> bool : return self . get_settings ()[ setting_name ] @classmethod def register_as_browser ( cls , tabwidget : widgets . TabWidget ): class BuiltInBrowser ( webbrowser . BaseBrowser ): def open ( self , url : str , new : int = 0 , autoraise : bool = True ): # logger.info(f\"opening {url} with builtin browser..\") webview = cls () webview . load_url ( url ) if new == 1 : webview . show () else : tabwidget . add_tab ( webview , str ( url ), show = autoraise ) webbrowser . register ( \"BuiltInBrowser\" , BuiltInBrowser )","title":"WebEngineView"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.find_text","text":"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable[[bool], None] result callback None Source code in prettyqt/webenginewidgets/webengineview.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = webenginecore . WebEnginePage . FindFlag ( 0 ) if case_sensitive : flag |= webenginecore . WebEnginePage . FindFlag . FindCaseSensitively if backward : flag |= webenginecore . WebEnginePage . FindFlag . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.load_url","text":"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url types.UrlType | types.PathType URL to load required Source code in prettyqt/webenginewidgets/webengineview.py def load_url ( self , url : types . UrlType | types . PathType ): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_url","text":"Set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url types.UrlType | types.PathType URL to set required Source code in prettyqt/webenginewidgets/webengineview.py def set_url ( self , url : types . UrlType | types . PathType ): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , os . PathLike ): url = core . Url . fromLocalFile ( os . fspath ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_zoom","text":"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/widgets.html","text":"widgets module widgets module. contains QtWidgets-based classes abstractbutton AbstractButton ( QAbstractButton ) Source code in prettyqt/widgets/abstractbutton.py class AbstractButton ( QtWidgets . QAbstractButton ): def serialize_fields ( self ): return dict ( text = self . text (), icon = self . get_icon (), checkable = self . isCheckable (), checked = self . isChecked (), auto_exclusive = self . autoExclusive (), auto_repeat = self . autoRepeat (), auto_repeat_delay = self . autoRepeatDelay (), auto_repeat_interval = self . autoRepeatInterval (), is_down = self . isDown (), icon_size = self . get_icon_size (), shortcut = self . get_shortcut (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setText ( state [ \"text\" ]) self . set_icon ( state [ \"icon\" ]) self . setChecked ( state . get ( \"checked\" , False )) self . setCheckable ( state [ \"checkable\" ]) self . setAutoExclusive ( state [ \"auto_exclusive\" ]) self . setAutoRepeat ( state [ \"auto_repeat\" ]) self . setAutoRepeatDelay ( state [ \"auto_repeat_delay\" ]) self . setAutoRepeatInterval ( state [ \"auto_repeat_interval\" ]) self . setDown ( state [ \"is_down\" ]) self . set_icon_size ( state [ \"icon_size\" ]) self . setShortcut ( state [ \"shortcut\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __bool__ ( self ): return self . isChecked () def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_style_icon ( self , icon : widgets . style . StandardPixmapStr , size : int = 15 ): \"\"\"Set theme icon for the button. Args: icon: icon to use size: icon size \"\"\" if icon not in widgets . style . STANDARD_PIXMAP : raise InvalidParamError ( icon , widgets . style . STANDARD_PIXMAP ) qicon = self . style () . standardIcon ( widgets . style . STANDARD_PIXMAP [ icon ], None , self ) self . set_icon ( qicon ) self . setIconSize ( core . Size ( size , size )) def set_shortcut ( self , shortcut : None | QtGui . QKeySequence | str ): if shortcut is None : shortcut = \"\" if isinstance ( shortcut , str ): shortcut = gui . KeySequence ( shortcut , gui . KeySequence . SequenceFormat . PortableText ) self . setShortcut ( shortcut ) def get_shortcut ( self ) -> gui . KeySequence : return gui . KeySequence ( self . shortcut () . toString (), gui . KeySequence . SequenceFormat . PortableText ) def set_text ( self , text : str ): self . setText ( text ) def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icon.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) def get_icon_size ( self ) -> core . Size : return core . Size ( self . iconSize ()) def get_value ( self ) -> bool : return self . isChecked () def set_value ( self , value : bool ): self . setChecked ( value ) @property def is_on ( self ) -> bool : return self . isChecked () @is_on . setter def is_on ( self , state : bool ): self . setChecked ( state ) set_icon ( self , icon : types . IconType ) Set the icon for the button. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/abstractbutton.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) set_icon_size ( self , size : int | types . SizeType ) Set size of the icon. Source code in prettyqt/widgets/abstractbutton.py def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icon.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) set_style_icon ( self , icon : widgets . style . StandardPixmapStr , size : int = 15 ) Set theme icon for the button. Parameters: Name Type Description Default icon widgets.style.StandardPixmapStr icon to use required size int icon size 15 Source code in prettyqt/widgets/abstractbutton.py def set_style_icon ( self , icon : widgets . style . StandardPixmapStr , size : int = 15 ): \"\"\"Set theme icon for the button. Args: icon: icon to use size: icon size \"\"\" if icon not in widgets . style . STANDARD_PIXMAP : raise InvalidParamError ( icon , widgets . style . STANDARD_PIXMAP ) qicon = self . style () . standardIcon ( widgets . style . STANDARD_PIXMAP [ icon ], None , self ) self . set_icon ( qicon ) self . setIconSize ( core . Size ( size , size )) abstractitemview AbstractItemView ( QAbstractItemView ) Source code in prettyqt/widgets/abstractitemview.py class AbstractItemView ( QtWidgets . QAbstractItemView ): def __len__ ( self ) -> int : if self . model () is not None : return self . model () . rowCount () return 0 def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return super () . selectAll () def set_model ( self , model : QtCore . QAbstractItemModel | None ): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # type: ignore # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model def set_delegate ( self , delegate : QtWidgets . QItemDelegate , column : int | None = None , row : int | None = None , persistent : bool = False , ): if column is not None : self . setItemDelegateForColumn ( column , delegate ) if persistent : model = self . model () for i in range ( 0 , model . rowCount ()): self . openPersistentEditor ( model . index ( i , column )) elif row is not None : self . setItemDelegateForRow ( row , delegate ) if persistent : model = self . model () for i in range ( 0 , model . columnCount ()): self . openPersistentEditor ( model . index ( row , i )) else : self . setItemDelegate ( delegate ) def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll () def set_table_color ( self , color : str ): with self . edit_stylesheet () as ss : ss . QHeaderView . section . backgroundColor . setValue ( color ) def current_index ( self ) -> QtCore . QModelIndex | None : if self . selectionModel () is None : return None return self . selectionModel () . currentIndex () def current_data ( self ): if self . selectionModel () is None : return None idx = self . selectionModel () . currentIndex () return idx . data ( constants . USER_ROLE ) # type: ignore def current_row ( self ) -> int | None : if self . selectionModel () is None : return None return self . selectionModel () . currentIndex () . row () def current_column ( self ) -> int | None : if self . selectionModel () is None : return None return self . selectionModel () . currentIndex () . column () def selected_indexes ( self ) -> list [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) # type: ignore return sorted ( indexes , key = lambda x : x . row ()) # type: ignore def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ()) def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ()) def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes () # type: ignore ) def setup_dragdrop_move ( self ): self . setDragEnabled ( True ) self . setAcceptDrops ( True ) self . setDragDropMode ( self . DragDropMode . DragDrop ) self . setDefaultDropAction ( constants . MOVE_ACTION ) self . setDropIndicatorShown ( True ) def set_edit_triggers ( self , * triggers : EditTriggerStr | None ): items = [ \"none\" if t is None else t for t in triggers ] for item in items : if item not in EDIT_TRIGGERS : raise InvalidParamError ( item , EDIT_TRIGGERS ) flags = helpers . merge_flags ( items , EDIT_TRIGGERS ) self . setEditTriggers ( flags ) def get_edit_triggers ( self ) -> list [ EditTriggerStr ]: return [ k for k , v in EDIT_TRIGGERS . items () if v & self . editTriggers ()] def set_selection_behaviour ( self , behaviour : SelectionBehaviourStr ): \"\"\"Set selection behaviour for given item view. Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOUR : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOUR ) self . setSelectionBehavior ( SELECTION_BEHAVIOUR [ behaviour ]) def get_selection_behaviour ( self ) -> SelectionBehaviourStr : \"\"\"Return current selection behaviour. Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOUR . inverse [ self . selectionBehavior ()] def set_drag_drop_mode ( self , mode : DragDropModeStr ): \"\"\"Set drag-drop mode for given item view. Args: mode: drag-drop mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_DROP_MODE : raise InvalidParamError ( mode , DRAG_DROP_MODE ) self . setDragDropMode ( DRAG_DROP_MODE [ mode ]) def get_drag_drop_mode ( self ) -> DragDropModeStr : \"\"\"Return current drag-drop mode. Returns: drag-drop mode \"\"\" return DRAG_DROP_MODE . inverse [ self . dragDropMode ()] def set_selection_mode ( self , mode : SelectionModeStr | None ): \"\"\"Set selection mode for given item view. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ]) def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()] def set_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the scroll mode for both directions. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) self . setVerticalScrollMode ( SCROLL_MODE [ mode ]) def set_horizontal_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the horizontal scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) def set_vertical_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the vertical scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setVerticalScrollMode ( SCROLL_MODE [ mode ]) def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ()) def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx ) def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop () def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom () def select_last_row ( self ): idx = self . model () . createIndex ( self . model () . rowCount () - 1 , 0 ) self . setCurrentIndex ( idx ) def scroll_to ( self , index , mode : ScrollHintStr = \"ensure_visible\" ): if mode not in SCROLL_HINT : raise InvalidParamError ( mode , SCROLL_HINT ) self . scrollTo ( index , SCROLL_HINT [ mode ]) def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p ) def set_icon_size ( self , size : int | types . SizeType ): if isinstance ( size , tuple ): size = QtCore . QSize ( * size ) elif isinstance ( size , int ): size = QtCore . QSize ( size , size ) self . setIconSize ( size ) get_drag_drop_mode ( self ) -> DragDropModeStr Return current drag-drop mode. Returns: Type Description DragDropModeStr drag-drop mode Source code in prettyqt/widgets/abstractitemview.py def get_drag_drop_mode ( self ) -> DragDropModeStr : \"\"\"Return current drag-drop mode. Returns: drag-drop mode \"\"\" return DRAG_DROP_MODE . inverse [ self . dragDropMode ()] get_selection_behaviour ( self ) -> SelectionBehaviourStr Return current selection behaviour. Returns: Type Description SelectionBehaviourStr selection behaviour Source code in prettyqt/widgets/abstractitemview.py def get_selection_behaviour ( self ) -> SelectionBehaviourStr : \"\"\"Return current selection behaviour. Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOUR . inverse [ self . selectionBehavior ()] get_selection_mode ( self ) -> SelectionModeStr Return current selection mode. Returns: Type Description SelectionModeStr selection mode Source code in prettyqt/widgets/abstractitemview.py def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()] highlight_when_inactive ( self ) Highlight items when widget does not have focus. Source code in prettyqt/widgets/abstractitemview.py def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p ) jump_to_column ( self , col_num : int ) Make sure column at given index is visible. scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx ) num_selected ( self ) -> int Return amount of selected rows. Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ()) scroll_to_bottom ( self ) Override to use abstractitemview-way of scrolling to bottom. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom () scroll_to_top ( self ) Override to use abstractitemview-way of scrolling to top. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop () selectAll ( self ) Override, we dont want to selectAll for too many items bc of performance. Source code in prettyqt/widgets/abstractitemview.py def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return super () . selectAll () selected_data ( self ) -> Generator [ Any , None , None ] Returns generator yielding selected userData. Source code in prettyqt/widgets/abstractitemview.py def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes () # type: ignore ) selected_indexes ( self ) -> list [ QtCore . QModelIndex ] Returns list of selected indexes in first row. Source code in prettyqt/widgets/abstractitemview.py def selected_indexes ( self ) -> list [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) # type: ignore return sorted ( indexes , key = lambda x : x . row ()) # type: ignore selected_names ( self ) -> Generator [ Any , None , None ] Returns generator yielding item names. Source code in prettyqt/widgets/abstractitemview.py def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ()) selected_rows ( self ) -> Generator [ int , None , None ] Returns generator yielding row nums. Source code in prettyqt/widgets/abstractitemview.py def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ()) set_drag_drop_mode ( self , mode : DragDropModeStr ) Set drag-drop mode for given item view. Parameters: Name Type Description Default mode DragDropModeStr drag-drop mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_drag_drop_mode ( self , mode : DragDropModeStr ): \"\"\"Set drag-drop mode for given item view. Args: mode: drag-drop mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_DROP_MODE : raise InvalidParamError ( mode , DRAG_DROP_MODE ) self . setDragDropMode ( DRAG_DROP_MODE [ mode ]) set_horizontal_scroll_mode ( self , mode : ScrollModeStr ) Set the horizontal scroll mode. Parameters: Name Type Description Default mode ScrollModeStr mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_horizontal_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the horizontal scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) set_model ( self , model : QtCore . QAbstractItemModel | None ) Delete old selection model explicitely, seems to help with memory usage. Source code in prettyqt/widgets/abstractitemview.py def set_model ( self , model : QtCore . QAbstractItemModel | None ): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # type: ignore # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model set_scroll_mode ( self , mode : ScrollModeStr ) Set the scroll mode for both directions. Parameters: Name Type Description Default mode ScrollModeStr mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the scroll mode for both directions. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) self . setVerticalScrollMode ( SCROLL_MODE [ mode ]) set_selection_behaviour ( self , behaviour : SelectionBehaviourStr ) Set selection behaviour for given item view. Parameters: Name Type Description Default behaviour SelectionBehaviourStr selection behaviour to use required Exceptions: Type Description InvalidParamError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_behaviour ( self , behaviour : SelectionBehaviourStr ): \"\"\"Set selection behaviour for given item view. Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOUR : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOUR ) self . setSelectionBehavior ( SELECTION_BEHAVIOUR [ behaviour ]) set_selection_mode ( self , mode : SelectionModeStr | None ) Set selection mode for given item view. Parameters: Name Type Description Default mode SelectionModeStr | None selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_mode ( self , mode : SelectionModeStr | None ): \"\"\"Set selection mode for given item view. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ]) set_vertical_scroll_mode ( self , mode : ScrollModeStr ) Set the vertical scroll mode. Parameters: Name Type Description Default mode ScrollModeStr mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_vertical_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the vertical scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setVerticalScrollMode ( SCROLL_MODE [ mode ]) toggle_select_all ( self ) Select all items from list (deselect when all selected). Source code in prettyqt/widgets/abstractitemview.py def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll () abstractscrollarea AbstractScrollArea ( QAbstractScrollArea ) Source code in prettyqt/widgets/abstractscrollarea.py class AbstractScrollArea ( QtWidgets . QAbstractScrollArea ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setHorizontalScrollBar ( widgets . ScrollBar ( parent = self )) self . setVerticalScrollBar ( widgets . ScrollBar ( parent = self )) def serialize_fields ( self ): return dict ( size_adjust_policy = self . get_size_adjust_policy (), horizontal_scrollbar_policy = self . get_horizontal_scrollbar_policy (), vertical_scrollbar_policy = self . get_vertical_scrollbar_policy (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_size_adjust_policy ( state [ \"size_adjust_policy\" ]) self . set_horizontal_scrollbar_policy ( state [ \"horizontal_scrollbar_policy\" ]) self . set_vertical_scrollbar_policy ( state [ \"vertical_scrollbar_policy\" ]) @property def h_scrollbar ( self ): return self . horizontalScrollBar () @h_scrollbar . setter def h_scrollbar ( self , scrollbar ): self . setHorizontalScrollBar ( scrollbar ) @property def v_scrollbar ( self ): return self . verticalScrollBar () @v_scrollbar . setter def v_scrollbar ( self , scrollbar ): self . setVerticalScrollBar ( scrollbar ) def set_size_adjust_policy ( self , policy : SizePolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICY : raise InvalidParamError ( policy , SIZE_POLICY ) self . setSizeAdjustPolicy ( SIZE_POLICY [ policy ]) def get_size_adjust_policy ( self ) -> SizePolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_POLICY . inverse [ self . sizeAdjustPolicy ()] def set_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the policy for both scrollbars. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) def set_horizontal_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the horizontal scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) def get_horizontal_scrollbar_policy ( self ): return constants . SCROLLBAR_POLICY . inverse [ self . horizontalScrollBarPolicy ()] def set_vertical_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the vertical scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) def get_vertical_scrollbar_policy ( self ): return constants . SCROLLBAR_POLICY . inverse [ self . verticalScrollBarPolicy ()] def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width ) def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min () def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max () get_size_adjust_policy ( self ) -> SizePolicyStr Return size adjust policy. Returns: Type Description SizePolicyStr size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def get_size_adjust_policy ( self ) -> SizePolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_POLICY . inverse [ self . sizeAdjustPolicy ()] scroll_to_bottom ( self ) Scroll to the bottom of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max () scroll_to_top ( self ) Scroll to the top of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min () set_horizontal_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ) Set the horizontal scrollbar visibility. Parameters: Name Type Description Default mode constants.ScrollBarPolicyStr visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the horizontal scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) set_horizontal_scrollbar_width ( self , width : int ) Set the horizontal scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) set_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ) Set the policy for both scrollbars. Parameters: Name Type Description Default mode constants.ScrollBarPolicyStr visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the policy for both scrollbars. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) set_scrollbar_width ( self , width : int ) Set the width for both scrollbars. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width ) set_size_adjust_policy ( self , policy : SizePolicyStr ) Set size adjust policy. Parameters: Name Type Description Default policy SizePolicyStr size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def set_size_adjust_policy ( self , policy : SizePolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICY : raise InvalidParamError ( policy , SIZE_POLICY ) self . setSizeAdjustPolicy ( SIZE_POLICY [ policy ]) set_vertical_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ) Set the vertical scrollbar visibility. Parameters: Name Type Description Default mode constants.ScrollBarPolicyStr visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the vertical scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) set_vertical_scrollbar_width ( self , width : int ) Set the vertical scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) abstractslider AbstractSlider ( QAbstractSlider ) Source code in prettyqt/widgets/abstractslider.py class AbstractSlider ( QtWidgets . QAbstractSlider ): value_changed = core . Signal ( int ) def on_value_change ( self ): self . value_changed . emit ( self . value ()) def serialize_fields ( self ): return dict ( range = ( self . minimum (), self . maximum ()), value = self . value (), has_tracking = self . hasTracking (), inverted_controls = self . invertedControls (), inverted_appearance = self . invertedAppearance (), single_step = self . singleStep (), page_step = self . pageStep (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_range ( * state [ \"range\" ]) self . set_value ( state [ \"value\" ]) self . setSingleStep ( state [ \"single_step\" ]) self . setPageStep ( state [ \"page_step\" ]) self . setTracking ( state [ \"has_tracking\" ]) self . setInvertedControls ( state [ \"inverted_controls\" ]) self . setInvertedAppearance ( state [ \"inverted_appearance\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == constants . HORIZONTAL def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == constants . VERTICAL def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( constants . HORIZONTAL ) def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( constants . VERTICAL ) def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the slider. Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ()) def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ()) def set_range ( self , min_val : int , max_val : int ): self . setRange ( min_val , max_val ) def set_step_size ( self , step_size : int ): self . setSingleStep ( step_size ) def set_repeat_action ( self , action : SliderActionStr , threshold : int = 500 , repeat_time : int = 50 ): \"\"\"Set the repeat action. Args: action: repeat action Raises: InvalidParamError: invalid repeat action \"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . setRepeatAction ( SLIDER_ACTION [ action ], threshold , repeat_time ) def get_repeat_action ( self ) -> SliderActionStr : \"\"\"Get current repeat action. Returns: current repeat action \"\"\" return SLIDER_ACTION . inverse [ self . repeatAction ()] def trigger_action ( self , action : SliderActionStr ): \"\"\"Trigger slider action.\"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . triggerAction ( SLIDER_ACTION [ action ]) def get_value ( self ): return self . value () def set_value ( self , value : int ): self . setValue ( value ) def on_scrollbar_range_changed ( self , minval , maxval ): if self . value () >= self . maximum () - 1 : self . setValue ( maxval ) def set_auto_scroll_to_end ( self , scroll : bool = True ): \"\"\"Set to always scroll to the end when range changes.\"\"\" if scroll : self . rangeChanged . connect ( self . on_scrollbar_range_changed ) else : self . rangeChanged . disconnect ( self . on_scrollbar_range_changed ) get_orientation ( self ) -> constants . OrientationStr Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/abstractslider.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] get_repeat_action ( self ) -> SliderActionStr Get current repeat action. Returns: Type Description SliderActionStr current repeat action Source code in prettyqt/widgets/abstractslider.py def get_repeat_action ( self ) -> SliderActionStr : \"\"\"Get current repeat action. Returns: current repeat action \"\"\" return SLIDER_ACTION . inverse [ self . repeatAction ()] is_horizontal ( self ) -> bool Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == constants . HORIZONTAL is_vertical ( self ) -> bool Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == constants . VERTICAL scroll_to_max ( self ) Scroll to the maximum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ()) scroll_to_min ( self ) Scroll to the minimum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ()) set_auto_scroll_to_end ( self , scroll : bool = True ) Set to always scroll to the end when range changes. Source code in prettyqt/widgets/abstractslider.py def set_auto_scroll_to_end ( self , scroll : bool = True ): \"\"\"Set to always scroll to the end when range changes.\"\"\" if scroll : self . rangeChanged . connect ( self . on_scrollbar_range_changed ) else : self . rangeChanged . disconnect ( self . on_scrollbar_range_changed ) set_horizontal ( self ) Set slider orientation to horizontal. Source code in prettyqt/widgets/abstractslider.py def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( constants . HORIZONTAL ) set_orientation ( self , orientation : constants . OrientationStr ) Set the orientation of the slider. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the slider required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/abstractslider.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the slider. Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) set_repeat_action ( self , action : SliderActionStr , threshold : int = 500 , repeat_time : int = 50 ) Set the repeat action. Parameters: Name Type Description Default action SliderActionStr repeat action required Exceptions: Type Description InvalidParamError invalid repeat action Source code in prettyqt/widgets/abstractslider.py def set_repeat_action ( self , action : SliderActionStr , threshold : int = 500 , repeat_time : int = 50 ): \"\"\"Set the repeat action. Args: action: repeat action Raises: InvalidParamError: invalid repeat action \"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . setRepeatAction ( SLIDER_ACTION [ action ], threshold , repeat_time ) set_vertical ( self ) Set slider orientation to vertical. Source code in prettyqt/widgets/abstractslider.py def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( constants . VERTICAL ) trigger_action ( self , action : SliderActionStr ) Trigger slider action. Source code in prettyqt/widgets/abstractslider.py def trigger_action ( self , action : SliderActionStr ): \"\"\"Trigger slider action.\"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . triggerAction ( SLIDER_ACTION [ action ]) abstractspinbox AbstractSpinBox ( QAbstractSpinBox ) Source code in prettyqt/widgets/abstractspinbox.py class AbstractSpinBox ( QtWidgets . QAbstractSpinBox ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setLineEdit ( widgets . LineEdit ()) self . setGroupSeparatorShown ( True ) def serialize_fields ( self ): return dict ( button_symbols = self . get_button_symbols (), correction_mode = self . get_correction_mode (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_correction_mode ( state [ \"correction_mode\" ]) self . set_button_symbols ( state [ \"button_symbols\" ]) def is_valid ( self ) -> bool : return self . hasAcceptableInput () def set_validator ( self , validator : gui . Validator ): self . lineEdit () . setValidator ( validator ) def get_button_symbols ( self ) -> SymbolStr : \"\"\"Return button symbol type. Returns: button symbol type \"\"\" return SYMBOLS . inverse [ self . buttonSymbols ()] def set_button_symbols ( self , mode : SymbolStr ): \"\"\"Set button symbol type. Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ]) def set_correction_mode ( self , mode : CorrectionModeStr ): \"\"\"Set correction mode. Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ]) def get_correction_mode ( self ) -> CorrectionModeStr : \"\"\"Return correction mode. Returns: correction mode \"\"\" return CORRECTION_MODES . inverse [ self . correctionMode ()] def set_step_type ( self , mode : StepTypeStr ): \"\"\"Set step type. Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ]) def get_step_type ( self ) -> StepTypeStr : \"\"\"Return step type. Returns: step type \"\"\" return STEP_TYPES . inverse [ self . stepType ()] def set_special_value ( self , value : str ): self . setSpecialValueText ( value ) def get_value ( self ) -> int : return self . value () def set_value ( self , value : int ): self . setValue ( value ) get_button_symbols ( self ) -> SymbolStr Return button symbol type. Returns: Type Description SymbolStr button symbol type Source code in prettyqt/widgets/abstractspinbox.py def get_button_symbols ( self ) -> SymbolStr : \"\"\"Return button symbol type. Returns: button symbol type \"\"\" return SYMBOLS . inverse [ self . buttonSymbols ()] get_correction_mode ( self ) -> CorrectionModeStr Return correction mode. Returns: Type Description CorrectionModeStr correction mode Source code in prettyqt/widgets/abstractspinbox.py def get_correction_mode ( self ) -> CorrectionModeStr : \"\"\"Return correction mode. Returns: correction mode \"\"\" return CORRECTION_MODES . inverse [ self . correctionMode ()] get_step_type ( self ) -> StepTypeStr Return step type. Returns: Type Description StepTypeStr step type Source code in prettyqt/widgets/abstractspinbox.py def get_step_type ( self ) -> StepTypeStr : \"\"\"Return step type. Returns: step type \"\"\" return STEP_TYPES . inverse [ self . stepType ()] set_button_symbols ( self , mode : SymbolStr ) Set button symbol type. Parameters: Name Type Description Default mode SymbolStr button symbol type to use required Exceptions: Type Description InvalidParamError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py def set_button_symbols ( self , mode : SymbolStr ): \"\"\"Set button symbol type. Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ]) set_correction_mode ( self , mode : CorrectionModeStr ) Set correction mode. Parameters: Name Type Description Default mode CorrectionModeStr correction mode to use required Exceptions: Type Description InvalidParamError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py def set_correction_mode ( self , mode : CorrectionModeStr ): \"\"\"Set correction mode. Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ]) set_step_type ( self , mode : StepTypeStr ) Set step type. Parameters: Name Type Description Default mode StepTypeStr step type to use required Exceptions: Type Description InvalidParamError invalid step type Source code in prettyqt/widgets/abstractspinbox.py def set_step_type ( self , mode : StepTypeStr ): \"\"\"Set step type. Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ]) action Action ( PrettyPrinter , QAction ) Source code in prettyqt/widgets/action.py class Action ( prettyprinter . PrettyPrinter , QtWidgets . QAction ): def __init__ ( self , parent : QtCore . QObject | None = None , text : str = \"\" , icon : types . IconType = None , shortcut : str | None = None , tooltip : str = \"\" , checkable : bool = False , checked : bool = False , statustip : str = \"\" , enabled : bool = True , callback : Callable | None = None , ): super () . __init__ ( parent ) self . _menu = None self . set_text ( text ) self . set_icon ( icon ) self . set_shortcut ( shortcut ) self . set_tooltip ( tooltip ) self . set_checkable ( checkable ) self . set_checked ( checked ) self . set_statustip ( statustip ) self . set_enabled ( enabled ) if callback is not None : self . triggered . connect ( callback ) def __repr__ ( self ) -> str : cls_name = type ( self ) . __name__ return f \" { cls_name } ( { helpers . format_kwargs ( self . serialize_fields ()) } )\" def serialize_fields ( self ): dct = dict ( auto_repeat = self . autoRepeat (), text = self . text (), enabled = self . isEnabled (), visible = self . isVisible (), font = self . get_font (), shortcut = self . get_shortcut (), tool_tip = self . toolTip (), checkable = self . isCheckable (), checked = self . isChecked (), icon = self . get_icon (), icon_text = self . iconText (), priority = self . get_priority (), icon_visible_in_menu = self . isIconVisibleInMenu (), shortcut_visible_in_context_menu = self . isShortcutVisibleInContextMenu (), menu_role = self . get_menu_role (), shortcut_context = self . get_shortcut_context (), status_tip = self . statusTip (), whats_this = self . whatsThis (), ) if core . VersionNumber . get_qt_version () < ( 6 , 0 , 0 ): dct [ \"menu\" ] = self . menu () return dct def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_text ( state . get ( \"text\" , \"\" )) self . set_enabled ( state . get ( \"enabled\" , True )) self . set_shortcut ( state [ \"shortcut\" ]) self . set_tooltip ( state . get ( \"tool_tip\" , \"\" )) self . set_statustip ( state . get ( \"status_tip\" , \"\" )) self . set_checked ( state . get ( \"checked\" , False )) self . set_priority ( state [ \"priority\" ]) self . set_shortcut_context ( state [ \"shortcut_context\" ]) self . set_checkable ( state [ \"checkable\" ]) self . setAutoRepeat ( state [ \"auto_repeat\" ]) self . setVisible ( state [ \"visible\" ]) self . setFont ( state [ \"font\" ]) # self.setIcon(state[\"icon\"]) self . setIconText ( state [ \"icon_text\" ]) self . setIconVisibleInMenu ( state [ \"icon_visible_in_menu\" ]) self . setShortcutVisibleInContextMenu ( state [ \"shortcut_visible_in_context_menu\" ]) self . set_menu_role ( state [ \"menu_role\" ]) self . setWhatsThis ( state [ \"whats_this\" ]) # if core.VersionNumber.get_qt_version() < (6, 0, 0): # self.setMenu(state[\"menu\"]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def set_text ( self , text : str ): self . setText ( text ) def set_enabled ( self , enabled : bool = True ): self . setEnabled ( enabled ) def set_disabled ( self ): self . setEnabled ( False ) def set_tooltip ( self , tooltip : str | types . PathType , size : types . SizeType | None = None , ): if isinstance ( tooltip , os . PathLike ): path = os . fspath ( tooltip ) if size is None : tooltip = f \"<img src= { path !r} >\" else : if isinstance ( size , QtCore . QSize ): size = ( size . width (), size . height ()) tooltip = f '<img src= { path !r} width=\" { size [ 0 ] } \" height=\" { size [ 1 ] } \">' self . setToolTip ( tooltip ) def set_statustip ( self , text : str ): self . setStatusTip ( text ) def set_checked ( self , value : bool ): self . setChecked ( value ) def set_checkable ( self , value : bool ): self . setCheckable ( value ) def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_shortcut ( self , shortcut : None | QtGui . QKeySequence | str ): if shortcut is None : shortcut = \"\" if isinstance ( shortcut , str ): shortcut = gui . KeySequence ( shortcut , gui . KeySequence . SequenceFormat . PortableText ) self . setShortcut ( shortcut ) def get_shortcut ( self ) -> gui . KeySequence | None : shortcut = self . shortcut () if not shortcut : return None return gui . KeySequence ( shortcut . toString (), gui . KeySequence . SequenceFormat . PortableText ) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def set_menu ( self , menu ): try : self . setMenu ( menu ) except AttributeError : self . triggered . connect ( menu . exec_ ) self . _menu = menu def menu ( self ): return self . _menu def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority of the action. Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ]) def get_priority ( self ) -> PriorityStr : \"\"\"Return current priority. Returns: priority \"\"\" return PRIORITIES . inverse [ self . priority ()] def set_shortcut_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setShortcutContext ( constants . CONTEXT [ context ]) def get_shortcut_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . shortcutContext ()] def set_menu_role ( self , role : RoleStr ): \"\"\"Set menu role. Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ]) def get_menu_role ( self ) -> RoleStr : \"\"\"Return menu role. Returns: menu role \"\"\" return ROLES . inverse [ self . menuRole ()] def show_shortcut_in_contextmenu ( self , state : bool = True ): self . setShortcutVisibleInContextMenu ( state ) get_menu_role ( self ) -> RoleStr Return menu role. Returns: Type Description RoleStr menu role Source code in prettyqt/widgets/action.py def get_menu_role ( self ) -> RoleStr : \"\"\"Return menu role. Returns: menu role \"\"\" return ROLES . inverse [ self . menuRole ()] get_priority ( self ) -> PriorityStr Return current priority. Returns: Type Description PriorityStr priority Source code in prettyqt/widgets/action.py def get_priority ( self ) -> PriorityStr : \"\"\"Return current priority. Returns: priority \"\"\" return PRIORITIES . inverse [ self . priority ()] get_shortcut_context ( self ) -> constants . ContextStr Return shortcut context. Returns: Type Description constants.ContextStr shortcut context Source code in prettyqt/widgets/action.py def get_shortcut_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . shortcutContext ()] menu ( self ) menu(self) -> PySide6.QtCore.QObject Source code in prettyqt/widgets/action.py def menu ( self ): return self . _menu set_icon ( self , icon : types . IconType ) Set the icon for the action. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/action.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) set_menu_role ( self , role : RoleStr ) Set menu role. Parameters: Name Type Description Default role RoleStr menu role required Exceptions: Type Description InvalidParamError menu role does not exist Source code in prettyqt/widgets/action.py def set_menu_role ( self , role : RoleStr ): \"\"\"Set menu role. Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ]) set_priority ( self , priority : PriorityStr ) Set priority of the action. Parameters: Name Type Description Default priority PriorityStr priority for the action required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/widgets/action.py def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority of the action. Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ]) set_shortcut_context ( self , context : constants . ContextStr ) Set shortcut context. Parameters: Name Type Description Default context constants.ContextStr shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/action.py def set_shortcut_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setShortcutContext ( constants . CONTEXT [ context ]) actiongroup ActionGroup ( QActionGroup ) Source code in prettyqt/widgets/actiongroup.py class ActionGroup ( QtWidgets . QActionGroup ): def __init__ ( self , parent : QtCore . QObject | None = None ): super () . __init__ ( parent ) # type: ignore def __len__ ( self ) -> int : return len ( self . actions ()) def __getitem__ ( self , item : int ) -> QtWidgets . QAction : return self . actions ()[ item ] def serialize_fields ( self ): return dict ( exclusion_policy = self . get_exclusion_policy (), visible = self . isVisible (), enabled = self . isEnabled (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setEnabled ( state . get ( \"enabled\" , \"\" )) self . setVisible ( state . get ( \"visible\" , \"\" )) self . set_exclusion_policy ( state . get ( \"exclusion_policy\" , \"\" )) def set_exclusion_policy ( self , policy : ExclusionPolicyStr | None ): \"\"\"Set exclusion policy to use. Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ]) def get_exclusion_policy ( self ) -> ExclusionPolicyStr : \"\"\"Return current exclusion policy. Returns: exclusion policy \"\"\" return POLICIES . inverse [ self . exclusionPolicy ()] get_exclusion_policy ( self ) -> ExclusionPolicyStr Return current exclusion policy. Returns: Type Description ExclusionPolicyStr exclusion policy Source code in prettyqt/widgets/actiongroup.py def get_exclusion_policy ( self ) -> ExclusionPolicyStr : \"\"\"Return current exclusion policy. Returns: exclusion policy \"\"\" return POLICIES . inverse [ self . exclusionPolicy ()] set_exclusion_policy ( self , policy : ExclusionPolicyStr | None ) Set exclusion policy to use. Parameters: Name Type Description Default policy ExclusionPolicyStr | None exclusion policy to use required Exceptions: Type Description InvalidParamError exclusion policy does not exist Source code in prettyqt/widgets/actiongroup.py def set_exclusion_policy ( self , policy : ExclusionPolicyStr | None ): \"\"\"Set exclusion policy to use. Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ]) application Application ( QApplication ) Source code in prettyqt/widgets/application.py class Application ( QtWidgets . QApplication ): def __class_getitem__ ( cls , name : str ) -> QtWidgets . QWidget : widget = cls . get_widget ( name ) if widget is None : raise ValueError ( f \"Widget { name !r} does not exist.\" ) return widget def __iter__ ( self ) -> Iterator [ QtWidgets . QWidget ]: return iter ( self . topLevelWidgets ()) def serialize_fields ( self ): return dict ( auto_sip_enabled = self . autoSipEnabled (), cursor_flash_time = self . cursorFlashTime (), double_click_interval = self . doubleClickInterval (), keyboard_input_interval = self . keyboardInputInterval (), start_drag_distance = self . startDragDistance (), start_drag_time = self . startDragTime (), style_sheet = self . styleSheet (), wheel_scroll_lines = self . wheelScrollLines (), ) def store_widget_states ( self , settings : MutableMapping | None = None , key : str = \"states\" ): settings = core . Settings () if settings is None else settings result = {} for k , v in SAVE_STATES . items (): result [ k ] = { i . objectName (): i . saveState () for i in self . find_children ( v ) if i . objectName () } settings [ key ] = result def restore_widget_states ( self , settings : Mapping | None = None , key : str = \"states\" ): settings = core . Settings () if settings is None else settings for category , v in SAVE_STATES . items (): items = settings [ key ] . get ( category ) if items is None : continue for name , state in items . items (): w = self . find_child ( v , name = name ) if w is not None : if isinstance ( state , str ): state = state . encode () w . restoreState ( state ) def about_popup ( self , title : str = \"About\" ): text = ( f \" { self . applicationName () } \\n\\n \" f \" { self . organizationName () } \\n \" f \" { self . applicationVersion () } \\n \" f \" { self . organizationDomain () } \" ) popup = widgets . MessageBox ( \"none\" , title , text , buttons = [ \"ok\" ], ) popup . set_icon ( \"mdi.information-outline\" ) popup . exec_ () @classmethod def get_mainwindow ( cls ) -> QtWidgets . QMainWindow | None : inst = cls . instance () if inst is None : return None widget_list = inst . topLevelWidgets () for widget in widget_list : if isinstance ( widget , QtWidgets . QMainWindow ): return widget return None @classmethod def get_widget ( cls , name : str ) -> QtWidgets . QWidget | None : mw = cls . get_mainwindow () if mw is None : logger . warning ( \"Trying to get widget from nonexistent mainwindow\" ) return None return mw . findChild ( QtWidgets . QWidget , name ) # type: ignore # widget_list = cls.instance().allWidgets() # for widget in widget_list: # if isinstance(widget, QtWidgets.QWidget) and widget.objectName() == name: # return widget # return None @contextlib . contextmanager def edit_stylesheet ( self ) -> Iterator [ qstylizer . style . StyleSheet ]: ss = self . get_stylesheet () yield ss self . set_stylesheet ( ss ) def set_stylesheet ( self , ss : None | str | qstylizer . style . StyleSheet | types . PathType ): if isinstance ( ss , os . PathLike ): ss = pathlib . Path ( ss ) . read_text () elif ss is None : ss = \"\" self . setStyleSheet ( str ( ss )) def get_stylesheet ( self ) -> qstylizer . style . StyleSheet : return qstylizer . parser . parse ( self . styleSheet ()) def set_theme ( self , theme : constants . ThemeStr ): self . set_palette ( theme ) if theme == \"default\" : self . set_stylesheet ( \"\" ) iconprovider . set_defaults ( color = \"black\" ) elif theme == \"dark\" : ss = ( paths . THEMES_PATH / \"darktheme.qss\" ) . read_text () self . set_stylesheet ( ss ) iconprovider . set_defaults ( color = \"lightblue\" ) @classmethod def get_available_themes ( cls ) -> dict [ constants . ThemeStr , str ]: return dict ( default = \"Default\" , dark = \"Dark\" ) def send_event ( self , obj_or_str : str | QtCore . QObject , event : QtCore . QEvent ): obj = self . get_widget ( obj_or_str ) if isinstance ( obj_or_str , str ) else obj_or_str if obj is None : raise ValueError ( obj ) return self . sendEvent ( obj , event ) def post_event ( self , obj_or_str : str | QtCore . QObject , event : QtCore . QEvent , priority : int | constants . EventPriorityStr = \"normal\" , ): obj = self . get_widget ( obj_or_str ) if isinstance ( obj_or_str , str ) else obj_or_str if obj is None : raise ValueError ( obj ) super () . post_event ( obj , event , priority ) @classmethod def get_style_icon ( cls , icon : widgets . style . StandardPixmapStr ) -> gui . Icon : style = cls . style () # icon_size = style.pixelMetric(QtWidgets.QStyle.PM_MessageBoxIconSize) if icon not in widgets . style . STANDARD_PIXMAP : raise InvalidParamError ( icon , widgets . style . STANDARD_PIXMAP ) icon = style . standardIcon ( widgets . style . STANDARD_PIXMAP [ icon ]) return gui . Icon ( icon ) def set_effect_enabled ( self , effect : constants . UiEffectStr , enabled : bool = True ): \"\"\"Set the enabled state of a desktop effect. Args: effect: desktop effect to set enabled: new state Raises: InvalidParamError: invalid desktop effect \"\"\" if effect not in constants . UI_EFFECTS : raise InvalidParamError ( effect , constants . UI_EFFECTS ) self . setEffectEnabled ( constants . UI_EFFECTS [ effect ]) def is_effect_enabled ( self , effect : constants . UiEffectStr ) -> bool : \"\"\"Return desktop effect state. Returns: desktop effect state \"\"\" return self . isEffectEnabled ( constants . UI_EFFECTS [ effect ]) def set_navigation_mode ( self , mode : constants . NavigationModeStr ): \"\"\"Set the navigation mode. Args: mode: navigation mode to use Raises: InvalidParamError: invalid navigation mode \"\"\" if mode not in constants . NAVIGATION_MODES : raise InvalidParamError ( mode , constants . NAVIGATION_MODES ) self . setNavigationMode ( constants . NAVIGATION_MODES [ mode ]) def get_navigation_mode ( self ) -> constants . NavigationModeStr : \"\"\"Return navigation mode. Returns: navigation mode \"\"\" return constants . NAVIGATION_MODES . inverse [ self . navigationMode ()] @classmethod def sleep ( cls , secs : float ): \"\"\"Pause application (non-blocking). Args: secs: seconds to sleep \"\"\" start = timeit . default_timer () while True : cls . processEvents () if timeit . default_timer () - start > secs : return get_navigation_mode ( self ) -> constants . NavigationModeStr Return navigation mode. Returns: Type Description constants.NavigationModeStr navigation mode Source code in prettyqt/widgets/application.py def get_navigation_mode ( self ) -> constants . NavigationModeStr : \"\"\"Return navigation mode. Returns: navigation mode \"\"\" return constants . NAVIGATION_MODES . inverse [ self . navigationMode ()] is_effect_enabled ( self , effect : constants . UiEffectStr ) -> bool Return desktop effect state. Returns: Type Description bool desktop effect state Source code in prettyqt/widgets/application.py def is_effect_enabled ( self , effect : constants . UiEffectStr ) -> bool : \"\"\"Return desktop effect state. Returns: desktop effect state \"\"\" return self . isEffectEnabled ( constants . UI_EFFECTS [ effect ]) set_effect_enabled ( self , effect : constants . UiEffectStr , enabled : bool = True ) Set the enabled state of a desktop effect. Parameters: Name Type Description Default effect constants.UiEffectStr desktop effect to set required enabled bool new state True Exceptions: Type Description InvalidParamError invalid desktop effect Source code in prettyqt/widgets/application.py def set_effect_enabled ( self , effect : constants . UiEffectStr , enabled : bool = True ): \"\"\"Set the enabled state of a desktop effect. Args: effect: desktop effect to set enabled: new state Raises: InvalidParamError: invalid desktop effect \"\"\" if effect not in constants . UI_EFFECTS : raise InvalidParamError ( effect , constants . UI_EFFECTS ) self . setEffectEnabled ( constants . UI_EFFECTS [ effect ]) set_navigation_mode ( self , mode : constants . NavigationModeStr ) Set the navigation mode. Parameters: Name Type Description Default mode constants.NavigationModeStr navigation mode to use required Exceptions: Type Description InvalidParamError invalid navigation mode Source code in prettyqt/widgets/application.py def set_navigation_mode ( self , mode : constants . NavigationModeStr ): \"\"\"Set the navigation mode. Args: mode: navigation mode to use Raises: InvalidParamError: invalid navigation mode \"\"\" if mode not in constants . NAVIGATION_MODES : raise InvalidParamError ( mode , constants . NAVIGATION_MODES ) self . setNavigationMode ( constants . NAVIGATION_MODES [ mode ]) sleep ( secs : float ) classmethod Pause application (non-blocking). Parameters: Name Type Description Default secs float seconds to sleep required Source code in prettyqt/widgets/application.py @classmethod def sleep ( cls , secs : float ): \"\"\"Pause application (non-blocking). Args: secs: seconds to sleep \"\"\" start = timeit . default_timer () while True : cls . processEvents () if timeit . default_timer () - start > secs : return boxlayout BoxLayout ( QBoxLayout ) Source code in prettyqt/widgets/boxlayout.py class BoxLayout ( QtWidgets . QBoxLayout ): def __init__ ( self , orientation : Literal [ \"horizontal\" , \"vertical\" ] = \"horizontal\" , parent : QtWidgets . QWidget | None = None , margin : int | None = None , ): o = ( self . Direction . TopToBottom if orientation == \"vertical\" else self . Direction . LeftToRight ) super () . __init__ ( o , parent ) if margin is not None : self . set_margin ( margin ) def serialize_fields ( self ): return dict ( items = self . get_children (), direction = self . get_direction ()) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_direction ( state [ \"direction\" ]) for item in state [ \"items\" ]: self . add ( item ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __add__ ( self , other : QtWidgets . QWidget | QtWidgets . QLayout ): self . add ( other ) return self def add ( self , * item ): for i in item : if isinstance ( i , QtWidgets . QWidget ): self . addWidget ( i ) else : self . addLayout ( i ) def add_stretch ( self , stretch : int = 0 ): self . addStretch ( stretch ) def add_spacing ( self , size : int ): self . addSpacing ( size ) def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()] get_direction ( self ) -> DirectionStr Return current direction. Returns: Type Description DirectionStr direction Source code in prettyqt/widgets/boxlayout.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()] set_direction ( self , direction : DirectionStr ) Set the direction. Parameters: Name Type Description Default direction DirectionStr direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/widgets/boxlayout.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) calendarwidget CalendarWidget ( QCalendarWidget ) Source code in prettyqt/widgets/calendarwidget.py class CalendarWidget ( QtWidgets . QCalendarWidget ): def serialize_fields ( self ): return dict ( date = self . get_date ()) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setSelectedDate ( state [ \"date\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def get_date ( self ) -> datetime . date : return self . selectedDate () . toPython () # type: ignore def get_value ( self ) -> datetime . date : return self . get_date () def set_value ( self , value : types . DateType ): if isinstance ( value , str ): value = QtCore . QDate . fromString ( value ) self . setSelectedDate ( value ) # type: ignore def set_range ( self , lower : types . DateType , upper : types . DateType , ): if isinstance ( lower , str ): lower = QtCore . QDate . fromString ( lower ) if isinstance ( upper , str ): upper = QtCore . QDate . fromString ( upper ) self . setMinimumDate ( lower ) # type: ignore self . setMaximumDate ( upper ) # type: ignore def set_selection_mode ( self , mode : SelectionModeStr | None ): \"\"\"Set selection mode for given calendar widget. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ]) def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()] get_selection_mode ( self ) -> SelectionModeStr Return current selection mode. Returns: Type Description SelectionModeStr selection mode Source code in prettyqt/widgets/calendarwidget.py def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()] set_selection_mode ( self , mode : SelectionModeStr | None ) Set selection mode for given calendar widget. Parameters: Name Type Description Default mode SelectionModeStr | None selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/calendarwidget.py def set_selection_mode ( self , mode : SelectionModeStr | None ): \"\"\"Set selection mode for given calendar widget. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ]) checkbox CheckBox ( QCheckBox ) Source code in prettyqt/widgets/checkbox.py class CheckBox ( QtWidgets . QCheckBox ): value_changed = core . Signal ( int ) def __init__ ( self , label : str = \"\" , parent : QtWidgets . QWidget | None = None , checked : bool = False , ): super () . __init__ ( label , parent ) self . stateChanged . connect ( self . value_changed ) self . setChecked ( checked ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setTristate ( state . get ( \"is_tristate\" , False )) self . set_checkstate ( state [ \"checkstate\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def serialize_fields ( self ): return dict ( checkstate = self . get_checkstate (), is_tristate = self . isTristate (), ) def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] get_checkstate ( self ) -> constants . StateStr Return checkstate. Returns: Type Description constants.StateStr checkstate Source code in prettyqt/widgets/checkbox.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] set_checkstate ( self , state : constants . StateStr ) Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/checkbox.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) colordialog CPAlphaShowLabel ( Label ) Source code in prettyqt/widgets/colordialog.py class CPAlphaShowLabel ( widgets . Label ): \"\"\"Label which displays the currently-active color using checkerboard alpha. A replacement for QColorDialog's QColorShowLabel. \"\"\" def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) # Length in pixels of a side of the checkerboard squares # (Pattern is made up of 2\u00d72 squares, total size 2n \u00d7 2n) self . checkerboard_size = 8 # Start out transparent by default self . color = self . parent () . currentColor () self . parent () . currentColorChanged . connect ( self . update_color ) self . pattern = gui . Pixmap . create_checkerboard_pattern ( self . checkerboard_size , \"#aaa\" , \"#ccc\" ) def update_color ( self , color : QtGui . QColor ): self . color = color self . repaint () def paintEvent ( self , event ): \"\"\"Show the current color using checkerboard alpha.\"\"\" event . accept () with gui . Painter ( self ) as p : p . set_pen ( None ) if self . color . alphaF () < 1.0 : p . drawTiledPixmap ( event . rect (), self . pattern , QtCore . QPoint ( 4 , 4 )) p . fillRect ( event . rect (), self . color ) paintEvent ( self , event ) Show the current color using checkerboard alpha. Source code in prettyqt/widgets/colordialog.py def paintEvent ( self , event ): \"\"\"Show the current color using checkerboard alpha.\"\"\" event . accept () with gui . Painter ( self ) as p : p . set_pen ( None ) if self . color . alphaF () < 1.0 : p . drawTiledPixmap ( event . rect (), self . pattern , QtCore . QPoint ( 4 , 4 )) p . fillRect ( event . rect (), self . color ) combobox ComboBox ( QComboBox ) Source code in prettyqt/widgets/combobox.py class ComboBox ( QtWidgets . QComboBox ): value_changed = core . Signal ( object ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . currentIndexChanged . connect ( self . index_changed ) def serialize_fields ( self ): items = [ ( self . itemText ( i ), self . itemData ( i ), self . item_icon ( i )) for i in range ( self . count ()) ] dct = dict ( index = self . currentIndex (), editable = self . isEditable (), max_count = self . maxCount (), has_frame = self . hasFrame (), icon_size = self . iconSize (), insert_policy = self . insertPolicy (), model_column = self . modelColumn (), max_visible_items = self . maxVisibleItems (), size_adjust_policy = self . get_size_adjust_policy (), duplicates_enabled = self . duplicatesEnabled (), min_contents_length = self . minimumContentsLength (), placeholder_text = self . placeholderText (), items = items , ) return dct def __setstate__ ( self , state ): super () . __setstate__ ( state ) for label , data , icon in state [ \"items\" ]: self . add ( label , data , icon = icon ) self . setCurrentIndex ( state [ \"index\" ]) self . setEditable ( state [ \"editable\" ]) self . setMaxCount ( state [ \"max_count\" ]) self . setMaxVisibleItems ( state [ \"max_visible_items\" ]) self . setMinimumContentsLength ( state [ \"min_contents_length\" ]) self . setDuplicatesEnabled ( state [ \"duplicates_enabled\" ]) self . setFrame ( state [ \"has_frame\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __len__ ( self ) -> int : return self . count () def index_changed ( self , index : int ): data = self . itemData ( index ) self . value_changed . emit ( data ) def add_items ( self , items : Iterable | Mapping , default = NoData ): if isinstance ( items , Mapping ): for k , v in items . items (): self . addItem ( v , userData = k ) else : for i in items : if isinstance ( i , ( tuple , list )): self . add ( * i ) else : self . addItem ( i , i ) if default is not NoData : self . set_value ( default ) def add ( self , label : str , data = NoData , icon : types . IconType = None ): if data is NoData : data = label if icon is not None : icon = iconprovider . get_icon ( icon ) self . addItem ( gui . Icon ( icon ), label , userData = data ) else : self . addItem ( label , userData = data ) def item_icon ( self , index : int ) -> gui . Icon | None : icon = self . itemIcon ( index ) if icon . isNull (): return None return gui . Icon ( icon ) def set_editable ( self , editable : bool ): self . setEditable ( editable ) if self . completer () is None and editable : self . setCompleter ( widgets . Completer ( self )) def set_insert_policy ( self , policy : InsertPolicyStr ): \"\"\"Set insert policy. Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICY : raise InvalidParamError ( policy , INSERT_POLICY ) self . setInsertPolicy ( INSERT_POLICY [ policy ]) def get_insert_policy ( self ) -> InsertPolicyStr : \"\"\"Return insert policy. Returns: insert policy \"\"\" return INSERT_POLICY . inverse [ self . insertPolicy ()] def set_size_adjust_policy ( self , policy : SizeAdjustPolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_ADJUST_POLICY : raise InvalidParamError ( policy , SIZE_ADJUST_POLICY ) self . setSizeAdjustPolicy ( SIZE_ADJUST_POLICY [ policy ]) def get_size_adjust_policy ( self ) -> SizeAdjustPolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_ADJUST_POLICY . inverse [ self . sizeAdjustPolicy ()] def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) def get_icon_size ( self ) -> core . Size : return core . Size ( self . iconSize ()) def set_min_char_length ( self , chars : int ): self . setMinimumContentsLength ( chars ) def get_value ( self ) -> Any : # if all(self.itemData(i) is None for i in range(self.count())): # return self.currentText() # else: # return self.currentData() return self . currentData () def set_value ( self , value : Any ): self . set_data ( value ) def set_text ( self , text : str ): self . setCurrentText ( text ) def set_data ( self , data : Any ): idx = self . findData ( data ) if idx == - 1 : raise ValueError ( \"invalid data\" ) self . setCurrentIndex ( idx ) def text ( self ) -> str : return self . currentText () def hide_completer ( self ): \"\"\"Hides the completion widget.\"\"\" completer = widgets . Completer ( self ) self . setCompleter ( completer ) get_insert_policy ( self ) -> InsertPolicyStr Return insert policy. Returns: Type Description InsertPolicyStr insert policy Source code in prettyqt/widgets/combobox.py def get_insert_policy ( self ) -> InsertPolicyStr : \"\"\"Return insert policy. Returns: insert policy \"\"\" return INSERT_POLICY . inverse [ self . insertPolicy ()] get_size_adjust_policy ( self ) -> SizeAdjustPolicyStr Return size adjust policy. Returns: Type Description SizeAdjustPolicyStr size adjust policy Source code in prettyqt/widgets/combobox.py def get_size_adjust_policy ( self ) -> SizeAdjustPolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_ADJUST_POLICY . inverse [ self . sizeAdjustPolicy ()] hide_completer ( self ) Hides the completion widget. Source code in prettyqt/widgets/combobox.py def hide_completer ( self ): \"\"\"Hides the completion widget.\"\"\" completer = widgets . Completer ( self ) self . setCompleter ( completer ) set_icon_size ( self , size : int | types . SizeType ) Set size of the icons. Source code in prettyqt/widgets/combobox.py def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) set_insert_policy ( self , policy : InsertPolicyStr ) Set insert policy. Parameters: Name Type Description Default policy InsertPolicyStr insert policy to use required Exceptions: Type Description InvalidParamError invalid insert policy Source code in prettyqt/widgets/combobox.py def set_insert_policy ( self , policy : InsertPolicyStr ): \"\"\"Set insert policy. Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICY : raise InvalidParamError ( policy , INSERT_POLICY ) self . setInsertPolicy ( INSERT_POLICY [ policy ]) set_size_adjust_policy ( self , policy : SizeAdjustPolicyStr ) Set size adjust policy. Parameters: Name Type Description Default policy SizeAdjustPolicyStr size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/combobox.py def set_size_adjust_policy ( self , policy : SizeAdjustPolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_ADJUST_POLICY : raise InvalidParamError ( policy , SIZE_ADJUST_POLICY ) self . setSizeAdjustPolicy ( SIZE_ADJUST_POLICY [ policy ]) completer Completer ( QCompleter ) Source code in prettyqt/widgets/completer.py class Completer ( QtWidgets . QCompleter ): def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) def set_sort_mode ( self , mode : SortModeStr | None ): \"\"\"Set sort mode to use. Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODE : raise InvalidParamError ( mode , SORT_MODE ) self . setModelSorting ( SORT_MODE [ mode ]) def get_sort_mode ( self ) -> SortModeStr : \"\"\"Return current sort mode. Returns: sort mode \"\"\" return SORT_MODE . inverse [ self . modelSorting ()] def set_completion_mode ( self , mode : CompletionModeStr ): \"\"\"Set completion mode to use. Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODE : raise InvalidParamError ( mode , COMPLETION_MODE ) self . setCompletionMode ( COMPLETION_MODE [ mode ]) def get_completion_mode ( self ) -> CompletionModeStr : \"\"\"Return current completion mode. Returns: completion mode \"\"\" return COMPLETION_MODE . inverse [ self . completionMode ()] def set_filter_mode ( self , mode : constants . FilterModeStr ): \"\"\"Set filter mode to use. Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in constants . FILTER_MODES : raise InvalidParamError ( mode , constants . FILTER_MODES ) self . setFilterMode ( constants . FILTER_MODES [ mode ]) def get_filter_mode ( self ) -> constants . FilterModeStr : \"\"\"Return current filter mode. Returns: filter mode \"\"\" return constants . FILTER_MODES . inverse [ self . filterMode ()] def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = ( QtCore . Qt . CaseSensitivity . CaseSensitive if state else QtCore . Qt . CaseSensitivity . CaseInsensitive ) self . setCaseSensitivity ( sensitivity ) def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ()) get_completion_mode ( self ) -> CompletionModeStr Return current completion mode. Returns: Type Description CompletionModeStr completion mode Source code in prettyqt/widgets/completer.py def get_completion_mode ( self ) -> CompletionModeStr : \"\"\"Return current completion mode. Returns: completion mode \"\"\" return COMPLETION_MODE . inverse [ self . completionMode ()] get_filter_mode ( self ) -> constants . FilterModeStr Return current filter mode. Returns: Type Description constants.FilterModeStr filter mode Source code in prettyqt/widgets/completer.py def get_filter_mode ( self ) -> constants . FilterModeStr : \"\"\"Return current filter mode. Returns: filter mode \"\"\" return constants . FILTER_MODES . inverse [ self . filterMode ()] get_sort_mode ( self ) -> SortModeStr Return current sort mode. Returns: Type Description SortModeStr sort mode Source code in prettyqt/widgets/completer.py def get_sort_mode ( self ) -> SortModeStr : \"\"\"Return current sort mode. Returns: sort mode \"\"\" return SORT_MODE . inverse [ self . modelSorting ()] is_case_sensitive ( self ) -> bool Return case sensitivity. Returns: Type Description bool case sensitivity Source code in prettyqt/widgets/completer.py def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ()) set_case_sensitive ( self , state : bool ) Set case sensitivity. Parameters: Name Type Description Default state bool case sensitive required Source code in prettyqt/widgets/completer.py def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = ( QtCore . Qt . CaseSensitivity . CaseSensitive if state else QtCore . Qt . CaseSensitivity . CaseInsensitive ) self . setCaseSensitivity ( sensitivity ) set_completion_mode ( self , mode : CompletionModeStr ) Set completion mode to use. Parameters: Name Type Description Default mode CompletionModeStr completion mode to use required Exceptions: Type Description InvalidParamError completion mode does not exist Source code in prettyqt/widgets/completer.py def set_completion_mode ( self , mode : CompletionModeStr ): \"\"\"Set completion mode to use. Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODE : raise InvalidParamError ( mode , COMPLETION_MODE ) self . setCompletionMode ( COMPLETION_MODE [ mode ]) set_filter_mode ( self , mode : constants . FilterModeStr ) Set filter mode to use. Parameters: Name Type Description Default mode constants.FilterModeStr filter mode to use required Exceptions: Type Description InvalidParamError filter mode does not exist Source code in prettyqt/widgets/completer.py def set_filter_mode ( self , mode : constants . FilterModeStr ): \"\"\"Set filter mode to use. Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in constants . FILTER_MODES : raise InvalidParamError ( mode , constants . FILTER_MODES ) self . setFilterMode ( constants . FILTER_MODES [ mode ]) set_sort_mode ( self , mode : SortModeStr | None ) Set sort mode to use. Parameters: Name Type Description Default mode SortModeStr | None sort mode to use required Exceptions: Type Description InvalidParamError sort mode does not exist Source code in prettyqt/widgets/completer.py def set_sort_mode ( self , mode : SortModeStr | None ): \"\"\"Set sort mode to use. Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODE : raise InvalidParamError ( mode , SORT_MODE ) self . setModelSorting ( SORT_MODE [ mode ]) datawidgetmapper DataWidgetMapper ( QDataWidgetMapper ) Source code in prettyqt/widgets/datawidgetmapper.py class DataWidgetMapper ( QtWidgets . QDataWidgetMapper ): def serialize_fields ( self ): return dict ( current_index = self . currentIndex (), orientation = self . get_orientation (), submit_policy = self . get_submit_policy (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_orientation ( state [ \"orientation\" ]) self . set_submit_policy ( state [ \"submit_policy\" ]) self . setCurrentIndex ( state [ \"current_index\" ]) def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the data widget mapper. Args: orientation: orientation for the data widget mapper Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] def set_submit_policy ( self , policy : SubmitPolicyStr ): \"\"\"Set the submit policy of the mapper. Args: policy: submit_policy for the data widget mapper Raises: InvalidParamError: submit_policy does not exist \"\"\" if policy not in SUBMIT_POLICY : raise InvalidParamError ( policy , SUBMIT_POLICY ) self . setSubmitPolicy ( SUBMIT_POLICY [ policy ]) def get_submit_policy ( self ) -> SubmitPolicyStr : \"\"\"Return current submit policy. Returns: submit policy \"\"\" return SUBMIT_POLICY . inverse [ self . submitPolicy ()] def add_mapping ( self , widget : QtWidgets . QWidget , section : int , property_name : str | None = None ): if property_name is None : self . addMapping ( widget , section ) else : ba = QtCore . QByteArray ( property_name . encode ()) self . addMapping ( widget , section , ba ) def get_mapped_property_name ( self , widget : QtWidgets . QWidget ) -> str : return bytes ( self . mappedPropertyName ( widget )) . decode () get_orientation ( self ) -> constants . OrientationStr Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/datawidgetmapper.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] get_submit_policy ( self ) -> SubmitPolicyStr Return current submit policy. Returns: Type Description SubmitPolicyStr submit policy Source code in prettyqt/widgets/datawidgetmapper.py def get_submit_policy ( self ) -> SubmitPolicyStr : \"\"\"Return current submit policy. Returns: submit policy \"\"\" return SUBMIT_POLICY . inverse [ self . submitPolicy ()] set_orientation ( self , orientation : constants . OrientationStr ) Set the orientation of the data widget mapper. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the data widget mapper required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the data widget mapper. Args: orientation: orientation for the data widget mapper Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) set_submit_policy ( self , policy : SubmitPolicyStr ) Set the submit policy of the mapper. Parameters: Name Type Description Default policy SubmitPolicyStr submit_policy for the data widget mapper required Exceptions: Type Description InvalidParamError submit_policy does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_submit_policy ( self , policy : SubmitPolicyStr ): \"\"\"Set the submit policy of the mapper. Args: policy: submit_policy for the data widget mapper Raises: InvalidParamError: submit_policy does not exist \"\"\" if policy not in SUBMIT_POLICY : raise InvalidParamError ( policy , SUBMIT_POLICY ) self . setSubmitPolicy ( SUBMIT_POLICY [ policy ]) dialog Dialog ( QDialog ) Source code in prettyqt/widgets/dialog.py class Dialog ( QtWidgets . QDialog ): def __init__ ( self , title : str = \"\" , icon : types . IconType = None , parent : QtWidgets . QWidget | None = None , delete_on_close : bool = False , layout : None | str | QtWidgets . QLayout = None , ): super () . __init__ ( parent = parent ) self . set_title ( title ) self . set_icon ( icon ) if delete_on_close : self . delete_on_close () if layout is not None : self . set_layout ( layout ) def __getitem__ ( self , index : str ) -> QtWidgets . QWidget : result = self . find_child ( QtWidgets . QWidget , index ) if result is None : raise KeyError ( \"Widget not found\" ) return result def serialize_fields ( self ): return dict ( # modal=self.isModal(), layout = self . layout (), size_grip_enabled = self . isSizeGripEnabled (), size = ( self . size () . width (), self . size () . height ()), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) if state [ \"layout\" ]: self . set_layout ( state [ \"layout\" ]) self . resize ( * state [ \"size\" ]) self . setSizeGripEnabled ( state [ \"size_grip_enabled\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e ) def delete_on_close ( self ): self . setAttribute ( QtCore . Qt . WidgetAttribute . WA_DeleteOnClose ) def add_widget ( self , widget : QtWidgets . QWidget ) -> QtWidgets . QWidget : self . box += widget return widget def add_buttonbox ( self ) -> widgets . DialogButtonBox : button_box = widgets . DialogButtonBox . create ( ok = self . accept , cancel = self . reject ) self . box . add ( button_box ) return button_box def show_blocking ( self ) -> bool : self . show () return bool ( self . main_loop ()) def is_accepted ( self ) -> bool : return self . result () == QtWidgets . QDialog . Accepted def main_loop ( self ) -> int : return self . exec_ () keyPressEvent ( self , e ) keyPressEvent(self, arg__1: PySide6.QtGui.QKeyEvent) -> None Source code in prettyqt/widgets/dialog.py def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e ) dialogbuttonbox DialogButtonBox ( QDialogButtonBox ) Source code in prettyqt/widgets/dialogbuttonbox.py class DialogButtonBox ( QtWidgets . QDialogButtonBox ): button_clicked = core . Signal ( str ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . clicked . connect ( self . on_click ) def __len__ ( self ) -> int : return len ( self . buttons ()) def __getitem__ ( self , index : ButtonStr ) -> QtWidgets . QPushButton : return self . button ( BUTTONS [ index ]) def __iter__ ( self ) -> Iterator [ QtWidgets . QAbstractButton ]: return iter ( self . buttons ()) def __contains__ ( self , index : ButtonStr ): return self . button ( BUTTONS [ index ]) is not None @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) # type: ignore return box def on_click ( self , button : QtCore . QObject ): self . button_clicked . emit ( button . objectName ()) def set_horizontal ( self ): self . setOrientation ( constants . HORIZONTAL ) def set_vertical ( self ): self . setOrientation ( constants . VERTICAL ) def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the button box. Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] def add_default_buttons ( self , buttons : Sequence [ ButtonStr ]): return [ self . add_default_button ( btn ) for btn in buttons ] def add_default_button ( self , button : ButtonStr , callback : Callable | None = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn def add_button ( self , button : QtWidgets . QPushButton | ButtonStr , role : RoleStr = \"accept\" , callback : Callable | None = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button add_button ( self , button : QtWidgets . QPushButton | ButtonStr , role : RoleStr = 'accept' , callback : Callable | None = None ) -> widgets . PushButton Add a button. Parameters: Name Type Description Default button QtWidgets.QPushButton | ButtonStr button to add required role RoleStr role of the button 'accept' callback Callable | None function to call when button gets clicked None Returns: Type Description widgets.PushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_button ( self , button : QtWidgets . QPushButton | ButtonStr , role : RoleStr = \"accept\" , callback : Callable | None = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button add_default_button ( self , button : ButtonStr , callback : Callable | None = None ) -> QtWidgets . QPushButton Add a default button. Parameters: Name Type Description Default button ButtonStr button to add required callback Callable | None function to call when button gets clicked None Returns: Type Description QtWidgets.QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_default_button ( self , button : ButtonStr , callback : Callable | None = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn create ( ** kwargs ) classmethod create(self, arg__1: int = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) -> None Source code in prettyqt/widgets/dialogbuttonbox.py @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) # type: ignore return box get_orientation ( self ) -> constants . OrientationStr Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/dialogbuttonbox.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] set_orientation ( self , orientation : constants . OrientationStr ) Set the orientation of the button box. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the button box required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the button box. Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) filedialog FileDialog ( QFileDialog ) Source code in prettyqt/widgets/filedialog.py class FileDialog ( QtWidgets . QFileDialog ): \"\"\"Simple dialog used to display some widget.\"\"\" def __init__ ( self , path : None | types . PathType = None , mode : AcceptModeStr = \"open\" , caption : str | None = None , path_id : str | None = None , extension_filter : dict | None = None , file_mode : FileModeStr = \"existing_files\" , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( parent = parent ) self . set_title ( caption ) self . path_id = path_id if extension_filter : self . set_extension_filter ( extension_filter ) if path_id is not None and path is None : settings = core . Settings () path = settings . get ( path_id , \"\" ) if path is not None : self . set_directory ( path ) self . set_file_mode ( file_mode ) self . set_accept_mode ( mode ) def serialize_fields ( self ): return dict ( file_mode = self . get_file_mode (), accept_mode = self . get_accept_mode (), filter = self . get_filter (), view_mode = self . get_view_mode (), name_filter = self . selectedNameFilter (), default_suffix = self . defaultSuffix (), name_filters = self . nameFilters (), supported_schemes = self . supportedSchemes (), ) def __setstate__ ( self , state ): self . set_file_mode ( state [ \"file_mode\" ]) self . set_accept_mode ( state [ \"accept_mode\" ]) self . set_view_mode ( state [ \"view_mode\" ]) self . set_filter ( * state [ \"filter\" ]) self . setNameFilters ( state [ \"name_filters\" ]) self . setNameFilter ( state [ \"name_filter\" ]) self . setDefaultSuffix ( state [ \"default_suffix\" ]) self . setSupportedSchemes ( state [ \"supported_schemes\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def set_accept_mode ( self , mode : AcceptModeStr ): \"\"\"Set accept mode. Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODE : raise InvalidParamError ( mode , ACCEPT_MODE ) self . setAcceptMode ( ACCEPT_MODE [ mode ]) def get_accept_mode ( self ) -> AcceptModeStr : \"\"\"Return accept mode. Returns: accept mode \"\"\" return ACCEPT_MODE . inverse [ self . acceptMode ()] def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] def set_label_text ( self , label : LabelStr , text : str ): \"\"\"Set the label text for button label. Args: label: button to set text for text: text to use \"\"\" if label not in LABEL : raise InvalidParamError ( label , LABEL ) self . setLabelText ( LABEL [ label ], text ) def get_label_text ( self , label : LabelStr ) -> str : \"\"\"Return label text. Returns: label text \"\"\" return self . labelText ( LABEL [ label ]) def get_file_mode ( self ) -> FileModeStr : \"\"\"Return file mode. Returns: file mode \"\"\" return FILE_MODE . inverse [ self . fileMode ()] def set_file_mode ( self , mode : FileModeStr ): \"\"\"Set the file mode of the dialog. Args: mode: mode to use \"\"\" self . setFileMode ( FILE_MODE [ mode ]) def selected_files ( self ) -> list [ pathlib . Path ]: return [ pathlib . Path ( p ) for p in self . selectedFiles ()] def selected_file ( self ) -> pathlib . Path | None : selected = self . selectedFiles () return pathlib . Path ( selected [ 0 ]) if selected else None def choose_folder ( self ) -> list [ pathlib . Path ] | None : self . set_file_mode ( \"directory\" ) return self . choose () def open_file ( self ) -> list [ pathlib . Path ] | None : self . set_file_mode ( \"existing_file\" ) return self . choose () def choose ( self ) -> list [ pathlib . Path ] | None : result = self . main_loop () if result != self . Accepted : return None paths = self . selected_files () folder_path = paths [ 0 ] . parent if self . path_id : settings = core . Settings () settings . setValue ( self . path_id , str ( folder_path )) return paths def set_extension_filter ( self , extension_dict : dict [ str , list [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str ) def get_directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( self . directory () . absolutePath ()) def set_directory ( self , path : types . PathType ): \"\"\"Set start directory.\"\"\" path = os . fspath ( path ) self . setDirectory ( path ) def set_filter ( self , * filters : core . dir . FilterStr ): for item in filters : if item not in core . dir . FILTERS : raise InvalidParamError ( item , core . dir . FILTERS ) flags = helpers . merge_flags ( filters , core . dir . FILTERS ) self . setFilter ( flags ) def get_filter ( self ) -> list [ core . dir . FilterStr ]: return [ k for k , v in core . dir . FILTERS . items () if v & self . filter ()] get_accept_mode ( self ) -> AcceptModeStr Return accept mode. Returns: Type Description AcceptModeStr accept mode Source code in prettyqt/widgets/filedialog.py def get_accept_mode ( self ) -> AcceptModeStr : \"\"\"Return accept mode. Returns: accept mode \"\"\" return ACCEPT_MODE . inverse [ self . acceptMode ()] get_directory ( self ) -> pathlib . Path Return current directory. returns current directory level as a Pathlib object Returns: Type Description pathlib.Path Pathlib object Source code in prettyqt/widgets/filedialog.py def get_directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( self . directory () . absolutePath ()) get_file_mode ( self ) -> FileModeStr Return file mode. Returns: Type Description FileModeStr file mode Source code in prettyqt/widgets/filedialog.py def get_file_mode ( self ) -> FileModeStr : \"\"\"Return file mode. Returns: file mode \"\"\" return FILE_MODE . inverse [ self . fileMode ()] get_label_text ( self , label : LabelStr ) -> str Return label text. Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py def get_label_text ( self , label : LabelStr ) -> str : \"\"\"Return label text. Returns: label text \"\"\" return self . labelText ( LABEL [ label ]) get_view_mode ( self ) -> ViewModeStr Return view mode. Returns: Type Description ViewModeStr view mode Source code in prettyqt/widgets/filedialog.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] set_accept_mode ( self , mode : AcceptModeStr ) Set accept mode. Parameters: Name Type Description Default mode AcceptModeStr accept mode to use required Exceptions: Type Description InvalidParamError invalid accept mode Source code in prettyqt/widgets/filedialog.py def set_accept_mode ( self , mode : AcceptModeStr ): \"\"\"Set accept mode. Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODE : raise InvalidParamError ( mode , ACCEPT_MODE ) self . setAcceptMode ( ACCEPT_MODE [ mode ]) set_directory ( self , path : types . PathType ) Set start directory. Source code in prettyqt/widgets/filedialog.py def set_directory ( self , path : types . PathType ): \"\"\"Set start directory.\"\"\" path = os . fspath ( path ) self . setDirectory ( path ) set_extension_filter ( self , extension_dict : dict [ str , list [ str ]]) Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict dict[str, list[str]] filter dictionary required Source code in prettyqt/widgets/filedialog.py def set_extension_filter ( self , extension_dict : dict [ str , list [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str ) set_file_mode ( self , mode : FileModeStr ) Set the file mode of the dialog. Parameters: Name Type Description Default mode FileModeStr mode to use required Source code in prettyqt/widgets/filedialog.py def set_file_mode ( self , mode : FileModeStr ): \"\"\"Set the file mode of the dialog. Args: mode: mode to use \"\"\" self . setFileMode ( FILE_MODE [ mode ]) set_label_text ( self , label : LabelStr , text : str ) Set the label text for button label. Parameters: Name Type Description Default label LabelStr button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py def set_label_text ( self , label : LabelStr , text : str ): \"\"\"Set the label text for button label. Args: label: button to set text for text: text to use \"\"\" if label not in LABEL : raise InvalidParamError ( label , LABEL ) self . setLabelText ( LABEL [ label ], text ) set_view_mode ( self , mode : ViewModeStr ) Set view mode. Parameters: Name Type Description Default mode ViewModeStr view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/filedialog.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) filesystemmodel FileSystemModel ( QFileSystemModel ) Source code in prettyqt/widgets/filesystemmodel.py class FileSystemModel ( QtWidgets . QFileSystemModel ): \"\"\"Class to populate a filesystem treeview.\"\"\" DATA_ROLE = constants . USER_ROLE + 33 # type: ignore content_type = \"files\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setReadOnly ( False ) def data ( self , index , role = QtCore . Qt . ItemDataRole . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . Roles . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role ) def get_file_info ( self , index : QtCore . QModelIndex ) -> core . FileInfo : return core . FileInfo ( self . fileInfo ( index )) def get_file_path ( self , index : QtCore . QModelIndex ) -> pathlib . Path : return pathlib . Path ( self . filePath ( index )) def yield_child_indexes ( self , index : QtCore . QModelIndex ) -> Iterator [ QtCore . QModelIndex ]: if not self . hasChildren ( index ): return path = self . filePath ( index ) flags = self . filter () | QtCore . QDir . NoDotAndDotDot for it in core . DirIterator ( path , flags ): yield self . index ( it ) def resolve_sym_links ( self , resolve : bool ): self . setResolveSymlinks ( resolve ) def watch_for_changes ( self , watch : bool ): self . setOption ( OPTIONS [ \"dont_watch_changes\" ], not watch ) def use_custom_icons ( self , use : bool ): self . setOption ( OPTIONS [ \"no_custom_icons\" ], not use ) def set_root_path ( self , path : types . PathType ) -> QtCore . QModelIndex : path = os . fspath ( path ) if path in [ \"/\" , \"root\" ]: path = core . Dir . rootPath () elif path == \"home\" : path = core . Dir . homePath () elif path == \"temp\" : path = core . Dir . tempPath () elif path == \"current\" : path = core . Dir . currentPath () return self . setRootPath ( path ) def set_name_filters ( self , filters , hide : bool = False ): self . setNameFilters ( filters ) self . setNameFilterDisables ( not hide ) def set_filter ( self , filter_mode : core . dir . FilterStr ): if filter_mode not in core . dir . FILTERS : raise InvalidParamError ( filter_mode , core . dir . FILTERS ) self . setFilter ( core . dir . FILTERS [ filter_mode ]) def get_paths ( self , indexes : Sequence [ QtCore . QModelIndex ]) -> list [ pathlib . Path ]: paths = [ i . data ( self . DATA_ROLE ) for i in indexes ] if not paths : return [] if paths [ 0 ] == \"\" : paths = [ folder / filename for folder in paths for filename in folder . iterdir () if ( folder / filename ) . is_file () ] return paths data ( self , index , role = < ItemDataRole . DisplayRole : 0 > ) data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/widgets/filesystemmodel.py def data ( self , index , role = QtCore . Qt . ItemDataRole . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . Roles . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role ) fontcombobox FontComboBox ( QFontComboBox ) Source code in prettyqt/widgets/fontcombobox.py class FontComboBox ( QtWidgets . QFontComboBox ): value_changed = core . Signal ( object ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . currentIndexChanged . connect ( self . index_changed ) def serialize_fields ( self ): return dict ( current_font = self . get_current_font (), font_filters = self . get_font_filters (), ) def __setstate__ ( self , state ): self . set_font_filters ( * state . get ( \"font_filters\" , [])) self . setCurrentFont ( state [ \"current_font\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def set_font_filters ( self , * filters : FontFilterStr ): \"\"\"Set font filters. Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags ) def get_font_filters ( self ) -> list [ FontFilterStr ]: \"\"\"Return list of font filters. Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()] def set_value ( self , value : QtGui . QFont ): self . setCurrentFont ( value ) def get_value ( self ) -> gui . Font : return self . get_current_font () def get_current_font ( self ) -> gui . Font : return gui . Font ( self . currentFont ()) get_font_filters ( self ) -> list [ FontFilterStr ] Return list of font filters. Returns: Type Description list[FontFilterStr] font filter list Source code in prettyqt/widgets/fontcombobox.py def get_font_filters ( self ) -> list [ FontFilterStr ]: \"\"\"Return list of font filters. Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()] set_font_filters ( self , * filters : FontFilterStr ) Set font filters. Parameters: Name Type Description Default filters FontFilterStr font filters to use () Exceptions: Type Description InvalidParamError invalid font filters Source code in prettyqt/widgets/fontcombobox.py def set_font_filters ( self , * filters : FontFilterStr ): \"\"\"Set font filters. Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags ) formlayout FormLayout ( QFormLayout ) Source code in prettyqt/widgets/formlayout.py class FormLayout ( QtWidgets . QFormLayout ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . set_size_mode ( \"maximum\" ) self . setVerticalSpacing ( 8 ) def __setitem__ ( self , index : int | tuple [ int , RoleStr ], value : str | QtWidgets . QWidget ): if isinstance ( index , tuple ): row = index [ 0 ] role = index [ 1 ] else : row = index role = \"both\" self . set_widget ( value , row , role ) def __delitem__ ( self , index : int ): self . removeRow ( index ) def __iter__ ( self ): return iter ( self [ i ] for i in range ( self . count ()) if self [ i ] is not None ) def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount () def __add__ ( self , other : QtWidgets . QWidget | QtWidgets . QLayout | tuple ): self . add ( other ) return self def serialize_fields ( self ): widget_list = [] positions = [] for i , item in enumerate ( list ( self )): widget_list . append ( item ) positions . append ( self . get_item_position ( i )) return dict ( widgets = widget_list , positions = positions ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __setstate__ ( self , state ): for i , ( item , pos ) in enumerate ( zip ( state [ \"widgets\" ], state [ \"positions\" ])): self . set_widget ( item , pos [ 0 ], pos [ 1 ]) def set_widget ( self , widget : str | QtWidgets . QWidget , row : int , role : RoleStr = \"both\" ): if isinstance ( widget , str ): widget = widgets . Label ( widget ) self . setWidget ( row , ROLE [ role ], widget ) def get_widget ( self , row : int , role : RoleStr = \"both\" ) -> QtWidgets . QLayout | QtWidgets . QWidget : item = self . itemAt ( row , ROLE [ role ]) widget = item . widget () if widget is None : widget = item . layout () return widget def get_item_position ( self , index : int ) -> tuple [ int , RoleStr ] | None : pos = self . getItemPosition ( index ) # type: ignore if pos [ 0 ] == - 1 : # type: ignore return None return pos [ 0 ], ROLE . inverse [ pos [ 1 ]] # type: ignore def add ( self , * items ): for i in items : if isinstance ( i , ( QtWidgets . QWidget , QtWidgets . QLayout )): self . addRow ( i ) if isinstance ( i , tuple ): self . addRow ( * i ) def set_row_wrap_policy ( self , policy : RowWrapPolicyStr ): \"\"\"Set row wrap policy to use. Args: policy: row wrap policy to use Raises: InvalidParamError: row wrap policy does not exist \"\"\" if policy not in ROW_WRAP_POLICY : raise InvalidParamError ( policy , ROW_WRAP_POLICY ) self . setRowWrapPolicy ( ROW_WRAP_POLICY [ policy ]) def get_row_wrap_policy ( self ) -> RowWrapPolicyStr : \"\"\"Return current row wrap policy. Returns: row wrap policy \"\"\" return ROW_WRAP_POLICY . inverse [ self . rowWrapPolicy ()] def set_field_growth_policy ( self , policy : FieldGrowthPolicyStr ): \"\"\"Set field growth policy to use. Args: policy: field growth policy to use Raises: InvalidParamError: field growth policy does not exist \"\"\" if policy not in FIELD_GROWTH_POLICY : raise InvalidParamError ( policy , FIELD_GROWTH_POLICY ) self . setFieldGrowthPolicy ( FIELD_GROWTH_POLICY [ policy ]) def get_field_growth_policy ( self ) -> FieldGrowthPolicyStr : \"\"\"Return current field growth policy. Returns: field growth policy \"\"\" return FIELD_GROWTH_POLICY . inverse [ self . fieldGrowthPolicy ()] __len__ ( self ) -> int special Needed for PySide2. Source code in prettyqt/widgets/formlayout.py def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount () get_field_growth_policy ( self ) -> FieldGrowthPolicyStr Return current field growth policy. Returns: Type Description FieldGrowthPolicyStr field growth policy Source code in prettyqt/widgets/formlayout.py def get_field_growth_policy ( self ) -> FieldGrowthPolicyStr : \"\"\"Return current field growth policy. Returns: field growth policy \"\"\" return FIELD_GROWTH_POLICY . inverse [ self . fieldGrowthPolicy ()] get_row_wrap_policy ( self ) -> RowWrapPolicyStr Return current row wrap policy. Returns: Type Description RowWrapPolicyStr row wrap policy Source code in prettyqt/widgets/formlayout.py def get_row_wrap_policy ( self ) -> RowWrapPolicyStr : \"\"\"Return current row wrap policy. Returns: row wrap policy \"\"\" return ROW_WRAP_POLICY . inverse [ self . rowWrapPolicy ()] set_field_growth_policy ( self , policy : FieldGrowthPolicyStr ) Set field growth policy to use. Parameters: Name Type Description Default policy FieldGrowthPolicyStr field growth policy to use required Exceptions: Type Description InvalidParamError field growth policy does not exist Source code in prettyqt/widgets/formlayout.py def set_field_growth_policy ( self , policy : FieldGrowthPolicyStr ): \"\"\"Set field growth policy to use. Args: policy: field growth policy to use Raises: InvalidParamError: field growth policy does not exist \"\"\" if policy not in FIELD_GROWTH_POLICY : raise InvalidParamError ( policy , FIELD_GROWTH_POLICY ) self . setFieldGrowthPolicy ( FIELD_GROWTH_POLICY [ policy ]) set_row_wrap_policy ( self , policy : RowWrapPolicyStr ) Set row wrap policy to use. Parameters: Name Type Description Default policy RowWrapPolicyStr row wrap policy to use required Exceptions: Type Description InvalidParamError row wrap policy does not exist Source code in prettyqt/widgets/formlayout.py def set_row_wrap_policy ( self , policy : RowWrapPolicyStr ): \"\"\"Set row wrap policy to use. Args: policy: row wrap policy to use Raises: InvalidParamError: row wrap policy does not exist \"\"\" if policy not in ROW_WRAP_POLICY : raise InvalidParamError ( policy , ROW_WRAP_POLICY ) self . setRowWrapPolicy ( ROW_WRAP_POLICY [ policy ]) frame Frame ( QFrame ) Source code in prettyqt/widgets/frame.py class Frame ( QtWidgets . QFrame ): def serialize_fields ( self ): return dict ( frame_shadow = self . get_frame_shadow (), frame_shape = self . get_frame_shape (), frame_rect = self . frameRect (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_frame_shadow ( state [ \"frame_shadow\" ]) self . set_frame_shape ( state [ \"frame_shape\" ]) self . setFrameRect ( state [ \"frame_rect\" ]) def set_frame_shadow ( self , style : ShadowStr ): \"\"\"Set frame shadow. Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style is None : return if style not in SHADOW : raise InvalidParamError ( style , SHADOW ) self . setFrameShadow ( SHADOW [ style ]) def get_frame_shadow ( self ) -> ShadowStr | None : \"\"\"Return current frame shadow. Returns: frame style \"\"\" if ( frame_shadow := self . frameShadow ()) == 0 : return None return SHADOW . inverse [ frame_shadow ] def set_frame_shape ( self , shape : FrameShapeStr ): \"\"\"Set frame shape. Args: shape: frame shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in FRAME_SHAPE : raise InvalidParamError ( shape , FRAME_SHAPE ) self . setFrameShape ( FRAME_SHAPE [ shape ]) def get_frame_shape ( self ) -> FrameShapeStr : \"\"\"Return current frame shape. Returns: frame shape \"\"\" return FRAME_SHAPE . inverse [ self . frameShape ()] get_frame_shadow ( self ) -> ShadowStr | None Return current frame shadow. Returns: Type Description ShadowStr | None frame style Source code in prettyqt/widgets/frame.py def get_frame_shadow ( self ) -> ShadowStr | None : \"\"\"Return current frame shadow. Returns: frame style \"\"\" if ( frame_shadow := self . frameShadow ()) == 0 : return None return SHADOW . inverse [ frame_shadow ] get_frame_shape ( self ) -> FrameShapeStr Return current frame shape. Returns: Type Description FrameShapeStr frame shape Source code in prettyqt/widgets/frame.py def get_frame_shape ( self ) -> FrameShapeStr : \"\"\"Return current frame shape. Returns: frame shape \"\"\" return FRAME_SHAPE . inverse [ self . frameShape ()] set_frame_shadow ( self , style : ShadowStr ) Set frame shadow. Parameters: Name Type Description Default style ShadowStr frame style to use required Exceptions: Type Description InvalidParamError style does not exist Source code in prettyqt/widgets/frame.py def set_frame_shadow ( self , style : ShadowStr ): \"\"\"Set frame shadow. Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style is None : return if style not in SHADOW : raise InvalidParamError ( style , SHADOW ) self . setFrameShadow ( SHADOW [ style ]) set_frame_shape ( self , shape : FrameShapeStr ) Set frame shape. Parameters: Name Type Description Default shape FrameShapeStr frame shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/widgets/frame.py def set_frame_shape ( self , shape : FrameShapeStr ): \"\"\"Set frame shape. Args: shape: frame shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in FRAME_SHAPE : raise InvalidParamError ( shape , FRAME_SHAPE ) self . setFrameShape ( FRAME_SHAPE [ shape ]) gesture Gesture ( QGesture ) Source code in prettyqt/widgets/gesture.py class Gesture ( QtWidgets . QGesture ): def get_state ( self ) -> constants . GestureStateStr : \"\"\"Return current state. Returns: state \"\"\" return constants . GESTURE_STATE . inverse [ self . state ()] def get_gesture_type ( self ) -> constants . GestureTypeStr : \"\"\"Return current gesture type. Returns: gesture type \"\"\" return constants . GESTURE_TYPE . inverse [ self . gestureType ()] def get_hot_spot ( self ) -> core . PointF : return core . PointF ( self . hotSpot ()) def set_gesture_cancel_policy ( self , policy : GestureCancelPolicyStr ): \"\"\"Set gesture cancel policy. Args: policy: gesture cancel policy to use Raises: InvalidParamError: gesture cancel policy does not exist \"\"\" if policy not in GESTURE_CANCEL_POLICY : raise InvalidParamError ( policy , GESTURE_CANCEL_POLICY ) self . setGestureCancelPolicy ( GESTURE_CANCEL_POLICY [ policy ]) def get_gesture_cancel_policy ( self ) -> GestureCancelPolicyStr : \"\"\"Return current gesture cancel policy. Returns: gesture cancel policy \"\"\" return GESTURE_CANCEL_POLICY . inverse [ self . gestureCancelPolicy ()] get_gesture_cancel_policy ( self ) -> GestureCancelPolicyStr Return current gesture cancel policy. Returns: Type Description GestureCancelPolicyStr gesture cancel policy Source code in prettyqt/widgets/gesture.py def get_gesture_cancel_policy ( self ) -> GestureCancelPolicyStr : \"\"\"Return current gesture cancel policy. Returns: gesture cancel policy \"\"\" return GESTURE_CANCEL_POLICY . inverse [ self . gestureCancelPolicy ()] get_gesture_type ( self ) -> constants . GestureTypeStr Return current gesture type. Returns: Type Description constants.GestureTypeStr gesture type Source code in prettyqt/widgets/gesture.py def get_gesture_type ( self ) -> constants . GestureTypeStr : \"\"\"Return current gesture type. Returns: gesture type \"\"\" return constants . GESTURE_TYPE . inverse [ self . gestureType ()] get_state ( self ) -> constants . GestureStateStr Return current state. Returns: Type Description constants.GestureStateStr state Source code in prettyqt/widgets/gesture.py def get_state ( self ) -> constants . GestureStateStr : \"\"\"Return current state. Returns: state \"\"\" return constants . GESTURE_STATE . inverse [ self . state ()] set_gesture_cancel_policy ( self , policy : GestureCancelPolicyStr ) Set gesture cancel policy. Parameters: Name Type Description Default policy GestureCancelPolicyStr gesture cancel policy to use required Exceptions: Type Description InvalidParamError gesture cancel policy does not exist Source code in prettyqt/widgets/gesture.py def set_gesture_cancel_policy ( self , policy : GestureCancelPolicyStr ): \"\"\"Set gesture cancel policy. Args: policy: gesture cancel policy to use Raises: InvalidParamError: gesture cancel policy does not exist \"\"\" if policy not in GESTURE_CANCEL_POLICY : raise InvalidParamError ( policy , GESTURE_CANCEL_POLICY ) self . setGestureCancelPolicy ( GESTURE_CANCEL_POLICY [ policy ]) graphicsitem GraphicsItem ( QGraphicsItem ) Source code in prettyqt/widgets/graphicsitem.py class GraphicsItem ( QtWidgets . QGraphicsItem ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def __contains__ ( self , value : QtCore . QPointF ) -> bool : return self . contains ( value ) def __getitem__ ( self , key : int ): return self . data ( key ) def __setitem__ ( self , key : int , value ): self . setData ( key , value ) def serialize_fields ( self ): return dict ( cache_mode = self . get_cache_mode (), accept_drops = self . acceptDrops (), accept_hover_events = self . acceptHoverEvents (), accept_touch_events = self . acceptTouchEvents (), bounding_region_granularity = self . boundingRegionGranularity (), enabled = self . isEnabled (), filters_child_events = self . filtersChildEvents (), opacity = self . opacity (), panel_modality = self . get_panel_modality (), pos = self . pos (), rotation = self . rotation (), scale = self . scale (), selected = self . isSelected (), tool_tip = self . toolTip (), transform_origin_point = self . transformOriginPoint (), visible = self . isVisible (), z_value = self . zValue (), ) def set_focus ( self , reason : constants . FocusReasonStr = \"other\" ): if reason not in constants . FOCUS_REASONS : raise InvalidParamError ( reason , constants . FOCUS_REASONS ) self . setFocus ( constants . FOCUS_REASONS [ reason ]) def colliding_items ( self , mode : constants . ItemSelectionModeStr = \"intersects_shape\" ) -> list [ QtWidgets . QGraphicsItem ]: if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) return self . collidingItems ( constants . ITEM_SELECTION_MODE [ mode ]) def collides_with ( self , item : QtGui . QPainterPath | QtWidgets . QGraphicsItem , mode : constants . ItemSelectionModeStr = \"intersects_shape\" , ) -> bool : if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) if isinstance ( item , QtGui . QPainterPath ): return self . collidesWithPath ( item , constants . ITEM_SELECTION_MODE [ mode ]) else : return self . collidesWithItem ( item , constants . ITEM_SELECTION_MODE [ mode ]) def set_panel_modality ( self , modality : PanelModalityStr ) -> None : \"\"\"Set panel modality. Args: modality: panel modality Raises: InvalidParamError: panel modality does not exist \"\"\" if modality not in PANEL_MODALITY : raise InvalidParamError ( modality , PANEL_MODALITY ) self . setPanelModality ( PANEL_MODALITY [ modality ]) def get_panel_modality ( self ) -> PanelModalityStr : \"\"\"Get the current modality modes as a string. Returns: panel modality \"\"\" return PANEL_MODALITY . inverse [ self . panelModality ()] def set_cache_mode ( self , mode : CacheModeStr ) -> None : \"\"\"Set cache mode. Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODE : raise InvalidParamError ( mode , CACHE_MODE ) self . setCacheMode ( CACHE_MODE [ mode ]) def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Get the current mode modes as a string. Returns: cache mode \"\"\" return CACHE_MODE . inverse [ self . cacheMode ()] def get_shape ( self ) -> gui . PainterPath : return gui . PainterPath ( self . shape ()) def set_scale ( self , scale : tuple [ float , float ] | float ): if isinstance ( scale , float ): self . setScale ( scale ) else : self . setTransform ( gui . Transform . fromScale ( scale [ 0 ], scale [ 1 ]), True ) get_cache_mode ( self ) -> CacheModeStr Get the current mode modes as a string. Returns: Type Description CacheModeStr cache mode Source code in prettyqt/widgets/graphicsitem.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Get the current mode modes as a string. Returns: cache mode \"\"\" return CACHE_MODE . inverse [ self . cacheMode ()] get_panel_modality ( self ) -> PanelModalityStr Get the current modality modes as a string. Returns: Type Description PanelModalityStr panel modality Source code in prettyqt/widgets/graphicsitem.py def get_panel_modality ( self ) -> PanelModalityStr : \"\"\"Get the current modality modes as a string. Returns: panel modality \"\"\" return PANEL_MODALITY . inverse [ self . panelModality ()] set_cache_mode ( self , mode : CacheModeStr ) -> None Set cache mode. Parameters: Name Type Description Default mode CacheModeStr cache mode required Exceptions: Type Description InvalidParamError cache mode does not exist Source code in prettyqt/widgets/graphicsitem.py def set_cache_mode ( self , mode : CacheModeStr ) -> None : \"\"\"Set cache mode. Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODE : raise InvalidParamError ( mode , CACHE_MODE ) self . setCacheMode ( CACHE_MODE [ mode ]) set_panel_modality ( self , modality : PanelModalityStr ) -> None Set panel modality. Parameters: Name Type Description Default modality PanelModalityStr panel modality required Exceptions: Type Description InvalidParamError panel modality does not exist Source code in prettyqt/widgets/graphicsitem.py def set_panel_modality ( self , modality : PanelModalityStr ) -> None : \"\"\"Set panel modality. Args: modality: panel modality Raises: InvalidParamError: panel modality does not exist \"\"\" if modality not in PANEL_MODALITY : raise InvalidParamError ( modality , PANEL_MODALITY ) self . setPanelModality ( PANEL_MODALITY [ modality ]) graphicspixmapitem GraphicsPixmapItem ( QGraphicsPixmapItem ) Source code in prettyqt/widgets/graphicspixmapitem.py class GraphicsPixmapItem ( QtWidgets . QGraphicsPixmapItem ): def serialize_fields ( self ): return dict ( offset = self . offset (), pixmap = self . get_pixmap (), shape_mode = self . get_shape_mode (), transformation_mode = self . get_transformation_mode (), ) def set_transformation_mode ( self , mode : constants . TransformationModeStr ): \"\"\"Set transformation mode. Args: mode: transformation mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in constants . TRANSFORMATION_MODE : raise InvalidParamError ( mode , constants . TRANSFORMATION_MODE ) self . setTransformationMode ( constants . TRANSFORMATION_MODE [ mode ]) def get_transformation_mode ( self ) -> constants . TransformationModeStr : \"\"\"Return current transformation mode. Returns: transformation mode \"\"\" return constants . TRANSFORMATION_MODE . inverse [ self . transformationMode ()] def set_shape_mode ( self , mode : ShapeModeStr ): \"\"\"Set shape mode. Args: mode: shape mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in SHAPE_MODE : raise InvalidParamError ( mode , SHAPE_MODE ) self . setShapeMode ( SHAPE_MODE [ mode ]) def get_shape_mode ( self ) -> ShapeModeStr : \"\"\"Return current shape mode. Returns: shape mode \"\"\" return SHAPE_MODE . inverse [ self . shapeMode ()] def get_pixmap ( self ) -> gui . Pixmap | None : pix = self . pixmap () if pix . isNull (): return None return gui . Pixmap ( pix ) get_shape_mode ( self ) -> ShapeModeStr Return current shape mode. Returns: Type Description ShapeModeStr shape mode Source code in prettyqt/widgets/graphicspixmapitem.py def get_shape_mode ( self ) -> ShapeModeStr : \"\"\"Return current shape mode. Returns: shape mode \"\"\" return SHAPE_MODE . inverse [ self . shapeMode ()] get_transformation_mode ( self ) -> constants . TransformationModeStr Return current transformation mode. Returns: Type Description constants.TransformationModeStr transformation mode Source code in prettyqt/widgets/graphicspixmapitem.py def get_transformation_mode ( self ) -> constants . TransformationModeStr : \"\"\"Return current transformation mode. Returns: transformation mode \"\"\" return constants . TRANSFORMATION_MODE . inverse [ self . transformationMode ()] set_shape_mode ( self , mode : ShapeModeStr ) Set shape mode. Parameters: Name Type Description Default mode ShapeModeStr shape mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicspixmapitem.py def set_shape_mode ( self , mode : ShapeModeStr ): \"\"\"Set shape mode. Args: mode: shape mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in SHAPE_MODE : raise InvalidParamError ( mode , SHAPE_MODE ) self . setShapeMode ( SHAPE_MODE [ mode ]) set_transformation_mode ( self , mode : constants . TransformationModeStr ) Set transformation mode. Parameters: Name Type Description Default mode constants.TransformationModeStr transformation mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicspixmapitem.py def set_transformation_mode ( self , mode : constants . TransformationModeStr ): \"\"\"Set transformation mode. Args: mode: transformation mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in constants . TRANSFORMATION_MODE : raise InvalidParamError ( mode , constants . TRANSFORMATION_MODE ) self . setTransformationMode ( constants . TRANSFORMATION_MODE [ mode ]) graphicsscene GraphicsScene ( QGraphicsScene ) Source code in prettyqt/widgets/graphicsscene.py class GraphicsScene ( QtWidgets . QGraphicsScene ): def serialize_fields ( self ): return dict ( items = self . items (), background_brush = self . get_background_brush (), foreground_brush = self . get_foreground_brush (), item_index_method = self . get_item_index_method (), minimum_render_size = self . minimumRenderSize (), palette = self . get_palette (), bsp_tree_depth = self . bspTreeDepth (), focus_on_touch = self . focusOnTouch (), sticky_focus = self . stickyFocus (), scene_rect = core . RectF ( self . sceneRect ()), font = self . get_font (), ) def __setitem__ ( self , state ): # self.setItem self . setBackgroundBrush ( state [ \"background_brush\" ]) self . setForegroundBrush ( state [ \"foreground_brush\" ]) self . set_item_index_method ( state [ \"item_index_method\" ]) self . setMinimumRenderSize ( state [ \"minimum_render_size\" ]) self . setPalette ( state [ \"palette\" ]) self . setBspTreeDepth ( state [ \"bsp_tree_depth\" ]) self . setFocusOnTouchRelease ( state [ \"focus_on_touch\" ]) self . setStickyFocus ( state [ \"focus_on_touch\" ]) self . setSceneRect ( state [ \"scene_rect\" ]) self . setFont ( state [ \"font\" ]) def __getitem__ ( self , index : int ) -> QtWidgets . QGraphicsItem : return self . items ()[ index ] def get_palette ( self ) -> gui . Palette : return gui . Palette ( self . palette ()) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_background_brush ( self ) -> gui . Brush : return gui . Brush ( self . backgroundBrush ()) def get_foreground_brush ( self ) -> gui . Brush : return gui . Brush ( self . foregroundBrush ()) def add ( self , item ) -> QtWidgets . QGraphicsItem : if isinstance ( item , QtWidgets . QGraphicsItem ): self . addItem ( item ) return item elif isinstance ( item , QtGui . QPixmap ): return self . add_pixmap ( item ) elif isinstance ( item , QtGui . QPainterPath ): return self . add_path ( item ) elif isinstance ( item , QtGui . QPolygonF ): return self . add_polygon ( item ) elif isinstance ( item , QtCore . QRectF ): return self . add_rect ( item ) elif isinstance ( item , QtCore . QLine ): return self . add_line ( item ) elif isinstance ( item , str ): return self . add_text ( item ) elif isinstance ( item , QtWidgets . QWidget ): return self . add_widget ( item ) else : raise TypeError ( item ) def add_pixmap ( self , pixmap : QtGui . QPixmap ) -> widgets . GraphicsPixmapItem : g_item = widgets . GraphicsPixmapItem () g_item . setPixmap ( pixmap ) self . addItem ( g_item ) return g_item def add_polygon ( self , polygon : QtGui . QPolygonF | QtGui . QPolygon , pen : QtGui . QPen | None = None , brush : QtGui . QBrush | None = None , ) -> widgets . GraphicsPolygonItem : if isinstance ( polygon , QtGui . QPolygon ): polygon = gui . PolygonF ( polygon ) g_item = widgets . GraphicsPolygonItem () g_item . setPolygon ( polygon ) if brush is not None : g_item . setBrush ( brush ) if pen is not None : g_item . setPen ( pen ) self . addItem ( g_item ) return g_item def add_path ( self , path : QtGui . QPainterPath , pen : QtGui . QPen | None = None , brush : QtGui . QBrush | None = None , ) -> widgets . GraphicsPathItem : g_item = widgets . GraphicsPathItem () g_item . setPath ( path ) if brush is not None : g_item . setBrush ( brush ) if pen is not None : g_item . setPen ( pen ) self . addItem ( g_item ) return g_item def add_rect ( self , rect : types . RectType | types . RectFType , pen : QtGui . QPen | None = None , brush : QtGui . QBrush | None = None , ) -> widgets . GraphicsRectItem : if isinstance ( rect , QtCore . QRect ): rect = core . RectF ( rect ) elif isinstance ( rect , tuple ): rect = core . RectF ( * rect ) g_item = widgets . GraphicsRectItem () g_item . setRect ( rect ) if brush is not None : g_item . setBrush ( brush ) if pen is not None : g_item . setPen ( pen ) self . addItem ( g_item ) return g_item def add_line ( self , line : QtCore . QLineF | QtCore . QLine | tuple [ float , float , float , float ], pen : QtGui . QPen | None = None , ) -> widgets . GraphicsLineItem : if isinstance ( line , QtCore . QLine ): line = core . LineF ( line ) elif isinstance ( line , tuple ): line = core . LineF ( * line ) g_item = widgets . GraphicsLineItem () g_item . setLine ( line ) if pen is not None : g_item . setPen ( pen ) self . addItem ( g_item ) return g_item def add_ellipse ( self , ellipse : types . RectType | types . RectFType , pen : QtGui . QPen | None = None , brush : QtGui . QBrush | None = None , ) -> widgets . GraphicsEllipseItem : if isinstance ( ellipse , QtCore . QRect ): ellipse = core . RectF ( ellipse ) elif isinstance ( ellipse , tuple ): ellipse = core . RectF ( * ellipse ) g_item = widgets . GraphicsEllipseItem () g_item . setRect ( ellipse ) if brush is not None : g_item . setBrush ( brush ) if pen is not None : g_item . setPen ( pen ) self . addItem ( g_item ) return g_item def add_text ( self , text : str , font : QtGui . QFont | None = None ) -> widgets . GraphicsTextItem : g_item = widgets . GraphicsTextItem () g_item . setPlainText ( text ) if font is not None : g_item . setFont ( font ) self . addItem ( g_item ) return g_item def add_simple_text ( self , text : str , font : QtGui . QFont | None = None ) -> widgets . GraphicsSimpleTextItem : g_item = widgets . GraphicsSimpleTextItem () g_item . setText ( text ) if font is not None : g_item . setFont ( font ) self . addItem ( g_item ) return g_item def add_widget ( self , widget : QtWidgets . QWidget ) -> widgets . GraphicsProxyWidget : g_item = widgets . GraphicsProxyWidget () g_item . setWidget ( widget ) self . addItem ( g_item ) return g_item def colliding_items ( self , item : QtWidgets . QGraphicsItem , mode : constants . ItemSelectionModeStr = \"intersects_shape\" , ) -> list [ QtWidgets . QGraphicsItem ]: if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) return self . collidingItems ( item , constants . ITEM_SELECTION_MODE [ mode ]) def add_item_group ( self , * items : QtWidgets . QGraphicsItem ) -> widgets . GraphicsItemGroup : group = widgets . GraphicsItemGroup () for item in items : group . addToGroup ( item ) return group def set_item_index_method ( self , method : ItemIndexMethodStr ): \"\"\"Set item index method. Args: method: item index method to use Raises: InvalidParamError: invalid item index method \"\"\" if method not in ITEM_INDEX_METHOD : raise InvalidParamError ( method , ITEM_INDEX_METHOD ) self . setItemIndexMethod ( ITEM_INDEX_METHOD [ method ]) def get_item_index_method ( self ) -> ItemIndexMethodStr : \"\"\"Return item index method. Returns: item index method \"\"\" return ITEM_INDEX_METHOD . inverse [ self . itemIndexMethod ()] get_item_index_method ( self ) -> ItemIndexMethodStr Return item index method. Returns: Type Description ItemIndexMethodStr item index method Source code in prettyqt/widgets/graphicsscene.py def get_item_index_method ( self ) -> ItemIndexMethodStr : \"\"\"Return item index method. Returns: item index method \"\"\" return ITEM_INDEX_METHOD . inverse [ self . itemIndexMethod ()] set_item_index_method ( self , method : ItemIndexMethodStr ) Set item index method. Parameters: Name Type Description Default method ItemIndexMethodStr item index method to use required Exceptions: Type Description InvalidParamError invalid item index method Source code in prettyqt/widgets/graphicsscene.py def set_item_index_method ( self , method : ItemIndexMethodStr ): \"\"\"Set item index method. Args: method: item index method to use Raises: InvalidParamError: invalid item index method \"\"\" if method not in ITEM_INDEX_METHOD : raise InvalidParamError ( method , ITEM_INDEX_METHOD ) self . setItemIndexMethod ( ITEM_INDEX_METHOD [ method ]) graphicsview GraphicsView ( QGraphicsView ) Source code in prettyqt/widgets/graphicsview.py class GraphicsView ( QtWidgets . QGraphicsView ): def serialize_fields ( self ): return dict ( scene = self . scene (), background_brush = self . get_background_brush (), foreground_brush = self . get_foreground_brush (), transformation_anchor = self . get_transformation_anchor (), resize_anchor = self . get_resize_anchor (), viewport_update_mode = self . get_viewport_update_mode (), drag_mode = self . get_drag_mode (), rubberband_selection_mode = self . get_rubberband_selection_mode (), scene_rect = core . RectF ( self . sceneRect ()), cache_mode = self . get_cache_mode (), is_interactive = self . isInteractive (), ) def __setitem__ ( self , state ): super () . __setstate__ ( state ) self . setScene ( state [ \"scene\" ]) self . setBackgroundBrush ( state [ \"background_brush\" ]) self . setForegroundBrush ( state [ \"foreground_brush\" ]) self . set_transformation_anchor ( state [ \"transformation_anchor\" ]) self . set_resize_anchor ( state [ \"resicze_anchor\" ]) self . set_viewport_update_mode ( state [ \"viewport_update_mode\" ]) self . set_drag_mode ( state [ \"drag_mode\" ]) self . set_rubberband_selection_mode ( state [ \"rubberband_selection_mode\" ]) self . setSceneRect ( state [ \"scene_rect\" ]) self . set_cache_mode ( state [ \"cache_mode\" ]) self . setInteractive ( state [ \"is_interactive\" ]) def __getitem__ ( self , index : int ) -> QtWidgets . QGraphicsItem : return self . items ()[ index ] def get_background_brush ( self ) -> gui . Brush : return gui . Brush ( self . backgroundBrush ()) def get_foreground_brush ( self ) -> gui . Brush : return gui . Brush ( self . foregroundBrush ()) def invalidate_scene ( self , rect : QtCore . QRectF , layer : widgets . graphicsscene . SceneLayerStr = \"all\" ): if layer not in widgets . graphicsscene . SCENE_LAYER : raise InvalidParamError ( layer , widgets . graphicsscene . SCENE_LAYER ) self . invalidateScene ( rect , widgets . graphicsscene . SCENE_LAYER [ layer ]) def set_transformation_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during transformations. Args: mode: transformation anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setTransformationAnchor ( VIEWPORT_ANCHOR [ mode ]) def get_transformation_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current transformation anchor. Returns: viewport anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . transformationAnchor ()] def set_resize_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during resizes. Args: mode: resize anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setResizeAnchor ( VIEWPORT_ANCHOR [ mode ]) def get_resize_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current resize anchor. Returns: resize anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . resizeAnchor ()] def set_viewport_update_mode ( self , mode : ViewportUpdateModeStr ): \"\"\"Set how the viewport should update its contents. Args: mode: viewport update mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_UPDATE_MODE : raise InvalidParamError ( mode , VIEWPORT_UPDATE_MODE ) self . setViewportUpdateMode ( VIEWPORT_UPDATE_MODE [ mode ]) def get_viewport_update_mode ( self ) -> ViewportUpdateModeStr : \"\"\"Return current viewport update mode. Returns: viewport update mode \"\"\" return VIEWPORT_UPDATE_MODE . inverse [ self . viewportUpdateMode ()] def set_drag_mode ( self , mode : DragModeStr ): \"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed. Args: mode: drag mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_MODE : raise InvalidParamError ( mode , DRAG_MODE ) self . setDragMode ( DRAG_MODE [ mode ]) def get_drag_mode ( self ) -> DragModeStr : \"\"\"Return current drag mode. Returns: drag mode \"\"\" return DRAG_MODE . inverse [ self . dragMode ()] def set_rubberband_selection_mode ( self , mode : constants . ItemSelectionModeStr ): \"\"\"Set the behavior for selecting items with a rubber band selection rectangle. Args: mode: rubberband selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) self . setRubberBandSelectionMode ( constants . ITEM_SELECTION_MODE [ mode ]) def get_rubberband_selection_mode ( self ) -> constants . ItemSelectionModeStr : \"\"\"Return current rubberband selection mode. Returns: rubberband selection mode \"\"\" return constants . ITEM_SELECTION_MODE . inverse [ self . rubberBandSelectionMode ()] def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set the cache mode. Args: mode: cache mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ]) def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Return current cache mode. Returns: cache mode \"\"\" return CACHE_MODES . inverse [ self . cacheMode ()] def set_optimization_flags ( self , * items : OptimizationFlagStr ): for item in items : if item not in OPTIMIZATION_FLAGS : raise InvalidParamError ( item , OPTIMIZATION_FLAGS ) flags = helpers . merge_flags ( items , OPTIMIZATION_FLAGS ) self . setOptimizationFlags ( flags ) def get_optimization_flags ( self ) -> list [ OptimizationFlagStr ]: return [ k for k , v in OPTIMIZATION_FLAGS . items () if v & self . optimizationFlags ()] get_cache_mode ( self ) -> CacheModeStr Return current cache mode. Returns: Type Description CacheModeStr cache mode Source code in prettyqt/widgets/graphicsview.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Return current cache mode. Returns: cache mode \"\"\" return CACHE_MODES . inverse [ self . cacheMode ()] get_drag_mode ( self ) -> DragModeStr Return current drag mode. Returns: Type Description DragModeStr drag mode Source code in prettyqt/widgets/graphicsview.py def get_drag_mode ( self ) -> DragModeStr : \"\"\"Return current drag mode. Returns: drag mode \"\"\" return DRAG_MODE . inverse [ self . dragMode ()] get_resize_anchor ( self ) -> ViewportAnchorStr Return current resize anchor. Returns: Type Description ViewportAnchorStr resize anchor Source code in prettyqt/widgets/graphicsview.py def get_resize_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current resize anchor. Returns: resize anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . resizeAnchor ()] get_rubberband_selection_mode ( self ) -> constants . ItemSelectionModeStr Return current rubberband selection mode. Returns: Type Description constants.ItemSelectionModeStr rubberband selection mode Source code in prettyqt/widgets/graphicsview.py def get_rubberband_selection_mode ( self ) -> constants . ItemSelectionModeStr : \"\"\"Return current rubberband selection mode. Returns: rubberband selection mode \"\"\" return constants . ITEM_SELECTION_MODE . inverse [ self . rubberBandSelectionMode ()] get_transformation_anchor ( self ) -> ViewportAnchorStr Return current transformation anchor. Returns: Type Description ViewportAnchorStr viewport anchor Source code in prettyqt/widgets/graphicsview.py def get_transformation_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current transformation anchor. Returns: viewport anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . transformationAnchor ()] get_viewport_update_mode ( self ) -> ViewportUpdateModeStr Return current viewport update mode. Returns: Type Description ViewportUpdateModeStr viewport update mode Source code in prettyqt/widgets/graphicsview.py def get_viewport_update_mode ( self ) -> ViewportUpdateModeStr : \"\"\"Return current viewport update mode. Returns: viewport update mode \"\"\" return VIEWPORT_UPDATE_MODE . inverse [ self . viewportUpdateMode ()] set_cache_mode ( self , mode : CacheModeStr ) Set the cache mode. Parameters: Name Type Description Default mode CacheModeStr cache mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set the cache mode. Args: mode: cache mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ]) set_drag_mode ( self , mode : DragModeStr ) Set the behavior for dragging the mouse while the left mouse button is pressed. Parameters: Name Type Description Default mode DragModeStr drag mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_drag_mode ( self , mode : DragModeStr ): \"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed. Args: mode: drag mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_MODE : raise InvalidParamError ( mode , DRAG_MODE ) self . setDragMode ( DRAG_MODE [ mode ]) set_resize_anchor ( self , mode : ViewportAnchorStr ) Set how the view should position the scene during resizes. Parameters: Name Type Description Default mode ViewportAnchorStr resize anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_resize_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during resizes. Args: mode: resize anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setResizeAnchor ( VIEWPORT_ANCHOR [ mode ]) set_rubberband_selection_mode ( self , mode : constants . ItemSelectionModeStr ) Set the behavior for selecting items with a rubber band selection rectangle. Parameters: Name Type Description Default mode constants.ItemSelectionModeStr rubberband selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_rubberband_selection_mode ( self , mode : constants . ItemSelectionModeStr ): \"\"\"Set the behavior for selecting items with a rubber band selection rectangle. Args: mode: rubberband selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) self . setRubberBandSelectionMode ( constants . ITEM_SELECTION_MODE [ mode ]) set_transformation_anchor ( self , mode : ViewportAnchorStr ) Set how the view should position the scene during transformations. Parameters: Name Type Description Default mode ViewportAnchorStr transformation anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_transformation_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during transformations. Args: mode: transformation anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setTransformationAnchor ( VIEWPORT_ANCHOR [ mode ]) set_viewport_update_mode ( self , mode : ViewportUpdateModeStr ) Set how the viewport should update its contents. Parameters: Name Type Description Default mode ViewportUpdateModeStr viewport update mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_viewport_update_mode ( self , mode : ViewportUpdateModeStr ): \"\"\"Set how the viewport should update its contents. Args: mode: viewport update mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_UPDATE_MODE : raise InvalidParamError ( mode , VIEWPORT_UPDATE_MODE ) self . setViewportUpdateMode ( VIEWPORT_UPDATE_MODE [ mode ]) graphicswidget GraphicsWidget ( QGraphicsWidget ) Source code in prettyqt/widgets/graphicswidget.py class GraphicsWidget ( QtWidgets . QGraphicsWidget ): def serialize_fields ( self ): return dict ( autofill_background = self . autoFillBackground (), font = self . get_font (), window_title = self . windowTitle (), preferred_size = self . preferredSize (), maximum_size = self . maximumSize (), palette = self . get_palette (), focus_policy = self . get_focus_policy (), ) def set_layout ( self , layout : LayoutStr | QtWidgets . QGraphicsLayout | None ): if layout is None : return if isinstance ( layout , QtWidgets . QGraphicsLayout ): self . box = layout elif layout == \"grid\" : self . box = widgets . GraphicsGridLayout () elif layout == \"anchor\" : self . box = widgets . GraphicsAnchorLayout () elif layout in ( \"horizontal\" , \"vertical\" ): self . box = widgets . GraphicsLinearLayout ( layout ) else : raise ValueError ( \"Invalid Layout\" ) self . setLayout ( self . box ) def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy: Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ]) def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return way the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()] def window_frame_section_at ( self , point : types . PointType ) -> constants . WindowFrameSectionStr : \"\"\"Return the window frame section at given position. Returns: str: Window frame section \"\"\" if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) return constants . WINDOW_FRAME_SECTION . inverse [ self . windowFrameSectionAt ( point )] def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_palette ( self ) -> gui . Palette : return gui . Palette ( self . palette ()) get_focus_policy ( self ) -> constants . FocusPolicyStr Return way the widget accepts keyboard focus. Returns: Type Description str Focus policy Source code in prettyqt/widgets/graphicswidget.py def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return way the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()] set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None Set the way the widget accepts keyboard focus. Parameters: Name Type Description Default policy constants.FocusPolicyStr Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/graphicswidget.py def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy: Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ]) window_frame_section_at ( self , point : types . PointType ) -> constants . WindowFrameSectionStr Return the window frame section at given position. Returns: Type Description str Window frame section Source code in prettyqt/widgets/graphicswidget.py def window_frame_section_at ( self , point : types . PointType ) -> constants . WindowFrameSectionStr : \"\"\"Return the window frame section at given position. Returns: str: Window frame section \"\"\" if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) return constants . WINDOW_FRAME_SECTION . inverse [ self . windowFrameSectionAt ( point )] gridlayout GridLayout ( QGridLayout ) Source code in prettyqt/widgets/gridlayout.py class GridLayout ( QtWidgets . QGridLayout ): def __getitem__ ( self , idx : tuple [ int , int ] | int | str ) -> QtWidgets . QWidget | QtWidgets . QLayout | None : if isinstance ( idx , tuple ): item = self . itemAtPosition ( * idx ) elif isinstance ( idx , int ): item = self . itemAt ( idx ) else : return self . find_child ( QtCore . QObject , idx ) widget = item . widget () if widget is None : return item . layout () return widget def __setitem__ ( self , idx : tuple [ int | slice , int | slice ], value : QtWidgets . QWidget | QtWidgets . QLayout | QtWidgets . QLayoutItem , ): row , col = idx rowspan = row . stop - row . start + 1 if isinstance ( row , slice ) else 1 colspan = col . stop - col . start + 1 if isinstance ( col , slice ) else 1 rowstart = row . start if isinstance ( row , slice ) else row colstart = col . start if isinstance ( col , slice ) else col self . add ( value , rowstart , colstart , rowspan , colspan ) def serialize_fields ( self ): widgets = [] positions = [] for i , item in enumerate ( list ( self )): widgets . append ( item ) positions . append ( self . getItemPosition ( i )) return dict ( widgets = widgets , positions = positions ) def __setstate__ ( self , state ): for i , ( item , pos ) in enumerate ( zip ( state [ \"widgets\" ], state [ \"positions\" ])): x , y , w , h = pos self [ x : x + w - 1 , y : y + h - 1 ] = item def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __iter__ ( self ) -> Iterator [ QtWidgets . QWidget | QtWidgets . QLayout ]: return iter ( item for i in range ( self . count ()) if ( item := self [ i ]) is not None ) def __add__ ( self , other : ( tuple | list | QtWidgets . QWidget | QtWidgets . QLayout | QtWidgets . QLayoutItem ), ): if isinstance ( other , ( tuple , list )): for i , control in enumerate ( other ): self [ self . rowCount (), i ] = other # type: ignore else : self [ self . rowCount (), 0 : self . columnCount () - 1 ] = other return self def add ( self , item : QtWidgets . QWidget | QtWidgets . QLayout | QtWidgets . QLayoutItem , rowstart : int , colstart : int , rowspan : int = 1 , colspan : int = 1 , ): if isinstance ( item , QtWidgets . QWidget ): self . addWidget ( item , rowstart , colstart , rowspan , colspan ) elif isinstance ( item , QtWidgets . QLayout ): self . addLayout ( item , rowstart , colstart , rowspan , colspan ) else : self . addItem ( item , rowstart , colstart , rowspan , colspan ) def append ( self , item : QtWidgets . QWidget | QtWidgets . QLayout | QtWidgets . QLayoutItem ): self [ self . rowCount (), 0 : self . columnCount () - 1 ] = item def set_origin_corner ( self , corner : constants . CornerStr ): \"\"\"Set the origin corner. Args: corner: origin corner Raises: InvalidParamError: corner does not exist \"\"\" if corner not in constants . CORNER : raise InvalidParamError ( corner , constants . CORNER ) self . setOriginCorner ( constants . CORNER [ corner ]) def get_origin_corner ( self ) -> constants . CornerStr : \"\"\"Return current origin corner. Returns: origin corner \"\"\" return constants . CORNER . inverse [ self . originCorner ()] get_origin_corner ( self ) -> constants . CornerStr Return current origin corner. Returns: Type Description constants.CornerStr origin corner Source code in prettyqt/widgets/gridlayout.py def get_origin_corner ( self ) -> constants . CornerStr : \"\"\"Return current origin corner. Returns: origin corner \"\"\" return constants . CORNER . inverse [ self . originCorner ()] set_origin_corner ( self , corner : constants . CornerStr ) Set the origin corner. Parameters: Name Type Description Default corner constants.CornerStr origin corner required Exceptions: Type Description InvalidParamError corner does not exist Source code in prettyqt/widgets/gridlayout.py def set_origin_corner ( self , corner : constants . CornerStr ): \"\"\"Set the origin corner. Args: corner: origin corner Raises: InvalidParamError: corner does not exist \"\"\" if corner not in constants . CORNER : raise InvalidParamError ( corner , constants . CORNER ) self . setOriginCorner ( constants . CORNER [ corner ]) headerview HeaderView ( QHeaderView ) Source code in prettyqt/widgets/headerview.py class HeaderView ( QtWidgets . QHeaderView ): section_vis_changed = core . Signal ( int , bool ) section_resized_by_user = core . Signal ( int , int , int ) def __init__ ( self , orientation : constants . OrientationStr | QtCore . Qt . Orientation , parent : QtWidgets . QWidget | None = None , ): if isinstance ( orientation , QtCore . Qt . Orientation ): ori = orientation else : ori = constants . ORIENTATION [ orientation ] super () . __init__ ( ori , parent = parent ) self . setSectionsMovable ( True ) self . setSectionsClickable ( True ) self . sectionResized . connect ( self . sectionResizeEvent ) self . _handle_section_is_pressed = False self . _widget_name = parent . get_id () if parent is not None else \"\" def mousePressEvent ( self , e ): super () . mousePressEvent ( e ) self . _handle_section_is_pressed = self . cursor () . shape () == QtCore . Qt . SplitHCursor def mouseReleaseEvent ( self , e ): super () . mouseReleaseEvent ( e ) self . _handle_section_is_pressed = False def sectionResizeEvent ( self , logical_index , old_size , new_size ): if self . _handle_section_is_pressed : self . section_resized_by_user . emit ( logical_index , old_size , new_size ) def generate_header_id ( self ): # return f\"{self._widget_name}.state\" column_names = \",\" . join ( self . get_section_labels ()) columns_hash = hashlib . md5 ( column_names . encode ()) . hexdigest () return f \" { type ( self ) . __name__ } _ { columns_hash } .state\" def save_state ( self , settings : core . Settings | None = None , key : str | None = None ): settings = core . Settings () if settings is None else settings key = self . generate_header_id () if key is None else key settings . set_value ( key , self . saveState ()) def load_state ( self , settings : core . Settings | None = None , key : str | None = None ) -> bool : settings = core . Settings () if settings is None else settings key = self . generate_header_id () if key is None else key state = settings . get ( key , None ) if state is not None : if isinstance ( state , str ): state = state . encode () self . restoreState ( state ) return True return False def resize_sections ( self , mode : ModeStr ): self . resizeSections ( MODES [ mode ]) @deprecated ( reason = \"This method is deprecated, use set_resize_mode instead.\" ) def resize_mode ( self , mode : ModeStr , col : int | None = None ): self . set_resize_mode ( mode , col ) def set_resize_mode ( self , mode : ModeStr , col : int | None = None ): if mode not in MODES : raise InvalidParamError ( mode , MODES ) if col is None : self . setSectionResizeMode ( MODES [ mode ]) else : self . setSectionResizeMode ( col , MODES [ mode ]) def get_section_labels ( self ) -> list [ str ]: model = self . model () return [ model . headerData ( i , constants . HORIZONTAL , constants . DISPLAY_ROLE # type: ignore ) for i in range ( self . count ()) ] def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) actions = self . get_header_actions () menu . add_actions ( actions ) menu . exec_ ( self . mapToGlobal ( event . position ())) def get_header_actions ( self ) -> list [ widgets . Action ]: actions = list () labels = self . get_section_labels ()[ 1 :] for i , header_label in enumerate ( labels , start = 1 ): val = not self . isSectionHidden ( i ) action = widgets . Action ( text = header_label , checkable = True , checked = val ) fn = functools . partial ( self . set_section_hidden , i = i , hide = val ) action . triggered . connect ( fn ) actions . append ( action ) return actions def set_section_hidden ( self , i : int , hide : bool ): self . section_vis_changed . emit ( i , hide ) self . setSectionHidden ( i , hide ) def set_sizes ( self , sizes : Iterable [ int | None ]): for i , size in enumerate ( sizes ): if size is not None : self . resizeSection ( i , size ) def set_default_section_size ( self , size : int | None ): if size is None : self . resetDefaultSectionSize () else : self . setDefaultSectionSize ( size ) def stretch_last_section ( self , stretch : bool = True ): self . setStretchLastSection ( stretch ) contextMenuEvent ( self , event ) Context menu for our files tree. Source code in prettyqt/widgets/headerview.py def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) actions = self . get_header_actions () menu . add_actions ( actions ) menu . exec_ ( self . mapToGlobal ( event . position ())) mousePressEvent ( self , e ) mousePressEvent(self, e: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/widgets/headerview.py def mousePressEvent ( self , e ): super () . mousePressEvent ( e ) self . _handle_section_is_pressed = self . cursor () . shape () == QtCore . Qt . SplitHCursor mouseReleaseEvent ( self , e ) mouseReleaseEvent(self, e: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/widgets/headerview.py def mouseReleaseEvent ( self , e ): super () . mouseReleaseEvent ( e ) self . _handle_section_is_pressed = False inputdialog InputDialog ( QInputDialog ) Source code in prettyqt/widgets/inputdialog.py class InputDialog ( QtWidgets . QInputDialog ): @classmethod def get_int ( cls , title : str = \"\" , label : str = \"\" , icon : types . IconType = None , ) -> int | None : par = widgets . Dialog () par . set_icon ( icon ) v = cls . getInt ( par , title , label , value = 0 ) return v [ 0 ] if v [ 1 ] else None @classmethod def get_float ( cls , title : str = \"\" , label : str = \"\" , icon : types . IconType = None , ) -> float | None : par = widgets . Dialog () par . set_icon ( icon ) v = cls . getDouble ( par , title , label , value = 0.0 ) return v [ 0 ] if v [ 1 ] else None @classmethod def get_text ( cls , title : str = \"\" , label : str = \"\" , icon : types . IconType = None , default_value : str = \"\" , echo_mode : widgets . lineedit . EchoModeStr = \"normal\" , ) -> str | None : par = widgets . Dialog () par . set_icon ( icon ) if echo_mode not in widgets . lineedit . ECHO_MODE : raise InvalidParamError ( echo_mode , widgets . lineedit . ECHO_MODE ) v = cls . getText ( par , title , label , widgets . lineedit . ECHO_MODE [ echo_mode ], default_value ) return v [ 0 ] if v [ 1 ] else None @classmethod def get_item ( cls , items : list [ str ], title : str = \"\" , label : str = \"\" , icon : types . IconType = None , editable : bool = False , ) -> str | None : par = widgets . Dialog () par . set_icon ( icon ) v = cls . getItem ( par , title , label , items , editable = editable , current = 0 ) return v [ 0 ] if v [ 1 ] else None def set_text_echo_mode ( self , mode : widgets . lineedit . EchoModeStr ): \"\"\"Set text echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in widgets . lineedit . ECHO_MODE : raise InvalidParamError ( mode , widgets . lineedit . ECHO_MODE ) self . setTextEchoMode ( widgets . lineedit . ECHO_MODE [ mode ]) def get_text_echo_mode ( self ) -> widgets . lineedit . EchoModeStr : \"\"\"Return text echo mode. Returns: echo mode \"\"\" return widgets . lineedit . ECHO_MODE . inverse [ self . textEchoMode ()] def set_input_mode ( self , mode : InputModeStr ): \"\"\"Set input mode. Args: mode: input mode to use Raises: InvalidParamError: invalid input mode \"\"\" if mode not in INPUT_MODE : raise InvalidParamError ( mode , INPUT_MODE ) self . setInputMode ( INPUT_MODE [ mode ]) def get_input_mode ( self ) -> InputModeStr : \"\"\"Return input mode. Returns: input mode \"\"\" return INPUT_MODE . inverse [ self . inputMode ()] get_input_mode ( self ) -> InputModeStr Return input mode. Returns: Type Description InputModeStr input mode Source code in prettyqt/widgets/inputdialog.py def get_input_mode ( self ) -> InputModeStr : \"\"\"Return input mode. Returns: input mode \"\"\" return INPUT_MODE . inverse [ self . inputMode ()] get_text_echo_mode ( self ) -> widgets . lineedit . EchoModeStr Return text echo mode. Returns: Type Description widgets.lineedit.EchoModeStr echo mode Source code in prettyqt/widgets/inputdialog.py def get_text_echo_mode ( self ) -> widgets . lineedit . EchoModeStr : \"\"\"Return text echo mode. Returns: echo mode \"\"\" return widgets . lineedit . ECHO_MODE . inverse [ self . textEchoMode ()] set_input_mode ( self , mode : InputModeStr ) Set input mode. Parameters: Name Type Description Default mode InputModeStr input mode to use required Exceptions: Type Description InvalidParamError invalid input mode Source code in prettyqt/widgets/inputdialog.py def set_input_mode ( self , mode : InputModeStr ): \"\"\"Set input mode. Args: mode: input mode to use Raises: InvalidParamError: invalid input mode \"\"\" if mode not in INPUT_MODE : raise InvalidParamError ( mode , INPUT_MODE ) self . setInputMode ( INPUT_MODE [ mode ]) set_text_echo_mode ( self , mode : widgets . lineedit . EchoModeStr ) Set text echo mode. Parameters: Name Type Description Default mode widgets.lineedit.EchoModeStr echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/inputdialog.py def set_text_echo_mode ( self , mode : widgets . lineedit . EchoModeStr ): \"\"\"Set text echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in widgets . lineedit . ECHO_MODE : raise InvalidParamError ( mode , widgets . lineedit . ECHO_MODE ) self . setTextEchoMode ( widgets . lineedit . ECHO_MODE [ mode ]) label Label ( QLabel ) Source code in prettyqt/widgets/label.py class Label ( QtWidgets . QLabel ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . openExternalLinks () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . text () !r} )\" def serialize_fields ( self ): pixmap = gui . Pixmap ( self . pixmap ()) return dict ( text = self . text (), scaled_contents = self . hasScaledContents (), indent = self . indent (), margin = self . margin (), text_format = self . get_text_format (), pixmap = pixmap if pixmap else None , open_external_links = self . openExternalLinks (), has_selected_text = self . hasSelectedText (), selected_text = self . selectedText (), alignment = ( self . get_horizontal_alignment (), self . get_vertical_alignment ()), word_wrap = self . wordWrap (), text_interaction_flags = self . get_text_interaction (), ) def __setstate__ ( self , state ): self . setText ( state . get ( \"text\" , \"\" )) self . setIndent ( state . get ( \"indent\" , - 1 )) self . setMargin ( state . get ( \"margin\" , 0 )) self . setWordWrap ( state . get ( \"word_wrap\" , 0 )) self . set_text_format ( state . get ( \"text_format\" , 0 )) # self.setPixmap(state.get(\"pixmap\")) self . setOpenExternalLinks ( state . get ( \"open_external_links\" , False )) self . set_alignment ( * state . get ( \"alignment\" )) self . setScaledContents ( state [ \"scaled_contents\" ]) self . setWordWrap ( state [ \"word_wrap\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def allow_links ( self ) -> Label : # self.setText(\"<a href=\\\"http://example.com/\\\">Click Here!</a>\") self . setTextFormat ( QtCore . Qt . TextFormat . RichText ) self . setTextInteractionFlags ( QtCore . Qt . TextInteractionFlag . TextBrowserInteraction # type: ignore ) self . setOpenExternalLinks ( True ) return self def set_alignment ( self , horizontal : constants . HorizontalAlignmentStr | None = None , vertical : constants . VerticalAlignmentStr | None = None , ): \"\"\"Set the alignment of the label's contents.\"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setAlignment ( flag ) return self def get_horizontal_alignment ( self ) -> constants . HorizontalAlignmentStr : align = self . alignment () if align & constants . ALIGN_RIGHT : # type: ignore return \"right\" elif align & constants . ALIGN_H_CENTER : # type: ignore return \"center\" elif align & constants . ALIGN_JUSTIFY : # type: ignore return \"justify\" else : return \"left\" def get_vertical_alignment ( self ) -> constants . VerticalAlignmentStr : align = self . alignment () if align & constants . ALIGN_TOP : # type: ignore return \"top\" elif align & constants . ALIGN_BOTTOM : # type: ignore return \"bottom\" elif align & constants . ALIGN_BASELINE : # type: ignore return \"baseline\" else : return \"center\" def set_indent ( self , indent : int ) -> Label : \"\"\"Set the label's text indent in pixels.\"\"\" self . setIndent ( indent ) return self def set_text_format ( self , text_format : TextFormatStr ) -> Label : \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) return self def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] def set_text_interaction ( self , * types : TextInteractionStr ) -> Label : \"\"\"Set the text interaction mode. Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self def get_text_interaction ( self ) -> list [ TextInteractionStr ]: \"\"\"Return current text interaction mode. Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()] def set_text ( self , text : str ) -> Label : \"\"\"Set the label's text.\"\"\" self . setText ( text ) return self def set_bold ( self , bold : bool = True ) -> Label : font = self . font () font . setBold ( bold ) self . setFont ( font ) return self def set_italic ( self , italic : bool = True ) -> Label : font = self . font () font . setItalic ( italic ) self . setFont ( font ) return self def set_point_size ( self , size : int ) -> Label : font = self . font () font . setPointSize ( size ) self . setFont ( font ) return self def set_weight ( self , weight : gui . font . WeightStr ) -> Label : \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) font = self . font () font . setWeight ( gui . font . WEIGHT [ weight ]) self . setFont ( font ) return self def set_color ( self , color : types . ColorType ) -> Label : with self . edit_stylesheet () as ss : if color is None : ss . color . setValue ( \"\" ) else : color = colors . get_color ( color ) ss . color . setValue ( color . name ()) return self def set_image ( self , path : types . PathType , width : int = 300 ) -> Label : self . setScaledContents ( True ) self . set_alignment ( horizontal = \"center\" ) self . setText ( \"<html><head/><body><p>\" f \"<img src= { os . fspath ( path ) !r} width= { str ( width ) !r} />\" \"</p></body></html>\" ) return self @classmethod def image_from_path ( cls , path : types . PathType , parent : QtWidgets . QWidget | None = None ) -> Label : pixmap = gui . Pixmap . from_file ( path ) label = cls ( parent = parent ) label . setPixmap ( pixmap ) label . resize ( pixmap . width (), pixmap . height ()) return label get_text_format ( self ) -> TextFormatStr Return current text format. Returns: Type Description TextFormatStr text format Source code in prettyqt/widgets/label.py def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] get_text_interaction ( self ) -> list [ TextInteractionStr ] Return current text interaction mode. Returns: Type Description list[TextInteractionStr] list of text interaction modes Source code in prettyqt/widgets/label.py def get_text_interaction ( self ) -> list [ TextInteractionStr ]: \"\"\"Return current text interaction mode. Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()] set_alignment ( self , horizontal : constants . HorizontalAlignmentStr | None = None , vertical : constants . VerticalAlignmentStr | None = None ) Set the alignment of the label's contents. Source code in prettyqt/widgets/label.py def set_alignment ( self , horizontal : constants . HorizontalAlignmentStr | None = None , vertical : constants . VerticalAlignmentStr | None = None , ): \"\"\"Set the alignment of the label's contents.\"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setAlignment ( flag ) return self set_indent ( self , indent : int ) -> Label Set the label's text indent in pixels. Source code in prettyqt/widgets/label.py def set_indent ( self , indent : int ) -> Label : \"\"\"Set the label's text indent in pixels.\"\"\" self . setIndent ( indent ) return self set_text ( self , text : str ) -> Label Set the label's text. Source code in prettyqt/widgets/label.py def set_text ( self , text : str ) -> Label : \"\"\"Set the label's text.\"\"\" self . setText ( text ) return self set_text_format ( self , text_format : TextFormatStr ) -> Label Set the text format. Parameters: Name Type Description Default text_format TextFormatStr text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/label.py def set_text_format ( self , text_format : TextFormatStr ) -> Label : \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) return self set_text_interaction ( self , * types : TextInteractionStr ) -> Label Set the text interaction mode. Parameters: Name Type Description Default types TextInteractionStr text interaction mode to use () Exceptions: Type Description InvalidParamError text interaction mode does not exist Source code in prettyqt/widgets/label.py def set_text_interaction ( self , * types : TextInteractionStr ) -> Label : \"\"\"Set the text interaction mode. Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self set_weight ( self , weight : gui . font . WeightStr ) -> Label Set the font weight. Parameters: Name Type Description Default weight gui.font.WeightStr font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/widgets/label.py def set_weight ( self , weight : gui . font . WeightStr ) -> Label : \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) font = self . font () font . setWeight ( gui . font . WEIGHT [ weight ]) self . setFont ( font ) return self layout Layout ( QLayout ) Source code in prettyqt/widgets/layout.py class Layout ( QtWidgets . QLayout ): def __getitem__ ( self , index : str | int ) -> QtWidgets . QWidget | QtWidgets . QLayout | None : if isinstance ( index , int ): item = self . itemAt ( index ) widget = item . widget () if widget is None : widget = item . layout () elif isinstance ( index , str ): return self . find_child ( typ = QtCore . QObject , name = index ) return widget def __delitem__ ( self , index : int ): item = self . itemAt ( index ) self . removeItem ( item ) def __len__ ( self ) -> int : return self . count () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def __iter__ ( self ): return iter ( self [ i ] for i in range ( self . count ())) def __contains__ ( self , item : QtWidgets . QWidget | QtWidgets . QLayoutItem ): return self . indexOf ( item ) >= 0 def serialize_fields ( self ): return dict ( size_mode = self . get_size_mode (), spacing = self . spacing (), enabled = self . isEnabled (), ) def get_children ( self ) -> list [ QtWidgets . QWidget | QtWidgets . QLayout ]: return list ( self ) def set_margin ( self , margin : int ): self . setContentsMargins ( margin , margin , margin , margin ) def set_spacing ( self , pixels : int ): self . setSpacing ( pixels ) def set_size_mode ( self , mode : SizeConstraintStr ): \"\"\"Set the size mode of the layout. Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in SIZE_CONSTRAINT : raise InvalidParamError ( mode , SIZE_CONSTRAINT ) self . setSizeConstraint ( SIZE_CONSTRAINT [ mode ]) def get_size_mode ( self ) -> SizeConstraintStr : \"\"\"Return current size mode. Returns: size mode \"\"\" return SIZE_CONSTRAINT . inverse [ self . sizeConstraint ()] def set_alignment ( self , alignment : constants . AlignmentStr , item : QtWidgets . QWidget | QtWidgets . QLayout | None = None , ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) if item is not None : return self . setAlignment ( item , constants . ALIGNMENTS [ alignment ]) else : return self . setAlignment ( constants . ALIGNMENTS [ alignment ]) def add ( self , * item : QtWidgets . QWidget | QtWidgets . QLayout ): for i in item : if isinstance ( i , QtWidgets . QWidget ): self . addWidget ( i ) elif isinstance ( i , QtWidgets . QLayout ): w = widgets . Widget () w . set_layout ( i ) self . addWidget ( w ) else : raise TypeError ( \"add_item only supports widgets and layouts\" ) get_size_mode ( self ) -> SizeConstraintStr Return current size mode. Returns: Type Description SizeConstraintStr size mode Source code in prettyqt/widgets/layout.py def get_size_mode ( self ) -> SizeConstraintStr : \"\"\"Return current size mode. Returns: size mode \"\"\" return SIZE_CONSTRAINT . inverse [ self . sizeConstraint ()] set_alignment ( self , alignment : constants . AlignmentStr , item : QtWidgets . QWidget | QtWidgets . QLayout | None = None ) Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Parameters: Name Type Description Default alignment constants.AlignmentStr alignment for the layout required item QtWidgets.QWidget | QtWidgets.QLayout | None set alignment for specific child only None Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layout.py def set_alignment ( self , alignment : constants . AlignmentStr , item : QtWidgets . QWidget | QtWidgets . QLayout | None = None , ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) if item is not None : return self . setAlignment ( item , constants . ALIGNMENTS [ alignment ]) else : return self . setAlignment ( constants . ALIGNMENTS [ alignment ]) set_size_mode ( self , mode : SizeConstraintStr ) Set the size mode of the layout. Parameters: Name Type Description Default mode SizeConstraintStr size mode for the layout required Exceptions: Type Description InvalidParamError size mode does not exist Source code in prettyqt/widgets/layout.py def set_size_mode ( self , mode : SizeConstraintStr ): \"\"\"Set the size mode of the layout. Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in SIZE_CONSTRAINT : raise InvalidParamError ( mode , SIZE_CONSTRAINT ) self . setSizeConstraint ( SIZE_CONSTRAINT [ mode ]) layoutitem LayoutItem ( QLayoutItem ) Source code in prettyqt/widgets/layoutitem.py class LayoutItem ( QtWidgets . QLayoutItem ): # def __bool__(self): # return not self.isEmpty() def set_alignment ( self , alignment : constants . AlignmentStr ): \"\"\"Set the alignment of the layout. Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) self . setAlignment ( constants . ALIGNMENTS [ alignment ]) def get_alignment ( self ) -> constants . AlignmentStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . ALIGNMENTS . inverse [ self . alignment ()] def get_item ( self , ) -> QtWidgets . QWidget | QtWidgets . QLayout | QtWidgets . QSpacerItem | None : if content := self . widget (): return content if content := self . layout (): return content if content := self . spacerItem (): return content return None get_alignment ( self ) -> constants . AlignmentStr Return current alignment. Returns: Type Description constants.AlignmentStr alignment Source code in prettyqt/widgets/layoutitem.py def get_alignment ( self ) -> constants . AlignmentStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . ALIGNMENTS . inverse [ self . alignment ()] set_alignment ( self , alignment : constants . AlignmentStr ) Set the alignment of the layout. Parameters: Name Type Description Default alignment constants.AlignmentStr alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layoutitem.py def set_alignment ( self , alignment : constants . AlignmentStr ): \"\"\"Set the alignment of the layout. Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) self . setAlignment ( constants . ALIGNMENTS [ alignment ]) lcdnumber LCDNumber ( QLCDNumber ) Source code in prettyqt/widgets/lcdnumber.py class LCDNumber ( QtWidgets . QLCDNumber ): def serialize_fields ( self ): return dict ( mode = self . get_mode (), segment_style = self . get_segment_style (), value = self . get_value (), ) def __setstate__ ( self , state ): self . set_mode ( state [ \"mode\" ]) self . set_segment_style ( state [ \"segment_style\" ]) self . set_value ( state [ \"value\" ]) def set_mode ( self , mode : ModeStr ): \"\"\"Set the lcd mode. Args: mode: lcd mode to use Raises: InvalidParamError: lcd mode does not exist \"\"\" if mode not in MODE : raise InvalidParamError ( mode , MODE ) self . setMode ( MODE [ mode ]) def get_mode ( self ) -> ModeStr : \"\"\"Return current lcd mode. Returns: lcd mode \"\"\" return MODE . inverse [ self . mode ()] def set_segment_style ( self , mode : SegmentStyleStr ): \"\"\"Set the segment style. Args: mode: segment style to use Raises: InvalidParamError: segment style does not exist \"\"\" if mode not in SEGMENT_STYLE : raise InvalidParamError ( mode , SEGMENT_STYLE ) self . setSegmentStyle ( SEGMENT_STYLE [ mode ]) def get_segment_style ( self ) -> SegmentStyleStr : \"\"\"Return current segment style. Returns: segment style \"\"\" return SEGMENT_STYLE . inverse [ self . segmentStyle ()] def set_value ( self , value : float | str ): self . display ( value ) def get_value ( self ) -> float : return self . value () get_mode ( self ) -> ModeStr Return current lcd mode. Returns: Type Description ModeStr lcd mode Source code in prettyqt/widgets/lcdnumber.py def get_mode ( self ) -> ModeStr : \"\"\"Return current lcd mode. Returns: lcd mode \"\"\" return MODE . inverse [ self . mode ()] get_segment_style ( self ) -> SegmentStyleStr Return current segment style. Returns: Type Description SegmentStyleStr segment style Source code in prettyqt/widgets/lcdnumber.py def get_segment_style ( self ) -> SegmentStyleStr : \"\"\"Return current segment style. Returns: segment style \"\"\" return SEGMENT_STYLE . inverse [ self . segmentStyle ()] set_mode ( self , mode : ModeStr ) Set the lcd mode. Parameters: Name Type Description Default mode ModeStr lcd mode to use required Exceptions: Type Description InvalidParamError lcd mode does not exist Source code in prettyqt/widgets/lcdnumber.py def set_mode ( self , mode : ModeStr ): \"\"\"Set the lcd mode. Args: mode: lcd mode to use Raises: InvalidParamError: lcd mode does not exist \"\"\" if mode not in MODE : raise InvalidParamError ( mode , MODE ) self . setMode ( MODE [ mode ]) set_segment_style ( self , mode : SegmentStyleStr ) Set the segment style. Parameters: Name Type Description Default mode SegmentStyleStr segment style to use required Exceptions: Type Description InvalidParamError segment style does not exist Source code in prettyqt/widgets/lcdnumber.py def set_segment_style ( self , mode : SegmentStyleStr ): \"\"\"Set the segment style. Args: mode: segment style to use Raises: InvalidParamError: segment style does not exist \"\"\" if mode not in SEGMENT_STYLE : raise InvalidParamError ( mode , SEGMENT_STYLE ) self . setSegmentStyle ( SEGMENT_STYLE [ mode ]) lineedit LineEdit ( QLineEdit ) Source code in prettyqt/widgets/lineedit.py class LineEdit ( QtWidgets . QLineEdit ): focusLost = core . Signal () enterPressed = core . Signal () editComplete = core . Signal ( str ) value_changed = core . Signal ( str ) def __init__ ( self , default_value : str = \"\" , read_only : bool = False , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( default_value , parent ) self . textChanged . connect ( self . _set_validation_color ) self . textChanged . connect ( self . value_changed ) self . set_read_only ( read_only ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } : { self . serialize_fields () } \" def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_text ( state [ \"text\" ]) self . setValidator ( state [ \"validator\" ]) self . setInputMask ( state [ \"input_mask\" ]) self . setMaxLength ( state [ \"max_length\" ]) self . setPlaceholderText ( state [ \"placeholder_text\" ]) self . setReadOnly ( state [ \"read_only\" ]) self . setFrame ( state [ \"has_frame\" ]) self . setClearButtonEnabled ( state [ \"clear_button_enabled\" ]) # self.setAlignment(state[\"alignment\"]) self . set_cursor_move_style ( state [ \"cursor_move_style\" ]) self . set_echo_mode ( state [ \"echo_mode\" ]) self . setCursorPosition ( state [ \"cursor_position\" ]) self . setDragEnabled ( state [ \"drag_enabled\" ]) self . setModified ( state [ \"is_modified\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __add__ ( self , other : str ): self . append_text ( other ) return self def serialize_fields ( self ): return dict ( text = self . text (), # alignment=self.alignment(), validator = self . validator (), max_length = self . maxLength (), read_only = self . isReadOnly (), input_mask = self . inputMask (), has_frame = self . hasFrame (), placeholder_text = self . placeholderText (), clear_button_enabled = self . isClearButtonEnabled (), cursor_move_style = self . get_cursor_move_style (), echo_mode = self . get_echo_mode (), cursor_position = self . cursorPosition (), drag_enabled = self . dragEnabled (), is_modified = self . isModified (), ) def focusOutEvent ( self , event ): self . focusLost . emit () return super () . focusOutEvent ( event ) def keyPressEvent ( self , event ): if event . key () in [ QtCore . Qt . Key . Key_Enter , QtCore . Qt . Key . Key_Return ]: self . enterPressed . emit () return super () . keyPressEvent ( event ) def _on_edit_complete ( self ): self . editComplete . emit ( self . text ()) def font ( self ) -> gui . Font : return gui . Font ( super () . font ()) def append_text ( self , text : str ): self . set_text ( self . text () + text ) def set_text ( self , text : str ): self . setText ( text ) def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) def set_regex_validator ( self , regex : str , flags = 0 ) -> gui . RegularExpressionValidator : validator = gui . RegularExpressionValidator ( self ) validator . set_regex ( regex , flags ) self . set_validator ( validator ) return validator def set_range ( self , lower : int | None , upper : int | None ): val = gui . IntValidator () val . set_range ( lower , upper ) self . set_validator ( val ) def set_validator ( self , validator : gui . Validator ): self . setValidator ( validator ) self . _set_validation_color () def set_input_mask ( self , mask : str ): self . setInputMask ( mask ) def _set_validation_color ( self , state : bool = True ): color = \"orange\" if not self . is_valid () else None self . set_background_color ( color ) def set_echo_mode ( self , mode : EchoModeStr ): \"\"\"Set echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODE : raise InvalidParamError ( mode , ECHO_MODE ) self . setEchoMode ( ECHO_MODE [ mode ]) def get_echo_mode ( self ) -> EchoModeStr : \"\"\"Return echo mode. Returns: echo mode \"\"\" return ECHO_MODE . inverse [ self . echoMode ()] def set_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set cursor move style. Args: style: cursor move style to use Raises: InvalidParamError: invalid cursor move style \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ]) def get_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . cursorMoveStyle ()] def add_action ( self , action : QtWidgets . QAction , position : ActionPositionStr = \"trailing\" ): self . addAction ( action , ACTION_POSITION [ position ]) def set_value ( self , value : str ): self . setText ( value ) def get_value ( self ) -> str : return self . text () def is_valid ( self ) -> bool : return self . hasAcceptableInput () focusOutEvent ( self , event ) focusOutEvent(self, arg__1: PySide6.QtGui.QFocusEvent) -> None Source code in prettyqt/widgets/lineedit.py def focusOutEvent ( self , event ): self . focusLost . emit () return super () . focusOutEvent ( event ) font ( self ) -> gui . Font font(self) -> PySide6.QtGui.QFont Source code in prettyqt/widgets/lineedit.py def font ( self ) -> gui . Font : return gui . Font ( super () . font ()) get_cursor_move_style ( self ) -> constants . CursorMoveStyleStr Return cursor move style. Returns: Type Description constants.CursorMoveStyleStr cursor move style Source code in prettyqt/widgets/lineedit.py def get_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . cursorMoveStyle ()] get_echo_mode ( self ) -> EchoModeStr Return echo mode. Returns: Type Description EchoModeStr echo mode Source code in prettyqt/widgets/lineedit.py def get_echo_mode ( self ) -> EchoModeStr : \"\"\"Return echo mode. Returns: echo mode \"\"\" return ECHO_MODE . inverse [ self . echoMode ()] keyPressEvent ( self , event ) keyPressEvent(self, arg__1: PySide6.QtGui.QKeyEvent) -> None Source code in prettyqt/widgets/lineedit.py def keyPressEvent ( self , event ): if event . key () in [ QtCore . Qt . Key . Key_Enter , QtCore . Qt . Key . Key_Return ]: self . enterPressed . emit () return super () . keyPressEvent ( event ) set_cursor_move_style ( self , style : constants . CursorMoveStyleStr ) Set cursor move style. Parameters: Name Type Description Default style constants.CursorMoveStyleStr cursor move style to use required Exceptions: Type Description InvalidParamError invalid cursor move style Source code in prettyqt/widgets/lineedit.py def set_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set cursor move style. Args: style: cursor move style to use Raises: InvalidParamError: invalid cursor move style \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ]) set_echo_mode ( self , mode : EchoModeStr ) Set echo mode. Parameters: Name Type Description Default mode EchoModeStr echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/lineedit.py def set_echo_mode ( self , mode : EchoModeStr ): \"\"\"Set echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODE : raise InvalidParamError ( mode , ECHO_MODE ) self . setEchoMode ( ECHO_MODE [ mode ]) set_read_only ( self , value : bool = True ) Set text to read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) listview ListView ( QListView ) Source code in prettyqt/widgets/listview.py class ListView ( QtWidgets . QListView ): def serialize_fields ( self ): return dict ( view_mode = self . get_view_mode (), resize_mode = self . get_resize_mode (), layout_mode = self . get_layout_mode (), movement = self . get_movement (), batch_size = self . batchSize (), flow = self . get_flow (), grid_size = self . get_grid_size (), is_wrapping = self . isWrapping (), # item_alignment=self.itemAlignment(), model_column = self . modelColumn (), selection_rect_visible = self . isSelectionRectVisible (), spacing = self . spacing (), uniform_item_sizes = self . uniformItemSizes (), word_wrap = self . wordWrap (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_view_mode ( state [ \"view_mode\" ]) self . set_resize_mode ( state [ \"resize_mode\" ]) self . set_layout_mode ( state [ \"layout_mode\" ]) self . set_movement ( state [ \"movement\" ]) self . setBatchSize ( state [ \"batch_size\" ]) self . set_flow ( state [ \"flow\" ]) self . set_grid_size ( state [ \"grid_size\" ]) self . setWrapping ( state [ \"is_wrapping\" ]) # self.setItemAlignment(state[\"flow\"]) self . setModelColumn ( state [ \"model_column\" ]) self . setSelectionRectVisible ( state [ \"selection_rect_visible\" ]) self . setSpacing ( state [ \"spacing\" ]) self . setUniformItemSizes ( state [ \"uniform_item_sizes\" ]) self . setWordWrap ( state [ \"word_wrap\" ]) def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] def set_resize_mode ( self , mode : ResizeModeStr ): \"\"\"Set resize mode. Args: mode: resize mode to use Raises: InvalidParamError: invalid resize mode \"\"\" if mode not in RESIZE_MODE : raise InvalidParamError ( mode , RESIZE_MODE ) self . setResizeMode ( RESIZE_MODE [ mode ]) def get_resize_mode ( self ) -> ResizeModeStr : \"\"\"Return resize mode. Returns: resize mode \"\"\" return RESIZE_MODE . inverse [ self . resizeMode ()] def set_layout_mode ( self , mode : LayoutModeStr ): \"\"\"Set layout mode. Args: mode: layout mode to use Raises: InvalidParamError: invalid layout mode \"\"\" if mode not in LAYOUT_MODE : raise InvalidParamError ( mode , LAYOUT_MODE ) self . setLayoutMode ( LAYOUT_MODE [ mode ]) def get_layout_mode ( self ) -> LayoutModeStr : \"\"\"Return layout mode. Returns: layout mode \"\"\" return LAYOUT_MODE . inverse [ self . layoutMode ()] def set_movement ( self , mode : MovementStr ): \"\"\"Set movement mode. Args: mode: movement mode to use Raises: InvalidParamError: invalid movement mode \"\"\" if mode not in MOVEMENT : raise InvalidParamError ( mode , MOVEMENT ) self . setMovement ( MOVEMENT [ mode ]) def get_movement ( self ) -> MovementStr : \"\"\"Return movement mode. Returns: movement mode \"\"\" return MOVEMENT . inverse [ self . movement ()] def set_flow ( self , mode : FlowStr ): \"\"\"Set flow mode. Args: mode: flow mode to use Raises: InvalidParamError: invalid flow mode \"\"\" if mode not in FLOW : raise InvalidParamError ( mode , FLOW ) self . setFlow ( FLOW [ mode ]) def get_flow ( self ) -> FlowStr : \"\"\"Return flow mode. Returns: flow mode \"\"\" return FLOW . inverse [ self . flow ()] def set_grid_size ( self , size : QtCore . QSize | tuple [ int , int ]): if isinstance ( size , tuple ): size = QtCore . QSize ( * size ) self . setGridSize ( size ) def get_grid_size ( self ) -> core . Size : return core . Size ( self . gridSize ()) get_flow ( self ) -> FlowStr Return flow mode. Returns: Type Description FlowStr flow mode Source code in prettyqt/widgets/listview.py def get_flow ( self ) -> FlowStr : \"\"\"Return flow mode. Returns: flow mode \"\"\" return FLOW . inverse [ self . flow ()] get_layout_mode ( self ) -> LayoutModeStr Return layout mode. Returns: Type Description LayoutModeStr layout mode Source code in prettyqt/widgets/listview.py def get_layout_mode ( self ) -> LayoutModeStr : \"\"\"Return layout mode. Returns: layout mode \"\"\" return LAYOUT_MODE . inverse [ self . layoutMode ()] get_movement ( self ) -> MovementStr Return movement mode. Returns: Type Description MovementStr movement mode Source code in prettyqt/widgets/listview.py def get_movement ( self ) -> MovementStr : \"\"\"Return movement mode. Returns: movement mode \"\"\" return MOVEMENT . inverse [ self . movement ()] get_resize_mode ( self ) -> ResizeModeStr Return resize mode. Returns: Type Description ResizeModeStr resize mode Source code in prettyqt/widgets/listview.py def get_resize_mode ( self ) -> ResizeModeStr : \"\"\"Return resize mode. Returns: resize mode \"\"\" return RESIZE_MODE . inverse [ self . resizeMode ()] get_view_mode ( self ) -> ViewModeStr Return view mode. Returns: Type Description ViewModeStr view mode Source code in prettyqt/widgets/listview.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] set_flow ( self , mode : FlowStr ) Set flow mode. Parameters: Name Type Description Default mode FlowStr flow mode to use required Exceptions: Type Description InvalidParamError invalid flow mode Source code in prettyqt/widgets/listview.py def set_flow ( self , mode : FlowStr ): \"\"\"Set flow mode. Args: mode: flow mode to use Raises: InvalidParamError: invalid flow mode \"\"\" if mode not in FLOW : raise InvalidParamError ( mode , FLOW ) self . setFlow ( FLOW [ mode ]) set_layout_mode ( self , mode : LayoutModeStr ) Set layout mode. Parameters: Name Type Description Default mode LayoutModeStr layout mode to use required Exceptions: Type Description InvalidParamError invalid layout mode Source code in prettyqt/widgets/listview.py def set_layout_mode ( self , mode : LayoutModeStr ): \"\"\"Set layout mode. Args: mode: layout mode to use Raises: InvalidParamError: invalid layout mode \"\"\" if mode not in LAYOUT_MODE : raise InvalidParamError ( mode , LAYOUT_MODE ) self . setLayoutMode ( LAYOUT_MODE [ mode ]) set_movement ( self , mode : MovementStr ) Set movement mode. Parameters: Name Type Description Default mode MovementStr movement mode to use required Exceptions: Type Description InvalidParamError invalid movement mode Source code in prettyqt/widgets/listview.py def set_movement ( self , mode : MovementStr ): \"\"\"Set movement mode. Args: mode: movement mode to use Raises: InvalidParamError: invalid movement mode \"\"\" if mode not in MOVEMENT : raise InvalidParamError ( mode , MOVEMENT ) self . setMovement ( MOVEMENT [ mode ]) set_resize_mode ( self , mode : ResizeModeStr ) Set resize mode. Parameters: Name Type Description Default mode ResizeModeStr resize mode to use required Exceptions: Type Description InvalidParamError invalid resize mode Source code in prettyqt/widgets/listview.py def set_resize_mode ( self , mode : ResizeModeStr ): \"\"\"Set resize mode. Args: mode: resize mode to use Raises: InvalidParamError: invalid resize mode \"\"\" if mode not in RESIZE_MODE : raise InvalidParamError ( mode , RESIZE_MODE ) self . setResizeMode ( RESIZE_MODE [ mode ]) set_view_mode ( self , mode : ViewModeStr ) Set view mode. Parameters: Name Type Description Default mode ViewModeStr view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/listview.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) listwidgetitem ListWidgetItem ( QListWidgetItem ) Source code in prettyqt/widgets/listwidgetitem.py class ListWidgetItem ( QtWidgets . QListWidgetItem ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . icon () } , { self . text () !r} )\" def __setitem__ ( self , index : int , value ): self . setData ( index , value ) def __getitem__ ( self , index : int ): return self . data ( index ) def serialize_fields ( self ): return dict ( text = self . text (), tool_tip = self . toolTip (), status_tip = self . statusTip (), checkstate = self . get_checkstate (), icon = self . get_icon (), data = self . data ( constants . USER_ROLE ), # type: ignore ) def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] def get_background ( self ) -> gui . Brush : return gui . Brush ( self . background ()) def get_foreground ( self ) -> gui . Brush : return gui . Brush ( self . foreground ()) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_data ( self , role : str , data ): role_id = constants . ITEM_DATA_ROLE [ role ] self . setData ( role_id , data ) def set_size_hint ( self , hint : types . SizeType ): if isinstance ( hint , tuple ): hint = QtCore . QSize ( * hint ) self . setSizeHint ( hint ) get_checkstate ( self ) -> constants . StateStr Return checkstate. Returns: Type Description constants.StateStr checkstate Source code in prettyqt/widgets/listwidgetitem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] set_checkstate ( self , state : constants . StateStr ) Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) set_icon ( self , icon : types . IconType ) Set the icon for the action. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/listwidgetitem.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) mainwindow MainWindow ( QMainWindow ) Source code in prettyqt/widgets/mainwindow.py class MainWindow ( QtWidgets . QMainWindow ): \"\"\"Class for our mainWindow. Includes all docks, a centralwidget and a toolbar \"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setMenuBar ( widgets . MenuBar ()) self . setDockOptions ( self . DockOption . AllowTabbedDocks # type: ignore | self . DockOption . AllowNestedDocks | self . DockOption . GroupedDragging | self . DockOption . AnimatedDocks ) def __getitem__ ( self , index : str ) -> QtWidgets . QWidget : result = self . find_child ( QtWidgets . QWidget , index ) if result is None : raise KeyError ( \"Widget not found\" ) return result def serialize_fields ( self ): return dict ( central_widget = self . centralWidget (), is_maximized = self . isMaximized (), ) def __setstate__ ( self , state ): if state [ \"central_widget\" ]: self . setCentralWidget ( state [ \"central_widget\" ]) if state [ \"is_maximized\" ]: self . showMaximized () self . box = self . layout () def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def set_widget ( self , widget : QtWidgets . QWidget | None ): if widget is None : self . takeCentralWidget () else : self . setCentralWidget ( widget ) def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add ( action ) return menu def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBar ( constants . TOOLBAR_AREA [ position ], toolbar ) def add_toolbar_break ( self , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBarBreak ( constants . TOOLBAR_AREA [ position ]) def load_window_state ( self , recursive : bool = False ) -> bool : settings = core . Settings () name = self . get_id () geom = settings . get ( f \" { name } .geometry\" ) state = settings . get ( f \" { name } .state\" ) restored = False if geom is not None and state is not None : try : logger . debug ( f \"Loading window state for { self . windowTitle () !r} ...\" ) self . restoreGeometry ( geom ) if isinstance ( state , str ): state = state . encode () self . restoreState ( state ) restored = True except TypeError : logger . error ( \"Wrong type for window state. Probably Qt binding switch?\" ) if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . load_window_state () return restored def save_window_state ( self , recursive : bool = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { self . windowTitle () !r} ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state () def add_widget_as_dock ( self , name : str , title : str , vertical : bool = True , position : constants . DockPositionStr = \"left\" , ) -> widgets . DockWidget : dock_widget = widgets . DockWidget ( self , name = name , title = title ) widget = widgets . Widget () widget . set_id ( f \" { name } .widget\" ) layout = widgets . BoxLayout ( \"vertical\" if vertical else \"horizontal\" , widget , margin = 0 ) dock_widget . setWidget ( widget ) self . add_dockwidget ( dock_widget , position ) dock_widget . box = layout return dock_widget def add_dockwidget ( self , dockwidget : QtWidgets . QDockWidget , position : constants . DockPositionStr = \"left\" , ): self . addDockWidget ( constants . DOCK_POSITION [ position ], dockwidget ) def remove_dockwidgets ( self , dockwidgets : Sequence [ QtWidgets . QDockWidget ]): for i in dockwidgets : self . removeDockWidget ( i ) def show_blocking ( self ): self . set_modality ( \"application\" ) self . show () def get_docks ( self ) -> list [ QtWidgets . QDockWidget ]: return self . find_children ( QtWidgets . QDockWidget , recursive = False ) def get_toolbars ( self ) -> list [ QtWidgets . QToolBar ]: return self . find_children ( QtWidgets . QToolBar , recursive = False ) def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen () add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : constants . ToolbarAreaStr = 'top' ) Adds a toolbar to the mainmenu at specified area. Parameters: Name Type Description Default toolbar QtWidgets.QToolBar toolbar to use required position constants.ToolbarAreaStr position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBar ( constants . TOOLBAR_AREA [ position ], toolbar ) add_toolbar_break ( self , position : constants . ToolbarAreaStr = 'top' ) Adds a toolbar break to the given area behind the last item. Parameters: Name Type Description Default position constants.ToolbarAreaStr position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar_break ( self , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBarBreak ( constants . TOOLBAR_AREA [ position ]) createPopupMenu ( self ) -> widgets . Menu createPopupMenu(self) -> PySide6.QtWidgets.QMenu Source code in prettyqt/widgets/mainwindow.py def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add ( action ) return menu save_window_state ( self , recursive : bool = False ) Save current window state as QSetting. Parameters: Name Type Description Default recursive bool Description False Source code in prettyqt/widgets/mainwindow.py def save_window_state ( self , recursive : bool = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { self . windowTitle () !r} ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state () toggle_fullscreen ( self ) Toggle between fullscreen and regular size. Source code in prettyqt/widgets/mainwindow.py def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen () mdiarea MdiArea ( QMdiArea ) Source code in prettyqt/widgets/mdiarea.py class MdiArea ( QtWidgets . QMdiArea ): def __add__ ( self , other : QtWidgets . QWidget ): self . add ( other ) return self def serialize_fields ( self ): return dict ( view_mode = self . get_view_mode (), window_order = self . get_window_order (), tab_position = self . get_tab_position (), background = self . get_background (), document_mode = self . documentMode (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_view_mode ( state [ \"view_mode\" ]) self . set_window_order ( state [ \"window_order\" ]) self . set_tab_position ( state [ \"tab_position\" ]) self . set_background ( state [ \"background\" ]) self . setDocumentMode ( state [ \"document_mode\" ]) def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode for the MDI area. Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return current view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] def set_window_order ( self , mode : WindowOrderStr ): \"\"\"Set the window order behaviour for the MDI area. Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDER : raise InvalidParamError ( mode , WINDOW_ORDER ) self . setActivationOrder ( WINDOW_ORDER [ mode ]) def get_window_order ( self ) -> WindowOrderStr : \"\"\"Return current window order. Returns: view mode \"\"\" return WINDOW_ORDER . inverse [ self . activationOrder ()] def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the MDI area. Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ]) def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return current tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()] def set_background ( self , brush_or_color : types . ColorAndBrushType , pattern : constants . PatternStr = \"solid\" , ): if isinstance ( brush_or_color , QtGui . QBrush ): brush = brush_or_color else : color = colors . get_color ( brush_or_color ) brush = gui . Brush ( color , constants . PATTERN [ pattern ]) self . setBackground ( brush ) def get_background ( self ) -> gui . Brush : return gui . Brush ( self . background ()) def add ( self , * item : QtWidgets . QWidget ): for i in item : if not isinstance ( i , QtWidgets . QMdiSubWindow ): widget = widgets . MdiSubWindow () widget . setWidget ( i ) self . addSubWindow ( widget ) else : self . addSubWindow ( i ) get_tab_position ( self ) -> TabPositionStr Return current tab position. Returns: Type Description TabPositionStr tab position Source code in prettyqt/widgets/mdiarea.py def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return current tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()] get_view_mode ( self ) -> ViewModeStr Return current view mode. Returns: Type Description ViewModeStr view mode Source code in prettyqt/widgets/mdiarea.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return current view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] get_window_order ( self ) -> WindowOrderStr Return current window order. Returns: Type Description WindowOrderStr view mode Source code in prettyqt/widgets/mdiarea.py def get_window_order ( self ) -> WindowOrderStr : \"\"\"Return current window order. Returns: view mode \"\"\" return WINDOW_ORDER . inverse [ self . activationOrder ()] set_tab_position ( self , position : TabPositionStr ) Set tab position for the MDI area. Parameters: Name Type Description Default position TabPositionStr tabs position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/mdiarea.py def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the MDI area. Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ]) set_view_mode ( self , mode : ViewModeStr ) Set view mode for the MDI area. Parameters: Name Type Description Default mode ViewModeStr view mode to use required Exceptions: Type Description InvalidParamError view mode does not exist Source code in prettyqt/widgets/mdiarea.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode for the MDI area. Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) set_window_order ( self , mode : WindowOrderStr ) Set the window order behaviour for the MDI area. Parameters: Name Type Description Default mode WindowOrderStr window order behaviour to use required Exceptions: Type Description InvalidParamError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py def set_window_order ( self , mode : WindowOrderStr ): \"\"\"Set the window order behaviour for the MDI area. Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDER : raise InvalidParamError ( mode , WINDOW_ORDER ) self . setActivationOrder ( WINDOW_ORDER [ mode ]) menu Menu ( QMenu ) Source code in prettyqt/widgets/menu.py class Menu ( QtWidgets . QMenu ): def __init__ ( self , title : str = \"\" , icon : types . IconType = None , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( title , parent = parent ) self . set_icon ( icon ) self . setToolTipsVisible ( True ) def __iter__ ( self ) -> Iterator [ QtWidgets . QAction ]: return iter ( self . actions ()) def __len__ ( self ) -> int : return len ( self . actions ()) def __add__ ( self , other : QtWidgets . QAction ): self . add ( other ) return self def __getitem__ ( self , item : str ) -> QtWidgets . QAction : for action in self . actions (): if action . objectName () == item : return action raise KeyError ( f \"Action { item } not in menu\" ) def serialize_fields ( self ): return dict ( separators_collapsible = self . separatorsCollapsible (), tearoff_enabled = self . isTearOffEnabled (), title = self . title (), tool_tips_visible = self . toolTipsVisible (), icon = self . get_icon (), ) def add ( self , * item : QtWidgets . QAction ): for i in item : i . setParent ( self ) self . addAction ( i ) def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def add_separator ( self , text : str | None = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator def add_action ( self , label : str | widgets . Action , callback : Callable = None , icon : Any | None = None , checkable : bool = False , checked : bool = False , shortcut : str | None = None , status_tip : str | None = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action def add_actions ( self , actions : list [ QtWidgets . QAction ]): self . addActions ( actions ) def add_menu ( self , menu : QtWidgets . QMenu ) -> QtWidgets . QAction : action = menu . menuAction () self . addAction ( action ) return action add_action ( self , label : str | widgets . Action , callback : Callable = None , icon : Any | None = None , checkable : bool = False , checked : bool = False , shortcut : str | None = None , status_tip : str | None = None ) -> widgets . Action Add an action to the menu. Parameters: Name Type Description Default label str | widgets.Action Label for button required callback Callable gets called when action is triggered None icon Any | None icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut str | None Shortcut for action None status_tip str | None Status tip to be shown in status bar None Returns: Type Description widgets.Action Action added to menu Source code in prettyqt/widgets/menu.py def add_action ( self , label : str | widgets . Action , callback : Callable = None , icon : Any | None = None , checkable : bool = False , checked : bool = False , shortcut : str | None = None , status_tip : str | None = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action add_separator ( self , text : str | None = None ) -> widgets . WidgetAction Adds a separator showing an optional label. Parameters: Name Type Description Default text str | None Text to show on separator None Returns: Type Description widgets.WidgetAction Separator action Source code in prettyqt/widgets/menu.py def add_separator ( self , text : str | None = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator set_icon ( self , icon : types . IconType ) Set the icon for the menu. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/menu.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) messagebox MessageBox ( QMessageBox ) Source code in prettyqt/widgets/messagebox.py class MessageBox ( QtWidgets . QMessageBox ): def __init__ ( self , icon : types . IconType | IconStr = None , title : str = \"\" , text : str = \"\" , informative_text : str = \"\" , details : str = \"\" , buttons : list [ ButtonStr ] | None = None , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( parent ) self . set_icon ( icon ) self . setText ( text ) self . setInformativeText ( informative_text ) self . setWindowTitle ( title ) self . setWindowFlags ( QtCore . Qt . WindowType . Dialog # type: ignore | QtCore . Qt . WindowType . WindowTitleHint | QtCore . Qt . WindowType . CustomizeWindowHint ) self . setDetailedText ( details ) if isinstance ( buttons , list ): for b in buttons : self . add_button ( b ) def serialize_fields ( self ): return dict ( icon = self . get_icon (), detailed_text = self . detailedText (), icon_pixmap = self . get_icon_pixmap (), informative_text = self . informativeText (), text = self . text (), text_format = self . get_text_format (), ) @classmethod def message ( cls , text : str , title : str = \"\" , icon : types . IconType = None , detail_text : str | None = None , ) -> str : m = cls ( \"none\" , title , text ) m . set_icon ( icon ) if detail_text is not None : m . setDetailedText ( detail_text ) return m . show_blocking () @classmethod def show_exception ( cls , exception : Exception ): exctype , value = sys . exc_info ()[: 2 ] tb = traceback . format_exc () dlg = cls ( text = str ( value ), title = str ( exctype ), icon = \"critical\" , details = tb ) dlg . show_blocking () def set_icon ( self , icon : types . IconType | IconStr ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) else : ico = iconprovider . get_icon ( icon ) self . setIconPixmap ( ico . get_pixmap ( size = 64 )) def show_blocking ( self ) -> ButtonStr : return BUTTONS . inverse [ self . main_loop ()] def get_icon_pixmap ( self ) -> gui . Pixmap | None : pix = self . iconPixmap () if pix . isNull (): return None return gui . Pixmap ( pix ) def get_standard_buttons ( self ) -> list [ ButtonStr ]: return [ k for k , v in BUTTONS . items () if v & self . standardButtons ()] def add_button ( self , button : ButtonStr ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ]) # @classmethod # def show_exception(cls, exception): # header = str(exception[0]) # error_text = str(exception[1]) # widgets.MessageBox.message(error_text, header, \"mdi.exclamation\") def set_text_format ( self , text_format : TextFormatStr ): \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] def set_escape_button ( self , button : ButtonStr | QtWidgets . QAbstractButton ): if isinstance ( button , QtWidgets . QAbstractButton ): self . setEscapeButton ( button ) else : self . setEscapeButton ( BUTTONS [ button ]) def set_default_button ( self , button : ButtonStr | QtWidgets . QPushButton ): if isinstance ( button , QtWidgets . QPushButton ): self . setDefaultButton ( button ) else : self . setDefaultButton ( BUTTONS [ button ]) add_button ( self , button : ButtonStr ) -> QtWidgets . QPushButton Add a default button. Parameters: Name Type Description Default button ButtonStr button to add required Returns: Type Description QtWidgets.QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/messagebox.py def add_button ( self , button : ButtonStr ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ]) get_text_format ( self ) -> TextFormatStr Return current text format. Returns: Type Description TextFormatStr text format Source code in prettyqt/widgets/messagebox.py def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] set_icon ( self , icon : types . IconType | IconStr ) Set the window icon. Parameters: Name Type Description Default icon types.IconType | IconStr icon to use required Source code in prettyqt/widgets/messagebox.py def set_icon ( self , icon : types . IconType | IconStr ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) else : ico = iconprovider . get_icon ( icon ) self . setIconPixmap ( ico . get_pixmap ( size = 64 )) set_text_format ( self , text_format : TextFormatStr ) Set the text format. Parameters: Name Type Description Default text_format TextFormatStr text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/messagebox.py def set_text_format ( self , text_format : TextFormatStr ): \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) plaintextedit PlainTextEdit ( QPlainTextEdit ) Source code in prettyqt/widgets/plaintextedit.py class PlainTextEdit ( QtWidgets . QPlainTextEdit ): value_changed = core . Signal () def __init__ ( self , text : str = \"\" , parent : QtWidgets . QWidget | None = None , read_only : bool = False , ): super () . __init__ ( parent ) self . _allow_wheel_zoom = False self . validator : QtGui . QValidator | None = None self . textChanged . connect ( self . _on_value_change ) self . set_read_only ( read_only ) doc = gui . TextDocument ( self ) layout = widgets . PlainTextDocumentLayout ( doc ) doc . setDocumentLayout ( layout ) self . setDocument ( doc ) self . set_text ( text ) def serialize_fields ( self ): return dict ( text = self . text (), read_only = self . isReadOnly (), line_wrap_mode = self . get_line_wrap_mode (), word_wrap_mode = self . get_word_wrap_mode (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_text ( state [ \"text\" ]) self . setReadOnly ( state [ \"read_only\" ]) self . set_line_wrap_mode ( state [ \"line_wrap_mode\" ]) self . set_word_wrap_mode ( state [ \"word_wrap_mode\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __add__ ( self , other : str ): self . append_text ( other ) return self def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event ) def allow_wheel_zoom ( self , do_zoom : bool = True ): self . _allow_wheel_zoom = do_zoom def goto_line ( self , line_no : int ): doc = self . document () lines = doc . blockCount () assert 1 <= line_no <= lines pos = doc . findBlockByLineNumber ( line_no - 1 ) . position () with self . current_cursor () as text_cursor : text_cursor . setPosition ( pos ) def get_selected_text ( self ) -> str : if self . textCursor () . hasSelection (): return self . textCursor () . selectedText () else : return \"\" def get_current_line ( self ) -> int : return self . textCursor () . blockNumber () def get_selected_rows ( self ) -> tuple [ int , int ]: start = self . textCursor () . selectionStart () end = self . textCursor () . selectionEnd () start_block_id = self . document () . findBlock ( start ) . blockNumber () end_block_id = self . document () . findBlock ( end ) . blockNumber () return ( start_block_id , end_block_id ) @contextlib . contextmanager def create_cursor ( self ) -> Iterator [ gui . TextCursor ]: cursor = gui . TextCursor ( self . document ()) yield cursor self . setTextCursor ( cursor ) @contextlib . contextmanager def current_cursor ( self ) -> Iterator [ gui . TextCursor ]: cursor = gui . TextCursor ( self . textCursor ()) yield cursor self . setTextCursor ( cursor ) def get_text_cursor ( self ) -> gui . TextCursor : return gui . TextCursor ( self . textCursor ()) def move_cursor ( self , operation : gui . textcursor . MoveOperationStr , mode : gui . textcursor . MoveModeStr = \"move\" , ): self . moveCursor ( gui . textcursor . MOVE_OPERATION [ operation ], gui . textcursor . MOVE_MODE [ mode ] ) def append_text ( self , text : str , newline : bool = True ): if newline : self . appendPlainText ( text ) else : self . move_cursor ( \"end\" ) self . insertPlainText ( text ) self . move_cursor ( \"end\" ) def set_text ( self , text : str ): self . setPlainText ( text ) def set_syntaxhighlighter ( self , syntax : str , style : str | None = None ): self . _hl = syntaxhighlighters . PygmentsHighlighter ( self . document (), syntax ) if style is not None : self . _hl . set_style ( style ) def text ( self ) -> str : return self . toPlainText () def select_text ( self , start : int , end : int ): with self . create_cursor () as c : c . select_text ( start , end ) def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) def show_whitespace_and_tabs ( self , show : bool ): \"\"\"Set show white spaces flag.\"\"\" doc = self . document () options = doc . defaultTextOption () flag = QtGui . QTextOption . Flag . ShowTabsAndSpaces if show : options . setFlags ( options . flags () | flag ) # type: ignore else : options . setFlags ( options . flags () & ~ flag ) # type: ignore doc . setDefaultTextOption ( options ) def highlight_current_line ( self , color : types . ColorType = None ): if color is None : color = self . get_palette () . get_color ( \"highlight\" ) else : color = colors . get_color ( color ) extra_selections = [] if not self . isReadOnly (): selection = widgets . TextEdit . ExtraSelection () selection . format . setBackground ( color ) prop = QtGui . QTextFormat . Property . FullWidthSelection selection . format . setProperty ( prop , True ) selection . cursor = self . textCursor () selection . cursor . clearSelection () extra_selections . append ( selection ) self . setExtraSelections ( extra_selections ) @deprecated ( reason = \"This method is deprecated, use set_word_wrap_mode instead.\" ) def set_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): self . set_word_wrap_mode ( mode ) def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ]) @deprecated ( reason = \"This method is deprecated, use get_word_wrap_mode instead.\" ) def get_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : return self . get_word_wrap_mode () def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()] def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ]) def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()] def _on_value_change ( self ): self . value_changed . emit () if self . validator is not None : self . _set_validation_color () def _set_validation_color ( self , state : bool = True ): color = \"orange\" if not self . is_valid () else None self . set_background_color ( color ) def set_validator ( self , validator : QtGui . QValidator | None ): self . validator = validator self . _set_validation_color () def set_regex_validator ( self , regex : str , flags = 0 ) -> gui . RegularExpressionValidator : validator = gui . RegularExpressionValidator ( self ) validator . set_regex ( regex , flags ) self . set_validator ( validator ) return validator def is_valid ( self ) -> bool : if self . validator is None : return True return self . validator . is_valid_value ( self . text ()) def set_value ( self , value : str ): self . setPlainText ( value ) def get_value ( self ) -> str : return self . text () get_line_wrap_mode ( self ) -> LineWrapModeStr Get the current wrap mode. Returns: Type Description LineWrapModeStr Wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()] get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr Get the current word wrap mode. Returns: Type Description gui.textoption.WordWrapModeStr Word wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()] set_line_wrap_mode ( self , mode : LineWrapModeStr ) Set line wrap mode. Parameters: Name Type Description Default mode LineWrapModeStr line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ]) set_read_only ( self , value : bool = True ) Make the PlainTextEdit read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ) Set word wrap mode. Parameters: Name Type Description Default mode gui.textoption.WordWrapModeStr word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ]) show_whitespace_and_tabs ( self , show : bool ) Set show white spaces flag. Source code in prettyqt/widgets/plaintextedit.py def show_whitespace_and_tabs ( self , show : bool ): \"\"\"Set show white spaces flag.\"\"\" doc = self . document () options = doc . defaultTextOption () flag = QtGui . QTextOption . Flag . ShowTabsAndSpaces if show : options . setFlags ( options . flags () | flag ) # type: ignore else : options . setFlags ( options . flags () & ~ flag ) # type: ignore doc . setDefaultTextOption ( options ) wheelEvent ( self , event ) Handle wheel event for zooming. Source code in prettyqt/widgets/plaintextedit.py def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event ) progressbar ProgressBar ( QProgressBar ) Source code in prettyqt/widgets/progressbar.py class ProgressBar ( QtWidgets . QProgressBar ): \"\"\"Progress dialog. wrapper for QtWidgets.QProgressBar \"\"\" def __init__ ( self , text_visible : bool = True , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent = parent ) self . setTextVisible ( text_visible ) def serialize_fields ( self ): return dict ( alignment = self . get_alignment (), format = self . format (), # inverted_appearance=self.invertedAppearance(), minimum = self . minimum (), maximum = self . maximum (), orientation = self . get_orientation (), text = self . text (), # text_direction=self.get_text_direction(), text_visible = self . isTextVisible (), value = self . value (), ) def set_alignment ( self , alignment : constants . AlignmentStr ): \"\"\"Set the alignment of the layout. Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) self . setAlignment ( constants . ALIGNMENTS [ alignment ]) def get_alignment ( self ) -> constants . AlignmentStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . ALIGNMENTS . inverse [ self . alignment ()] def set_text_direction ( self , text_direction : TextDirectionStr ): \"\"\"Set the text direction of the layout. Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ]) def get_text_direction ( self ) -> TextDirectionStr : \"\"\"Return current text direction. Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inverse [ self . textDirection ()] def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the progress bar. Args: orientation: orientation for the progress bar Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] def set_range ( self , start : int , end : int ): self . setRange ( start , end ) def set_value ( self , value : int ): self . setValue ( value ) def get_value ( self ) -> int : return self . value () get_alignment ( self ) -> constants . AlignmentStr Return current alignment. Returns: Type Description constants.AlignmentStr alignment Source code in prettyqt/widgets/progressbar.py def get_alignment ( self ) -> constants . AlignmentStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . ALIGNMENTS . inverse [ self . alignment ()] get_orientation ( self ) -> constants . OrientationStr Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/progressbar.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] get_text_direction ( self ) -> TextDirectionStr Return current text direction. Returns: Type Description TextDirectionStr Text direction Source code in prettyqt/widgets/progressbar.py def get_text_direction ( self ) -> TextDirectionStr : \"\"\"Return current text direction. Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inverse [ self . textDirection ()] set_alignment ( self , alignment : constants . AlignmentStr ) Set the alignment of the layout. Parameters: Name Type Description Default alignment constants.AlignmentStr alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/progressbar.py def set_alignment ( self , alignment : constants . AlignmentStr ): \"\"\"Set the alignment of the layout. Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) self . setAlignment ( constants . ALIGNMENTS [ alignment ]) set_orientation ( self , orientation : constants . OrientationStr ) Set the orientation of the progress bar. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the progress bar required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/progressbar.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the progress bar. Args: orientation: orientation for the progress bar Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) set_text_direction ( self , text_direction : TextDirectionStr ) Set the text direction of the layout. Parameters: Name Type Description Default text_direction TextDirectionStr text direction for the layout required Exceptions: Type Description InvalidParamError text direction does not exist Source code in prettyqt/widgets/progressbar.py def set_text_direction ( self , text_direction : TextDirectionStr ): \"\"\"Set the text direction of the layout. Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ]) scroller Scroller Source code in prettyqt/widgets/scroller.py class Scroller : def __init__ ( self , item : QtWidgets . QScroller ): self . item = item def __getattr__ ( self , val ): return getattr ( self . item , val ) def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()] def get_velocity ( self ) -> core . PointF : return core . PointF ( self . velocity ()) def get_pixel_per_meter ( self ) -> core . PointF : return core . PointF ( self . pixelPerMeter ()) def get_final_position ( self ) -> core . PointF : return core . PointF ( self . finalPosition ()) def handle_input ( self , input_type : InputStr , position : types . PointFType , timestamp : int = 0 ) -> bool : if isinstance ( position , tuple ): position = core . PointF ( * position ) if input_type not in INPUT : raise InvalidParamError ( input_type , INPUT ) return self . handleInput ( INPUT [ input_type ], position , timestamp ) def get_scroller_properties ( self ) -> widgets . ScrollerProperties : return widgets . ScrollerProperties ( self . scrollerProperties ()) @classmethod def get_scroller ( cls , obj : QtCore . QObject ): return cls ( QtWidgets . QScroller . scroller ( obj )) @staticmethod def grab_gesture ( target : QtCore . QObject , gesture_type : ScrollGestureTypeStr = \"touch\" ) -> str : if gesture_type not in SCROLLER_GESTURE_TYPE : raise InvalidParamError ( gesture_type , SCROLLER_GESTURE_TYPE ) gesture = QtWidgets . QScroller . grabGesture ( target , SCROLLER_GESTURE_TYPE [ gesture_type ] ) if gesture >= 256 : gesture -= 256 return constants . GESTURE_TYPE . inverse [ gesture ] get_state ( self ) -> StateStr Return current state. Returns: Type Description StateStr state Source code in prettyqt/widgets/scroller.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()] scrollerproperties ScrollerProperties ( QScrollerProperties ) Source code in prettyqt/widgets/scrollerproperties.py class ScrollerProperties ( QtWidgets . QScrollerProperties ): def __getitem__ ( self , metric : ScrollmetricStr ): return self . get_scroll_metric ( metric ) def __setitem__ ( self , metric : ScrollmetricStr , value : Any ): self . set_scroll_metric ( metric , value ) def set_scroll_metric ( self , metric : ScrollmetricStr , value : Any ): \"\"\"Set scroll metric. Args: metric: Scroll metric to set value: Value to set Raises: InvalidParamError: metric does not exist \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) self . setScrollMetric ( SCROLL_METRIC [ metric ], value ) def get_scroll_metric ( self , metric : ScrollmetricStr ) -> Any : \"\"\"Return scroll metric. Args: metric: Scroll metric to get Raises: InvalidParamError: metric does not exist Returns: state \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) return self . scrollMetric ( SCROLL_METRIC [ metric ]) get_scroll_metric ( self , metric : ScrollmetricStr ) -> Any Return scroll metric. Parameters: Name Type Description Default metric ScrollmetricStr Scroll metric to get required Exceptions: Type Description InvalidParamError metric does not exist Returns: Type Description Any state Source code in prettyqt/widgets/scrollerproperties.py def get_scroll_metric ( self , metric : ScrollmetricStr ) -> Any : \"\"\"Return scroll metric. Args: metric: Scroll metric to get Raises: InvalidParamError: metric does not exist Returns: state \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) return self . scrollMetric ( SCROLL_METRIC [ metric ]) set_scroll_metric ( self , metric : ScrollmetricStr , value : Any ) Set scroll metric. Parameters: Name Type Description Default metric ScrollmetricStr Scroll metric to set required value Any Value to set required Exceptions: Type Description InvalidParamError metric does not exist Source code in prettyqt/widgets/scrollerproperties.py def set_scroll_metric ( self , metric : ScrollmetricStr , value : Any ): \"\"\"Set scroll metric. Args: metric: Scroll metric to set value: Value to set Raises: InvalidParamError: metric does not exist \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) self . setScrollMetric ( SCROLL_METRIC [ metric ], value ) shortcut Shortcut ( QShortcut ) Source code in prettyqt/widgets/shortcut.py class Shortcut ( QtWidgets . QShortcut ): def __str__ ( self ): return self . key () . toString () def serialize_field ( self ): return dict ( auto_repeat = self . autoRepeat (), context = self . get_context (), enabled = self . isEnabled (), key = self . get_key (), whats_this = self . whatsThis (), ) def set_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setContext ( constants . CONTEXT [ context ]) def get_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . context ()] def get_key ( self ) -> gui . KeySequence : \"\"\"Return the shortcut's key sequence. Returns: Key sequence \"\"\" return gui . KeySequence ( self . key () . toString (), gui . KeySequence . SequenceFormat . PortableText ) get_context ( self ) -> constants . ContextStr Return shortcut context. Returns: Type Description constants.ContextStr shortcut context Source code in prettyqt/widgets/shortcut.py def get_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . context ()] get_key ( self ) -> gui . KeySequence Return the shortcut's key sequence. Returns: Type Description gui.KeySequence Key sequence Source code in prettyqt/widgets/shortcut.py def get_key ( self ) -> gui . KeySequence : \"\"\"Return the shortcut's key sequence. Returns: Key sequence \"\"\" return gui . KeySequence ( self . key () . toString (), gui . KeySequence . SequenceFormat . PortableText ) set_context ( self , context : constants . ContextStr ) Set shortcut context. Parameters: Name Type Description Default context constants.ContextStr shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/shortcut.py def set_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setContext ( constants . CONTEXT [ context ]) sizepolicy SizePolicy ( PrettyPrinter , QSizePolicy ) Source code in prettyqt/widgets/sizepolicy.py class SizePolicy ( prettyprinter . PrettyPrinter , QtWidgets . QSizePolicy ): def __repr__ ( self ) -> str : cls_name = type ( self ) . __name__ params = helpers . format_kwargs ( self . __getstate__ ()) return f \" { cls_name } ( { params } )\" def __getstate__ ( self ): return dict ( has_height_for_width = self . hasHeightForWidth (), has_width_for_height = self . hasWidthForHeight (), horizontal_stretch = self . horizontalStretch (), vertical_stretch = self . verticalStretch (), horizontal_policy = self . get_horizontal_policy (), vertical_policy = self . get_vertical_policy (), retain_size_when_hidden = self . retainSizeWhenHidden (), control_type = self . get_control_type (), ) def __setstate__ ( self , state : dict [ str , Any ]) -> None : self . setHeightForWidth ( state [ \"has_height_for_width\" ]) self . setWidthForHeight ( state [ \"has_width_for_height\" ]) self . setHorizontalStretch ( state [ \"horizontal_stretch\" ]) self . setVerticalStretch ( state [ \"vertical_stretch\" ]) self . set_horizontal_policy ( state [ \"horizontal_policy\" ]) self . set_vertical_policy ( state [ \"vertical_policy\" ]) self . setRetainSizeWhenHidden ( state [ \"retain_size_when_hidden\" ]) self . set_control_type ( state [ \"control_type\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def serialize ( self ) -> dict [ str , Any ]: return self . __getstate__ () @classmethod def clone ( cls , qpol : QtWidgets . QSizePolicy ) -> SizePolicy : pol = cls ( qpol . horizontalPolicy (), qpol . verticalPolicy (), qpol . controlType ()) pol . setHeightForWidth ( qpol . hasHeightForWidth ()) pol . setWidthForHeight ( qpol . hasWidthForHeight ()) pol . setHorizontalStretch ( qpol . horizontalStretch ()) pol . setVerticalStretch ( qpol . verticalStretch ()) pol . setRetainSizeWhenHidden ( qpol . retainSizeWhenHidden ()) return pol def get_horizontal_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: horizontal size policy \"\"\" return SIZE_POLICY . inverse [ self . horizontalPolicy ()] def set_horizontal_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setHorizontalPolicy ( SIZE_POLICY [ policy ]) def get_vertical_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: vertical size policy \"\"\" return SIZE_POLICY . inverse [ self . verticalPolicy ()] def set_vertical_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setVerticalPolicy ( SIZE_POLICY [ policy ]) def get_control_type ( self ) -> ControlTypeStr : \"\"\"Return control type. Returns: control type \"\"\" return CONTROL_TYPE . inverse [ self . controlType ()] def set_control_type ( self , typ : ControlTypeStr ) -> None : \"\"\"Set the control type. Args: typ: control type to set Raises: InvalidParamError: control type does not exist \"\"\" if typ not in CONTROL_TYPE : raise InvalidParamError ( typ , CONTROL_TYPE ) self . setControlType ( CONTROL_TYPE [ typ ]) get_control_type ( self ) -> ControlTypeStr Return control type. Returns: Type Description ControlTypeStr control type Source code in prettyqt/widgets/sizepolicy.py def get_control_type ( self ) -> ControlTypeStr : \"\"\"Return control type. Returns: control type \"\"\" return CONTROL_TYPE . inverse [ self . controlType ()] get_horizontal_policy ( self ) -> SizePolicyStr Return size policy. Returns: Type Description SizePolicyStr horizontal size policy Source code in prettyqt/widgets/sizepolicy.py def get_horizontal_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: horizontal size policy \"\"\" return SIZE_POLICY . inverse [ self . horizontalPolicy ()] get_vertical_policy ( self ) -> SizePolicyStr Return size policy. Returns: Type Description SizePolicyStr vertical size policy Source code in prettyqt/widgets/sizepolicy.py def get_vertical_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: vertical size policy \"\"\" return SIZE_POLICY . inverse [ self . verticalPolicy ()] set_control_type ( self , typ : ControlTypeStr ) -> None Set the control type. Parameters: Name Type Description Default typ ControlTypeStr control type to set required Exceptions: Type Description InvalidParamError control type does not exist Source code in prettyqt/widgets/sizepolicy.py def set_control_type ( self , typ : ControlTypeStr ) -> None : \"\"\"Set the control type. Args: typ: control type to set Raises: InvalidParamError: control type does not exist \"\"\" if typ not in CONTROL_TYPE : raise InvalidParamError ( typ , CONTROL_TYPE ) self . setControlType ( CONTROL_TYPE [ typ ]) set_horizontal_policy ( self , policy : SizePolicyStr ) -> None Set the horizontal policy. Parameters: Name Type Description Default policy SizePolicyStr policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_horizontal_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setHorizontalPolicy ( SIZE_POLICY [ policy ]) set_vertical_policy ( self , policy : SizePolicyStr ) -> None Set the horizontal policy. Parameters: Name Type Description Default policy SizePolicyStr policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_vertical_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setVerticalPolicy ( SIZE_POLICY [ policy ]) slider Slider ( QSlider ) Source code in prettyqt/widgets/slider.py class Slider ( QtWidgets . QSlider ): value_changed = core . Signal ( int ) def __init__ ( self , orientation : ( constants . OrientationStr | QtCore . Qt . Orientation ) = \"horizontal\" , parent : QtWidgets . QWidget | None = None , ): if isinstance ( orientation , QtCore . Qt . Orientation ): ori = orientation else : ori = constants . ORIENTATION [ orientation ] super () . __init__ ( ori , parent ) self . valueChanged . connect ( self . on_value_change ) def serialize_fields ( self ): return dict ( tick_position = self . get_tick_position (), tick_interval = self . tickInterval (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_tick_position ( state [ \"tick_position\" ]) self . setTickInterval ( state [ \"tick_interval\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def set_tick_position ( self , position : TickPositionAllStr ): \"\"\"Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITION : raise InvalidParamError ( position , TICK_POSITION ) self . setTickPosition ( TICK_POSITION [ position ]) def get_tick_position ( self ) -> TickPositionStr : \"\"\"Return tick position. Returns: tick position \"\"\" return TICK_POSITION . inverse [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\" get_tick_position ( self ) -> TickPositionStr Return tick position. Returns: Type Description TickPositionStr tick position Source code in prettyqt/widgets/slider.py def get_tick_position ( self ) -> TickPositionStr : \"\"\"Return tick position. Returns: tick position \"\"\" return TICK_POSITION . inverse [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\" set_tick_position ( self , position : TickPositionAllStr ) Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Parameters: Name Type Description Default position TickPositionAllStr position for the ticks required Source code in prettyqt/widgets/slider.py def set_tick_position ( self , position : TickPositionAllStr ): \"\"\"Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITION : raise InvalidParamError ( position , TICK_POSITION ) self . setTickPosition ( TICK_POSITION [ position ]) splitter Splitter ( QSplitter ) Source code in prettyqt/widgets/splitter.py class Splitter ( QtWidgets . QSplitter ): def __init__ ( self , orientation : ( constants . OrientationStr | QtCore . Qt . Orientation ) = \"horizontal\" , parent : QtWidgets . QWidget | None = None , ): if isinstance ( orientation , QtCore . Qt . Orientation ): ori = orientation else : ori = constants . ORIENTATION [ orientation ] super () . __init__ ( ori , parent ) def __getitem__ ( self , index : int | str ) -> QtWidgets . QWidget : if isinstance ( index , int ): return self . widget ( index ) else : result = self . find_child ( QtWidgets . QWidget , index ) if result is None : raise KeyError ( \"Widget not found\" ) return result def __setitem__ ( self , index : int , value : QtWidgets . QWidget ): self . replaceWidget ( index , value ) def serialize_fields ( self ): return dict ( items = self . get_children (), orientation = self . get_orientation (), handle_width = self . handleWidth (), children_collapsible = self . childrenCollapsible (), opaque_resize = self . opaqueResize (), ) def __setstate__ ( self , state ): for item in state [ \"items\" ]: self . addWidget ( item ) self . setHandleWidth ( state [ \"handle_width\" ]) self . setChildrenCollapsible ( state [ \"children_collapsible\" ]) self . setOpaqueResize ( state [ \"opaque_resize\" ]) def __reduce__ ( self ): return type ( self ), ( self . orientation (),), self . __getstate__ () def __iter__ ( self ) -> Iterator [ QtWidgets . QWidget ]: return iter ( self . get_children ()) def __len__ ( self ) -> int : return self . count () def __contains__ ( self , item : QtWidgets . QWidget ): return self . indexOf ( item ) >= 0 def __add__ ( self , other : QtWidgets . QWidget | QtWidgets . QLayout ): self . add ( other ) return self def get_children ( self ) -> list [ QtWidgets . QWidget ]: return [ self [ i ] for i in range ( self . count ())] def add_widget ( self , widget : QtWidgets . QWidget ): self . addWidget ( widget ) def add_layout ( self , layout : QtWidgets . QLayout ) -> widgets . Widget : widget = widgets . Widget () widget . set_layout ( layout ) self . addWidget ( widget ) return widget def add ( self , * item : QtWidgets . QWidget | QtWidgets . QLayout ): for i in item : if isinstance ( i , QtWidgets . QWidget ): self . add_widget ( i ) else : self . add_layout ( i ) @classmethod def from_widgets ( cls , * widgets : QtWidgets . QWidget , horizontal : bool = False , parent : QtWidgets . QWidget | None = None , ): splitter = cls ( \"horizontal\" if horizontal else \"vertical\" , parent = parent ) for widget in widgets : splitter += widget return splitter def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the splitter. Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] get_orientation ( self ) -> constants . OrientationStr Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/splitter.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] set_orientation ( self , orientation : constants . OrientationStr ) Set the orientation of the splitter. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitter.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the splitter. Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) splitterhandle SplitterHandle ( QSplitterHandle ) Source code in prettyqt/widgets/splitterhandle.py class SplitterHandle ( QtWidgets . QSplitterHandle ): def __init__ ( self , orientation : constants . OrientationStr | QtCore . Qt . Orientation , parent : QtWidgets . QSplitter , ): if isinstance ( orientation , QtCore . Qt . Orientation ): ori = orientation else : ori = constants . ORIENTATION [ orientation ] super () . __init__ ( ori , parent ) def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the slider. Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] get_orientation ( self ) -> constants . OrientationStr Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/splitterhandle.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] set_orientation ( self , orientation : constants . OrientationStr ) Set the orientation of the slider. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the slider required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitterhandle.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the slider. Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) styleoptionslider StyleOptionSlider ( QStyleOptionSlider ) Source code in prettyqt/widgets/styleoptionslider.py class StyleOptionSlider ( QtWidgets . QStyleOptionSlider ): def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == constants . HORIZONTAL def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == constants . VERTICAL def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = constants . HORIZONTAL def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = constants . VERTICAL def get_orientation ( self ) -> Literal [ \"horizontal\" , \"vertical\" ]: return \"horizontal\" if self . is_horizontal () else \"vertical\" is_horizontal ( self ) -> bool Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == constants . HORIZONTAL is_vertical ( self ) -> bool Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == constants . VERTICAL set_horizontal ( self ) -> None Set slider orientation to horizontal. Source code in prettyqt/widgets/styleoptionslider.py def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = constants . HORIZONTAL set_vertical ( self ) -> None Set slider orientation to vertical. Source code in prettyqt/widgets/styleoptionslider.py def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = constants . VERTICAL swipegesture SwipeGesture ( QSwipeGesture ) Source code in prettyqt/widgets/swipegesture.py class SwipeGesture ( QtWidgets . QSwipeGesture ): def get_horizontal_direction ( self ) -> HorizontalDirectionStr : \"\"\"Return horizontal direction of the gesture. Returns: horizontal direction \"\"\" return SWIPE_DIRECTION . inverse [ self . horizontalDirection ()] def get_vertical_direction ( self ) -> VerticalDirectionStr : \"\"\"Return vertical direction of the gesture. Returns: vertical direction \"\"\" return SWIPE_DIRECTION . inverse [ self . verticalDirection ()] get_horizontal_direction ( self ) -> HorizontalDirectionStr Return horizontal direction of the gesture. Returns: Type Description HorizontalDirectionStr horizontal direction Source code in prettyqt/widgets/swipegesture.py def get_horizontal_direction ( self ) -> HorizontalDirectionStr : \"\"\"Return horizontal direction of the gesture. Returns: horizontal direction \"\"\" return SWIPE_DIRECTION . inverse [ self . horizontalDirection ()] get_vertical_direction ( self ) -> VerticalDirectionStr Return vertical direction of the gesture. Returns: Type Description VerticalDirectionStr vertical direction Source code in prettyqt/widgets/swipegesture.py def get_vertical_direction ( self ) -> VerticalDirectionStr : \"\"\"Return vertical direction of the gesture. Returns: vertical direction \"\"\" return SWIPE_DIRECTION . inverse [ self . verticalDirection ()] systemtrayicon SystemTrayIcon ( QSystemTrayIcon ) Source code in prettyqt/widgets/systemtrayicon.py class SystemTrayIcon ( QtWidgets . QSystemTrayIcon ): def set_icon ( self , icon : types . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def show_message ( self , title : str , message : str = \"\" , icon : types . IconType = None , timeout : int = 10 , ): if icon is None : ico = gui . Icon () if icon in MESSAGE_ICONS : ico = MESSAGE_ICONS [ icon ] else : ico = iconprovider . get_icon ( icon ) self . showMessage ( title , message , ico , timeout * 1000 ) set_icon ( self , icon : types . IconType ) Set the system tray icon. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/systemtrayicon.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) tabbar TabBar ( QTabBar ) Source code in prettyqt/widgets/tabbar.py class TabBar ( QtWidgets . QTabBar ): on_detach = QtCore . Signal ( int , QtCore . QPoint ) def __init__ ( self , parent : QtWidgets . QWidget | None = None ) -> None : super () . __init__ ( parent ) self . setAcceptDrops ( True ) self . set_elide_mode ( \"right\" ) self . set_selection_behavior_on_remove ( \"left_tab\" ) def __getitem__ ( self , index : tuple [ int , str ]): return self . tabButton ( index [ 0 ], POSITIONS [ index [ 1 ]]) def __setitem__ ( self , index : tuple [ int , PositionStr ], value : QtWidgets . QWidget | None ): self . set_tab ( index [ 0 ], index [ 1 ], value ) def serialize_fields ( self ): return dict ( movable = self . isMovable (), document_mode = self . documentMode (), current_index = self . currentIndex (), # shape=self.shape(), draw_base = self . drawBase (), elide_mode = self . get_elide_mode (), icon_size = core . Size ( self . iconSize ()), ) def __setstate__ ( self , state ): self . setDocumentMode ( state . get ( \"document_mode\" , False )) self . setMovable ( state . get ( \"movable\" , False )) # self.setShape(state.get(\"shape\", \"rounded\")) self . setIconSize ( state [ \"icon_size\" ]) self . setDrawBase ( state . get ( \"draw_base\" )) self . set_elide_mode ( state . get ( \"elide_mode\" )) self . setCurrentIndex ( state . get ( \"index\" , 0 )) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () # Send the on_detach when a tab is double clicked def mouseDoubleClickEvent ( self , event ): event . accept () tab = self . tabAt ( event . position ()) pos = QtGui . QCursor . pos () self . on_detach . emit ( tab , pos ) def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) def get_icon_size ( self ) -> core . Size : return core . Size ( self . iconSize ()) def set_tab ( self , index : int , position : PositionStr , widget : QtWidgets . QWidget | None ) -> None : self . setTabButton ( index , POSITIONS [ position ], widget ) # type: ignore @deprecated ( reason = \"This method is deprecated, use set_selection_behavior_on_remove instead.\" ) def set_remove_behaviour ( self , mode : RemoveBehaviourStr ) -> None : self . set_selection_behavior_on_remove ( mode ) def set_selection_behavior_on_remove ( self , mode : RemoveBehaviourStr ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOUR : raise InvalidParamError ( mode , REMOVE_BEHAVIOUR ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOUR [ mode ]) def get_remove_behaviour ( self ) -> RemoveBehaviourStr : \"\"\"Return remove behaviour. Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOUR . inverse [ self . selectionBehaviorOnRemove ()] def set_elide_mode ( self , mode : constants . ElideModeStr ) -> None : \"\"\"Set elide mode. Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in constants . ELIDE_MODE : raise InvalidParamError ( mode , constants . ELIDE_MODE ) self . setElideMode ( constants . ELIDE_MODE [ mode ]) def get_elide_mode ( self ) -> constants . ElideModeStr : \"\"\"Return elide mode. Returns: elide mode \"\"\" return constants . ELIDE_MODE . inverse [ self . elideMode ()] get_elide_mode ( self ) -> constants . ElideModeStr Return elide mode. Returns: Type Description constants.ElideModeStr elide mode Source code in prettyqt/widgets/tabbar.py def get_elide_mode ( self ) -> constants . ElideModeStr : \"\"\"Return elide mode. Returns: elide mode \"\"\" return constants . ELIDE_MODE . inverse [ self . elideMode ()] get_remove_behaviour ( self ) -> RemoveBehaviourStr Return remove behaviour. Returns: Type Description RemoveBehaviourStr remove behaviour Source code in prettyqt/widgets/tabbar.py def get_remove_behaviour ( self ) -> RemoveBehaviourStr : \"\"\"Return remove behaviour. Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOUR . inverse [ self . selectionBehaviorOnRemove ()] mouseDoubleClickEvent ( self , event ) mouseDoubleClickEvent(self, arg__1: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/widgets/tabbar.py def mouseDoubleClickEvent ( self , event ): event . accept () tab = self . tabAt ( event . position ()) pos = QtGui . QCursor . pos () self . on_detach . emit ( tab , pos ) set_elide_mode ( self , mode : constants . ElideModeStr ) -> None Set elide mode. Parameters: Name Type Description Default mode constants.ElideModeStr elide mode to use required Exceptions: Type Description InvalidParamError invalid elide mode Source code in prettyqt/widgets/tabbar.py def set_elide_mode ( self , mode : constants . ElideModeStr ) -> None : \"\"\"Set elide mode. Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in constants . ELIDE_MODE : raise InvalidParamError ( mode , constants . ELIDE_MODE ) self . setElideMode ( constants . ELIDE_MODE [ mode ]) set_icon_size ( self , size : int | types . SizeType ) Set size of the icons. Source code in prettyqt/widgets/tabbar.py def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) set_selection_behavior_on_remove ( self , mode : RemoveBehaviourStr ) -> None Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Parameters: Name Type Description Default mode RemoveBehaviourStr new remove behaviour required Source code in prettyqt/widgets/tabbar.py def set_selection_behavior_on_remove ( self , mode : RemoveBehaviourStr ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOUR : raise InvalidParamError ( mode , REMOVE_BEHAVIOUR ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOUR [ mode ]) tableview TableView ( QTableView ) Source code in prettyqt/widgets/tableview.py class TableView ( QtWidgets . QTableView ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) class_name = type ( self ) . __name__ self . set_id ( class_name ) self . setHorizontalHeader ( widgets . HeaderView ( \"horizontal\" , parent = self )) self . setVerticalHeader ( widgets . HeaderView ( \"vertical\" , parent = self )) self . setAlternatingRowColors ( True ) self . setWordWrap ( False ) def serialize_fields ( self ): return dict ( corner_button_enabled = self . isCornerButtonEnabled (), grid_style = self . get_grid_style (), show_grid = self . showGrid (), sorting_enabled = self . isSortingEnabled (), word_wrap = self . wordWrap (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setCornerButtonEnabled ( state [ \"corner_button_enabled\" ]) self . set_grid_style ( state [ \"grid_style\" ]) self . setShowGrid ( state [ \"show_grid\" ]) self . setSortingEnabled ( state [ \"sorting_enabled\" ]) self . setWordWrap ( state [ \"word_wrap\" ]) @property def h_header ( self ): return self . horizontalHeader () @h_header . setter def h_header ( self , header ): self . setHorizontalHeader ( header ) @property def v_header ( self ): return self . verticalHeader () @v_header . setter def v_header ( self , header ): self . setVerticalHeader ( header ) def setup_list_style ( self ): self . set_selection_behaviour ( \"rows\" ) self . h_header . setStretchLastSection ( True ) self . v_header . set_resize_mode ( \"fixed\" ) self . v_header . set_default_section_size ( 28 ) def adapt_sizes ( self ): model = self . model () if model is not None and ( model . rowCount () * model . columnCount ()) < 1000 : self . resizeColumnsToContents () else : self . h_header . resize_sections ( \"interactive\" ) def sort_by_column ( self , column : int | None , ascending : bool = True ): column = - 1 if column is None else column order = constants . ASCENDING if ascending else constants . DESCENDING self . sortByColumn ( column , order ) def set_grid_style ( self , style : constants . PenStyleStr ): \"\"\"Set grid style. Args: style: grid style to use Raises: InvalidParamError: invalid grid style \"\"\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setGridStyle ( constants . PEN_STYLE [ style ]) def get_grid_style ( self ) -> constants . PenStyleStr : \"\"\"Return grid style. Returns: grid style \"\"\" return constants . PEN_STYLE . inverse [ self . gridStyle ()] get_grid_style ( self ) -> constants . PenStyleStr Return grid style. Returns: Type Description constants.PenStyleStr grid style Source code in prettyqt/widgets/tableview.py def get_grid_style ( self ) -> constants . PenStyleStr : \"\"\"Return grid style. Returns: grid style \"\"\" return constants . PEN_STYLE . inverse [ self . gridStyle ()] set_grid_style ( self , style : constants . PenStyleStr ) Set grid style. Parameters: Name Type Description Default style constants.PenStyleStr grid style to use required Exceptions: Type Description InvalidParamError invalid grid style Source code in prettyqt/widgets/tableview.py def set_grid_style ( self , style : constants . PenStyleStr ): \"\"\"Set grid style. Args: style: grid style to use Raises: InvalidParamError: invalid grid style \"\"\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setGridStyle ( constants . PEN_STYLE [ style ]) tablewidgetitem TableWidgetItem ( QTableWidgetItem ) Source code in prettyqt/widgets/tablewidgetitem.py class TableWidgetItem ( QtWidgets . QTableWidgetItem ): def __setitem__ ( self , index : int , value ): self . setData ( index , value ) def __getitem__ ( self , index : int ): return self . data ( index ) def serialize_fields ( self ): return dict ( text = self . text (), tool_tip = self . toolTip (), status_tip = self . statusTip (), checkstate = self . get_checkstate (), icon = self . get_icon (), data = self . data ( constants . USER_ROLE ), # type: ignore ) def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] def set_text_alignment ( self , horizontal : constants . HorizontalAlignmentStr | None = None , vertical : constants . VerticalAlignmentStr | None = None , ): \"\"\"Set text alignment of the checkbox. Args: horizontal: horizontal text alignment to use vertical: vertical text alignment to use Raises: InvalidParamError: invalid text alignment \"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setTextAlignment ( flag ) def get_background ( self ) -> gui . Brush : return gui . Brush ( self . background ()) def get_foreground ( self ) -> gui . Brush : return gui . Brush ( self . foreground ()) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_tooltip ( self , tooltip : str | types . PathType , size : types . SizeType | None = None , ): if isinstance ( tooltip , os . PathLike ): path = os . fspath ( tooltip ) if size is None : tooltip = f \"<img src= { path !r} >\" else : if isinstance ( size , QtCore . QSize ): size = ( size . width (), size . height ()) tooltip = f '<img src= { path !r} width=\" { size [ 0 ] } \" height=\" { size [ 1 ] } \">' self . setToolTip ( tooltip ) get_checkstate ( self ) -> constants . StateStr Return checkstate. Returns: Type Description constants.StateStr checkstate Source code in prettyqt/widgets/tablewidgetitem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] set_checkstate ( self , state : constants . StateStr ) Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/tablewidgetitem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) set_icon ( self , icon : types . IconType ) Set the icon for the action. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/tablewidgetitem.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) set_text_alignment ( self , horizontal : constants . HorizontalAlignmentStr | None = None , vertical : constants . VerticalAlignmentStr | None = None ) Set text alignment of the checkbox. Parameters: Name Type Description Default horizontal constants.HorizontalAlignmentStr | None horizontal text alignment to use None vertical constants.VerticalAlignmentStr | None vertical text alignment to use None Exceptions: Type Description InvalidParamError invalid text alignment Source code in prettyqt/widgets/tablewidgetitem.py def set_text_alignment ( self , horizontal : constants . HorizontalAlignmentStr | None = None , vertical : constants . VerticalAlignmentStr | None = None , ): \"\"\"Set text alignment of the checkbox. Args: horizontal: horizontal text alignment to use vertical: vertical text alignment to use Raises: InvalidParamError: invalid text alignment \"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setTextAlignment ( flag ) tabwidget DetachedTab ( MainWindow ) Source code in prettyqt/widgets/tabwidget.py class DetachedTab ( widgets . MainWindow ): \"\"\"Window containing a detached tab. When a tab is detached, the contents are placed into this QMainWindow. The tab can be re-attached by closing the dialog Attributes: on_close: signal, emitted when window is closed (widget, title, icon) \"\"\" on_close = core . Signal ( QtWidgets . QWidget , str , QtGui . QIcon ) def __init__ ( self , name : str , widget : QtWidgets . QWidget ): super () . __init__ ( None ) self . set_id ( name ) self . set_title ( name ) self . widget = widget self . setCentralWidget ( self . widget ) self . widget . show () # If the window is closed, emit the on_close and give the # content widget back to the DetachableTabWidget def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . get_id (), self . windowIcon ()) closeEvent ( self , event ) closeEvent(self, event: PySide6.QtGui.QCloseEvent) -> None Source code in prettyqt/widgets/tabwidget.py def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . get_id (), self . windowIcon ()) TabWidget ( QTabWidget ) Source code in prettyqt/widgets/tabwidget.py class TabWidget ( QtWidgets . QTabWidget ): \"\"\"Widget for managing the tabs section.\"\"\" def __init__ ( self , parent : QtWidgets . QWidget | None = None , closable : bool = False , detachable : bool = False , ) -> None : # Basic initalization super () . __init__ ( parent ) self . tabCloseRequested . connect ( self . remove_tab ) self . tab_bar = widgets . TabBar ( self ) self . setTabBar ( self . tab_bar ) # Used to keep a reference to detached tabs since their QMainWindow # does not have a parent self . detached_tabs : dict [ str , DetachedTab ] = {} if detachable : self . set_detachable () self . set_closable ( closable ) def __len__ ( self ) -> int : return self . count () def __getitem__ ( self , index : int ) -> QtWidgets . QWidget : if isinstance ( index , int ): return self . widget ( index ) else : result = self . findChild ( QtWidgets . QWidget , index ) if result is None : raise KeyError ( \"Widget not found\" ) return result def __contains__ ( self , item : QtWidgets . QWidget ): return self . indexOf ( item ) >= 0 def serialize_fields ( self ): return dict ( tabbar = self . tabBar (), widgets = self . get_children (), movable = self . isMovable (), document_mode = self . documentMode (), current_index = self . currentIndex (), tab_shape = self . get_tab_shape (), # elide_mode=self.get_elide_mode(), icon_size = self . iconSize (), tab_position = self . get_tab_position (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setTabBar ( state [ \"tabbar\" ]) self . setDocumentMode ( state . get ( \"document_mode\" , False )) self . setMovable ( state . get ( \"movable\" , False )) self . set_tab_shape ( state . get ( \"tab_shape\" , \"rounded\" )) self . setIconSize ( state [ \"icon_size\" ]) for ( widget , name , icon , tooltip , whatsthis ) in state [ \"widgets\" ]: i = self . add_tab ( widget , name , icon ) self . setTabToolTip ( i , tooltip ) self . setTabWhatsThis ( i , whatsthis ) self . setCurrentIndex ( state . get ( \"index\" , 0 )) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def update_tab_bar_visibility ( self ): \"\"\"Update visibility of the tabBar depending of the number of tabs. 0 or 1 tab -> tabBar hidden, 2+ tabs - >tabBar visible need to be called explicitly, or be connected to tabInserted/tabRemoved \"\"\" self . tabBar () . setVisible ( self . count () > 1 ) def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) def set_document_mode ( self , state : bool = True ) -> None : self . setDocumentMode ( state ) def set_tab_shape ( self , shape : TabShapeStr ): \"\"\"Set tab shape for the tabwidget. Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ]) def get_tab_shape ( self ) -> TabShapeStr : \"\"\"Return tab shape. Returns: tab shape \"\"\" return TAB_SHAPES . inverse [ self . tabShape ()] def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the tabwidget. Args: position: tab position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ]) def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()] def get_children ( self ) -> list [ tuple ]: return [ ( self . widget ( i ), self . tabText ( i ), self . tab_icon ( i ), self . tabToolTip ( i ), self . tabWhatsThis ( i ), ) for i in range ( self . count ()) ] def tab_icon ( self , i : int ) -> gui . Icon | None : icon = self . tabIcon ( i ) if icon . isNull (): return None return gui . Icon ( icon ) def set_detachable ( self ): self . tab_bar . on_detach . connect ( self . detach_tab ) core . CoreApplication . call_on_exit ( self . close_detached_tabs ) self . setMovable ( True ) def set_closable ( self , closable : bool = True ): self . setTabsClosable ( closable ) @core . Slot ( int , QtCore . QPoint ) def detach_tab ( self , index : int , point : types . PointType ): \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) name = self . tabText ( index ) icon = self . tab_icon ( index ) if icon is None : icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab def add_tab ( self , item : QtWidgets . QWidget | QtWidgets . QLayout , label : str , icon : types . IconType = None , position : int | None = None , show : bool = False , ) -> int : if isinstance ( item , QtWidgets . QLayout ): widget = widgets . Widget () widget . set_layout ( item ) else : widget = item if position is None : position = len ( self ) if not icon : index = self . insertTab ( position , widget , label ) else : icon = iconprovider . get_icon ( icon ) index = self . insertTab ( position , widget , icon , label ) if show : self . setCurrentIndex ( index ) return index def attach_tab ( self , widget : QtWidgets . QWidget | QtWidgets . QLayout , name : str , icon : types . IconType = None , insert_at : int | None = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (types.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True ) def close_detached_tabs ( self ): \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close () @core . Slot ( int ) def remove_tab ( self , index : int ): widget = self . widget ( index ) self . removeTab ( index ) if widget is not None : widget . deleteLater () @core . Slot ( QtWidgets . QWidget , str ) def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True ) def set_tab ( self , index : int , position : str , widget : QtWidgets . QWidget | None = None ): self . tabBar () . set_tab ( index , position , widget ) attach_tab ( self , widget : QtWidgets . QWidget | QtWidgets . QLayout , name : str , icon : types . IconType = None , insert_at : int | None = None ) Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Parameters: Name Type Description Default widget Union[QtWidgets.QWidget, QtWidgets.QLayout] the content widget from the DetachedTab window required name str the name of the detached tab required icon types.IconType the window icon for the detached tab None insert_at Optional[int] insert the re-attached tab at the given index None Source code in prettyqt/widgets/tabwidget.py def attach_tab ( self , widget : QtWidgets . QWidget | QtWidgets . QLayout , name : str , icon : types . IconType = None , insert_at : int | None = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (types.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True ) close_detached_tabs ( self ) Close all tabs that are currently detached. Source code in prettyqt/widgets/tabwidget.py def close_detached_tabs ( self ): \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close () detach_tab ( self , index : int , point : types . PointType ) Detach tab by removing its contents and placing them in a DetachedTab window. Parameters: Name Type Description Default index int index location of the tab to be detached required point QtCore.QPoint screen pos for creating the new DetachedTab window required Returns: Type Description None Description Source code in prettyqt/widgets/tabwidget.py @core . Slot ( int , QtCore . QPoint ) def detach_tab ( self , index : int , point : types . PointType ): \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) name = self . tabText ( index ) icon = self . tab_icon ( index ) if icon is None : icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab get_tab_position ( self ) -> TabPositionStr Return tab position. Returns: Type Description TabPositionStr tab position Source code in prettyqt/widgets/tabwidget.py def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()] get_tab_shape ( self ) -> TabShapeStr Return tab shape. Returns: Type Description TabShapeStr tab shape Source code in prettyqt/widgets/tabwidget.py def get_tab_shape ( self ) -> TabShapeStr : \"\"\"Return tab shape. Returns: tab shape \"\"\" return TAB_SHAPES . inverse [ self . tabShape ()] open_widget ( self , widget : QtWidgets . QWidget , title : str = 'Unnamed' ) Create a tab containing delivered widget. Source code in prettyqt/widgets/tabwidget.py @core . Slot ( QtWidgets . QWidget , str ) def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True ) set_icon_size ( self , size : int | types . SizeType ) Set size of the icons. Source code in prettyqt/widgets/tabwidget.py def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) set_tab_position ( self , position : TabPositionStr ) Set tab position for the tabwidget. Parameters: Name Type Description Default position TabPositionStr tab position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the tabwidget. Args: position: tab position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ]) set_tab_shape ( self , shape : TabShapeStr ) Set tab shape for the tabwidget. Parameters: Name Type Description Default shape TabShapeStr tab shape to use required Exceptions: Type Description InvalidParamError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_shape ( self , shape : TabShapeStr ): \"\"\"Set tab shape for the tabwidget. Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ]) update_tab_bar_visibility ( self ) Update visibility of the tabBar depending of the number of tabs. 0 or 1 tab -> tabBar hidden, 2+ tabs - >tabBar visible need to be called explicitly, or be connected to tabInserted/tabRemoved Source code in prettyqt/widgets/tabwidget.py def update_tab_bar_visibility ( self ): \"\"\"Update visibility of the tabBar depending of the number of tabs. 0 or 1 tab -> tabBar hidden, 2+ tabs - >tabBar visible need to be called explicitly, or be connected to tabInserted/tabRemoved \"\"\" self . tabBar () . setVisible ( self . count () > 1 ) textedit TextEdit ( QTextEdit ) Source code in prettyqt/widgets/textedit.py class TextEdit ( QtWidgets . QTextEdit ): value_changed = core . Signal ( str ) def __init__ ( self , * args , ** kwargs ) -> None : super () . __init__ ( * args , ** kwargs ) self . textChanged . connect ( self . on_value_change ) def serialize_fields ( self ): return dict ( text = self . text (), accept_rich_text = self . acceptRichText (), auto_formatting = self . get_auto_formatting (), cursor_width = self . cursorWidth (), document_title = self . documentTitle (), line_wrap_column_or_width = self . lineWrapColumnOrWidth (), line_wrap_mode = self . get_line_wrap_mode (), word_wrap_mode = self . get_word_wrap_mode (), overwrite_mode = self . overwriteMode (), placeholder_text = self . placeholderText (), read_only = self . isReadOnly (), tab_changes_focus = self . tabChangesFocus (), tab_stop_distance = self . tabStopDistance (), undo_redo_enabled = self . isUndoRedoEnabled (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_text ( state [ \"text\" ]) self . setAcceptRichText ( state [ \"accept_rich_text\" ]) self . set_auto_formatting ( state [ \"auto_formatting\" ]) self . setCursorWidth ( state [ \"cursor_width\" ]) self . setDocumentTitle ( state [ \"document_title\" ]) self . setLineWrapColumnOrWidth ( state [ \"line_wrap_column_or_width\" ]) self . set_line_wrap_mode ( state [ \"line_wrap_mode\" ]) self . set_word_wrap_mode ( state [ \"word_wrap_mode\" ]) self . setOverwriteMode ( state [ \"overwrite_mode\" ]) self . setPlaceholderText ( state [ \"placeholder_text\" ]) self . setReadOnly ( state [ \"read_only\" ]) self . setTabChangesFocus ( state [ \"tab_changes_focus\" ]) self . setTabStopDistance ( state [ \"tab_stop_distance\" ]) self . setUndoRedoEnabled ( state [ \"undo_redo_enabled\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __add__ ( self , other : str ) -> TextEdit : self . append_text ( other ) return self def on_value_change ( self ) -> None : self . value_changed . emit ( self . text ()) @contextlib . contextmanager def create_cursor ( self ) -> Iterator [ gui . TextCursor ]: cursor = gui . TextCursor ( self . document ()) yield cursor self . setTextCursor ( cursor ) def get_text_cursor ( self ) -> gui . TextCursor : return gui . TextCursor ( self . textCursor ()) def set_text ( self , text : str ) -> None : self . setPlainText ( text ) def append_text ( self , text : str ) -> None : self . append ( text ) def text ( self ) -> str : return self . toPlainText () def select_text ( self , start : int , end : int ) -> None : with self . create_cursor () as c : c . select_text ( start , end ) def set_read_only ( self , value : bool = True ) -> None : self . setReadOnly ( value ) def set_text_color ( self , color : types . ColorType ) -> None : color = colors . get_color ( color ) self . setTextColor ( color ) def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ]) def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()] def set_auto_formatting ( self , mode : AutoFormattingStr ): \"\"\"Set auto formatting mode. Args: mode: auto formatting mode to use Raises: InvalidParamError: auto formatting mode does not exist \"\"\" if mode not in AUTO_FORMATTING : raise InvalidParamError ( mode , AUTO_FORMATTING ) self . setAutoFormatting ( AUTO_FORMATTING [ mode ]) def get_auto_formatting ( self ) -> AutoFormattingStr : \"\"\"Get the current auto formatting mode. Returns: Auto formatting mode \"\"\" return AUTO_FORMATTING . inverse [ self . autoFormatting ()] def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ]) def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()] get_auto_formatting ( self ) -> AutoFormattingStr Get the current auto formatting mode. Returns: Type Description AutoFormattingStr Auto formatting mode Source code in prettyqt/widgets/textedit.py def get_auto_formatting ( self ) -> AutoFormattingStr : \"\"\"Get the current auto formatting mode. Returns: Auto formatting mode \"\"\" return AUTO_FORMATTING . inverse [ self . autoFormatting ()] get_line_wrap_mode ( self ) -> LineWrapModeStr Get the current wrap mode. Returns: Type Description LineWrapModeStr Wrap mode Source code in prettyqt/widgets/textedit.py def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()] get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr Get the current word wrap mode. Returns: Type Description gui.textoption.WordWrapModeStr Word wrap mode Source code in prettyqt/widgets/textedit.py def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()] set_auto_formatting ( self , mode : AutoFormattingStr ) Set auto formatting mode. Parameters: Name Type Description Default mode AutoFormattingStr auto formatting mode to use required Exceptions: Type Description InvalidParamError auto formatting mode does not exist Source code in prettyqt/widgets/textedit.py def set_auto_formatting ( self , mode : AutoFormattingStr ): \"\"\"Set auto formatting mode. Args: mode: auto formatting mode to use Raises: InvalidParamError: auto formatting mode does not exist \"\"\" if mode not in AUTO_FORMATTING : raise InvalidParamError ( mode , AUTO_FORMATTING ) self . setAutoFormatting ( AUTO_FORMATTING [ mode ]) set_line_wrap_mode ( self , mode : LineWrapModeStr ) Set line wrap mode. Parameters: Name Type Description Default mode LineWrapModeStr line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/textedit.py def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ]) set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ) Set word wrap mode. Parameters: Name Type Description Default mode gui.textoption.WordWrapModeStr word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/textedit.py def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ]) toolbar ToolBar ( QToolBar ) Source code in prettyqt/widgets/toolbar.py class ToolBar ( QtWidgets . QToolBar ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . set_icon_size ( 24 ) self . menu_buttons = list () def __setstate__ ( self , state : dict [ str , Any ]) -> None : super () . __setstate__ ( state ) self . addActions ( state [ \"actions\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def serialize_fields ( self ): return dict ( actions = self . actions (), allowed_areas = self . get_allowed_areas ()) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . windowTitle () !r} )\" def add ( self , item : QtWidgets . QAction | QtWidgets . QWidget ): if isinstance ( item , QtWidgets . QAction ): self . addAction ( item ) else : self . addWidget ( item ) def add_menu_button ( self , label : str , icon : types . IconType , menu : QtWidgets . QMenu ) -> widgets . ToolButton : btn = widgets . ToolButton . for_menu ( menu ) btn . setText ( label ) btn . setToolButtonStyle ( self . toolButtonStyle ()) btn . set_icon ( icon ) self . menu_buttons . append ( btn ) self . addWidget ( btn ) return btn def add_separator ( self , text : str | None = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label ) def set_style ( self , style : constants . ToolButtonStyleStr ): self . setToolButtonStyle ( constants . TOOLBUTTON_STYLE [ style ]) for btn in self . menu_buttons : btn . set_style ( style ) def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return current style. Returns: style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()] def add_action ( self , label : str , icon : types . IconType = None , callback : Callable | None = None , checkable : bool = False , ) -> QtWidgets . QAction : icon = iconprovider . get_icon ( icon ) action = self . addAction ( icon , label ) if callback is not None : action . triggered . connect ( callback ) if checkable : action . setCheckable ( True ) return action def add_spacer ( self ) -> QtWidgets . QAction : spacer = widgets . Widget () spacer . set_size_policy ( \"expanding\" , \"expanding\" ) return self . addWidget ( spacer ) def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) def get_icon_size ( self ) -> core . Size : return core . Size ( self . iconSize ()) def set_font_size ( self , size : int ): with self . edit_font () as font : font . set_size ( size ) def is_area_allowed ( self , area : constants . ToolbarAreaStr ) -> bool : \"\"\"Check if toolbar is allowed at specified area. Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in constants . TOOLBAR_AREA : raise InvalidParamError ( area , constants . TOOLBAR_AREA ) return self . isAreaAllowed ( constants . TOOLBAR_AREA [ area ]) def set_allowed_areas ( self , * areas : constants . ToolbarAreaStr ): for area in areas : if area not in constants . TOOLBAR_AREA : raise InvalidParamError ( area , constants . TOOLBAR_AREA ) flag = helpers . merge_flags ( areas , constants . TOOLBAR_AREA ) self . setAllowedAreas ( flag ) def get_allowed_areas ( self ) -> list [ constants . ToolbarAreaStr ]: return [ k for k , v in constants . TOOLBAR_AREA . items () if v & self . allowedAreas () # type: ignore ] add_separator ( self , text : str | None = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction Adds a separator showing an optional label. Parameters: Name Type Description Default text str | None Text to show on separator None before QtWidgets.QAction insert separator before specific action None Returns: Type Description QtWidgets.QAction Separator action Source code in prettyqt/widgets/toolbar.py def add_separator ( self , text : str | None = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label ) get_style ( self ) -> constants . ToolButtonStyleStr Return current style. Returns: Type Description constants.ToolButtonStyleStr style Source code in prettyqt/widgets/toolbar.py def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return current style. Returns: style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()] is_area_allowed ( self , area : constants . ToolbarAreaStr ) -> bool Check if toolbar is allowed at specified area. Parameters: Name Type Description Default area constants.ToolbarAreaStr area of the toolbar required Exceptions: Type Description InvalidParamError area does not exist Source code in prettyqt/widgets/toolbar.py def is_area_allowed ( self , area : constants . ToolbarAreaStr ) -> bool : \"\"\"Check if toolbar is allowed at specified area. Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in constants . TOOLBAR_AREA : raise InvalidParamError ( area , constants . TOOLBAR_AREA ) return self . isAreaAllowed ( constants . TOOLBAR_AREA [ area ]) set_icon_size ( self , size : int | types . SizeType ) Set size of the icons. Source code in prettyqt/widgets/toolbar.py def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) toolbutton ToolButton ( QToolButton ) Source code in prettyqt/widgets/toolbutton.py class ToolButton ( QtWidgets . QToolButton ): def __getitem__ ( self , item : str ) -> QtWidgets . QAction : menu = self . menu () return menu [ item ] # def set_menu(self, menu: QtWidgets.QMenu): # menu.setParent(self) # self.setMenu(menu) @classmethod def for_menu ( cls , menu : QtWidgets . QMenu , icon : types . IconType = None ): btn = cls () btn . setMenu ( menu ) # btn.set_title(menu.title()) btn . set_popup_mode ( \"instant\" ) btn . set_icon ( icon ) return btn def set_default_action ( self , action ): self . setDefaultAction ( action ) def set_popup_mode ( self , mode : PopupModeStr ): \"\"\"Set the popup mode of the toolbutton. Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODE : raise InvalidParamError ( mode , POPUP_MODE ) self . setPopupMode ( POPUP_MODE [ mode ]) def get_popup_mode ( self ) -> PopupModeStr : \"\"\"Return popup mode. Returns: popup mode \"\"\" return POPUP_MODE . inverse [ self . popupMode ()] def set_arrow_type ( self , mode : constants . ArrowTypeStr ): \"\"\"Set the arrow type of the toolbutton. Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in constants . ARROW_TYPE : raise InvalidParamError ( mode , constants . ARROW_TYPE ) self . setArrowType ( constants . ARROW_TYPE [ mode ]) def get_arrow_type ( self ) -> constants . ArrowTypeStr : \"\"\"Return arrow type. Returns: arrow type \"\"\" return constants . ARROW_TYPE . inverse [ self . arrowType ()] def set_style ( self , style : constants . ToolButtonStyleStr ): \"\"\"Set the toolbutton style. Args: style: style to use Raises: InvalidParamError: invalid style \"\"\" if style not in constants . TOOLBUTTON_STYLE : raise InvalidParamError ( style , constants . TOOLBUTTON_STYLE ) self . setToolButtonStyle ( constants . TOOLBUTTON_STYLE [ style ]) def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return toolbutton style. Returns: toolbutton style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()] get_arrow_type ( self ) -> constants . ArrowTypeStr Return arrow type. Returns: Type Description constants.ArrowTypeStr arrow type Source code in prettyqt/widgets/toolbutton.py def get_arrow_type ( self ) -> constants . ArrowTypeStr : \"\"\"Return arrow type. Returns: arrow type \"\"\" return constants . ARROW_TYPE . inverse [ self . arrowType ()] get_popup_mode ( self ) -> PopupModeStr Return popup mode. Returns: Type Description PopupModeStr popup mode Source code in prettyqt/widgets/toolbutton.py def get_popup_mode ( self ) -> PopupModeStr : \"\"\"Return popup mode. Returns: popup mode \"\"\" return POPUP_MODE . inverse [ self . popupMode ()] get_style ( self ) -> constants . ToolButtonStyleStr Return toolbutton style. Returns: Type Description constants.ToolButtonStyleStr toolbutton style Source code in prettyqt/widgets/toolbutton.py def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return toolbutton style. Returns: toolbutton style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()] set_arrow_type ( self , mode : constants . ArrowTypeStr ) Set the arrow type of the toolbutton. Parameters: Name Type Description Default mode constants.ArrowTypeStr arrow type to use required Exceptions: Type Description InvalidParamError invalid arrow type Source code in prettyqt/widgets/toolbutton.py def set_arrow_type ( self , mode : constants . ArrowTypeStr ): \"\"\"Set the arrow type of the toolbutton. Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in constants . ARROW_TYPE : raise InvalidParamError ( mode , constants . ARROW_TYPE ) self . setArrowType ( constants . ARROW_TYPE [ mode ]) set_popup_mode ( self , mode : PopupModeStr ) Set the popup mode of the toolbutton. Parameters: Name Type Description Default mode PopupModeStr popup mode to use required Exceptions: Type Description InvalidParamError invalid popup mode Source code in prettyqt/widgets/toolbutton.py def set_popup_mode ( self , mode : PopupModeStr ): \"\"\"Set the popup mode of the toolbutton. Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODE : raise InvalidParamError ( mode , POPUP_MODE ) self . setPopupMode ( POPUP_MODE [ mode ]) set_style ( self , style : constants . ToolButtonStyleStr ) Set the toolbutton style. Parameters: Name Type Description Default style constants.ToolButtonStyleStr style to use required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/widgets/toolbutton.py def set_style ( self , style : constants . ToolButtonStyleStr ): \"\"\"Set the toolbutton style. Args: style: style to use Raises: InvalidParamError: invalid style \"\"\" if style not in constants . TOOLBUTTON_STYLE : raise InvalidParamError ( style , constants . TOOLBUTTON_STYLE ) self . setToolButtonStyle ( constants . TOOLBUTTON_STYLE [ style ]) treewidgetitem TreeWidgetItem ( QTreeWidgetItem ) Source code in prettyqt/widgets/treewidgetitem.py class TreeWidgetItem ( QtWidgets . QTreeWidgetItem ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def serialize_fields ( self ): data = [ self . data ( i , constants . USER_ROLE ) # type: ignore for i in range ( self . columnCount ()) ] return dict ( text = [ self . text ( i ) for i in range ( self . columnCount ())], tool_tip = [ self . toolTip ( i ) for i in range ( self . columnCount ())], status_tip = [ self . statusTip ( i ) for i in range ( self . columnCount ())], checkstate = [ self . get_checkstate ( i ) for i in range ( self . columnCount ())], icon = [ self . get_icon ( i ) for i in range ( self . columnCount ())], data = data , ) def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __iter__ ( self ) -> Iterator [ QtWidgets . QTreeWidgetItem ]: return iter ( self . child ( i ) for i in range ( self . childCount ())) def __len__ ( self ): return self . childCount () def __getitem__ ( self , index : int ) -> QtWidgets . QTreeWidgetItem : item = self . child ( index ) if item is None : raise KeyError ( index ) return item def __delitem__ ( self , index : int ): self . takeChild ( index ) def __add__ ( self , other : QtWidgets . QTreeWidgetItem ) -> TreeWidgetItem : self . addChild ( other ) return self def set_size_hint ( self , hint : types . SizeType , column : int = 0 ): if isinstance ( hint , tuple ): hint = QtCore . QSize ( * hint ) self . setSizeHint ( column , hint ) def sort_children ( self , column : int , descending : bool = False ): order = constants . DESCENDING if descending else constants . ASCENDING self . sortChildren ( column , order ) def set_icon ( self , icon : types . IconType , column : int = 0 ): \"\"\"Set the icon for the action. Args: icon: icon to use column: column \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( column , icon ) def get_background ( self , column : int = 0 ) -> gui . Brush : return gui . Brush ( self . background ( column )) def get_foreground ( self , column : int = 0 ) -> gui . Brush : return gui . Brush ( self . foreground ( column )) def get_font ( self , column : int = 0 ) -> gui . Font : return gui . Font ( self . font ( column )) def get_icon ( self , column : int = 0 ) -> gui . Icon | None : icon = self . icon ( column ) if icon . isNull (): return None return gui . Icon ( icon ) def set_checkstate ( self , state : constants . StateStr , column : int = 0 ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use column: column Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( column , constants . STATE [ state ]) def get_checkstate ( self , column : int = 0 ) -> constants . StateStr : \"\"\"Return checkstate. Args: column: column Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ( column )] def set_child_indicator_policy ( self , policy : ChildIndicatorPolicyStr ): \"\"\"Set the child indicator policy. Args: policy: child indicator policy Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CHILD_INDICATOR_POLICY : raise InvalidParamError ( policy , CHILD_INDICATOR_POLICY ) self . setChildIndicatorPolicy ( CHILD_INDICATOR_POLICY [ policy ]) def get_child_indicator_policy ( self ) -> ChildIndicatorPolicyStr : \"\"\"Return current child indicator policy. Returns: child indicator policy \"\"\" return CHILD_INDICATOR_POLICY . inverse [ self . childIndicatorPolicy ()] get_checkstate ( self , column : int = 0 ) -> constants . StateStr Return checkstate. Parameters: Name Type Description Default column int column 0 Returns: Type Description constants.StateStr checkstate Source code in prettyqt/widgets/treewidgetitem.py def get_checkstate ( self , column : int = 0 ) -> constants . StateStr : \"\"\"Return checkstate. Args: column: column Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ( column )] get_child_indicator_policy ( self ) -> ChildIndicatorPolicyStr Return current child indicator policy. Returns: Type Description ChildIndicatorPolicyStr child indicator policy Source code in prettyqt/widgets/treewidgetitem.py def get_child_indicator_policy ( self ) -> ChildIndicatorPolicyStr : \"\"\"Return current child indicator policy. Returns: child indicator policy \"\"\" return CHILD_INDICATOR_POLICY . inverse [ self . childIndicatorPolicy ()] set_checkstate ( self , state : constants . StateStr , column : int = 0 ) Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required column int column 0 Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py def set_checkstate ( self , state : constants . StateStr , column : int = 0 ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use column: column Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( column , constants . STATE [ state ]) set_child_indicator_policy ( self , policy : ChildIndicatorPolicyStr ) Set the child indicator policy. Parameters: Name Type Description Default policy ChildIndicatorPolicyStr child indicator policy required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/treewidgetitem.py def set_child_indicator_policy ( self , policy : ChildIndicatorPolicyStr ): \"\"\"Set the child indicator policy. Args: policy: child indicator policy Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CHILD_INDICATOR_POLICY : raise InvalidParamError ( policy , CHILD_INDICATOR_POLICY ) self . setChildIndicatorPolicy ( CHILD_INDICATOR_POLICY [ policy ]) set_icon ( self , icon : types . IconType , column : int = 0 ) Set the icon for the action. Parameters: Name Type Description Default icon types.IconType icon to use required column int column 0 Source code in prettyqt/widgets/treewidgetitem.py def set_icon ( self , icon : types . IconType , column : int = 0 ): \"\"\"Set the icon for the action. Args: icon: icon to use column: column \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( column , icon ) undoview UndoView ( QUndoView ) Source code in prettyqt/widgets/undoview.py class UndoView ( QtWidgets . QUndoView ): def __getitem__ ( self , index : int ) -> QtWidgets . QUndoCommand : return self . stack () . command ( index ) def set_clean_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setCleanIcon ( icon ) def set_value ( self , value : QtWidgets . QUndoGroup | QtWidgets . QUndoStack ): if isinstance ( value , QtWidgets . QUndoGroup ): self . setGroup ( value ) else : self . setStack ( value ) set_clean_icon ( self , icon : types . IconType ) Set the icon for the clean button. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/undoview.py def set_clean_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setCleanIcon ( icon ) widget Widget ( PrettyPrinter , QWidget ) Source code in prettyqt/widgets/widget.py class Widget ( prettyprinter . PrettyPrinter , QtWidgets . QWidget ): box : QtWidgets . QLayout def __repr__ ( self ) -> str : cls_name = type ( self ) . __name__ params = helpers . format_kwargs ( self . serialize_fields ()) return f \" { cls_name } ( { params } )\" def __setstate__ ( self , state : dict [ str , Any ]) -> None : if self . layout () is None : self . set_layout ( state [ \"layout\" ]) self . setSizePolicy ( state [ \"size_policy\" ]) self . setAccessibleName ( state [ \"accessible_name\" ]) self . setToolTip ( state . get ( \"tool_tip\" , \"\" )) self . setToolTipDuration ( state . get ( \"tooltip_duration\" , \"\" )) self . setWindowTitle ( state . get ( \"window_title\" , \"\" )) self . setWindowFilePath ( state . get ( \"window_file_path\" , \"\" )) self . setEnabled ( state . get ( \"enabled\" , True )) self . setVisible ( state . get ( \"visible\" , True )) self . setTabletTracking ( state . get ( \"tablet_tracking\" , True )) self . setWindowModified ( state . get ( \"window_modified\" , False )) self . setWindowOpacity ( state . get ( \"window_opacity\" , 1.0 )) self . set_icon ( state . get ( \"icon\" )) self . set_modality ( state . get ( \"modality\" , \"\" )) self . setWhatsThis ( state . get ( \"whats_this\" , \"\" )) self . set_context_menu_policy ( state . get ( \"contextmenu_policy\" , \"\" )) self . set_focus_policy ( state . get ( \"focus_policy\" , \"\" )) self . setStatusTip ( state . get ( \"status_tip\" , \"\" )) self . setStyleSheet ( state . get ( \"stylesheet\" , \"\" )) self . setFont ( state . get ( \"font\" , \"\" )) if state [ \"is_maximized\" ]: self . showMaximized () def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def serialize_fields ( self ) -> dict [ str , Any ]: return dict ( layout = self . layout () if isinstance ( self . layout (), widgets . Layout ) else None , size_policy = self . get_size_policy (), is_maximized = self . isMaximized (), actions = self . actions (), accessible_name = self . accessibleName (), tool_tip = self . toolTip (), tooltip_duration = self . toolTipDuration (), window_title = self . windowTitle (), window_file_path = self . windowFilePath (), enabled = self . isEnabled (), tablet_tracking = self . hasTabletTracking (), window_modified = self . isWindowModified (), window_opacity = self . windowOpacity (), visible = self . isVisible (), stylesheet = self . styleSheet (), icon = self . get_icon (), modality = self . get_modality (), whats_this = self . whatsThis (), contextmenu_policy = self . get_context_menu_policy (), focus_policy = self . get_focus_policy (), status_tip = self . statusTip (), font = self . get_font (), ) def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size ) def raise_to_top ( self ): if sys . platform . startswith ( \"win\" ): import win32con from win32gui import SetWindowPos # set to always-on-top and disable it again. that way windows stays in front flag = win32con . SWP_NOMOVE | win32con . SWP_NOSIZE | win32con . SWP_SHOWWINDOW win_id = self . winId () SetWindowPos ( win_id , win32con . HWND_TOPMOST , 0 , 0 , 0 , 0 , flag ) SetWindowPos ( win_id , win32con . HWND_NOTOPMOST , 0 , 0 , 0 , 0 , flag ) # state = (self.windowState() & ~Qt.WindowMinimized) | Qt.WindowActive # self.setWindowState(state) self . raise_ () self . show () self . activateWindow () def set_icon ( self , icon : types . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) def get_icon ( self ) -> gui . Icon | None : icon = self . windowIcon () if icon . isNull (): return None return gui . Icon ( self . windowIcon ()) def set_min_size ( self , * size ) -> None : self . setMinimumSize ( * size ) def set_max_size ( self , * size ) -> None : self . setMaximumSize ( * size ) def set_min_width ( self , width : int | None ) -> None : if width is None : width = 0 self . setMinimumWidth ( width ) def set_max_width ( self , width : int | None ) -> None : if width is None : width = 16777215 # QtWidgets.QWIDGETSIZE_MAX self . setMaximumWidth ( width ) def set_min_height ( self , height : int | None ) -> None : if height is None : height = 0 self . setMinimumHeight ( height ) def set_max_height ( self , height : int | None ) -> None : if height is None : height = 16777215 # QtWidgets.QWIDGETSIZE_MAX self . setMaximumHeight ( height ) @property def title ( self ) -> str : return self . windowTitle () @title . setter def title ( self , name : str ): self . setWindowTitle ( name ) @property def enabled ( self ) -> bool : return self . isEnabled () @enabled . setter def enabled ( self , state : bool ): self . setEnabled ( state ) def set_enabled ( self , enabled : bool = True ) -> None : self . setEnabled ( enabled ) def set_disabled ( self ) -> None : self . setEnabled ( False ) def set_title ( self , title : str ) -> None : self . setWindowTitle ( title ) def get_title ( self ) -> str : return self . windowTitle () def set_tooltip ( self , tooltip : str | types . PathType , size : types . SizeType | None = None , ): if isinstance ( tooltip , os . PathLike ): path = os . fspath ( tooltip ) if size is None : tooltip = f \"<img src= { path !r} >\" else : if isinstance ( size , QtCore . QSize ): size = ( size . width (), size . height ()) tooltip = f '<img src= { path !r} width=\" { size [ 0 ] } \" height=\" { size [ 1 ] } \">' self . setToolTip ( tooltip ) def set_font ( self , font_name : str | None = None , font_size : int | None = None , weight : int | None = None , italic : bool = False , ) -> gui . Font : if font_size is None : font_size = - 1 if weight is None : weight = - 1 if font_name is None : font_name = self . font () . family () font = gui . Font ( font_name , font_size , weight , italic ) self . setFont ( font ) return font def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_foreground_role ( self ) -> gui . palette . RoleStr : return gui . palette . ROLE . inverse [ self . foregroundRole ()] def set_foreground_role ( self , role : gui . palette . RoleStr ): if role not in gui . palette . ROLE : raise InvalidParamError ( role , gui . palette . ROLE ) self . setForegroundRole ( gui . palette . ROLE [ role ]) def get_background_role ( self ) -> gui . palette . RoleStr : return gui . palette . ROLE . inverse [ self . backgroundRole ()] def set_background_role ( self , role : gui . palette . RoleStr ): if role not in gui . palette . ROLE : raise InvalidParamError ( role , gui . palette . ROLE ) self . setBackgroundRole ( gui . palette . ROLE [ role ]) def set_window_flags ( self , * flags : constants . WindowFlagStr , append : bool = False ): for flag in flags : if flag not in constants . WINDOW_FLAGS : raise InvalidParamError ( flag , constants . WINDOW_FLAGS ) result = helpers . merge_flags ( flags , constants . WINDOW_FLAGS ) if append : result = result | self . windowFlags () self . setWindowFlags ( result ) def set_flags ( self , minimize : bool | None = None , maximize : bool | None = None , close : bool | None = None , stay_on_top : bool | None = None , frameless : bool | None = None , window : bool | None = None , dialog : bool | None = None , tooltip : bool | None = None , tool : bool | None = None , customize : bool | None = None , window_title : bool | None = None , ) -> None : if minimize is not None : self . setWindowFlag ( QtCore . Qt . WindowType . WindowMinimizeButtonHint , minimize ) if maximize is not None : self . setWindowFlag ( QtCore . Qt . WindowType . WindowMaximizeButtonHint , maximize ) if close is not None : self . setWindowFlag ( QtCore . Qt . WindowType . WindowCloseButtonHint , close ) if stay_on_top is not None : self . setWindowFlag ( QtCore . Qt . WindowType . WindowStaysOnTopHint , stay_on_top ) if frameless is not None : self . setWindowFlag ( QtCore . Qt . WindowType . FramelessWindowHint , frameless ) if window is not None : self . setWindowFlag ( QtCore . Qt . WindowType . Window , window ) if dialog is not None : self . setWindowFlag ( QtCore . Qt . WindowType . Dialog , dialog ) if tooltip is not None : self . setWindowFlag ( QtCore . Qt . WindowType . ToolTip , tooltip ) if tool is not None : self . setWindowFlag ( QtCore . Qt . WindowType . Tool , tool ) if customize is not None : self . setWindowFlag ( QtCore . Qt . WindowType . CustomizeWindowHint , customize ) if window_title is not None : self . setWindowFlag ( QtCore . Qt . WindowType . WindowTitleHint , window_title ) def set_attribute ( self , attribute : constants . WidgetAttributeStr , state : bool = True ) -> None : if attribute not in constants . WIDGET_ATTRIBUTE : raise InvalidParamError ( attribute , constants . WIDGET_ATTRIBUTE ) self . setAttribute ( constants . WIDGET_ATTRIBUTE [ attribute ], state ) def set_attributes ( self , ** kwargs : bool ) -> None : for attr , state in kwargs . items (): if attr not in constants . WIDGET_ATTRIBUTE : raise InvalidParamError ( attr , constants . WIDGET_ATTRIBUTE ) self . setAttribute ( constants . WIDGET_ATTRIBUTE [ attr ], state ) # type: ignore def set_modality ( self , modality : constants . ModalityStr ) -> None : \"\"\"Set modality for the dialog. Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in constants . MODALITY : raise InvalidParamError ( modality , constants . MODALITY ) self . setWindowModality ( constants . MODALITY [ modality ]) def get_modality ( self ) -> constants . ModalityStr : \"\"\"Get the current modality modes as a string. Returns: modality mode \"\"\" return constants . MODALITY . inverse [ self . windowModality ()] def set_size_policy ( self , horizontal : widgets . sizepolicy . SizePolicyStr | None = None , vertical : widgets . sizepolicy . SizePolicyStr | None = None , ) -> None : \"\"\"Set the sizes policy. Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp ) def get_size_policy ( self ) -> widgets . SizePolicy : qpol = self . sizePolicy () if isinstance ( qpol , widgets . SizePolicy ): return qpol return widgets . SizePolicy . clone ( qpol ) def get_palette ( self ) -> gui . Palette : return gui . Palette ( self . palette ()) def set_background_color ( self , color : types . ColorType ) -> None : col_str = \"\" if color is None else colors . get_color ( color ) . name () with self . edit_stylesheet () as ss : ss . backgroundColor . setValue ( col_str ) @contextlib . contextmanager def updates_off ( self ) -> Iterator [ None ]: updates = self . updatesEnabled () self . setUpdatesEnabled ( False ) yield None self . setUpdatesEnabled ( updates ) @contextlib . contextmanager def edit_stylesheet ( self ) -> Iterator [ qstylizer . style . StyleSheet ]: ss = self . get_stylesheet () yield ss self . set_stylesheet ( ss ) def set_stylesheet ( self , ss : None | str | qstylizer . style . StyleSheet | types . PathType ): if isinstance ( ss , os . PathLike ): ss = pathlib . Path ( ss ) . read_text () elif ss is None : ss = \"\" self . setStyleSheet ( str ( ss )) def get_stylesheet ( self ) -> qstylizer . style . StyleSheet : try : return qstylizer . parser . parse ( self . styleSheet ()) except ValueError : return qstylizer . style . StyleSheet () @contextlib . contextmanager def edit_palette ( self ) -> Iterator [ gui . Palette ]: palette = gui . Palette ( self . palette ()) yield palette self . setPalette ( palette ) @contextlib . contextmanager def edit_font ( self ) -> Iterator [ gui . Font ]: font = gui . Font ( self . font ()) yield font self . setFont ( font ) @deprecated ( reason = \"This context manager is deprecated, use edit_font instead.\" ) @contextlib . contextmanager def current_font ( self ) -> Iterator [ gui . Font ]: with self . edit_font () as font : yield font @deprecated ( reason = \"This method is deprecated, use set_context_menu_policy instead.\" ) def set_contextmenu_policy ( self , policy : constants . ContextPolicyStr ) -> None : return self . set_context_menu_policy ( policy ) def set_context_menu_policy ( self , policy : constants . ContextPolicyStr ) -> None : \"\"\"Set contextmenu policy for given item view. Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . CONTEXT_POLICY : raise InvalidParamError ( policy , constants . CONTEXT_POLICY ) self . setContextMenuPolicy ( constants . CONTEXT_POLICY [ policy ]) @deprecated ( reason = \"This method is deprecated, use get_context_menu_policy instead.\" ) def get_contextmenu_policy ( self ) -> constants . ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return self . get_context_menu_policy () def get_context_menu_policy ( self ) -> constants . ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return constants . CONTEXT_POLICY . inverse [ self . contextMenuPolicy ()] def set_window_state ( self , policy : constants . WindowStateStr ) -> None : \"\"\"Set window state for given item view. Args: policy: window state to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . WINDOW_STATES : raise InvalidParamError ( policy , constants . WINDOW_STATES ) self . setWindowState ( constants . WINDOW_STATES [ policy ]) def get_window_state ( self ) -> constants . WindowStateStr : \"\"\"Return current window state. Returns: window state \"\"\" return constants . WINDOW_STATES . inverse [ self . windowState ()] def set_custom_menu ( self , method : Callable ) -> None : self . set_context_menu_policy ( \"custom\" ) self . customContextMenuRequested . connect ( method ) def set_layout ( self , layout : LayoutStr | QtWidgets . QLayout | None , margin : int | None = None , spacing : int | None = None , ): if layout is None : return if layout == \"horizontal\" : self . box = widgets . BoxLayout ( \"horizontal\" ) elif layout == \"vertical\" : self . box = widgets . BoxLayout ( \"vertical\" ) elif layout == \"grid\" : self . box = widgets . GridLayout () elif layout == \"form\" : self . box = widgets . FormLayout () elif layout == \"stacked\" : self . box = widgets . StackedLayout () elif layout == \"flow\" : from prettyqt import custom_widgets self . box = custom_widgets . FlowLayout () elif isinstance ( layout , QtWidgets . QLayout ): self . box = layout else : raise ValueError ( \"Invalid Layout\" ) self . setLayout ( self . box ) if margin is not None : self . box . set_margin ( margin ) if spacing is not None : self . box . setSpacing ( spacing ) def center ( self , screen : int = 0 ) -> None : qr = self . frameGeometry () cp = gui . GuiApplication . screens ()[ screen ] . geometry () . center () qr . moveCenter ( cp ) self . move ( qr . topLeft ()) def set_cursor ( self , cursor : constants . CursorShapeStr | QtGui . QCursor ) -> None : if isinstance ( cursor , QtGui . QCursor ): curs = cursor else : if cursor not in constants . CURSOR_SHAPE : raise InvalidParamError ( cursor , constants . CURSOR_SHAPE ) curs = gui . Cursor ( constants . CURSOR_SHAPE [ cursor ]) self . setCursor ( curs ) def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ]) def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return waay the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()] def set_font_size ( self , size : int ) -> None : font = self . font () font . setPointSize ( size ) self . setFont ( font ) @deprecated ( reason = \"This method is deprecated, use get_font_metrics instead.\" ) def font_metrics ( self ) -> gui . FontMetrics : return self . get_font_metrics () def get_font_metrics ( self ) -> gui . FontMetrics : return gui . FontMetrics ( self . fontMetrics ()) def get_font_info ( self ) -> gui . FontInfo : return gui . FontInfo ( self . fontInfo ()) def set_margin ( self , margin : int ) -> None : self . setContentsMargins ( margin , margin , margin , margin ) def raise_dock ( self ) -> bool : w = self . find_parent ( QtWidgets . QDockWidget ) if w is None : return False w . setVisible ( True ) w . raise_ () return True def set_mask ( self , area : types . RectType | QtGui . QRegion | None , typ : gui . region . RegionTypeStr = \"rectangle\" , ): if area is None : self . clearMask () return if isinstance ( area , tuple ): area = QtCore . QRect ( * area ) if isinstance ( area , QtCore . QRect ): area = gui . Region ( area , gui . region . REGION_TYPE [ typ ]) self . setMask ( area ) def set_window_file_path ( self , path : types . PathType ): self . setWindowFilePath ( os . fspath ( path )) def get_window_file_path ( self ) -> pathlib . Path | None : path = self . windowFilePath () if not path : return None return pathlib . Path ( path ) def get_screen ( self ) -> gui . Screen | None : window = self . window () . windowHandle () if window is None : return None return gui . Screen ( window . screen ()) get_context_menu_policy ( self ) -> constants . ContextPolicyStr Return current contextmenu policy. Returns: Type Description constants.ContextPolicyStr contextmenu policy Source code in prettyqt/widgets/widget.py def get_context_menu_policy ( self ) -> constants . ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return constants . CONTEXT_POLICY . inverse [ self . contextMenuPolicy ()] get_contextmenu_policy ( self ) -> constants . ContextPolicyStr Return current contextmenu policy. Returns: Type Description constants.ContextPolicyStr contextmenu policy Source code in prettyqt/widgets/widget.py @deprecated ( reason = \"This method is deprecated, use get_context_menu_policy instead.\" ) def get_contextmenu_policy ( self ) -> constants . ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return self . get_context_menu_policy () get_focus_policy ( self ) -> constants . FocusPolicyStr Return waay the widget accepts keyboard focus. Returns: Type Description str Focus policy Source code in prettyqt/widgets/widget.py def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return waay the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()] get_modality ( self ) -> constants . ModalityStr Get the current modality modes as a string. Returns: Type Description constants.ModalityStr modality mode Source code in prettyqt/widgets/widget.py def get_modality ( self ) -> constants . ModalityStr : \"\"\"Get the current modality modes as a string. Returns: modality mode \"\"\" return constants . MODALITY . inverse [ self . windowModality ()] get_window_state ( self ) -> constants . WindowStateStr Return current window state. Returns: Type Description constants.WindowStateStr window state Source code in prettyqt/widgets/widget.py def get_window_state ( self ) -> constants . WindowStateStr : \"\"\"Return current window state. Returns: window state \"\"\" return constants . WINDOW_STATES . inverse [ self . windowState ()] resize ( self , * size ) -> None resize(self, arg__1: PySide6.QtCore.QSize) -> None resize(self, w: int, h: int) -> None Source code in prettyqt/widgets/widget.py def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size ) set_context_menu_policy ( self , policy : constants . ContextPolicyStr ) -> None Set contextmenu policy for given item view. Parameters: Name Type Description Default policy constants.ContextPolicyStr contextmenu policy to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_context_menu_policy ( self , policy : constants . ContextPolicyStr ) -> None : \"\"\"Set contextmenu policy for given item view. Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . CONTEXT_POLICY : raise InvalidParamError ( policy , constants . CONTEXT_POLICY ) self . setContextMenuPolicy ( constants . CONTEXT_POLICY [ policy ]) set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None Set the way the widget accepts keyboard focus. Parameters: Name Type Description Default policy str Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/widget.py def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ]) set_icon ( self , icon : types . IconType ) -> None Set the window icon. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/widget.py def set_icon ( self , icon : types . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) set_modality ( self , modality : constants . ModalityStr ) -> None Set modality for the dialog. Parameters: Name Type Description Default modality constants.ModalityStr modality for the main window required Exceptions: Type Description InvalidParamError modality type does not exist Source code in prettyqt/widgets/widget.py def set_modality ( self , modality : constants . ModalityStr ) -> None : \"\"\"Set modality for the dialog. Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in constants . MODALITY : raise InvalidParamError ( modality , constants . MODALITY ) self . setWindowModality ( constants . MODALITY [ modality ]) set_size_policy ( self , horizontal : widgets . sizepolicy . SizePolicyStr | None = None , vertical : widgets . sizepolicy . SizePolicyStr | None = None ) -> None Set the sizes policy. Parameters: Name Type Description Default horizontal widgets.sizepolicy.SizePolicyStr | None horizontal size policy None vertical widgets.sizepolicy.SizePolicyStr | None vertical size policy None Source code in prettyqt/widgets/widget.py def set_size_policy ( self , horizontal : widgets . sizepolicy . SizePolicyStr | None = None , vertical : widgets . sizepolicy . SizePolicyStr | None = None , ) -> None : \"\"\"Set the sizes policy. Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp ) set_window_state ( self , policy : constants . WindowStateStr ) -> None Set window state for given item view. Parameters: Name Type Description Default policy constants.WindowStateStr window state to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_window_state ( self , policy : constants . WindowStateStr ) -> None : \"\"\"Set window state for given item view. Args: policy: window state to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . WINDOW_STATES : raise InvalidParamError ( policy , constants . WINDOW_STATES ) self . setWindowState ( constants . WINDOW_STATES [ policy ]) wizard Wizard ( QWizard ) Source code in prettyqt/widgets/wizard.py class Wizard ( QtWidgets . QWizard ): def __getitem__ ( self , key : int ) -> QtWidgets . QWizardPage : p = self . page ( key ) if p is None : raise KeyError ( key ) return p def __setitem__ ( self , key : int , value : QtWidgets . QWizardPage ): return self . setPage ( key , value ) def __delitem__ ( self , key : int ): if key not in self . pageIds (): raise KeyError ( key ) return self . removePage ( key ) def __iter__ ( self ) -> Iterator [ QtWidgets . QWizardPage ]: return iter ( self . page ( i ) for i in self . pageIds ()) def __add__ ( self , other : QtWidgets . QWizardPage ) -> Wizard : self . addPage ( other ) return self def serialize_fields ( self ): return dict ( current_id = self . currentId (), start_id = self . startId (), sub_title_format = self . get_subtitle_format (), title_format = self . get_title_format (), wizard_style = self . get_wizard_style (), ) def add_widget_as_page ( self , widget : QtWidgets . QWidget ) -> None : page = widgets . WizardPage ( self ) layout = widgets . BoxLayout ( \"vertical\" , self ) layout += widget page . set_layout ( layout ) def set_title_format ( self , fmt : TextFormatStr ): \"\"\"Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: title format to use Raises: InvalidParamError: title format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setTitleFormat ( TEXT_FORMATS [ fmt ]) def get_title_format ( self ) -> TextFormatStr : \"\"\"Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: title format \"\"\" return TEXT_FORMATS . inverse [ self . titleFormat ()] def set_subtitle_format ( self , fmt : TextFormatStr ): \"\"\"Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: subtitle format to use Raises: InvalidParamError: subtitle format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setSubTitleFormat ( TEXT_FORMATS [ fmt ]) def get_subtitle_format ( self ) -> TextFormatStr : \"\"\"Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: subtitle format \"\"\" return TEXT_FORMATS . inverse [ self . subTitleFormat ()] def get_button ( self , button_type : WizardButtonStr ) -> QtWidgets . QAbstractButton : if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . button ( WIZARD_BUTTON [ button_type ]) def set_button_text ( self , button_type : WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) self . setButtonText ( WIZARD_BUTTON [ button_type ], value ) def get_button_text ( self , button_type : WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . buttonText ( WIZARD_BUTTON [ button_type ]) def set_pixmap ( self , typ : WizardPixmapStr , pixmap : QtGui . QPixmap | None ): if typ not in WIZARD_PIXMAP : raise InvalidParamError ( typ , WIZARD_PIXMAP ) if pixmap is None : pixmap = QtGui . QPixmap () self . setPixmap ( WIZARD_PIXMAP [ typ ], pixmap ) def get_pixmap ( self , typ : WizardPixmapStr ) -> gui . Pixmap | None : if typ not in WIZARD_PIXMAP : raise InvalidParamError ( typ , WIZARD_PIXMAP ) pix = gui . Pixmap ( self . pixmap ( WIZARD_PIXMAP [ typ ])) if pix . isNull (): return None return pix def set_wizard_style ( self , style : WizardStyleStr ): \"\"\"Set the wizard style. Args: style: wizard style Raises: InvalidParamError: wizard style does not exist \"\"\" if style not in WIZARD_STYLE : raise InvalidParamError ( style , WIZARD_STYLE ) self . setWizardStyle ( WIZARD_STYLE [ style ]) def get_wizard_style ( self ) -> WizardStyleStr : \"\"\"Return current wizard style. Returns: Wizard style \"\"\" return WIZARD_STYLE . inverse [ self . wizardStyle ()] def set_option ( self , option : WizardOptionStr , value : bool ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) self . setOption ( WIZARD_OPTIONS [ option ], value ) def get_option ( self , option : WizardOptionStr ) -> bool : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) return self . testOption ( WIZARD_OPTIONS [ option ]) get_button_text ( self , button_type : WizardButtonStr ) -> str Return text for given button type. Parameters: Name Type Description Default button_type WizardButtonStr button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizard.py def get_button_text ( self , button_type : WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . buttonText ( WIZARD_BUTTON [ button_type ]) get_option ( self , option : WizardOptionStr ) -> bool Return the value assigned to option. Parameters: Name Type Description Default option WizardOptionStr option to get required Returns: Type Description bool option Source code in prettyqt/widgets/wizard.py def get_option ( self , option : WizardOptionStr ) -> bool : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) return self . testOption ( WIZARD_OPTIONS [ option ]) get_subtitle_format ( self ) -> TextFormatStr Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description TextFormatStr subtitle format Source code in prettyqt/widgets/wizard.py def get_subtitle_format ( self ) -> TextFormatStr : \"\"\"Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: subtitle format \"\"\" return TEXT_FORMATS . inverse [ self . subTitleFormat ()] get_title_format ( self ) -> TextFormatStr Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description TextFormatStr title format Source code in prettyqt/widgets/wizard.py def get_title_format ( self ) -> TextFormatStr : \"\"\"Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: title format \"\"\" return TEXT_FORMATS . inverse [ self . titleFormat ()] get_wizard_style ( self ) -> WizardStyleStr Return current wizard style. Returns: Type Description WizardStyleStr Wizard style Source code in prettyqt/widgets/wizard.py def get_wizard_style ( self ) -> WizardStyleStr : \"\"\"Return current wizard style. Returns: Wizard style \"\"\" return WIZARD_STYLE . inverse [ self . wizardStyle ()] set_button_text ( self , button_type : WizardButtonStr , value : str ) Set text for given button type. Parameters: Name Type Description Default button_type WizardButtonStr button to get text from required value str text to set required Source code in prettyqt/widgets/wizard.py def set_button_text ( self , button_type : WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) self . setButtonText ( WIZARD_BUTTON [ button_type ], value ) set_option ( self , option : WizardOptionStr , value : bool ) Set option to given value. Parameters: Name Type Description Default option WizardOptionStr option to use required value bool value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/widgets/wizard.py def set_option ( self , option : WizardOptionStr , value : bool ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) self . setOption ( WIZARD_OPTIONS [ option ], value ) set_subtitle_format ( self , fmt : TextFormatStr ) Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt TextFormatStr subtitle format to use required Exceptions: Type Description InvalidParamError subtitle format does not exist Source code in prettyqt/widgets/wizard.py def set_subtitle_format ( self , fmt : TextFormatStr ): \"\"\"Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: subtitle format to use Raises: InvalidParamError: subtitle format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setSubTitleFormat ( TEXT_FORMATS [ fmt ]) set_title_format ( self , fmt : TextFormatStr ) Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt TextFormatStr title format to use required Exceptions: Type Description InvalidParamError title format does not exist Source code in prettyqt/widgets/wizard.py def set_title_format ( self , fmt : TextFormatStr ): \"\"\"Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: title format to use Raises: InvalidParamError: title format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setTitleFormat ( TEXT_FORMATS [ fmt ]) set_wizard_style ( self , style : WizardStyleStr ) Set the wizard style. Parameters: Name Type Description Default style WizardStyleStr wizard style required Exceptions: Type Description InvalidParamError wizard style does not exist Source code in prettyqt/widgets/wizard.py def set_wizard_style ( self , style : WizardStyleStr ): \"\"\"Set the wizard style. Args: style: wizard style Raises: InvalidParamError: wizard style does not exist \"\"\" if style not in WIZARD_STYLE : raise InvalidParamError ( style , WIZARD_STYLE ) self . setWizardStyle ( WIZARD_STYLE [ style ]) wizardpage WizardPage ( QWizardPage ) Source code in prettyqt/widgets/wizardpage.py class WizardPage ( QtWidgets . QWizardPage ): def serialize_fields ( self ): return dict ( title = self . title (), sub_title = self . subTitle ()) def set_pixmap ( self , typ : widgets . wizard . WizardPixmapStr , pixmap : QtGui . QPixmap | None ): if typ not in widgets . wizard . WIZARD_PIXMAP : raise InvalidParamError ( typ , widgets . wizard . WIZARD_PIXMAP ) if pixmap is None : pixmap = QtGui . QPixmap () self . setPixmap ( widgets . wizard . WIZARD_PIXMAP [ typ ], pixmap ) def get_pixmap ( self , typ : widgets . wizard . WizardPixmapStr ) -> gui . Pixmap | None : if typ not in widgets . wizard . WIZARD_PIXMAP : raise InvalidParamError ( typ , widgets . wizard . WIZARD_PIXMAP ) pix = gui . Pixmap ( self . pixmap ( widgets . wizard . WIZARD_PIXMAP [ typ ])) if pix . isNull (): return None return pix def set_button_text ( self , button_type : widgets . wizard . WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) self . setButtonText ( widgets . wizard . WIZARD_BUTTON [ button_type ], value ) def get_button_text ( self , button_type : widgets . wizard . WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) return self . buttonText ( widgets . wizard . WIZARD_BUTTON [ button_type ]) get_button_text ( self , button_type : widgets . wizard . WizardButtonStr ) -> str Return text for given button type. Parameters: Name Type Description Default button_type widgets.wizard.WizardButtonStr button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizardpage.py def get_button_text ( self , button_type : widgets . wizard . WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) return self . buttonText ( widgets . wizard . WIZARD_BUTTON [ button_type ]) set_button_text ( self , button_type : widgets . wizard . WizardButtonStr , value : str ) Set text for given button type. Parameters: Name Type Description Default button_type widgets.wizard.WizardButtonStr button to get text from required value str text to set required Source code in prettyqt/widgets/wizardpage.py def set_button_text ( self , button_type : widgets . wizard . WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) self . setButtonText ( widgets . wizard . WIZARD_BUTTON [ button_type ], value )","title":"widgets"},{"location":"api/widgets.html#widgets-module","text":"widgets module. contains QtWidgets-based classes","title":"widgets module"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton","text":"","title":"abstractbutton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton","text":"Source code in prettyqt/widgets/abstractbutton.py class AbstractButton ( QtWidgets . QAbstractButton ): def serialize_fields ( self ): return dict ( text = self . text (), icon = self . get_icon (), checkable = self . isCheckable (), checked = self . isChecked (), auto_exclusive = self . autoExclusive (), auto_repeat = self . autoRepeat (), auto_repeat_delay = self . autoRepeatDelay (), auto_repeat_interval = self . autoRepeatInterval (), is_down = self . isDown (), icon_size = self . get_icon_size (), shortcut = self . get_shortcut (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setText ( state [ \"text\" ]) self . set_icon ( state [ \"icon\" ]) self . setChecked ( state . get ( \"checked\" , False )) self . setCheckable ( state [ \"checkable\" ]) self . setAutoExclusive ( state [ \"auto_exclusive\" ]) self . setAutoRepeat ( state [ \"auto_repeat\" ]) self . setAutoRepeatDelay ( state [ \"auto_repeat_delay\" ]) self . setAutoRepeatInterval ( state [ \"auto_repeat_interval\" ]) self . setDown ( state [ \"is_down\" ]) self . set_icon_size ( state [ \"icon_size\" ]) self . setShortcut ( state [ \"shortcut\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __bool__ ( self ): return self . isChecked () def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_style_icon ( self , icon : widgets . style . StandardPixmapStr , size : int = 15 ): \"\"\"Set theme icon for the button. Args: icon: icon to use size: icon size \"\"\" if icon not in widgets . style . STANDARD_PIXMAP : raise InvalidParamError ( icon , widgets . style . STANDARD_PIXMAP ) qicon = self . style () . standardIcon ( widgets . style . STANDARD_PIXMAP [ icon ], None , self ) self . set_icon ( qicon ) self . setIconSize ( core . Size ( size , size )) def set_shortcut ( self , shortcut : None | QtGui . QKeySequence | str ): if shortcut is None : shortcut = \"\" if isinstance ( shortcut , str ): shortcut = gui . KeySequence ( shortcut , gui . KeySequence . SequenceFormat . PortableText ) self . setShortcut ( shortcut ) def get_shortcut ( self ) -> gui . KeySequence : return gui . KeySequence ( self . shortcut () . toString (), gui . KeySequence . SequenceFormat . PortableText ) def set_text ( self , text : str ): self . setText ( text ) def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icon.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) def get_icon_size ( self ) -> core . Size : return core . Size ( self . iconSize ()) def get_value ( self ) -> bool : return self . isChecked () def set_value ( self , value : bool ): self . setChecked ( value ) @property def is_on ( self ) -> bool : return self . isChecked () @is_on . setter def is_on ( self , state : bool ): self . setChecked ( state )","title":"AbstractButton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton.set_icon","text":"Set the icon for the button. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/abstractbutton.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton.set_icon_size","text":"Set size of the icon. Source code in prettyqt/widgets/abstractbutton.py def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icon.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton.set_style_icon","text":"Set theme icon for the button. Parameters: Name Type Description Default icon widgets.style.StandardPixmapStr icon to use required size int icon size 15 Source code in prettyqt/widgets/abstractbutton.py def set_style_icon ( self , icon : widgets . style . StandardPixmapStr , size : int = 15 ): \"\"\"Set theme icon for the button. Args: icon: icon to use size: icon size \"\"\" if icon not in widgets . style . STANDARD_PIXMAP : raise InvalidParamError ( icon , widgets . style . STANDARD_PIXMAP ) qicon = self . style () . standardIcon ( widgets . style . STANDARD_PIXMAP [ icon ], None , self ) self . set_icon ( qicon ) self . setIconSize ( core . Size ( size , size ))","title":"set_style_icon()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview","text":"","title":"abstractitemview"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView","text":"Source code in prettyqt/widgets/abstractitemview.py class AbstractItemView ( QtWidgets . QAbstractItemView ): def __len__ ( self ) -> int : if self . model () is not None : return self . model () . rowCount () return 0 def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return super () . selectAll () def set_model ( self , model : QtCore . QAbstractItemModel | None ): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # type: ignore # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model def set_delegate ( self , delegate : QtWidgets . QItemDelegate , column : int | None = None , row : int | None = None , persistent : bool = False , ): if column is not None : self . setItemDelegateForColumn ( column , delegate ) if persistent : model = self . model () for i in range ( 0 , model . rowCount ()): self . openPersistentEditor ( model . index ( i , column )) elif row is not None : self . setItemDelegateForRow ( row , delegate ) if persistent : model = self . model () for i in range ( 0 , model . columnCount ()): self . openPersistentEditor ( model . index ( row , i )) else : self . setItemDelegate ( delegate ) def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll () def set_table_color ( self , color : str ): with self . edit_stylesheet () as ss : ss . QHeaderView . section . backgroundColor . setValue ( color ) def current_index ( self ) -> QtCore . QModelIndex | None : if self . selectionModel () is None : return None return self . selectionModel () . currentIndex () def current_data ( self ): if self . selectionModel () is None : return None idx = self . selectionModel () . currentIndex () return idx . data ( constants . USER_ROLE ) # type: ignore def current_row ( self ) -> int | None : if self . selectionModel () is None : return None return self . selectionModel () . currentIndex () . row () def current_column ( self ) -> int | None : if self . selectionModel () is None : return None return self . selectionModel () . currentIndex () . column () def selected_indexes ( self ) -> list [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) # type: ignore return sorted ( indexes , key = lambda x : x . row ()) # type: ignore def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ()) def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ()) def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes () # type: ignore ) def setup_dragdrop_move ( self ): self . setDragEnabled ( True ) self . setAcceptDrops ( True ) self . setDragDropMode ( self . DragDropMode . DragDrop ) self . setDefaultDropAction ( constants . MOVE_ACTION ) self . setDropIndicatorShown ( True ) def set_edit_triggers ( self , * triggers : EditTriggerStr | None ): items = [ \"none\" if t is None else t for t in triggers ] for item in items : if item not in EDIT_TRIGGERS : raise InvalidParamError ( item , EDIT_TRIGGERS ) flags = helpers . merge_flags ( items , EDIT_TRIGGERS ) self . setEditTriggers ( flags ) def get_edit_triggers ( self ) -> list [ EditTriggerStr ]: return [ k for k , v in EDIT_TRIGGERS . items () if v & self . editTriggers ()] def set_selection_behaviour ( self , behaviour : SelectionBehaviourStr ): \"\"\"Set selection behaviour for given item view. Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOUR : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOUR ) self . setSelectionBehavior ( SELECTION_BEHAVIOUR [ behaviour ]) def get_selection_behaviour ( self ) -> SelectionBehaviourStr : \"\"\"Return current selection behaviour. Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOUR . inverse [ self . selectionBehavior ()] def set_drag_drop_mode ( self , mode : DragDropModeStr ): \"\"\"Set drag-drop mode for given item view. Args: mode: drag-drop mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_DROP_MODE : raise InvalidParamError ( mode , DRAG_DROP_MODE ) self . setDragDropMode ( DRAG_DROP_MODE [ mode ]) def get_drag_drop_mode ( self ) -> DragDropModeStr : \"\"\"Return current drag-drop mode. Returns: drag-drop mode \"\"\" return DRAG_DROP_MODE . inverse [ self . dragDropMode ()] def set_selection_mode ( self , mode : SelectionModeStr | None ): \"\"\"Set selection mode for given item view. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ]) def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()] def set_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the scroll mode for both directions. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) self . setVerticalScrollMode ( SCROLL_MODE [ mode ]) def set_horizontal_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the horizontal scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) def set_vertical_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the vertical scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setVerticalScrollMode ( SCROLL_MODE [ mode ]) def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ()) def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx ) def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop () def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom () def select_last_row ( self ): idx = self . model () . createIndex ( self . model () . rowCount () - 1 , 0 ) self . setCurrentIndex ( idx ) def scroll_to ( self , index , mode : ScrollHintStr = \"ensure_visible\" ): if mode not in SCROLL_HINT : raise InvalidParamError ( mode , SCROLL_HINT ) self . scrollTo ( index , SCROLL_HINT [ mode ]) def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p ) def set_icon_size ( self , size : int | types . SizeType ): if isinstance ( size , tuple ): size = QtCore . QSize ( * size ) elif isinstance ( size , int ): size = QtCore . QSize ( size , size ) self . setIconSize ( size )","title":"AbstractItemView"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_drag_drop_mode","text":"Return current drag-drop mode. Returns: Type Description DragDropModeStr drag-drop mode Source code in prettyqt/widgets/abstractitemview.py def get_drag_drop_mode ( self ) -> DragDropModeStr : \"\"\"Return current drag-drop mode. Returns: drag-drop mode \"\"\" return DRAG_DROP_MODE . inverse [ self . dragDropMode ()]","title":"get_drag_drop_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_behaviour","text":"Return current selection behaviour. Returns: Type Description SelectionBehaviourStr selection behaviour Source code in prettyqt/widgets/abstractitemview.py def get_selection_behaviour ( self ) -> SelectionBehaviourStr : \"\"\"Return current selection behaviour. Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOUR . inverse [ self . selectionBehavior ()]","title":"get_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_mode","text":"Return current selection mode. Returns: Type Description SelectionModeStr selection mode Source code in prettyqt/widgets/abstractitemview.py def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.highlight_when_inactive","text":"Highlight items when widget does not have focus. Source code in prettyqt/widgets/abstractitemview.py def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p )","title":"highlight_when_inactive()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.jump_to_column","text":"Make sure column at given index is visible. scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx )","title":"jump_to_column()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.num_selected","text":"Return amount of selected rows. Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ())","title":"num_selected()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_bottom","text":"Override to use abstractitemview-way of scrolling to bottom. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_top","text":"Override to use abstractitemview-way of scrolling to top. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selectAll","text":"Override, we dont want to selectAll for too many items bc of performance. Source code in prettyqt/widgets/abstractitemview.py def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return super () . selectAll ()","title":"selectAll()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_data","text":"Returns generator yielding selected userData. Source code in prettyqt/widgets/abstractitemview.py def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes () # type: ignore )","title":"selected_data()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_indexes","text":"Returns list of selected indexes in first row. Source code in prettyqt/widgets/abstractitemview.py def selected_indexes ( self ) -> list [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) # type: ignore return sorted ( indexes , key = lambda x : x . row ()) # type: ignore","title":"selected_indexes()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_names","text":"Returns generator yielding item names. Source code in prettyqt/widgets/abstractitemview.py def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ())","title":"selected_names()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_rows","text":"Returns generator yielding row nums. Source code in prettyqt/widgets/abstractitemview.py def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ())","title":"selected_rows()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_drag_drop_mode","text":"Set drag-drop mode for given item view. Parameters: Name Type Description Default mode DragDropModeStr drag-drop mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_drag_drop_mode ( self , mode : DragDropModeStr ): \"\"\"Set drag-drop mode for given item view. Args: mode: drag-drop mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_DROP_MODE : raise InvalidParamError ( mode , DRAG_DROP_MODE ) self . setDragDropMode ( DRAG_DROP_MODE [ mode ])","title":"set_drag_drop_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_horizontal_scroll_mode","text":"Set the horizontal scroll mode. Parameters: Name Type Description Default mode ScrollModeStr mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_horizontal_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the horizontal scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ])","title":"set_horizontal_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_model","text":"Delete old selection model explicitely, seems to help with memory usage. Source code in prettyqt/widgets/abstractitemview.py def set_model ( self , model : QtCore . QAbstractItemModel | None ): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # type: ignore # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model","title":"set_model()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_scroll_mode","text":"Set the scroll mode for both directions. Parameters: Name Type Description Default mode ScrollModeStr mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the scroll mode for both directions. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) self . setVerticalScrollMode ( SCROLL_MODE [ mode ])","title":"set_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_behaviour","text":"Set selection behaviour for given item view. Parameters: Name Type Description Default behaviour SelectionBehaviourStr selection behaviour to use required Exceptions: Type Description InvalidParamError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_behaviour ( self , behaviour : SelectionBehaviourStr ): \"\"\"Set selection behaviour for given item view. Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOUR : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOUR ) self . setSelectionBehavior ( SELECTION_BEHAVIOUR [ behaviour ])","title":"set_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_mode","text":"Set selection mode for given item view. Parameters: Name Type Description Default mode SelectionModeStr | None selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_mode ( self , mode : SelectionModeStr | None ): \"\"\"Set selection mode for given item view. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_vertical_scroll_mode","text":"Set the vertical scroll mode. Parameters: Name Type Description Default mode ScrollModeStr mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_vertical_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the vertical scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setVerticalScrollMode ( SCROLL_MODE [ mode ])","title":"set_vertical_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.toggle_select_all","text":"Select all items from list (deselect when all selected). Source code in prettyqt/widgets/abstractitemview.py def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll ()","title":"toggle_select_all()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea","text":"","title":"abstractscrollarea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea","text":"Source code in prettyqt/widgets/abstractscrollarea.py class AbstractScrollArea ( QtWidgets . QAbstractScrollArea ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setHorizontalScrollBar ( widgets . ScrollBar ( parent = self )) self . setVerticalScrollBar ( widgets . ScrollBar ( parent = self )) def serialize_fields ( self ): return dict ( size_adjust_policy = self . get_size_adjust_policy (), horizontal_scrollbar_policy = self . get_horizontal_scrollbar_policy (), vertical_scrollbar_policy = self . get_vertical_scrollbar_policy (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_size_adjust_policy ( state [ \"size_adjust_policy\" ]) self . set_horizontal_scrollbar_policy ( state [ \"horizontal_scrollbar_policy\" ]) self . set_vertical_scrollbar_policy ( state [ \"vertical_scrollbar_policy\" ]) @property def h_scrollbar ( self ): return self . horizontalScrollBar () @h_scrollbar . setter def h_scrollbar ( self , scrollbar ): self . setHorizontalScrollBar ( scrollbar ) @property def v_scrollbar ( self ): return self . verticalScrollBar () @v_scrollbar . setter def v_scrollbar ( self , scrollbar ): self . setVerticalScrollBar ( scrollbar ) def set_size_adjust_policy ( self , policy : SizePolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICY : raise InvalidParamError ( policy , SIZE_POLICY ) self . setSizeAdjustPolicy ( SIZE_POLICY [ policy ]) def get_size_adjust_policy ( self ) -> SizePolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_POLICY . inverse [ self . sizeAdjustPolicy ()] def set_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the policy for both scrollbars. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) def set_horizontal_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the horizontal scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) def get_horizontal_scrollbar_policy ( self ): return constants . SCROLLBAR_POLICY . inverse [ self . horizontalScrollBarPolicy ()] def set_vertical_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the vertical scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) def get_vertical_scrollbar_policy ( self ): return constants . SCROLLBAR_POLICY . inverse [ self . verticalScrollBarPolicy ()] def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width ) def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min () def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max ()","title":"AbstractScrollArea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.get_size_adjust_policy","text":"Return size adjust policy. Returns: Type Description SizePolicyStr size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def get_size_adjust_policy ( self ) -> SizePolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_POLICY . inverse [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_bottom","text":"Scroll to the bottom of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_top","text":"Scroll to the top of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_policy","text":"Set the horizontal scrollbar visibility. Parameters: Name Type Description Default mode constants.ScrollBarPolicyStr visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the horizontal scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ])","title":"set_horizontal_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_width","text":"Set the horizontal scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" )","title":"set_horizontal_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_policy","text":"Set the policy for both scrollbars. Parameters: Name Type Description Default mode constants.ScrollBarPolicyStr visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the policy for both scrollbars. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ])","title":"set_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_width","text":"Set the width for both scrollbars. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width )","title":"set_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_size_adjust_policy","text":"Set size adjust policy. Parameters: Name Type Description Default policy SizePolicyStr size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def set_size_adjust_policy ( self , policy : SizePolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICY : raise InvalidParamError ( policy , SIZE_POLICY ) self . setSizeAdjustPolicy ( SIZE_POLICY [ policy ])","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_policy","text":"Set the vertical scrollbar visibility. Parameters: Name Type Description Default mode constants.ScrollBarPolicyStr visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the vertical scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ])","title":"set_vertical_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_width","text":"Set the vertical scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" )","title":"set_vertical_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider","text":"","title":"abstractslider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider","text":"Source code in prettyqt/widgets/abstractslider.py class AbstractSlider ( QtWidgets . QAbstractSlider ): value_changed = core . Signal ( int ) def on_value_change ( self ): self . value_changed . emit ( self . value ()) def serialize_fields ( self ): return dict ( range = ( self . minimum (), self . maximum ()), value = self . value (), has_tracking = self . hasTracking (), inverted_controls = self . invertedControls (), inverted_appearance = self . invertedAppearance (), single_step = self . singleStep (), page_step = self . pageStep (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_range ( * state [ \"range\" ]) self . set_value ( state [ \"value\" ]) self . setSingleStep ( state [ \"single_step\" ]) self . setPageStep ( state [ \"page_step\" ]) self . setTracking ( state [ \"has_tracking\" ]) self . setInvertedControls ( state [ \"inverted_controls\" ]) self . setInvertedAppearance ( state [ \"inverted_appearance\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == constants . HORIZONTAL def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == constants . VERTICAL def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( constants . HORIZONTAL ) def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( constants . VERTICAL ) def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the slider. Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ()) def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ()) def set_range ( self , min_val : int , max_val : int ): self . setRange ( min_val , max_val ) def set_step_size ( self , step_size : int ): self . setSingleStep ( step_size ) def set_repeat_action ( self , action : SliderActionStr , threshold : int = 500 , repeat_time : int = 50 ): \"\"\"Set the repeat action. Args: action: repeat action Raises: InvalidParamError: invalid repeat action \"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . setRepeatAction ( SLIDER_ACTION [ action ], threshold , repeat_time ) def get_repeat_action ( self ) -> SliderActionStr : \"\"\"Get current repeat action. Returns: current repeat action \"\"\" return SLIDER_ACTION . inverse [ self . repeatAction ()] def trigger_action ( self , action : SliderActionStr ): \"\"\"Trigger slider action.\"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . triggerAction ( SLIDER_ACTION [ action ]) def get_value ( self ): return self . value () def set_value ( self , value : int ): self . setValue ( value ) def on_scrollbar_range_changed ( self , minval , maxval ): if self . value () >= self . maximum () - 1 : self . setValue ( maxval ) def set_auto_scroll_to_end ( self , scroll : bool = True ): \"\"\"Set to always scroll to the end when range changes.\"\"\" if scroll : self . rangeChanged . connect ( self . on_scrollbar_range_changed ) else : self . rangeChanged . disconnect ( self . on_scrollbar_range_changed )","title":"AbstractSlider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.get_orientation","text":"Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/abstractslider.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.get_repeat_action","text":"Get current repeat action. Returns: Type Description SliderActionStr current repeat action Source code in prettyqt/widgets/abstractslider.py def get_repeat_action ( self ) -> SliderActionStr : \"\"\"Get current repeat action. Returns: current repeat action \"\"\" return SLIDER_ACTION . inverse [ self . repeatAction ()]","title":"get_repeat_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_horizontal","text":"Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == constants . HORIZONTAL","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_vertical","text":"Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == constants . VERTICAL","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_max","text":"Scroll to the maximum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ())","title":"scroll_to_max()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_min","text":"Scroll to the minimum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ())","title":"scroll_to_min()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_auto_scroll_to_end","text":"Set to always scroll to the end when range changes. Source code in prettyqt/widgets/abstractslider.py def set_auto_scroll_to_end ( self , scroll : bool = True ): \"\"\"Set to always scroll to the end when range changes.\"\"\" if scroll : self . rangeChanged . connect ( self . on_scrollbar_range_changed ) else : self . rangeChanged . disconnect ( self . on_scrollbar_range_changed )","title":"set_auto_scroll_to_end()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_horizontal","text":"Set slider orientation to horizontal. Source code in prettyqt/widgets/abstractslider.py def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( constants . HORIZONTAL )","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_orientation","text":"Set the orientation of the slider. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the slider required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/abstractslider.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the slider. Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_repeat_action","text":"Set the repeat action. Parameters: Name Type Description Default action SliderActionStr repeat action required Exceptions: Type Description InvalidParamError invalid repeat action Source code in prettyqt/widgets/abstractslider.py def set_repeat_action ( self , action : SliderActionStr , threshold : int = 500 , repeat_time : int = 50 ): \"\"\"Set the repeat action. Args: action: repeat action Raises: InvalidParamError: invalid repeat action \"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . setRepeatAction ( SLIDER_ACTION [ action ], threshold , repeat_time )","title":"set_repeat_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_vertical","text":"Set slider orientation to vertical. Source code in prettyqt/widgets/abstractslider.py def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( constants . VERTICAL )","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.trigger_action","text":"Trigger slider action. Source code in prettyqt/widgets/abstractslider.py def trigger_action ( self , action : SliderActionStr ): \"\"\"Trigger slider action.\"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . triggerAction ( SLIDER_ACTION [ action ])","title":"trigger_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox","text":"","title":"abstractspinbox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox","text":"Source code in prettyqt/widgets/abstractspinbox.py class AbstractSpinBox ( QtWidgets . QAbstractSpinBox ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setLineEdit ( widgets . LineEdit ()) self . setGroupSeparatorShown ( True ) def serialize_fields ( self ): return dict ( button_symbols = self . get_button_symbols (), correction_mode = self . get_correction_mode (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_correction_mode ( state [ \"correction_mode\" ]) self . set_button_symbols ( state [ \"button_symbols\" ]) def is_valid ( self ) -> bool : return self . hasAcceptableInput () def set_validator ( self , validator : gui . Validator ): self . lineEdit () . setValidator ( validator ) def get_button_symbols ( self ) -> SymbolStr : \"\"\"Return button symbol type. Returns: button symbol type \"\"\" return SYMBOLS . inverse [ self . buttonSymbols ()] def set_button_symbols ( self , mode : SymbolStr ): \"\"\"Set button symbol type. Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ]) def set_correction_mode ( self , mode : CorrectionModeStr ): \"\"\"Set correction mode. Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ]) def get_correction_mode ( self ) -> CorrectionModeStr : \"\"\"Return correction mode. Returns: correction mode \"\"\" return CORRECTION_MODES . inverse [ self . correctionMode ()] def set_step_type ( self , mode : StepTypeStr ): \"\"\"Set step type. Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ]) def get_step_type ( self ) -> StepTypeStr : \"\"\"Return step type. Returns: step type \"\"\" return STEP_TYPES . inverse [ self . stepType ()] def set_special_value ( self , value : str ): self . setSpecialValueText ( value ) def get_value ( self ) -> int : return self . value () def set_value ( self , value : int ): self . setValue ( value )","title":"AbstractSpinBox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_button_symbols","text":"Return button symbol type. Returns: Type Description SymbolStr button symbol type Source code in prettyqt/widgets/abstractspinbox.py def get_button_symbols ( self ) -> SymbolStr : \"\"\"Return button symbol type. Returns: button symbol type \"\"\" return SYMBOLS . inverse [ self . buttonSymbols ()]","title":"get_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_correction_mode","text":"Return correction mode. Returns: Type Description CorrectionModeStr correction mode Source code in prettyqt/widgets/abstractspinbox.py def get_correction_mode ( self ) -> CorrectionModeStr : \"\"\"Return correction mode. Returns: correction mode \"\"\" return CORRECTION_MODES . inverse [ self . correctionMode ()]","title":"get_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_step_type","text":"Return step type. Returns: Type Description StepTypeStr step type Source code in prettyqt/widgets/abstractspinbox.py def get_step_type ( self ) -> StepTypeStr : \"\"\"Return step type. Returns: step type \"\"\" return STEP_TYPES . inverse [ self . stepType ()]","title":"get_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_button_symbols","text":"Set button symbol type. Parameters: Name Type Description Default mode SymbolStr button symbol type to use required Exceptions: Type Description InvalidParamError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py def set_button_symbols ( self , mode : SymbolStr ): \"\"\"Set button symbol type. Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ])","title":"set_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_correction_mode","text":"Set correction mode. Parameters: Name Type Description Default mode CorrectionModeStr correction mode to use required Exceptions: Type Description InvalidParamError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py def set_correction_mode ( self , mode : CorrectionModeStr ): \"\"\"Set correction mode. Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ])","title":"set_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_step_type","text":"Set step type. Parameters: Name Type Description Default mode StepTypeStr step type to use required Exceptions: Type Description InvalidParamError invalid step type Source code in prettyqt/widgets/abstractspinbox.py def set_step_type ( self , mode : StepTypeStr ): \"\"\"Set step type. Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ])","title":"set_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.action","text":"","title":"action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action","text":"Source code in prettyqt/widgets/action.py class Action ( prettyprinter . PrettyPrinter , QtWidgets . QAction ): def __init__ ( self , parent : QtCore . QObject | None = None , text : str = \"\" , icon : types . IconType = None , shortcut : str | None = None , tooltip : str = \"\" , checkable : bool = False , checked : bool = False , statustip : str = \"\" , enabled : bool = True , callback : Callable | None = None , ): super () . __init__ ( parent ) self . _menu = None self . set_text ( text ) self . set_icon ( icon ) self . set_shortcut ( shortcut ) self . set_tooltip ( tooltip ) self . set_checkable ( checkable ) self . set_checked ( checked ) self . set_statustip ( statustip ) self . set_enabled ( enabled ) if callback is not None : self . triggered . connect ( callback ) def __repr__ ( self ) -> str : cls_name = type ( self ) . __name__ return f \" { cls_name } ( { helpers . format_kwargs ( self . serialize_fields ()) } )\" def serialize_fields ( self ): dct = dict ( auto_repeat = self . autoRepeat (), text = self . text (), enabled = self . isEnabled (), visible = self . isVisible (), font = self . get_font (), shortcut = self . get_shortcut (), tool_tip = self . toolTip (), checkable = self . isCheckable (), checked = self . isChecked (), icon = self . get_icon (), icon_text = self . iconText (), priority = self . get_priority (), icon_visible_in_menu = self . isIconVisibleInMenu (), shortcut_visible_in_context_menu = self . isShortcutVisibleInContextMenu (), menu_role = self . get_menu_role (), shortcut_context = self . get_shortcut_context (), status_tip = self . statusTip (), whats_this = self . whatsThis (), ) if core . VersionNumber . get_qt_version () < ( 6 , 0 , 0 ): dct [ \"menu\" ] = self . menu () return dct def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_text ( state . get ( \"text\" , \"\" )) self . set_enabled ( state . get ( \"enabled\" , True )) self . set_shortcut ( state [ \"shortcut\" ]) self . set_tooltip ( state . get ( \"tool_tip\" , \"\" )) self . set_statustip ( state . get ( \"status_tip\" , \"\" )) self . set_checked ( state . get ( \"checked\" , False )) self . set_priority ( state [ \"priority\" ]) self . set_shortcut_context ( state [ \"shortcut_context\" ]) self . set_checkable ( state [ \"checkable\" ]) self . setAutoRepeat ( state [ \"auto_repeat\" ]) self . setVisible ( state [ \"visible\" ]) self . setFont ( state [ \"font\" ]) # self.setIcon(state[\"icon\"]) self . setIconText ( state [ \"icon_text\" ]) self . setIconVisibleInMenu ( state [ \"icon_visible_in_menu\" ]) self . setShortcutVisibleInContextMenu ( state [ \"shortcut_visible_in_context_menu\" ]) self . set_menu_role ( state [ \"menu_role\" ]) self . setWhatsThis ( state [ \"whats_this\" ]) # if core.VersionNumber.get_qt_version() < (6, 0, 0): # self.setMenu(state[\"menu\"]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def set_text ( self , text : str ): self . setText ( text ) def set_enabled ( self , enabled : bool = True ): self . setEnabled ( enabled ) def set_disabled ( self ): self . setEnabled ( False ) def set_tooltip ( self , tooltip : str | types . PathType , size : types . SizeType | None = None , ): if isinstance ( tooltip , os . PathLike ): path = os . fspath ( tooltip ) if size is None : tooltip = f \"<img src= { path !r} >\" else : if isinstance ( size , QtCore . QSize ): size = ( size . width (), size . height ()) tooltip = f '<img src= { path !r} width=\" { size [ 0 ] } \" height=\" { size [ 1 ] } \">' self . setToolTip ( tooltip ) def set_statustip ( self , text : str ): self . setStatusTip ( text ) def set_checked ( self , value : bool ): self . setChecked ( value ) def set_checkable ( self , value : bool ): self . setCheckable ( value ) def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_shortcut ( self , shortcut : None | QtGui . QKeySequence | str ): if shortcut is None : shortcut = \"\" if isinstance ( shortcut , str ): shortcut = gui . KeySequence ( shortcut , gui . KeySequence . SequenceFormat . PortableText ) self . setShortcut ( shortcut ) def get_shortcut ( self ) -> gui . KeySequence | None : shortcut = self . shortcut () if not shortcut : return None return gui . KeySequence ( shortcut . toString (), gui . KeySequence . SequenceFormat . PortableText ) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def set_menu ( self , menu ): try : self . setMenu ( menu ) except AttributeError : self . triggered . connect ( menu . exec_ ) self . _menu = menu def menu ( self ): return self . _menu def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority of the action. Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ]) def get_priority ( self ) -> PriorityStr : \"\"\"Return current priority. Returns: priority \"\"\" return PRIORITIES . inverse [ self . priority ()] def set_shortcut_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setShortcutContext ( constants . CONTEXT [ context ]) def get_shortcut_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . shortcutContext ()] def set_menu_role ( self , role : RoleStr ): \"\"\"Set menu role. Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ]) def get_menu_role ( self ) -> RoleStr : \"\"\"Return menu role. Returns: menu role \"\"\" return ROLES . inverse [ self . menuRole ()] def show_shortcut_in_contextmenu ( self , state : bool = True ): self . setShortcutVisibleInContextMenu ( state )","title":"Action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_menu_role","text":"Return menu role. Returns: Type Description RoleStr menu role Source code in prettyqt/widgets/action.py def get_menu_role ( self ) -> RoleStr : \"\"\"Return menu role. Returns: menu role \"\"\" return ROLES . inverse [ self . menuRole ()]","title":"get_menu_role()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_priority","text":"Return current priority. Returns: Type Description PriorityStr priority Source code in prettyqt/widgets/action.py def get_priority ( self ) -> PriorityStr : \"\"\"Return current priority. Returns: priority \"\"\" return PRIORITIES . inverse [ self . priority ()]","title":"get_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_shortcut_context","text":"Return shortcut context. Returns: Type Description constants.ContextStr shortcut context Source code in prettyqt/widgets/action.py def get_shortcut_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . shortcutContext ()]","title":"get_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.menu","text":"menu(self) -> PySide6.QtCore.QObject Source code in prettyqt/widgets/action.py def menu ( self ): return self . _menu","title":"menu()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/action.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_menu_role","text":"Set menu role. Parameters: Name Type Description Default role RoleStr menu role required Exceptions: Type Description InvalidParamError menu role does not exist Source code in prettyqt/widgets/action.py def set_menu_role ( self , role : RoleStr ): \"\"\"Set menu role. Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ])","title":"set_menu_role()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_priority","text":"Set priority of the action. Parameters: Name Type Description Default priority PriorityStr priority for the action required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/widgets/action.py def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority of the action. Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ])","title":"set_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_shortcut_context","text":"Set shortcut context. Parameters: Name Type Description Default context constants.ContextStr shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/action.py def set_shortcut_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setShortcutContext ( constants . CONTEXT [ context ])","title":"set_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup","text":"","title":"actiongroup"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup","text":"Source code in prettyqt/widgets/actiongroup.py class ActionGroup ( QtWidgets . QActionGroup ): def __init__ ( self , parent : QtCore . QObject | None = None ): super () . __init__ ( parent ) # type: ignore def __len__ ( self ) -> int : return len ( self . actions ()) def __getitem__ ( self , item : int ) -> QtWidgets . QAction : return self . actions ()[ item ] def serialize_fields ( self ): return dict ( exclusion_policy = self . get_exclusion_policy (), visible = self . isVisible (), enabled = self . isEnabled (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setEnabled ( state . get ( \"enabled\" , \"\" )) self . setVisible ( state . get ( \"visible\" , \"\" )) self . set_exclusion_policy ( state . get ( \"exclusion_policy\" , \"\" )) def set_exclusion_policy ( self , policy : ExclusionPolicyStr | None ): \"\"\"Set exclusion policy to use. Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ]) def get_exclusion_policy ( self ) -> ExclusionPolicyStr : \"\"\"Return current exclusion policy. Returns: exclusion policy \"\"\" return POLICIES . inverse [ self . exclusionPolicy ()]","title":"ActionGroup"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.get_exclusion_policy","text":"Return current exclusion policy. Returns: Type Description ExclusionPolicyStr exclusion policy Source code in prettyqt/widgets/actiongroup.py def get_exclusion_policy ( self ) -> ExclusionPolicyStr : \"\"\"Return current exclusion policy. Returns: exclusion policy \"\"\" return POLICIES . inverse [ self . exclusionPolicy ()]","title":"get_exclusion_policy()"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.set_exclusion_policy","text":"Set exclusion policy to use. Parameters: Name Type Description Default policy ExclusionPolicyStr | None exclusion policy to use required Exceptions: Type Description InvalidParamError exclusion policy does not exist Source code in prettyqt/widgets/actiongroup.py def set_exclusion_policy ( self , policy : ExclusionPolicyStr | None ): \"\"\"Set exclusion policy to use. Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ])","title":"set_exclusion_policy()"},{"location":"api/widgets.html#prettyqt.widgets.application","text":"","title":"application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application","text":"Source code in prettyqt/widgets/application.py class Application ( QtWidgets . QApplication ): def __class_getitem__ ( cls , name : str ) -> QtWidgets . QWidget : widget = cls . get_widget ( name ) if widget is None : raise ValueError ( f \"Widget { name !r} does not exist.\" ) return widget def __iter__ ( self ) -> Iterator [ QtWidgets . QWidget ]: return iter ( self . topLevelWidgets ()) def serialize_fields ( self ): return dict ( auto_sip_enabled = self . autoSipEnabled (), cursor_flash_time = self . cursorFlashTime (), double_click_interval = self . doubleClickInterval (), keyboard_input_interval = self . keyboardInputInterval (), start_drag_distance = self . startDragDistance (), start_drag_time = self . startDragTime (), style_sheet = self . styleSheet (), wheel_scroll_lines = self . wheelScrollLines (), ) def store_widget_states ( self , settings : MutableMapping | None = None , key : str = \"states\" ): settings = core . Settings () if settings is None else settings result = {} for k , v in SAVE_STATES . items (): result [ k ] = { i . objectName (): i . saveState () for i in self . find_children ( v ) if i . objectName () } settings [ key ] = result def restore_widget_states ( self , settings : Mapping | None = None , key : str = \"states\" ): settings = core . Settings () if settings is None else settings for category , v in SAVE_STATES . items (): items = settings [ key ] . get ( category ) if items is None : continue for name , state in items . items (): w = self . find_child ( v , name = name ) if w is not None : if isinstance ( state , str ): state = state . encode () w . restoreState ( state ) def about_popup ( self , title : str = \"About\" ): text = ( f \" { self . applicationName () } \\n\\n \" f \" { self . organizationName () } \\n \" f \" { self . applicationVersion () } \\n \" f \" { self . organizationDomain () } \" ) popup = widgets . MessageBox ( \"none\" , title , text , buttons = [ \"ok\" ], ) popup . set_icon ( \"mdi.information-outline\" ) popup . exec_ () @classmethod def get_mainwindow ( cls ) -> QtWidgets . QMainWindow | None : inst = cls . instance () if inst is None : return None widget_list = inst . topLevelWidgets () for widget in widget_list : if isinstance ( widget , QtWidgets . QMainWindow ): return widget return None @classmethod def get_widget ( cls , name : str ) -> QtWidgets . QWidget | None : mw = cls . get_mainwindow () if mw is None : logger . warning ( \"Trying to get widget from nonexistent mainwindow\" ) return None return mw . findChild ( QtWidgets . QWidget , name ) # type: ignore # widget_list = cls.instance().allWidgets() # for widget in widget_list: # if isinstance(widget, QtWidgets.QWidget) and widget.objectName() == name: # return widget # return None @contextlib . contextmanager def edit_stylesheet ( self ) -> Iterator [ qstylizer . style . StyleSheet ]: ss = self . get_stylesheet () yield ss self . set_stylesheet ( ss ) def set_stylesheet ( self , ss : None | str | qstylizer . style . StyleSheet | types . PathType ): if isinstance ( ss , os . PathLike ): ss = pathlib . Path ( ss ) . read_text () elif ss is None : ss = \"\" self . setStyleSheet ( str ( ss )) def get_stylesheet ( self ) -> qstylizer . style . StyleSheet : return qstylizer . parser . parse ( self . styleSheet ()) def set_theme ( self , theme : constants . ThemeStr ): self . set_palette ( theme ) if theme == \"default\" : self . set_stylesheet ( \"\" ) iconprovider . set_defaults ( color = \"black\" ) elif theme == \"dark\" : ss = ( paths . THEMES_PATH / \"darktheme.qss\" ) . read_text () self . set_stylesheet ( ss ) iconprovider . set_defaults ( color = \"lightblue\" ) @classmethod def get_available_themes ( cls ) -> dict [ constants . ThemeStr , str ]: return dict ( default = \"Default\" , dark = \"Dark\" ) def send_event ( self , obj_or_str : str | QtCore . QObject , event : QtCore . QEvent ): obj = self . get_widget ( obj_or_str ) if isinstance ( obj_or_str , str ) else obj_or_str if obj is None : raise ValueError ( obj ) return self . sendEvent ( obj , event ) def post_event ( self , obj_or_str : str | QtCore . QObject , event : QtCore . QEvent , priority : int | constants . EventPriorityStr = \"normal\" , ): obj = self . get_widget ( obj_or_str ) if isinstance ( obj_or_str , str ) else obj_or_str if obj is None : raise ValueError ( obj ) super () . post_event ( obj , event , priority ) @classmethod def get_style_icon ( cls , icon : widgets . style . StandardPixmapStr ) -> gui . Icon : style = cls . style () # icon_size = style.pixelMetric(QtWidgets.QStyle.PM_MessageBoxIconSize) if icon not in widgets . style . STANDARD_PIXMAP : raise InvalidParamError ( icon , widgets . style . STANDARD_PIXMAP ) icon = style . standardIcon ( widgets . style . STANDARD_PIXMAP [ icon ]) return gui . Icon ( icon ) def set_effect_enabled ( self , effect : constants . UiEffectStr , enabled : bool = True ): \"\"\"Set the enabled state of a desktop effect. Args: effect: desktop effect to set enabled: new state Raises: InvalidParamError: invalid desktop effect \"\"\" if effect not in constants . UI_EFFECTS : raise InvalidParamError ( effect , constants . UI_EFFECTS ) self . setEffectEnabled ( constants . UI_EFFECTS [ effect ]) def is_effect_enabled ( self , effect : constants . UiEffectStr ) -> bool : \"\"\"Return desktop effect state. Returns: desktop effect state \"\"\" return self . isEffectEnabled ( constants . UI_EFFECTS [ effect ]) def set_navigation_mode ( self , mode : constants . NavigationModeStr ): \"\"\"Set the navigation mode. Args: mode: navigation mode to use Raises: InvalidParamError: invalid navigation mode \"\"\" if mode not in constants . NAVIGATION_MODES : raise InvalidParamError ( mode , constants . NAVIGATION_MODES ) self . setNavigationMode ( constants . NAVIGATION_MODES [ mode ]) def get_navigation_mode ( self ) -> constants . NavigationModeStr : \"\"\"Return navigation mode. Returns: navigation mode \"\"\" return constants . NAVIGATION_MODES . inverse [ self . navigationMode ()] @classmethod def sleep ( cls , secs : float ): \"\"\"Pause application (non-blocking). Args: secs: seconds to sleep \"\"\" start = timeit . default_timer () while True : cls . processEvents () if timeit . default_timer () - start > secs : return","title":"Application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.get_navigation_mode","text":"Return navigation mode. Returns: Type Description constants.NavigationModeStr navigation mode Source code in prettyqt/widgets/application.py def get_navigation_mode ( self ) -> constants . NavigationModeStr : \"\"\"Return navigation mode. Returns: navigation mode \"\"\" return constants . NAVIGATION_MODES . inverse [ self . navigationMode ()]","title":"get_navigation_mode()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.is_effect_enabled","text":"Return desktop effect state. Returns: Type Description bool desktop effect state Source code in prettyqt/widgets/application.py def is_effect_enabled ( self , effect : constants . UiEffectStr ) -> bool : \"\"\"Return desktop effect state. Returns: desktop effect state \"\"\" return self . isEffectEnabled ( constants . UI_EFFECTS [ effect ])","title":"is_effect_enabled()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.set_effect_enabled","text":"Set the enabled state of a desktop effect. Parameters: Name Type Description Default effect constants.UiEffectStr desktop effect to set required enabled bool new state True Exceptions: Type Description InvalidParamError invalid desktop effect Source code in prettyqt/widgets/application.py def set_effect_enabled ( self , effect : constants . UiEffectStr , enabled : bool = True ): \"\"\"Set the enabled state of a desktop effect. Args: effect: desktop effect to set enabled: new state Raises: InvalidParamError: invalid desktop effect \"\"\" if effect not in constants . UI_EFFECTS : raise InvalidParamError ( effect , constants . UI_EFFECTS ) self . setEffectEnabled ( constants . UI_EFFECTS [ effect ])","title":"set_effect_enabled()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.set_navigation_mode","text":"Set the navigation mode. Parameters: Name Type Description Default mode constants.NavigationModeStr navigation mode to use required Exceptions: Type Description InvalidParamError invalid navigation mode Source code in prettyqt/widgets/application.py def set_navigation_mode ( self , mode : constants . NavigationModeStr ): \"\"\"Set the navigation mode. Args: mode: navigation mode to use Raises: InvalidParamError: invalid navigation mode \"\"\" if mode not in constants . NAVIGATION_MODES : raise InvalidParamError ( mode , constants . NAVIGATION_MODES ) self . setNavigationMode ( constants . NAVIGATION_MODES [ mode ])","title":"set_navigation_mode()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.sleep","text":"Pause application (non-blocking). Parameters: Name Type Description Default secs float seconds to sleep required Source code in prettyqt/widgets/application.py @classmethod def sleep ( cls , secs : float ): \"\"\"Pause application (non-blocking). Args: secs: seconds to sleep \"\"\" start = timeit . default_timer () while True : cls . processEvents () if timeit . default_timer () - start > secs : return","title":"sleep()"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout","text":"","title":"boxlayout"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayout","text":"Source code in prettyqt/widgets/boxlayout.py class BoxLayout ( QtWidgets . QBoxLayout ): def __init__ ( self , orientation : Literal [ \"horizontal\" , \"vertical\" ] = \"horizontal\" , parent : QtWidgets . QWidget | None = None , margin : int | None = None , ): o = ( self . Direction . TopToBottom if orientation == \"vertical\" else self . Direction . LeftToRight ) super () . __init__ ( o , parent ) if margin is not None : self . set_margin ( margin ) def serialize_fields ( self ): return dict ( items = self . get_children (), direction = self . get_direction ()) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_direction ( state [ \"direction\" ]) for item in state [ \"items\" ]: self . add ( item ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __add__ ( self , other : QtWidgets . QWidget | QtWidgets . QLayout ): self . add ( other ) return self def add ( self , * item ): for i in item : if isinstance ( i , QtWidgets . QWidget ): self . addWidget ( i ) else : self . addLayout ( i ) def add_stretch ( self , stretch : int = 0 ): self . addStretch ( stretch ) def add_spacing ( self , size : int ): self . addSpacing ( size ) def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()]","title":"BoxLayout"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayout.get_direction","text":"Return current direction. Returns: Type Description DirectionStr direction Source code in prettyqt/widgets/boxlayout.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()]","title":"get_direction()"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayout.set_direction","text":"Set the direction. Parameters: Name Type Description Default direction DirectionStr direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/widgets/boxlayout.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ])","title":"set_direction()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget","text":"","title":"calendarwidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget","text":"Source code in prettyqt/widgets/calendarwidget.py class CalendarWidget ( QtWidgets . QCalendarWidget ): def serialize_fields ( self ): return dict ( date = self . get_date ()) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setSelectedDate ( state [ \"date\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def get_date ( self ) -> datetime . date : return self . selectedDate () . toPython () # type: ignore def get_value ( self ) -> datetime . date : return self . get_date () def set_value ( self , value : types . DateType ): if isinstance ( value , str ): value = QtCore . QDate . fromString ( value ) self . setSelectedDate ( value ) # type: ignore def set_range ( self , lower : types . DateType , upper : types . DateType , ): if isinstance ( lower , str ): lower = QtCore . QDate . fromString ( lower ) if isinstance ( upper , str ): upper = QtCore . QDate . fromString ( upper ) self . setMinimumDate ( lower ) # type: ignore self . setMaximumDate ( upper ) # type: ignore def set_selection_mode ( self , mode : SelectionModeStr | None ): \"\"\"Set selection mode for given calendar widget. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ]) def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()]","title":"CalendarWidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.get_selection_mode","text":"Return current selection mode. Returns: Type Description SelectionModeStr selection mode Source code in prettyqt/widgets/calendarwidget.py def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.set_selection_mode","text":"Set selection mode for given calendar widget. Parameters: Name Type Description Default mode SelectionModeStr | None selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/calendarwidget.py def set_selection_mode ( self , mode : SelectionModeStr | None ): \"\"\"Set selection mode for given calendar widget. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox","text":"","title":"checkbox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox","text":"Source code in prettyqt/widgets/checkbox.py class CheckBox ( QtWidgets . QCheckBox ): value_changed = core . Signal ( int ) def __init__ ( self , label : str = \"\" , parent : QtWidgets . QWidget | None = None , checked : bool = False , ): super () . __init__ ( label , parent ) self . stateChanged . connect ( self . value_changed ) self . setChecked ( checked ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setTristate ( state . get ( \"is_tristate\" , False )) self . set_checkstate ( state [ \"checkstate\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def serialize_fields ( self ): return dict ( checkstate = self . get_checkstate (), is_tristate = self . isTristate (), ) def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()]","title":"CheckBox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.get_checkstate","text":"Return checkstate. Returns: Type Description constants.StateStr checkstate Source code in prettyqt/widgets/checkbox.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/checkbox.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.colordialog","text":"","title":"colordialog"},{"location":"api/widgets.html#prettyqt.widgets.colordialog.CPAlphaShowLabel","text":"Source code in prettyqt/widgets/colordialog.py class CPAlphaShowLabel ( widgets . Label ): \"\"\"Label which displays the currently-active color using checkerboard alpha. A replacement for QColorDialog's QColorShowLabel. \"\"\" def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) # Length in pixels of a side of the checkerboard squares # (Pattern is made up of 2\u00d72 squares, total size 2n \u00d7 2n) self . checkerboard_size = 8 # Start out transparent by default self . color = self . parent () . currentColor () self . parent () . currentColorChanged . connect ( self . update_color ) self . pattern = gui . Pixmap . create_checkerboard_pattern ( self . checkerboard_size , \"#aaa\" , \"#ccc\" ) def update_color ( self , color : QtGui . QColor ): self . color = color self . repaint () def paintEvent ( self , event ): \"\"\"Show the current color using checkerboard alpha.\"\"\" event . accept () with gui . Painter ( self ) as p : p . set_pen ( None ) if self . color . alphaF () < 1.0 : p . drawTiledPixmap ( event . rect (), self . pattern , QtCore . QPoint ( 4 , 4 )) p . fillRect ( event . rect (), self . color )","title":"CPAlphaShowLabel"},{"location":"api/widgets.html#prettyqt.widgets.colordialog.CPAlphaShowLabel.paintEvent","text":"Show the current color using checkerboard alpha. Source code in prettyqt/widgets/colordialog.py def paintEvent ( self , event ): \"\"\"Show the current color using checkerboard alpha.\"\"\" event . accept () with gui . Painter ( self ) as p : p . set_pen ( None ) if self . color . alphaF () < 1.0 : p . drawTiledPixmap ( event . rect (), self . pattern , QtCore . QPoint ( 4 , 4 )) p . fillRect ( event . rect (), self . color )","title":"paintEvent()"},{"location":"api/widgets.html#prettyqt.widgets.combobox","text":"","title":"combobox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox","text":"Source code in prettyqt/widgets/combobox.py class ComboBox ( QtWidgets . QComboBox ): value_changed = core . Signal ( object ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . currentIndexChanged . connect ( self . index_changed ) def serialize_fields ( self ): items = [ ( self . itemText ( i ), self . itemData ( i ), self . item_icon ( i )) for i in range ( self . count ()) ] dct = dict ( index = self . currentIndex (), editable = self . isEditable (), max_count = self . maxCount (), has_frame = self . hasFrame (), icon_size = self . iconSize (), insert_policy = self . insertPolicy (), model_column = self . modelColumn (), max_visible_items = self . maxVisibleItems (), size_adjust_policy = self . get_size_adjust_policy (), duplicates_enabled = self . duplicatesEnabled (), min_contents_length = self . minimumContentsLength (), placeholder_text = self . placeholderText (), items = items , ) return dct def __setstate__ ( self , state ): super () . __setstate__ ( state ) for label , data , icon in state [ \"items\" ]: self . add ( label , data , icon = icon ) self . setCurrentIndex ( state [ \"index\" ]) self . setEditable ( state [ \"editable\" ]) self . setMaxCount ( state [ \"max_count\" ]) self . setMaxVisibleItems ( state [ \"max_visible_items\" ]) self . setMinimumContentsLength ( state [ \"min_contents_length\" ]) self . setDuplicatesEnabled ( state [ \"duplicates_enabled\" ]) self . setFrame ( state [ \"has_frame\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __len__ ( self ) -> int : return self . count () def index_changed ( self , index : int ): data = self . itemData ( index ) self . value_changed . emit ( data ) def add_items ( self , items : Iterable | Mapping , default = NoData ): if isinstance ( items , Mapping ): for k , v in items . items (): self . addItem ( v , userData = k ) else : for i in items : if isinstance ( i , ( tuple , list )): self . add ( * i ) else : self . addItem ( i , i ) if default is not NoData : self . set_value ( default ) def add ( self , label : str , data = NoData , icon : types . IconType = None ): if data is NoData : data = label if icon is not None : icon = iconprovider . get_icon ( icon ) self . addItem ( gui . Icon ( icon ), label , userData = data ) else : self . addItem ( label , userData = data ) def item_icon ( self , index : int ) -> gui . Icon | None : icon = self . itemIcon ( index ) if icon . isNull (): return None return gui . Icon ( icon ) def set_editable ( self , editable : bool ): self . setEditable ( editable ) if self . completer () is None and editable : self . setCompleter ( widgets . Completer ( self )) def set_insert_policy ( self , policy : InsertPolicyStr ): \"\"\"Set insert policy. Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICY : raise InvalidParamError ( policy , INSERT_POLICY ) self . setInsertPolicy ( INSERT_POLICY [ policy ]) def get_insert_policy ( self ) -> InsertPolicyStr : \"\"\"Return insert policy. Returns: insert policy \"\"\" return INSERT_POLICY . inverse [ self . insertPolicy ()] def set_size_adjust_policy ( self , policy : SizeAdjustPolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_ADJUST_POLICY : raise InvalidParamError ( policy , SIZE_ADJUST_POLICY ) self . setSizeAdjustPolicy ( SIZE_ADJUST_POLICY [ policy ]) def get_size_adjust_policy ( self ) -> SizeAdjustPolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_ADJUST_POLICY . inverse [ self . sizeAdjustPolicy ()] def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) def get_icon_size ( self ) -> core . Size : return core . Size ( self . iconSize ()) def set_min_char_length ( self , chars : int ): self . setMinimumContentsLength ( chars ) def get_value ( self ) -> Any : # if all(self.itemData(i) is None for i in range(self.count())): # return self.currentText() # else: # return self.currentData() return self . currentData () def set_value ( self , value : Any ): self . set_data ( value ) def set_text ( self , text : str ): self . setCurrentText ( text ) def set_data ( self , data : Any ): idx = self . findData ( data ) if idx == - 1 : raise ValueError ( \"invalid data\" ) self . setCurrentIndex ( idx ) def text ( self ) -> str : return self . currentText () def hide_completer ( self ): \"\"\"Hides the completion widget.\"\"\" completer = widgets . Completer ( self ) self . setCompleter ( completer )","title":"ComboBox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_insert_policy","text":"Return insert policy. Returns: Type Description InsertPolicyStr insert policy Source code in prettyqt/widgets/combobox.py def get_insert_policy ( self ) -> InsertPolicyStr : \"\"\"Return insert policy. Returns: insert policy \"\"\" return INSERT_POLICY . inverse [ self . insertPolicy ()]","title":"get_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_size_adjust_policy","text":"Return size adjust policy. Returns: Type Description SizeAdjustPolicyStr size adjust policy Source code in prettyqt/widgets/combobox.py def get_size_adjust_policy ( self ) -> SizeAdjustPolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_ADJUST_POLICY . inverse [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.hide_completer","text":"Hides the completion widget. Source code in prettyqt/widgets/combobox.py def hide_completer ( self ): \"\"\"Hides the completion widget.\"\"\" completer = widgets . Completer ( self ) self . setCompleter ( completer )","title":"hide_completer()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_icon_size","text":"Set size of the icons. Source code in prettyqt/widgets/combobox.py def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_insert_policy","text":"Set insert policy. Parameters: Name Type Description Default policy InsertPolicyStr insert policy to use required Exceptions: Type Description InvalidParamError invalid insert policy Source code in prettyqt/widgets/combobox.py def set_insert_policy ( self , policy : InsertPolicyStr ): \"\"\"Set insert policy. Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICY : raise InvalidParamError ( policy , INSERT_POLICY ) self . setInsertPolicy ( INSERT_POLICY [ policy ])","title":"set_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_size_adjust_policy","text":"Set size adjust policy. Parameters: Name Type Description Default policy SizeAdjustPolicyStr size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/combobox.py def set_size_adjust_policy ( self , policy : SizeAdjustPolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_ADJUST_POLICY : raise InvalidParamError ( policy , SIZE_ADJUST_POLICY ) self . setSizeAdjustPolicy ( SIZE_ADJUST_POLICY [ policy ])","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.completer","text":"","title":"completer"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer","text":"Source code in prettyqt/widgets/completer.py class Completer ( QtWidgets . QCompleter ): def __init__ ( self , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent ) def set_sort_mode ( self , mode : SortModeStr | None ): \"\"\"Set sort mode to use. Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODE : raise InvalidParamError ( mode , SORT_MODE ) self . setModelSorting ( SORT_MODE [ mode ]) def get_sort_mode ( self ) -> SortModeStr : \"\"\"Return current sort mode. Returns: sort mode \"\"\" return SORT_MODE . inverse [ self . modelSorting ()] def set_completion_mode ( self , mode : CompletionModeStr ): \"\"\"Set completion mode to use. Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODE : raise InvalidParamError ( mode , COMPLETION_MODE ) self . setCompletionMode ( COMPLETION_MODE [ mode ]) def get_completion_mode ( self ) -> CompletionModeStr : \"\"\"Return current completion mode. Returns: completion mode \"\"\" return COMPLETION_MODE . inverse [ self . completionMode ()] def set_filter_mode ( self , mode : constants . FilterModeStr ): \"\"\"Set filter mode to use. Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in constants . FILTER_MODES : raise InvalidParamError ( mode , constants . FILTER_MODES ) self . setFilterMode ( constants . FILTER_MODES [ mode ]) def get_filter_mode ( self ) -> constants . FilterModeStr : \"\"\"Return current filter mode. Returns: filter mode \"\"\" return constants . FILTER_MODES . inverse [ self . filterMode ()] def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = ( QtCore . Qt . CaseSensitivity . CaseSensitive if state else QtCore . Qt . CaseSensitivity . CaseInsensitive ) self . setCaseSensitivity ( sensitivity ) def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ())","title":"Completer"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_completion_mode","text":"Return current completion mode. Returns: Type Description CompletionModeStr completion mode Source code in prettyqt/widgets/completer.py def get_completion_mode ( self ) -> CompletionModeStr : \"\"\"Return current completion mode. Returns: completion mode \"\"\" return COMPLETION_MODE . inverse [ self . completionMode ()]","title":"get_completion_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_filter_mode","text":"Return current filter mode. Returns: Type Description constants.FilterModeStr filter mode Source code in prettyqt/widgets/completer.py def get_filter_mode ( self ) -> constants . FilterModeStr : \"\"\"Return current filter mode. Returns: filter mode \"\"\" return constants . FILTER_MODES . inverse [ self . filterMode ()]","title":"get_filter_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_sort_mode","text":"Return current sort mode. Returns: Type Description SortModeStr sort mode Source code in prettyqt/widgets/completer.py def get_sort_mode ( self ) -> SortModeStr : \"\"\"Return current sort mode. Returns: sort mode \"\"\" return SORT_MODE . inverse [ self . modelSorting ()]","title":"get_sort_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.is_case_sensitive","text":"Return case sensitivity. Returns: Type Description bool case sensitivity Source code in prettyqt/widgets/completer.py def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ())","title":"is_case_sensitive()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_case_sensitive","text":"Set case sensitivity. Parameters: Name Type Description Default state bool case sensitive required Source code in prettyqt/widgets/completer.py def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = ( QtCore . Qt . CaseSensitivity . CaseSensitive if state else QtCore . Qt . CaseSensitivity . CaseInsensitive ) self . setCaseSensitivity ( sensitivity )","title":"set_case_sensitive()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_completion_mode","text":"Set completion mode to use. Parameters: Name Type Description Default mode CompletionModeStr completion mode to use required Exceptions: Type Description InvalidParamError completion mode does not exist Source code in prettyqt/widgets/completer.py def set_completion_mode ( self , mode : CompletionModeStr ): \"\"\"Set completion mode to use. Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODE : raise InvalidParamError ( mode , COMPLETION_MODE ) self . setCompletionMode ( COMPLETION_MODE [ mode ])","title":"set_completion_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_filter_mode","text":"Set filter mode to use. Parameters: Name Type Description Default mode constants.FilterModeStr filter mode to use required Exceptions: Type Description InvalidParamError filter mode does not exist Source code in prettyqt/widgets/completer.py def set_filter_mode ( self , mode : constants . FilterModeStr ): \"\"\"Set filter mode to use. Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in constants . FILTER_MODES : raise InvalidParamError ( mode , constants . FILTER_MODES ) self . setFilterMode ( constants . FILTER_MODES [ mode ])","title":"set_filter_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_sort_mode","text":"Set sort mode to use. Parameters: Name Type Description Default mode SortModeStr | None sort mode to use required Exceptions: Type Description InvalidParamError sort mode does not exist Source code in prettyqt/widgets/completer.py def set_sort_mode ( self , mode : SortModeStr | None ): \"\"\"Set sort mode to use. Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODE : raise InvalidParamError ( mode , SORT_MODE ) self . setModelSorting ( SORT_MODE [ mode ])","title":"set_sort_mode()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper","text":"","title":"datawidgetmapper"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper","text":"Source code in prettyqt/widgets/datawidgetmapper.py class DataWidgetMapper ( QtWidgets . QDataWidgetMapper ): def serialize_fields ( self ): return dict ( current_index = self . currentIndex (), orientation = self . get_orientation (), submit_policy = self . get_submit_policy (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_orientation ( state [ \"orientation\" ]) self . set_submit_policy ( state [ \"submit_policy\" ]) self . setCurrentIndex ( state [ \"current_index\" ]) def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the data widget mapper. Args: orientation: orientation for the data widget mapper Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] def set_submit_policy ( self , policy : SubmitPolicyStr ): \"\"\"Set the submit policy of the mapper. Args: policy: submit_policy for the data widget mapper Raises: InvalidParamError: submit_policy does not exist \"\"\" if policy not in SUBMIT_POLICY : raise InvalidParamError ( policy , SUBMIT_POLICY ) self . setSubmitPolicy ( SUBMIT_POLICY [ policy ]) def get_submit_policy ( self ) -> SubmitPolicyStr : \"\"\"Return current submit policy. Returns: submit policy \"\"\" return SUBMIT_POLICY . inverse [ self . submitPolicy ()] def add_mapping ( self , widget : QtWidgets . QWidget , section : int , property_name : str | None = None ): if property_name is None : self . addMapping ( widget , section ) else : ba = QtCore . QByteArray ( property_name . encode ()) self . addMapping ( widget , section , ba ) def get_mapped_property_name ( self , widget : QtWidgets . QWidget ) -> str : return bytes ( self . mappedPropertyName ( widget )) . decode ()","title":"DataWidgetMapper"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_orientation","text":"Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/datawidgetmapper.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_submit_policy","text":"Return current submit policy. Returns: Type Description SubmitPolicyStr submit policy Source code in prettyqt/widgets/datawidgetmapper.py def get_submit_policy ( self ) -> SubmitPolicyStr : \"\"\"Return current submit policy. Returns: submit policy \"\"\" return SUBMIT_POLICY . inverse [ self . submitPolicy ()]","title":"get_submit_policy()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_orientation","text":"Set the orientation of the data widget mapper. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the data widget mapper required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the data widget mapper. Args: orientation: orientation for the data widget mapper Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_submit_policy","text":"Set the submit policy of the mapper. Parameters: Name Type Description Default policy SubmitPolicyStr submit_policy for the data widget mapper required Exceptions: Type Description InvalidParamError submit_policy does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_submit_policy ( self , policy : SubmitPolicyStr ): \"\"\"Set the submit policy of the mapper. Args: policy: submit_policy for the data widget mapper Raises: InvalidParamError: submit_policy does not exist \"\"\" if policy not in SUBMIT_POLICY : raise InvalidParamError ( policy , SUBMIT_POLICY ) self . setSubmitPolicy ( SUBMIT_POLICY [ policy ])","title":"set_submit_policy()"},{"location":"api/widgets.html#prettyqt.widgets.dialog","text":"","title":"dialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.Dialog","text":"Source code in prettyqt/widgets/dialog.py class Dialog ( QtWidgets . QDialog ): def __init__ ( self , title : str = \"\" , icon : types . IconType = None , parent : QtWidgets . QWidget | None = None , delete_on_close : bool = False , layout : None | str | QtWidgets . QLayout = None , ): super () . __init__ ( parent = parent ) self . set_title ( title ) self . set_icon ( icon ) if delete_on_close : self . delete_on_close () if layout is not None : self . set_layout ( layout ) def __getitem__ ( self , index : str ) -> QtWidgets . QWidget : result = self . find_child ( QtWidgets . QWidget , index ) if result is None : raise KeyError ( \"Widget not found\" ) return result def serialize_fields ( self ): return dict ( # modal=self.isModal(), layout = self . layout (), size_grip_enabled = self . isSizeGripEnabled (), size = ( self . size () . width (), self . size () . height ()), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) if state [ \"layout\" ]: self . set_layout ( state [ \"layout\" ]) self . resize ( * state [ \"size\" ]) self . setSizeGripEnabled ( state [ \"size_grip_enabled\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e ) def delete_on_close ( self ): self . setAttribute ( QtCore . Qt . WidgetAttribute . WA_DeleteOnClose ) def add_widget ( self , widget : QtWidgets . QWidget ) -> QtWidgets . QWidget : self . box += widget return widget def add_buttonbox ( self ) -> widgets . DialogButtonBox : button_box = widgets . DialogButtonBox . create ( ok = self . accept , cancel = self . reject ) self . box . add ( button_box ) return button_box def show_blocking ( self ) -> bool : self . show () return bool ( self . main_loop ()) def is_accepted ( self ) -> bool : return self . result () == QtWidgets . QDialog . Accepted def main_loop ( self ) -> int : return self . exec_ ()","title":"Dialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.Dialog.keyPressEvent","text":"keyPressEvent(self, arg__1: PySide6.QtGui.QKeyEvent) -> None Source code in prettyqt/widgets/dialog.py def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e )","title":"keyPressEvent()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox","text":"","title":"dialogbuttonbox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox","text":"Source code in prettyqt/widgets/dialogbuttonbox.py class DialogButtonBox ( QtWidgets . QDialogButtonBox ): button_clicked = core . Signal ( str ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . clicked . connect ( self . on_click ) def __len__ ( self ) -> int : return len ( self . buttons ()) def __getitem__ ( self , index : ButtonStr ) -> QtWidgets . QPushButton : return self . button ( BUTTONS [ index ]) def __iter__ ( self ) -> Iterator [ QtWidgets . QAbstractButton ]: return iter ( self . buttons ()) def __contains__ ( self , index : ButtonStr ): return self . button ( BUTTONS [ index ]) is not None @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) # type: ignore return box def on_click ( self , button : QtCore . QObject ): self . button_clicked . emit ( button . objectName ()) def set_horizontal ( self ): self . setOrientation ( constants . HORIZONTAL ) def set_vertical ( self ): self . setOrientation ( constants . VERTICAL ) def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the button box. Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] def add_default_buttons ( self , buttons : Sequence [ ButtonStr ]): return [ self . add_default_button ( btn ) for btn in buttons ] def add_default_button ( self , button : ButtonStr , callback : Callable | None = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn def add_button ( self , button : QtWidgets . QPushButton | ButtonStr , role : RoleStr = \"accept\" , callback : Callable | None = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button","title":"DialogButtonBox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_button","text":"Add a button. Parameters: Name Type Description Default button QtWidgets.QPushButton | ButtonStr button to add required role RoleStr role of the button 'accept' callback Callable | None function to call when button gets clicked None Returns: Type Description widgets.PushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_button ( self , button : QtWidgets . QPushButton | ButtonStr , role : RoleStr = \"accept\" , callback : Callable | None = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_default_button","text":"Add a default button. Parameters: Name Type Description Default button ButtonStr button to add required callback Callable | None function to call when button gets clicked None Returns: Type Description QtWidgets.QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_default_button ( self , button : ButtonStr , callback : Callable | None = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn","title":"add_default_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.create","text":"create(self, arg__1: int = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) -> None Source code in prettyqt/widgets/dialogbuttonbox.py @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) # type: ignore return box","title":"create()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.get_orientation","text":"Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/dialogbuttonbox.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.set_orientation","text":"Set the orientation of the button box. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the button box required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the button box. Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog","text":"","title":"filedialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog","text":"Source code in prettyqt/widgets/filedialog.py class FileDialog ( QtWidgets . QFileDialog ): \"\"\"Simple dialog used to display some widget.\"\"\" def __init__ ( self , path : None | types . PathType = None , mode : AcceptModeStr = \"open\" , caption : str | None = None , path_id : str | None = None , extension_filter : dict | None = None , file_mode : FileModeStr = \"existing_files\" , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( parent = parent ) self . set_title ( caption ) self . path_id = path_id if extension_filter : self . set_extension_filter ( extension_filter ) if path_id is not None and path is None : settings = core . Settings () path = settings . get ( path_id , \"\" ) if path is not None : self . set_directory ( path ) self . set_file_mode ( file_mode ) self . set_accept_mode ( mode ) def serialize_fields ( self ): return dict ( file_mode = self . get_file_mode (), accept_mode = self . get_accept_mode (), filter = self . get_filter (), view_mode = self . get_view_mode (), name_filter = self . selectedNameFilter (), default_suffix = self . defaultSuffix (), name_filters = self . nameFilters (), supported_schemes = self . supportedSchemes (), ) def __setstate__ ( self , state ): self . set_file_mode ( state [ \"file_mode\" ]) self . set_accept_mode ( state [ \"accept_mode\" ]) self . set_view_mode ( state [ \"view_mode\" ]) self . set_filter ( * state [ \"filter\" ]) self . setNameFilters ( state [ \"name_filters\" ]) self . setNameFilter ( state [ \"name_filter\" ]) self . setDefaultSuffix ( state [ \"default_suffix\" ]) self . setSupportedSchemes ( state [ \"supported_schemes\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def set_accept_mode ( self , mode : AcceptModeStr ): \"\"\"Set accept mode. Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODE : raise InvalidParamError ( mode , ACCEPT_MODE ) self . setAcceptMode ( ACCEPT_MODE [ mode ]) def get_accept_mode ( self ) -> AcceptModeStr : \"\"\"Return accept mode. Returns: accept mode \"\"\" return ACCEPT_MODE . inverse [ self . acceptMode ()] def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] def set_label_text ( self , label : LabelStr , text : str ): \"\"\"Set the label text for button label. Args: label: button to set text for text: text to use \"\"\" if label not in LABEL : raise InvalidParamError ( label , LABEL ) self . setLabelText ( LABEL [ label ], text ) def get_label_text ( self , label : LabelStr ) -> str : \"\"\"Return label text. Returns: label text \"\"\" return self . labelText ( LABEL [ label ]) def get_file_mode ( self ) -> FileModeStr : \"\"\"Return file mode. Returns: file mode \"\"\" return FILE_MODE . inverse [ self . fileMode ()] def set_file_mode ( self , mode : FileModeStr ): \"\"\"Set the file mode of the dialog. Args: mode: mode to use \"\"\" self . setFileMode ( FILE_MODE [ mode ]) def selected_files ( self ) -> list [ pathlib . Path ]: return [ pathlib . Path ( p ) for p in self . selectedFiles ()] def selected_file ( self ) -> pathlib . Path | None : selected = self . selectedFiles () return pathlib . Path ( selected [ 0 ]) if selected else None def choose_folder ( self ) -> list [ pathlib . Path ] | None : self . set_file_mode ( \"directory\" ) return self . choose () def open_file ( self ) -> list [ pathlib . Path ] | None : self . set_file_mode ( \"existing_file\" ) return self . choose () def choose ( self ) -> list [ pathlib . Path ] | None : result = self . main_loop () if result != self . Accepted : return None paths = self . selected_files () folder_path = paths [ 0 ] . parent if self . path_id : settings = core . Settings () settings . setValue ( self . path_id , str ( folder_path )) return paths def set_extension_filter ( self , extension_dict : dict [ str , list [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str ) def get_directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( self . directory () . absolutePath ()) def set_directory ( self , path : types . PathType ): \"\"\"Set start directory.\"\"\" path = os . fspath ( path ) self . setDirectory ( path ) def set_filter ( self , * filters : core . dir . FilterStr ): for item in filters : if item not in core . dir . FILTERS : raise InvalidParamError ( item , core . dir . FILTERS ) flags = helpers . merge_flags ( filters , core . dir . FILTERS ) self . setFilter ( flags ) def get_filter ( self ) -> list [ core . dir . FilterStr ]: return [ k for k , v in core . dir . FILTERS . items () if v & self . filter ()]","title":"FileDialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_accept_mode","text":"Return accept mode. Returns: Type Description AcceptModeStr accept mode Source code in prettyqt/widgets/filedialog.py def get_accept_mode ( self ) -> AcceptModeStr : \"\"\"Return accept mode. Returns: accept mode \"\"\" return ACCEPT_MODE . inverse [ self . acceptMode ()]","title":"get_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_directory","text":"Return current directory. returns current directory level as a Pathlib object Returns: Type Description pathlib.Path Pathlib object Source code in prettyqt/widgets/filedialog.py def get_directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( self . directory () . absolutePath ())","title":"get_directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_file_mode","text":"Return file mode. Returns: Type Description FileModeStr file mode Source code in prettyqt/widgets/filedialog.py def get_file_mode ( self ) -> FileModeStr : \"\"\"Return file mode. Returns: file mode \"\"\" return FILE_MODE . inverse [ self . fileMode ()]","title":"get_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_label_text","text":"Return label text. Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py def get_label_text ( self , label : LabelStr ) -> str : \"\"\"Return label text. Returns: label text \"\"\" return self . labelText ( LABEL [ label ])","title":"get_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_view_mode","text":"Return view mode. Returns: Type Description ViewModeStr view mode Source code in prettyqt/widgets/filedialog.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_accept_mode","text":"Set accept mode. Parameters: Name Type Description Default mode AcceptModeStr accept mode to use required Exceptions: Type Description InvalidParamError invalid accept mode Source code in prettyqt/widgets/filedialog.py def set_accept_mode ( self , mode : AcceptModeStr ): \"\"\"Set accept mode. Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODE : raise InvalidParamError ( mode , ACCEPT_MODE ) self . setAcceptMode ( ACCEPT_MODE [ mode ])","title":"set_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_directory","text":"Set start directory. Source code in prettyqt/widgets/filedialog.py def set_directory ( self , path : types . PathType ): \"\"\"Set start directory.\"\"\" path = os . fspath ( path ) self . setDirectory ( path )","title":"set_directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_extension_filter","text":"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict dict[str, list[str]] filter dictionary required Source code in prettyqt/widgets/filedialog.py def set_extension_filter ( self , extension_dict : dict [ str , list [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str )","title":"set_extension_filter()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_file_mode","text":"Set the file mode of the dialog. Parameters: Name Type Description Default mode FileModeStr mode to use required Source code in prettyqt/widgets/filedialog.py def set_file_mode ( self , mode : FileModeStr ): \"\"\"Set the file mode of the dialog. Args: mode: mode to use \"\"\" self . setFileMode ( FILE_MODE [ mode ])","title":"set_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_label_text","text":"Set the label text for button label. Parameters: Name Type Description Default label LabelStr button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py def set_label_text ( self , label : LabelStr , text : str ): \"\"\"Set the label text for button label. Args: label: button to set text for text: text to use \"\"\" if label not in LABEL : raise InvalidParamError ( label , LABEL ) self . setLabelText ( LABEL [ label ], text )","title":"set_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_view_mode","text":"Set view mode. Parameters: Name Type Description Default mode ViewModeStr view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/filedialog.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel","text":"","title":"filesystemmodel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel","text":"Source code in prettyqt/widgets/filesystemmodel.py class FileSystemModel ( QtWidgets . QFileSystemModel ): \"\"\"Class to populate a filesystem treeview.\"\"\" DATA_ROLE = constants . USER_ROLE + 33 # type: ignore content_type = \"files\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setReadOnly ( False ) def data ( self , index , role = QtCore . Qt . ItemDataRole . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . Roles . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role ) def get_file_info ( self , index : QtCore . QModelIndex ) -> core . FileInfo : return core . FileInfo ( self . fileInfo ( index )) def get_file_path ( self , index : QtCore . QModelIndex ) -> pathlib . Path : return pathlib . Path ( self . filePath ( index )) def yield_child_indexes ( self , index : QtCore . QModelIndex ) -> Iterator [ QtCore . QModelIndex ]: if not self . hasChildren ( index ): return path = self . filePath ( index ) flags = self . filter () | QtCore . QDir . NoDotAndDotDot for it in core . DirIterator ( path , flags ): yield self . index ( it ) def resolve_sym_links ( self , resolve : bool ): self . setResolveSymlinks ( resolve ) def watch_for_changes ( self , watch : bool ): self . setOption ( OPTIONS [ \"dont_watch_changes\" ], not watch ) def use_custom_icons ( self , use : bool ): self . setOption ( OPTIONS [ \"no_custom_icons\" ], not use ) def set_root_path ( self , path : types . PathType ) -> QtCore . QModelIndex : path = os . fspath ( path ) if path in [ \"/\" , \"root\" ]: path = core . Dir . rootPath () elif path == \"home\" : path = core . Dir . homePath () elif path == \"temp\" : path = core . Dir . tempPath () elif path == \"current\" : path = core . Dir . currentPath () return self . setRootPath ( path ) def set_name_filters ( self , filters , hide : bool = False ): self . setNameFilters ( filters ) self . setNameFilterDisables ( not hide ) def set_filter ( self , filter_mode : core . dir . FilterStr ): if filter_mode not in core . dir . FILTERS : raise InvalidParamError ( filter_mode , core . dir . FILTERS ) self . setFilter ( core . dir . FILTERS [ filter_mode ]) def get_paths ( self , indexes : Sequence [ QtCore . QModelIndex ]) -> list [ pathlib . Path ]: paths = [ i . data ( self . DATA_ROLE ) for i in indexes ] if not paths : return [] if paths [ 0 ] == \"\" : paths = [ folder / filename for folder in paths for filename in folder . iterdir () if ( folder / filename ) . is_file () ] return paths","title":"FileSystemModel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel.data","text":"data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -> Any Source code in prettyqt/widgets/filesystemmodel.py def data ( self , index , role = QtCore . Qt . ItemDataRole . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . Roles . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role )","title":"data()"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox","text":"","title":"fontcombobox"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox","text":"Source code in prettyqt/widgets/fontcombobox.py class FontComboBox ( QtWidgets . QFontComboBox ): value_changed = core . Signal ( object ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . currentIndexChanged . connect ( self . index_changed ) def serialize_fields ( self ): return dict ( current_font = self . get_current_font (), font_filters = self . get_font_filters (), ) def __setstate__ ( self , state ): self . set_font_filters ( * state . get ( \"font_filters\" , [])) self . setCurrentFont ( state [ \"current_font\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def set_font_filters ( self , * filters : FontFilterStr ): \"\"\"Set font filters. Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags ) def get_font_filters ( self ) -> list [ FontFilterStr ]: \"\"\"Return list of font filters. Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()] def set_value ( self , value : QtGui . QFont ): self . setCurrentFont ( value ) def get_value ( self ) -> gui . Font : return self . get_current_font () def get_current_font ( self ) -> gui . Font : return gui . Font ( self . currentFont ())","title":"FontComboBox"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.get_font_filters","text":"Return list of font filters. Returns: Type Description list[FontFilterStr] font filter list Source code in prettyqt/widgets/fontcombobox.py def get_font_filters ( self ) -> list [ FontFilterStr ]: \"\"\"Return list of font filters. Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()]","title":"get_font_filters()"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.set_font_filters","text":"Set font filters. Parameters: Name Type Description Default filters FontFilterStr font filters to use () Exceptions: Type Description InvalidParamError invalid font filters Source code in prettyqt/widgets/fontcombobox.py def set_font_filters ( self , * filters : FontFilterStr ): \"\"\"Set font filters. Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags )","title":"set_font_filters()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout","text":"","title":"formlayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout","text":"Source code in prettyqt/widgets/formlayout.py class FormLayout ( QtWidgets . QFormLayout ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . set_size_mode ( \"maximum\" ) self . setVerticalSpacing ( 8 ) def __setitem__ ( self , index : int | tuple [ int , RoleStr ], value : str | QtWidgets . QWidget ): if isinstance ( index , tuple ): row = index [ 0 ] role = index [ 1 ] else : row = index role = \"both\" self . set_widget ( value , row , role ) def __delitem__ ( self , index : int ): self . removeRow ( index ) def __iter__ ( self ): return iter ( self [ i ] for i in range ( self . count ()) if self [ i ] is not None ) def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount () def __add__ ( self , other : QtWidgets . QWidget | QtWidgets . QLayout | tuple ): self . add ( other ) return self def serialize_fields ( self ): widget_list = [] positions = [] for i , item in enumerate ( list ( self )): widget_list . append ( item ) positions . append ( self . get_item_position ( i )) return dict ( widgets = widget_list , positions = positions ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __setstate__ ( self , state ): for i , ( item , pos ) in enumerate ( zip ( state [ \"widgets\" ], state [ \"positions\" ])): self . set_widget ( item , pos [ 0 ], pos [ 1 ]) def set_widget ( self , widget : str | QtWidgets . QWidget , row : int , role : RoleStr = \"both\" ): if isinstance ( widget , str ): widget = widgets . Label ( widget ) self . setWidget ( row , ROLE [ role ], widget ) def get_widget ( self , row : int , role : RoleStr = \"both\" ) -> QtWidgets . QLayout | QtWidgets . QWidget : item = self . itemAt ( row , ROLE [ role ]) widget = item . widget () if widget is None : widget = item . layout () return widget def get_item_position ( self , index : int ) -> tuple [ int , RoleStr ] | None : pos = self . getItemPosition ( index ) # type: ignore if pos [ 0 ] == - 1 : # type: ignore return None return pos [ 0 ], ROLE . inverse [ pos [ 1 ]] # type: ignore def add ( self , * items ): for i in items : if isinstance ( i , ( QtWidgets . QWidget , QtWidgets . QLayout )): self . addRow ( i ) if isinstance ( i , tuple ): self . addRow ( * i ) def set_row_wrap_policy ( self , policy : RowWrapPolicyStr ): \"\"\"Set row wrap policy to use. Args: policy: row wrap policy to use Raises: InvalidParamError: row wrap policy does not exist \"\"\" if policy not in ROW_WRAP_POLICY : raise InvalidParamError ( policy , ROW_WRAP_POLICY ) self . setRowWrapPolicy ( ROW_WRAP_POLICY [ policy ]) def get_row_wrap_policy ( self ) -> RowWrapPolicyStr : \"\"\"Return current row wrap policy. Returns: row wrap policy \"\"\" return ROW_WRAP_POLICY . inverse [ self . rowWrapPolicy ()] def set_field_growth_policy ( self , policy : FieldGrowthPolicyStr ): \"\"\"Set field growth policy to use. Args: policy: field growth policy to use Raises: InvalidParamError: field growth policy does not exist \"\"\" if policy not in FIELD_GROWTH_POLICY : raise InvalidParamError ( policy , FIELD_GROWTH_POLICY ) self . setFieldGrowthPolicy ( FIELD_GROWTH_POLICY [ policy ]) def get_field_growth_policy ( self ) -> FieldGrowthPolicyStr : \"\"\"Return current field growth policy. Returns: field growth policy \"\"\" return FIELD_GROWTH_POLICY . inverse [ self . fieldGrowthPolicy ()]","title":"FormLayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.__len__","text":"Needed for PySide2. Source code in prettyqt/widgets/formlayout.py def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_field_growth_policy","text":"Return current field growth policy. Returns: Type Description FieldGrowthPolicyStr field growth policy Source code in prettyqt/widgets/formlayout.py def get_field_growth_policy ( self ) -> FieldGrowthPolicyStr : \"\"\"Return current field growth policy. Returns: field growth policy \"\"\" return FIELD_GROWTH_POLICY . inverse [ self . fieldGrowthPolicy ()]","title":"get_field_growth_policy()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_row_wrap_policy","text":"Return current row wrap policy. Returns: Type Description RowWrapPolicyStr row wrap policy Source code in prettyqt/widgets/formlayout.py def get_row_wrap_policy ( self ) -> RowWrapPolicyStr : \"\"\"Return current row wrap policy. Returns: row wrap policy \"\"\" return ROW_WRAP_POLICY . inverse [ self . rowWrapPolicy ()]","title":"get_row_wrap_policy()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_field_growth_policy","text":"Set field growth policy to use. Parameters: Name Type Description Default policy FieldGrowthPolicyStr field growth policy to use required Exceptions: Type Description InvalidParamError field growth policy does not exist Source code in prettyqt/widgets/formlayout.py def set_field_growth_policy ( self , policy : FieldGrowthPolicyStr ): \"\"\"Set field growth policy to use. Args: policy: field growth policy to use Raises: InvalidParamError: field growth policy does not exist \"\"\" if policy not in FIELD_GROWTH_POLICY : raise InvalidParamError ( policy , FIELD_GROWTH_POLICY ) self . setFieldGrowthPolicy ( FIELD_GROWTH_POLICY [ policy ])","title":"set_field_growth_policy()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_row_wrap_policy","text":"Set row wrap policy to use. Parameters: Name Type Description Default policy RowWrapPolicyStr row wrap policy to use required Exceptions: Type Description InvalidParamError row wrap policy does not exist Source code in prettyqt/widgets/formlayout.py def set_row_wrap_policy ( self , policy : RowWrapPolicyStr ): \"\"\"Set row wrap policy to use. Args: policy: row wrap policy to use Raises: InvalidParamError: row wrap policy does not exist \"\"\" if policy not in ROW_WRAP_POLICY : raise InvalidParamError ( policy , ROW_WRAP_POLICY ) self . setRowWrapPolicy ( ROW_WRAP_POLICY [ policy ])","title":"set_row_wrap_policy()"},{"location":"api/widgets.html#prettyqt.widgets.frame","text":"","title":"frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame","text":"Source code in prettyqt/widgets/frame.py class Frame ( QtWidgets . QFrame ): def serialize_fields ( self ): return dict ( frame_shadow = self . get_frame_shadow (), frame_shape = self . get_frame_shape (), frame_rect = self . frameRect (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_frame_shadow ( state [ \"frame_shadow\" ]) self . set_frame_shape ( state [ \"frame_shape\" ]) self . setFrameRect ( state [ \"frame_rect\" ]) def set_frame_shadow ( self , style : ShadowStr ): \"\"\"Set frame shadow. Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style is None : return if style not in SHADOW : raise InvalidParamError ( style , SHADOW ) self . setFrameShadow ( SHADOW [ style ]) def get_frame_shadow ( self ) -> ShadowStr | None : \"\"\"Return current frame shadow. Returns: frame style \"\"\" if ( frame_shadow := self . frameShadow ()) == 0 : return None return SHADOW . inverse [ frame_shadow ] def set_frame_shape ( self , shape : FrameShapeStr ): \"\"\"Set frame shape. Args: shape: frame shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in FRAME_SHAPE : raise InvalidParamError ( shape , FRAME_SHAPE ) self . setFrameShape ( FRAME_SHAPE [ shape ]) def get_frame_shape ( self ) -> FrameShapeStr : \"\"\"Return current frame shape. Returns: frame shape \"\"\" return FRAME_SHAPE . inverse [ self . frameShape ()]","title":"Frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.get_frame_shadow","text":"Return current frame shadow. Returns: Type Description ShadowStr | None frame style Source code in prettyqt/widgets/frame.py def get_frame_shadow ( self ) -> ShadowStr | None : \"\"\"Return current frame shadow. Returns: frame style \"\"\" if ( frame_shadow := self . frameShadow ()) == 0 : return None return SHADOW . inverse [ frame_shadow ]","title":"get_frame_shadow()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.get_frame_shape","text":"Return current frame shape. Returns: Type Description FrameShapeStr frame shape Source code in prettyqt/widgets/frame.py def get_frame_shape ( self ) -> FrameShapeStr : \"\"\"Return current frame shape. Returns: frame shape \"\"\" return FRAME_SHAPE . inverse [ self . frameShape ()]","title":"get_frame_shape()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.set_frame_shadow","text":"Set frame shadow. Parameters: Name Type Description Default style ShadowStr frame style to use required Exceptions: Type Description InvalidParamError style does not exist Source code in prettyqt/widgets/frame.py def set_frame_shadow ( self , style : ShadowStr ): \"\"\"Set frame shadow. Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style is None : return if style not in SHADOW : raise InvalidParamError ( style , SHADOW ) self . setFrameShadow ( SHADOW [ style ])","title":"set_frame_shadow()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.set_frame_shape","text":"Set frame shape. Parameters: Name Type Description Default shape FrameShapeStr frame shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/widgets/frame.py def set_frame_shape ( self , shape : FrameShapeStr ): \"\"\"Set frame shape. Args: shape: frame shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in FRAME_SHAPE : raise InvalidParamError ( shape , FRAME_SHAPE ) self . setFrameShape ( FRAME_SHAPE [ shape ])","title":"set_frame_shape()"},{"location":"api/widgets.html#prettyqt.widgets.gesture","text":"","title":"gesture"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture","text":"Source code in prettyqt/widgets/gesture.py class Gesture ( QtWidgets . QGesture ): def get_state ( self ) -> constants . GestureStateStr : \"\"\"Return current state. Returns: state \"\"\" return constants . GESTURE_STATE . inverse [ self . state ()] def get_gesture_type ( self ) -> constants . GestureTypeStr : \"\"\"Return current gesture type. Returns: gesture type \"\"\" return constants . GESTURE_TYPE . inverse [ self . gestureType ()] def get_hot_spot ( self ) -> core . PointF : return core . PointF ( self . hotSpot ()) def set_gesture_cancel_policy ( self , policy : GestureCancelPolicyStr ): \"\"\"Set gesture cancel policy. Args: policy: gesture cancel policy to use Raises: InvalidParamError: gesture cancel policy does not exist \"\"\" if policy not in GESTURE_CANCEL_POLICY : raise InvalidParamError ( policy , GESTURE_CANCEL_POLICY ) self . setGestureCancelPolicy ( GESTURE_CANCEL_POLICY [ policy ]) def get_gesture_cancel_policy ( self ) -> GestureCancelPolicyStr : \"\"\"Return current gesture cancel policy. Returns: gesture cancel policy \"\"\" return GESTURE_CANCEL_POLICY . inverse [ self . gestureCancelPolicy ()]","title":"Gesture"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.get_gesture_cancel_policy","text":"Return current gesture cancel policy. Returns: Type Description GestureCancelPolicyStr gesture cancel policy Source code in prettyqt/widgets/gesture.py def get_gesture_cancel_policy ( self ) -> GestureCancelPolicyStr : \"\"\"Return current gesture cancel policy. Returns: gesture cancel policy \"\"\" return GESTURE_CANCEL_POLICY . inverse [ self . gestureCancelPolicy ()]","title":"get_gesture_cancel_policy()"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.get_gesture_type","text":"Return current gesture type. Returns: Type Description constants.GestureTypeStr gesture type Source code in prettyqt/widgets/gesture.py def get_gesture_type ( self ) -> constants . GestureTypeStr : \"\"\"Return current gesture type. Returns: gesture type \"\"\" return constants . GESTURE_TYPE . inverse [ self . gestureType ()]","title":"get_gesture_type()"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.get_state","text":"Return current state. Returns: Type Description constants.GestureStateStr state Source code in prettyqt/widgets/gesture.py def get_state ( self ) -> constants . GestureStateStr : \"\"\"Return current state. Returns: state \"\"\" return constants . GESTURE_STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.set_gesture_cancel_policy","text":"Set gesture cancel policy. Parameters: Name Type Description Default policy GestureCancelPolicyStr gesture cancel policy to use required Exceptions: Type Description InvalidParamError gesture cancel policy does not exist Source code in prettyqt/widgets/gesture.py def set_gesture_cancel_policy ( self , policy : GestureCancelPolicyStr ): \"\"\"Set gesture cancel policy. Args: policy: gesture cancel policy to use Raises: InvalidParamError: gesture cancel policy does not exist \"\"\" if policy not in GESTURE_CANCEL_POLICY : raise InvalidParamError ( policy , GESTURE_CANCEL_POLICY ) self . setGestureCancelPolicy ( GESTURE_CANCEL_POLICY [ policy ])","title":"set_gesture_cancel_policy()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem","text":"","title":"graphicsitem"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem","text":"Source code in prettyqt/widgets/graphicsitem.py class GraphicsItem ( QtWidgets . QGraphicsItem ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def __contains__ ( self , value : QtCore . QPointF ) -> bool : return self . contains ( value ) def __getitem__ ( self , key : int ): return self . data ( key ) def __setitem__ ( self , key : int , value ): self . setData ( key , value ) def serialize_fields ( self ): return dict ( cache_mode = self . get_cache_mode (), accept_drops = self . acceptDrops (), accept_hover_events = self . acceptHoverEvents (), accept_touch_events = self . acceptTouchEvents (), bounding_region_granularity = self . boundingRegionGranularity (), enabled = self . isEnabled (), filters_child_events = self . filtersChildEvents (), opacity = self . opacity (), panel_modality = self . get_panel_modality (), pos = self . pos (), rotation = self . rotation (), scale = self . scale (), selected = self . isSelected (), tool_tip = self . toolTip (), transform_origin_point = self . transformOriginPoint (), visible = self . isVisible (), z_value = self . zValue (), ) def set_focus ( self , reason : constants . FocusReasonStr = \"other\" ): if reason not in constants . FOCUS_REASONS : raise InvalidParamError ( reason , constants . FOCUS_REASONS ) self . setFocus ( constants . FOCUS_REASONS [ reason ]) def colliding_items ( self , mode : constants . ItemSelectionModeStr = \"intersects_shape\" ) -> list [ QtWidgets . QGraphicsItem ]: if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) return self . collidingItems ( constants . ITEM_SELECTION_MODE [ mode ]) def collides_with ( self , item : QtGui . QPainterPath | QtWidgets . QGraphicsItem , mode : constants . ItemSelectionModeStr = \"intersects_shape\" , ) -> bool : if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) if isinstance ( item , QtGui . QPainterPath ): return self . collidesWithPath ( item , constants . ITEM_SELECTION_MODE [ mode ]) else : return self . collidesWithItem ( item , constants . ITEM_SELECTION_MODE [ mode ]) def set_panel_modality ( self , modality : PanelModalityStr ) -> None : \"\"\"Set panel modality. Args: modality: panel modality Raises: InvalidParamError: panel modality does not exist \"\"\" if modality not in PANEL_MODALITY : raise InvalidParamError ( modality , PANEL_MODALITY ) self . setPanelModality ( PANEL_MODALITY [ modality ]) def get_panel_modality ( self ) -> PanelModalityStr : \"\"\"Get the current modality modes as a string. Returns: panel modality \"\"\" return PANEL_MODALITY . inverse [ self . panelModality ()] def set_cache_mode ( self , mode : CacheModeStr ) -> None : \"\"\"Set cache mode. Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODE : raise InvalidParamError ( mode , CACHE_MODE ) self . setCacheMode ( CACHE_MODE [ mode ]) def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Get the current mode modes as a string. Returns: cache mode \"\"\" return CACHE_MODE . inverse [ self . cacheMode ()] def get_shape ( self ) -> gui . PainterPath : return gui . PainterPath ( self . shape ()) def set_scale ( self , scale : tuple [ float , float ] | float ): if isinstance ( scale , float ): self . setScale ( scale ) else : self . setTransform ( gui . Transform . fromScale ( scale [ 0 ], scale [ 1 ]), True )","title":"GraphicsItem"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem.get_cache_mode","text":"Get the current mode modes as a string. Returns: Type Description CacheModeStr cache mode Source code in prettyqt/widgets/graphicsitem.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Get the current mode modes as a string. Returns: cache mode \"\"\" return CACHE_MODE . inverse [ self . cacheMode ()]","title":"get_cache_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem.get_panel_modality","text":"Get the current modality modes as a string. Returns: Type Description PanelModalityStr panel modality Source code in prettyqt/widgets/graphicsitem.py def get_panel_modality ( self ) -> PanelModalityStr : \"\"\"Get the current modality modes as a string. Returns: panel modality \"\"\" return PANEL_MODALITY . inverse [ self . panelModality ()]","title":"get_panel_modality()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem.set_cache_mode","text":"Set cache mode. Parameters: Name Type Description Default mode CacheModeStr cache mode required Exceptions: Type Description InvalidParamError cache mode does not exist Source code in prettyqt/widgets/graphicsitem.py def set_cache_mode ( self , mode : CacheModeStr ) -> None : \"\"\"Set cache mode. Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODE : raise InvalidParamError ( mode , CACHE_MODE ) self . setCacheMode ( CACHE_MODE [ mode ])","title":"set_cache_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem.set_panel_modality","text":"Set panel modality. Parameters: Name Type Description Default modality PanelModalityStr panel modality required Exceptions: Type Description InvalidParamError panel modality does not exist Source code in prettyqt/widgets/graphicsitem.py def set_panel_modality ( self , modality : PanelModalityStr ) -> None : \"\"\"Set panel modality. Args: modality: panel modality Raises: InvalidParamError: panel modality does not exist \"\"\" if modality not in PANEL_MODALITY : raise InvalidParamError ( modality , PANEL_MODALITY ) self . setPanelModality ( PANEL_MODALITY [ modality ])","title":"set_panel_modality()"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem","text":"","title":"graphicspixmapitem"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem","text":"Source code in prettyqt/widgets/graphicspixmapitem.py class GraphicsPixmapItem ( QtWidgets . QGraphicsPixmapItem ): def serialize_fields ( self ): return dict ( offset = self . offset (), pixmap = self . get_pixmap (), shape_mode = self . get_shape_mode (), transformation_mode = self . get_transformation_mode (), ) def set_transformation_mode ( self , mode : constants . TransformationModeStr ): \"\"\"Set transformation mode. Args: mode: transformation mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in constants . TRANSFORMATION_MODE : raise InvalidParamError ( mode , constants . TRANSFORMATION_MODE ) self . setTransformationMode ( constants . TRANSFORMATION_MODE [ mode ]) def get_transformation_mode ( self ) -> constants . TransformationModeStr : \"\"\"Return current transformation mode. Returns: transformation mode \"\"\" return constants . TRANSFORMATION_MODE . inverse [ self . transformationMode ()] def set_shape_mode ( self , mode : ShapeModeStr ): \"\"\"Set shape mode. Args: mode: shape mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in SHAPE_MODE : raise InvalidParamError ( mode , SHAPE_MODE ) self . setShapeMode ( SHAPE_MODE [ mode ]) def get_shape_mode ( self ) -> ShapeModeStr : \"\"\"Return current shape mode. Returns: shape mode \"\"\" return SHAPE_MODE . inverse [ self . shapeMode ()] def get_pixmap ( self ) -> gui . Pixmap | None : pix = self . pixmap () if pix . isNull (): return None return gui . Pixmap ( pix )","title":"GraphicsPixmapItem"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.get_shape_mode","text":"Return current shape mode. Returns: Type Description ShapeModeStr shape mode Source code in prettyqt/widgets/graphicspixmapitem.py def get_shape_mode ( self ) -> ShapeModeStr : \"\"\"Return current shape mode. Returns: shape mode \"\"\" return SHAPE_MODE . inverse [ self . shapeMode ()]","title":"get_shape_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.get_transformation_mode","text":"Return current transformation mode. Returns: Type Description constants.TransformationModeStr transformation mode Source code in prettyqt/widgets/graphicspixmapitem.py def get_transformation_mode ( self ) -> constants . TransformationModeStr : \"\"\"Return current transformation mode. Returns: transformation mode \"\"\" return constants . TRANSFORMATION_MODE . inverse [ self . transformationMode ()]","title":"get_transformation_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.set_shape_mode","text":"Set shape mode. Parameters: Name Type Description Default mode ShapeModeStr shape mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicspixmapitem.py def set_shape_mode ( self , mode : ShapeModeStr ): \"\"\"Set shape mode. Args: mode: shape mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in SHAPE_MODE : raise InvalidParamError ( mode , SHAPE_MODE ) self . setShapeMode ( SHAPE_MODE [ mode ])","title":"set_shape_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.set_transformation_mode","text":"Set transformation mode. Parameters: Name Type Description Default mode constants.TransformationModeStr transformation mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicspixmapitem.py def set_transformation_mode ( self , mode : constants . TransformationModeStr ): \"\"\"Set transformation mode. Args: mode: transformation mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in constants . TRANSFORMATION_MODE : raise InvalidParamError ( mode , constants . TRANSFORMATION_MODE ) self . setTransformationMode ( constants . TRANSFORMATION_MODE [ mode ])","title":"set_transformation_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene","text":"","title":"graphicsscene"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene","text":"Source code in prettyqt/widgets/graphicsscene.py class GraphicsScene ( QtWidgets . QGraphicsScene ): def serialize_fields ( self ): return dict ( items = self . items (), background_brush = self . get_background_brush (), foreground_brush = self . get_foreground_brush (), item_index_method = self . get_item_index_method (), minimum_render_size = self . minimumRenderSize (), palette = self . get_palette (), bsp_tree_depth = self . bspTreeDepth (), focus_on_touch = self . focusOnTouch (), sticky_focus = self . stickyFocus (), scene_rect = core . RectF ( self . sceneRect ()), font = self . get_font (), ) def __setitem__ ( self , state ): # self.setItem self . setBackgroundBrush ( state [ \"background_brush\" ]) self . setForegroundBrush ( state [ \"foreground_brush\" ]) self . set_item_index_method ( state [ \"item_index_method\" ]) self . setMinimumRenderSize ( state [ \"minimum_render_size\" ]) self . setPalette ( state [ \"palette\" ]) self . setBspTreeDepth ( state [ \"bsp_tree_depth\" ]) self . setFocusOnTouchRelease ( state [ \"focus_on_touch\" ]) self . setStickyFocus ( state [ \"focus_on_touch\" ]) self . setSceneRect ( state [ \"scene_rect\" ]) self . setFont ( state [ \"font\" ]) def __getitem__ ( self , index : int ) -> QtWidgets . QGraphicsItem : return self . items ()[ index ] def get_palette ( self ) -> gui . Palette : return gui . Palette ( self . palette ()) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_background_brush ( self ) -> gui . Brush : return gui . Brush ( self . backgroundBrush ()) def get_foreground_brush ( self ) -> gui . Brush : return gui . Brush ( self . foregroundBrush ()) def add ( self , item ) -> QtWidgets . QGraphicsItem : if isinstance ( item , QtWidgets . QGraphicsItem ): self . addItem ( item ) return item elif isinstance ( item , QtGui . QPixmap ): return self . add_pixmap ( item ) elif isinstance ( item , QtGui . QPainterPath ): return self . add_path ( item ) elif isinstance ( item , QtGui . QPolygonF ): return self . add_polygon ( item ) elif isinstance ( item , QtCore . QRectF ): return self . add_rect ( item ) elif isinstance ( item , QtCore . QLine ): return self . add_line ( item ) elif isinstance ( item , str ): return self . add_text ( item ) elif isinstance ( item , QtWidgets . QWidget ): return self . add_widget ( item ) else : raise TypeError ( item ) def add_pixmap ( self , pixmap : QtGui . QPixmap ) -> widgets . GraphicsPixmapItem : g_item = widgets . GraphicsPixmapItem () g_item . setPixmap ( pixmap ) self . addItem ( g_item ) return g_item def add_polygon ( self , polygon : QtGui . QPolygonF | QtGui . QPolygon , pen : QtGui . QPen | None = None , brush : QtGui . QBrush | None = None , ) -> widgets . GraphicsPolygonItem : if isinstance ( polygon , QtGui . QPolygon ): polygon = gui . PolygonF ( polygon ) g_item = widgets . GraphicsPolygonItem () g_item . setPolygon ( polygon ) if brush is not None : g_item . setBrush ( brush ) if pen is not None : g_item . setPen ( pen ) self . addItem ( g_item ) return g_item def add_path ( self , path : QtGui . QPainterPath , pen : QtGui . QPen | None = None , brush : QtGui . QBrush | None = None , ) -> widgets . GraphicsPathItem : g_item = widgets . GraphicsPathItem () g_item . setPath ( path ) if brush is not None : g_item . setBrush ( brush ) if pen is not None : g_item . setPen ( pen ) self . addItem ( g_item ) return g_item def add_rect ( self , rect : types . RectType | types . RectFType , pen : QtGui . QPen | None = None , brush : QtGui . QBrush | None = None , ) -> widgets . GraphicsRectItem : if isinstance ( rect , QtCore . QRect ): rect = core . RectF ( rect ) elif isinstance ( rect , tuple ): rect = core . RectF ( * rect ) g_item = widgets . GraphicsRectItem () g_item . setRect ( rect ) if brush is not None : g_item . setBrush ( brush ) if pen is not None : g_item . setPen ( pen ) self . addItem ( g_item ) return g_item def add_line ( self , line : QtCore . QLineF | QtCore . QLine | tuple [ float , float , float , float ], pen : QtGui . QPen | None = None , ) -> widgets . GraphicsLineItem : if isinstance ( line , QtCore . QLine ): line = core . LineF ( line ) elif isinstance ( line , tuple ): line = core . LineF ( * line ) g_item = widgets . GraphicsLineItem () g_item . setLine ( line ) if pen is not None : g_item . setPen ( pen ) self . addItem ( g_item ) return g_item def add_ellipse ( self , ellipse : types . RectType | types . RectFType , pen : QtGui . QPen | None = None , brush : QtGui . QBrush | None = None , ) -> widgets . GraphicsEllipseItem : if isinstance ( ellipse , QtCore . QRect ): ellipse = core . RectF ( ellipse ) elif isinstance ( ellipse , tuple ): ellipse = core . RectF ( * ellipse ) g_item = widgets . GraphicsEllipseItem () g_item . setRect ( ellipse ) if brush is not None : g_item . setBrush ( brush ) if pen is not None : g_item . setPen ( pen ) self . addItem ( g_item ) return g_item def add_text ( self , text : str , font : QtGui . QFont | None = None ) -> widgets . GraphicsTextItem : g_item = widgets . GraphicsTextItem () g_item . setPlainText ( text ) if font is not None : g_item . setFont ( font ) self . addItem ( g_item ) return g_item def add_simple_text ( self , text : str , font : QtGui . QFont | None = None ) -> widgets . GraphicsSimpleTextItem : g_item = widgets . GraphicsSimpleTextItem () g_item . setText ( text ) if font is not None : g_item . setFont ( font ) self . addItem ( g_item ) return g_item def add_widget ( self , widget : QtWidgets . QWidget ) -> widgets . GraphicsProxyWidget : g_item = widgets . GraphicsProxyWidget () g_item . setWidget ( widget ) self . addItem ( g_item ) return g_item def colliding_items ( self , item : QtWidgets . QGraphicsItem , mode : constants . ItemSelectionModeStr = \"intersects_shape\" , ) -> list [ QtWidgets . QGraphicsItem ]: if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) return self . collidingItems ( item , constants . ITEM_SELECTION_MODE [ mode ]) def add_item_group ( self , * items : QtWidgets . QGraphicsItem ) -> widgets . GraphicsItemGroup : group = widgets . GraphicsItemGroup () for item in items : group . addToGroup ( item ) return group def set_item_index_method ( self , method : ItemIndexMethodStr ): \"\"\"Set item index method. Args: method: item index method to use Raises: InvalidParamError: invalid item index method \"\"\" if method not in ITEM_INDEX_METHOD : raise InvalidParamError ( method , ITEM_INDEX_METHOD ) self . setItemIndexMethod ( ITEM_INDEX_METHOD [ method ]) def get_item_index_method ( self ) -> ItemIndexMethodStr : \"\"\"Return item index method. Returns: item index method \"\"\" return ITEM_INDEX_METHOD . inverse [ self . itemIndexMethod ()]","title":"GraphicsScene"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.get_item_index_method","text":"Return item index method. Returns: Type Description ItemIndexMethodStr item index method Source code in prettyqt/widgets/graphicsscene.py def get_item_index_method ( self ) -> ItemIndexMethodStr : \"\"\"Return item index method. Returns: item index method \"\"\" return ITEM_INDEX_METHOD . inverse [ self . itemIndexMethod ()]","title":"get_item_index_method()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.set_item_index_method","text":"Set item index method. Parameters: Name Type Description Default method ItemIndexMethodStr item index method to use required Exceptions: Type Description InvalidParamError invalid item index method Source code in prettyqt/widgets/graphicsscene.py def set_item_index_method ( self , method : ItemIndexMethodStr ): \"\"\"Set item index method. Args: method: item index method to use Raises: InvalidParamError: invalid item index method \"\"\" if method not in ITEM_INDEX_METHOD : raise InvalidParamError ( method , ITEM_INDEX_METHOD ) self . setItemIndexMethod ( ITEM_INDEX_METHOD [ method ])","title":"set_item_index_method()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview","text":"","title":"graphicsview"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView","text":"Source code in prettyqt/widgets/graphicsview.py class GraphicsView ( QtWidgets . QGraphicsView ): def serialize_fields ( self ): return dict ( scene = self . scene (), background_brush = self . get_background_brush (), foreground_brush = self . get_foreground_brush (), transformation_anchor = self . get_transformation_anchor (), resize_anchor = self . get_resize_anchor (), viewport_update_mode = self . get_viewport_update_mode (), drag_mode = self . get_drag_mode (), rubberband_selection_mode = self . get_rubberband_selection_mode (), scene_rect = core . RectF ( self . sceneRect ()), cache_mode = self . get_cache_mode (), is_interactive = self . isInteractive (), ) def __setitem__ ( self , state ): super () . __setstate__ ( state ) self . setScene ( state [ \"scene\" ]) self . setBackgroundBrush ( state [ \"background_brush\" ]) self . setForegroundBrush ( state [ \"foreground_brush\" ]) self . set_transformation_anchor ( state [ \"transformation_anchor\" ]) self . set_resize_anchor ( state [ \"resicze_anchor\" ]) self . set_viewport_update_mode ( state [ \"viewport_update_mode\" ]) self . set_drag_mode ( state [ \"drag_mode\" ]) self . set_rubberband_selection_mode ( state [ \"rubberband_selection_mode\" ]) self . setSceneRect ( state [ \"scene_rect\" ]) self . set_cache_mode ( state [ \"cache_mode\" ]) self . setInteractive ( state [ \"is_interactive\" ]) def __getitem__ ( self , index : int ) -> QtWidgets . QGraphicsItem : return self . items ()[ index ] def get_background_brush ( self ) -> gui . Brush : return gui . Brush ( self . backgroundBrush ()) def get_foreground_brush ( self ) -> gui . Brush : return gui . Brush ( self . foregroundBrush ()) def invalidate_scene ( self , rect : QtCore . QRectF , layer : widgets . graphicsscene . SceneLayerStr = \"all\" ): if layer not in widgets . graphicsscene . SCENE_LAYER : raise InvalidParamError ( layer , widgets . graphicsscene . SCENE_LAYER ) self . invalidateScene ( rect , widgets . graphicsscene . SCENE_LAYER [ layer ]) def set_transformation_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during transformations. Args: mode: transformation anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setTransformationAnchor ( VIEWPORT_ANCHOR [ mode ]) def get_transformation_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current transformation anchor. Returns: viewport anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . transformationAnchor ()] def set_resize_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during resizes. Args: mode: resize anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setResizeAnchor ( VIEWPORT_ANCHOR [ mode ]) def get_resize_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current resize anchor. Returns: resize anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . resizeAnchor ()] def set_viewport_update_mode ( self , mode : ViewportUpdateModeStr ): \"\"\"Set how the viewport should update its contents. Args: mode: viewport update mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_UPDATE_MODE : raise InvalidParamError ( mode , VIEWPORT_UPDATE_MODE ) self . setViewportUpdateMode ( VIEWPORT_UPDATE_MODE [ mode ]) def get_viewport_update_mode ( self ) -> ViewportUpdateModeStr : \"\"\"Return current viewport update mode. Returns: viewport update mode \"\"\" return VIEWPORT_UPDATE_MODE . inverse [ self . viewportUpdateMode ()] def set_drag_mode ( self , mode : DragModeStr ): \"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed. Args: mode: drag mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_MODE : raise InvalidParamError ( mode , DRAG_MODE ) self . setDragMode ( DRAG_MODE [ mode ]) def get_drag_mode ( self ) -> DragModeStr : \"\"\"Return current drag mode. Returns: drag mode \"\"\" return DRAG_MODE . inverse [ self . dragMode ()] def set_rubberband_selection_mode ( self , mode : constants . ItemSelectionModeStr ): \"\"\"Set the behavior for selecting items with a rubber band selection rectangle. Args: mode: rubberband selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) self . setRubberBandSelectionMode ( constants . ITEM_SELECTION_MODE [ mode ]) def get_rubberband_selection_mode ( self ) -> constants . ItemSelectionModeStr : \"\"\"Return current rubberband selection mode. Returns: rubberband selection mode \"\"\" return constants . ITEM_SELECTION_MODE . inverse [ self . rubberBandSelectionMode ()] def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set the cache mode. Args: mode: cache mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ]) def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Return current cache mode. Returns: cache mode \"\"\" return CACHE_MODES . inverse [ self . cacheMode ()] def set_optimization_flags ( self , * items : OptimizationFlagStr ): for item in items : if item not in OPTIMIZATION_FLAGS : raise InvalidParamError ( item , OPTIMIZATION_FLAGS ) flags = helpers . merge_flags ( items , OPTIMIZATION_FLAGS ) self . setOptimizationFlags ( flags ) def get_optimization_flags ( self ) -> list [ OptimizationFlagStr ]: return [ k for k , v in OPTIMIZATION_FLAGS . items () if v & self . optimizationFlags ()]","title":"GraphicsView"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_cache_mode","text":"Return current cache mode. Returns: Type Description CacheModeStr cache mode Source code in prettyqt/widgets/graphicsview.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Return current cache mode. Returns: cache mode \"\"\" return CACHE_MODES . inverse [ self . cacheMode ()]","title":"get_cache_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_drag_mode","text":"Return current drag mode. Returns: Type Description DragModeStr drag mode Source code in prettyqt/widgets/graphicsview.py def get_drag_mode ( self ) -> DragModeStr : \"\"\"Return current drag mode. Returns: drag mode \"\"\" return DRAG_MODE . inverse [ self . dragMode ()]","title":"get_drag_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_resize_anchor","text":"Return current resize anchor. Returns: Type Description ViewportAnchorStr resize anchor Source code in prettyqt/widgets/graphicsview.py def get_resize_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current resize anchor. Returns: resize anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . resizeAnchor ()]","title":"get_resize_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_rubberband_selection_mode","text":"Return current rubberband selection mode. Returns: Type Description constants.ItemSelectionModeStr rubberband selection mode Source code in prettyqt/widgets/graphicsview.py def get_rubberband_selection_mode ( self ) -> constants . ItemSelectionModeStr : \"\"\"Return current rubberband selection mode. Returns: rubberband selection mode \"\"\" return constants . ITEM_SELECTION_MODE . inverse [ self . rubberBandSelectionMode ()]","title":"get_rubberband_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_transformation_anchor","text":"Return current transformation anchor. Returns: Type Description ViewportAnchorStr viewport anchor Source code in prettyqt/widgets/graphicsview.py def get_transformation_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current transformation anchor. Returns: viewport anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . transformationAnchor ()]","title":"get_transformation_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_viewport_update_mode","text":"Return current viewport update mode. Returns: Type Description ViewportUpdateModeStr viewport update mode Source code in prettyqt/widgets/graphicsview.py def get_viewport_update_mode ( self ) -> ViewportUpdateModeStr : \"\"\"Return current viewport update mode. Returns: viewport update mode \"\"\" return VIEWPORT_UPDATE_MODE . inverse [ self . viewportUpdateMode ()]","title":"get_viewport_update_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_cache_mode","text":"Set the cache mode. Parameters: Name Type Description Default mode CacheModeStr cache mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set the cache mode. Args: mode: cache mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ])","title":"set_cache_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_drag_mode","text":"Set the behavior for dragging the mouse while the left mouse button is pressed. Parameters: Name Type Description Default mode DragModeStr drag mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_drag_mode ( self , mode : DragModeStr ): \"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed. Args: mode: drag mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_MODE : raise InvalidParamError ( mode , DRAG_MODE ) self . setDragMode ( DRAG_MODE [ mode ])","title":"set_drag_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_resize_anchor","text":"Set how the view should position the scene during resizes. Parameters: Name Type Description Default mode ViewportAnchorStr resize anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_resize_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during resizes. Args: mode: resize anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setResizeAnchor ( VIEWPORT_ANCHOR [ mode ])","title":"set_resize_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_rubberband_selection_mode","text":"Set the behavior for selecting items with a rubber band selection rectangle. Parameters: Name Type Description Default mode constants.ItemSelectionModeStr rubberband selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_rubberband_selection_mode ( self , mode : constants . ItemSelectionModeStr ): \"\"\"Set the behavior for selecting items with a rubber band selection rectangle. Args: mode: rubberband selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) self . setRubberBandSelectionMode ( constants . ITEM_SELECTION_MODE [ mode ])","title":"set_rubberband_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_transformation_anchor","text":"Set how the view should position the scene during transformations. Parameters: Name Type Description Default mode ViewportAnchorStr transformation anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_transformation_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during transformations. Args: mode: transformation anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setTransformationAnchor ( VIEWPORT_ANCHOR [ mode ])","title":"set_transformation_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_viewport_update_mode","text":"Set how the viewport should update its contents. Parameters: Name Type Description Default mode ViewportUpdateModeStr viewport update mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_viewport_update_mode ( self , mode : ViewportUpdateModeStr ): \"\"\"Set how the viewport should update its contents. Args: mode: viewport update mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_UPDATE_MODE : raise InvalidParamError ( mode , VIEWPORT_UPDATE_MODE ) self . setViewportUpdateMode ( VIEWPORT_UPDATE_MODE [ mode ])","title":"set_viewport_update_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget","text":"","title":"graphicswidget"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget","text":"Source code in prettyqt/widgets/graphicswidget.py class GraphicsWidget ( QtWidgets . QGraphicsWidget ): def serialize_fields ( self ): return dict ( autofill_background = self . autoFillBackground (), font = self . get_font (), window_title = self . windowTitle (), preferred_size = self . preferredSize (), maximum_size = self . maximumSize (), palette = self . get_palette (), focus_policy = self . get_focus_policy (), ) def set_layout ( self , layout : LayoutStr | QtWidgets . QGraphicsLayout | None ): if layout is None : return if isinstance ( layout , QtWidgets . QGraphicsLayout ): self . box = layout elif layout == \"grid\" : self . box = widgets . GraphicsGridLayout () elif layout == \"anchor\" : self . box = widgets . GraphicsAnchorLayout () elif layout in ( \"horizontal\" , \"vertical\" ): self . box = widgets . GraphicsLinearLayout ( layout ) else : raise ValueError ( \"Invalid Layout\" ) self . setLayout ( self . box ) def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy: Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ]) def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return way the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()] def window_frame_section_at ( self , point : types . PointType ) -> constants . WindowFrameSectionStr : \"\"\"Return the window frame section at given position. Returns: str: Window frame section \"\"\" if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) return constants . WINDOW_FRAME_SECTION . inverse [ self . windowFrameSectionAt ( point )] def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_palette ( self ) -> gui . Palette : return gui . Palette ( self . palette ())","title":"GraphicsWidget"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget.get_focus_policy","text":"Return way the widget accepts keyboard focus. Returns: Type Description str Focus policy Source code in prettyqt/widgets/graphicswidget.py def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return way the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()]","title":"get_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget.set_focus_policy","text":"Set the way the widget accepts keyboard focus. Parameters: Name Type Description Default policy constants.FocusPolicyStr Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/graphicswidget.py def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy: Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ])","title":"set_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget.window_frame_section_at","text":"Return the window frame section at given position. Returns: Type Description str Window frame section Source code in prettyqt/widgets/graphicswidget.py def window_frame_section_at ( self , point : types . PointType ) -> constants . WindowFrameSectionStr : \"\"\"Return the window frame section at given position. Returns: str: Window frame section \"\"\" if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) return constants . WINDOW_FRAME_SECTION . inverse [ self . windowFrameSectionAt ( point )]","title":"window_frame_section_at()"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout","text":"","title":"gridlayout"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout","text":"Source code in prettyqt/widgets/gridlayout.py class GridLayout ( QtWidgets . QGridLayout ): def __getitem__ ( self , idx : tuple [ int , int ] | int | str ) -> QtWidgets . QWidget | QtWidgets . QLayout | None : if isinstance ( idx , tuple ): item = self . itemAtPosition ( * idx ) elif isinstance ( idx , int ): item = self . itemAt ( idx ) else : return self . find_child ( QtCore . QObject , idx ) widget = item . widget () if widget is None : return item . layout () return widget def __setitem__ ( self , idx : tuple [ int | slice , int | slice ], value : QtWidgets . QWidget | QtWidgets . QLayout | QtWidgets . QLayoutItem , ): row , col = idx rowspan = row . stop - row . start + 1 if isinstance ( row , slice ) else 1 colspan = col . stop - col . start + 1 if isinstance ( col , slice ) else 1 rowstart = row . start if isinstance ( row , slice ) else row colstart = col . start if isinstance ( col , slice ) else col self . add ( value , rowstart , colstart , rowspan , colspan ) def serialize_fields ( self ): widgets = [] positions = [] for i , item in enumerate ( list ( self )): widgets . append ( item ) positions . append ( self . getItemPosition ( i )) return dict ( widgets = widgets , positions = positions ) def __setstate__ ( self , state ): for i , ( item , pos ) in enumerate ( zip ( state [ \"widgets\" ], state [ \"positions\" ])): x , y , w , h = pos self [ x : x + w - 1 , y : y + h - 1 ] = item def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __iter__ ( self ) -> Iterator [ QtWidgets . QWidget | QtWidgets . QLayout ]: return iter ( item for i in range ( self . count ()) if ( item := self [ i ]) is not None ) def __add__ ( self , other : ( tuple | list | QtWidgets . QWidget | QtWidgets . QLayout | QtWidgets . QLayoutItem ), ): if isinstance ( other , ( tuple , list )): for i , control in enumerate ( other ): self [ self . rowCount (), i ] = other # type: ignore else : self [ self . rowCount (), 0 : self . columnCount () - 1 ] = other return self def add ( self , item : QtWidgets . QWidget | QtWidgets . QLayout | QtWidgets . QLayoutItem , rowstart : int , colstart : int , rowspan : int = 1 , colspan : int = 1 , ): if isinstance ( item , QtWidgets . QWidget ): self . addWidget ( item , rowstart , colstart , rowspan , colspan ) elif isinstance ( item , QtWidgets . QLayout ): self . addLayout ( item , rowstart , colstart , rowspan , colspan ) else : self . addItem ( item , rowstart , colstart , rowspan , colspan ) def append ( self , item : QtWidgets . QWidget | QtWidgets . QLayout | QtWidgets . QLayoutItem ): self [ self . rowCount (), 0 : self . columnCount () - 1 ] = item def set_origin_corner ( self , corner : constants . CornerStr ): \"\"\"Set the origin corner. Args: corner: origin corner Raises: InvalidParamError: corner does not exist \"\"\" if corner not in constants . CORNER : raise InvalidParamError ( corner , constants . CORNER ) self . setOriginCorner ( constants . CORNER [ corner ]) def get_origin_corner ( self ) -> constants . CornerStr : \"\"\"Return current origin corner. Returns: origin corner \"\"\" return constants . CORNER . inverse [ self . originCorner ()]","title":"GridLayout"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.get_origin_corner","text":"Return current origin corner. Returns: Type Description constants.CornerStr origin corner Source code in prettyqt/widgets/gridlayout.py def get_origin_corner ( self ) -> constants . CornerStr : \"\"\"Return current origin corner. Returns: origin corner \"\"\" return constants . CORNER . inverse [ self . originCorner ()]","title":"get_origin_corner()"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.set_origin_corner","text":"Set the origin corner. Parameters: Name Type Description Default corner constants.CornerStr origin corner required Exceptions: Type Description InvalidParamError corner does not exist Source code in prettyqt/widgets/gridlayout.py def set_origin_corner ( self , corner : constants . CornerStr ): \"\"\"Set the origin corner. Args: corner: origin corner Raises: InvalidParamError: corner does not exist \"\"\" if corner not in constants . CORNER : raise InvalidParamError ( corner , constants . CORNER ) self . setOriginCorner ( constants . CORNER [ corner ])","title":"set_origin_corner()"},{"location":"api/widgets.html#prettyqt.widgets.headerview","text":"","title":"headerview"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView","text":"Source code in prettyqt/widgets/headerview.py class HeaderView ( QtWidgets . QHeaderView ): section_vis_changed = core . Signal ( int , bool ) section_resized_by_user = core . Signal ( int , int , int ) def __init__ ( self , orientation : constants . OrientationStr | QtCore . Qt . Orientation , parent : QtWidgets . QWidget | None = None , ): if isinstance ( orientation , QtCore . Qt . Orientation ): ori = orientation else : ori = constants . ORIENTATION [ orientation ] super () . __init__ ( ori , parent = parent ) self . setSectionsMovable ( True ) self . setSectionsClickable ( True ) self . sectionResized . connect ( self . sectionResizeEvent ) self . _handle_section_is_pressed = False self . _widget_name = parent . get_id () if parent is not None else \"\" def mousePressEvent ( self , e ): super () . mousePressEvent ( e ) self . _handle_section_is_pressed = self . cursor () . shape () == QtCore . Qt . SplitHCursor def mouseReleaseEvent ( self , e ): super () . mouseReleaseEvent ( e ) self . _handle_section_is_pressed = False def sectionResizeEvent ( self , logical_index , old_size , new_size ): if self . _handle_section_is_pressed : self . section_resized_by_user . emit ( logical_index , old_size , new_size ) def generate_header_id ( self ): # return f\"{self._widget_name}.state\" column_names = \",\" . join ( self . get_section_labels ()) columns_hash = hashlib . md5 ( column_names . encode ()) . hexdigest () return f \" { type ( self ) . __name__ } _ { columns_hash } .state\" def save_state ( self , settings : core . Settings | None = None , key : str | None = None ): settings = core . Settings () if settings is None else settings key = self . generate_header_id () if key is None else key settings . set_value ( key , self . saveState ()) def load_state ( self , settings : core . Settings | None = None , key : str | None = None ) -> bool : settings = core . Settings () if settings is None else settings key = self . generate_header_id () if key is None else key state = settings . get ( key , None ) if state is not None : if isinstance ( state , str ): state = state . encode () self . restoreState ( state ) return True return False def resize_sections ( self , mode : ModeStr ): self . resizeSections ( MODES [ mode ]) @deprecated ( reason = \"This method is deprecated, use set_resize_mode instead.\" ) def resize_mode ( self , mode : ModeStr , col : int | None = None ): self . set_resize_mode ( mode , col ) def set_resize_mode ( self , mode : ModeStr , col : int | None = None ): if mode not in MODES : raise InvalidParamError ( mode , MODES ) if col is None : self . setSectionResizeMode ( MODES [ mode ]) else : self . setSectionResizeMode ( col , MODES [ mode ]) def get_section_labels ( self ) -> list [ str ]: model = self . model () return [ model . headerData ( i , constants . HORIZONTAL , constants . DISPLAY_ROLE # type: ignore ) for i in range ( self . count ()) ] def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) actions = self . get_header_actions () menu . add_actions ( actions ) menu . exec_ ( self . mapToGlobal ( event . position ())) def get_header_actions ( self ) -> list [ widgets . Action ]: actions = list () labels = self . get_section_labels ()[ 1 :] for i , header_label in enumerate ( labels , start = 1 ): val = not self . isSectionHidden ( i ) action = widgets . Action ( text = header_label , checkable = True , checked = val ) fn = functools . partial ( self . set_section_hidden , i = i , hide = val ) action . triggered . connect ( fn ) actions . append ( action ) return actions def set_section_hidden ( self , i : int , hide : bool ): self . section_vis_changed . emit ( i , hide ) self . setSectionHidden ( i , hide ) def set_sizes ( self , sizes : Iterable [ int | None ]): for i , size in enumerate ( sizes ): if size is not None : self . resizeSection ( i , size ) def set_default_section_size ( self , size : int | None ): if size is None : self . resetDefaultSectionSize () else : self . setDefaultSectionSize ( size ) def stretch_last_section ( self , stretch : bool = True ): self . setStretchLastSection ( stretch )","title":"HeaderView"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView.contextMenuEvent","text":"Context menu for our files tree. Source code in prettyqt/widgets/headerview.py def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) actions = self . get_header_actions () menu . add_actions ( actions ) menu . exec_ ( self . mapToGlobal ( event . position ()))","title":"contextMenuEvent()"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView.mousePressEvent","text":"mousePressEvent(self, e: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/widgets/headerview.py def mousePressEvent ( self , e ): super () . mousePressEvent ( e ) self . _handle_section_is_pressed = self . cursor () . shape () == QtCore . Qt . SplitHCursor","title":"mousePressEvent()"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView.mouseReleaseEvent","text":"mouseReleaseEvent(self, e: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/widgets/headerview.py def mouseReleaseEvent ( self , e ): super () . mouseReleaseEvent ( e ) self . _handle_section_is_pressed = False","title":"mouseReleaseEvent()"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog","text":"","title":"inputdialog"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog","text":"Source code in prettyqt/widgets/inputdialog.py class InputDialog ( QtWidgets . QInputDialog ): @classmethod def get_int ( cls , title : str = \"\" , label : str = \"\" , icon : types . IconType = None , ) -> int | None : par = widgets . Dialog () par . set_icon ( icon ) v = cls . getInt ( par , title , label , value = 0 ) return v [ 0 ] if v [ 1 ] else None @classmethod def get_float ( cls , title : str = \"\" , label : str = \"\" , icon : types . IconType = None , ) -> float | None : par = widgets . Dialog () par . set_icon ( icon ) v = cls . getDouble ( par , title , label , value = 0.0 ) return v [ 0 ] if v [ 1 ] else None @classmethod def get_text ( cls , title : str = \"\" , label : str = \"\" , icon : types . IconType = None , default_value : str = \"\" , echo_mode : widgets . lineedit . EchoModeStr = \"normal\" , ) -> str | None : par = widgets . Dialog () par . set_icon ( icon ) if echo_mode not in widgets . lineedit . ECHO_MODE : raise InvalidParamError ( echo_mode , widgets . lineedit . ECHO_MODE ) v = cls . getText ( par , title , label , widgets . lineedit . ECHO_MODE [ echo_mode ], default_value ) return v [ 0 ] if v [ 1 ] else None @classmethod def get_item ( cls , items : list [ str ], title : str = \"\" , label : str = \"\" , icon : types . IconType = None , editable : bool = False , ) -> str | None : par = widgets . Dialog () par . set_icon ( icon ) v = cls . getItem ( par , title , label , items , editable = editable , current = 0 ) return v [ 0 ] if v [ 1 ] else None def set_text_echo_mode ( self , mode : widgets . lineedit . EchoModeStr ): \"\"\"Set text echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in widgets . lineedit . ECHO_MODE : raise InvalidParamError ( mode , widgets . lineedit . ECHO_MODE ) self . setTextEchoMode ( widgets . lineedit . ECHO_MODE [ mode ]) def get_text_echo_mode ( self ) -> widgets . lineedit . EchoModeStr : \"\"\"Return text echo mode. Returns: echo mode \"\"\" return widgets . lineedit . ECHO_MODE . inverse [ self . textEchoMode ()] def set_input_mode ( self , mode : InputModeStr ): \"\"\"Set input mode. Args: mode: input mode to use Raises: InvalidParamError: invalid input mode \"\"\" if mode not in INPUT_MODE : raise InvalidParamError ( mode , INPUT_MODE ) self . setInputMode ( INPUT_MODE [ mode ]) def get_input_mode ( self ) -> InputModeStr : \"\"\"Return input mode. Returns: input mode \"\"\" return INPUT_MODE . inverse [ self . inputMode ()]","title":"InputDialog"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.get_input_mode","text":"Return input mode. Returns: Type Description InputModeStr input mode Source code in prettyqt/widgets/inputdialog.py def get_input_mode ( self ) -> InputModeStr : \"\"\"Return input mode. Returns: input mode \"\"\" return INPUT_MODE . inverse [ self . inputMode ()]","title":"get_input_mode()"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.get_text_echo_mode","text":"Return text echo mode. Returns: Type Description widgets.lineedit.EchoModeStr echo mode Source code in prettyqt/widgets/inputdialog.py def get_text_echo_mode ( self ) -> widgets . lineedit . EchoModeStr : \"\"\"Return text echo mode. Returns: echo mode \"\"\" return widgets . lineedit . ECHO_MODE . inverse [ self . textEchoMode ()]","title":"get_text_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.set_input_mode","text":"Set input mode. Parameters: Name Type Description Default mode InputModeStr input mode to use required Exceptions: Type Description InvalidParamError invalid input mode Source code in prettyqt/widgets/inputdialog.py def set_input_mode ( self , mode : InputModeStr ): \"\"\"Set input mode. Args: mode: input mode to use Raises: InvalidParamError: invalid input mode \"\"\" if mode not in INPUT_MODE : raise InvalidParamError ( mode , INPUT_MODE ) self . setInputMode ( INPUT_MODE [ mode ])","title":"set_input_mode()"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.set_text_echo_mode","text":"Set text echo mode. Parameters: Name Type Description Default mode widgets.lineedit.EchoModeStr echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/inputdialog.py def set_text_echo_mode ( self , mode : widgets . lineedit . EchoModeStr ): \"\"\"Set text echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in widgets . lineedit . ECHO_MODE : raise InvalidParamError ( mode , widgets . lineedit . ECHO_MODE ) self . setTextEchoMode ( widgets . lineedit . ECHO_MODE [ mode ])","title":"set_text_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.label","text":"","title":"label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label","text":"Source code in prettyqt/widgets/label.py class Label ( QtWidgets . QLabel ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . openExternalLinks () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . text () !r} )\" def serialize_fields ( self ): pixmap = gui . Pixmap ( self . pixmap ()) return dict ( text = self . text (), scaled_contents = self . hasScaledContents (), indent = self . indent (), margin = self . margin (), text_format = self . get_text_format (), pixmap = pixmap if pixmap else None , open_external_links = self . openExternalLinks (), has_selected_text = self . hasSelectedText (), selected_text = self . selectedText (), alignment = ( self . get_horizontal_alignment (), self . get_vertical_alignment ()), word_wrap = self . wordWrap (), text_interaction_flags = self . get_text_interaction (), ) def __setstate__ ( self , state ): self . setText ( state . get ( \"text\" , \"\" )) self . setIndent ( state . get ( \"indent\" , - 1 )) self . setMargin ( state . get ( \"margin\" , 0 )) self . setWordWrap ( state . get ( \"word_wrap\" , 0 )) self . set_text_format ( state . get ( \"text_format\" , 0 )) # self.setPixmap(state.get(\"pixmap\")) self . setOpenExternalLinks ( state . get ( \"open_external_links\" , False )) self . set_alignment ( * state . get ( \"alignment\" )) self . setScaledContents ( state [ \"scaled_contents\" ]) self . setWordWrap ( state [ \"word_wrap\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def allow_links ( self ) -> Label : # self.setText(\"<a href=\\\"http://example.com/\\\">Click Here!</a>\") self . setTextFormat ( QtCore . Qt . TextFormat . RichText ) self . setTextInteractionFlags ( QtCore . Qt . TextInteractionFlag . TextBrowserInteraction # type: ignore ) self . setOpenExternalLinks ( True ) return self def set_alignment ( self , horizontal : constants . HorizontalAlignmentStr | None = None , vertical : constants . VerticalAlignmentStr | None = None , ): \"\"\"Set the alignment of the label's contents.\"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setAlignment ( flag ) return self def get_horizontal_alignment ( self ) -> constants . HorizontalAlignmentStr : align = self . alignment () if align & constants . ALIGN_RIGHT : # type: ignore return \"right\" elif align & constants . ALIGN_H_CENTER : # type: ignore return \"center\" elif align & constants . ALIGN_JUSTIFY : # type: ignore return \"justify\" else : return \"left\" def get_vertical_alignment ( self ) -> constants . VerticalAlignmentStr : align = self . alignment () if align & constants . ALIGN_TOP : # type: ignore return \"top\" elif align & constants . ALIGN_BOTTOM : # type: ignore return \"bottom\" elif align & constants . ALIGN_BASELINE : # type: ignore return \"baseline\" else : return \"center\" def set_indent ( self , indent : int ) -> Label : \"\"\"Set the label's text indent in pixels.\"\"\" self . setIndent ( indent ) return self def set_text_format ( self , text_format : TextFormatStr ) -> Label : \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) return self def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] def set_text_interaction ( self , * types : TextInteractionStr ) -> Label : \"\"\"Set the text interaction mode. Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self def get_text_interaction ( self ) -> list [ TextInteractionStr ]: \"\"\"Return current text interaction mode. Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()] def set_text ( self , text : str ) -> Label : \"\"\"Set the label's text.\"\"\" self . setText ( text ) return self def set_bold ( self , bold : bool = True ) -> Label : font = self . font () font . setBold ( bold ) self . setFont ( font ) return self def set_italic ( self , italic : bool = True ) -> Label : font = self . font () font . setItalic ( italic ) self . setFont ( font ) return self def set_point_size ( self , size : int ) -> Label : font = self . font () font . setPointSize ( size ) self . setFont ( font ) return self def set_weight ( self , weight : gui . font . WeightStr ) -> Label : \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) font = self . font () font . setWeight ( gui . font . WEIGHT [ weight ]) self . setFont ( font ) return self def set_color ( self , color : types . ColorType ) -> Label : with self . edit_stylesheet () as ss : if color is None : ss . color . setValue ( \"\" ) else : color = colors . get_color ( color ) ss . color . setValue ( color . name ()) return self def set_image ( self , path : types . PathType , width : int = 300 ) -> Label : self . setScaledContents ( True ) self . set_alignment ( horizontal = \"center\" ) self . setText ( \"<html><head/><body><p>\" f \"<img src= { os . fspath ( path ) !r} width= { str ( width ) !r} />\" \"</p></body></html>\" ) return self @classmethod def image_from_path ( cls , path : types . PathType , parent : QtWidgets . QWidget | None = None ) -> Label : pixmap = gui . Pixmap . from_file ( path ) label = cls ( parent = parent ) label . setPixmap ( pixmap ) label . resize ( pixmap . width (), pixmap . height ()) return label","title":"Label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_format","text":"Return current text format. Returns: Type Description TextFormatStr text format Source code in prettyqt/widgets/label.py def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_interaction","text":"Return current text interaction mode. Returns: Type Description list[TextInteractionStr] list of text interaction modes Source code in prettyqt/widgets/label.py def get_text_interaction ( self ) -> list [ TextInteractionStr ]: \"\"\"Return current text interaction mode. Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()]","title":"get_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_alignment","text":"Set the alignment of the label's contents. Source code in prettyqt/widgets/label.py def set_alignment ( self , horizontal : constants . HorizontalAlignmentStr | None = None , vertical : constants . VerticalAlignmentStr | None = None , ): \"\"\"Set the alignment of the label's contents.\"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setAlignment ( flag ) return self","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_indent","text":"Set the label's text indent in pixels. Source code in prettyqt/widgets/label.py def set_indent ( self , indent : int ) -> Label : \"\"\"Set the label's text indent in pixels.\"\"\" self . setIndent ( indent ) return self","title":"set_indent()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text","text":"Set the label's text. Source code in prettyqt/widgets/label.py def set_text ( self , text : str ) -> Label : \"\"\"Set the label's text.\"\"\" self . setText ( text ) return self","title":"set_text()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_format","text":"Set the text format. Parameters: Name Type Description Default text_format TextFormatStr text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/label.py def set_text_format ( self , text_format : TextFormatStr ) -> Label : \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) return self","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_interaction","text":"Set the text interaction mode. Parameters: Name Type Description Default types TextInteractionStr text interaction mode to use () Exceptions: Type Description InvalidParamError text interaction mode does not exist Source code in prettyqt/widgets/label.py def set_text_interaction ( self , * types : TextInteractionStr ) -> Label : \"\"\"Set the text interaction mode. Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self","title":"set_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_weight","text":"Set the font weight. Parameters: Name Type Description Default weight gui.font.WeightStr font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/widgets/label.py def set_weight ( self , weight : gui . font . WeightStr ) -> Label : \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) font = self . font () font . setWeight ( gui . font . WEIGHT [ weight ]) self . setFont ( font ) return self","title":"set_weight()"},{"location":"api/widgets.html#prettyqt.widgets.layout","text":"","title":"layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout","text":"Source code in prettyqt/widgets/layout.py class Layout ( QtWidgets . QLayout ): def __getitem__ ( self , index : str | int ) -> QtWidgets . QWidget | QtWidgets . QLayout | None : if isinstance ( index , int ): item = self . itemAt ( index ) widget = item . widget () if widget is None : widget = item . layout () elif isinstance ( index , str ): return self . find_child ( typ = QtCore . QObject , name = index ) return widget def __delitem__ ( self , index : int ): item = self . itemAt ( index ) self . removeItem ( item ) def __len__ ( self ) -> int : return self . count () def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def __iter__ ( self ): return iter ( self [ i ] for i in range ( self . count ())) def __contains__ ( self , item : QtWidgets . QWidget | QtWidgets . QLayoutItem ): return self . indexOf ( item ) >= 0 def serialize_fields ( self ): return dict ( size_mode = self . get_size_mode (), spacing = self . spacing (), enabled = self . isEnabled (), ) def get_children ( self ) -> list [ QtWidgets . QWidget | QtWidgets . QLayout ]: return list ( self ) def set_margin ( self , margin : int ): self . setContentsMargins ( margin , margin , margin , margin ) def set_spacing ( self , pixels : int ): self . setSpacing ( pixels ) def set_size_mode ( self , mode : SizeConstraintStr ): \"\"\"Set the size mode of the layout. Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in SIZE_CONSTRAINT : raise InvalidParamError ( mode , SIZE_CONSTRAINT ) self . setSizeConstraint ( SIZE_CONSTRAINT [ mode ]) def get_size_mode ( self ) -> SizeConstraintStr : \"\"\"Return current size mode. Returns: size mode \"\"\" return SIZE_CONSTRAINT . inverse [ self . sizeConstraint ()] def set_alignment ( self , alignment : constants . AlignmentStr , item : QtWidgets . QWidget | QtWidgets . QLayout | None = None , ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) if item is not None : return self . setAlignment ( item , constants . ALIGNMENTS [ alignment ]) else : return self . setAlignment ( constants . ALIGNMENTS [ alignment ]) def add ( self , * item : QtWidgets . QWidget | QtWidgets . QLayout ): for i in item : if isinstance ( i , QtWidgets . QWidget ): self . addWidget ( i ) elif isinstance ( i , QtWidgets . QLayout ): w = widgets . Widget () w . set_layout ( i ) self . addWidget ( w ) else : raise TypeError ( \"add_item only supports widgets and layouts\" )","title":"Layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.get_size_mode","text":"Return current size mode. Returns: Type Description SizeConstraintStr size mode Source code in prettyqt/widgets/layout.py def get_size_mode ( self ) -> SizeConstraintStr : \"\"\"Return current size mode. Returns: size mode \"\"\" return SIZE_CONSTRAINT . inverse [ self . sizeConstraint ()]","title":"get_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_alignment","text":"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Parameters: Name Type Description Default alignment constants.AlignmentStr alignment for the layout required item QtWidgets.QWidget | QtWidgets.QLayout | None set alignment for specific child only None Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layout.py def set_alignment ( self , alignment : constants . AlignmentStr , item : QtWidgets . QWidget | QtWidgets . QLayout | None = None , ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) if item is not None : return self . setAlignment ( item , constants . ALIGNMENTS [ alignment ]) else : return self . setAlignment ( constants . ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_size_mode","text":"Set the size mode of the layout. Parameters: Name Type Description Default mode SizeConstraintStr size mode for the layout required Exceptions: Type Description InvalidParamError size mode does not exist Source code in prettyqt/widgets/layout.py def set_size_mode ( self , mode : SizeConstraintStr ): \"\"\"Set the size mode of the layout. Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in SIZE_CONSTRAINT : raise InvalidParamError ( mode , SIZE_CONSTRAINT ) self . setSizeConstraint ( SIZE_CONSTRAINT [ mode ])","title":"set_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.layoutitem","text":"","title":"layoutitem"},{"location":"api/widgets.html#prettyqt.widgets.layoutitem.LayoutItem","text":"Source code in prettyqt/widgets/layoutitem.py class LayoutItem ( QtWidgets . QLayoutItem ): # def __bool__(self): # return not self.isEmpty() def set_alignment ( self , alignment : constants . AlignmentStr ): \"\"\"Set the alignment of the layout. Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) self . setAlignment ( constants . ALIGNMENTS [ alignment ]) def get_alignment ( self ) -> constants . AlignmentStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . ALIGNMENTS . inverse [ self . alignment ()] def get_item ( self , ) -> QtWidgets . QWidget | QtWidgets . QLayout | QtWidgets . QSpacerItem | None : if content := self . widget (): return content if content := self . layout (): return content if content := self . spacerItem (): return content return None","title":"LayoutItem"},{"location":"api/widgets.html#prettyqt.widgets.layoutitem.LayoutItem.get_alignment","text":"Return current alignment. Returns: Type Description constants.AlignmentStr alignment Source code in prettyqt/widgets/layoutitem.py def get_alignment ( self ) -> constants . AlignmentStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . ALIGNMENTS . inverse [ self . alignment ()]","title":"get_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.layoutitem.LayoutItem.set_alignment","text":"Set the alignment of the layout. Parameters: Name Type Description Default alignment constants.AlignmentStr alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layoutitem.py def set_alignment ( self , alignment : constants . AlignmentStr ): \"\"\"Set the alignment of the layout. Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) self . setAlignment ( constants . ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber","text":"","title":"lcdnumber"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber","text":"Source code in prettyqt/widgets/lcdnumber.py class LCDNumber ( QtWidgets . QLCDNumber ): def serialize_fields ( self ): return dict ( mode = self . get_mode (), segment_style = self . get_segment_style (), value = self . get_value (), ) def __setstate__ ( self , state ): self . set_mode ( state [ \"mode\" ]) self . set_segment_style ( state [ \"segment_style\" ]) self . set_value ( state [ \"value\" ]) def set_mode ( self , mode : ModeStr ): \"\"\"Set the lcd mode. Args: mode: lcd mode to use Raises: InvalidParamError: lcd mode does not exist \"\"\" if mode not in MODE : raise InvalidParamError ( mode , MODE ) self . setMode ( MODE [ mode ]) def get_mode ( self ) -> ModeStr : \"\"\"Return current lcd mode. Returns: lcd mode \"\"\" return MODE . inverse [ self . mode ()] def set_segment_style ( self , mode : SegmentStyleStr ): \"\"\"Set the segment style. Args: mode: segment style to use Raises: InvalidParamError: segment style does not exist \"\"\" if mode not in SEGMENT_STYLE : raise InvalidParamError ( mode , SEGMENT_STYLE ) self . setSegmentStyle ( SEGMENT_STYLE [ mode ]) def get_segment_style ( self ) -> SegmentStyleStr : \"\"\"Return current segment style. Returns: segment style \"\"\" return SEGMENT_STYLE . inverse [ self . segmentStyle ()] def set_value ( self , value : float | str ): self . display ( value ) def get_value ( self ) -> float : return self . value ()","title":"LCDNumber"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_mode","text":"Return current lcd mode. Returns: Type Description ModeStr lcd mode Source code in prettyqt/widgets/lcdnumber.py def get_mode ( self ) -> ModeStr : \"\"\"Return current lcd mode. Returns: lcd mode \"\"\" return MODE . inverse [ self . mode ()]","title":"get_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_segment_style","text":"Return current segment style. Returns: Type Description SegmentStyleStr segment style Source code in prettyqt/widgets/lcdnumber.py def get_segment_style ( self ) -> SegmentStyleStr : \"\"\"Return current segment style. Returns: segment style \"\"\" return SEGMENT_STYLE . inverse [ self . segmentStyle ()]","title":"get_segment_style()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_mode","text":"Set the lcd mode. Parameters: Name Type Description Default mode ModeStr lcd mode to use required Exceptions: Type Description InvalidParamError lcd mode does not exist Source code in prettyqt/widgets/lcdnumber.py def set_mode ( self , mode : ModeStr ): \"\"\"Set the lcd mode. Args: mode: lcd mode to use Raises: InvalidParamError: lcd mode does not exist \"\"\" if mode not in MODE : raise InvalidParamError ( mode , MODE ) self . setMode ( MODE [ mode ])","title":"set_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_segment_style","text":"Set the segment style. Parameters: Name Type Description Default mode SegmentStyleStr segment style to use required Exceptions: Type Description InvalidParamError segment style does not exist Source code in prettyqt/widgets/lcdnumber.py def set_segment_style ( self , mode : SegmentStyleStr ): \"\"\"Set the segment style. Args: mode: segment style to use Raises: InvalidParamError: segment style does not exist \"\"\" if mode not in SEGMENT_STYLE : raise InvalidParamError ( mode , SEGMENT_STYLE ) self . setSegmentStyle ( SEGMENT_STYLE [ mode ])","title":"set_segment_style()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit","text":"","title":"lineedit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit","text":"Source code in prettyqt/widgets/lineedit.py class LineEdit ( QtWidgets . QLineEdit ): focusLost = core . Signal () enterPressed = core . Signal () editComplete = core . Signal ( str ) value_changed = core . Signal ( str ) def __init__ ( self , default_value : str = \"\" , read_only : bool = False , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( default_value , parent ) self . textChanged . connect ( self . _set_validation_color ) self . textChanged . connect ( self . value_changed ) self . set_read_only ( read_only ) def __repr__ ( self ): return f \" { type ( self ) . __name__ } : { self . serialize_fields () } \" def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_text ( state [ \"text\" ]) self . setValidator ( state [ \"validator\" ]) self . setInputMask ( state [ \"input_mask\" ]) self . setMaxLength ( state [ \"max_length\" ]) self . setPlaceholderText ( state [ \"placeholder_text\" ]) self . setReadOnly ( state [ \"read_only\" ]) self . setFrame ( state [ \"has_frame\" ]) self . setClearButtonEnabled ( state [ \"clear_button_enabled\" ]) # self.setAlignment(state[\"alignment\"]) self . set_cursor_move_style ( state [ \"cursor_move_style\" ]) self . set_echo_mode ( state [ \"echo_mode\" ]) self . setCursorPosition ( state [ \"cursor_position\" ]) self . setDragEnabled ( state [ \"drag_enabled\" ]) self . setModified ( state [ \"is_modified\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __add__ ( self , other : str ): self . append_text ( other ) return self def serialize_fields ( self ): return dict ( text = self . text (), # alignment=self.alignment(), validator = self . validator (), max_length = self . maxLength (), read_only = self . isReadOnly (), input_mask = self . inputMask (), has_frame = self . hasFrame (), placeholder_text = self . placeholderText (), clear_button_enabled = self . isClearButtonEnabled (), cursor_move_style = self . get_cursor_move_style (), echo_mode = self . get_echo_mode (), cursor_position = self . cursorPosition (), drag_enabled = self . dragEnabled (), is_modified = self . isModified (), ) def focusOutEvent ( self , event ): self . focusLost . emit () return super () . focusOutEvent ( event ) def keyPressEvent ( self , event ): if event . key () in [ QtCore . Qt . Key . Key_Enter , QtCore . Qt . Key . Key_Return ]: self . enterPressed . emit () return super () . keyPressEvent ( event ) def _on_edit_complete ( self ): self . editComplete . emit ( self . text ()) def font ( self ) -> gui . Font : return gui . Font ( super () . font ()) def append_text ( self , text : str ): self . set_text ( self . text () + text ) def set_text ( self , text : str ): self . setText ( text ) def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) def set_regex_validator ( self , regex : str , flags = 0 ) -> gui . RegularExpressionValidator : validator = gui . RegularExpressionValidator ( self ) validator . set_regex ( regex , flags ) self . set_validator ( validator ) return validator def set_range ( self , lower : int | None , upper : int | None ): val = gui . IntValidator () val . set_range ( lower , upper ) self . set_validator ( val ) def set_validator ( self , validator : gui . Validator ): self . setValidator ( validator ) self . _set_validation_color () def set_input_mask ( self , mask : str ): self . setInputMask ( mask ) def _set_validation_color ( self , state : bool = True ): color = \"orange\" if not self . is_valid () else None self . set_background_color ( color ) def set_echo_mode ( self , mode : EchoModeStr ): \"\"\"Set echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODE : raise InvalidParamError ( mode , ECHO_MODE ) self . setEchoMode ( ECHO_MODE [ mode ]) def get_echo_mode ( self ) -> EchoModeStr : \"\"\"Return echo mode. Returns: echo mode \"\"\" return ECHO_MODE . inverse [ self . echoMode ()] def set_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set cursor move style. Args: style: cursor move style to use Raises: InvalidParamError: invalid cursor move style \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ]) def get_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . cursorMoveStyle ()] def add_action ( self , action : QtWidgets . QAction , position : ActionPositionStr = \"trailing\" ): self . addAction ( action , ACTION_POSITION [ position ]) def set_value ( self , value : str ): self . setText ( value ) def get_value ( self ) -> str : return self . text () def is_valid ( self ) -> bool : return self . hasAcceptableInput ()","title":"LineEdit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.focusOutEvent","text":"focusOutEvent(self, arg__1: PySide6.QtGui.QFocusEvent) -> None Source code in prettyqt/widgets/lineedit.py def focusOutEvent ( self , event ): self . focusLost . emit () return super () . focusOutEvent ( event )","title":"focusOutEvent()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.font","text":"font(self) -> PySide6.QtGui.QFont Source code in prettyqt/widgets/lineedit.py def font ( self ) -> gui . Font : return gui . Font ( super () . font ())","title":"font()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_cursor_move_style","text":"Return cursor move style. Returns: Type Description constants.CursorMoveStyleStr cursor move style Source code in prettyqt/widgets/lineedit.py def get_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . cursorMoveStyle ()]","title":"get_cursor_move_style()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_echo_mode","text":"Return echo mode. Returns: Type Description EchoModeStr echo mode Source code in prettyqt/widgets/lineedit.py def get_echo_mode ( self ) -> EchoModeStr : \"\"\"Return echo mode. Returns: echo mode \"\"\" return ECHO_MODE . inverse [ self . echoMode ()]","title":"get_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.keyPressEvent","text":"keyPressEvent(self, arg__1: PySide6.QtGui.QKeyEvent) -> None Source code in prettyqt/widgets/lineedit.py def keyPressEvent ( self , event ): if event . key () in [ QtCore . Qt . Key . Key_Enter , QtCore . Qt . Key . Key_Return ]: self . enterPressed . emit () return super () . keyPressEvent ( event )","title":"keyPressEvent()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_cursor_move_style","text":"Set cursor move style. Parameters: Name Type Description Default style constants.CursorMoveStyleStr cursor move style to use required Exceptions: Type Description InvalidParamError invalid cursor move style Source code in prettyqt/widgets/lineedit.py def set_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set cursor move style. Args: style: cursor move style to use Raises: InvalidParamError: invalid cursor move style \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ])","title":"set_cursor_move_style()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_echo_mode","text":"Set echo mode. Parameters: Name Type Description Default mode EchoModeStr echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/lineedit.py def set_echo_mode ( self , mode : EchoModeStr ): \"\"\"Set echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODE : raise InvalidParamError ( mode , ECHO_MODE ) self . setEchoMode ( ECHO_MODE [ mode ])","title":"set_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_read_only","text":"Set text to read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.listview","text":"","title":"listview"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView","text":"Source code in prettyqt/widgets/listview.py class ListView ( QtWidgets . QListView ): def serialize_fields ( self ): return dict ( view_mode = self . get_view_mode (), resize_mode = self . get_resize_mode (), layout_mode = self . get_layout_mode (), movement = self . get_movement (), batch_size = self . batchSize (), flow = self . get_flow (), grid_size = self . get_grid_size (), is_wrapping = self . isWrapping (), # item_alignment=self.itemAlignment(), model_column = self . modelColumn (), selection_rect_visible = self . isSelectionRectVisible (), spacing = self . spacing (), uniform_item_sizes = self . uniformItemSizes (), word_wrap = self . wordWrap (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_view_mode ( state [ \"view_mode\" ]) self . set_resize_mode ( state [ \"resize_mode\" ]) self . set_layout_mode ( state [ \"layout_mode\" ]) self . set_movement ( state [ \"movement\" ]) self . setBatchSize ( state [ \"batch_size\" ]) self . set_flow ( state [ \"flow\" ]) self . set_grid_size ( state [ \"grid_size\" ]) self . setWrapping ( state [ \"is_wrapping\" ]) # self.setItemAlignment(state[\"flow\"]) self . setModelColumn ( state [ \"model_column\" ]) self . setSelectionRectVisible ( state [ \"selection_rect_visible\" ]) self . setSpacing ( state [ \"spacing\" ]) self . setUniformItemSizes ( state [ \"uniform_item_sizes\" ]) self . setWordWrap ( state [ \"word_wrap\" ]) def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] def set_resize_mode ( self , mode : ResizeModeStr ): \"\"\"Set resize mode. Args: mode: resize mode to use Raises: InvalidParamError: invalid resize mode \"\"\" if mode not in RESIZE_MODE : raise InvalidParamError ( mode , RESIZE_MODE ) self . setResizeMode ( RESIZE_MODE [ mode ]) def get_resize_mode ( self ) -> ResizeModeStr : \"\"\"Return resize mode. Returns: resize mode \"\"\" return RESIZE_MODE . inverse [ self . resizeMode ()] def set_layout_mode ( self , mode : LayoutModeStr ): \"\"\"Set layout mode. Args: mode: layout mode to use Raises: InvalidParamError: invalid layout mode \"\"\" if mode not in LAYOUT_MODE : raise InvalidParamError ( mode , LAYOUT_MODE ) self . setLayoutMode ( LAYOUT_MODE [ mode ]) def get_layout_mode ( self ) -> LayoutModeStr : \"\"\"Return layout mode. Returns: layout mode \"\"\" return LAYOUT_MODE . inverse [ self . layoutMode ()] def set_movement ( self , mode : MovementStr ): \"\"\"Set movement mode. Args: mode: movement mode to use Raises: InvalidParamError: invalid movement mode \"\"\" if mode not in MOVEMENT : raise InvalidParamError ( mode , MOVEMENT ) self . setMovement ( MOVEMENT [ mode ]) def get_movement ( self ) -> MovementStr : \"\"\"Return movement mode. Returns: movement mode \"\"\" return MOVEMENT . inverse [ self . movement ()] def set_flow ( self , mode : FlowStr ): \"\"\"Set flow mode. Args: mode: flow mode to use Raises: InvalidParamError: invalid flow mode \"\"\" if mode not in FLOW : raise InvalidParamError ( mode , FLOW ) self . setFlow ( FLOW [ mode ]) def get_flow ( self ) -> FlowStr : \"\"\"Return flow mode. Returns: flow mode \"\"\" return FLOW . inverse [ self . flow ()] def set_grid_size ( self , size : QtCore . QSize | tuple [ int , int ]): if isinstance ( size , tuple ): size = QtCore . QSize ( * size ) self . setGridSize ( size ) def get_grid_size ( self ) -> core . Size : return core . Size ( self . gridSize ())","title":"ListView"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_flow","text":"Return flow mode. Returns: Type Description FlowStr flow mode Source code in prettyqt/widgets/listview.py def get_flow ( self ) -> FlowStr : \"\"\"Return flow mode. Returns: flow mode \"\"\" return FLOW . inverse [ self . flow ()]","title":"get_flow()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_layout_mode","text":"Return layout mode. Returns: Type Description LayoutModeStr layout mode Source code in prettyqt/widgets/listview.py def get_layout_mode ( self ) -> LayoutModeStr : \"\"\"Return layout mode. Returns: layout mode \"\"\" return LAYOUT_MODE . inverse [ self . layoutMode ()]","title":"get_layout_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_movement","text":"Return movement mode. Returns: Type Description MovementStr movement mode Source code in prettyqt/widgets/listview.py def get_movement ( self ) -> MovementStr : \"\"\"Return movement mode. Returns: movement mode \"\"\" return MOVEMENT . inverse [ self . movement ()]","title":"get_movement()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_resize_mode","text":"Return resize mode. Returns: Type Description ResizeModeStr resize mode Source code in prettyqt/widgets/listview.py def get_resize_mode ( self ) -> ResizeModeStr : \"\"\"Return resize mode. Returns: resize mode \"\"\" return RESIZE_MODE . inverse [ self . resizeMode ()]","title":"get_resize_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_view_mode","text":"Return view mode. Returns: Type Description ViewModeStr view mode Source code in prettyqt/widgets/listview.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_flow","text":"Set flow mode. Parameters: Name Type Description Default mode FlowStr flow mode to use required Exceptions: Type Description InvalidParamError invalid flow mode Source code in prettyqt/widgets/listview.py def set_flow ( self , mode : FlowStr ): \"\"\"Set flow mode. Args: mode: flow mode to use Raises: InvalidParamError: invalid flow mode \"\"\" if mode not in FLOW : raise InvalidParamError ( mode , FLOW ) self . setFlow ( FLOW [ mode ])","title":"set_flow()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_layout_mode","text":"Set layout mode. Parameters: Name Type Description Default mode LayoutModeStr layout mode to use required Exceptions: Type Description InvalidParamError invalid layout mode Source code in prettyqt/widgets/listview.py def set_layout_mode ( self , mode : LayoutModeStr ): \"\"\"Set layout mode. Args: mode: layout mode to use Raises: InvalidParamError: invalid layout mode \"\"\" if mode not in LAYOUT_MODE : raise InvalidParamError ( mode , LAYOUT_MODE ) self . setLayoutMode ( LAYOUT_MODE [ mode ])","title":"set_layout_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_movement","text":"Set movement mode. Parameters: Name Type Description Default mode MovementStr movement mode to use required Exceptions: Type Description InvalidParamError invalid movement mode Source code in prettyqt/widgets/listview.py def set_movement ( self , mode : MovementStr ): \"\"\"Set movement mode. Args: mode: movement mode to use Raises: InvalidParamError: invalid movement mode \"\"\" if mode not in MOVEMENT : raise InvalidParamError ( mode , MOVEMENT ) self . setMovement ( MOVEMENT [ mode ])","title":"set_movement()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_resize_mode","text":"Set resize mode. Parameters: Name Type Description Default mode ResizeModeStr resize mode to use required Exceptions: Type Description InvalidParamError invalid resize mode Source code in prettyqt/widgets/listview.py def set_resize_mode ( self , mode : ResizeModeStr ): \"\"\"Set resize mode. Args: mode: resize mode to use Raises: InvalidParamError: invalid resize mode \"\"\" if mode not in RESIZE_MODE : raise InvalidParamError ( mode , RESIZE_MODE ) self . setResizeMode ( RESIZE_MODE [ mode ])","title":"set_resize_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_view_mode","text":"Set view mode. Parameters: Name Type Description Default mode ViewModeStr view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/listview.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem","text":"","title":"listwidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem","text":"Source code in prettyqt/widgets/listwidgetitem.py class ListWidgetItem ( QtWidgets . QListWidgetItem ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . icon () } , { self . text () !r} )\" def __setitem__ ( self , index : int , value ): self . setData ( index , value ) def __getitem__ ( self , index : int ): return self . data ( index ) def serialize_fields ( self ): return dict ( text = self . text (), tool_tip = self . toolTip (), status_tip = self . statusTip (), checkstate = self . get_checkstate (), icon = self . get_icon (), data = self . data ( constants . USER_ROLE ), # type: ignore ) def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] def get_background ( self ) -> gui . Brush : return gui . Brush ( self . background ()) def get_foreground ( self ) -> gui . Brush : return gui . Brush ( self . foreground ()) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_data ( self , role : str , data ): role_id = constants . ITEM_DATA_ROLE [ role ] self . setData ( role_id , data ) def set_size_hint ( self , hint : types . SizeType ): if isinstance ( hint , tuple ): hint = QtCore . QSize ( * hint ) self . setSizeHint ( hint )","title":"ListWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.get_checkstate","text":"Return checkstate. Returns: Type Description constants.StateStr checkstate Source code in prettyqt/widgets/listwidgetitem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/listwidgetitem.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow","text":"","title":"mainwindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow","text":"Source code in prettyqt/widgets/mainwindow.py class MainWindow ( QtWidgets . QMainWindow ): \"\"\"Class for our mainWindow. Includes all docks, a centralwidget and a toolbar \"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setMenuBar ( widgets . MenuBar ()) self . setDockOptions ( self . DockOption . AllowTabbedDocks # type: ignore | self . DockOption . AllowNestedDocks | self . DockOption . GroupedDragging | self . DockOption . AnimatedDocks ) def __getitem__ ( self , index : str ) -> QtWidgets . QWidget : result = self . find_child ( QtWidgets . QWidget , index ) if result is None : raise KeyError ( \"Widget not found\" ) return result def serialize_fields ( self ): return dict ( central_widget = self . centralWidget (), is_maximized = self . isMaximized (), ) def __setstate__ ( self , state ): if state [ \"central_widget\" ]: self . setCentralWidget ( state [ \"central_widget\" ]) if state [ \"is_maximized\" ]: self . showMaximized () self . box = self . layout () def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def set_widget ( self , widget : QtWidgets . QWidget | None ): if widget is None : self . takeCentralWidget () else : self . setCentralWidget ( widget ) def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add ( action ) return menu def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBar ( constants . TOOLBAR_AREA [ position ], toolbar ) def add_toolbar_break ( self , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBarBreak ( constants . TOOLBAR_AREA [ position ]) def load_window_state ( self , recursive : bool = False ) -> bool : settings = core . Settings () name = self . get_id () geom = settings . get ( f \" { name } .geometry\" ) state = settings . get ( f \" { name } .state\" ) restored = False if geom is not None and state is not None : try : logger . debug ( f \"Loading window state for { self . windowTitle () !r} ...\" ) self . restoreGeometry ( geom ) if isinstance ( state , str ): state = state . encode () self . restoreState ( state ) restored = True except TypeError : logger . error ( \"Wrong type for window state. Probably Qt binding switch?\" ) if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . load_window_state () return restored def save_window_state ( self , recursive : bool = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { self . windowTitle () !r} ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state () def add_widget_as_dock ( self , name : str , title : str , vertical : bool = True , position : constants . DockPositionStr = \"left\" , ) -> widgets . DockWidget : dock_widget = widgets . DockWidget ( self , name = name , title = title ) widget = widgets . Widget () widget . set_id ( f \" { name } .widget\" ) layout = widgets . BoxLayout ( \"vertical\" if vertical else \"horizontal\" , widget , margin = 0 ) dock_widget . setWidget ( widget ) self . add_dockwidget ( dock_widget , position ) dock_widget . box = layout return dock_widget def add_dockwidget ( self , dockwidget : QtWidgets . QDockWidget , position : constants . DockPositionStr = \"left\" , ): self . addDockWidget ( constants . DOCK_POSITION [ position ], dockwidget ) def remove_dockwidgets ( self , dockwidgets : Sequence [ QtWidgets . QDockWidget ]): for i in dockwidgets : self . removeDockWidget ( i ) def show_blocking ( self ): self . set_modality ( \"application\" ) self . show () def get_docks ( self ) -> list [ QtWidgets . QDockWidget ]: return self . find_children ( QtWidgets . QDockWidget , recursive = False ) def get_toolbars ( self ) -> list [ QtWidgets . QToolBar ]: return self . find_children ( QtWidgets . QToolBar , recursive = False ) def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen ()","title":"MainWindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar","text":"Adds a toolbar to the mainmenu at specified area. Parameters: Name Type Description Default toolbar QtWidgets.QToolBar toolbar to use required position constants.ToolbarAreaStr position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBar ( constants . TOOLBAR_AREA [ position ], toolbar )","title":"add_toolbar()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar_break","text":"Adds a toolbar break to the given area behind the last item. Parameters: Name Type Description Default position constants.ToolbarAreaStr position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar_break ( self , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBarBreak ( constants . TOOLBAR_AREA [ position ])","title":"add_toolbar_break()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.createPopupMenu","text":"createPopupMenu(self) -> PySide6.QtWidgets.QMenu Source code in prettyqt/widgets/mainwindow.py def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add ( action ) return menu","title":"createPopupMenu()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.save_window_state","text":"Save current window state as QSetting. Parameters: Name Type Description Default recursive bool Description False Source code in prettyqt/widgets/mainwindow.py def save_window_state ( self , recursive : bool = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { self . windowTitle () !r} ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state ()","title":"save_window_state()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.toggle_fullscreen","text":"Toggle between fullscreen and regular size. Source code in prettyqt/widgets/mainwindow.py def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen ()","title":"toggle_fullscreen()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea","text":"","title":"mdiarea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea","text":"Source code in prettyqt/widgets/mdiarea.py class MdiArea ( QtWidgets . QMdiArea ): def __add__ ( self , other : QtWidgets . QWidget ): self . add ( other ) return self def serialize_fields ( self ): return dict ( view_mode = self . get_view_mode (), window_order = self . get_window_order (), tab_position = self . get_tab_position (), background = self . get_background (), document_mode = self . documentMode (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_view_mode ( state [ \"view_mode\" ]) self . set_window_order ( state [ \"window_order\" ]) self . set_tab_position ( state [ \"tab_position\" ]) self . set_background ( state [ \"background\" ]) self . setDocumentMode ( state [ \"document_mode\" ]) def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode for the MDI area. Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return current view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] def set_window_order ( self , mode : WindowOrderStr ): \"\"\"Set the window order behaviour for the MDI area. Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDER : raise InvalidParamError ( mode , WINDOW_ORDER ) self . setActivationOrder ( WINDOW_ORDER [ mode ]) def get_window_order ( self ) -> WindowOrderStr : \"\"\"Return current window order. Returns: view mode \"\"\" return WINDOW_ORDER . inverse [ self . activationOrder ()] def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the MDI area. Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ]) def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return current tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()] def set_background ( self , brush_or_color : types . ColorAndBrushType , pattern : constants . PatternStr = \"solid\" , ): if isinstance ( brush_or_color , QtGui . QBrush ): brush = brush_or_color else : color = colors . get_color ( brush_or_color ) brush = gui . Brush ( color , constants . PATTERN [ pattern ]) self . setBackground ( brush ) def get_background ( self ) -> gui . Brush : return gui . Brush ( self . background ()) def add ( self , * item : QtWidgets . QWidget ): for i in item : if not isinstance ( i , QtWidgets . QMdiSubWindow ): widget = widgets . MdiSubWindow () widget . setWidget ( i ) self . addSubWindow ( widget ) else : self . addSubWindow ( i )","title":"MdiArea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_tab_position","text":"Return current tab position. Returns: Type Description TabPositionStr tab position Source code in prettyqt/widgets/mdiarea.py def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return current tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()]","title":"get_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_view_mode","text":"Return current view mode. Returns: Type Description ViewModeStr view mode Source code in prettyqt/widgets/mdiarea.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return current view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_window_order","text":"Return current window order. Returns: Type Description WindowOrderStr view mode Source code in prettyqt/widgets/mdiarea.py def get_window_order ( self ) -> WindowOrderStr : \"\"\"Return current window order. Returns: view mode \"\"\" return WINDOW_ORDER . inverse [ self . activationOrder ()]","title":"get_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_tab_position","text":"Set tab position for the MDI area. Parameters: Name Type Description Default position TabPositionStr tabs position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/mdiarea.py def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the MDI area. Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ])","title":"set_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_view_mode","text":"Set view mode for the MDI area. Parameters: Name Type Description Default mode ViewModeStr view mode to use required Exceptions: Type Description InvalidParamError view mode does not exist Source code in prettyqt/widgets/mdiarea.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode for the MDI area. Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_window_order","text":"Set the window order behaviour for the MDI area. Parameters: Name Type Description Default mode WindowOrderStr window order behaviour to use required Exceptions: Type Description InvalidParamError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py def set_window_order ( self , mode : WindowOrderStr ): \"\"\"Set the window order behaviour for the MDI area. Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDER : raise InvalidParamError ( mode , WINDOW_ORDER ) self . setActivationOrder ( WINDOW_ORDER [ mode ])","title":"set_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.menu","text":"","title":"menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu","text":"Source code in prettyqt/widgets/menu.py class Menu ( QtWidgets . QMenu ): def __init__ ( self , title : str = \"\" , icon : types . IconType = None , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( title , parent = parent ) self . set_icon ( icon ) self . setToolTipsVisible ( True ) def __iter__ ( self ) -> Iterator [ QtWidgets . QAction ]: return iter ( self . actions ()) def __len__ ( self ) -> int : return len ( self . actions ()) def __add__ ( self , other : QtWidgets . QAction ): self . add ( other ) return self def __getitem__ ( self , item : str ) -> QtWidgets . QAction : for action in self . actions (): if action . objectName () == item : return action raise KeyError ( f \"Action { item } not in menu\" ) def serialize_fields ( self ): return dict ( separators_collapsible = self . separatorsCollapsible (), tearoff_enabled = self . isTearOffEnabled (), title = self . title (), tool_tips_visible = self . toolTipsVisible (), icon = self . get_icon (), ) def add ( self , * item : QtWidgets . QAction ): for i in item : i . setParent ( self ) self . addAction ( i ) def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def add_separator ( self , text : str | None = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator def add_action ( self , label : str | widgets . Action , callback : Callable = None , icon : Any | None = None , checkable : bool = False , checked : bool = False , shortcut : str | None = None , status_tip : str | None = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action def add_actions ( self , actions : list [ QtWidgets . QAction ]): self . addActions ( actions ) def add_menu ( self , menu : QtWidgets . QMenu ) -> QtWidgets . QAction : action = menu . menuAction () self . addAction ( action ) return action","title":"Menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_action","text":"Add an action to the menu. Parameters: Name Type Description Default label str | widgets.Action Label for button required callback Callable gets called when action is triggered None icon Any | None icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut str | None Shortcut for action None status_tip str | None Status tip to be shown in status bar None Returns: Type Description widgets.Action Action added to menu Source code in prettyqt/widgets/menu.py def add_action ( self , label : str | widgets . Action , callback : Callable = None , icon : Any | None = None , checkable : bool = False , checked : bool = False , shortcut : str | None = None , status_tip : str | None = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action","title":"add_action()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_separator","text":"Adds a separator showing an optional label. Parameters: Name Type Description Default text str | None Text to show on separator None Returns: Type Description widgets.WidgetAction Separator action Source code in prettyqt/widgets/menu.py def add_separator ( self , text : str | None = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.set_icon","text":"Set the icon for the menu. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/menu.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox","text":"","title":"messagebox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox","text":"Source code in prettyqt/widgets/messagebox.py class MessageBox ( QtWidgets . QMessageBox ): def __init__ ( self , icon : types . IconType | IconStr = None , title : str = \"\" , text : str = \"\" , informative_text : str = \"\" , details : str = \"\" , buttons : list [ ButtonStr ] | None = None , parent : QtWidgets . QWidget | None = None , ): super () . __init__ ( parent ) self . set_icon ( icon ) self . setText ( text ) self . setInformativeText ( informative_text ) self . setWindowTitle ( title ) self . setWindowFlags ( QtCore . Qt . WindowType . Dialog # type: ignore | QtCore . Qt . WindowType . WindowTitleHint | QtCore . Qt . WindowType . CustomizeWindowHint ) self . setDetailedText ( details ) if isinstance ( buttons , list ): for b in buttons : self . add_button ( b ) def serialize_fields ( self ): return dict ( icon = self . get_icon (), detailed_text = self . detailedText (), icon_pixmap = self . get_icon_pixmap (), informative_text = self . informativeText (), text = self . text (), text_format = self . get_text_format (), ) @classmethod def message ( cls , text : str , title : str = \"\" , icon : types . IconType = None , detail_text : str | None = None , ) -> str : m = cls ( \"none\" , title , text ) m . set_icon ( icon ) if detail_text is not None : m . setDetailedText ( detail_text ) return m . show_blocking () @classmethod def show_exception ( cls , exception : Exception ): exctype , value = sys . exc_info ()[: 2 ] tb = traceback . format_exc () dlg = cls ( text = str ( value ), title = str ( exctype ), icon = \"critical\" , details = tb ) dlg . show_blocking () def set_icon ( self , icon : types . IconType | IconStr ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) else : ico = iconprovider . get_icon ( icon ) self . setIconPixmap ( ico . get_pixmap ( size = 64 )) def show_blocking ( self ) -> ButtonStr : return BUTTONS . inverse [ self . main_loop ()] def get_icon_pixmap ( self ) -> gui . Pixmap | None : pix = self . iconPixmap () if pix . isNull (): return None return gui . Pixmap ( pix ) def get_standard_buttons ( self ) -> list [ ButtonStr ]: return [ k for k , v in BUTTONS . items () if v & self . standardButtons ()] def add_button ( self , button : ButtonStr ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ]) # @classmethod # def show_exception(cls, exception): # header = str(exception[0]) # error_text = str(exception[1]) # widgets.MessageBox.message(error_text, header, \"mdi.exclamation\") def set_text_format ( self , text_format : TextFormatStr ): \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] def set_escape_button ( self , button : ButtonStr | QtWidgets . QAbstractButton ): if isinstance ( button , QtWidgets . QAbstractButton ): self . setEscapeButton ( button ) else : self . setEscapeButton ( BUTTONS [ button ]) def set_default_button ( self , button : ButtonStr | QtWidgets . QPushButton ): if isinstance ( button , QtWidgets . QPushButton ): self . setDefaultButton ( button ) else : self . setDefaultButton ( BUTTONS [ button ])","title":"MessageBox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.add_button","text":"Add a default button. Parameters: Name Type Description Default button ButtonStr button to add required Returns: Type Description QtWidgets.QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/messagebox.py def add_button ( self , button : ButtonStr ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ])","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.get_text_format","text":"Return current text format. Returns: Type Description TextFormatStr text format Source code in prettyqt/widgets/messagebox.py def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_icon","text":"Set the window icon. Parameters: Name Type Description Default icon types.IconType | IconStr icon to use required Source code in prettyqt/widgets/messagebox.py def set_icon ( self , icon : types . IconType | IconStr ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) else : ico = iconprovider . get_icon ( icon ) self . setIconPixmap ( ico . get_pixmap ( size = 64 ))","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_text_format","text":"Set the text format. Parameters: Name Type Description Default text_format TextFormatStr text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/messagebox.py def set_text_format ( self , text_format : TextFormatStr ): \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ])","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit","text":"","title":"plaintextedit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit","text":"Source code in prettyqt/widgets/plaintextedit.py class PlainTextEdit ( QtWidgets . QPlainTextEdit ): value_changed = core . Signal () def __init__ ( self , text : str = \"\" , parent : QtWidgets . QWidget | None = None , read_only : bool = False , ): super () . __init__ ( parent ) self . _allow_wheel_zoom = False self . validator : QtGui . QValidator | None = None self . textChanged . connect ( self . _on_value_change ) self . set_read_only ( read_only ) doc = gui . TextDocument ( self ) layout = widgets . PlainTextDocumentLayout ( doc ) doc . setDocumentLayout ( layout ) self . setDocument ( doc ) self . set_text ( text ) def serialize_fields ( self ): return dict ( text = self . text (), read_only = self . isReadOnly (), line_wrap_mode = self . get_line_wrap_mode (), word_wrap_mode = self . get_word_wrap_mode (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_text ( state [ \"text\" ]) self . setReadOnly ( state [ \"read_only\" ]) self . set_line_wrap_mode ( state [ \"line_wrap_mode\" ]) self . set_word_wrap_mode ( state [ \"word_wrap_mode\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __add__ ( self , other : str ): self . append_text ( other ) return self def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event ) def allow_wheel_zoom ( self , do_zoom : bool = True ): self . _allow_wheel_zoom = do_zoom def goto_line ( self , line_no : int ): doc = self . document () lines = doc . blockCount () assert 1 <= line_no <= lines pos = doc . findBlockByLineNumber ( line_no - 1 ) . position () with self . current_cursor () as text_cursor : text_cursor . setPosition ( pos ) def get_selected_text ( self ) -> str : if self . textCursor () . hasSelection (): return self . textCursor () . selectedText () else : return \"\" def get_current_line ( self ) -> int : return self . textCursor () . blockNumber () def get_selected_rows ( self ) -> tuple [ int , int ]: start = self . textCursor () . selectionStart () end = self . textCursor () . selectionEnd () start_block_id = self . document () . findBlock ( start ) . blockNumber () end_block_id = self . document () . findBlock ( end ) . blockNumber () return ( start_block_id , end_block_id ) @contextlib . contextmanager def create_cursor ( self ) -> Iterator [ gui . TextCursor ]: cursor = gui . TextCursor ( self . document ()) yield cursor self . setTextCursor ( cursor ) @contextlib . contextmanager def current_cursor ( self ) -> Iterator [ gui . TextCursor ]: cursor = gui . TextCursor ( self . textCursor ()) yield cursor self . setTextCursor ( cursor ) def get_text_cursor ( self ) -> gui . TextCursor : return gui . TextCursor ( self . textCursor ()) def move_cursor ( self , operation : gui . textcursor . MoveOperationStr , mode : gui . textcursor . MoveModeStr = \"move\" , ): self . moveCursor ( gui . textcursor . MOVE_OPERATION [ operation ], gui . textcursor . MOVE_MODE [ mode ] ) def append_text ( self , text : str , newline : bool = True ): if newline : self . appendPlainText ( text ) else : self . move_cursor ( \"end\" ) self . insertPlainText ( text ) self . move_cursor ( \"end\" ) def set_text ( self , text : str ): self . setPlainText ( text ) def set_syntaxhighlighter ( self , syntax : str , style : str | None = None ): self . _hl = syntaxhighlighters . PygmentsHighlighter ( self . document (), syntax ) if style is not None : self . _hl . set_style ( style ) def text ( self ) -> str : return self . toPlainText () def select_text ( self , start : int , end : int ): with self . create_cursor () as c : c . select_text ( start , end ) def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) def show_whitespace_and_tabs ( self , show : bool ): \"\"\"Set show white spaces flag.\"\"\" doc = self . document () options = doc . defaultTextOption () flag = QtGui . QTextOption . Flag . ShowTabsAndSpaces if show : options . setFlags ( options . flags () | flag ) # type: ignore else : options . setFlags ( options . flags () & ~ flag ) # type: ignore doc . setDefaultTextOption ( options ) def highlight_current_line ( self , color : types . ColorType = None ): if color is None : color = self . get_palette () . get_color ( \"highlight\" ) else : color = colors . get_color ( color ) extra_selections = [] if not self . isReadOnly (): selection = widgets . TextEdit . ExtraSelection () selection . format . setBackground ( color ) prop = QtGui . QTextFormat . Property . FullWidthSelection selection . format . setProperty ( prop , True ) selection . cursor = self . textCursor () selection . cursor . clearSelection () extra_selections . append ( selection ) self . setExtraSelections ( extra_selections ) @deprecated ( reason = \"This method is deprecated, use set_word_wrap_mode instead.\" ) def set_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): self . set_word_wrap_mode ( mode ) def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ]) @deprecated ( reason = \"This method is deprecated, use get_word_wrap_mode instead.\" ) def get_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : return self . get_word_wrap_mode () def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()] def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ]) def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()] def _on_value_change ( self ): self . value_changed . emit () if self . validator is not None : self . _set_validation_color () def _set_validation_color ( self , state : bool = True ): color = \"orange\" if not self . is_valid () else None self . set_background_color ( color ) def set_validator ( self , validator : QtGui . QValidator | None ): self . validator = validator self . _set_validation_color () def set_regex_validator ( self , regex : str , flags = 0 ) -> gui . RegularExpressionValidator : validator = gui . RegularExpressionValidator ( self ) validator . set_regex ( regex , flags ) self . set_validator ( validator ) return validator def is_valid ( self ) -> bool : if self . validator is None : return True return self . validator . is_valid_value ( self . text ()) def set_value ( self , value : str ): self . setPlainText ( value ) def get_value ( self ) -> str : return self . text ()","title":"PlainTextEdit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.get_line_wrap_mode","text":"Get the current wrap mode. Returns: Type Description LineWrapModeStr Wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()]","title":"get_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.get_word_wrap_mode","text":"Get the current word wrap mode. Returns: Type Description gui.textoption.WordWrapModeStr Word wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()]","title":"get_word_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_line_wrap_mode","text":"Set line wrap mode. Parameters: Name Type Description Default mode LineWrapModeStr line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ])","title":"set_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_read_only","text":"Make the PlainTextEdit read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_word_wrap_mode","text":"Set word wrap mode. Parameters: Name Type Description Default mode gui.textoption.WordWrapModeStr word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ])","title":"set_word_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.show_whitespace_and_tabs","text":"Set show white spaces flag. Source code in prettyqt/widgets/plaintextedit.py def show_whitespace_and_tabs ( self , show : bool ): \"\"\"Set show white spaces flag.\"\"\" doc = self . document () options = doc . defaultTextOption () flag = QtGui . QTextOption . Flag . ShowTabsAndSpaces if show : options . setFlags ( options . flags () | flag ) # type: ignore else : options . setFlags ( options . flags () & ~ flag ) # type: ignore doc . setDefaultTextOption ( options )","title":"show_whitespace_and_tabs()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.wheelEvent","text":"Handle wheel event for zooming. Source code in prettyqt/widgets/plaintextedit.py def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event )","title":"wheelEvent()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar","text":"","title":"progressbar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar","text":"Source code in prettyqt/widgets/progressbar.py class ProgressBar ( QtWidgets . QProgressBar ): \"\"\"Progress dialog. wrapper for QtWidgets.QProgressBar \"\"\" def __init__ ( self , text_visible : bool = True , parent : QtWidgets . QWidget | None = None ): super () . __init__ ( parent = parent ) self . setTextVisible ( text_visible ) def serialize_fields ( self ): return dict ( alignment = self . get_alignment (), format = self . format (), # inverted_appearance=self.invertedAppearance(), minimum = self . minimum (), maximum = self . maximum (), orientation = self . get_orientation (), text = self . text (), # text_direction=self.get_text_direction(), text_visible = self . isTextVisible (), value = self . value (), ) def set_alignment ( self , alignment : constants . AlignmentStr ): \"\"\"Set the alignment of the layout. Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) self . setAlignment ( constants . ALIGNMENTS [ alignment ]) def get_alignment ( self ) -> constants . AlignmentStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . ALIGNMENTS . inverse [ self . alignment ()] def set_text_direction ( self , text_direction : TextDirectionStr ): \"\"\"Set the text direction of the layout. Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ]) def get_text_direction ( self ) -> TextDirectionStr : \"\"\"Return current text direction. Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inverse [ self . textDirection ()] def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the progress bar. Args: orientation: orientation for the progress bar Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] def set_range ( self , start : int , end : int ): self . setRange ( start , end ) def set_value ( self , value : int ): self . setValue ( value ) def get_value ( self ) -> int : return self . value ()","title":"ProgressBar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_alignment","text":"Return current alignment. Returns: Type Description constants.AlignmentStr alignment Source code in prettyqt/widgets/progressbar.py def get_alignment ( self ) -> constants . AlignmentStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . ALIGNMENTS . inverse [ self . alignment ()]","title":"get_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_orientation","text":"Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/progressbar.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_text_direction","text":"Return current text direction. Returns: Type Description TextDirectionStr Text direction Source code in prettyqt/widgets/progressbar.py def get_text_direction ( self ) -> TextDirectionStr : \"\"\"Return current text direction. Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inverse [ self . textDirection ()]","title":"get_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_alignment","text":"Set the alignment of the layout. Parameters: Name Type Description Default alignment constants.AlignmentStr alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/progressbar.py def set_alignment ( self , alignment : constants . AlignmentStr ): \"\"\"Set the alignment of the layout. Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) self . setAlignment ( constants . ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_orientation","text":"Set the orientation of the progress bar. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the progress bar required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/progressbar.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the progress bar. Args: orientation: orientation for the progress bar Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_text_direction","text":"Set the text direction of the layout. Parameters: Name Type Description Default text_direction TextDirectionStr text direction for the layout required Exceptions: Type Description InvalidParamError text direction does not exist Source code in prettyqt/widgets/progressbar.py def set_text_direction ( self , text_direction : TextDirectionStr ): \"\"\"Set the text direction of the layout. Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ])","title":"set_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.scroller","text":"","title":"scroller"},{"location":"api/widgets.html#prettyqt.widgets.scroller.Scroller","text":"Source code in prettyqt/widgets/scroller.py class Scroller : def __init__ ( self , item : QtWidgets . QScroller ): self . item = item def __getattr__ ( self , val ): return getattr ( self . item , val ) def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()] def get_velocity ( self ) -> core . PointF : return core . PointF ( self . velocity ()) def get_pixel_per_meter ( self ) -> core . PointF : return core . PointF ( self . pixelPerMeter ()) def get_final_position ( self ) -> core . PointF : return core . PointF ( self . finalPosition ()) def handle_input ( self , input_type : InputStr , position : types . PointFType , timestamp : int = 0 ) -> bool : if isinstance ( position , tuple ): position = core . PointF ( * position ) if input_type not in INPUT : raise InvalidParamError ( input_type , INPUT ) return self . handleInput ( INPUT [ input_type ], position , timestamp ) def get_scroller_properties ( self ) -> widgets . ScrollerProperties : return widgets . ScrollerProperties ( self . scrollerProperties ()) @classmethod def get_scroller ( cls , obj : QtCore . QObject ): return cls ( QtWidgets . QScroller . scroller ( obj )) @staticmethod def grab_gesture ( target : QtCore . QObject , gesture_type : ScrollGestureTypeStr = \"touch\" ) -> str : if gesture_type not in SCROLLER_GESTURE_TYPE : raise InvalidParamError ( gesture_type , SCROLLER_GESTURE_TYPE ) gesture = QtWidgets . QScroller . grabGesture ( target , SCROLLER_GESTURE_TYPE [ gesture_type ] ) if gesture >= 256 : gesture -= 256 return constants . GESTURE_TYPE . inverse [ gesture ]","title":"Scroller"},{"location":"api/widgets.html#prettyqt.widgets.scroller.Scroller.get_state","text":"Return current state. Returns: Type Description StateStr state Source code in prettyqt/widgets/scroller.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties","text":"","title":"scrollerproperties"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties","text":"Source code in prettyqt/widgets/scrollerproperties.py class ScrollerProperties ( QtWidgets . QScrollerProperties ): def __getitem__ ( self , metric : ScrollmetricStr ): return self . get_scroll_metric ( metric ) def __setitem__ ( self , metric : ScrollmetricStr , value : Any ): self . set_scroll_metric ( metric , value ) def set_scroll_metric ( self , metric : ScrollmetricStr , value : Any ): \"\"\"Set scroll metric. Args: metric: Scroll metric to set value: Value to set Raises: InvalidParamError: metric does not exist \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) self . setScrollMetric ( SCROLL_METRIC [ metric ], value ) def get_scroll_metric ( self , metric : ScrollmetricStr ) -> Any : \"\"\"Return scroll metric. Args: metric: Scroll metric to get Raises: InvalidParamError: metric does not exist Returns: state \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) return self . scrollMetric ( SCROLL_METRIC [ metric ])","title":"ScrollerProperties"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.get_scroll_metric","text":"Return scroll metric. Parameters: Name Type Description Default metric ScrollmetricStr Scroll metric to get required Exceptions: Type Description InvalidParamError metric does not exist Returns: Type Description Any state Source code in prettyqt/widgets/scrollerproperties.py def get_scroll_metric ( self , metric : ScrollmetricStr ) -> Any : \"\"\"Return scroll metric. Args: metric: Scroll metric to get Raises: InvalidParamError: metric does not exist Returns: state \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) return self . scrollMetric ( SCROLL_METRIC [ metric ])","title":"get_scroll_metric()"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.set_scroll_metric","text":"Set scroll metric. Parameters: Name Type Description Default metric ScrollmetricStr Scroll metric to set required value Any Value to set required Exceptions: Type Description InvalidParamError metric does not exist Source code in prettyqt/widgets/scrollerproperties.py def set_scroll_metric ( self , metric : ScrollmetricStr , value : Any ): \"\"\"Set scroll metric. Args: metric: Scroll metric to set value: Value to set Raises: InvalidParamError: metric does not exist \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) self . setScrollMetric ( SCROLL_METRIC [ metric ], value )","title":"set_scroll_metric()"},{"location":"api/widgets.html#prettyqt.widgets.shortcut","text":"","title":"shortcut"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut","text":"Source code in prettyqt/widgets/shortcut.py class Shortcut ( QtWidgets . QShortcut ): def __str__ ( self ): return self . key () . toString () def serialize_field ( self ): return dict ( auto_repeat = self . autoRepeat (), context = self . get_context (), enabled = self . isEnabled (), key = self . get_key (), whats_this = self . whatsThis (), ) def set_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setContext ( constants . CONTEXT [ context ]) def get_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . context ()] def get_key ( self ) -> gui . KeySequence : \"\"\"Return the shortcut's key sequence. Returns: Key sequence \"\"\" return gui . KeySequence ( self . key () . toString (), gui . KeySequence . SequenceFormat . PortableText )","title":"Shortcut"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.get_context","text":"Return shortcut context. Returns: Type Description constants.ContextStr shortcut context Source code in prettyqt/widgets/shortcut.py def get_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . context ()]","title":"get_context()"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.get_key","text":"Return the shortcut's key sequence. Returns: Type Description gui.KeySequence Key sequence Source code in prettyqt/widgets/shortcut.py def get_key ( self ) -> gui . KeySequence : \"\"\"Return the shortcut's key sequence. Returns: Key sequence \"\"\" return gui . KeySequence ( self . key () . toString (), gui . KeySequence . SequenceFormat . PortableText )","title":"get_key()"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.set_context","text":"Set shortcut context. Parameters: Name Type Description Default context constants.ContextStr shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/shortcut.py def set_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setContext ( constants . CONTEXT [ context ])","title":"set_context()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy","text":"","title":"sizepolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy","text":"Source code in prettyqt/widgets/sizepolicy.py class SizePolicy ( prettyprinter . PrettyPrinter , QtWidgets . QSizePolicy ): def __repr__ ( self ) -> str : cls_name = type ( self ) . __name__ params = helpers . format_kwargs ( self . __getstate__ ()) return f \" { cls_name } ( { params } )\" def __getstate__ ( self ): return dict ( has_height_for_width = self . hasHeightForWidth (), has_width_for_height = self . hasWidthForHeight (), horizontal_stretch = self . horizontalStretch (), vertical_stretch = self . verticalStretch (), horizontal_policy = self . get_horizontal_policy (), vertical_policy = self . get_vertical_policy (), retain_size_when_hidden = self . retainSizeWhenHidden (), control_type = self . get_control_type (), ) def __setstate__ ( self , state : dict [ str , Any ]) -> None : self . setHeightForWidth ( state [ \"has_height_for_width\" ]) self . setWidthForHeight ( state [ \"has_width_for_height\" ]) self . setHorizontalStretch ( state [ \"horizontal_stretch\" ]) self . setVerticalStretch ( state [ \"vertical_stretch\" ]) self . set_horizontal_policy ( state [ \"horizontal_policy\" ]) self . set_vertical_policy ( state [ \"vertical_policy\" ]) self . setRetainSizeWhenHidden ( state [ \"retain_size_when_hidden\" ]) self . set_control_type ( state [ \"control_type\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def serialize ( self ) -> dict [ str , Any ]: return self . __getstate__ () @classmethod def clone ( cls , qpol : QtWidgets . QSizePolicy ) -> SizePolicy : pol = cls ( qpol . horizontalPolicy (), qpol . verticalPolicy (), qpol . controlType ()) pol . setHeightForWidth ( qpol . hasHeightForWidth ()) pol . setWidthForHeight ( qpol . hasWidthForHeight ()) pol . setHorizontalStretch ( qpol . horizontalStretch ()) pol . setVerticalStretch ( qpol . verticalStretch ()) pol . setRetainSizeWhenHidden ( qpol . retainSizeWhenHidden ()) return pol def get_horizontal_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: horizontal size policy \"\"\" return SIZE_POLICY . inverse [ self . horizontalPolicy ()] def set_horizontal_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setHorizontalPolicy ( SIZE_POLICY [ policy ]) def get_vertical_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: vertical size policy \"\"\" return SIZE_POLICY . inverse [ self . verticalPolicy ()] def set_vertical_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setVerticalPolicy ( SIZE_POLICY [ policy ]) def get_control_type ( self ) -> ControlTypeStr : \"\"\"Return control type. Returns: control type \"\"\" return CONTROL_TYPE . inverse [ self . controlType ()] def set_control_type ( self , typ : ControlTypeStr ) -> None : \"\"\"Set the control type. Args: typ: control type to set Raises: InvalidParamError: control type does not exist \"\"\" if typ not in CONTROL_TYPE : raise InvalidParamError ( typ , CONTROL_TYPE ) self . setControlType ( CONTROL_TYPE [ typ ])","title":"SizePolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_control_type","text":"Return control type. Returns: Type Description ControlTypeStr control type Source code in prettyqt/widgets/sizepolicy.py def get_control_type ( self ) -> ControlTypeStr : \"\"\"Return control type. Returns: control type \"\"\" return CONTROL_TYPE . inverse [ self . controlType ()]","title":"get_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_horizontal_policy","text":"Return size policy. Returns: Type Description SizePolicyStr horizontal size policy Source code in prettyqt/widgets/sizepolicy.py def get_horizontal_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: horizontal size policy \"\"\" return SIZE_POLICY . inverse [ self . horizontalPolicy ()]","title":"get_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_vertical_policy","text":"Return size policy. Returns: Type Description SizePolicyStr vertical size policy Source code in prettyqt/widgets/sizepolicy.py def get_vertical_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: vertical size policy \"\"\" return SIZE_POLICY . inverse [ self . verticalPolicy ()]","title":"get_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_control_type","text":"Set the control type. Parameters: Name Type Description Default typ ControlTypeStr control type to set required Exceptions: Type Description InvalidParamError control type does not exist Source code in prettyqt/widgets/sizepolicy.py def set_control_type ( self , typ : ControlTypeStr ) -> None : \"\"\"Set the control type. Args: typ: control type to set Raises: InvalidParamError: control type does not exist \"\"\" if typ not in CONTROL_TYPE : raise InvalidParamError ( typ , CONTROL_TYPE ) self . setControlType ( CONTROL_TYPE [ typ ])","title":"set_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_horizontal_policy","text":"Set the horizontal policy. Parameters: Name Type Description Default policy SizePolicyStr policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_horizontal_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setHorizontalPolicy ( SIZE_POLICY [ policy ])","title":"set_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_vertical_policy","text":"Set the horizontal policy. Parameters: Name Type Description Default policy SizePolicyStr policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_vertical_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setVerticalPolicy ( SIZE_POLICY [ policy ])","title":"set_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.slider","text":"","title":"slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider","text":"Source code in prettyqt/widgets/slider.py class Slider ( QtWidgets . QSlider ): value_changed = core . Signal ( int ) def __init__ ( self , orientation : ( constants . OrientationStr | QtCore . Qt . Orientation ) = \"horizontal\" , parent : QtWidgets . QWidget | None = None , ): if isinstance ( orientation , QtCore . Qt . Orientation ): ori = orientation else : ori = constants . ORIENTATION [ orientation ] super () . __init__ ( ori , parent ) self . valueChanged . connect ( self . on_value_change ) def serialize_fields ( self ): return dict ( tick_position = self . get_tick_position (), tick_interval = self . tickInterval (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_tick_position ( state [ \"tick_position\" ]) self . setTickInterval ( state [ \"tick_interval\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def set_tick_position ( self , position : TickPositionAllStr ): \"\"\"Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITION : raise InvalidParamError ( position , TICK_POSITION ) self . setTickPosition ( TICK_POSITION [ position ]) def get_tick_position ( self ) -> TickPositionStr : \"\"\"Return tick position. Returns: tick position \"\"\" return TICK_POSITION . inverse [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\"","title":"Slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.get_tick_position","text":"Return tick position. Returns: Type Description TickPositionStr tick position Source code in prettyqt/widgets/slider.py def get_tick_position ( self ) -> TickPositionStr : \"\"\"Return tick position. Returns: tick position \"\"\" return TICK_POSITION . inverse [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\"","title":"get_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.set_tick_position","text":"Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Parameters: Name Type Description Default position TickPositionAllStr position for the ticks required Source code in prettyqt/widgets/slider.py def set_tick_position ( self , position : TickPositionAllStr ): \"\"\"Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITION : raise InvalidParamError ( position , TICK_POSITION ) self . setTickPosition ( TICK_POSITION [ position ])","title":"set_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.splitter","text":"","title":"splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter","text":"Source code in prettyqt/widgets/splitter.py class Splitter ( QtWidgets . QSplitter ): def __init__ ( self , orientation : ( constants . OrientationStr | QtCore . Qt . Orientation ) = \"horizontal\" , parent : QtWidgets . QWidget | None = None , ): if isinstance ( orientation , QtCore . Qt . Orientation ): ori = orientation else : ori = constants . ORIENTATION [ orientation ] super () . __init__ ( ori , parent ) def __getitem__ ( self , index : int | str ) -> QtWidgets . QWidget : if isinstance ( index , int ): return self . widget ( index ) else : result = self . find_child ( QtWidgets . QWidget , index ) if result is None : raise KeyError ( \"Widget not found\" ) return result def __setitem__ ( self , index : int , value : QtWidgets . QWidget ): self . replaceWidget ( index , value ) def serialize_fields ( self ): return dict ( items = self . get_children (), orientation = self . get_orientation (), handle_width = self . handleWidth (), children_collapsible = self . childrenCollapsible (), opaque_resize = self . opaqueResize (), ) def __setstate__ ( self , state ): for item in state [ \"items\" ]: self . addWidget ( item ) self . setHandleWidth ( state [ \"handle_width\" ]) self . setChildrenCollapsible ( state [ \"children_collapsible\" ]) self . setOpaqueResize ( state [ \"opaque_resize\" ]) def __reduce__ ( self ): return type ( self ), ( self . orientation (),), self . __getstate__ () def __iter__ ( self ) -> Iterator [ QtWidgets . QWidget ]: return iter ( self . get_children ()) def __len__ ( self ) -> int : return self . count () def __contains__ ( self , item : QtWidgets . QWidget ): return self . indexOf ( item ) >= 0 def __add__ ( self , other : QtWidgets . QWidget | QtWidgets . QLayout ): self . add ( other ) return self def get_children ( self ) -> list [ QtWidgets . QWidget ]: return [ self [ i ] for i in range ( self . count ())] def add_widget ( self , widget : QtWidgets . QWidget ): self . addWidget ( widget ) def add_layout ( self , layout : QtWidgets . QLayout ) -> widgets . Widget : widget = widgets . Widget () widget . set_layout ( layout ) self . addWidget ( widget ) return widget def add ( self , * item : QtWidgets . QWidget | QtWidgets . QLayout ): for i in item : if isinstance ( i , QtWidgets . QWidget ): self . add_widget ( i ) else : self . add_layout ( i ) @classmethod def from_widgets ( cls , * widgets : QtWidgets . QWidget , horizontal : bool = False , parent : QtWidgets . QWidget | None = None , ): splitter = cls ( \"horizontal\" if horizontal else \"vertical\" , parent = parent ) for widget in widgets : splitter += widget return splitter def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the splitter. Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"Splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.get_orientation","text":"Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/splitter.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.set_orientation","text":"Set the orientation of the splitter. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitter.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the splitter. Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle","text":"","title":"splitterhandle"},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle.SplitterHandle","text":"Source code in prettyqt/widgets/splitterhandle.py class SplitterHandle ( QtWidgets . QSplitterHandle ): def __init__ ( self , orientation : constants . OrientationStr | QtCore . Qt . Orientation , parent : QtWidgets . QSplitter , ): if isinstance ( orientation , QtCore . Qt . Orientation ): ori = orientation else : ori = constants . ORIENTATION [ orientation ] super () . __init__ ( ori , parent ) def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the slider. Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"SplitterHandle"},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle.SplitterHandle.get_orientation","text":"Return current orientation. Returns: Type Description constants.OrientationStr orientation Source code in prettyqt/widgets/splitterhandle.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle.SplitterHandle.set_orientation","text":"Set the orientation of the slider. Parameters: Name Type Description Default orientation constants.OrientationStr orientation for the slider required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitterhandle.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the slider. Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider","text":"","title":"styleoptionslider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider","text":"Source code in prettyqt/widgets/styleoptionslider.py class StyleOptionSlider ( QtWidgets . QStyleOptionSlider ): def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == constants . HORIZONTAL def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == constants . VERTICAL def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = constants . HORIZONTAL def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = constants . VERTICAL def get_orientation ( self ) -> Literal [ \"horizontal\" , \"vertical\" ]: return \"horizontal\" if self . is_horizontal () else \"vertical\"","title":"StyleOptionSlider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_horizontal","text":"Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == constants . HORIZONTAL","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_vertical","text":"Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == constants . VERTICAL","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_horizontal","text":"Set slider orientation to horizontal. Source code in prettyqt/widgets/styleoptionslider.py def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = constants . HORIZONTAL","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_vertical","text":"Set slider orientation to vertical. Source code in prettyqt/widgets/styleoptionslider.py def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = constants . VERTICAL","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture","text":"","title":"swipegesture"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGesture","text":"Source code in prettyqt/widgets/swipegesture.py class SwipeGesture ( QtWidgets . QSwipeGesture ): def get_horizontal_direction ( self ) -> HorizontalDirectionStr : \"\"\"Return horizontal direction of the gesture. Returns: horizontal direction \"\"\" return SWIPE_DIRECTION . inverse [ self . horizontalDirection ()] def get_vertical_direction ( self ) -> VerticalDirectionStr : \"\"\"Return vertical direction of the gesture. Returns: vertical direction \"\"\" return SWIPE_DIRECTION . inverse [ self . verticalDirection ()]","title":"SwipeGesture"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGesture.get_horizontal_direction","text":"Return horizontal direction of the gesture. Returns: Type Description HorizontalDirectionStr horizontal direction Source code in prettyqt/widgets/swipegesture.py def get_horizontal_direction ( self ) -> HorizontalDirectionStr : \"\"\"Return horizontal direction of the gesture. Returns: horizontal direction \"\"\" return SWIPE_DIRECTION . inverse [ self . horizontalDirection ()]","title":"get_horizontal_direction()"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGesture.get_vertical_direction","text":"Return vertical direction of the gesture. Returns: Type Description VerticalDirectionStr vertical direction Source code in prettyqt/widgets/swipegesture.py def get_vertical_direction ( self ) -> VerticalDirectionStr : \"\"\"Return vertical direction of the gesture. Returns: vertical direction \"\"\" return SWIPE_DIRECTION . inverse [ self . verticalDirection ()]","title":"get_vertical_direction()"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon","text":"","title":"systemtrayicon"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon","text":"Source code in prettyqt/widgets/systemtrayicon.py class SystemTrayIcon ( QtWidgets . QSystemTrayIcon ): def set_icon ( self , icon : types . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def show_message ( self , title : str , message : str = \"\" , icon : types . IconType = None , timeout : int = 10 , ): if icon is None : ico = gui . Icon () if icon in MESSAGE_ICONS : ico = MESSAGE_ICONS [ icon ] else : ico = iconprovider . get_icon ( icon ) self . showMessage ( title , message , ico , timeout * 1000 )","title":"SystemTrayIcon"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon.set_icon","text":"Set the system tray icon. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/systemtrayicon.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar","text":"","title":"tabbar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar","text":"Source code in prettyqt/widgets/tabbar.py class TabBar ( QtWidgets . QTabBar ): on_detach = QtCore . Signal ( int , QtCore . QPoint ) def __init__ ( self , parent : QtWidgets . QWidget | None = None ) -> None : super () . __init__ ( parent ) self . setAcceptDrops ( True ) self . set_elide_mode ( \"right\" ) self . set_selection_behavior_on_remove ( \"left_tab\" ) def __getitem__ ( self , index : tuple [ int , str ]): return self . tabButton ( index [ 0 ], POSITIONS [ index [ 1 ]]) def __setitem__ ( self , index : tuple [ int , PositionStr ], value : QtWidgets . QWidget | None ): self . set_tab ( index [ 0 ], index [ 1 ], value ) def serialize_fields ( self ): return dict ( movable = self . isMovable (), document_mode = self . documentMode (), current_index = self . currentIndex (), # shape=self.shape(), draw_base = self . drawBase (), elide_mode = self . get_elide_mode (), icon_size = core . Size ( self . iconSize ()), ) def __setstate__ ( self , state ): self . setDocumentMode ( state . get ( \"document_mode\" , False )) self . setMovable ( state . get ( \"movable\" , False )) # self.setShape(state.get(\"shape\", \"rounded\")) self . setIconSize ( state [ \"icon_size\" ]) self . setDrawBase ( state . get ( \"draw_base\" )) self . set_elide_mode ( state . get ( \"elide_mode\" )) self . setCurrentIndex ( state . get ( \"index\" , 0 )) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () # Send the on_detach when a tab is double clicked def mouseDoubleClickEvent ( self , event ): event . accept () tab = self . tabAt ( event . position ()) pos = QtGui . QCursor . pos () self . on_detach . emit ( tab , pos ) def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) def get_icon_size ( self ) -> core . Size : return core . Size ( self . iconSize ()) def set_tab ( self , index : int , position : PositionStr , widget : QtWidgets . QWidget | None ) -> None : self . setTabButton ( index , POSITIONS [ position ], widget ) # type: ignore @deprecated ( reason = \"This method is deprecated, use set_selection_behavior_on_remove instead.\" ) def set_remove_behaviour ( self , mode : RemoveBehaviourStr ) -> None : self . set_selection_behavior_on_remove ( mode ) def set_selection_behavior_on_remove ( self , mode : RemoveBehaviourStr ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOUR : raise InvalidParamError ( mode , REMOVE_BEHAVIOUR ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOUR [ mode ]) def get_remove_behaviour ( self ) -> RemoveBehaviourStr : \"\"\"Return remove behaviour. Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOUR . inverse [ self . selectionBehaviorOnRemove ()] def set_elide_mode ( self , mode : constants . ElideModeStr ) -> None : \"\"\"Set elide mode. Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in constants . ELIDE_MODE : raise InvalidParamError ( mode , constants . ELIDE_MODE ) self . setElideMode ( constants . ELIDE_MODE [ mode ]) def get_elide_mode ( self ) -> constants . ElideModeStr : \"\"\"Return elide mode. Returns: elide mode \"\"\" return constants . ELIDE_MODE . inverse [ self . elideMode ()]","title":"TabBar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_elide_mode","text":"Return elide mode. Returns: Type Description constants.ElideModeStr elide mode Source code in prettyqt/widgets/tabbar.py def get_elide_mode ( self ) -> constants . ElideModeStr : \"\"\"Return elide mode. Returns: elide mode \"\"\" return constants . ELIDE_MODE . inverse [ self . elideMode ()]","title":"get_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_remove_behaviour","text":"Return remove behaviour. Returns: Type Description RemoveBehaviourStr remove behaviour Source code in prettyqt/widgets/tabbar.py def get_remove_behaviour ( self ) -> RemoveBehaviourStr : \"\"\"Return remove behaviour. Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOUR . inverse [ self . selectionBehaviorOnRemove ()]","title":"get_remove_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.mouseDoubleClickEvent","text":"mouseDoubleClickEvent(self, arg__1: PySide6.QtGui.QMouseEvent) -> None Source code in prettyqt/widgets/tabbar.py def mouseDoubleClickEvent ( self , event ): event . accept () tab = self . tabAt ( event . position ()) pos = QtGui . QCursor . pos () self . on_detach . emit ( tab , pos )","title":"mouseDoubleClickEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_elide_mode","text":"Set elide mode. Parameters: Name Type Description Default mode constants.ElideModeStr elide mode to use required Exceptions: Type Description InvalidParamError invalid elide mode Source code in prettyqt/widgets/tabbar.py def set_elide_mode ( self , mode : constants . ElideModeStr ) -> None : \"\"\"Set elide mode. Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in constants . ELIDE_MODE : raise InvalidParamError ( mode , constants . ELIDE_MODE ) self . setElideMode ( constants . ELIDE_MODE [ mode ])","title":"set_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_icon_size","text":"Set size of the icons. Source code in prettyqt/widgets/tabbar.py def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_selection_behavior_on_remove","text":"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Parameters: Name Type Description Default mode RemoveBehaviourStr new remove behaviour required Source code in prettyqt/widgets/tabbar.py def set_selection_behavior_on_remove ( self , mode : RemoveBehaviourStr ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOUR : raise InvalidParamError ( mode , REMOVE_BEHAVIOUR ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOUR [ mode ])","title":"set_selection_behavior_on_remove()"},{"location":"api/widgets.html#prettyqt.widgets.tableview","text":"","title":"tableview"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableView","text":"Source code in prettyqt/widgets/tableview.py class TableView ( QtWidgets . QTableView ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) class_name = type ( self ) . __name__ self . set_id ( class_name ) self . setHorizontalHeader ( widgets . HeaderView ( \"horizontal\" , parent = self )) self . setVerticalHeader ( widgets . HeaderView ( \"vertical\" , parent = self )) self . setAlternatingRowColors ( True ) self . setWordWrap ( False ) def serialize_fields ( self ): return dict ( corner_button_enabled = self . isCornerButtonEnabled (), grid_style = self . get_grid_style (), show_grid = self . showGrid (), sorting_enabled = self . isSortingEnabled (), word_wrap = self . wordWrap (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setCornerButtonEnabled ( state [ \"corner_button_enabled\" ]) self . set_grid_style ( state [ \"grid_style\" ]) self . setShowGrid ( state [ \"show_grid\" ]) self . setSortingEnabled ( state [ \"sorting_enabled\" ]) self . setWordWrap ( state [ \"word_wrap\" ]) @property def h_header ( self ): return self . horizontalHeader () @h_header . setter def h_header ( self , header ): self . setHorizontalHeader ( header ) @property def v_header ( self ): return self . verticalHeader () @v_header . setter def v_header ( self , header ): self . setVerticalHeader ( header ) def setup_list_style ( self ): self . set_selection_behaviour ( \"rows\" ) self . h_header . setStretchLastSection ( True ) self . v_header . set_resize_mode ( \"fixed\" ) self . v_header . set_default_section_size ( 28 ) def adapt_sizes ( self ): model = self . model () if model is not None and ( model . rowCount () * model . columnCount ()) < 1000 : self . resizeColumnsToContents () else : self . h_header . resize_sections ( \"interactive\" ) def sort_by_column ( self , column : int | None , ascending : bool = True ): column = - 1 if column is None else column order = constants . ASCENDING if ascending else constants . DESCENDING self . sortByColumn ( column , order ) def set_grid_style ( self , style : constants . PenStyleStr ): \"\"\"Set grid style. Args: style: grid style to use Raises: InvalidParamError: invalid grid style \"\"\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setGridStyle ( constants . PEN_STYLE [ style ]) def get_grid_style ( self ) -> constants . PenStyleStr : \"\"\"Return grid style. Returns: grid style \"\"\" return constants . PEN_STYLE . inverse [ self . gridStyle ()]","title":"TableView"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableView.get_grid_style","text":"Return grid style. Returns: Type Description constants.PenStyleStr grid style Source code in prettyqt/widgets/tableview.py def get_grid_style ( self ) -> constants . PenStyleStr : \"\"\"Return grid style. Returns: grid style \"\"\" return constants . PEN_STYLE . inverse [ self . gridStyle ()]","title":"get_grid_style()"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableView.set_grid_style","text":"Set grid style. Parameters: Name Type Description Default style constants.PenStyleStr grid style to use required Exceptions: Type Description InvalidParamError invalid grid style Source code in prettyqt/widgets/tableview.py def set_grid_style ( self , style : constants . PenStyleStr ): \"\"\"Set grid style. Args: style: grid style to use Raises: InvalidParamError: invalid grid style \"\"\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setGridStyle ( constants . PEN_STYLE [ style ])","title":"set_grid_style()"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem","text":"","title":"tablewidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem","text":"Source code in prettyqt/widgets/tablewidgetitem.py class TableWidgetItem ( QtWidgets . QTableWidgetItem ): def __setitem__ ( self , index : int , value ): self . setData ( index , value ) def __getitem__ ( self , index : int ): return self . data ( index ) def serialize_fields ( self ): return dict ( text = self . text (), tool_tip = self . toolTip (), status_tip = self . statusTip (), checkstate = self . get_checkstate (), icon = self . get_icon (), data = self . data ( constants . USER_ROLE ), # type: ignore ) def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] def set_text_alignment ( self , horizontal : constants . HorizontalAlignmentStr | None = None , vertical : constants . VerticalAlignmentStr | None = None , ): \"\"\"Set text alignment of the checkbox. Args: horizontal: horizontal text alignment to use vertical: vertical text alignment to use Raises: InvalidParamError: invalid text alignment \"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setTextAlignment ( flag ) def get_background ( self ) -> gui . Brush : return gui . Brush ( self . background ()) def get_foreground ( self ) -> gui . Brush : return gui . Brush ( self . foreground ()) def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_icon ( self ) -> gui . Icon | None : icon = self . icon () if icon . isNull (): return None return gui . Icon ( icon ) def set_tooltip ( self , tooltip : str | types . PathType , size : types . SizeType | None = None , ): if isinstance ( tooltip , os . PathLike ): path = os . fspath ( tooltip ) if size is None : tooltip = f \"<img src= { path !r} >\" else : if isinstance ( size , QtCore . QSize ): size = ( size . width (), size . height ()) tooltip = f '<img src= { path !r} width=\" { size [ 0 ] } \" height=\" { size [ 1 ] } \">' self . setToolTip ( tooltip )","title":"TableWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.get_checkstate","text":"Return checkstate. Returns: Type Description constants.StateStr checkstate Source code in prettyqt/widgets/tablewidgetitem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/tablewidgetitem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/tablewidgetitem.py def set_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_text_alignment","text":"Set text alignment of the checkbox. Parameters: Name Type Description Default horizontal constants.HorizontalAlignmentStr | None horizontal text alignment to use None vertical constants.VerticalAlignmentStr | None vertical text alignment to use None Exceptions: Type Description InvalidParamError invalid text alignment Source code in prettyqt/widgets/tablewidgetitem.py def set_text_alignment ( self , horizontal : constants . HorizontalAlignmentStr | None = None , vertical : constants . VerticalAlignmentStr | None = None , ): \"\"\"Set text alignment of the checkbox. Args: horizontal: horizontal text alignment to use vertical: vertical text alignment to use Raises: InvalidParamError: invalid text alignment \"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setTextAlignment ( flag )","title":"set_text_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget","text":"","title":"tabwidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab","text":"Source code in prettyqt/widgets/tabwidget.py class DetachedTab ( widgets . MainWindow ): \"\"\"Window containing a detached tab. When a tab is detached, the contents are placed into this QMainWindow. The tab can be re-attached by closing the dialog Attributes: on_close: signal, emitted when window is closed (widget, title, icon) \"\"\" on_close = core . Signal ( QtWidgets . QWidget , str , QtGui . QIcon ) def __init__ ( self , name : str , widget : QtWidgets . QWidget ): super () . __init__ ( None ) self . set_id ( name ) self . set_title ( name ) self . widget = widget self . setCentralWidget ( self . widget ) self . widget . show () # If the window is closed, emit the on_close and give the # content widget back to the DetachableTabWidget def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . get_id (), self . windowIcon ())","title":"DetachedTab"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab.closeEvent","text":"closeEvent(self, event: PySide6.QtGui.QCloseEvent) -> None Source code in prettyqt/widgets/tabwidget.py def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . get_id (), self . windowIcon ())","title":"closeEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget","text":"Source code in prettyqt/widgets/tabwidget.py class TabWidget ( QtWidgets . QTabWidget ): \"\"\"Widget for managing the tabs section.\"\"\" def __init__ ( self , parent : QtWidgets . QWidget | None = None , closable : bool = False , detachable : bool = False , ) -> None : # Basic initalization super () . __init__ ( parent ) self . tabCloseRequested . connect ( self . remove_tab ) self . tab_bar = widgets . TabBar ( self ) self . setTabBar ( self . tab_bar ) # Used to keep a reference to detached tabs since their QMainWindow # does not have a parent self . detached_tabs : dict [ str , DetachedTab ] = {} if detachable : self . set_detachable () self . set_closable ( closable ) def __len__ ( self ) -> int : return self . count () def __getitem__ ( self , index : int ) -> QtWidgets . QWidget : if isinstance ( index , int ): return self . widget ( index ) else : result = self . findChild ( QtWidgets . QWidget , index ) if result is None : raise KeyError ( \"Widget not found\" ) return result def __contains__ ( self , item : QtWidgets . QWidget ): return self . indexOf ( item ) >= 0 def serialize_fields ( self ): return dict ( tabbar = self . tabBar (), widgets = self . get_children (), movable = self . isMovable (), document_mode = self . documentMode (), current_index = self . currentIndex (), tab_shape = self . get_tab_shape (), # elide_mode=self.get_elide_mode(), icon_size = self . iconSize (), tab_position = self . get_tab_position (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . setTabBar ( state [ \"tabbar\" ]) self . setDocumentMode ( state . get ( \"document_mode\" , False )) self . setMovable ( state . get ( \"movable\" , False )) self . set_tab_shape ( state . get ( \"tab_shape\" , \"rounded\" )) self . setIconSize ( state [ \"icon_size\" ]) for ( widget , name , icon , tooltip , whatsthis ) in state [ \"widgets\" ]: i = self . add_tab ( widget , name , icon ) self . setTabToolTip ( i , tooltip ) self . setTabWhatsThis ( i , whatsthis ) self . setCurrentIndex ( state . get ( \"index\" , 0 )) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def update_tab_bar_visibility ( self ): \"\"\"Update visibility of the tabBar depending of the number of tabs. 0 or 1 tab -> tabBar hidden, 2+ tabs - >tabBar visible need to be called explicitly, or be connected to tabInserted/tabRemoved \"\"\" self . tabBar () . setVisible ( self . count () > 1 ) def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) def set_document_mode ( self , state : bool = True ) -> None : self . setDocumentMode ( state ) def set_tab_shape ( self , shape : TabShapeStr ): \"\"\"Set tab shape for the tabwidget. Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ]) def get_tab_shape ( self ) -> TabShapeStr : \"\"\"Return tab shape. Returns: tab shape \"\"\" return TAB_SHAPES . inverse [ self . tabShape ()] def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the tabwidget. Args: position: tab position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ]) def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()] def get_children ( self ) -> list [ tuple ]: return [ ( self . widget ( i ), self . tabText ( i ), self . tab_icon ( i ), self . tabToolTip ( i ), self . tabWhatsThis ( i ), ) for i in range ( self . count ()) ] def tab_icon ( self , i : int ) -> gui . Icon | None : icon = self . tabIcon ( i ) if icon . isNull (): return None return gui . Icon ( icon ) def set_detachable ( self ): self . tab_bar . on_detach . connect ( self . detach_tab ) core . CoreApplication . call_on_exit ( self . close_detached_tabs ) self . setMovable ( True ) def set_closable ( self , closable : bool = True ): self . setTabsClosable ( closable ) @core . Slot ( int , QtCore . QPoint ) def detach_tab ( self , index : int , point : types . PointType ): \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) name = self . tabText ( index ) icon = self . tab_icon ( index ) if icon is None : icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab def add_tab ( self , item : QtWidgets . QWidget | QtWidgets . QLayout , label : str , icon : types . IconType = None , position : int | None = None , show : bool = False , ) -> int : if isinstance ( item , QtWidgets . QLayout ): widget = widgets . Widget () widget . set_layout ( item ) else : widget = item if position is None : position = len ( self ) if not icon : index = self . insertTab ( position , widget , label ) else : icon = iconprovider . get_icon ( icon ) index = self . insertTab ( position , widget , icon , label ) if show : self . setCurrentIndex ( index ) return index def attach_tab ( self , widget : QtWidgets . QWidget | QtWidgets . QLayout , name : str , icon : types . IconType = None , insert_at : int | None = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (types.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True ) def close_detached_tabs ( self ): \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close () @core . Slot ( int ) def remove_tab ( self , index : int ): widget = self . widget ( index ) self . removeTab ( index ) if widget is not None : widget . deleteLater () @core . Slot ( QtWidgets . QWidget , str ) def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True ) def set_tab ( self , index : int , position : str , widget : QtWidgets . QWidget | None = None ): self . tabBar () . set_tab ( index , position , widget )","title":"TabWidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.attach_tab","text":"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Parameters: Name Type Description Default widget Union[QtWidgets.QWidget, QtWidgets.QLayout] the content widget from the DetachedTab window required name str the name of the detached tab required icon types.IconType the window icon for the detached tab None insert_at Optional[int] insert the re-attached tab at the given index None Source code in prettyqt/widgets/tabwidget.py def attach_tab ( self , widget : QtWidgets . QWidget | QtWidgets . QLayout , name : str , icon : types . IconType = None , insert_at : int | None = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (types.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True )","title":"attach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.close_detached_tabs","text":"Close all tabs that are currently detached. Source code in prettyqt/widgets/tabwidget.py def close_detached_tabs ( self ): \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close ()","title":"close_detached_tabs()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.detach_tab","text":"Detach tab by removing its contents and placing them in a DetachedTab window. Parameters: Name Type Description Default index int index location of the tab to be detached required point QtCore.QPoint screen pos for creating the new DetachedTab window required Returns: Type Description None Description Source code in prettyqt/widgets/tabwidget.py @core . Slot ( int , QtCore . QPoint ) def detach_tab ( self , index : int , point : types . PointType ): \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) name = self . tabText ( index ) icon = self . tab_icon ( index ) if icon is None : icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab","title":"detach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_position","text":"Return tab position. Returns: Type Description TabPositionStr tab position Source code in prettyqt/widgets/tabwidget.py def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()]","title":"get_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_shape","text":"Return tab shape. Returns: Type Description TabShapeStr tab shape Source code in prettyqt/widgets/tabwidget.py def get_tab_shape ( self ) -> TabShapeStr : \"\"\"Return tab shape. Returns: tab shape \"\"\" return TAB_SHAPES . inverse [ self . tabShape ()]","title":"get_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.open_widget","text":"Create a tab containing delivered widget. Source code in prettyqt/widgets/tabwidget.py @core . Slot ( QtWidgets . QWidget , str ) def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True )","title":"open_widget()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_icon_size","text":"Set size of the icons. Source code in prettyqt/widgets/tabwidget.py def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_position","text":"Set tab position for the tabwidget. Parameters: Name Type Description Default position TabPositionStr tab position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the tabwidget. Args: position: tab position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ])","title":"set_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_shape","text":"Set tab shape for the tabwidget. Parameters: Name Type Description Default shape TabShapeStr tab shape to use required Exceptions: Type Description InvalidParamError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_shape ( self , shape : TabShapeStr ): \"\"\"Set tab shape for the tabwidget. Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ])","title":"set_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.update_tab_bar_visibility","text":"Update visibility of the tabBar depending of the number of tabs. 0 or 1 tab -> tabBar hidden, 2+ tabs - >tabBar visible need to be called explicitly, or be connected to tabInserted/tabRemoved Source code in prettyqt/widgets/tabwidget.py def update_tab_bar_visibility ( self ): \"\"\"Update visibility of the tabBar depending of the number of tabs. 0 or 1 tab -> tabBar hidden, 2+ tabs - >tabBar visible need to be called explicitly, or be connected to tabInserted/tabRemoved \"\"\" self . tabBar () . setVisible ( self . count () > 1 )","title":"update_tab_bar_visibility()"},{"location":"api/widgets.html#prettyqt.widgets.textedit","text":"","title":"textedit"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit","text":"Source code in prettyqt/widgets/textedit.py class TextEdit ( QtWidgets . QTextEdit ): value_changed = core . Signal ( str ) def __init__ ( self , * args , ** kwargs ) -> None : super () . __init__ ( * args , ** kwargs ) self . textChanged . connect ( self . on_value_change ) def serialize_fields ( self ): return dict ( text = self . text (), accept_rich_text = self . acceptRichText (), auto_formatting = self . get_auto_formatting (), cursor_width = self . cursorWidth (), document_title = self . documentTitle (), line_wrap_column_or_width = self . lineWrapColumnOrWidth (), line_wrap_mode = self . get_line_wrap_mode (), word_wrap_mode = self . get_word_wrap_mode (), overwrite_mode = self . overwriteMode (), placeholder_text = self . placeholderText (), read_only = self . isReadOnly (), tab_changes_focus = self . tabChangesFocus (), tab_stop_distance = self . tabStopDistance (), undo_redo_enabled = self . isUndoRedoEnabled (), ) def __setstate__ ( self , state ): super () . __setstate__ ( state ) self . set_text ( state [ \"text\" ]) self . setAcceptRichText ( state [ \"accept_rich_text\" ]) self . set_auto_formatting ( state [ \"auto_formatting\" ]) self . setCursorWidth ( state [ \"cursor_width\" ]) self . setDocumentTitle ( state [ \"document_title\" ]) self . setLineWrapColumnOrWidth ( state [ \"line_wrap_column_or_width\" ]) self . set_line_wrap_mode ( state [ \"line_wrap_mode\" ]) self . set_word_wrap_mode ( state [ \"word_wrap_mode\" ]) self . setOverwriteMode ( state [ \"overwrite_mode\" ]) self . setPlaceholderText ( state [ \"placeholder_text\" ]) self . setReadOnly ( state [ \"read_only\" ]) self . setTabChangesFocus ( state [ \"tab_changes_focus\" ]) self . setTabStopDistance ( state [ \"tab_stop_distance\" ]) self . setUndoRedoEnabled ( state [ \"undo_redo_enabled\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __add__ ( self , other : str ) -> TextEdit : self . append_text ( other ) return self def on_value_change ( self ) -> None : self . value_changed . emit ( self . text ()) @contextlib . contextmanager def create_cursor ( self ) -> Iterator [ gui . TextCursor ]: cursor = gui . TextCursor ( self . document ()) yield cursor self . setTextCursor ( cursor ) def get_text_cursor ( self ) -> gui . TextCursor : return gui . TextCursor ( self . textCursor ()) def set_text ( self , text : str ) -> None : self . setPlainText ( text ) def append_text ( self , text : str ) -> None : self . append ( text ) def text ( self ) -> str : return self . toPlainText () def select_text ( self , start : int , end : int ) -> None : with self . create_cursor () as c : c . select_text ( start , end ) def set_read_only ( self , value : bool = True ) -> None : self . setReadOnly ( value ) def set_text_color ( self , color : types . ColorType ) -> None : color = colors . get_color ( color ) self . setTextColor ( color ) def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ]) def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()] def set_auto_formatting ( self , mode : AutoFormattingStr ): \"\"\"Set auto formatting mode. Args: mode: auto formatting mode to use Raises: InvalidParamError: auto formatting mode does not exist \"\"\" if mode not in AUTO_FORMATTING : raise InvalidParamError ( mode , AUTO_FORMATTING ) self . setAutoFormatting ( AUTO_FORMATTING [ mode ]) def get_auto_formatting ( self ) -> AutoFormattingStr : \"\"\"Get the current auto formatting mode. Returns: Auto formatting mode \"\"\" return AUTO_FORMATTING . inverse [ self . autoFormatting ()] def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ]) def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()]","title":"TextEdit"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.get_auto_formatting","text":"Get the current auto formatting mode. Returns: Type Description AutoFormattingStr Auto formatting mode Source code in prettyqt/widgets/textedit.py def get_auto_formatting ( self ) -> AutoFormattingStr : \"\"\"Get the current auto formatting mode. Returns: Auto formatting mode \"\"\" return AUTO_FORMATTING . inverse [ self . autoFormatting ()]","title":"get_auto_formatting()"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.get_line_wrap_mode","text":"Get the current wrap mode. Returns: Type Description LineWrapModeStr Wrap mode Source code in prettyqt/widgets/textedit.py def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()]","title":"get_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.get_word_wrap_mode","text":"Get the current word wrap mode. Returns: Type Description gui.textoption.WordWrapModeStr Word wrap mode Source code in prettyqt/widgets/textedit.py def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()]","title":"get_word_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.set_auto_formatting","text":"Set auto formatting mode. Parameters: Name Type Description Default mode AutoFormattingStr auto formatting mode to use required Exceptions: Type Description InvalidParamError auto formatting mode does not exist Source code in prettyqt/widgets/textedit.py def set_auto_formatting ( self , mode : AutoFormattingStr ): \"\"\"Set auto formatting mode. Args: mode: auto formatting mode to use Raises: InvalidParamError: auto formatting mode does not exist \"\"\" if mode not in AUTO_FORMATTING : raise InvalidParamError ( mode , AUTO_FORMATTING ) self . setAutoFormatting ( AUTO_FORMATTING [ mode ])","title":"set_auto_formatting()"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.set_line_wrap_mode","text":"Set line wrap mode. Parameters: Name Type Description Default mode LineWrapModeStr line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/textedit.py def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ])","title":"set_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.set_word_wrap_mode","text":"Set word wrap mode. Parameters: Name Type Description Default mode gui.textoption.WordWrapModeStr word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/textedit.py def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ])","title":"set_word_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar","text":"","title":"toolbar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar","text":"Source code in prettyqt/widgets/toolbar.py class ToolBar ( QtWidgets . QToolBar ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . set_icon_size ( 24 ) self . menu_buttons = list () def __setstate__ ( self , state : dict [ str , Any ]) -> None : super () . __setstate__ ( state ) self . addActions ( state [ \"actions\" ]) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def serialize_fields ( self ): return dict ( actions = self . actions (), allowed_areas = self . get_allowed_areas ()) def __repr__ ( self ): return f \" { type ( self ) . __name__ } ( { self . windowTitle () !r} )\" def add ( self , item : QtWidgets . QAction | QtWidgets . QWidget ): if isinstance ( item , QtWidgets . QAction ): self . addAction ( item ) else : self . addWidget ( item ) def add_menu_button ( self , label : str , icon : types . IconType , menu : QtWidgets . QMenu ) -> widgets . ToolButton : btn = widgets . ToolButton . for_menu ( menu ) btn . setText ( label ) btn . setToolButtonStyle ( self . toolButtonStyle ()) btn . set_icon ( icon ) self . menu_buttons . append ( btn ) self . addWidget ( btn ) return btn def add_separator ( self , text : str | None = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label ) def set_style ( self , style : constants . ToolButtonStyleStr ): self . setToolButtonStyle ( constants . TOOLBUTTON_STYLE [ style ]) for btn in self . menu_buttons : btn . set_style ( style ) def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return current style. Returns: style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()] def add_action ( self , label : str , icon : types . IconType = None , callback : Callable | None = None , checkable : bool = False , ) -> QtWidgets . QAction : icon = iconprovider . get_icon ( icon ) action = self . addAction ( icon , label ) if callback is not None : action . triggered . connect ( callback ) if checkable : action . setCheckable ( True ) return action def add_spacer ( self ) -> QtWidgets . QAction : spacer = widgets . Widget () spacer . set_size_policy ( \"expanding\" , \"expanding\" ) return self . addWidget ( spacer ) def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) def get_icon_size ( self ) -> core . Size : return core . Size ( self . iconSize ()) def set_font_size ( self , size : int ): with self . edit_font () as font : font . set_size ( size ) def is_area_allowed ( self , area : constants . ToolbarAreaStr ) -> bool : \"\"\"Check if toolbar is allowed at specified area. Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in constants . TOOLBAR_AREA : raise InvalidParamError ( area , constants . TOOLBAR_AREA ) return self . isAreaAllowed ( constants . TOOLBAR_AREA [ area ]) def set_allowed_areas ( self , * areas : constants . ToolbarAreaStr ): for area in areas : if area not in constants . TOOLBAR_AREA : raise InvalidParamError ( area , constants . TOOLBAR_AREA ) flag = helpers . merge_flags ( areas , constants . TOOLBAR_AREA ) self . setAllowedAreas ( flag ) def get_allowed_areas ( self ) -> list [ constants . ToolbarAreaStr ]: return [ k for k , v in constants . TOOLBAR_AREA . items () if v & self . allowedAreas () # type: ignore ]","title":"ToolBar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.add_separator","text":"Adds a separator showing an optional label. Parameters: Name Type Description Default text str | None Text to show on separator None before QtWidgets.QAction insert separator before specific action None Returns: Type Description QtWidgets.QAction Separator action Source code in prettyqt/widgets/toolbar.py def add_separator ( self , text : str | None = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label )","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.get_style","text":"Return current style. Returns: Type Description constants.ToolButtonStyleStr style Source code in prettyqt/widgets/toolbar.py def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return current style. Returns: style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()]","title":"get_style()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.is_area_allowed","text":"Check if toolbar is allowed at specified area. Parameters: Name Type Description Default area constants.ToolbarAreaStr area of the toolbar required Exceptions: Type Description InvalidParamError area does not exist Source code in prettyqt/widgets/toolbar.py def is_area_allowed ( self , area : constants . ToolbarAreaStr ) -> bool : \"\"\"Check if toolbar is allowed at specified area. Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in constants . TOOLBAR_AREA : raise InvalidParamError ( area , constants . TOOLBAR_AREA ) return self . isAreaAllowed ( constants . TOOLBAR_AREA [ area ])","title":"is_area_allowed()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.set_icon_size","text":"Set size of the icons. Source code in prettyqt/widgets/toolbar.py def set_icon_size ( self , size : int | types . SizeType ): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton","text":"","title":"toolbutton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton","text":"Source code in prettyqt/widgets/toolbutton.py class ToolButton ( QtWidgets . QToolButton ): def __getitem__ ( self , item : str ) -> QtWidgets . QAction : menu = self . menu () return menu [ item ] # def set_menu(self, menu: QtWidgets.QMenu): # menu.setParent(self) # self.setMenu(menu) @classmethod def for_menu ( cls , menu : QtWidgets . QMenu , icon : types . IconType = None ): btn = cls () btn . setMenu ( menu ) # btn.set_title(menu.title()) btn . set_popup_mode ( \"instant\" ) btn . set_icon ( icon ) return btn def set_default_action ( self , action ): self . setDefaultAction ( action ) def set_popup_mode ( self , mode : PopupModeStr ): \"\"\"Set the popup mode of the toolbutton. Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODE : raise InvalidParamError ( mode , POPUP_MODE ) self . setPopupMode ( POPUP_MODE [ mode ]) def get_popup_mode ( self ) -> PopupModeStr : \"\"\"Return popup mode. Returns: popup mode \"\"\" return POPUP_MODE . inverse [ self . popupMode ()] def set_arrow_type ( self , mode : constants . ArrowTypeStr ): \"\"\"Set the arrow type of the toolbutton. Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in constants . ARROW_TYPE : raise InvalidParamError ( mode , constants . ARROW_TYPE ) self . setArrowType ( constants . ARROW_TYPE [ mode ]) def get_arrow_type ( self ) -> constants . ArrowTypeStr : \"\"\"Return arrow type. Returns: arrow type \"\"\" return constants . ARROW_TYPE . inverse [ self . arrowType ()] def set_style ( self , style : constants . ToolButtonStyleStr ): \"\"\"Set the toolbutton style. Args: style: style to use Raises: InvalidParamError: invalid style \"\"\" if style not in constants . TOOLBUTTON_STYLE : raise InvalidParamError ( style , constants . TOOLBUTTON_STYLE ) self . setToolButtonStyle ( constants . TOOLBUTTON_STYLE [ style ]) def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return toolbutton style. Returns: toolbutton style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()]","title":"ToolButton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_arrow_type","text":"Return arrow type. Returns: Type Description constants.ArrowTypeStr arrow type Source code in prettyqt/widgets/toolbutton.py def get_arrow_type ( self ) -> constants . ArrowTypeStr : \"\"\"Return arrow type. Returns: arrow type \"\"\" return constants . ARROW_TYPE . inverse [ self . arrowType ()]","title":"get_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_popup_mode","text":"Return popup mode. Returns: Type Description PopupModeStr popup mode Source code in prettyqt/widgets/toolbutton.py def get_popup_mode ( self ) -> PopupModeStr : \"\"\"Return popup mode. Returns: popup mode \"\"\" return POPUP_MODE . inverse [ self . popupMode ()]","title":"get_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_style","text":"Return toolbutton style. Returns: Type Description constants.ToolButtonStyleStr toolbutton style Source code in prettyqt/widgets/toolbutton.py def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return toolbutton style. Returns: toolbutton style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()]","title":"get_style()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_arrow_type","text":"Set the arrow type of the toolbutton. Parameters: Name Type Description Default mode constants.ArrowTypeStr arrow type to use required Exceptions: Type Description InvalidParamError invalid arrow type Source code in prettyqt/widgets/toolbutton.py def set_arrow_type ( self , mode : constants . ArrowTypeStr ): \"\"\"Set the arrow type of the toolbutton. Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in constants . ARROW_TYPE : raise InvalidParamError ( mode , constants . ARROW_TYPE ) self . setArrowType ( constants . ARROW_TYPE [ mode ])","title":"set_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_popup_mode","text":"Set the popup mode of the toolbutton. Parameters: Name Type Description Default mode PopupModeStr popup mode to use required Exceptions: Type Description InvalidParamError invalid popup mode Source code in prettyqt/widgets/toolbutton.py def set_popup_mode ( self , mode : PopupModeStr ): \"\"\"Set the popup mode of the toolbutton. Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODE : raise InvalidParamError ( mode , POPUP_MODE ) self . setPopupMode ( POPUP_MODE [ mode ])","title":"set_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_style","text":"Set the toolbutton style. Parameters: Name Type Description Default style constants.ToolButtonStyleStr style to use required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/widgets/toolbutton.py def set_style ( self , style : constants . ToolButtonStyleStr ): \"\"\"Set the toolbutton style. Args: style: style to use Raises: InvalidParamError: invalid style \"\"\" if style not in constants . TOOLBUTTON_STYLE : raise InvalidParamError ( style , constants . TOOLBUTTON_STYLE ) self . setToolButtonStyle ( constants . TOOLBUTTON_STYLE [ style ])","title":"set_style()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem","text":"","title":"treewidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem","text":"Source code in prettyqt/widgets/treewidgetitem.py class TreeWidgetItem ( QtWidgets . QTreeWidgetItem ): def __repr__ ( self ): return f \" { type ( self ) . __name__ } ()\" def serialize_fields ( self ): data = [ self . data ( i , constants . USER_ROLE ) # type: ignore for i in range ( self . columnCount ()) ] return dict ( text = [ self . text ( i ) for i in range ( self . columnCount ())], tool_tip = [ self . toolTip ( i ) for i in range ( self . columnCount ())], status_tip = [ self . statusTip ( i ) for i in range ( self . columnCount ())], checkstate = [ self . get_checkstate ( i ) for i in range ( self . columnCount ())], icon = [ self . get_icon ( i ) for i in range ( self . columnCount ())], data = data , ) def __getstate__ ( self ): return bytes ( self ) def __setstate__ ( self , ba ): core . DataStream . write_bytearray ( ba , self ) def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def __bytes__ ( self ): ba = core . DataStream . create_bytearray ( self ) return bytes ( ba ) def __iter__ ( self ) -> Iterator [ QtWidgets . QTreeWidgetItem ]: return iter ( self . child ( i ) for i in range ( self . childCount ())) def __len__ ( self ): return self . childCount () def __getitem__ ( self , index : int ) -> QtWidgets . QTreeWidgetItem : item = self . child ( index ) if item is None : raise KeyError ( index ) return item def __delitem__ ( self , index : int ): self . takeChild ( index ) def __add__ ( self , other : QtWidgets . QTreeWidgetItem ) -> TreeWidgetItem : self . addChild ( other ) return self def set_size_hint ( self , hint : types . SizeType , column : int = 0 ): if isinstance ( hint , tuple ): hint = QtCore . QSize ( * hint ) self . setSizeHint ( column , hint ) def sort_children ( self , column : int , descending : bool = False ): order = constants . DESCENDING if descending else constants . ASCENDING self . sortChildren ( column , order ) def set_icon ( self , icon : types . IconType , column : int = 0 ): \"\"\"Set the icon for the action. Args: icon: icon to use column: column \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( column , icon ) def get_background ( self , column : int = 0 ) -> gui . Brush : return gui . Brush ( self . background ( column )) def get_foreground ( self , column : int = 0 ) -> gui . Brush : return gui . Brush ( self . foreground ( column )) def get_font ( self , column : int = 0 ) -> gui . Font : return gui . Font ( self . font ( column )) def get_icon ( self , column : int = 0 ) -> gui . Icon | None : icon = self . icon ( column ) if icon . isNull (): return None return gui . Icon ( icon ) def set_checkstate ( self , state : constants . StateStr , column : int = 0 ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use column: column Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( column , constants . STATE [ state ]) def get_checkstate ( self , column : int = 0 ) -> constants . StateStr : \"\"\"Return checkstate. Args: column: column Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ( column )] def set_child_indicator_policy ( self , policy : ChildIndicatorPolicyStr ): \"\"\"Set the child indicator policy. Args: policy: child indicator policy Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CHILD_INDICATOR_POLICY : raise InvalidParamError ( policy , CHILD_INDICATOR_POLICY ) self . setChildIndicatorPolicy ( CHILD_INDICATOR_POLICY [ policy ]) def get_child_indicator_policy ( self ) -> ChildIndicatorPolicyStr : \"\"\"Return current child indicator policy. Returns: child indicator policy \"\"\" return CHILD_INDICATOR_POLICY . inverse [ self . childIndicatorPolicy ()]","title":"TreeWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_checkstate","text":"Return checkstate. Parameters: Name Type Description Default column int column 0 Returns: Type Description constants.StateStr checkstate Source code in prettyqt/widgets/treewidgetitem.py def get_checkstate ( self , column : int = 0 ) -> constants . StateStr : \"\"\"Return checkstate. Args: column: column Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ( column )]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_child_indicator_policy","text":"Return current child indicator policy. Returns: Type Description ChildIndicatorPolicyStr child indicator policy Source code in prettyqt/widgets/treewidgetitem.py def get_child_indicator_policy ( self ) -> ChildIndicatorPolicyStr : \"\"\"Return current child indicator policy. Returns: child indicator policy \"\"\" return CHILD_INDICATOR_POLICY . inverse [ self . childIndicatorPolicy ()]","title":"get_child_indicator_policy()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required column int column 0 Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py def set_checkstate ( self , state : constants . StateStr , column : int = 0 ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use column: column Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( column , constants . STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_child_indicator_policy","text":"Set the child indicator policy. Parameters: Name Type Description Default policy ChildIndicatorPolicyStr child indicator policy required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/treewidgetitem.py def set_child_indicator_policy ( self , policy : ChildIndicatorPolicyStr ): \"\"\"Set the child indicator policy. Args: policy: child indicator policy Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CHILD_INDICATOR_POLICY : raise InvalidParamError ( policy , CHILD_INDICATOR_POLICY ) self . setChildIndicatorPolicy ( CHILD_INDICATOR_POLICY [ policy ])","title":"set_child_indicator_policy()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon types.IconType icon to use required column int column 0 Source code in prettyqt/widgets/treewidgetitem.py def set_icon ( self , icon : types . IconType , column : int = 0 ): \"\"\"Set the icon for the action. Args: icon: icon to use column: column \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( column , icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.undoview","text":"","title":"undoview"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView","text":"Source code in prettyqt/widgets/undoview.py class UndoView ( QtWidgets . QUndoView ): def __getitem__ ( self , index : int ) -> QtWidgets . QUndoCommand : return self . stack () . command ( index ) def set_clean_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setCleanIcon ( icon ) def set_value ( self , value : QtWidgets . QUndoGroup | QtWidgets . QUndoStack ): if isinstance ( value , QtWidgets . QUndoGroup ): self . setGroup ( value ) else : self . setStack ( value )","title":"UndoView"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView.set_clean_icon","text":"Set the icon for the clean button. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/undoview.py def set_clean_icon ( self , icon : types . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setCleanIcon ( icon )","title":"set_clean_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget","text":"","title":"widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget","text":"Source code in prettyqt/widgets/widget.py class Widget ( prettyprinter . PrettyPrinter , QtWidgets . QWidget ): box : QtWidgets . QLayout def __repr__ ( self ) -> str : cls_name = type ( self ) . __name__ params = helpers . format_kwargs ( self . serialize_fields ()) return f \" { cls_name } ( { params } )\" def __setstate__ ( self , state : dict [ str , Any ]) -> None : if self . layout () is None : self . set_layout ( state [ \"layout\" ]) self . setSizePolicy ( state [ \"size_policy\" ]) self . setAccessibleName ( state [ \"accessible_name\" ]) self . setToolTip ( state . get ( \"tool_tip\" , \"\" )) self . setToolTipDuration ( state . get ( \"tooltip_duration\" , \"\" )) self . setWindowTitle ( state . get ( \"window_title\" , \"\" )) self . setWindowFilePath ( state . get ( \"window_file_path\" , \"\" )) self . setEnabled ( state . get ( \"enabled\" , True )) self . setVisible ( state . get ( \"visible\" , True )) self . setTabletTracking ( state . get ( \"tablet_tracking\" , True )) self . setWindowModified ( state . get ( \"window_modified\" , False )) self . setWindowOpacity ( state . get ( \"window_opacity\" , 1.0 )) self . set_icon ( state . get ( \"icon\" )) self . set_modality ( state . get ( \"modality\" , \"\" )) self . setWhatsThis ( state . get ( \"whats_this\" , \"\" )) self . set_context_menu_policy ( state . get ( \"contextmenu_policy\" , \"\" )) self . set_focus_policy ( state . get ( \"focus_policy\" , \"\" )) self . setStatusTip ( state . get ( \"status_tip\" , \"\" )) self . setStyleSheet ( state . get ( \"stylesheet\" , \"\" )) self . setFont ( state . get ( \"font\" , \"\" )) if state [ \"is_maximized\" ]: self . showMaximized () def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () def serialize_fields ( self ) -> dict [ str , Any ]: return dict ( layout = self . layout () if isinstance ( self . layout (), widgets . Layout ) else None , size_policy = self . get_size_policy (), is_maximized = self . isMaximized (), actions = self . actions (), accessible_name = self . accessibleName (), tool_tip = self . toolTip (), tooltip_duration = self . toolTipDuration (), window_title = self . windowTitle (), window_file_path = self . windowFilePath (), enabled = self . isEnabled (), tablet_tracking = self . hasTabletTracking (), window_modified = self . isWindowModified (), window_opacity = self . windowOpacity (), visible = self . isVisible (), stylesheet = self . styleSheet (), icon = self . get_icon (), modality = self . get_modality (), whats_this = self . whatsThis (), contextmenu_policy = self . get_context_menu_policy (), focus_policy = self . get_focus_policy (), status_tip = self . statusTip (), font = self . get_font (), ) def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size ) def raise_to_top ( self ): if sys . platform . startswith ( \"win\" ): import win32con from win32gui import SetWindowPos # set to always-on-top and disable it again. that way windows stays in front flag = win32con . SWP_NOMOVE | win32con . SWP_NOSIZE | win32con . SWP_SHOWWINDOW win_id = self . winId () SetWindowPos ( win_id , win32con . HWND_TOPMOST , 0 , 0 , 0 , 0 , flag ) SetWindowPos ( win_id , win32con . HWND_NOTOPMOST , 0 , 0 , 0 , 0 , flag ) # state = (self.windowState() & ~Qt.WindowMinimized) | Qt.WindowActive # self.setWindowState(state) self . raise_ () self . show () self . activateWindow () def set_icon ( self , icon : types . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) def get_icon ( self ) -> gui . Icon | None : icon = self . windowIcon () if icon . isNull (): return None return gui . Icon ( self . windowIcon ()) def set_min_size ( self , * size ) -> None : self . setMinimumSize ( * size ) def set_max_size ( self , * size ) -> None : self . setMaximumSize ( * size ) def set_min_width ( self , width : int | None ) -> None : if width is None : width = 0 self . setMinimumWidth ( width ) def set_max_width ( self , width : int | None ) -> None : if width is None : width = 16777215 # QtWidgets.QWIDGETSIZE_MAX self . setMaximumWidth ( width ) def set_min_height ( self , height : int | None ) -> None : if height is None : height = 0 self . setMinimumHeight ( height ) def set_max_height ( self , height : int | None ) -> None : if height is None : height = 16777215 # QtWidgets.QWIDGETSIZE_MAX self . setMaximumHeight ( height ) @property def title ( self ) -> str : return self . windowTitle () @title . setter def title ( self , name : str ): self . setWindowTitle ( name ) @property def enabled ( self ) -> bool : return self . isEnabled () @enabled . setter def enabled ( self , state : bool ): self . setEnabled ( state ) def set_enabled ( self , enabled : bool = True ) -> None : self . setEnabled ( enabled ) def set_disabled ( self ) -> None : self . setEnabled ( False ) def set_title ( self , title : str ) -> None : self . setWindowTitle ( title ) def get_title ( self ) -> str : return self . windowTitle () def set_tooltip ( self , tooltip : str | types . PathType , size : types . SizeType | None = None , ): if isinstance ( tooltip , os . PathLike ): path = os . fspath ( tooltip ) if size is None : tooltip = f \"<img src= { path !r} >\" else : if isinstance ( size , QtCore . QSize ): size = ( size . width (), size . height ()) tooltip = f '<img src= { path !r} width=\" { size [ 0 ] } \" height=\" { size [ 1 ] } \">' self . setToolTip ( tooltip ) def set_font ( self , font_name : str | None = None , font_size : int | None = None , weight : int | None = None , italic : bool = False , ) -> gui . Font : if font_size is None : font_size = - 1 if weight is None : weight = - 1 if font_name is None : font_name = self . font () . family () font = gui . Font ( font_name , font_size , weight , italic ) self . setFont ( font ) return font def get_font ( self ) -> gui . Font : return gui . Font ( self . font ()) def get_foreground_role ( self ) -> gui . palette . RoleStr : return gui . palette . ROLE . inverse [ self . foregroundRole ()] def set_foreground_role ( self , role : gui . palette . RoleStr ): if role not in gui . palette . ROLE : raise InvalidParamError ( role , gui . palette . ROLE ) self . setForegroundRole ( gui . palette . ROLE [ role ]) def get_background_role ( self ) -> gui . palette . RoleStr : return gui . palette . ROLE . inverse [ self . backgroundRole ()] def set_background_role ( self , role : gui . palette . RoleStr ): if role not in gui . palette . ROLE : raise InvalidParamError ( role , gui . palette . ROLE ) self . setBackgroundRole ( gui . palette . ROLE [ role ]) def set_window_flags ( self , * flags : constants . WindowFlagStr , append : bool = False ): for flag in flags : if flag not in constants . WINDOW_FLAGS : raise InvalidParamError ( flag , constants . WINDOW_FLAGS ) result = helpers . merge_flags ( flags , constants . WINDOW_FLAGS ) if append : result = result | self . windowFlags () self . setWindowFlags ( result ) def set_flags ( self , minimize : bool | None = None , maximize : bool | None = None , close : bool | None = None , stay_on_top : bool | None = None , frameless : bool | None = None , window : bool | None = None , dialog : bool | None = None , tooltip : bool | None = None , tool : bool | None = None , customize : bool | None = None , window_title : bool | None = None , ) -> None : if minimize is not None : self . setWindowFlag ( QtCore . Qt . WindowType . WindowMinimizeButtonHint , minimize ) if maximize is not None : self . setWindowFlag ( QtCore . Qt . WindowType . WindowMaximizeButtonHint , maximize ) if close is not None : self . setWindowFlag ( QtCore . Qt . WindowType . WindowCloseButtonHint , close ) if stay_on_top is not None : self . setWindowFlag ( QtCore . Qt . WindowType . WindowStaysOnTopHint , stay_on_top ) if frameless is not None : self . setWindowFlag ( QtCore . Qt . WindowType . FramelessWindowHint , frameless ) if window is not None : self . setWindowFlag ( QtCore . Qt . WindowType . Window , window ) if dialog is not None : self . setWindowFlag ( QtCore . Qt . WindowType . Dialog , dialog ) if tooltip is not None : self . setWindowFlag ( QtCore . Qt . WindowType . ToolTip , tooltip ) if tool is not None : self . setWindowFlag ( QtCore . Qt . WindowType . Tool , tool ) if customize is not None : self . setWindowFlag ( QtCore . Qt . WindowType . CustomizeWindowHint , customize ) if window_title is not None : self . setWindowFlag ( QtCore . Qt . WindowType . WindowTitleHint , window_title ) def set_attribute ( self , attribute : constants . WidgetAttributeStr , state : bool = True ) -> None : if attribute not in constants . WIDGET_ATTRIBUTE : raise InvalidParamError ( attribute , constants . WIDGET_ATTRIBUTE ) self . setAttribute ( constants . WIDGET_ATTRIBUTE [ attribute ], state ) def set_attributes ( self , ** kwargs : bool ) -> None : for attr , state in kwargs . items (): if attr not in constants . WIDGET_ATTRIBUTE : raise InvalidParamError ( attr , constants . WIDGET_ATTRIBUTE ) self . setAttribute ( constants . WIDGET_ATTRIBUTE [ attr ], state ) # type: ignore def set_modality ( self , modality : constants . ModalityStr ) -> None : \"\"\"Set modality for the dialog. Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in constants . MODALITY : raise InvalidParamError ( modality , constants . MODALITY ) self . setWindowModality ( constants . MODALITY [ modality ]) def get_modality ( self ) -> constants . ModalityStr : \"\"\"Get the current modality modes as a string. Returns: modality mode \"\"\" return constants . MODALITY . inverse [ self . windowModality ()] def set_size_policy ( self , horizontal : widgets . sizepolicy . SizePolicyStr | None = None , vertical : widgets . sizepolicy . SizePolicyStr | None = None , ) -> None : \"\"\"Set the sizes policy. Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp ) def get_size_policy ( self ) -> widgets . SizePolicy : qpol = self . sizePolicy () if isinstance ( qpol , widgets . SizePolicy ): return qpol return widgets . SizePolicy . clone ( qpol ) def get_palette ( self ) -> gui . Palette : return gui . Palette ( self . palette ()) def set_background_color ( self , color : types . ColorType ) -> None : col_str = \"\" if color is None else colors . get_color ( color ) . name () with self . edit_stylesheet () as ss : ss . backgroundColor . setValue ( col_str ) @contextlib . contextmanager def updates_off ( self ) -> Iterator [ None ]: updates = self . updatesEnabled () self . setUpdatesEnabled ( False ) yield None self . setUpdatesEnabled ( updates ) @contextlib . contextmanager def edit_stylesheet ( self ) -> Iterator [ qstylizer . style . StyleSheet ]: ss = self . get_stylesheet () yield ss self . set_stylesheet ( ss ) def set_stylesheet ( self , ss : None | str | qstylizer . style . StyleSheet | types . PathType ): if isinstance ( ss , os . PathLike ): ss = pathlib . Path ( ss ) . read_text () elif ss is None : ss = \"\" self . setStyleSheet ( str ( ss )) def get_stylesheet ( self ) -> qstylizer . style . StyleSheet : try : return qstylizer . parser . parse ( self . styleSheet ()) except ValueError : return qstylizer . style . StyleSheet () @contextlib . contextmanager def edit_palette ( self ) -> Iterator [ gui . Palette ]: palette = gui . Palette ( self . palette ()) yield palette self . setPalette ( palette ) @contextlib . contextmanager def edit_font ( self ) -> Iterator [ gui . Font ]: font = gui . Font ( self . font ()) yield font self . setFont ( font ) @deprecated ( reason = \"This context manager is deprecated, use edit_font instead.\" ) @contextlib . contextmanager def current_font ( self ) -> Iterator [ gui . Font ]: with self . edit_font () as font : yield font @deprecated ( reason = \"This method is deprecated, use set_context_menu_policy instead.\" ) def set_contextmenu_policy ( self , policy : constants . ContextPolicyStr ) -> None : return self . set_context_menu_policy ( policy ) def set_context_menu_policy ( self , policy : constants . ContextPolicyStr ) -> None : \"\"\"Set contextmenu policy for given item view. Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . CONTEXT_POLICY : raise InvalidParamError ( policy , constants . CONTEXT_POLICY ) self . setContextMenuPolicy ( constants . CONTEXT_POLICY [ policy ]) @deprecated ( reason = \"This method is deprecated, use get_context_menu_policy instead.\" ) def get_contextmenu_policy ( self ) -> constants . ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return self . get_context_menu_policy () def get_context_menu_policy ( self ) -> constants . ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return constants . CONTEXT_POLICY . inverse [ self . contextMenuPolicy ()] def set_window_state ( self , policy : constants . WindowStateStr ) -> None : \"\"\"Set window state for given item view. Args: policy: window state to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . WINDOW_STATES : raise InvalidParamError ( policy , constants . WINDOW_STATES ) self . setWindowState ( constants . WINDOW_STATES [ policy ]) def get_window_state ( self ) -> constants . WindowStateStr : \"\"\"Return current window state. Returns: window state \"\"\" return constants . WINDOW_STATES . inverse [ self . windowState ()] def set_custom_menu ( self , method : Callable ) -> None : self . set_context_menu_policy ( \"custom\" ) self . customContextMenuRequested . connect ( method ) def set_layout ( self , layout : LayoutStr | QtWidgets . QLayout | None , margin : int | None = None , spacing : int | None = None , ): if layout is None : return if layout == \"horizontal\" : self . box = widgets . BoxLayout ( \"horizontal\" ) elif layout == \"vertical\" : self . box = widgets . BoxLayout ( \"vertical\" ) elif layout == \"grid\" : self . box = widgets . GridLayout () elif layout == \"form\" : self . box = widgets . FormLayout () elif layout == \"stacked\" : self . box = widgets . StackedLayout () elif layout == \"flow\" : from prettyqt import custom_widgets self . box = custom_widgets . FlowLayout () elif isinstance ( layout , QtWidgets . QLayout ): self . box = layout else : raise ValueError ( \"Invalid Layout\" ) self . setLayout ( self . box ) if margin is not None : self . box . set_margin ( margin ) if spacing is not None : self . box . setSpacing ( spacing ) def center ( self , screen : int = 0 ) -> None : qr = self . frameGeometry () cp = gui . GuiApplication . screens ()[ screen ] . geometry () . center () qr . moveCenter ( cp ) self . move ( qr . topLeft ()) def set_cursor ( self , cursor : constants . CursorShapeStr | QtGui . QCursor ) -> None : if isinstance ( cursor , QtGui . QCursor ): curs = cursor else : if cursor not in constants . CURSOR_SHAPE : raise InvalidParamError ( cursor , constants . CURSOR_SHAPE ) curs = gui . Cursor ( constants . CURSOR_SHAPE [ cursor ]) self . setCursor ( curs ) def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ]) def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return waay the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()] def set_font_size ( self , size : int ) -> None : font = self . font () font . setPointSize ( size ) self . setFont ( font ) @deprecated ( reason = \"This method is deprecated, use get_font_metrics instead.\" ) def font_metrics ( self ) -> gui . FontMetrics : return self . get_font_metrics () def get_font_metrics ( self ) -> gui . FontMetrics : return gui . FontMetrics ( self . fontMetrics ()) def get_font_info ( self ) -> gui . FontInfo : return gui . FontInfo ( self . fontInfo ()) def set_margin ( self , margin : int ) -> None : self . setContentsMargins ( margin , margin , margin , margin ) def raise_dock ( self ) -> bool : w = self . find_parent ( QtWidgets . QDockWidget ) if w is None : return False w . setVisible ( True ) w . raise_ () return True def set_mask ( self , area : types . RectType | QtGui . QRegion | None , typ : gui . region . RegionTypeStr = \"rectangle\" , ): if area is None : self . clearMask () return if isinstance ( area , tuple ): area = QtCore . QRect ( * area ) if isinstance ( area , QtCore . QRect ): area = gui . Region ( area , gui . region . REGION_TYPE [ typ ]) self . setMask ( area ) def set_window_file_path ( self , path : types . PathType ): self . setWindowFilePath ( os . fspath ( path )) def get_window_file_path ( self ) -> pathlib . Path | None : path = self . windowFilePath () if not path : return None return pathlib . Path ( path ) def get_screen ( self ) -> gui . Screen | None : window = self . window () . windowHandle () if window is None : return None return gui . Screen ( window . screen ())","title":"Widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_context_menu_policy","text":"Return current contextmenu policy. Returns: Type Description constants.ContextPolicyStr contextmenu policy Source code in prettyqt/widgets/widget.py def get_context_menu_policy ( self ) -> constants . ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return constants . CONTEXT_POLICY . inverse [ self . contextMenuPolicy ()]","title":"get_context_menu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_contextmenu_policy","text":"Return current contextmenu policy. Returns: Type Description constants.ContextPolicyStr contextmenu policy Source code in prettyqt/widgets/widget.py @deprecated ( reason = \"This method is deprecated, use get_context_menu_policy instead.\" ) def get_contextmenu_policy ( self ) -> constants . ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return self . get_context_menu_policy ()","title":"get_contextmenu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_focus_policy","text":"Return waay the widget accepts keyboard focus. Returns: Type Description str Focus policy Source code in prettyqt/widgets/widget.py def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return waay the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()]","title":"get_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_modality","text":"Get the current modality modes as a string. Returns: Type Description constants.ModalityStr modality mode Source code in prettyqt/widgets/widget.py def get_modality ( self ) -> constants . ModalityStr : \"\"\"Get the current modality modes as a string. Returns: modality mode \"\"\" return constants . MODALITY . inverse [ self . windowModality ()]","title":"get_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_window_state","text":"Return current window state. Returns: Type Description constants.WindowStateStr window state Source code in prettyqt/widgets/widget.py def get_window_state ( self ) -> constants . WindowStateStr : \"\"\"Return current window state. Returns: window state \"\"\" return constants . WINDOW_STATES . inverse [ self . windowState ()]","title":"get_window_state()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.resize","text":"resize(self, arg__1: PySide6.QtCore.QSize) -> None resize(self, w: int, h: int) -> None Source code in prettyqt/widgets/widget.py def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size )","title":"resize()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_context_menu_policy","text":"Set contextmenu policy for given item view. Parameters: Name Type Description Default policy constants.ContextPolicyStr contextmenu policy to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_context_menu_policy ( self , policy : constants . ContextPolicyStr ) -> None : \"\"\"Set contextmenu policy for given item view. Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . CONTEXT_POLICY : raise InvalidParamError ( policy , constants . CONTEXT_POLICY ) self . setContextMenuPolicy ( constants . CONTEXT_POLICY [ policy ])","title":"set_context_menu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_focus_policy","text":"Set the way the widget accepts keyboard focus. Parameters: Name Type Description Default policy str Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/widget.py def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ])","title":"set_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_icon","text":"Set the window icon. Parameters: Name Type Description Default icon types.IconType icon to use required Source code in prettyqt/widgets/widget.py def set_icon ( self , icon : types . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_modality","text":"Set modality for the dialog. Parameters: Name Type Description Default modality constants.ModalityStr modality for the main window required Exceptions: Type Description InvalidParamError modality type does not exist Source code in prettyqt/widgets/widget.py def set_modality ( self , modality : constants . ModalityStr ) -> None : \"\"\"Set modality for the dialog. Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in constants . MODALITY : raise InvalidParamError ( modality , constants . MODALITY ) self . setWindowModality ( constants . MODALITY [ modality ])","title":"set_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_size_policy","text":"Set the sizes policy. Parameters: Name Type Description Default horizontal widgets.sizepolicy.SizePolicyStr | None horizontal size policy None vertical widgets.sizepolicy.SizePolicyStr | None vertical size policy None Source code in prettyqt/widgets/widget.py def set_size_policy ( self , horizontal : widgets . sizepolicy . SizePolicyStr | None = None , vertical : widgets . sizepolicy . SizePolicyStr | None = None , ) -> None : \"\"\"Set the sizes policy. Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp )","title":"set_size_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_window_state","text":"Set window state for given item view. Parameters: Name Type Description Default policy constants.WindowStateStr window state to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_window_state ( self , policy : constants . WindowStateStr ) -> None : \"\"\"Set window state for given item view. Args: policy: window state to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . WINDOW_STATES : raise InvalidParamError ( policy , constants . WINDOW_STATES ) self . setWindowState ( constants . WINDOW_STATES [ policy ])","title":"set_window_state()"},{"location":"api/widgets.html#prettyqt.widgets.wizard","text":"","title":"wizard"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard","text":"Source code in prettyqt/widgets/wizard.py class Wizard ( QtWidgets . QWizard ): def __getitem__ ( self , key : int ) -> QtWidgets . QWizardPage : p = self . page ( key ) if p is None : raise KeyError ( key ) return p def __setitem__ ( self , key : int , value : QtWidgets . QWizardPage ): return self . setPage ( key , value ) def __delitem__ ( self , key : int ): if key not in self . pageIds (): raise KeyError ( key ) return self . removePage ( key ) def __iter__ ( self ) -> Iterator [ QtWidgets . QWizardPage ]: return iter ( self . page ( i ) for i in self . pageIds ()) def __add__ ( self , other : QtWidgets . QWizardPage ) -> Wizard : self . addPage ( other ) return self def serialize_fields ( self ): return dict ( current_id = self . currentId (), start_id = self . startId (), sub_title_format = self . get_subtitle_format (), title_format = self . get_title_format (), wizard_style = self . get_wizard_style (), ) def add_widget_as_page ( self , widget : QtWidgets . QWidget ) -> None : page = widgets . WizardPage ( self ) layout = widgets . BoxLayout ( \"vertical\" , self ) layout += widget page . set_layout ( layout ) def set_title_format ( self , fmt : TextFormatStr ): \"\"\"Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: title format to use Raises: InvalidParamError: title format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setTitleFormat ( TEXT_FORMATS [ fmt ]) def get_title_format ( self ) -> TextFormatStr : \"\"\"Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: title format \"\"\" return TEXT_FORMATS . inverse [ self . titleFormat ()] def set_subtitle_format ( self , fmt : TextFormatStr ): \"\"\"Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: subtitle format to use Raises: InvalidParamError: subtitle format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setSubTitleFormat ( TEXT_FORMATS [ fmt ]) def get_subtitle_format ( self ) -> TextFormatStr : \"\"\"Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: subtitle format \"\"\" return TEXT_FORMATS . inverse [ self . subTitleFormat ()] def get_button ( self , button_type : WizardButtonStr ) -> QtWidgets . QAbstractButton : if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . button ( WIZARD_BUTTON [ button_type ]) def set_button_text ( self , button_type : WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) self . setButtonText ( WIZARD_BUTTON [ button_type ], value ) def get_button_text ( self , button_type : WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . buttonText ( WIZARD_BUTTON [ button_type ]) def set_pixmap ( self , typ : WizardPixmapStr , pixmap : QtGui . QPixmap | None ): if typ not in WIZARD_PIXMAP : raise InvalidParamError ( typ , WIZARD_PIXMAP ) if pixmap is None : pixmap = QtGui . QPixmap () self . setPixmap ( WIZARD_PIXMAP [ typ ], pixmap ) def get_pixmap ( self , typ : WizardPixmapStr ) -> gui . Pixmap | None : if typ not in WIZARD_PIXMAP : raise InvalidParamError ( typ , WIZARD_PIXMAP ) pix = gui . Pixmap ( self . pixmap ( WIZARD_PIXMAP [ typ ])) if pix . isNull (): return None return pix def set_wizard_style ( self , style : WizardStyleStr ): \"\"\"Set the wizard style. Args: style: wizard style Raises: InvalidParamError: wizard style does not exist \"\"\" if style not in WIZARD_STYLE : raise InvalidParamError ( style , WIZARD_STYLE ) self . setWizardStyle ( WIZARD_STYLE [ style ]) def get_wizard_style ( self ) -> WizardStyleStr : \"\"\"Return current wizard style. Returns: Wizard style \"\"\" return WIZARD_STYLE . inverse [ self . wizardStyle ()] def set_option ( self , option : WizardOptionStr , value : bool ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) self . setOption ( WIZARD_OPTIONS [ option ], value ) def get_option ( self , option : WizardOptionStr ) -> bool : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) return self . testOption ( WIZARD_OPTIONS [ option ])","title":"Wizard"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_button_text","text":"Return text for given button type. Parameters: Name Type Description Default button_type WizardButtonStr button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizard.py def get_button_text ( self , button_type : WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . buttonText ( WIZARD_BUTTON [ button_type ])","title":"get_button_text()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_option","text":"Return the value assigned to option. Parameters: Name Type Description Default option WizardOptionStr option to get required Returns: Type Description bool option Source code in prettyqt/widgets/wizard.py def get_option ( self , option : WizardOptionStr ) -> bool : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) return self . testOption ( WIZARD_OPTIONS [ option ])","title":"get_option()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_subtitle_format","text":"Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description TextFormatStr subtitle format Source code in prettyqt/widgets/wizard.py def get_subtitle_format ( self ) -> TextFormatStr : \"\"\"Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: subtitle format \"\"\" return TEXT_FORMATS . inverse [ self . subTitleFormat ()]","title":"get_subtitle_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_title_format","text":"Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description TextFormatStr title format Source code in prettyqt/widgets/wizard.py def get_title_format ( self ) -> TextFormatStr : \"\"\"Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: title format \"\"\" return TEXT_FORMATS . inverse [ self . titleFormat ()]","title":"get_title_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_wizard_style","text":"Return current wizard style. Returns: Type Description WizardStyleStr Wizard style Source code in prettyqt/widgets/wizard.py def get_wizard_style ( self ) -> WizardStyleStr : \"\"\"Return current wizard style. Returns: Wizard style \"\"\" return WIZARD_STYLE . inverse [ self . wizardStyle ()]","title":"get_wizard_style()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_button_text","text":"Set text for given button type. Parameters: Name Type Description Default button_type WizardButtonStr button to get text from required value str text to set required Source code in prettyqt/widgets/wizard.py def set_button_text ( self , button_type : WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) self . setButtonText ( WIZARD_BUTTON [ button_type ], value )","title":"set_button_text()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_option","text":"Set option to given value. Parameters: Name Type Description Default option WizardOptionStr option to use required value bool value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/widgets/wizard.py def set_option ( self , option : WizardOptionStr , value : bool ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) self . setOption ( WIZARD_OPTIONS [ option ], value )","title":"set_option()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_subtitle_format","text":"Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt TextFormatStr subtitle format to use required Exceptions: Type Description InvalidParamError subtitle format does not exist Source code in prettyqt/widgets/wizard.py def set_subtitle_format ( self , fmt : TextFormatStr ): \"\"\"Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: subtitle format to use Raises: InvalidParamError: subtitle format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setSubTitleFormat ( TEXT_FORMATS [ fmt ])","title":"set_subtitle_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_title_format","text":"Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt TextFormatStr title format to use required Exceptions: Type Description InvalidParamError title format does not exist Source code in prettyqt/widgets/wizard.py def set_title_format ( self , fmt : TextFormatStr ): \"\"\"Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: title format to use Raises: InvalidParamError: title format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setTitleFormat ( TEXT_FORMATS [ fmt ])","title":"set_title_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_wizard_style","text":"Set the wizard style. Parameters: Name Type Description Default style WizardStyleStr wizard style required Exceptions: Type Description InvalidParamError wizard style does not exist Source code in prettyqt/widgets/wizard.py def set_wizard_style ( self , style : WizardStyleStr ): \"\"\"Set the wizard style. Args: style: wizard style Raises: InvalidParamError: wizard style does not exist \"\"\" if style not in WIZARD_STYLE : raise InvalidParamError ( style , WIZARD_STYLE ) self . setWizardStyle ( WIZARD_STYLE [ style ])","title":"set_wizard_style()"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage","text":"","title":"wizardpage"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPage","text":"Source code in prettyqt/widgets/wizardpage.py class WizardPage ( QtWidgets . QWizardPage ): def serialize_fields ( self ): return dict ( title = self . title (), sub_title = self . subTitle ()) def set_pixmap ( self , typ : widgets . wizard . WizardPixmapStr , pixmap : QtGui . QPixmap | None ): if typ not in widgets . wizard . WIZARD_PIXMAP : raise InvalidParamError ( typ , widgets . wizard . WIZARD_PIXMAP ) if pixmap is None : pixmap = QtGui . QPixmap () self . setPixmap ( widgets . wizard . WIZARD_PIXMAP [ typ ], pixmap ) def get_pixmap ( self , typ : widgets . wizard . WizardPixmapStr ) -> gui . Pixmap | None : if typ not in widgets . wizard . WIZARD_PIXMAP : raise InvalidParamError ( typ , widgets . wizard . WIZARD_PIXMAP ) pix = gui . Pixmap ( self . pixmap ( widgets . wizard . WIZARD_PIXMAP [ typ ])) if pix . isNull (): return None return pix def set_button_text ( self , button_type : widgets . wizard . WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) self . setButtonText ( widgets . wizard . WIZARD_BUTTON [ button_type ], value ) def get_button_text ( self , button_type : widgets . wizard . WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) return self . buttonText ( widgets . wizard . WIZARD_BUTTON [ button_type ])","title":"WizardPage"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPage.get_button_text","text":"Return text for given button type. Parameters: Name Type Description Default button_type widgets.wizard.WizardButtonStr button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizardpage.py def get_button_text ( self , button_type : widgets . wizard . WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) return self . buttonText ( widgets . wizard . WIZARD_BUTTON [ button_type ])","title":"get_button_text()"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPage.set_button_text","text":"Set text for given button type. Parameters: Name Type Description Default button_type widgets.wizard.WizardButtonStr button to get text from required value str text to set required Source code in prettyqt/widgets/wizardpage.py def set_button_text ( self , button_type : widgets . wizard . WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) self . setButtonText ( widgets . wizard . WIZARD_BUTTON [ button_type ], value )","title":"set_button_text()"}]}