{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"prettyqt: Pythonic layer on top of PyQt5 / PyQt6 / PySide6","text":""},{"location":"index.html#what-is-it","title":"What is it?","text":"<p>PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt6 / PySide6.</p>"},{"location":"index.html#main-features","title":"Main Features","text":"<p>Here are just a few of the things that PrettyQt does well:</p> <ul> <li>Large parts of the Qt API are available in a PEP-8-compliant way.</li> <li>Several predefined widgets, validators, models, syntax highlighters are included.</li> <li>A regex module based on QRegularExpression with the same API as Pythons core re module.</li> </ul>"},{"location":"index.html#where-to-get-it","title":"Where to get it","text":"<p>The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt</p> <p>The latest released version are available at the Python package index.</p> <pre><code># or PyPI\npip install prettyqt\n</code></pre>"},{"location":"index.html#dependencies","title":"Dependencies","text":"<ul> <li>bidict</li> <li>orjson</li> <li>regex</li> <li>docutils</li> </ul>"},{"location":"index.html#installation-from-sources","title":"Installation from sources","text":"<p>This project uses poetry for dependency management and packaging. Install this first. In the <code>prettyqt</code> directory (same one where you found this file after cloning the git repo), execute:</p> <pre><code>poetry install\n</code></pre>"},{"location":"index.html#license","title":"License","text":"<p>MIT</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/</p>"},{"location":"index.html#contributing-to-prettyqt","title":"Contributing to prettyqt","text":"<p>All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome.</p> <p>Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!</p>"},{"location":"changelog.html","title":"Changelog","text":""},{"location":"changelog.html#v1100-2023-04-18","title":"v1.10.0 (2023-04-18)","text":""},{"location":"changelog.html#feat","title":"Feat","text":"<ul> <li>ColumnItemModel: methods for setting data</li> <li>TreeItem: add iter method</li> </ul>"},{"location":"changelog.html#fix","title":"Fix","text":"<ul> <li>AttributeModel: checkstate instead of text for is_attribute</li> <li>UndoStack: raise KeyError instead of returning it</li> </ul>"},{"location":"changelog.html#v192-2023-04-17","title":"v1.9.2 (2023-04-17)","text":""},{"location":"changelog.html#fix_1","title":"Fix","text":"<ul> <li>StorageInfoModel: move some stuff to baseclass</li> </ul>"},{"location":"changelog.html#v191-2023-04-17","title":"v1.9.1 (2023-04-17)","text":""},{"location":"changelog.html#fix_2","title":"Fix","text":"<ul> <li>ColumnItemModel: fix wrong value for non-listed roles in data()</li> <li>ObjectBrowser: re-add DEFAULT_ATTR_DETAILS and inspected_node_is_visible</li> </ul>"},{"location":"changelog.html#v190-2023-04-17","title":"v1.9.0 (2023-04-17)","text":""},{"location":"changelog.html#feat_1","title":"Feat","text":"<ul> <li>custom_widgets: add FileTree class</li> <li>AbstractItemModel: add update_all method</li> </ul>"},{"location":"changelog.html#fix_3","title":"Fix","text":"<ul> <li>IconDelegate: fix exception when QIcon is passed</li> </ul>"},{"location":"changelog.html#v181-2023-04-17","title":"v1.8.1 (2023-04-17)","text":""},{"location":"changelog.html#fix_4","title":"Fix","text":"<ul> <li>user_data fix</li> </ul>"},{"location":"changelog.html#v180-2023-04-17","title":"v1.8.0 (2023-04-17)","text":""},{"location":"changelog.html#feat_2","title":"Feat","text":"<ul> <li>ColumnItemModel: add user_data to ColumnItems</li> </ul>"},{"location":"changelog.html#v171-2023-04-17","title":"v1.7.1 (2023-04-17)","text":""},{"location":"changelog.html#fix_5","title":"Fix","text":"<ul> <li>fix docs generation</li> </ul>"},{"location":"changelog.html#v170-2023-04-17","title":"v1.7.0 (2023-04-17)","text":""},{"location":"changelog.html#feat_3","title":"Feat","text":"<ul> <li>ColumnItemModel: add support for sort value and tooltips</li> <li>Widget: add grab_mouse_events / grab_keyboard_events context managers</li> <li>Painter: add some convenience methods</li> </ul>"},{"location":"changelog.html#v160-2023-04-16","title":"v1.6.0 (2023-04-16)","text":""},{"location":"changelog.html#feat_4","title":"Feat","text":"<ul> <li>Widget: add delete_children method</li> <li>Url: add is_special_url and _has_explicit_scheme methods</li> <li>Application: add set_style method</li> <li>Scrollbar: add scroll_to_next/previous_row methods</li> <li>Uuid: add to_string method</li> </ul>"},{"location":"changelog.html#fix_6","title":"Fix","text":"<ul> <li>Application: correct icon colors for new Qt built in dark mode (when using Fusion theme)</li> <li>ChartView: correct cursor shape for dragging movements</li> </ul>"},{"location":"changelog.html#v150-2023-04-13","title":"v1.5.0 (2023-04-13)","text":""},{"location":"changelog.html#feat_5","title":"Feat","text":"<ul> <li>TimeZone: add get_time_spec method</li> <li>TextDocument: add get/set_meta_information methods</li> <li>ListWidgetItem: add set_text_alignment method</li> <li>DirIterator: add get_file_path / get_file_info methods</li> </ul>"},{"location":"changelog.html#fix_7","title":"Fix","text":"<ul> <li>FileSystemModel: fix yield_child_indexes method</li> </ul>"},{"location":"changelog.html#v142-2023-04-12","title":"v1.4.2 (2023-04-12)","text":""},{"location":"changelog.html#fix_8","title":"Fix","text":"<ul> <li>only run tests on linux for now</li> </ul>"},{"location":"changelog.html#v141-2023-04-12","title":"v1.4.1 (2023-04-12)","text":""},{"location":"changelog.html#fix_9","title":"Fix","text":"<ul> <li>remove codecov from deps</li> </ul>"},{"location":"changelog.html#v140-2023-04-12","title":"v1.4.0 (2023-04-12)","text":""},{"location":"changelog.html#feat_6","title":"Feat","text":"<ul> <li>Color: add convert_to method</li> <li>Color: add get_spec method</li> <li>core: add KeyCombination class</li> <li>re-add qthelp module</li> </ul>"},{"location":"changelog.html#fix_10","title":"Fix","text":"<ul> <li>fixed Color.as_qt error with Qt6.5</li> </ul>"},{"location":"changelog.html#v130-2023-04-11","title":"v1.3.0 (2023-04-11)","text":""},{"location":"changelog.html#feat_7","title":"Feat","text":"<ul> <li>add some set_origin methods</li> <li>add some set_transform methods</li> <li>Brush: add set_style method</li> </ul>"},{"location":"changelog.html#v120-2023-04-11","title":"v1.2.0 (2023-04-11)","text":""},{"location":"changelog.html#feat_8","title":"Feat","text":"<ul> <li>re-enable texttospeech module</li> <li>gui: add AbstractFileIconProvider class</li> <li>core: add MetaType class</li> <li>gui: add StyleHints class</li> </ul>"},{"location":"changelog.html#fix_11","title":"Fix","text":"<ul> <li>correct filtering for Dir.get_entry_info_list</li> <li>Dir: explicitely use kwargs for entryList/entryInfoList calls</li> <li>prevent namespace collisions with builtin locale package</li> </ul>"},{"location":"changelog.html#v112-2023-04-10","title":"v1.1.2 (2023-04-10)","text":""},{"location":"changelog.html#fix_12","title":"Fix","text":"<ul> <li>always pass sys.argv to QCoreApplication etc</li> </ul>"},{"location":"changelog.html#v111-2023-04-10","title":"v1.1.1 (2023-04-10)","text":""},{"location":"changelog.html#fix_13","title":"Fix","text":"<ul> <li>Qt6 fixes for Dialog classes</li> </ul>"},{"location":"changelog.html#v110-2023-04-10","title":"v1.1.0 (2023-04-10)","text":""},{"location":"changelog.html#feat_9","title":"Feat","text":"<ul> <li>Image: add as_bytes method</li> </ul>"},{"location":"changelog.html#v100-2023-04-07","title":"v1.0.0 (2023-04-07)","text":""},{"location":"changelog.html#feat_10","title":"Feat","text":"<ul> <li>MultimediaWidgets for Qt6</li> <li>get rid of mro fuckery</li> <li>re-add location module</li> </ul>"},{"location":"changelog.html#fix_14","title":"Fix","text":"<ul> <li>remove title property for widgets</li> </ul>"},{"location":"changelog.html#v01933-2023-04-04","title":"v0.193.3 (2023-04-04)","text":""},{"location":"changelog.html#fix_15","title":"Fix","text":"<ul> <li>get rid of sre_constants warnings</li> </ul>"},{"location":"changelog.html#v01932-2023-02-04","title":"v0.193.2 (2023-02-04)","text":""},{"location":"changelog.html#fix_16","title":"Fix","text":"<ul> <li>correctly init dataclass for py3.11</li> <li>proper QDialog exec fix</li> </ul>"},{"location":"changelog.html#v01931-2022-11-18","title":"v0.193.1 (2022-11-18)","text":""},{"location":"changelog.html#fix_17","title":"Fix","text":"<ul> <li>exec_ fix for PyQt6</li> </ul>"},{"location":"changelog.html#v01930-2022-11-12","title":"v0.193.0 (2022-11-12)","text":""},{"location":"changelog.html#feat_11","title":"Feat","text":"<ul> <li>custom_models: add BaseNestedModel class</li> </ul>"},{"location":"changelog.html#v01921-2022-11-12","title":"v0.192.1 (2022-11-12)","text":""},{"location":"changelog.html#fix_18","title":"Fix","text":"<ul> <li>disable BaseModelMixin test for now</li> </ul>"},{"location":"changelog.html#v01920-2022-11-12","title":"v0.192.0 (2022-11-12)","text":""},{"location":"changelog.html#feat_12","title":"Feat","text":"<ul> <li>custom_models: add BaseListMixin class</li> </ul>"},{"location":"changelog.html#v01910-2022-11-10","title":"v0.191.0 (2022-11-10)","text":""},{"location":"changelog.html#feat_13","title":"Feat","text":"<ul> <li>custom_models: add BaseModelMixin class</li> </ul>"},{"location":"changelog.html#v01908-2022-11-09","title":"v0.190.8 (2022-11-09)","text":""},{"location":"changelog.html#fix_19","title":"Fix","text":"<ul> <li>better check for combobox set_editable method</li> </ul>"},{"location":"changelog.html#v01907-2022-11-08","title":"v0.190.7 (2022-11-08)","text":""},{"location":"changelog.html#fix_20","title":"Fix","text":"<ul> <li>Combobox: set Completer only when calling set_editable to avoid error message</li> </ul>"},{"location":"changelog.html#v01906-2022-11-03","title":"v0.190.6 (2022-11-03)","text":""},{"location":"changelog.html#fix_21","title":"Fix","text":"<ul> <li>proper fix for restoreState</li> </ul>"},{"location":"changelog.html#v01905-2022-11-03","title":"v0.190.5 (2022-11-03)","text":""},{"location":"changelog.html#fix_22","title":"Fix","text":"<ul> <li>allow str for restoreState</li> </ul>"},{"location":"changelog.html#v01904-2022-11-03","title":"v0.190.4 (2022-11-03)","text":""},{"location":"changelog.html#fix_23","title":"Fix","text":"<ul> <li>qt compat</li> <li>some compat fixes</li> <li>qt6 flag compat</li> <li>qt6 compat</li> </ul>"},{"location":"changelog.html#v01903-2022-06-30","title":"v0.190.3 (2022-06-30)","text":""},{"location":"changelog.html#fix_24","title":"Fix","text":"<ul> <li>bump regex dep</li> </ul>"},{"location":"changelog.html#v01902-2022-04-07","title":"v0.190.2 (2022-04-07)","text":""},{"location":"changelog.html#fix_25","title":"Fix","text":"<ul> <li>scxml not available for PyQt5</li> </ul>"},{"location":"changelog.html#v01901-2022-04-06","title":"v0.190.1 (2022-04-06)","text":""},{"location":"changelog.html#fix_26","title":"Fix","text":"<ul> <li>regex fix</li> </ul>"},{"location":"changelog.html#v01900-2022-04-06","title":"v0.190.0 (2022-04-06)","text":""},{"location":"changelog.html#feat_14","title":"Feat","text":"<ul> <li>Application: add sleep method</li> <li>add scxml module</li> </ul>"},{"location":"changelog.html#v01890-2021-12-31","title":"v0.189.0 (2021-12-31)","text":""},{"location":"changelog.html#feat_15","title":"Feat","text":"<ul> <li>XmlStreamReader: add get_token_type / read_next methods</li> <li>Rect: add margins_added / margins_removed methods</li> <li>TextDocument: add show_whitespaces_and_tabs method</li> <li>Chart: add set_margins method</li> <li>core: add XmlStreamReader class</li> <li>Size/SizeF: add shrunk_by / grown_by methods</li> <li>StandardItem/ListWidgetItem/TreeWidgetItem: add set_size_hint method</li> <li>Polygon/PolygonF: add get_data_buffer method</li> <li>ListWidgetItem: add set_data method</li> <li>Window/Widget: add get_screen method</li> </ul>"},{"location":"changelog.html#fix_27","title":"Fix","text":"<ul> <li>typo for DateType</li> <li>CompletionWidget: correctly cast to int for SetY</li> </ul>"},{"location":"changelog.html#v01880-2021-12-14","title":"v0.188.0 (2021-12-14)","text":""},{"location":"changelog.html#feat_16","title":"Feat","text":"<ul> <li>add JsonModel class</li> <li>Translator: add for_system_language method</li> <li>StyleOptionToolBox: add get/set_selected_position methods</li> <li>Widget: add screen param to center method</li> <li>Url: add from_local_file method</li> <li>custom_widgets: add CompletionWidget class</li> <li>TextDocument/TextDocumentFragment: add write_to_file method</li> <li>Font: add set_family method</li> <li>gui: add TextDocumentWriter class</li> <li>TextCursor: add get_selection method</li> <li>Mimedata: add set_svg_data / set_path_data</li> <li>gui: add TextDocumentFragment class</li> <li>ListWidet: add find_items method</li> <li>SpacerItem: add get_size_policy method</li> <li>custom_validators: add IntegerValidator class</li> </ul>"},{"location":"changelog.html#v01872-2021-11-18","title":"v0.187.2 (2021-11-18)","text":""},{"location":"changelog.html#fix_28","title":"Fix","text":"<ul> <li>fix import for non-windows</li> </ul>"},{"location":"changelog.html#v01871-2021-11-18","title":"v0.187.1 (2021-11-18)","text":""},{"location":"changelog.html#fix_29","title":"Fix","text":"<ul> <li>add FramelessWindow to init.py</li> </ul>"},{"location":"changelog.html#v01870-2021-11-18","title":"v0.187.0 (2021-11-18)","text":""},{"location":"changelog.html#feat_17","title":"Feat","text":"<ul> <li>Pixmap: add get_image_data_url method</li> <li>FramelessWindow: make AeroSnap work</li> <li>custom_widgets: add JoystickButton class</li> <li>Add SvgBufferIconEngine class</li> <li>FontDatabase: keep track of font paths</li> <li>Style: add draw_control method</li> <li>Icon: add from_char method</li> <li>Pixmap: add create_char method</li> </ul>"},{"location":"changelog.html#fix_30","title":"Fix","text":"<ul> <li>fix ProgressBarDelegate orientation for Qt6</li> </ul>"},{"location":"changelog.html#v01860-2021-11-11","title":"v0.186.0 (2021-11-11)","text":""},{"location":"changelog.html#feat_18","title":"Feat","text":"<ul> <li>WebEnginePage: add some more methods</li> <li>Color: add get_name method</li> <li>iconprovider: add dir and getattr methods to iconsets</li> <li>TextDocument: add some more methods</li> <li>TextBlock: add str method</li> <li>Process: add get_process_environment method</li> <li>qml: add clear_type_registrations method</li> <li>FileIconProvider: support os.PathLike for get_icon</li> <li>custom_widgets: add SubsequenceCompleter class</li> <li>Completer: add set/is_case_sensitive methods</li> <li>custom_models: add SubsequenceSortFilterProxyModel class</li> <li>SortFilterProxyModel: add set_sort_role method</li> </ul>"},{"location":"changelog.html#v01850-2021-11-04","title":"v0.185.0 (2021-11-04)","text":""},{"location":"changelog.html#feat_19","title":"Feat","text":"<ul> <li>add QT_VERSION var to qt module</li> </ul>"},{"location":"changelog.html#fix_31","title":"Fix","text":"<ul> <li>core: dont shadow builtin libraries</li> </ul>"},{"location":"changelog.html#v01840-2021-10-30","title":"v0.184.0 (2021-10-30)","text":""},{"location":"changelog.html#feat_20","title":"Feat","text":"<ul> <li>qt: add flag_to_int method</li> <li>debugging: add is_deleted fn</li> <li>TextEdit: add get_text_cursor method</li> <li>PlainTextEdit: add get_text_cursor method</li> <li>better package support by using importlib.resources for resource files</li> <li>add qt.set_env_vars</li> <li>fallback to installed qt package in case environment var QT_API is invalid / empty</li> <li>TextBlock: add some methods related to syntax highlighting</li> <li>HeaderView: add section_resized_by_user signal</li> <li>Widget: add resized signal</li> <li>add StandardIconsWidget class</li> <li>TextCursor: add get_cursor_position method</li> <li>SyntaxHighlighter: add get_current_block / get_format</li> <li>Process: add edit_environment method</li> <li>Widget: rename get/set_context_menu_policy methods</li> <li>TextLayout: add get_text_option method</li> <li>TextDocument: add some more methods</li> <li>TextCursor: add str method</li> <li>StandardItemModel: add create_single_item_model classmethod</li> <li>ProcessEnvironment: add update() / items() methods</li> <li>Color: add drift_color classmethod</li> <li>PlaintextEdit: TextDocument by default</li> <li>PlainTextEdit: add show_whitespace_and_tabs method</li> <li>add mimetype_icon fn for FileIconProvider</li> <li>Add MenuRecentFiles class</li> <li>update iconsets</li> </ul>"},{"location":"changelog.html#fix_32","title":"Fix","text":"<ul> <li>TextCursor: correctly convert EOL in str</li> <li>qt6 flag fix</li> <li>typo in AwesomeFileIconProvider</li> </ul>"},{"location":"changelog.html#v01836-2021-10-26","title":"v0.183.6 (2021-10-26)","text":""},{"location":"changelog.html#fix_33","title":"Fix","text":"<ul> <li>more qt compat stuff</li> <li>generate docs on py3.9</li> </ul>"},{"location":"changelog.html#v01835-2021-10-12","title":"v0.183.5 (2021-10-12)","text":""},{"location":"changelog.html#fix_34","title":"Fix","text":"<ul> <li>only test on 3.9 / macos10</li> </ul>"},{"location":"changelog.html#v01834-2021-10-12","title":"v0.183.4 (2021-10-12)","text":""},{"location":"changelog.html#fix_35","title":"Fix","text":"<ul> <li>dont use poetry pre version</li> </ul>"},{"location":"changelog.html#v01833-2021-10-12","title":"v0.183.3 (2021-10-12)","text":""},{"location":"changelog.html#fix_36","title":"Fix","text":"<ul> <li>qt6 compat</li> <li>some flag fixes</li> </ul>"},{"location":"changelog.html#v01832-2021-02-05","title":"v0.183.2 (2021-02-05)","text":""},{"location":"changelog.html#fix_37","title":"Fix","text":"<ul> <li>another try to fix docs generation</li> </ul>"},{"location":"changelog.html#v01831-2021-02-05","title":"v0.183.1 (2021-02-05)","text":""},{"location":"changelog.html#fix_38","title":"Fix","text":"<ul> <li>fix docs generation</li> </ul>"},{"location":"changelog.html#v01830-2021-02-05","title":"v0.183.0 (2021-02-05)","text":""},{"location":"changelog.html#feat_21","title":"Feat","text":"<ul> <li>JSEngine: add eval method</li> <li>Pixmap: add rotated method</li> <li>ColorDialog: add replace_qcolorshowlabel</li> <li>JSValue: add call method</li> <li>PlainTextEdit: add some more methods</li> <li>core: add Slot method</li> <li>core: add Mutex/Semaphore classes</li> <li>LineEdit: add some signals</li> <li>svg: add SvgWidget class</li> </ul>"},{"location":"changelog.html#fix_39","title":"Fix","text":"<ul> <li>correctly keep state when using block_signals / updates_off context managers</li> </ul>"},{"location":"changelog.html#v01821-2021-01-26","title":"v0.182.1 (2021-01-26)","text":""},{"location":"changelog.html#fix_40","title":"Fix","text":"<ul> <li>colors fix</li> </ul>"},{"location":"changelog.html#v01820-2021-01-26","title":"v0.182.0 (2021-01-26)","text":""},{"location":"changelog.html#feat_22","title":"Feat","text":"<ul> <li>Image: add invert_pixels method</li> <li>Color: invert_alpha param for inverted method</li> <li>MetaObject: type_filter kwarg for get_methods</li> <li>core: add MetaProperty class</li> <li>MetaObject: include_super param for get_ methods</li> <li>ItemEditorFactory: add property_name kwarg to register_editor method</li> <li>TabWidget: add update_tab_bar_visibility method</li> <li>Pixmap: add from_image method</li> <li>MessageBox: add some constants</li> <li>MessageBox: add set_escape/default_button methods</li> <li>MessageBox: add get_icon_pixmap method</li> <li>svg: add SvgRenderer class</li> <li>Image: add from_ndarray method</li> </ul>"},{"location":"changelog.html#v01810-2021-01-23","title":"v0.181.0 (2021-01-23)","text":""},{"location":"changelog.html#feat_23","title":"Feat","text":"<ul> <li>Color: add is_dark and inverted methods</li> <li>Dir: add set_search_paths method</li> <li>Palette: add inverted method</li> <li>Dir: add add_search_path method</li> <li>core: add AbstractNativeEventFilter</li> </ul>"},{"location":"changelog.html#v01800-2021-01-20","title":"v0.180.0 (2021-01-20)","text":""},{"location":"changelog.html#feat_24","title":"Feat","text":"<ul> <li>TextDocument: add some methods related to default stylesheet editing</li> <li>PygmentsHighlighter: add repr method</li> <li>PygmentsHighlighter: add style kwarg</li> <li>QtCore: add QClassInfo for PyQt5/6</li> <li>colors: add interpolate_text_colors fn</li> <li>Color: add from_hsv method</li> <li>gui: add Drag class</li> <li>DataWidgetMapper: add get_mapped_property_name method</li> <li>DataWidgetMapper: add add_mapping method</li> </ul>"},{"location":"changelog.html#v01790-2021-01-18","title":"v0.179.0 (2021-01-18)","text":""},{"location":"changelog.html#fix_41","title":"Fix","text":"<ul> <li>RegexInput flags fix</li> <li>ModelTester: correctly disconnect model</li> </ul>"},{"location":"changelog.html#feat_25","title":"Feat","text":"<ul> <li>Painter: more kwargs for set_pen method</li> <li>Pen: allow custom dash pattern for set_style</li> <li>ItemEditorFactory: add register_default_editor method</li> <li>GraphicsItem: add set_scale method</li> <li>Pixmap: add create_checkerboard_pattern method</li> <li>ColorDialog: add get_qcolorshower/get_qcolorshowlabel methods</li> <li>TableWidgetItem: add set_tooltip method</li> </ul>"},{"location":"changelog.html#v01780-2021-01-14","title":"v0.178.0 (2021-01-14)","text":""},{"location":"changelog.html#feat_26","title":"Feat","text":"<ul> <li>IODevice: add len method</li> <li>EventLoop: throw exception when running twice</li> <li>Color: add to_qsscolor method</li> <li>Color: add interpolate_color method</li> <li>Locale: add get_system_locale / get_system_language methods</li> <li>use subclassed ItemEditorFactory as default factory</li> </ul>"},{"location":"changelog.html#v01771-2021-01-13","title":"v0.177.1 (2021-01-13)","text":""},{"location":"changelog.html#fix_42","title":"Fix","text":"<ul> <li>test fix</li> </ul>"},{"location":"changelog.html#v01770-2021-01-13","title":"v0.177.0 (2021-01-13)","text":""},{"location":"changelog.html#feat_27","title":"Feat","text":"<ul> <li>allow args for app() methods</li> </ul>"},{"location":"changelog.html#v01760-2021-01-13","title":"v0.176.0 (2021-01-13)","text":""},{"location":"changelog.html#feat_28","title":"Feat","text":"<ul> <li>Timer: add start_timer method</li> <li>Timer: add set_interval method</li> <li>allow os.PathLike for using images in set_tooltip methods</li> <li>Movie: add get_supported_formats method</li> <li>iconprovider: add AwesomeQuickImageProvider class</li> <li>iconprovider: add AwesomeFileIconProvider class</li> </ul>"},{"location":"changelog.html#v01750-2021-01-12","title":"v0.175.0 (2021-01-12)","text":""},{"location":"changelog.html#feat_29","title":"Feat","text":"<ul> <li>add prettyqtest</li> <li>qml: add register_qml_type method</li> <li>AbstractSlider: add set_auto_scroll_to_end method</li> <li>GuiApplication: add edit_palette context manager</li> <li>Dir: add get_entry_list method</li> </ul>"},{"location":"changelog.html#v01740-2021-01-11","title":"v0.174.0 (2021-01-11)","text":""},{"location":"changelog.html#feat_30","title":"Feat","text":"<ul> <li>core: add FileSelector class</li> <li>Dir: add get_entry_info_list method</li> <li>Resource: add set/get_file_name and register_resource methods</li> <li>Application: add get_available_themes method</li> </ul>"},{"location":"changelog.html#v01730-2021-01-10","title":"v0.173.0 (2021-01-10)","text":""},{"location":"changelog.html#fix_43","title":"Fix","text":"<ul> <li>correct icon color for dark mode</li> </ul>"},{"location":"changelog.html#feat_31","title":"Feat","text":"<ul> <li>custom_models: add StorageInfoModel class</li> <li>DataStream: add get/set_status methods</li> <li>custom_widgets: add ElidedLabel class</li> <li>Painter: add get_font_metrics method</li> <li>gui: add TextLayout class</li> <li>add SyncedProperty class</li> <li>Widget: add get/set_window_file_path methods</li> <li>widgets: add SplitterHandle class</li> </ul>"},{"location":"changelog.html#v01720-2021-01-09","title":"v0.172.0 (2021-01-09)","text":""},{"location":"changelog.html#feat_32","title":"Feat","text":"<ul> <li>Application: add set_theme method</li> <li>gui: add TextObjectInterface class</li> <li>PyQt5: import QEnum and QFlag classes</li> <li>core: add MetaMethod/MetaObject classes</li> <li>widgets: add FocusFrame class</li> <li>quick: add Quick(Async)ImageProvider classes</li> <li>QmlEngine: add some more methods</li> <li>QmlApplicationEngine: add load_file method</li> </ul>"},{"location":"changelog.html#v01711-2021-01-07","title":"v0.171.1 (2021-01-07)","text":""},{"location":"changelog.html#fix_44","title":"Fix","text":"<ul> <li>comment out some event constants</li> </ul>"},{"location":"changelog.html#v01710-2021-01-07","title":"v0.171.0 (2021-01-07)","text":""},{"location":"changelog.html#feat_33","title":"Feat","text":"<ul> <li>GraphicsItem: add get/set_cache_mode methods</li> <li>GraphicsPixmapItem: some additional methods</li> <li>custom_widgets: add BorderLayout class</li> <li>widgets: add WidgetItem class</li> <li>LayoutItem: add get_item method</li> <li>LayoutItem: add get/set_alignment methods</li> <li>Style: add draw_primitive method</li> <li>StyleOption: add based_on method</li> </ul>"},{"location":"changelog.html#fix_45","title":"Fix","text":"<ul> <li>AutoSlot: use typing.get_type_hints</li> </ul>"},{"location":"changelog.html#v01700-2021-01-05","title":"v0.170.0 (2021-01-05)","text":""},{"location":"changelog.html#feat_34","title":"Feat","text":"<ul> <li>Validators: also allow Pattern for set_regex</li> <li>add tile rule constant</li> <li>add SingleApplication class</li> <li>custom_widgets: add Notification class</li> <li>TreeWidget: add contains method</li> <li>HelpContentWidget: add index_of method</li> <li>add contains method to some widgets</li> <li>ItemEditorFactory: add register_editor method</li> <li>widgets: add ItemEditorCreatorBase / ItemEditorFactory</li> <li>types: add Variant(Type)</li> <li>VariantAnimation: add set_range method</li> <li>TextStream: add read_lines method</li> <li>TextStream: add set_codec method</li> </ul>"},{"location":"changelog.html#v01690-2021-01-04","title":"v0.169.0 (2021-01-04)","text":""},{"location":"changelog.html#feat_35","title":"Feat","text":"<ul> <li>RegularExpressionMatch: add get_match_type method</li> <li>CoreApplication: allow more types for version metadata</li> <li>Windows: add workaround for raising window</li> <li>network: add LocalSocket class</li> </ul>"},{"location":"changelog.html#fix_46","title":"Fix","text":"<ul> <li>CoreApplication: fix setting metadata</li> </ul>"},{"location":"changelog.html#v01680-2021-01-03","title":"v0.168.0 (2021-01-03)","text":""},{"location":"changelog.html#feat_36","title":"Feat","text":"<ul> <li>eventfilters: add AnimatedToolTipEventFilter class</li> <li>Widget: tooltip kwarg for set_flags method</li> <li>AbstractAnimation: add restart_animation method</li> <li>add custom_animations module</li> <li>AbstractAnimation: implement and and or</li> <li>Dir: some additional methods</li> </ul>"},{"location":"changelog.html#v01670-2021-01-02","title":"v0.167.0 (2021-01-02)","text":""},{"location":"changelog.html#feat_37","title":"Feat","text":"<ul> <li>FileSystemModel: add get_file_info and get_file_path methods</li> <li>add fspath to Dir and FileInfo classes</li> </ul>"},{"location":"changelog.html#v01661-2021-01-01","title":"v0.166.1 (2021-01-01)","text":""},{"location":"changelog.html#fix_47","title":"Fix","text":"<ul> <li>localization fixups</li> </ul>"},{"location":"changelog.html#v01660-2020-12-31","title":"v0.166.0 (2020-12-31)","text":""},{"location":"changelog.html#feat_38","title":"Feat","text":"<ul> <li>CoreApplication: add get_available_languages and load_language methods</li> </ul>"},{"location":"changelog.html#v01650-2020-12-31","title":"v0.165.0 (2020-12-31)","text":""},{"location":"changelog.html#feat_39","title":"Feat","text":"<ul> <li>WebEngineView: add register_as_browser method</li> <li>WebEngineView: ass some settings-related methods</li> <li>Translator: add load_file method</li> <li>add FramelessWindow class</li> <li>add webchannel module</li> <li>qt: add QtWebchannel module</li> <li>widgets: add FileIconProvider class</li> <li>add prettyqt.qt.QtUiTools module</li> </ul>"},{"location":"changelog.html#v01640-2020-12-29","title":"v0.164.0 (2020-12-29)","text":""},{"location":"changelog.html#feat_40","title":"Feat","text":"<ul> <li>CoreApplication: add restart method</li> </ul>"},{"location":"changelog.html#fix_48","title":"Fix","text":"<ul> <li>FontDatabase: make get_system_font a classmethod</li> <li>ObjectBrowser signal fix for Qt6</li> <li>PdfWriter: correctly inherit from Object and PagedPaintDevice</li> </ul>"},{"location":"changelog.html#v01630-2020-12-27","title":"v0.163.0 (2020-12-27)","text":""},{"location":"changelog.html#feat_41","title":"Feat","text":"<ul> <li>OperatingsystemVersion: add eq and hash methods</li> <li>VersionNumber: add hash method</li> <li>FontDatabase: add optional md5 check for add_font</li> </ul>"},{"location":"changelog.html#fix_49","title":"Fix","text":"<ul> <li>revert CharIconPainter paint method for now</li> </ul>"},{"location":"changelog.html#v01620-2020-12-27","title":"v0.162.0 (2020-12-27)","text":""},{"location":"changelog.html#feat_42","title":"Feat","text":"<ul> <li>FontDatabase: add additional check in add_font</li> <li>Painter: add offset_by and apply_transform context managers</li> </ul>"},{"location":"changelog.html#fix_50","title":"Fix","text":"<ul> <li>IconWidget: update when setting size</li> </ul>"},{"location":"changelog.html#v01610-2020-12-26","title":"v0.161.0 (2020-12-26)","text":""},{"location":"changelog.html#feat_43","title":"Feat","text":"<ul> <li>LineEdit: add add_action method</li> <li>ListView/TableView: add some more setters / getters</li> <li>Painter: add edit_pen context manager</li> <li>PolygonF: alternative ctors for diamond / star creation</li> </ul>"},{"location":"changelog.html#fix_51","title":"Fix","text":"<ul> <li>LabeledSlider: call adjust_margins on correct object</li> <li>correct IconProvider init</li> </ul>"},{"location":"changelog.html#v01600-2020-12-25","title":"v0.160.0 (2020-12-25)","text":""},{"location":"changelog.html#feat_44","title":"Feat","text":"<ul> <li>gui: add TextLine module</li> <li>Doublevalidator: add set_range method</li> <li>IntValidator: add set_range method</li> <li>Pixmap: add eq method</li> </ul>"},{"location":"changelog.html#v01590-2020-12-24","title":"v0.159.0 (2020-12-24)","text":""},{"location":"changelog.html#feat_45","title":"Feat","text":"<ul> <li>LineEdit: add set/get_cursor_move_style methods</li> </ul>"},{"location":"changelog.html#v01580-2020-12-22","title":"v0.158.0 (2020-12-22)","text":""},{"location":"changelog.html#feat_46","title":"Feat","text":"<ul> <li>iconprovider: add reset_cache method</li> <li>Widget: add set/get_foreground/background_role methods</li> <li>Application/Widget: add set/get_stylesheet methods</li> <li>Application: add edit_stylesheet context manager</li> </ul>"},{"location":"changelog.html#v01571-2020-12-22","title":"v0.157.1 (2020-12-22)","text":""},{"location":"changelog.html#fix_52","title":"Fix","text":"<ul> <li>SpanSlider fix</li> </ul>"},{"location":"changelog.html#v01570-2020-12-22","title":"v0.157.0 (2020-12-22)","text":""},{"location":"changelog.html#feat_47","title":"Feat","text":"<ul> <li>Painter: add native_mode context manager</li> <li>FontDatabase: add add_font method</li> <li>gui: add IconEngine class</li> <li>TabWidget: add set_icon_size method</li> <li>Icon: allow more types for size param</li> </ul>"},{"location":"changelog.html#v01560-2020-12-21","title":"v0.156.0 (2020-12-21)","text":""},{"location":"changelog.html#feat_48","title":"Feat","text":"<ul> <li>RegularExpressionMatch: add bool method</li> <li>custom_widgets: add ObjectBrowser class</li> <li>Timer: add restart method</li> <li>ListView: add set_grid_size method</li> <li>SortFilterProxyModel: add is/set_filter_case_sensitive methods</li> <li>AbstractItemView: add set_icon_size method</li> </ul>"},{"location":"changelog.html#v01550-2020-12-20","title":"v0.155.0 (2020-12-20)","text":""},{"location":"changelog.html#feat_49","title":"Feat","text":"<ul> <li>Label: add get_horizontal/vertical_alignment methods</li> <li>GraphicsWidget: add window_frame_section_at method</li> </ul>"},{"location":"changelog.html#v01540-2020-12-18","title":"v0.154.0 (2020-12-18)","text":""},{"location":"changelog.html#feat_50","title":"Feat","text":"<ul> <li>add QtLocation and QtHelp to qt submodule</li> <li>Dir/FileDialog: add get/set_filter methods</li> <li>InputDialog: add get/set_input_mode and get/set_text_echo_mode methods</li> </ul>"},{"location":"changelog.html#fix_53","title":"Fix","text":"<ul> <li>correct StarDelegate setModelData call</li> </ul>"},{"location":"changelog.html#v01530-2020-12-17","title":"v0.153.0 (2020-12-17)","text":""},{"location":"changelog.html#feat_51","title":"Feat","text":"<ul> <li>MediaPlayer: add get_error method</li> </ul>"},{"location":"changelog.html#v01521-2020-12-17","title":"v0.152.1 (2020-12-17)","text":""},{"location":"changelog.html#fix_54","title":"Fix","text":"<ul> <li>PySide2 workaround for non-recursive Object.findChild(ren)</li> </ul>"},{"location":"changelog.html#v01520-2020-12-16","title":"v0.152.0 (2020-12-16)","text":""},{"location":"changelog.html#feat_52","title":"Feat","text":"<ul> <li>Standarditem/StandardItemModel: add enabled and editable kwarg to add_item methods</li> <li>AbstractItemView: add get/set_drag_drop_mode methods</li> </ul>"},{"location":"changelog.html#v01510-2020-12-16","title":"v0.151.0 (2020-12-16)","text":""},{"location":"changelog.html#feat_53","title":"Feat","text":"<ul> <li>ToolBar: add add method</li> <li>Icon: add get_actual_size method</li> <li>winextras: add WinThumbnailToolButton class</li> <li>ToolButton: add set_menu method</li> <li>Uuid: add str method</li> </ul>"},{"location":"changelog.html#fix_55","title":"Fix","text":"<ul> <li>PySide2 find_child(ren) fix</li> </ul>"},{"location":"changelog.html#v01500-2020-12-15","title":"v0.150.0 (2020-12-15)","text":""},{"location":"changelog.html#feat_54","title":"Feat","text":"<ul> <li>Movie: add get_state method</li> </ul>"},{"location":"changelog.html#v01490-2020-12-15","title":"v0.149.0 (2020-12-15)","text":""},{"location":"changelog.html#feat_55","title":"Feat","text":"<ul> <li>add HoverIconEventFilter class</li> <li>positioning: add GeoPositionInfo class</li> <li>Icon: add mode and state kwarg for add/get_pixmap</li> <li>widget: add set_mask method</li> <li>core: add FileSystemWatcher class</li> <li>Palette: add get/set_color_group methods</li> <li>Brush: add some addtional methods</li> <li>Region: add some additional methods</li> <li>custom_delegates: add RenderLinkDelegate class</li> <li>TableWidgetItem: add set_text_alignment method</li> <li>Gradients: add repr and some helper methods to gradient classes</li> </ul>"},{"location":"changelog.html#fix_56","title":"Fix","text":"<ul> <li>PySide2 workaround for missing recursive param in findChild(ren)</li> <li>WebEngineHistory len fix for PySide2</li> <li>CategoryAxis len fix for PySide2</li> <li>correctly inherit LCDNumber</li> </ul>"},{"location":"changelog.html#v01480-2020-12-14","title":"v0.148.0 (2020-12-14)","text":""},{"location":"changelog.html#feat_56","title":"Feat","text":"<ul> <li>Widget: add get/set_window_state methods</li> <li>AbstractTextDocumentLayout: add tuple support for hit_test point arg</li> <li>TimeZone: add get_display_name method</li> <li>GuiApplication: add get/set_high_dpi_scale_factor_rounding_policy methods</li> <li>StandardItem: add some new methods</li> <li>AbstractButton: add get_icon method</li> <li>StandardItemModel: add add_item method</li> <li>StandardItem: add get/set_checkstate methods</li> <li>Window: add start_system_resize method</li> </ul>"},{"location":"changelog.html#v01472-2020-12-14","title":"v0.147.2 (2020-12-14)","text":""},{"location":"changelog.html#fix_57","title":"Fix","text":"<ul> <li>MacOs test fix</li> </ul>"},{"location":"changelog.html#v01471-2020-12-14","title":"v0.147.1 (2020-12-14)","text":""},{"location":"changelog.html#fix_58","title":"Fix","text":"<ul> <li>MacOs test fix</li> </ul>"},{"location":"changelog.html#v01470-2020-12-13","title":"v0.147.0 (2020-12-13)","text":""},{"location":"changelog.html#feat_57","title":"Feat","text":"<ul> <li>ToolBar: add get_allowed_areas method</li> <li>WebEnginePage: add some additional methods</li> <li>WebEngineSettings: add delitem method</li> <li>Application: add send/post_event methods</li> </ul>"},{"location":"changelog.html#v01460-2020-12-13","title":"v0.146.0 (2020-12-13)","text":""},{"location":"changelog.html#fix_59","title":"Fix","text":"<ul> <li>correctly serialize AbstractGraphicsShapeItem</li> </ul>"},{"location":"changelog.html#feat_58","title":"Feat","text":"<ul> <li>GuiApplication: add get_icon method</li> <li>PlainTextEdit: add get(_line)_wrap_mode methods</li> <li>GuiApplication: add get_application_state method</li> </ul>"},{"location":"changelog.html#v01450-2020-12-11","title":"v0.145.0 (2020-12-11)","text":""},{"location":"changelog.html#fix_60","title":"Fix","text":"<ul> <li>GraphicsGridLayout: serialize correctly</li> <li>MediaRecorder: use correct module in set_video/audio_settings</li> <li>correct constant naming</li> <li>install_exceptionhook fix</li> </ul>"},{"location":"changelog.html#feat_59","title":"Feat","text":"<ul> <li>GridLayout: add get/set_origin_corner methods</li> <li>BoxLayout: add get/set_direction methods</li> <li>NetworkCookieJar: add add and set_cookies_from_url methods</li> <li>NetworkCookie: add set_expiration_date method</li> <li>Translator: add bool method</li> <li>custom_widgets: add RoundProgressBar class</li> <li>DateTimeEdit: add some more methods related to sections</li> <li>get/set_icon_size work for some widgets</li> <li>CalendarWidget: add set_range method</li> <li>HeaderView: add generate_header_id method</li> <li>Widget: add edit_palette contextmanager and get_font method</li> <li>Palette: add brush methods</li> <li>custom_models: add ImportlibDistributionModel class</li> </ul>"},{"location":"changelog.html#v01440-2020-12-09","title":"v0.144.0 (2020-12-09)","text":""},{"location":"changelog.html#fix_61","title":"Fix","text":"<ul> <li>Settings: iter through key-value pairs</li> <li>correct inheritance for QuickItem</li> <li>ColumnItemModel: correct get_width signature</li> </ul>"},{"location":"changelog.html#feat_60","title":"Feat","text":"<ul> <li>qml: add QmlImageProviderbase class</li> <li>widgets: add TreeWidgetItemIterator class</li> <li>quick: add some more classes</li> <li>qml: add QmlParserStatus class</li> <li>Widget: add get_title method</li> <li>Painter: add get_text_rect method</li> <li>ListWidget: add add_item method</li> </ul>"},{"location":"changelog.html#v01430-2020-12-08","title":"v0.143.0 (2020-12-08)","text":""},{"location":"changelog.html#fix_62","title":"Fix","text":"<ul> <li>ObjectBrowser fix</li> </ul>"},{"location":"changelog.html#feat_61","title":"Feat","text":"<ul> <li>implement eq method for some more validator classes</li> </ul>"},{"location":"changelog.html#v01421-2020-12-07","title":"v0.142.1 (2020-12-07)","text":""},{"location":"changelog.html#fix_63","title":"Fix","text":"<ul> <li>use our own SizeF class</li> </ul>"},{"location":"changelog.html#v01420-2020-12-07","title":"v0.142.0 (2020-12-07)","text":""},{"location":"changelog.html#feat_62","title":"Feat","text":"<ul> <li>SizeF: add some methods to be on par with Size</li> <li>Size: add expanded_to method</li> <li>CompositeValidator: add some additional methods</li> <li>custom_validators: add eq method to validator classes</li> <li>TreeWidgetItem: add some more methods</li> <li>widgets: add TableWidgetSelectionRange class</li> <li>core: add Calendar class</li> <li>core: add SignalMapper class</li> <li>core: add StateMachine class</li> <li>core: add LockFile class</li> <li>core: add JsonDocument/JsonValue classes</li> <li>GeoCircle: allow tuple in ctor</li> <li>core: add SocketNotifier class</li> <li>widgets: add Shortcut class</li> </ul>"},{"location":"changelog.html#fix_64","title":"Fix","text":"<ul> <li>Correctly inherit StyleItemDelegate</li> </ul>"},{"location":"changelog.html#v01410-2020-12-03","title":"v0.141.0 (2020-12-03)","text":""},{"location":"changelog.html#feat_63","title":"Feat","text":"<ul> <li>core: add Collator(SortKey) classes</li> </ul>"},{"location":"changelog.html#fix_65","title":"Fix","text":"<ul> <li>github actions fix</li> </ul>"},{"location":"changelog.html#v01404-2020-12-02","title":"v0.140.4 (2020-12-02)","text":""},{"location":"changelog.html#fix_66","title":"Fix","text":"<ul> <li>docs build fix</li> </ul>"},{"location":"changelog.html#v01403-2020-12-02","title":"v0.140.3 (2020-12-02)","text":""},{"location":"changelog.html#fix_67","title":"Fix","text":"<ul> <li>docs deployment</li> </ul>"},{"location":"changelog.html#v01402-2020-12-02","title":"v0.140.2 (2020-12-02)","text":""},{"location":"changelog.html#fix_68","title":"Fix","text":"<ul> <li>deploy check for github actions</li> </ul>"},{"location":"changelog.html#v01401-2020-12-02","title":"v0.140.1 (2020-12-02)","text":""},{"location":"changelog.html#fix_69","title":"Fix","text":"<ul> <li>github actions: conditional deploy step</li> </ul>"},{"location":"changelog.html#v01400-2020-12-02","title":"v0.140.0 (2020-12-02)","text":""},{"location":"changelog.html#feat_64","title":"Feat","text":"<ul> <li>gui: add ColorSpace class</li> </ul>"},{"location":"changelog.html#v01390-2020-12-02","title":"v0.139.0 (2020-12-02)","text":""},{"location":"changelog.html#feat_65","title":"Feat","text":"<ul> <li>FileInfo/Dir: fallback to pathlib.Path methods</li> <li>widgets: add Proxy/CommonStyle classes</li> <li>widgets: add Gesture classes</li> <li>core: add TemporaryDir class</li> <li>widgets: add WhatsThis class</li> <li>core: add ItemSelectionRange class</li> <li>FormLayout: add some more methods</li> <li>core: add ProcessEnvironment class</li> <li>gui: add StaticText class</li> <li>core: add PauseAnimation class</li> </ul>"},{"location":"changelog.html#v01380-2020-12-01","title":"v0.138.0 (2020-12-01)","text":""},{"location":"changelog.html#feat_66","title":"Feat","text":"<ul> <li>core: add ChildEvent / TimerEvent classes</li> <li>core: add IdentityProxyModel class</li> <li>gui: add SessionManager class</li> <li>gui: add InputMethod class</li> <li>core: add AbstractEventDispatcher class</li> <li>widgets: add StackedWidget class</li> <li>widgets: add some events</li> <li>FileInfo: add some additional methods</li> <li>gui: add Vector3D class</li> <li>core: add MimeType / MimeDatabase classes</li> <li>core: add SaveFile class</li> <li>core: add SignalBlocker class</li> <li>core: add TimeLine class</li> <li>gui: add Bitmap class</li> <li>core: add RandomGenerator class</li> <li>FileDevice: add get_error method</li> <li>widgets: add Dial class</li> <li>widgets: add RubberBand class</li> <li>Wizard/WizardPage: add some more methods</li> <li>widgets: add GraphicsRotation / GraphicsScale classes</li> <li>widgets: add GraphicsTransform class</li> <li>widgets: add LCDNumber class</li> <li>widgets: add Scroller(Properties) classes</li> <li>core: add CommandLineParser/Option classes</li> <li>Pixmap: add some more methods</li> <li>gui: add Screen class</li> <li>Transform: add some more methods</li> <li>add Abstract/PlainTextTextDocumentLayout classes</li> <li>core: add BasicTimer class</li> <li>core: add Resource class</li> <li>core: add StorageInfo class</li> <li>core: add ElapsedTimer class</li> <li>core: add CryptographicHash class</li> </ul>"},{"location":"changelog.html#v01371-2020-11-27","title":"v0.137.1 (2020-11-27)","text":""},{"location":"changelog.html#fix_70","title":"Fix","text":"<ul> <li>doc build fix</li> </ul>"},{"location":"changelog.html#v01370-2020-11-27","title":"v0.137.0 (2020-11-27)","text":""},{"location":"changelog.html#feat_67","title":"Feat","text":"<ul> <li>core: add OperatingSystemVersion class</li> <li>PdfWriter: add set_page_margins method</li> <li>core: add MarginsF class</li> <li>core: Add TextStream class</li> <li>core: add ByteArrayMatcher</li> <li>AbstractItemModel: add check_index method</li> <li>PlaceManager: add search_place method</li> <li>core: add app method</li> <li>add bytes method to some classes</li> <li>utils: add Singleton metaclass</li> <li>icon: add add_pixmap method</li> <li>gui: Add PixmapCache</li> <li>Font: add some more methods</li> </ul>"},{"location":"changelog.html#v01360-2020-11-26","title":"v0.136.0 (2020-11-26)","text":""},{"location":"changelog.html#feat_68","title":"Feat","text":"<ul> <li>location: add PlaceResult class</li> <li>location: add PlaceProposedSearchResult class</li> <li>location: add clone_from method to reply classes</li> <li>Object: add has_id method</li> </ul>"},{"location":"changelog.html#fix_71","title":"Fix","text":"<ul> <li>emit inputandslider signal correctly on value change</li> <li>correct flag for constants.NO_CHILDREN</li> </ul>"},{"location":"changelog.html#v01350-2020-11-26","title":"v0.135.0 (2020-11-26)","text":""},{"location":"changelog.html#feat_69","title":"Feat","text":"<ul> <li>WebEngineHistoryItem: add get_icon_url method</li> <li>location: add PlaceMatchReply / PlaceIdReply classes</li> <li>PlaceContentReply/PlaceSearchReply: add request methods</li> <li>gui: add TextListFormat class</li> <li>gui: add TextImageFormat class</li> <li>location: add some reply/result classes</li> <li>gui: add TextTableCellFormat class</li> <li>gui: add app method</li> <li>gui: add TextFrameFormat class</li> <li>Application: add get_font method</li> <li>add qthelp module</li> <li>quick: add QuickPaintedItem class</li> <li>gui: add TextBlockGroup class</li> <li>TextCharFormat: add get/set_vertical_alignment methods</li> <li>TextBlock: add contains method</li> <li>PaintDevice: add get_metric method</li> <li>GuiApplication: add get/set_layout_direction methods</li> <li>gui: add TextObject / TextLength / TextFrame / TextFormat classes</li> <li>core: add ItemSelection class</li> <li>GraphicsLayout: add set_margin method</li> </ul>"},{"location":"changelog.html#fix_72","title":"Fix","text":"<ul> <li>correctly add items for GraphicsGridLayout</li> </ul>"},{"location":"changelog.html#v01340-2020-11-23","title":"v0.134.0 (2020-11-23)","text":""},{"location":"changelog.html#feat_70","title":"Feat","text":"<ul> <li>core: add PersistentModelIndex class</li> <li>core: add PluginLoader class</li> <li>core: add Library class</li> <li>gui: add PainterPathStroker class</li> <li>gui: add ImageWriter / ImageReader / ImageIOHandler classes</li> <li>quick: add QuickItem / QuickWindow classes</li> <li>core: add install_message_handler method</li> <li>gui: add RasterWindow / PaintDeviceWindow / OpenGLWindow classes</li> <li>svg: add SvgGenerator class</li> <li>SplashScreen: allow pixmap for ctor</li> <li>icon: add get_available_sizes method</li> <li>widget: add set_attributes method</li> <li>gui: add Vector4D / Matrix4x4 classes</li> <li>custom_widgets: add StarDelegate class</li> <li>custom_delegates: add ProgressBarDelegate class</li> <li>widgets: add missing StyleOption classes</li> <li>WidgetItems: some more methods</li> <li>Painter: add backup_state contextmanager</li> </ul>"},{"location":"changelog.html#fix_73","title":"Fix","text":"<ul> <li>KeySequenceEdit: correct repr</li> <li>correct coloring for WaitingSpinner</li> </ul>"},{"location":"changelog.html#v01331-2020-11-16","title":"v0.133.1 (2020-11-16)","text":""},{"location":"changelog.html#fix_74","title":"Fix","text":"<ul> <li>test fix</li> </ul>"},{"location":"changelog.html#v01330-2020-11-16","title":"v0.133.0 (2020-11-16)","text":""},{"location":"changelog.html#feat_71","title":"Feat","text":"<ul> <li>ComboBox: default param for add_items</li> <li>AbstractItemModel: add force_reset/force_layoutchange methods</li> <li>add location module</li> <li>gui: add FontMetricsF class</li> <li>GeoCoordinate: add bool method</li> <li>FontMetrics: add get_(tight_)bounding_rect methods</li> <li>Url: add to_string method</li> <li>network: add LocalServer / TcpServer classes</li> <li>multimediawidgets: add GraphicsVideoItem class</li> <li>mediaobject: add get_availability method</li> <li>add qt module</li> </ul>"},{"location":"changelog.html#v01321-2020-11-07","title":"v0.132.1 (2020-11-07)","text":""},{"location":"changelog.html#fix_75","title":"Fix","text":"<ul> <li>import fix</li> </ul>"},{"location":"changelog.html#v01320-2020-11-07","title":"v0.132.0 (2020-11-07)","text":""},{"location":"changelog.html#feat_72","title":"Feat","text":"<ul> <li>NetworkAccessManager: allow str for request</li> <li>network: add UdpSocket</li> <li>network: add NetworkAddressEntry / NetworkInterface classes</li> <li>add texttospeech module</li> <li>network: add NetworkDatagram class</li> <li>core: add DeadlineTimer class</li> <li>network: add HostAddress/AbstractSocket/TcpSocket classes</li> <li>network: add NetworkProxy class</li> <li>network: add HttpMultiPart class</li> <li>network: add HttpPart class</li> <li>NetworkRequest: add set/get_header methods</li> </ul>"},{"location":"changelog.html#v01310-2020-11-04","title":"v0.131.0 (2020-11-04)","text":""},{"location":"changelog.html#feat_73","title":"Feat","text":"<ul> <li>webenginecore: add WebEngineHttpRequest class</li> <li>webenginewidgets: add WebEngineContextMenuData class</li> <li>webenginewidgets: add WebEngineScriptCollection class</li> <li>multimedia: add CameraExposure/CameraImageProcessing classes</li> <li>multimedia: add CameraFocus(Zone) classes</li> <li>webenginecore: add WebEngineUrlSchemeHandler</li> </ul>"},{"location":"changelog.html#v01300-2020-11-04","title":"v0.130.0 (2020-11-04)","text":""},{"location":"changelog.html#feat_74","title":"Feat","text":"<ul> <li>WebEnginePage: add some settings methods</li> <li>webenginewidgets: add WebEngineSettings class</li> <li>add bluetooth module</li> <li>core: add Uuid class</li> <li>add quick module</li> <li>gui: add Surface and Window class</li> <li>multimedia: add ImageEncoderSettings</li> <li>multimedia: add MediaTimeRange and MediaTimeInterval classes</li> </ul>"},{"location":"changelog.html#v01291-2020-10-29","title":"v0.129.1 (2020-10-29)","text":""},{"location":"changelog.html#fix_76","title":"Fix","text":"<ul> <li>fix tests</li> <li>fix multimedia tests for Travis</li> </ul>"},{"location":"changelog.html#feat_75","title":"Feat","text":"<ul> <li>charts: add Legend class</li> <li>WebEnginePage: add get_history method</li> <li>qml: add JSValue(Iterator) class</li> <li>VideoWidget: option for fullscreen toggling via double click</li> <li>multimedia: add CameraViewFinderSettings</li> <li>multimedia: add VideoFrame class</li> <li>multimedia: add AbstractPlanarVideoBuffer class</li> <li>multimedia: add AbstractVideoBuffer class</li> <li>multimedia: add Camera class</li> <li>multimedia: add CameraInfo class</li> <li>gui: add Clipboard class</li> <li>multimedia: add AudioFormat class</li> <li>multimedia: add SoundEffect class</li> <li>charts: add PieSlice class</li> <li>charts: add BoxSet and CandlestickSet classes</li> <li>charts: add Axis-related classes</li> <li>charts: add BarSeries-related classes</li> </ul>"},{"location":"changelog.html#v01281-2020-10-25","title":"v0.128.1 (2020-10-25)","text":""},{"location":"changelog.html#fix_77","title":"Fix","text":"<ul> <li>import fix</li> </ul>"},{"location":"changelog.html#v01280-2020-10-25","title":"v0.128.0 (2020-10-25)","text":""},{"location":"changelog.html#feat_76","title":"Feat","text":"<ul> <li>custom_widgets: add ExpandableLine class</li> <li>ParallelAnimationGroup: add set_duration method</li> <li>charts: add Abstract/ValueAxis and PolarChart classes</li> <li>core: add SequentialAnimationGroup class</li> <li>AnimationGroup: allow slicing for indexing</li> <li>AnimationGroup: add add_property_animation method</li> <li>ChartView: add get/set_rubber_band methods</li> <li>Chart: add some more methods</li> <li>core: add Locale class</li> <li>core: add Margins class</li> <li>webenginewidgets: add some more modules</li> </ul>"},{"location":"changelog.html#fix_78","title":"Fix","text":"<ul> <li>Chart: properly inherit from GraphicsWidget</li> </ul>"},{"location":"changelog.html#v01271-2020-10-20","title":"v0.127.1 (2020-10-20)","text":""},{"location":"changelog.html#fix_79","title":"Fix","text":"<ul> <li>fix tests</li> </ul>"},{"location":"changelog.html#v01270-2020-10-20","title":"v0.127.0 (2020-10-20)","text":""},{"location":"changelog.html#fix_80","title":"Fix","text":"<ul> <li>always import correct bindings for winextras module</li> <li>Url: allow initializing without arg</li> </ul>"},{"location":"changelog.html#feat_77","title":"Feat","text":"<ul> <li>PainterPath: add set_fill_rule method</li> <li>PainterPath: add get_bounding_rect method</li> <li>GraphicsItem: add get_shape method</li> <li>MediaPlaylist: add get_media_url method</li> <li>start with webenginecore module</li> <li>core: add EventLoop class</li> <li>Widget: add get_font_info method</li> <li>custom_models: add PlaylistModel</li> <li>Translator: add get_file_path method</li> <li>add positioning module</li> <li>add some first QtQml classes</li> <li>core: add LibraryInfo class</li> <li>Application: add iter method</li> <li>Application: add get/set_navigation_mode methods</li> <li>Application: add get/is_effect_enabled methods</li> <li>custom_widgets: add Player class</li> </ul>"},{"location":"changelog.html#v01260-2020-10-08","title":"v0.126.0 (2020-10-08)","text":""},{"location":"changelog.html#feat_78","title":"Feat","text":"<ul> <li>core: add Process class</li> <li>DateTime: add get/set_time_spec and get_date/time methods</li> <li>core: add Time class</li> <li>DateTime: add timezone methods</li> <li>core: add TimeZone class</li> <li>Pixmap: add create_dot classmethod</li> </ul>"},{"location":"changelog.html#v01251-2020-10-07","title":"v0.125.1 (2020-10-07)","text":""},{"location":"changelog.html#fix_81","title":"Fix","text":"<ul> <li>import fix</li> </ul>"},{"location":"changelog.html#v01250-2020-10-07","title":"v0.125.0 (2020-10-07)","text":""},{"location":"changelog.html#feat_79","title":"Feat","text":"<ul> <li>widgets: add Transition classes</li> <li>core: add Transition classes</li> </ul>"},{"location":"changelog.html#fix_82","title":"Fix","text":"<ul> <li>fix Action.get_shortcut for NoneValue</li> </ul>"},{"location":"changelog.html#v01240-2020-10-05","title":"v0.124.0 (2020-10-05)","text":""},{"location":"changelog.html#feat_80","title":"Feat","text":"<ul> <li>IODevice: add get_open_mode method</li> <li>Improve repr and add str method for Date and DateTime</li> <li>core: add TemporaryFile class</li> <li>FileDevice: add set/get_file_time methods</li> <li>MainWindow: allow setting central widget to None</li> <li>AbstractButton: add get_shortcut method</li> <li>Url: add from_user_input method</li> <li>WebEngineView: add get_url method</li> <li>FileInfo: support pathlib + add proper repr</li> <li>KeySequence: allow initializing with standard keys</li> </ul>"},{"location":"changelog.html#v01231-2020-09-29","title":"v0.123.1 (2020-09-29)","text":""},{"location":"changelog.html#fix_83","title":"Fix","text":"<ul> <li>add missing State import in core module</li> </ul>"},{"location":"changelog.html#v01230-2020-09-29","title":"v0.123.0 (2020-09-29)","text":""},{"location":"changelog.html#feat_81","title":"Feat","text":"<ul> <li>core: add State classes</li> <li>core: add TextBoundaryFinder class</li> <li>ProgressBar: add get/set_orientation methods + serialize work</li> <li>Action: allow setting callback with ctor</li> <li>WebEngineView: set subclassed WebEnginePage by default</li> <li>WebEnginePage: add some more methods and constants</li> <li>AbstractSlider: add get/set_orientation methods</li> <li>core: add FileInfo class</li> <li>webenginewidgets: add WebEngineProfile class</li> </ul>"},{"location":"changelog.html#v01221-2020-09-27","title":"v0.122.1 (2020-09-27)","text":""},{"location":"changelog.html#fix_84","title":"Fix","text":"<ul> <li>use correct icon names</li> </ul>"},{"location":"changelog.html#v01220-2020-09-27","title":"v0.122.0 (2020-09-27)","text":""},{"location":"changelog.html#feat_82","title":"Feat","text":"<ul> <li>gui: add PageLayout</li> <li>gui: add Movie class</li> <li>gui: add PageSize class</li> <li>gui: add FontInfo class</li> <li>core: add UrlQuery class</li> <li>add network module</li> <li>PropertyAnimation: add get/set_property_name methods</li> <li>core: add ParallelAnimationGroup</li> <li>widgets: add SizeGrip class</li> <li>widgets: add DataWidgetMapper class</li> <li>core: add StringListModel</li> <li>VersionNumber: add get_python_version</li> <li>gui: add Transform class</li> <li>Painter: add draw_polygon method</li> <li>add core.ByteArray</li> </ul>"},{"location":"changelog.html#v01210-2020-09-10","title":"v0.121.0 (2020-09-10)","text":""},{"location":"changelog.html#feat_83","title":"Feat","text":"<ul> <li>Image: add setitem / getitem methods</li> <li>Line/LineF: add reversed and abs methods</li> <li>GraphicsScene: add get/set_item_index_method method</li> </ul>"},{"location":"changelog.html#fix_85","title":"Fix","text":"<ul> <li>serialization fixes</li> </ul>"},{"location":"changelog.html#v01200-2020-08-27","title":"v0.120.0 (2020-08-27)","text":""},{"location":"changelog.html#feat_84","title":"Feat","text":"<ul> <li>GraphicsWidget: add set_layout method</li> <li>GraphicsLayout: add some magic methods</li> <li>GraphicsScene: add add_item_group method</li> <li>widgets: add GraphicsAnchorLayout / GraphicsGridLayout / GraphicsLinearLayout</li> <li>widgets: add GraphicsItemGroup</li> <li>Layout: add delitem method</li> <li>Polygon/PolygonF: add repr and iter methods</li> <li>PainterPath: some additional methods</li> <li>GraphicsItems: add repr methods</li> <li>Line/LineF: add repr and iter</li> <li>Application: allow loading included language files via load_language_file</li> <li>widgets: add GraphicsView class</li> </ul>"},{"location":"changelog.html#refactor","title":"Refactor","text":"<ul> <li>PromptLineEdit rework</li> </ul>"},{"location":"changelog.html#v01191-2020-08-24","title":"v0.119.1 (2020-08-24)","text":""},{"location":"changelog.html#fix_86","title":"Fix","text":"<ul> <li>add missing StyleOptionComplex class</li> </ul>"},{"location":"changelog.html#v01190-2020-08-24","title":"v0.119.0 (2020-08-24)","text":""},{"location":"changelog.html#feat_85","title":"Feat","text":"<ul> <li>GraphicsScene: add some convenience methods</li> <li>widgets: add graphicsitem classes</li> <li>StylePainter: add draw_complex_control method</li> <li>gui: allow pickling some more classes</li> <li>core: add LineF class</li> <li>Widget: add get_palette() method</li> <li>widgets: add GraphicsPixmapItem / GraphicsScene</li> <li>GraphicsItem: add getitem and setitem methods</li> <li>widgets: add Blur/Colorize/DropShadowEffect</li> </ul>"},{"location":"changelog.html#fix_87","title":"Fix","text":"<ul> <li>Graphicsitem collides methods fix</li> <li>KeySequence: pickling</li> </ul>"},{"location":"changelog.html#v01182-2020-08-17","title":"v0.118.2 (2020-08-17)","text":""},{"location":"changelog.html#fix_88","title":"Fix","text":"<ul> <li>Fix tests</li> </ul>"},{"location":"changelog.html#v01181-2020-08-17","title":"v0.118.1 (2020-08-17)","text":""},{"location":"changelog.html#fix_89","title":"Fix","text":"<ul> <li>MenuBar: fix add method</li> </ul>"},{"location":"changelog.html#v01180-2020-08-17","title":"v0.118.0 (2020-08-17)","text":""},{"location":"changelog.html#refactor_1","title":"Refactor","text":"<ul> <li>MenuBar: return subclassed types instead of qt classes</li> </ul>"},{"location":"changelog.html#feat_86","title":"Feat","text":"<ul> <li>gui: add TextDocument / TextBlock / TextOption</li> <li>gui: add ConicalGradient / RadialGradient</li> <li>custom_widgets: add CollapsibleFrame</li> <li>GraphicsItem: add some more methods</li> </ul>"},{"location":"changelog.html#v01170-2020-08-16","title":"v0.117.0 (2020-08-16)","text":""},{"location":"changelog.html#feat_87","title":"Feat","text":"<ul> <li>MimeData: add dict-like interface</li> <li>Timer: add get/set_type methods</li> <li>File: add repr and str methods</li> <li>Dir: add repr and truediv methods</li> <li>Frame: set/get_frame_shape, set/get_frame_shadow</li> <li>Splitter: add setitem method, and some more typing</li> <li>Polygon/PolygonF: pythonize</li> <li>core: add Abstract/Variant/PropertyAnimation and AnimationGroup</li> <li>core: add EasingCurve</li> <li>StyleOptionSlider: add get_orientation method</li> </ul>"},{"location":"changelog.html#refactor_2","title":"Refactor","text":"<ul> <li>SpanSlider: clean up code</li> </ul>"},{"location":"changelog.html#v01160-2020-08-13","title":"v0.116.0 (2020-08-13)","text":""},{"location":"changelog.html#feat_88","title":"Feat","text":"<ul> <li>gui: add LinearGradient</li> <li>AbstractSlider: add get/set_repeat_action and trigger_action methods</li> <li>TabWidget: add get/set_tab_position methods</li> <li>Image/Pixmap: add bool method</li> <li>MenuBar: serialize stuff</li> <li>MdiArea: serialize stuff</li> <li>Brush: allow pickling + add get_texture_image method</li> <li>custom_widgets: add Timeline</li> <li>Pen: add methods for setting and getting style / join style / cap style</li> </ul>"},{"location":"changelog.html#refactor_3","title":"Refactor","text":"<ul> <li>Painter: rework set_pen / get_pen</li> </ul>"},{"location":"changelog.html#v01150-2020-08-12","title":"v0.115.0 (2020-08-12)","text":""},{"location":"changelog.html#feat_89","title":"Feat","text":"<ul> <li>Polygon: add add_points method</li> <li>Object: add store_widget_states / restore_widget_states</li> <li>Painter: add paint_on, set_transparent_background, set_brush</li> <li>PainterPath: add add_rect method</li> <li>Application: add class_getitem</li> </ul>"},{"location":"changelog.html#fix_90","title":"Fix","text":"<ul> <li>RegexEditor: correctly initialize dialog</li> </ul>"},{"location":"changelog.html#v01141-2020-08-12","title":"v0.114.1 (2020-08-12)","text":""},{"location":"changelog.html#fix_91","title":"Fix","text":"<ul> <li>HeaderView: fix saving state</li> </ul>"},{"location":"changelog.html#v01140-2020-08-12","title":"v0.114.0 (2020-08-12)","text":""},{"location":"changelog.html#refactor_4","title":"Refactor","text":"<ul> <li>use AutoSlot decorator</li> </ul>"},{"location":"changelog.html#feat_90","title":"Feat","text":"<ul> <li>add autoslot decorator</li> <li>add prettyqt.debug</li> </ul>"},{"location":"changelog.html#v01130-2020-08-10","title":"v0.113.0 (2020-08-10)","text":""},{"location":"changelog.html#feat_91","title":"Feat","text":"<ul> <li>gui: add PainterPath class</li> <li>gui: add Polygon class</li> <li>gui: palette improvements</li> <li>core: add Line class</li> <li>core: add TransposeProxyModel / ConcatenateTablesProxyModel</li> <li>add ObjectBrowser</li> <li>widgets: add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect</li> <li>Action: \"checked\" param for ctor</li> <li>gui: some magic methods + get_matches for KeySequence</li> <li>core: allow pickling VersionNumber / Size / Dir</li> <li>gui: add Gradient class</li> <li>add ColumnItemModel / ColumnItem</li> <li>Settings: add set_values method</li> <li>Widget: spacing kwarg for set_layout</li> </ul>"},{"location":"changelog.html#refactor_5","title":"Refactor","text":"<ul> <li>add serialization stuff</li> <li>improve some repr methods</li> </ul>"},{"location":"changelog.html#v01120-2020-08-04","title":"v0.112.0 (2020-08-04)","text":""},{"location":"changelog.html#feat_92","title":"Feat","text":"<ul> <li>utils: add install_exceptionhook method</li> <li>FileSystemModel: add some more shortcuts for set_root_path</li> <li>core: add VersionNumber class</li> <li>Application: add get_icon method</li> <li>MessageBox: add show_exception method</li> </ul>"},{"location":"changelog.html#refactor_6","title":"Refactor","text":"<ul> <li>improve compat with older Qt Versions</li> </ul>"},{"location":"changelog.html#fix_92","title":"Fix","text":"<ul> <li>another test fix</li> </ul>"},{"location":"changelog.html#v01111-2020-08-03","title":"v0.111.1 (2020-08-03)","text":""},{"location":"changelog.html#fix_93","title":"Fix","text":"<ul> <li>fix tests for Linux</li> </ul>"},{"location":"changelog.html#v01110-2020-08-03","title":"v0.111.0 (2020-08-03)","text":""},{"location":"changelog.html#feat_93","title":"Feat","text":"<ul> <li>widgets: add FontComboBox</li> <li>StandardPaths: add class_getitem method</li> <li>Action: some more ctor kwargs</li> <li>Action: add get/set_menu_role methods, some pickle work</li> </ul>"},{"location":"changelog.html#refactor_7","title":"Refactor","text":"<ul> <li>custom Exception for wrong params</li> </ul>"},{"location":"changelog.html#fix_94","title":"Fix","text":"<ul> <li>Menu: disable separator widgetAction</li> </ul>"},{"location":"changelog.html#v01102-2020-08-03","title":"v0.110.2 (2020-08-03)","text":""},{"location":"changelog.html#fix_95","title":"Fix","text":"<ul> <li>fix broken LogTextEdit</li> </ul>"},{"location":"changelog.html#v01101-2020-08-03","title":"v0.110.1 (2020-08-03)","text":""},{"location":"changelog.html#fix_96","title":"Fix","text":"<ul> <li>LogTextEdit: improve exception handling</li> <li>SidebarWidget: some fixes related to set_marker</li> </ul>"},{"location":"changelog.html#v01100-2020-08-02","title":"v0.110.0 (2020-08-02)","text":""},{"location":"changelog.html#refactor_8","title":"Refactor","text":"<ul> <li>improve serialization for listitems</li> <li>Validator pickle work</li> </ul>"},{"location":"changelog.html#feat_94","title":"Feat","text":"<ul> <li>Image: allow pickling</li> <li>DataStream: add create_bytearray / write_bytearray / copy_data methods</li> <li>core: add DataStream class</li> </ul>"},{"location":"changelog.html#v01090-2020-08-02","title":"v0.109.0 (2020-08-02)","text":""},{"location":"changelog.html#feat_95","title":"Feat","text":"<ul> <li>widget: add pretty method for devtools</li> <li>GridLayout: allow adding tuples/lists</li> </ul>"},{"location":"changelog.html#refactor_9","title":"Refactor","text":"<ul> <li>rework widget pickling</li> <li>move CheckboxDelegate to custom_delegates</li> <li>pickle stuff for undocommand</li> </ul>"},{"location":"changelog.html#v01080-2020-07-31","title":"v0.108.0 (2020-07-31)","text":""},{"location":"changelog.html#feat_96","title":"Feat","text":"<ul> <li>custom_delegates: add IconDelegate and NoFocusDelegate</li> <li>TableWidet: add getitem and setitem methods</li> <li>Icon: add from_image method</li> <li>allow str for layout.getitem (uses objectName)</li> <li>SidebarWidget: add set_marker method</li> </ul>"},{"location":"changelog.html#refactor_10","title":"Refactor","text":"<ul> <li>move delegates to separate module</li> </ul>"},{"location":"changelog.html#v01070-2020-07-29","title":"v0.107.0 (2020-07-29)","text":""},{"location":"changelog.html#feat_97","title":"Feat","text":"<ul> <li>GridLayout: also allow adding LayoutItems via add method</li> </ul>"},{"location":"changelog.html#v01061-2020-07-29","title":"v0.106.1 (2020-07-29)","text":""},{"location":"changelog.html#fix_97","title":"Fix","text":"<ul> <li>TabWidget: correctly close detached tabs on app close</li> <li>pickle fixes for toolbar and dockwidget</li> <li>PygmentsHighlighter: catch pygments KeyError</li> </ul>"},{"location":"changelog.html#v01060-2020-07-26","title":"v0.106.0 (2020-07-26)","text":""},{"location":"changelog.html#feat_98","title":"Feat","text":"<ul> <li>gui: add DesktopServices class</li> <li>multimedia: add AudioRecorder class</li> <li>core: add StandardPaths class</li> <li>widgets: add Undo classes</li> </ul>"},{"location":"changelog.html#v01050-2020-07-24","title":"v0.105.0 (2020-07-24)","text":""},{"location":"changelog.html#feat_99","title":"Feat","text":"<ul> <li>MediaRecorder: some new methods</li> <li>sort_by_column for tableview and treeview</li> <li>multimedia: dict-setter and getter for encodersettings</li> </ul>"},{"location":"changelog.html#refactor_11","title":"Refactor","text":"<ul> <li>improve Url-Pathlib interoperability</li> </ul>"},{"location":"changelog.html#fix_98","title":"Fix","text":"<ul> <li>PopupInfo: use PrimaryScreen geometry instead of screens[0] for positioning</li> </ul>"},{"location":"changelog.html#v01040-2020-07-23","title":"v0.104.0 (2020-07-23)","text":""},{"location":"changelog.html#feat_100","title":"Feat","text":"<ul> <li>multimedia: add MediaRecorder</li> <li>AbstractItemModel: add getitem method</li> <li>multimedia: add VideoEncoderSettings / AudioEncoderSettings</li> </ul>"},{"location":"changelog.html#refactor_12","title":"Refactor","text":"<ul> <li>use subclassed core.Size</li> </ul>"},{"location":"changelog.html#v01030-2020-07-22","title":"v0.103.0 (2020-07-22)","text":""},{"location":"changelog.html#feat_101","title":"Feat","text":"<ul> <li>ActionGroup: add getitem method</li> <li>MediaContent: add get_url method</li> <li>add multimediawidgets module</li> <li>add multimedia module</li> <li>PlainTextEdit: add allow_wheel_zoom method</li> <li>Object: name kwarg for find_parent method</li> </ul>"},{"location":"changelog.html#v01020-2020-07-21","title":"v0.102.0 (2020-07-21)","text":""},{"location":"changelog.html#refactor_13","title":"Refactor","text":"<ul> <li>move raise_dock to from Widget to Object</li> <li>SidebarWidget: some code cleanup, make settings button size configurable</li> <li>Widget: default state to True for set_attribute</li> <li>MainWindow: add return value for load_window_state</li> </ul>"},{"location":"changelog.html#feat_102","title":"Feat","text":"<ul> <li>Object: add find_parent method</li> <li>PlainTextEdit: add style kwarg to set_syntaxhighlighter</li> </ul>"},{"location":"changelog.html#v01011-2020-07-20","title":"v0.101.1 (2020-07-20)","text":""},{"location":"changelog.html#fix_99","title":"Fix","text":"<ul> <li>LogTextEdit: better integrate with custom qstylesheets</li> </ul>"},{"location":"changelog.html#v01010-2020-07-20","title":"v0.101.0 (2020-07-20)","text":""},{"location":"changelog.html#feat_103","title":"Feat","text":"<ul> <li>MessageBox: add detail_text keyword argument to message method</li> </ul>"},{"location":"changelog.html#fix_100","title":"Fix","text":"<ul> <li>correct return type for gui.icon.get_icon</li> </ul>"},{"location":"changelog.html#v01000-2020-07-20","title":"v0.100.0 (2020-07-20)","text":""},{"location":"changelog.html#feat_104","title":"Feat","text":"<ul> <li>ToolTip: add show_text method</li> <li>GuiApplication: add set_override_cursor / restore_override_cursor methods</li> <li>GuiApplication: add override_cursor context manager</li> </ul>"},{"location":"changelog.html#v0990-2020-07-18","title":"v0.99.0 (2020-07-18)","text":""},{"location":"changelog.html#refactor_14","title":"Refactor","text":"<ul> <li>FileChooserButton: typing and fixes</li> <li>Dataset: typing and fixes</li> <li>SidebarWidget: use button map instead of attaching button to widget</li> </ul>"},{"location":"changelog.html#feat_105","title":"Feat","text":"<ul> <li>AbstractItemView: add scroll_to method</li> </ul>"},{"location":"changelog.html#v0985-2020-07-17","title":"v0.98.5 (2020-07-17)","text":""},{"location":"changelog.html#perf","title":"Perf","text":"<ul> <li>add icon cache</li> </ul>"},{"location":"changelog.html#refactor_15","title":"Refactor","text":"<ul> <li>use core.Settings for windows dark mode detection</li> </ul>"},{"location":"changelog.html#v0984-2020-07-15","title":"v0.98.4 (2020-07-15)","text":""},{"location":"changelog.html#fix_101","title":"Fix","text":"<ul> <li>use qta default icon color instead of black for default</li> </ul>"},{"location":"changelog.html#v0983-2020-07-15","title":"v0.98.3 (2020-07-15)","text":""},{"location":"changelog.html#refactor_16","title":"Refactor","text":"<ul> <li>properly set stylesheets by using contextmanager</li> <li>FontDialog: do not override current_font contextmanager</li> <li>move current_font context manager to Widget class</li> </ul>"},{"location":"changelog.html#v0982-2020-07-15","title":"v0.98.2 (2020-07-15)","text":""},{"location":"changelog.html#fix_102","title":"Fix","text":"<ul> <li>package name</li> </ul>"},{"location":"changelog.html#v0981-2020-07-15","title":"v0.98.1 (2020-07-15)","text":""},{"location":"changelog.html#fix_103","title":"Fix","text":"<ul> <li>correctly reset stylesheet for widget validation background</li> </ul>"},{"location":"changelog.html#refactor_17","title":"Refactor","text":"<ul> <li>use qstylizer for stylesheet editing</li> </ul>"},{"location":"changelog.html#v0980-2020-07-15","title":"v0.98.0 (2020-07-15)","text":""},{"location":"changelog.html#feat_106","title":"Feat","text":"<ul> <li>widgets: add StyleFactory</li> </ul>"},{"location":"changelog.html#refactor_18","title":"Refactor","text":"<ul> <li>FontDatabase: make add_fonts_from_folder a classmethod</li> </ul>"},{"location":"changelog.html#v0970-2020-07-15","title":"v0.97.0 (2020-07-15)","text":""},{"location":"changelog.html#feat_107","title":"Feat","text":"<ul> <li>gui: add FontDatabase</li> <li>widgets: add Completer</li> <li>widgets: add ActionGroup</li> </ul>"},{"location":"changelog.html#v0960-2020-07-14","title":"v0.96.0 (2020-07-14)","text":""},{"location":"changelog.html#feat_108","title":"Feat","text":"<ul> <li>SelectionWidget: default keyword argument for add_custom</li> </ul>"},{"location":"changelog.html#v0950-2020-07-14","title":"v0.95.0 (2020-07-14)","text":""},{"location":"changelog.html#feat_109","title":"Feat","text":"<ul> <li>SelectionWidget: different options for custom type</li> <li>add PagedPaintDevice</li> <li>Widget: add set_margin method</li> </ul>"},{"location":"changelog.html#v0940-2020-07-14","title":"v0.94.0 (2020-07-14)","text":""},{"location":"changelog.html#feat_110","title":"Feat","text":"<ul> <li>Widget: add Widget.font_metrics()</li> <li>SpacerItem: allow strings for size policy in ctor</li> <li>allow Mapping for listwidget.add_items</li> </ul>"},{"location":"changelog.html#refactor_19","title":"Refactor","text":"<ul> <li>change to {value: label} dicts for FlagSelectionWidget.add_items</li> </ul>"},{"location":"changelog.html#v0931-2020-07-14","title":"v0.93.1 (2020-07-14)","text":""},{"location":"changelog.html#refactor_20","title":"Refactor","text":"<ul> <li>typecheck for Mapping instead of dict for combobox / selectionwidget add_items method</li> </ul>"},{"location":"changelog.html#v0930-2020-07-14","title":"v0.93.0 (2020-07-14)","text":""},{"location":"changelog.html#feat_111","title":"Feat","text":"<ul> <li>add register_extensions function to settings module</li> </ul>"},{"location":"changelog.html#refactor_21","title":"Refactor","text":"<ul> <li>Settings: do not override value method</li> </ul>"},{"location":"changelog.html#v0921-2020-07-14","title":"v0.92.1 (2020-07-14)","text":""},{"location":"changelog.html#fix_104","title":"Fix","text":"<ul> <li>winextras test fix</li> </ul>"},{"location":"changelog.html#v0920-2020-07-14","title":"v0.92.0 (2020-07-14)","text":""},{"location":"changelog.html#feat_112","title":"Feat","text":"<ul> <li>add widgets.SystemTrayIcon</li> <li>add winextras module</li> <li>Label: set_indent method</li> </ul>"},{"location":"changelog.html#v0910-2020-07-13","title":"v0.91.0 (2020-07-13)","text":""},{"location":"changelog.html#feat_113","title":"Feat","text":"<ul> <li>SidebarWidget: allow choosing layout</li> <li>MainWindow: add show_blocking method</li> </ul>"},{"location":"changelog.html#v0900-2020-07-13","title":"v0.90.0 (2020-07-13)","text":""},{"location":"changelog.html#feat_114","title":"Feat","text":"<ul> <li>Toolbar: allow combinations of allowed areas for set_allowed_areas</li> <li>SidebarWidget: add optional settings menu</li> </ul>"},{"location":"changelog.html#v0891-2020-07-13","title":"v0.89.1 (2020-07-13)","text":""},{"location":"changelog.html#refactor_22","title":"Refactor","text":"<ul> <li>SelectionWidget: switch to {data: label} dicts for add_items to be in line with RadioButton</li> </ul>"},{"location":"changelog.html#v0890-2020-07-13","title":"v0.89.0 (2020-07-13)","text":""},{"location":"changelog.html#feat_115","title":"Feat","text":"<ul> <li>SidebarWidget: make button width configurable</li> </ul>"},{"location":"changelog.html#v0881-2020-07-13","title":"v0.88.1 (2020-07-13)","text":""},{"location":"changelog.html#refactor_23","title":"Refactor","text":"<ul> <li>ComboBox: use set_data for set_value</li> </ul>"},{"location":"changelog.html#fix_105","title":"Fix","text":"<ul> <li>ComboBox: fix add_items method</li> </ul>"},{"location":"changelog.html#v0880-2020-07-13","title":"v0.88.0 (2020-07-13)","text":""},{"location":"changelog.html#feat_116","title":"Feat","text":"<ul> <li>ComboBox: set_data method</li> </ul>"},{"location":"changelog.html#v0870-2020-07-13","title":"v0.87.0 (2020-07-13)","text":""},{"location":"changelog.html#feat_117","title":"Feat","text":"<ul> <li>ComboBox: allow dict for add_items</li> </ul>"},{"location":"changelog.html#v0863-2020-07-12","title":"v0.86.3 (2020-07-12)","text":""},{"location":"changelog.html#refactor_24","title":"Refactor","text":"<ul> <li>RegexEditor: code cleanup</li> </ul>"},{"location":"changelog.html#v0862-2020-07-12","title":"v0.86.2 (2020-07-12)","text":""},{"location":"changelog.html#fix_106","title":"Fix","text":"<ul> <li>another deployment fix</li> </ul>"},{"location":"changelog.html#v0861-2020-07-12","title":"v0.86.1 (2020-07-12)","text":""},{"location":"changelog.html#fix_107","title":"Fix","text":"<ul> <li>deployment fix</li> </ul>"},{"location":"changelog.html#v0860-2020-07-12","title":"v0.86.0 (2020-07-12)","text":""},{"location":"changelog.html#feat_118","title":"Feat","text":"<ul> <li>add Scintilla CodeEditor</li> <li>PlainTextEdit: add color argument for highlight_current_line</li> </ul>"},{"location":"changelog.html#v0851-2020-07-10","title":"v0.85.1 (2020-07-10)","text":""},{"location":"changelog.html#fix_108","title":"Fix","text":"<ul> <li>add missing pygments requirement</li> </ul>"},{"location":"changelog.html#v0850-2020-07-10","title":"v0.85.0 (2020-07-10)","text":""},{"location":"changelog.html#feat_119","title":"Feat","text":"<ul> <li>dataset: add RegexPattern DataItem</li> <li>RegexEditor: use syntaxhighlighter for pattern</li> <li>RegexInput: use syntaxhighlighter for pattern</li> <li>PlainTextEdit: add set_syntaxhighlighter method</li> <li>Label: add set_color method</li> </ul>"},{"location":"changelog.html#refactor_25","title":"Refactor","text":"<ul> <li>CodeEditor: use pygments for syntax highlighting</li> </ul>"},{"location":"changelog.html#v0840-2020-07-10","title":"v0.84.0 (2020-07-10)","text":""},{"location":"changelog.html#feat_120","title":"Feat","text":"<ul> <li>sidebarwidget: allow setting tab by object id</li> <li>Object: name kwarg for Object.find_children, add Object.find_child</li> </ul>"},{"location":"changelog.html#v0831-2020-07-09","title":"v0.83.1 (2020-07-09)","text":""},{"location":"changelog.html#refactor_26","title":"Refactor","text":"<ul> <li>move set_icon from window classes to widget class</li> </ul>"},{"location":"changelog.html#v0830-2020-07-09","title":"v0.83.0 (2020-07-09)","text":""},{"location":"changelog.html#feat_121","title":"Feat","text":"<ul> <li>add Label.set_point_size</li> <li>add self for label methods to allow chaining</li> <li>Font.current_font context manager</li> </ul>"},{"location":"changelog.html#v0820-2020-07-09","title":"v0.82.0 (2020-07-09)","text":""},{"location":"changelog.html#feat_122","title":"Feat","text":"<ul> <li>add Label.set_bold / set_italic / set_weight</li> <li>added Font.set_weight</li> </ul>"},{"location":"changelog.html#v0810-2020-07-08","title":"v0.81.0 (2020-07-08)","text":""},{"location":"changelog.html#feat_123","title":"Feat","text":"<ul> <li>allow setting window icon color</li> <li>os dark mode detection</li> </ul>"},{"location":"changelog.html#v0801-2020-07-08","title":"v0.80.1 (2020-07-08)","text":""},{"location":"changelog.html#fix_109","title":"Fix","text":"<ul> <li>Settings.value() returned wrong type</li> </ul>"},{"location":"changelog.html#v0800-2020-07-08","title":"v0.80.0 (2020-07-08)","text":""},{"location":"changelog.html#feat_124","title":"Feat","text":"<ul> <li>add Widget.set_attribute</li> <li>add margin keyword argument to Widget.set_layout</li> </ul>"},{"location":"changelog.html#v0791-2020-07-08","title":"v0.79.1 (2020-07-08)","text":""},{"location":"changelog.html#fix_110","title":"Fix","text":"<ul> <li>remove Qt logger on Application exit</li> </ul>"},{"location":"changelog.html#v0790-2020-07-08","title":"v0.79.0 (2020-07-08)","text":""},{"location":"changelog.html#feat_125","title":"Feat","text":"<ul> <li>add widgets.Application.get_widget</li> </ul>"},{"location":"changelog.html#v0780-2020-07-08","title":"v0.78.0 (2020-07-08)","text":""},{"location":"changelog.html#feat_126","title":"Feat","text":"<ul> <li>allow to save/load window state recursively. Saving needs to be done explicitely now.</li> </ul>"},{"location":"changelog.html#fix_111","title":"Fix","text":"<ul> <li>some fixes for core.Settings dict interface</li> <li>properly preserve types in core.Settings</li> </ul>"},{"location":"changelog.html#v0771-2020-07-07","title":"v0.77.1 (2020-07-07)","text":""},{"location":"changelog.html#refactor_27","title":"Refactor","text":"<ul> <li>also allow qt flag for Splitter ctor</li> </ul>"},{"location":"changelog.html#fix_112","title":"Fix","text":"<ul> <li>return correct types for re.groupdict / re.groups</li> <li>Fixed an issue which prevented saving an image from chartview</li> </ul>"},{"location":"changelog.html#0770-2020-07-06","title":"0.77.0 (2020-07-06)","text":""},{"location":"changelog.html#feat_127","title":"Feat","text":"<ul> <li>allow custom icons for Messagebox</li> <li>add Icon.get_pixmap</li> <li>add Object.set_unique_id / Object.get_id</li> <li>allow None for set_max_height/width widget setters</li> <li>add checkboxdelegate</li> <li>add regexinput</li> <li>add pre-commit-hook for commit messages</li> </ul>"},{"location":"changelog.html#fix_113","title":"Fix","text":"<ul> <li>fix Messagebox.message call</li> </ul>"},{"location":"changelog.html#refactor_28","title":"Refactor","text":"<ul> <li>dont use property setter widget.id</li> <li>dont use property setter widget.title</li> <li>add child classes in re module</li> <li>radiodelegate stuff</li> <li>no props for abstractscrollarea scrollbars</li> </ul>"},{"location":"changelog.html#v0759-2020-07-05","title":"v0.75.9 (2020-07-05)","text":""},{"location":"changelog.html#v0758-2020-07-05","title":"v0.75.8 (2020-07-05)","text":""},{"location":"changelog.html#v0757-2020-07-05","title":"v0.75.7 (2020-07-05)","text":""},{"location":"changelog.html#v0756-2020-07-05","title":"v0.75.6 (2020-07-05)","text":""},{"location":"changelog.html#v0755-2020-07-05","title":"v0.75.5 (2020-07-05)","text":""},{"location":"changelog.html#v0754-2020-07-05","title":"v0.75.4 (2020-07-05)","text":""},{"location":"changelog.html#v0753-2020-07-05","title":"v0.75.3 (2020-07-05)","text":""},{"location":"changelog.html#v0752-2020-07-05","title":"v0.75.2 (2020-07-05)","text":""},{"location":"changelog.html#v0751-2020-07-05","title":"v0.75.1 (2020-07-05)","text":""},{"location":"changelog.html#v0750-2020-07-05","title":"v0.75.0 (2020-07-05)","text":""},{"location":"changelog.html#v0743-2020-07-05","title":"v0.74.3 (2020-07-05)","text":""},{"location":"changelog.html#v0742-2020-07-05","title":"v0.74.2 (2020-07-05)","text":""},{"location":"changelog.html#v0741-2020-07-05","title":"v0.74.1 (2020-07-05)","text":""},{"location":"changelog.html#v0740-2020-07-05","title":"v0.74.0 (2020-07-05)","text":""},{"location":"changelog.html#v0734-2020-07-04","title":"v0.73.4 (2020-07-04)","text":""},{"location":"changelog.html#v0733-2020-07-04","title":"v0.73.3 (2020-07-04)","text":""},{"location":"changelog.html#v0732-2020-07-04","title":"v0.73.2 (2020-07-04)","text":""},{"location":"changelog.html#v0731-2020-07-04","title":"v0.73.1 (2020-07-04)","text":""},{"location":"changelog.html#v0730-2020-07-02","title":"v0.73.0 (2020-07-02)","text":""},{"location":"changelog.html#v0723-2020-07-01","title":"v0.72.3 (2020-07-01)","text":""},{"location":"changelog.html#v0722-2020-07-01","title":"v0.72.2 (2020-07-01)","text":""},{"location":"changelog.html#v0721-2020-07-01","title":"v0.72.1 (2020-07-01)","text":""},{"location":"changelog.html#v0720-2020-07-01","title":"v0.72.0 (2020-07-01)","text":""},{"location":"changelog.html#v0710-2020-06-30","title":"v0.71.0 (2020-06-30)","text":""},{"location":"changelog.html#v0700-2020-06-30","title":"v0.70.0 (2020-06-30)","text":""},{"location":"changelog.html#v0690-2020-06-29","title":"v0.69.0 (2020-06-29)","text":""},{"location":"changelog.html#v0680-2020-06-29","title":"v0.68.0 (2020-06-29)","text":""},{"location":"changelog.html#v0671-2020-06-28","title":"v0.67.1 (2020-06-28)","text":""},{"location":"changelog.html#v0651-2020-06-24","title":"v0.65.1 (2020-06-24)","text":""},{"location":"changelog.html#v0650-2020-06-24","title":"v0.65.0 (2020-06-24)","text":""},{"location":"changelog.html#v0640-2020-06-24","title":"v0.64.0 (2020-06-24)","text":""},{"location":"changelog.html#v0630-2020-06-22","title":"v0.63.0 (2020-06-22)","text":""},{"location":"changelog.html#v0620-2020-06-21","title":"v0.62.0 (2020-06-21)","text":""},{"location":"changelog.html#v0610-2020-06-21","title":"v0.61.0 (2020-06-21)","text":""},{"location":"changelog.html#v0601-2020-06-21","title":"v0.60.1 (2020-06-21)","text":""},{"location":"changelog.html#v0600-2020-06-20","title":"v0.60.0 (2020-06-20)","text":""},{"location":"changelog.html#v0590-2020-06-20","title":"v0.59.0 (2020-06-20)","text":""},{"location":"changelog.html#v0581-2020-06-19","title":"v0.58.1 (2020-06-19)","text":""},{"location":"changelog.html#v0571-2020-06-15","title":"v0.57.1 (2020-06-15)","text":""},{"location":"changelog.html#v0570-2020-06-14","title":"v0.57.0 (2020-06-14)","text":""},{"location":"changelog.html#v0561-2020-06-10","title":"v0.56.1 (2020-06-10)","text":""},{"location":"changelog.html#v0560-2020-06-10","title":"v0.56.0 (2020-06-10)","text":""},{"location":"changelog.html#v0550-2020-06-09","title":"v0.55.0 (2020-06-09)","text":""},{"location":"changelog.html#v0540-2020-06-08","title":"v0.54.0 (2020-06-08)","text":""},{"location":"api/bluetooth.html","title":"bluetooth module","text":"<p>bluetooth module.</p> <p>contains QtBluetooth-based classes</p>"},{"location":"api/charts.html","title":"charts module","text":"<p>Charts module.</p>"},{"location":"api/charts.html#prettyqt.charts.abstractaxis","title":"<code>abstractaxis</code>","text":""},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxisMixin","title":"<code> AbstractAxisMixin            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/charts/abstractaxis.py</code> <pre><code>class AbstractAxisMixin(core.ObjectMixin):\n    def get_alignment(self) -&gt; constants.SideStr | None:\n\"\"\"Return current alignment.\n\n        Returns:\n            alignment\n        \"\"\"\n        alignment = self.alignment()\n        if alignment == constants.ALIGN_NONE:\n            return None\n        return constants.SIDES.inverse[alignment]\n\n    def get_orientation(self) -&gt; constants.OrientationStr | None:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        orientation = self.orientation()\n        if orientation == constants.ORIENTATION_NONE:\n            return None\n        return constants.ORIENTATION.inverse[orientation]\n\n    def get_grid_line_color(self) -&gt; gui.Color:\n        return gui.Color(self.gridLineColor())\n\n    def get_grid_line_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.gridLinePen())\n\n    def get_line_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.linePen())\n\n    def get_line_pen_color(self) -&gt; gui.Color:\n        return gui.Color(self.linePenColor())\n\n    def get_labels_color(self) -&gt; gui.Color:\n        return gui.Color(self.labelsColor())\n\n    def get_labels_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.labelsBrush())\n\n    def get_labels_font(self) -&gt; gui.Font:\n        return gui.Font(self.labelsFont())\n\n    def get_title_font(self) -&gt; gui.Font:\n        return gui.Font(self.titleFont())\n\n    def get_title_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.titleBrush())\n\n    def get_shades_color(self) -&gt; gui.Color:\n        return gui.Color(self.shadesColor())\n\n    def get_shades_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.shadesBrush())\n\n    def get_shades_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.shadesPen())\n\n    def get_shades_border_color(self) -&gt; gui.Color:\n        return gui.Color(self.shadesBorderColor())\n\n    def get_minor_grid_line_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.minorGridLinePen())\n\n    def get_minor_grid_line_color(self) -&gt; gui.Color:\n        return gui.Color(self.minorGridLineColor())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxisMixin.get_alignment","title":"<code>get_alignment(self) -&gt; constants.SideStr | None</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.SideStr | None</code> <p>alignment</p> Source code in <code>prettyqt/charts/abstractaxis.py</code> <pre><code>def get_alignment(self) -&gt; constants.SideStr | None:\n\"\"\"Return current alignment.\n\n    Returns:\n        alignment\n    \"\"\"\n    alignment = self.alignment()\n    if alignment == constants.ALIGN_NONE:\n        return None\n    return constants.SIDES.inverse[alignment]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxisMixin.get_orientation","title":"<code>get_orientation(self) -&gt; constants.OrientationStr | None</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr | None</code> <p>orientation</p> Source code in <code>prettyqt/charts/abstractaxis.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr | None:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    orientation = self.orientation()\n    if orientation == constants.ORIENTATION_NONE:\n        return None\n    return constants.ORIENTATION.inverse[orientation]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries","title":"<code>abstractbarseries</code>","text":""},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeriesMixin","title":"<code> AbstractBarSeriesMixin            (AbstractSeriesMixin)         </code>","text":"Source code in <code>prettyqt/charts/abstractbarseries.py</code> <pre><code>class AbstractBarSeriesMixin(charts.AbstractSeriesMixin):\n    def __delitem__(self, index: int):\n        barsets = self.barSets()\n        self.remove(barsets[index])\n\n    def __getitem__(self, index: int) -&gt; QtCharts.QBarSet:\n        barsets = self.barSets()\n        return barsets[index]\n\n    def set_labels_position(self, position: LabelsPositionStr):\n\"\"\"Set the labels position.\n\n        Args:\n            position: labels position\n\n        Raises:\n            InvalidParamError: labels position does not exist\n        \"\"\"\n        if position not in LABELS_POSITIONS:\n            raise InvalidParamError(position, LABELS_POSITIONS)\n        self.setLabelsPosition(LABELS_POSITIONS[position])\n\n    def get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n\n        Returns:\n            labels position\n        \"\"\"\n        return LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeriesMixin.get_labels_position","title":"<code>get_labels_position(self) -&gt; LabelsPositionStr</code>","text":"<p>Return current labels position.</p> <p>Returns:</p> Type Description <code>LabelsPositionStr</code> <p>labels position</p> Source code in <code>prettyqt/charts/abstractbarseries.py</code> <pre><code>def get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n\n    Returns:\n        labels position\n    \"\"\"\n    return LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeriesMixin.set_labels_position","title":"<code>set_labels_position(self, position: LabelsPositionStr)</code>","text":"<p>Set the labels position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>LabelsPositionStr</code> <p>labels position</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>labels position does not exist</p> Source code in <code>prettyqt/charts/abstractbarseries.py</code> <pre><code>def set_labels_position(self, position: LabelsPositionStr):\n\"\"\"Set the labels position.\n\n    Args:\n        position: labels position\n\n    Raises:\n        InvalidParamError: labels position does not exist\n    \"\"\"\n    if position not in LABELS_POSITIONS:\n        raise InvalidParamError(position, LABELS_POSITIONS)\n    self.setLabelsPosition(LABELS_POSITIONS[position])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.abstractseries","title":"<code>abstractseries</code>","text":""},{"location":"api/charts.html#prettyqt.charts.abstractseries.AbstractSeriesMixin","title":"<code> AbstractSeriesMixin            (ObjectMixin)         </code>","text":"<p>QAbstractSeries with some custom properties.</p> Source code in <code>prettyqt/charts/abstractseries.py</code> <pre><code>class AbstractSeriesMixin(core.ObjectMixin):\n\"\"\"QAbstractSeries with some custom properties.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._group = \"\"\n\n    def get_group(self):\n        return self._group\n\n    def set_group(self, value):\n        self._group = value\n\n    group = core.Property(str, get_group, set_group)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.categoryaxis","title":"<code>categoryaxis</code>","text":""},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis","title":"<code> CategoryAxis            (ValueAxisMixin, QCategoryAxis)         </code>","text":"Source code in <code>prettyqt/charts/categoryaxis.py</code> <pre><code>class CategoryAxis(charts.ValueAxisMixin, QtCharts.QCategoryAxis):\n    def __delitem__(self, index: str):\n        self.remove(index)\n\n    def __getitem__(self, label: int | slice) -&gt; str | list[str]:\n        return self.categoriesLabels()[label]\n\n    def __setitem__(self, index: str, value: str):\n        self.replaceLabel(index, value)\n\n    def __iter__(self) -&gt; Iterator[str]:\n        return iter(self.categoriesLabels())\n\n    def __add__(self, other: tuple[str, int]) -&gt; CategoryAxis:\n        self.append(*other)\n        return self\n\n    def __len__(self):\n        # needed for PySide6\n        return self.count()\n\n    def set_labels_position(self, position: LabelsPositionStr):\n\"\"\"Set the labels position.\n\n        Args:\n            position: labels position\n\n        Raises:\n            InvalidParamError: labels position does not exist\n        \"\"\"\n        if position not in LABELS_POSITIONS:\n            raise InvalidParamError(position, LABELS_POSITIONS)\n        self.setLabelsPosition(LABELS_POSITIONS[position])\n\n    def get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n\n        Returns:\n            labels position\n        \"\"\"\n        return LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.get_labels_position","title":"<code>get_labels_position(self) -&gt; LabelsPositionStr</code>","text":"<p>Return current labels position.</p> <p>Returns:</p> Type Description <code>LabelsPositionStr</code> <p>labels position</p> Source code in <code>prettyqt/charts/categoryaxis.py</code> <pre><code>def get_labels_position(self) -&gt; LabelsPositionStr:\n\"\"\"Return current labels position.\n\n    Returns:\n        labels position\n    \"\"\"\n    return LABELS_POSITIONS.inverse[self.labelsPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.set_labels_position","title":"<code>set_labels_position(self, position: LabelsPositionStr)</code>","text":"<p>Set the labels position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>LabelsPositionStr</code> <p>labels position</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>labels position does not exist</p> Source code in <code>prettyqt/charts/categoryaxis.py</code> <pre><code>def set_labels_position(self, position: LabelsPositionStr):\n\"\"\"Set the labels position.\n\n    Args:\n        position: labels position\n\n    Raises:\n        InvalidParamError: labels position does not exist\n    \"\"\"\n    if position not in LABELS_POSITIONS:\n        raise InvalidParamError(position, LABELS_POSITIONS)\n    self.setLabelsPosition(LABELS_POSITIONS[position])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chart","title":"<code>chart</code>","text":""},{"location":"api/charts.html#prettyqt.charts.chart.ChartMixin","title":"<code> ChartMixin            (GraphicsWidgetMixin)         </code>","text":"Source code in <code>prettyqt/charts/chart.py</code> <pre><code>class ChartMixin(widgets.GraphicsWidgetMixin):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.max_x = 0\n        self.max_y = 0\n        self.min_x = 0\n        self.min_y = 0\n\n    def serialize_fields(self):\n        return dict(\n            animation_duration=self.animationDuration(),\n            animation_easing_curve=self.get_animation_easing_curve(),\n            animation_options=self.get_animation_options(),\n            background_roundness=self.backgroundRoundness(),\n            background_visible=self.isBackgroundVisible(),\n            chart_type=self.get_chart_type(),\n            drop_shadow_enabled=self.isDropShadowEnabled(),\n            locale=self.get_locale(),\n            localize_numbers=self.localizeNumbers(),\n            margins=self.get_margins(),\n            plot_area=self.get_plot_area(),\n            plot_area_background_visible=self.isPlotAreaBackgroundVisible(),\n            theme=self.get_theme(),\n            title=self.title(),\n        )\n\n    def update_boundaries(self):\n\"\"\"Set new min/max values based on axis.\"\"\"\n        self.max_x = self.axisX().max()\n        self.max_y = self.axisY().max()\n        self.min_x = self.axisX().min()\n        self.min_y = self.axisY().min()\n\n    def hide_legend(self):\n        self.legend().hide()\n\n    def show_legend(self):\n        self.legend().show()\n\n    def get_legend(self) -&gt; charts.Legend:\n        return charts.Legend(self.legend())\n\n    def set_legend_alignment(self, alignment: constants.SideStr):\n        if alignment not in constants.SIDES:\n            raise InvalidParamError(alignment, constants.SIDES)\n        self.legend().setAlignment(constants.SIDES[alignment])\n\n    def set_theme(self, theme_name: ThemeStr):\n        self.setTheme(THEMES[theme_name])\n\n    def set_margins(self, margins: datatypes.MarginsType):\n        if isinstance(margins, tuple):\n            margins = QtCore.QMargins(*margins)\n        self.setMargins(margins)\n\n    def set_animation_options(self, option: AnimationOptionStr):\n        self.setAnimationOptions(ANIMATION_OPTIONS[option])\n\n    def apply_nice_numbers(self):\n\"\"\"Adjust both axis to display nice round numbers.\"\"\"\n        self.axisX().applyNiceNumbers()\n        self.axisY().applyNiceNumbers()\n\n    def zoom_by_factor(self, factor: float):\n\"\"\"Zoom in/out by factor (1.0 = no change).\n\n        Make sure that we dont zoom out too far\n        \"\"\"\n        self.zoom(factor)\n        if self.axisX().min() &lt; self.min_x:\n            self.axisX().setMin(self.min_x)\n        if self.axisX().max() &gt; self.max_x:\n            self.axisX().setMax(self.max_x)\n        if self.axisY().max() &gt; self.max_y:\n            self.axisY().setMax(self.max_y)\n\n        # always bottom-align when zooming for now. should perhaps become optional.\n        # if self.axisY().min() &lt; self.min_y:\n        self.axisY().setMin(max(0, self.min_y))\n\n    def get_chart_type(self) -&gt; ChartTypeStr:\n        return CHART_TYPES.inverse[self.chartType()]\n\n    def get_margins(self) -&gt; core.Margins:\n        return core.Margins(self.margins())\n\n    def get_plot_area(self) -&gt; core.RectF:\n        return core.RectF(self.plotArea())\n\n    def get_locale(self) -&gt; core.Locale:\n        return core.Locale(self.locale())\n\n    def get_theme(self) -&gt; ThemeStr:\n        return THEMES.inverse[self.theme()]\n\n    def get_animation_options(self) -&gt; list[AnimationOptionStr]:\n        return [k for k, v in ANIMATION_OPTIONS.items() if v &amp; self.animationOptions()]\n\n    def get_animation_easing_curve(self) -&gt; core.EasingCurve:\n        return core.EasingCurve(self.animationEasingCurve())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chart.ChartMixin.apply_nice_numbers","title":"<code>apply_nice_numbers(self)</code>","text":"<p>Adjust both axis to display nice round numbers.</p> Source code in <code>prettyqt/charts/chart.py</code> <pre><code>def apply_nice_numbers(self):\n\"\"\"Adjust both axis to display nice round numbers.\"\"\"\n    self.axisX().applyNiceNumbers()\n    self.axisY().applyNiceNumbers()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chart.ChartMixin.update_boundaries","title":"<code>update_boundaries(self)</code>","text":"<p>Set new min/max values based on axis.</p> Source code in <code>prettyqt/charts/chart.py</code> <pre><code>def update_boundaries(self):\n\"\"\"Set new min/max values based on axis.\"\"\"\n    self.max_x = self.axisX().max()\n    self.max_y = self.axisY().max()\n    self.min_x = self.axisX().min()\n    self.min_y = self.axisY().min()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chart.ChartMixin.zoom_by_factor","title":"<code>zoom_by_factor(self, factor: float)</code>","text":"<p>Zoom in/out by factor (1.0 = no change).</p> <p>Make sure that we dont zoom out too far</p> Source code in <code>prettyqt/charts/chart.py</code> <pre><code>def zoom_by_factor(self, factor: float):\n\"\"\"Zoom in/out by factor (1.0 = no change).\n\n    Make sure that we dont zoom out too far\n    \"\"\"\n    self.zoom(factor)\n    if self.axisX().min() &lt; self.min_x:\n        self.axisX().setMin(self.min_x)\n    if self.axisX().max() &gt; self.max_x:\n        self.axisX().setMax(self.max_x)\n    if self.axisY().max() &gt; self.max_y:\n        self.axisY().setMax(self.max_y)\n\n    # always bottom-align when zooming for now. should perhaps become optional.\n    # if self.axisY().min() &lt; self.min_y:\n    self.axisY().setMin(max(0, self.min_y))\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview","title":"<code>chartview</code>","text":""},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView","title":"<code> ChartView            (GraphicsViewMixin, QChartView)         </code>","text":"Source code in <code>prettyqt/charts/chartview.py</code> <pre><code>class ChartView(widgets.GraphicsViewMixin, QtCharts.QChartView):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        chart = charts.Chart()\n        self.setChart(chart)\n        self.setRenderHint(gui.Painter.RenderHint.Antialiasing)\n        self.set_rubber_band(\"rectangle\")\n        # self.setDragMode(self.RubberBandDrag)\n\n    def keyPressEvent(self, event: QtGui.QKeyEvent):\n\"\"\"Handle keypress events to allow navigation via keyboard.\"\"\"\n        match event.key():\n            case QtCore.Qt.Key.Key_Escape:\n                self.chart().zoomReset()\n            case QtCore.Qt.Key.Key_Plus:\n                self.chart().zoom_by_factor(ZOOM_IN_FACTOR)\n            case QtCore.Qt.Key.Key_Minus:\n                self.chart().zoom_by_factor(ZOOM_OUT_FACTOR)\n            case QtCore.Qt.Key.Key_Left:\n                self.chart().scroll(-SCROLL_STEP_SIZE, 0)\n            case QtCore.Qt.Key.Key_Right:\n                self.chart().scroll(SCROLL_STEP_SIZE, 0)\n            case QtCore.Qt.Key.Key_Up:\n                self.chart().scroll(0, SCROLL_STEP_SIZE)\n            case QtCore.Qt.Key.Key_Down:\n                self.chart().scroll(0, -SCROLL_STEP_SIZE)\n            case QtCore.Qt.Key.Key_0:\n                self.chart().apply_nice_numbers()\n            case _:\n                super().keyPressEvent(event)\n                return\n        event.accept()\n\n    def wheelEvent(self, event: QtGui.QWheelEvent):\n\"\"\"Handle wheel event for zooming.\"\"\"\n        fct = ZOOM_IN_FACTOR if event.angleDelta().y() &gt; 0 else ZOOM_OUT_FACTOR\n        self.chart().zoom_by_factor(fct)\n\n    def mouseReleaseEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n        if event.button() == QtCore.Qt.MouseButton.RightButton:\n            widgets.Application.restoreOverrideCursor()\n            event.accept()\n            return\n        super().mouseReleaseEvent(event)\n\n    def mousePressEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n        if event.button() == QtCore.Qt.MouseButton.RightButton:\n            widgets.Application.set_override_cursor(\"size_all\")\n            self.last_mouse_pos = event.position()\n            event.accept()\n\n        super().mousePressEvent(event)\n\n    def mouseMoveEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n        # pan the chart with a middle mouse drag\n        if event.buttons() &amp; QtCore.Qt.MouseButton.RightButton:  # type: ignore\n            if not self.last_mouse_pos:\n                return\n            pos_diff = event.position() - self.last_mouse_pos\n            self.chart().scroll(-pos_diff.x(), pos_diff.y())\n\n            self.last_mouse_pos = event.position()\n            event.accept()\n\n        super().mouseMoveEvent(event)\n\n    @core.Slot()\n    def save_as_image(self):\n\"\"\"Let user choose folder and save chart as an image file.\"\"\"\n        dlg = widgets.FileDialog(mode=\"save\", caption=\"Save image\")\n        filters = {\"Bmp files\": [\".bmp\"], \"Jpeg files\": [\".jpg\"], \"Png files\": [\".png\"]}\n        dlg.set_extension_filter(filters)\n        filename = dlg.open_file()\n        if not filename:\n            return\n        self.chart().show_legend()\n        image = self.get_image()\n        image.save(str(filename[0]))\n        self.chart().hide_legend()\n\n    def set_rubber_band(self, typ: RubberBandStr):\n\"\"\"Set the rubber band type.\n\n        Args:\n            typ: rubber band type\n\n        Raises:\n            InvalidParamError: rubber band type does not exist\n        \"\"\"\n        if typ not in RUBBER_BAND:\n            raise InvalidParamError(typ, RUBBER_BAND)\n        self.setRubberBand(RUBBER_BAND[typ])\n\n    def get_rubber_band(self) -&gt; RubberBandStr:\n\"\"\"Return current rubber band type.\n\n        Returns:\n            Rubber band type\n        \"\"\"\n        return RUBBER_BAND.inverse[self.rubberBand()]\n\n    # def hide_legend(self):\n    #     self.chart().hide_legend()\n\n    # def show_legend(self):\n    #     self.chart().show_legend()\n\n    # def set_legend_alignment(self, alignment: str):\n    #     if alignment not in constants.SIDES:\n    #         raise ValueError(f\"{alignment!r} not a valid alignment.\")\n    #     self.chart().legend().setAlignment(constants.SIDES[alignment])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.get_rubber_band","title":"<code>get_rubber_band(self) -&gt; RubberBandStr</code>","text":"<p>Return current rubber band type.</p> <p>Returns:</p> Type Description <code>RubberBandStr</code> <p>Rubber band type</p> Source code in <code>prettyqt/charts/chartview.py</code> <pre><code>def get_rubber_band(self) -&gt; RubberBandStr:\n\"\"\"Return current rubber band type.\n\n    Returns:\n        Rubber band type\n    \"\"\"\n    return RUBBER_BAND.inverse[self.rubberBand()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.keyPressEvent","title":"<code>keyPressEvent(self, event: QtGui.QKeyEvent)</code>","text":"<p>Handle keypress events to allow navigation via keyboard.</p> Source code in <code>prettyqt/charts/chartview.py</code> <pre><code>def keyPressEvent(self, event: QtGui.QKeyEvent):\n\"\"\"Handle keypress events to allow navigation via keyboard.\"\"\"\n    match event.key():\n        case QtCore.Qt.Key.Key_Escape:\n            self.chart().zoomReset()\n        case QtCore.Qt.Key.Key_Plus:\n            self.chart().zoom_by_factor(ZOOM_IN_FACTOR)\n        case QtCore.Qt.Key.Key_Minus:\n            self.chart().zoom_by_factor(ZOOM_OUT_FACTOR)\n        case QtCore.Qt.Key.Key_Left:\n            self.chart().scroll(-SCROLL_STEP_SIZE, 0)\n        case QtCore.Qt.Key.Key_Right:\n            self.chart().scroll(SCROLL_STEP_SIZE, 0)\n        case QtCore.Qt.Key.Key_Up:\n            self.chart().scroll(0, SCROLL_STEP_SIZE)\n        case QtCore.Qt.Key.Key_Down:\n            self.chart().scroll(0, -SCROLL_STEP_SIZE)\n        case QtCore.Qt.Key.Key_0:\n            self.chart().apply_nice_numbers()\n        case _:\n            super().keyPressEvent(event)\n            return\n    event.accept()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseMoveEvent","title":"<code>mouseMoveEvent(self, event: QtGui.QMouseEvent)</code>","text":"<p>Override to allow dragging the chart.</p> Source code in <code>prettyqt/charts/chartview.py</code> <pre><code>def mouseMoveEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n    # pan the chart with a middle mouse drag\n    if event.buttons() &amp; QtCore.Qt.MouseButton.RightButton:  # type: ignore\n        if not self.last_mouse_pos:\n            return\n        pos_diff = event.position() - self.last_mouse_pos\n        self.chart().scroll(-pos_diff.x(), pos_diff.y())\n\n        self.last_mouse_pos = event.position()\n        event.accept()\n\n    super().mouseMoveEvent(event)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mousePressEvent","title":"<code>mousePressEvent(self, event: QtGui.QMouseEvent)</code>","text":"<p>Override to allow dragging the chart.</p> Source code in <code>prettyqt/charts/chartview.py</code> <pre><code>def mousePressEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n    if event.button() == QtCore.Qt.MouseButton.RightButton:\n        widgets.Application.set_override_cursor(\"size_all\")\n        self.last_mouse_pos = event.position()\n        event.accept()\n\n    super().mousePressEvent(event)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseReleaseEvent","title":"<code>mouseReleaseEvent(self, event: QtGui.QMouseEvent)</code>","text":"<p>Override to allow dragging the chart.</p> Source code in <code>prettyqt/charts/chartview.py</code> <pre><code>def mouseReleaseEvent(self, event: QtGui.QMouseEvent):\n\"\"\"Override to allow dragging the chart.\"\"\"\n    if event.button() == QtCore.Qt.MouseButton.RightButton:\n        widgets.Application.restoreOverrideCursor()\n        event.accept()\n        return\n    super().mouseReleaseEvent(event)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.save_as_image","title":"<code>save_as_image(self)</code>","text":"<p>Let user choose folder and save chart as an image file.</p> Source code in <code>prettyqt/charts/chartview.py</code> <pre><code>@core.Slot()\ndef save_as_image(self):\n\"\"\"Let user choose folder and save chart as an image file.\"\"\"\n    dlg = widgets.FileDialog(mode=\"save\", caption=\"Save image\")\n    filters = {\"Bmp files\": [\".bmp\"], \"Jpeg files\": [\".jpg\"], \"Png files\": [\".png\"]}\n    dlg.set_extension_filter(filters)\n    filename = dlg.open_file()\n    if not filename:\n        return\n    self.chart().show_legend()\n    image = self.get_image()\n    image.save(str(filename[0]))\n    self.chart().hide_legend()\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.set_rubber_band","title":"<code>set_rubber_band(self, typ: RubberBandStr)</code>","text":"<p>Set the rubber band type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>RubberBandStr</code> <p>rubber band type</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>rubber band type does not exist</p> Source code in <code>prettyqt/charts/chartview.py</code> <pre><code>def set_rubber_band(self, typ: RubberBandStr):\n\"\"\"Set the rubber band type.\n\n    Args:\n        typ: rubber band type\n\n    Raises:\n        InvalidParamError: rubber band type does not exist\n    \"\"\"\n    if typ not in RUBBER_BAND:\n        raise InvalidParamError(typ, RUBBER_BAND)\n    self.setRubberBand(RUBBER_BAND[typ])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.wheelEvent","title":"<code>wheelEvent(self, event: QtGui.QWheelEvent)</code>","text":"<p>Handle wheel event for zooming.</p> Source code in <code>prettyqt/charts/chartview.py</code> <pre><code>def wheelEvent(self, event: QtGui.QWheelEvent):\n\"\"\"Handle wheel event for zooming.\"\"\"\n    fct = ZOOM_IN_FACTOR if event.angleDelta().y() &gt; 0 else ZOOM_OUT_FACTOR\n    self.chart().zoom_by_factor(fct)\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend","title":"<code>legend</code>","text":""},{"location":"api/charts.html#prettyqt.charts.legend.Legend","title":"<code> Legend            (GraphicsWidgetMixin)         </code>","text":"Source code in <code>prettyqt/charts/legend.py</code> <pre><code>class Legend(widgets.GraphicsWidgetMixin):\n    def __init__(self, item: QtCharts.QLegend):\n        self.item = item\n\n    def __getattr__(self, val):\n        return getattr(self.item, val)\n\n    def serialize_fields(self):\n        return dict(\n            alignment=self.get_alignment(),\n            background_visible=self.isBackgroundVisible(),\n            border_color=self.get_border_color(),\n            color=self.get_color(),\n            font=self.get_font(),\n            label_color=self.get_label_color(),\n            marker_shape=self.get_marker_shape(),\n            reverse_markers=self.reverseMarkers(),\n            show_tooltips=self.showToolTips(),\n        )\n\n    def set_alignment(self, alignment: constants.SideStr):\n\"\"\"Set the alignment of the legend.\n\n        Args:\n            alignment: alignment for the legend\n\n        Raises:\n            InvalidParamError: alignment does not exist\n        \"\"\"\n        if alignment not in constants.SIDES:\n            raise InvalidParamError(alignment, constants.SIDES)\n        self.setAlignment(constants.SIDES[alignment])\n\n    def get_alignment(self) -&gt; constants.SideStr:\n\"\"\"Return current alignment.\n\n        Returns:\n            alignment\n        \"\"\"\n        return constants.SIDES.inverse[self.alignment()]\n\n    def set_marker_shape(self, shape: MarkerShapeStr):\n\"\"\"Set the marker shape.\n\n        Args:\n            shape: marker shape\n\n        Raises:\n            InvalidParamError: marker shape does not exist\n        \"\"\"\n        if shape not in MARKER_SHAPES:\n            raise InvalidParamError(shape, MARKER_SHAPES)\n        self.setMarkerShape(MARKER_SHAPES[shape])\n\n    def get_marker_shape(self) -&gt; MarkerShapeStr:\n\"\"\"Return current marker shape.\n\n        Returns:\n            Marker shape\n        \"\"\"\n        return MARKER_SHAPES.inverse[self.markerShape()]\n\n    def get_border_color(self) -&gt; gui.Color:\n        return gui.Color(self.borderColor())\n\n    def get_color(self) -&gt; gui.Color:\n        return gui.Color(self.color())\n\n    def get_label_color(self) -&gt; gui.Color:\n        return gui.Color(self.labelColor())\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_alignment","title":"<code>get_alignment(self) -&gt; constants.SideStr</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.SideStr</code> <p>alignment</p> Source code in <code>prettyqt/charts/legend.py</code> <pre><code>def get_alignment(self) -&gt; constants.SideStr:\n\"\"\"Return current alignment.\n\n    Returns:\n        alignment\n    \"\"\"\n    return constants.SIDES.inverse[self.alignment()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_marker_shape","title":"<code>get_marker_shape(self) -&gt; MarkerShapeStr</code>","text":"<p>Return current marker shape.</p> <p>Returns:</p> Type Description <code>MarkerShapeStr</code> <p>Marker shape</p> Source code in <code>prettyqt/charts/legend.py</code> <pre><code>def get_marker_shape(self) -&gt; MarkerShapeStr:\n\"\"\"Return current marker shape.\n\n    Returns:\n        Marker shape\n    \"\"\"\n    return MARKER_SHAPES.inverse[self.markerShape()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_alignment","title":"<code>set_alignment(self, alignment: constants.SideStr)</code>","text":"<p>Set the alignment of the legend.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.SideStr</code> <p>alignment for the legend</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>alignment does not exist</p> Source code in <code>prettyqt/charts/legend.py</code> <pre><code>def set_alignment(self, alignment: constants.SideStr):\n\"\"\"Set the alignment of the legend.\n\n    Args:\n        alignment: alignment for the legend\n\n    Raises:\n        InvalidParamError: alignment does not exist\n    \"\"\"\n    if alignment not in constants.SIDES:\n        raise InvalidParamError(alignment, constants.SIDES)\n    self.setAlignment(constants.SIDES[alignment])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_marker_shape","title":"<code>set_marker_shape(self, shape: MarkerShapeStr)</code>","text":"<p>Set the marker shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>MarkerShapeStr</code> <p>marker shape</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>marker shape does not exist</p> Source code in <code>prettyqt/charts/legend.py</code> <pre><code>def set_marker_shape(self, shape: MarkerShapeStr):\n\"\"\"Set the marker shape.\n\n    Args:\n        shape: marker shape\n\n    Raises:\n        InvalidParamError: marker shape does not exist\n    \"\"\"\n    if shape not in MARKER_SHAPES:\n        raise InvalidParamError(shape, MARKER_SHAPES)\n    self.setMarkerShape(MARKER_SHAPES[shape])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.pieslice","title":"<code>pieslice</code>","text":""},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice","title":"<code> PieSlice            (ObjectMixin, QPieSlice)         </code>","text":"Source code in <code>prettyqt/charts/pieslice.py</code> <pre><code>class PieSlice(core.ObjectMixin, QtCharts.QPieSlice):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.label()!r}, {self.value()})\"\n\n    def set_label_position(self, position: LabelPositionStr):\n\"\"\"Set the label position.\n\n        Args:\n            position: label position\n\n        Raises:\n            InvalidParamError: label position does not exist\n        \"\"\"\n        if position not in LABEL_POSITION:\n            raise InvalidParamError(position, LABEL_POSITION)\n        self.setLabelPosition(LABEL_POSITION[position])\n\n    def get_label_position(self) -&gt; LabelPositionStr:\n\"\"\"Return current label position.\n\n        Returns:\n            label position\n        \"\"\"\n        return LABEL_POSITION.inverse[self.labelPosition()]\n\n    def get_label_font(self) -&gt; gui.Font:\n        return gui.Font(self.labelFont())\n\n    def get_label_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.labelBrush())\n\n    def get_label_color(self) -&gt; gui.Color:\n        return gui.Color(self.labelColor())\n\n    def get_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.pen())\n\n    def get_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.brush())\n\n    def get_color(self) -&gt; gui.Color:\n        return gui.Color(self.color())\n\n    def get_border_color(self) -&gt; gui.Color:\n        return gui.Color(self.borderColor())\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.get_label_position","title":"<code>get_label_position(self) -&gt; LabelPositionStr</code>","text":"<p>Return current label position.</p> <p>Returns:</p> Type Description <code>LabelPositionStr</code> <p>label position</p> Source code in <code>prettyqt/charts/pieslice.py</code> <pre><code>def get_label_position(self) -&gt; LabelPositionStr:\n\"\"\"Return current label position.\n\n    Returns:\n        label position\n    \"\"\"\n    return LABEL_POSITION.inverse[self.labelPosition()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.set_label_position","title":"<code>set_label_position(self, position: LabelPositionStr)</code>","text":"<p>Set the label position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>LabelPositionStr</code> <p>label position</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>label position does not exist</p> Source code in <code>prettyqt/charts/pieslice.py</code> <pre><code>def set_label_position(self, position: LabelPositionStr):\n\"\"\"Set the label position.\n\n    Args:\n        position: label position\n\n    Raises:\n        InvalidParamError: label position does not exist\n    \"\"\"\n    if position not in LABEL_POSITION:\n        raise InvalidParamError(position, LABEL_POSITION)\n    self.setLabelPosition(LABEL_POSITION[position])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.valueaxis","title":"<code>valueaxis</code>","text":""},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxisMixin","title":"<code> ValueAxisMixin            (AbstractAxisMixin)         </code>","text":"Source code in <code>prettyqt/charts/valueaxis.py</code> <pre><code>class ValueAxisMixin(charts.AbstractAxisMixin):\n    def set_tick_type(self, tick_type: TickTypeStr):\n\"\"\"Set the tick type of the legend.\n\n        Args:\n            tick_type: tick type for the legend\n\n        Raises:\n            InvalidParamError: tick type does not exist\n        \"\"\"\n        if tick_type not in TICK_TYPES:\n            raise InvalidParamError(tick_type, TICK_TYPES)\n        self.setTickType(TICK_TYPES[tick_type])\n\n    def get_tick_type(self) -&gt; TickTypeStr:\n\"\"\"Return current tick type.\n\n        Returns:\n            tick_type\n        \"\"\"\n        return TICK_TYPES.inverse[self.tickType()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxisMixin.get_tick_type","title":"<code>get_tick_type(self) -&gt; TickTypeStr</code>","text":"<p>Return current tick type.</p> <p>Returns:</p> Type Description <code>TickTypeStr</code> <p>tick_type</p> Source code in <code>prettyqt/charts/valueaxis.py</code> <pre><code>def get_tick_type(self) -&gt; TickTypeStr:\n\"\"\"Return current tick type.\n\n    Returns:\n        tick_type\n    \"\"\"\n    return TICK_TYPES.inverse[self.tickType()]\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxisMixin.set_tick_type","title":"<code>set_tick_type(self, tick_type: TickTypeStr)</code>","text":"<p>Set the tick type of the legend.</p> <p>Parameters:</p> Name Type Description Default <code>tick_type</code> <code>TickTypeStr</code> <p>tick type for the legend</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>tick type does not exist</p> Source code in <code>prettyqt/charts/valueaxis.py</code> <pre><code>def set_tick_type(self, tick_type: TickTypeStr):\n\"\"\"Set the tick type of the legend.\n\n    Args:\n        tick_type: tick type for the legend\n\n    Raises:\n        InvalidParamError: tick type does not exist\n    \"\"\"\n    if tick_type not in TICK_TYPES:\n        raise InvalidParamError(tick_type, TICK_TYPES)\n    self.setTickType(TICK_TYPES[tick_type])\n</code></pre>"},{"location":"api/charts.html#prettyqt.charts.xyseries","title":"<code>xyseries</code>","text":""},{"location":"api/charts.html#prettyqt.charts.xyseries.XYSeriesMixin","title":"<code> XYSeriesMixin            (AbstractSeriesMixin)         </code>","text":"<p>QXYSeries with some custom properties.</p> Source code in <code>prettyqt/charts/xyseries.py</code> <pre><code>class XYSeriesMixin(charts.AbstractSeriesMixin):\n\"\"\"QXYSeries with some custom properties.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # self._process_name = \"\"\n        self.setUseOpenGL()\n\n    def __setitem__(self, index: int, val: QtCore.QPointF):\n        self.replace(index, val)\n\n    def __delitem__(self, index: int):\n        self.remove(index)\n\n    def __setstate__(self, state):\n        self.append(state[\"points\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __add__(self, other: QtCore.QPointF) -&gt; XYSeries:\n        self.append(other)\n        return self\n\n    def serialize_fields(self):\n        if prettyqt.qt.API == \"pyqt6\":\n            points = [self.at(i) for i in range(self.count())]\n        else:\n            points = self.points()\n        return dict(points=points)\n\n    def get_pen(self) -&gt; gui.Pen:\n        return gui.Pen(self.pen())\n\n    def get_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.brush())\n</code></pre>"},{"location":"api/constants.html","title":"constants module","text":"<p>Constants module.</p>"},{"location":"api/core.html","title":"core module","text":"<p>Core module.</p> <p>Contains QtCore-based classes</p>"},{"location":"api/core.html#prettyqt.core.abstractanimation","title":"<code>abstractanimation</code>","text":""},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin","title":"<code> AbstractAnimationMixin            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/core/abstractanimation.py</code> <pre><code>class AbstractAnimationMixin(core.ObjectMixin):\n    def __len__(self):\n        return self.duration()\n\n    def __and__(self, other: AbstractAnimation) -&gt; core.SequentialAnimationGroup:\n        group = core.SequentialAnimationGroup()\n        group.addAnimation(self)\n        group.addAnimation(other)\n        return group\n\n    def __or__(self, other: AbstractAnimation) -&gt; core.ParallelAnimationGroup:\n        group = core.ParallelAnimationGroup()\n        group.addAnimation(self)\n        group.addAnimation(other)\n        return group\n\n    def serialize_fields(self):\n        return dict(\n            duration=self.duration(),\n            direction=self.get_direction(),\n            loop_count=self.loopCount(),\n            current_time=self.currentTime(),\n        )\n\n    def set_direction(self, direction: DirectionStr):\n\"\"\"Set animation direction.\n\n        Args:\n            direction: animation direction\n\n        Raises:\n            InvalidParamError: animation direction does not exist\n        \"\"\"\n        if direction not in DIRECTION:\n            raise InvalidParamError(direction, DIRECTION)\n        self.setDirection(DIRECTION[direction])\n\n    def get_direction(self) -&gt; DirectionStr:\n\"\"\"Get the current animation direction.\n\n        Returns:\n            animation direction\n        \"\"\"\n        return DIRECTION.inverse[self.direction()]\n\n    def get_state(self) -&gt; StateStr:\n\"\"\"Get the current animation state.\n\n        Returns:\n            animation state\n        \"\"\"\n        return STATE.inverse[self.state()]\n\n    def start_animation(self, policy: DeletionPolicyStr = \"keep\"):\n\"\"\"Start the animation.\n\n        Args:\n            policy: animation policy\n\n        Raises:\n            InvalidParamError: animation policy does not exist\n        \"\"\"\n        if policy not in DELETION_POLICY:\n            raise InvalidParamError(policy, DELETION_POLICY)\n        self.start(DELETION_POLICY[policy])\n\n    def restart_animation(self, policy: DeletionPolicyStr = \"keep\"):\n\"\"\"Restart the animation.\n\n        Args:\n            policy: animation policy\n\n        Raises:\n            InvalidParamError: animation policy does not exist\n        \"\"\"\n        self.stop()\n        self.start_animation(policy)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.get_direction","title":"<code>get_direction(self) -&gt; DirectionStr</code>","text":"<p>Get the current animation direction.</p> <p>Returns:</p> Type Description <code>DirectionStr</code> <p>animation direction</p> Source code in <code>prettyqt/core/abstractanimation.py</code> <pre><code>def get_direction(self) -&gt; DirectionStr:\n\"\"\"Get the current animation direction.\n\n    Returns:\n        animation direction\n    \"\"\"\n    return DIRECTION.inverse[self.direction()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.get_state","title":"<code>get_state(self) -&gt; StateStr</code>","text":"<p>Get the current animation state.</p> <p>Returns:</p> Type Description <code>StateStr</code> <p>animation state</p> Source code in <code>prettyqt/core/abstractanimation.py</code> <pre><code>def get_state(self) -&gt; StateStr:\n\"\"\"Get the current animation state.\n\n    Returns:\n        animation state\n    \"\"\"\n    return STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.restart_animation","title":"<code>restart_animation(self, policy: DeletionPolicyStr = 'keep')</code>","text":"<p>Restart the animation.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>DeletionPolicyStr</code> <p>animation policy</p> <code>'keep'</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>animation policy does not exist</p> Source code in <code>prettyqt/core/abstractanimation.py</code> <pre><code>def restart_animation(self, policy: DeletionPolicyStr = \"keep\"):\n\"\"\"Restart the animation.\n\n    Args:\n        policy: animation policy\n\n    Raises:\n        InvalidParamError: animation policy does not exist\n    \"\"\"\n    self.stop()\n    self.start_animation(policy)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.set_direction","title":"<code>set_direction(self, direction: DirectionStr)</code>","text":"<p>Set animation direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>DirectionStr</code> <p>animation direction</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>animation direction does not exist</p> Source code in <code>prettyqt/core/abstractanimation.py</code> <pre><code>def set_direction(self, direction: DirectionStr):\n\"\"\"Set animation direction.\n\n    Args:\n        direction: animation direction\n\n    Raises:\n        InvalidParamError: animation direction does not exist\n    \"\"\"\n    if direction not in DIRECTION:\n        raise InvalidParamError(direction, DIRECTION)\n    self.setDirection(DIRECTION[direction])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimationMixin.start_animation","title":"<code>start_animation(self, policy: DeletionPolicyStr = 'keep')</code>","text":"<p>Start the animation.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>DeletionPolicyStr</code> <p>animation policy</p> <code>'keep'</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>animation policy does not exist</p> Source code in <code>prettyqt/core/abstractanimation.py</code> <pre><code>def start_animation(self, policy: DeletionPolicyStr = \"keep\"):\n\"\"\"Start the animation.\n\n    Args:\n        policy: animation policy\n\n    Raises:\n        InvalidParamError: animation policy does not exist\n    \"\"\"\n    if policy not in DELETION_POLICY:\n        raise InvalidParamError(policy, DELETION_POLICY)\n    self.start(DELETION_POLICY[policy])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel","title":"<code>abstractitemmodel</code>","text":""},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin","title":"<code> AbstractItemModelMixin            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/core/abstractitemmodel.py</code> <pre><code>class AbstractItemModelMixin(core.ObjectMixin):\n    def __repr__(self):\n        return f\"{type(self).__name__}: {self.rowCount()} rows\"\n\n    def __len__(self) -&gt; int:\n\"\"\"Return amount of rows.\"\"\"\n        return self.rowCount()\n\n    # causes issues with PySide2\n    # def __getitem__(self, index: Tuple[int, int]) -&gt; QtCore.QModelIndex:\n    #     return self.index(*index)\n\n    def check_index(\n        self,\n        index: QtCore.QModelIndex,\n        index_is_valid: bool = False,\n        do_not_use_parent: bool = False,\n        parent_is_invalid: bool = False,\n    ) -&gt; bool:\n        flag = QtCore.QAbstractItemModel.CheckIndexOption.NoOption\n        if index_is_valid:\n            flag |= CHECK_INDEX_OPTIONS[\"index_is_valid\"]  # type: ignore\n        if do_not_use_parent:\n            flag |= CHECK_INDEX_OPTIONS[\"do_not_use_parent\"]  # type: ignore\n        if parent_is_invalid:\n            flag |= CHECK_INDEX_OPTIONS[\"parent_is_invalid\"]  # type: ignore\n        check_flag = QtCore.QAbstractItemModel.CheckIndexOption(0) | flag  # type: ignore\n        return self.checkIndex(index, check_flag)  # type: ignore\n\n    @contextlib.contextmanager\n    def change_layout(self):\n\"\"\"Context manager to change the layout.\n\n        wraps calls with correct signals\n        emitted at beginning: layoutAboutToBeChanged\n        emitted at end: layoutChanged\n\n        \"\"\"\n        self.layoutAboutToBeChanged.emit()\n        yield None\n        self.layoutChanged.emit()\n\n    @contextlib.contextmanager\n    def reset_model(self):\n\"\"\"Context manager to reset the model.\n\n        wraps calls with correct signals\n        emitted at beginning: beginResetModel\n        emitted at end: endResetModel\n\n        \"\"\"\n        self.beginResetModel()\n        yield None\n        self.endResetModel()\n\n    def update_row(self, row: int):\n        start_index = self.index(row, 0)\n        end_index = self.index(row, self.columnCount() - 1)\n        self.dataChanged.emit(start_index, end_index)\n\n    def update_all(self):\n        top_left = self.index(0, 0)\n        bottom_right = self.index(self.rowCount() - 1, self.columnCount() - 1)\n        self.dataChanged.emit(top_left, bottom_right)\n\n    @contextlib.contextmanager\n    def remove_rows(\n        self,\n        first: int | None = None,\n        last: int | None = None,\n        parent: QtCore.QModelIndex | None = None,\n    ):\n        parent = QtCore.QModelIndex() if parent is None else parent\n        first = first if first is not None else 0\n        last = last if last is not None else self.rowCount()\n        self.beginRemoveRows(parent, first, last)\n        yield None\n        self.endRemoveRows()\n\n    @contextlib.contextmanager\n    def remove_columns(\n        self,\n        first: int | None = None,\n        last: int | None = None,\n        parent: QtCore.QModelIndex | None = None,\n    ):\n        parent = QtCore.QModelIndex() if parent is None else parent\n        first = first if first is not None else 0\n        last = last if last is not None else self.rowCount()\n        self.beginRemoveColumns(parent, first, last)\n        yield None\n        self.endRemoveColumns()\n\n    @contextlib.contextmanager\n    def insert_rows(\n        self,\n        first: int | None = None,\n        last: int | None = None,\n        parent: QtCore.QModelIndex | None = None,\n    ):\n        parent = QtCore.QModelIndex() if parent is None else parent\n        first = first if first is not None else 0\n        last = last if last is not None else self.rowCount()\n        self.beginInsertRows(parent, first, last)\n        yield None\n        self.endInsertRows()\n\n    @contextlib.contextmanager\n    def append_rows(self, num_rows: int, parent: QtCore.QModelIndex | None = None):\n        parent = QtCore.QModelIndex() if parent is None else parent\n        row_count = self.rowCount()\n        self.beginInsertRows(parent, row_count, row_count + num_rows - 1)\n        yield None\n        self.endInsertRows()\n\n    @contextlib.contextmanager\n    def insert_columns(\n        self,\n        first: int | None = None,\n        last: int | None = None,\n        parent: QtCore.QModelIndex | None = None,\n    ):\n        parent = QtCore.QModelIndex() if parent is None else parent\n        first = first if first is not None else 0\n        last = last if last is not None else self.rowCount()\n        self.beginInsertColumns(parent, first, last)\n        yield None\n        self.endInsertColumns()\n\n    def force_reset(self):\n        self.beginResetModel()\n        self.endResetModel()\n\n    def force_layoutchange(self):\n        self.layoutAboutToBeChanged.emit()\n        self.layoutChanged.emit()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.__len__","title":"<code>__len__(self) -&gt; int</code>  <code>special</code>","text":"<p>Return amount of rows.</p> Source code in <code>prettyqt/core/abstractitemmodel.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Return amount of rows.\"\"\"\n    return self.rowCount()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.change_layout","title":"<code>change_layout(self)</code>","text":"<p>Context manager to change the layout.</p> <p>wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged</p> Source code in <code>prettyqt/core/abstractitemmodel.py</code> <pre><code>@contextlib.contextmanager\ndef change_layout(self):\n\"\"\"Context manager to change the layout.\n\n    wraps calls with correct signals\n    emitted at beginning: layoutAboutToBeChanged\n    emitted at end: layoutChanged\n\n    \"\"\"\n    self.layoutAboutToBeChanged.emit()\n    yield None\n    self.layoutChanged.emit()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModelMixin.reset_model","title":"<code>reset_model(self)</code>","text":"<p>Context manager to reset the model.</p> <p>wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel</p> Source code in <code>prettyqt/core/abstractitemmodel.py</code> <pre><code>@contextlib.contextmanager\ndef reset_model(self):\n\"\"\"Context manager to reset the model.\n\n    wraps calls with correct signals\n    emitted at beginning: beginResetModel\n    emitted at end: endResetModel\n\n    \"\"\"\n    self.beginResetModel()\n    yield None\n    self.endResetModel()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractproxymodel","title":"<code>abstractproxymodel</code>","text":""},{"location":"api/core.html#prettyqt.core.abstractproxymodel.AbstractProxyModelMixin","title":"<code> AbstractProxyModelMixin            (AbstractItemModelMixin)         </code>","text":"Source code in <code>prettyqt/core/abstractproxymodel.py</code> <pre><code>class AbstractProxyModelMixin(core.AbstractItemModelMixin):\n    def first_item_index(self) -&gt; core.ModelIndex:\n\"\"\"Return the first child of the root item.\"\"\"\n        # We cannot just call the same function of the source model because the first node\n        # there may be hidden.\n        proxy_root_index = self.mapFromSource(core.ModelIndex())\n        first_item_index = self.index(0, 0, proxy_root_index)\n        return first_item_index\n</code></pre>"},{"location":"api/core.html#prettyqt.core.abstractproxymodel.AbstractProxyModelMixin.first_item_index","title":"<code>first_item_index(self) -&gt; core.ModelIndex</code>","text":"<p>Return the first child of the root item.</p> Source code in <code>prettyqt/core/abstractproxymodel.py</code> <pre><code>def first_item_index(self) -&gt; core.ModelIndex:\n\"\"\"Return the first child of the root item.\"\"\"\n    # We cannot just call the same function of the source model because the first node\n    # there may be hidden.\n    proxy_root_index = self.mapFromSource(core.ModelIndex())\n    first_item_index = self.index(0, 0, proxy_root_index)\n    return first_item_index\n</code></pre>"},{"location":"api/core.html#prettyqt.core.collator","title":"<code>collator</code>","text":""},{"location":"api/core.html#prettyqt.core.collator.Collator","title":"<code> Collator            (QCollator)         </code>","text":"Source code in <code>prettyqt/core/collator.py</code> <pre><code>class Collator(QtCore.QCollator):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.get_locale()!r})\"\n\n    def get_locale(self) -&gt; core.Locale:\n        return core.Locale(self.locale())\n\n    def set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n\n        Args:\n            state: case sensitive\n\n        \"\"\"\n        sensitivity = (\n            QtCore.Qt.CaseSensitivity.CaseSensitive\n            if state\n            else QtCore.Qt.CaseSensitivity.CaseInsensitive\n        )\n        self.setCaseSensitivity(sensitivity)\n\n    def is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n\n        Returns:\n            case sensitivity\n        \"\"\"\n        return bool(self.caseSensitivity())\n\n    def get_sort_key(self, string: str) -&gt; core.CollatorSortKey:\n        return core.CollatorSortKey(self.sortKey(string))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.collator.Collator.is_case_sensitive","title":"<code>is_case_sensitive(self) -&gt; bool</code>","text":"<p>Return case sensitivity.</p> <p>Returns:</p> Type Description <code>bool</code> <p>case sensitivity</p> Source code in <code>prettyqt/core/collator.py</code> <pre><code>def is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n\n    Returns:\n        case sensitivity\n    \"\"\"\n    return bool(self.caseSensitivity())\n</code></pre>"},{"location":"api/core.html#prettyqt.core.collator.Collator.set_case_sensitive","title":"<code>set_case_sensitive(self, state: bool)</code>","text":"<p>Set case sensitivity.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>case sensitive</p> required Source code in <code>prettyqt/core/collator.py</code> <pre><code>def set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n\n    Args:\n        state: case sensitive\n\n    \"\"\"\n    sensitivity = (\n        QtCore.Qt.CaseSensitivity.CaseSensitive\n        if state\n        else QtCore.Qt.CaseSensitivity.CaseInsensitive\n    )\n    self.setCaseSensitivity(sensitivity)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.commandlineparser","title":"<code>commandlineparser</code>","text":""},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser","title":"<code> CommandLineParser            (QCommandLineParser)         </code>","text":"Source code in <code>prettyqt/core/commandlineparser.py</code> <pre><code>class CommandLineParser(QtCore.QCommandLineParser):\n    def set_single_dash_word_option_mode(self, mode: SingleDashWordStr):\n\"\"\"Set the single dash word option mode.\n\n        Args:\n            mode: single dash word option mode\n\n        Raises:\n            InvalidParamError: single dash word option mode does not exist\n        \"\"\"\n        if mode not in SINGLE_DASH_WORD:\n            raise InvalidParamError(mode, SINGLE_DASH_WORD)\n        self.setSingleDashWordOptionMode(SINGLE_DASH_WORD[mode])\n\n    def set_options_after_positional_arguments_mode(self, mode: SingleDashWordStr):\n\"\"\"Set the options after positional arguments mode.\n\n        Args:\n            mode: options after positional arguments mode\n\n        Raises:\n            InvalidParamError: options after positional arguments mode does not exist\n        \"\"\"\n        if mode not in OPTIONS_AFTER_POS_ARG:\n            raise InvalidParamError(mode, OPTIONS_AFTER_POS_ARG)\n        self.setOptionsAfterPositionalArgumentsMode(OPTIONS_AFTER_POS_ARG[mode])\n\n    def add_option(\n        self,\n        name: str,\n        description: str | None = None,\n        value_name: str | None = None,\n        default_value: str | None = None,\n    ) -&gt; core.CommandLineOption:\n        if description is None:\n            description = \"\"\n        if value_name is None:\n            value_name = \"\"\n        if default_value is None:\n            default_value = \"\"\n        option = core.CommandLineOption(name, description, value_name, default_value)\n        self.addOption(option)\n        return option\n</code></pre>"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_options_after_positional_arguments_mode","title":"<code>set_options_after_positional_arguments_mode(self, mode: SingleDashWordStr)</code>","text":"<p>Set the options after positional arguments mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SingleDashWordStr</code> <p>options after positional arguments mode</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>options after positional arguments mode does not exist</p> Source code in <code>prettyqt/core/commandlineparser.py</code> <pre><code>def set_options_after_positional_arguments_mode(self, mode: SingleDashWordStr):\n\"\"\"Set the options after positional arguments mode.\n\n    Args:\n        mode: options after positional arguments mode\n\n    Raises:\n        InvalidParamError: options after positional arguments mode does not exist\n    \"\"\"\n    if mode not in OPTIONS_AFTER_POS_ARG:\n        raise InvalidParamError(mode, OPTIONS_AFTER_POS_ARG)\n    self.setOptionsAfterPositionalArgumentsMode(OPTIONS_AFTER_POS_ARG[mode])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_single_dash_word_option_mode","title":"<code>set_single_dash_word_option_mode(self, mode: SingleDashWordStr)</code>","text":"<p>Set the single dash word option mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SingleDashWordStr</code> <p>single dash word option mode</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>single dash word option mode does not exist</p> Source code in <code>prettyqt/core/commandlineparser.py</code> <pre><code>def set_single_dash_word_option_mode(self, mode: SingleDashWordStr):\n\"\"\"Set the single dash word option mode.\n\n    Args:\n        mode: single dash word option mode\n\n    Raises:\n        InvalidParamError: single dash word option mode does not exist\n    \"\"\"\n    if mode not in SINGLE_DASH_WORD:\n        raise InvalidParamError(mode, SINGLE_DASH_WORD)\n    self.setSingleDashWordOptionMode(SINGLE_DASH_WORD[mode])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream","title":"<code>datastream</code>","text":""},{"location":"api/core.html#prettyqt.core.datastream.DataStream","title":"<code> DataStream            (QDataStream)         </code>","text":"Source code in <code>prettyqt/core/datastream.py</code> <pre><code>class DataStream(QtCore.QDataStream):\n    def set_byte_order(self, order: ByteOrderStr):\n\"\"\"Set byte order.\n\n        Args:\n            order: byte order to use\n\n        Raises:\n            InvalidParamError: invalid order\n        \"\"\"\n        if order not in BYTE_ORDER:\n            raise InvalidParamError(order, BYTE_ORDER)\n        self.setByteOrder(BYTE_ORDER[order])\n\n    def get_byte_order(self) -&gt; ByteOrderStr:\n\"\"\"Return byte order.\n\n        Returns:\n            byte order\n        \"\"\"\n        return BYTE_ORDER.inverse[self.byteOrder()]\n\n    def set_status(self, status: StatusStr):\n\"\"\"Set status.\n\n        Args:\n            status: status to use\n\n        Raises:\n            InvalidParamError: invalid status\n        \"\"\"\n        if status not in STATUS:\n            raise InvalidParamError(status, STATUS)\n        self.setStatus(STATUS[status])\n\n    def get_status(self) -&gt; StatusStr:\n\"\"\"Return status.\n\n        Returns:\n            status\n        \"\"\"\n        return STATUS.inverse[self.status()]\n\n    def set_floating_point_precision(self, precision: FloatingPointPrecisionStr):\n\"\"\"Set floating point precision.\n\n        Args:\n            precision: floating point precision\n\n        Raises:\n            InvalidParamError: invalid precision\n        \"\"\"\n        if precision not in FLOATING_POINT_PRECISION:\n            raise InvalidParamError(precision, FLOATING_POINT_PRECISION)\n        self.setFloatingPointPrecision(FLOATING_POINT_PRECISION[precision])\n\n    def get_floating_point_precision(self) -&gt; FloatingPointPrecisionStr:\n\"\"\"Return floating point precision.\n\n        Returns:\n            floating point precision\n        \"\"\"\n        return FLOATING_POINT_PRECISION.inverse[self.floatingPointPrecision()]\n\n    @classmethod\n    def create_bytearray(cls, data: datatypes.QtSerializableType) -&gt; QtCore.QByteArray:\n        ba = QtCore.QByteArray()\n        stream = cls(ba, core.iodevice.OPEN_MODES[\"write_only\"])\n        stream &lt;&lt; data\n        return ba\n\n    @classmethod\n    def write_bytearray(\n        cls, ba: datatypes.ByteArrayType, write_to: datatypes.QtSerializableType\n    ):\n        if isinstance(ba, str):\n            ba = ba.encode()\n        if not isinstance(ba, QtCore.QByteArray):\n            ba = QtCore.QByteArray(ba)\n        stream = cls(ba, core.iodevice.OPEN_MODES[\"read_only\"])\n        stream &gt;&gt; write_to\n\n    @classmethod\n    def copy_data(cls, source, dest):\n        ba = cls.create_bytearray(source)\n        cls.write_bytearray(ba, dest)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_byte_order","title":"<code>get_byte_order(self) -&gt; ByteOrderStr</code>","text":"<p>Return byte order.</p> <p>Returns:</p> Type Description <code>ByteOrderStr</code> <p>byte order</p> Source code in <code>prettyqt/core/datastream.py</code> <pre><code>def get_byte_order(self) -&gt; ByteOrderStr:\n\"\"\"Return byte order.\n\n    Returns:\n        byte order\n    \"\"\"\n    return BYTE_ORDER.inverse[self.byteOrder()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_floating_point_precision","title":"<code>get_floating_point_precision(self) -&gt; FloatingPointPrecisionStr</code>","text":"<p>Return floating point precision.</p> <p>Returns:</p> Type Description <code>FloatingPointPrecisionStr</code> <p>floating point precision</p> Source code in <code>prettyqt/core/datastream.py</code> <pre><code>def get_floating_point_precision(self) -&gt; FloatingPointPrecisionStr:\n\"\"\"Return floating point precision.\n\n    Returns:\n        floating point precision\n    \"\"\"\n    return FLOATING_POINT_PRECISION.inverse[self.floatingPointPrecision()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_status","title":"<code>get_status(self) -&gt; StatusStr</code>","text":"<p>Return status.</p> <p>Returns:</p> Type Description <code>StatusStr</code> <p>status</p> Source code in <code>prettyqt/core/datastream.py</code> <pre><code>def get_status(self) -&gt; StatusStr:\n\"\"\"Return status.\n\n    Returns:\n        status\n    \"\"\"\n    return STATUS.inverse[self.status()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_byte_order","title":"<code>set_byte_order(self, order: ByteOrderStr)</code>","text":"<p>Set byte order.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>ByteOrderStr</code> <p>byte order to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid order</p> Source code in <code>prettyqt/core/datastream.py</code> <pre><code>def set_byte_order(self, order: ByteOrderStr):\n\"\"\"Set byte order.\n\n    Args:\n        order: byte order to use\n\n    Raises:\n        InvalidParamError: invalid order\n    \"\"\"\n    if order not in BYTE_ORDER:\n        raise InvalidParamError(order, BYTE_ORDER)\n    self.setByteOrder(BYTE_ORDER[order])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_floating_point_precision","title":"<code>set_floating_point_precision(self, precision: FloatingPointPrecisionStr)</code>","text":"<p>Set floating point precision.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>FloatingPointPrecisionStr</code> <p>floating point precision</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid precision</p> Source code in <code>prettyqt/core/datastream.py</code> <pre><code>def set_floating_point_precision(self, precision: FloatingPointPrecisionStr):\n\"\"\"Set floating point precision.\n\n    Args:\n        precision: floating point precision\n\n    Raises:\n        InvalidParamError: invalid precision\n    \"\"\"\n    if precision not in FLOATING_POINT_PRECISION:\n        raise InvalidParamError(precision, FLOATING_POINT_PRECISION)\n    self.setFloatingPointPrecision(FLOATING_POINT_PRECISION[precision])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_status","title":"<code>set_status(self, status: StatusStr)</code>","text":"<p>Set status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>StatusStr</code> <p>status to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid status</p> Source code in <code>prettyqt/core/datastream.py</code> <pre><code>def set_status(self, status: StatusStr):\n\"\"\"Set status.\n\n    Args:\n        status: status to use\n\n    Raises:\n        InvalidParamError: invalid status\n    \"\"\"\n    if status not in STATUS:\n        raise InvalidParamError(status, STATUS)\n    self.setStatus(STATUS[status])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.deadlinetimer","title":"<code>deadlinetimer</code>","text":""},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer","title":"<code> DeadlineTimer            (QDeadlineTimer)         </code>","text":"Source code in <code>prettyqt/core/deadlinetimer.py</code> <pre><code>class DeadlineTimer(QtCore.QDeadlineTimer):\n    def set_type(self, typ: constants.TimerTypeStr):\n\"\"\"Set the timer type.\n\n        Args:\n            typ: timer type\n\n        Raises:\n            InvalidParamError: timer type does not exist\n        \"\"\"\n        if typ not in constants.TIMER_TYPE:\n            raise InvalidParamError(typ, constants.TIMER_TYPE)\n        self.setTimerType(constants.TIMER_TYPE[typ])\n\n    def get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n\n        Returns:\n            timer type\n        \"\"\"\n        return constants.TIMER_TYPE.inverse[self.timerType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.get_type","title":"<code>get_type(self) -&gt; constants.TimerTypeStr</code>","text":"<p>Return current timer type.</p> <p>Returns:</p> Type Description <code>constants.TimerTypeStr</code> <p>timer type</p> Source code in <code>prettyqt/core/deadlinetimer.py</code> <pre><code>def get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n\n    Returns:\n        timer type\n    \"\"\"\n    return constants.TIMER_TYPE.inverse[self.timerType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.set_type","title":"<code>set_type(self, typ: constants.TimerTypeStr)</code>","text":"<p>Set the timer type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>constants.TimerTypeStr</code> <p>timer type</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>timer type does not exist</p> Source code in <code>prettyqt/core/deadlinetimer.py</code> <pre><code>def set_type(self, typ: constants.TimerTypeStr):\n\"\"\"Set the timer type.\n\n    Args:\n        typ: timer type\n\n    Raises:\n        InvalidParamError: timer type does not exist\n    \"\"\"\n    if typ not in constants.TIMER_TYPE:\n        raise InvalidParamError(typ, constants.TIMER_TYPE)\n    self.setTimerType(constants.TIMER_TYPE[typ])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.easingcurve","title":"<code>easingcurve</code>","text":""},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve","title":"<code> EasingCurve            (QEasingCurve)         </code>","text":"Source code in <code>prettyqt/core/easingcurve.py</code> <pre><code>class EasingCurve(QtCore.QEasingCurve):\n    def __init__(self, other_or_type: TypeStr | int | QtCore.QEasingCurve = \"linear\"):\n        if isinstance(other_or_type, str) and other_or_type in TYPE:\n            typ = TYPE[other_or_type]\n        else:\n            typ = other_or_type\n        super().__init__(typ)\n\n    def __getitem__(self, value: float) -&gt; float:\n        return self.valueForProgress(value)\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.get_type()!r})\"\n\n    def set_custom_type(self, method: CurveMethod):\n        self.setCustomType(method)\n\n    def get_custom_type(self) -&gt; CurveMethod:\n        return self.customType()  # type: ignore\n\n    def set_type(self, typ: TypeStr):\n\"\"\"Set easing curve type.\n\n        Args:\n            typ: easing curve type\n\n        Raises:\n            InvalidParamError: easing curve type does not exist\n        \"\"\"\n        if typ not in TYPE:\n            raise InvalidParamError(typ, TYPE)\n        self.setType(TYPE[typ])\n\n    def get_type(self) -&gt; TypeStr:\n\"\"\"Get the current easing curve type.\n\n        Returns:\n            easing curve type\n        \"\"\"\n        return TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.get_type","title":"<code>get_type(self) -&gt; TypeStr</code>","text":"<p>Get the current easing curve type.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>easing curve type</p> Source code in <code>prettyqt/core/easingcurve.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Get the current easing curve type.\n\n    Returns:\n        easing curve type\n    \"\"\"\n    return TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.set_type","title":"<code>set_type(self, typ: TypeStr)</code>","text":"<p>Set easing curve type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TypeStr</code> <p>easing curve type</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>easing curve type does not exist</p> Source code in <code>prettyqt/core/easingcurve.py</code> <pre><code>def set_type(self, typ: TypeStr):\n\"\"\"Set easing curve type.\n\n    Args:\n        typ: easing curve type\n\n    Raises:\n        InvalidParamError: easing curve type does not exist\n    \"\"\"\n    if typ not in TYPE:\n        raise InvalidParamError(typ, TYPE)\n    self.setType(TYPE[typ])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.elapsedtimer","title":"<code>elapsedtimer</code>","text":""},{"location":"api/core.html#prettyqt.core.elapsedtimer.ElapsedTimer","title":"<code> ElapsedTimer            (QElapsedTimer)         </code>","text":"Source code in <code>prettyqt/core/elapsedtimer.py</code> <pre><code>class ElapsedTimer(QtCore.QElapsedTimer):\n    def __bool__(self):\n        return self.isValid()\n\n    def get_clock_type(self) -&gt; ClockTypeStr:\n\"\"\"Return current clock type.\n\n        Returns:\n            clock type\n        \"\"\"\n        return CLOCK_TYPE.inverse[self.clockType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.elapsedtimer.ElapsedTimer.get_clock_type","title":"<code>get_clock_type(self) -&gt; ClockTypeStr</code>","text":"<p>Return current clock type.</p> <p>Returns:</p> Type Description <code>ClockTypeStr</code> <p>clock type</p> Source code in <code>prettyqt/core/elapsedtimer.py</code> <pre><code>def get_clock_type(self) -&gt; ClockTypeStr:\n\"\"\"Return current clock type.\n\n    Returns:\n        clock type\n    \"\"\"\n    return CLOCK_TYPE.inverse[self.clockType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.filedevice","title":"<code>filedevice</code>","text":""},{"location":"api/core.html#prettyqt.core.filedevice.FileDeviceMixin","title":"<code> FileDeviceMixin            (IODeviceMixin)         </code>","text":"Source code in <code>prettyqt/core/filedevice.py</code> <pre><code>class FileDeviceMixin(core.IODeviceMixin):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.fileName()!r})\"\n\n    def __str__(self):\n        return self.fileName()\n\n    def set_file_time(self, file_time: datatypes.DateTimeType, typ: FileTimeStr) -&gt; bool:\n\"\"\"Set file time.\n\n        Args:\n            file_time: file time to set\n            typ: file time type\n\n        Raises:\n            InvalidParamError: file time does not exist\n        \"\"\"\n        if isinstance(file_time, str):\n            file_time = dateutil.parser.parse(file_time)\n        if typ not in FILE_TIME:\n            raise InvalidParamError(typ, FILE_TIME)\n        return self.setFileTime(file_time, FILE_TIME[typ])  # type: ignore\n\n    def get_file_time(self, typ: FileTimeStr) -&gt; datetime.datetime | None:\n\"\"\"Return current file time.\n\n        Returns:\n            file time\n        \"\"\"\n        if typ not in FILE_TIME:\n            raise InvalidParamError(typ, FILE_TIME)\n        if date := self.fileTime(FILE_TIME[typ]):\n            return date.toPython()  # type: ignore\n\n    def get_error(self) -&gt; FileErrorStr:\n\"\"\"Return file error status.\n\n        Returns:\n            file error status\n        \"\"\"\n        return FILE_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.filedevice.FileDeviceMixin.get_error","title":"<code>get_error(self) -&gt; FileErrorStr</code>","text":"<p>Return file error status.</p> <p>Returns:</p> Type Description <code>FileErrorStr</code> <p>file error status</p> Source code in <code>prettyqt/core/filedevice.py</code> <pre><code>def get_error(self) -&gt; FileErrorStr:\n\"\"\"Return file error status.\n\n    Returns:\n        file error status\n    \"\"\"\n    return FILE_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.filedevice.FileDeviceMixin.get_file_time","title":"<code>get_file_time(self, typ: FileTimeStr) -&gt; datetime.datetime | None</code>","text":"<p>Return current file time.</p> <p>Returns:</p> Type Description <code>datetime.datetime | None</code> <p>file time</p> Source code in <code>prettyqt/core/filedevice.py</code> <pre><code>def get_file_time(self, typ: FileTimeStr) -&gt; datetime.datetime | None:\n\"\"\"Return current file time.\n\n    Returns:\n        file time\n    \"\"\"\n    if typ not in FILE_TIME:\n        raise InvalidParamError(typ, FILE_TIME)\n    if date := self.fileTime(FILE_TIME[typ]):\n        return date.toPython()  # type: ignore\n</code></pre>"},{"location":"api/core.html#prettyqt.core.filedevice.FileDeviceMixin.set_file_time","title":"<code>set_file_time(self, file_time: datatypes.DateTimeType, typ: FileTimeStr) -&gt; bool</code>","text":"<p>Set file time.</p> <p>Parameters:</p> Name Type Description Default <code>file_time</code> <code>datatypes.DateTimeType</code> <p>file time to set</p> required <code>typ</code> <code>FileTimeStr</code> <p>file time type</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>file time does not exist</p> Source code in <code>prettyqt/core/filedevice.py</code> <pre><code>def set_file_time(self, file_time: datatypes.DateTimeType, typ: FileTimeStr) -&gt; bool:\n\"\"\"Set file time.\n\n    Args:\n        file_time: file time to set\n        typ: file time type\n\n    Raises:\n        InvalidParamError: file time does not exist\n    \"\"\"\n    if isinstance(file_time, str):\n        file_time = dateutil.parser.parse(file_time)\n    if typ not in FILE_TIME:\n        raise InvalidParamError(typ, FILE_TIME)\n    return self.setFileTime(file_time, FILE_TIME[typ])  # type: ignore\n</code></pre>"},{"location":"api/core.html#prettyqt.core.operatingsystemversion","title":"<code>operatingsystemversion</code>","text":""},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion","title":"<code> OperatingSystemVersion            (QOperatingSystemVersion)         </code>","text":"Source code in <code>prettyqt/core/operatingsystemversion.py</code> <pre><code>class OperatingSystemVersion(QtCore.QOperatingSystemVersion):\n    def __init__(\n        self,\n        typ: QtCore.QOperatingSystemVersion.OSType | str,\n        major: int,\n        minor: int | None = None,\n        micro: int | None = None,\n    ):\n        if isinstance(typ, str):\n            os_type = OS_TYPE[typ]\n        else:\n            os_type = typ\n        if minor is None:\n            minor = -1\n        if micro is None:\n            micro = -1\n        super().__init__(os_type, major, minor, micro)\n\n    def __repr__(self):\n        return (\n            f\"{type(self).__name__}({self.get_type()!r}, {self.majorVersion()}, \"\n            f\"{self.minorVersion()}, {self.microVersion()})\"\n        )\n\n    def __reduce__(self):\n        return (\n            type(self),\n            (\n                self.get_type(),\n                self.majorVersion(),\n                self.minorVersion(),\n                self.microVersion(),\n            ),\n        )\n\n    def __eq__(self, other):\n        if not isinstance(other, OperatingSystemVersion):\n            return False\n        return (\n            self.get_type() == other.get_type()\n            and self.get_versionnumber() == other.get_versionnumber()\n        )\n\n    def __hash__(self):\n        return hash(\n            (\n                self.get_type(),\n                self.majorVersion(),\n                self.minorVersion(),\n                self.microVersion(),\n            )\n        )\n\n    def get_type(self) -&gt; OsTypeStr:\n\"\"\"Get current os type.\n\n        Returns:\n            current os type\n        \"\"\"\n        return OS_TYPE.inverse[self.type()]\n\n    def get_versionnumber(self) -&gt; core.VersionNumber:\n        return core.VersionNumber(\n            self.majorVersion(), self.minorVersion(), self.microVersion()\n        )\n</code></pre>"},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion.__hash__","title":"<code>__hash__(self)</code>  <code>special</code>","text":"<p>Return hash(self).</p> Source code in <code>prettyqt/core/operatingsystemversion.py</code> <pre><code>def __hash__(self):\n    return hash(\n        (\n            self.get_type(),\n            self.majorVersion(),\n            self.minorVersion(),\n            self.microVersion(),\n        )\n    )\n</code></pre>"},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion.get_type","title":"<code>get_type(self) -&gt; OsTypeStr</code>","text":"<p>Get current os type.</p> <p>Returns:</p> Type Description <code>OsTypeStr</code> <p>current os type</p> Source code in <code>prettyqt/core/operatingsystemversion.py</code> <pre><code>def get_type(self) -&gt; OsTypeStr:\n\"\"\"Get current os type.\n\n    Returns:\n        current os type\n    \"\"\"\n    return OS_TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process","title":"<code>process</code>","text":""},{"location":"api/core.html#prettyqt.core.process.Process","title":"<code> Process            (IODeviceMixin, QProcess)         </code>","text":"Source code in <code>prettyqt/core/process.py</code> <pre><code>class Process(core.IODeviceMixin, QtCore.QProcess):\n    def set_read_channel(self, channel: ProcessChannelStr):\n\"\"\"Set the input channel channel.\n\n        Args:\n            channel: channel to set\n\n        Raises:\n            InvalidParamError: invalid channel\n        \"\"\"\n        if channel not in PROCESS_CHANNELS:\n            raise InvalidParamError(channel, PROCESS_CHANNELS)\n        self.setReadChannel(PROCESS_CHANNELS[channel])\n\n    def get_read_channel(self) -&gt; ProcessChannelStr:\n        return PROCESS_CHANNELS.inverse[self.readChannel()]\n\n    def close_read_channel(self, channel: ProcessChannelStr):\n        self.closeReadChannel(PROCESS_CHANNELS[channel])\n\n    def set_input_channel_mode(self, mode: InputChannelModeStr):\n\"\"\"Set the input channel mode.\n\n        Args:\n            mode: mode to set\n\n        Raises:\n            InvalidParamError: invalid mode\n        \"\"\"\n        if mode not in INPUT_CHANNEL_MODES:\n            raise InvalidParamError(mode, INPUT_CHANNEL_MODES)\n        self.setInputChannelMode(INPUT_CHANNEL_MODES[mode])\n\n    def get_input_channel_mode(self) -&gt; InputChannelModeStr:\n        return INPUT_CHANNEL_MODES.inverse[self.inputChannelMode()]\n\n    def set_process_channel_mode(self, mode: ProcessChannelModeStr):\n\"\"\"Set the process channel mode.\n\n        Args:\n            mode: mode to set\n\n        Raises:\n            InvalidParamError: invalid mode\n        \"\"\"\n        if mode not in PROCESS_CHANNEL_MODES:\n            raise InvalidParamError(mode, PROCESS_CHANNEL_MODES)\n        self.setProcessChannelMode(PROCESS_CHANNEL_MODES[mode])\n\n    def get_process_channel_mode(self) -&gt; ProcessChannelModeStr:\n        return PROCESS_CHANNEL_MODES.inverse[self.processChannelMode()]\n\n    def set_state(self, state: ProcessStateStr):\n\"\"\"Set the process state.\n\n        Args:\n            state: state to set\n\n        Raises:\n            InvalidParamError: invalid state\n        \"\"\"\n        if state not in PROCESS_STATES:\n            raise InvalidParamError(state, PROCESS_STATES)\n        self.setProcessState(PROCESS_STATES[state])\n\n    def get_state(self) -&gt; ProcessStateStr:\n        return PROCESS_STATES.inverse[self.state()]\n\n    def get_error(self) -&gt; ProcessErrorStr:\n        return PROCESS_ERRORS.inverse[self.error()]\n\n    def get_exit_status(self) -&gt; ExitStatusStr:\n        return EXIT_STATUS.inverse[self.exitStatus()]\n\n    def get_process_environment(self) -&gt; core.ProcessEnvironment:\n        return core.ProcessEnvironment(self.processEnvironment())\n\n    @contextlib.contextmanager\n    def edit_process_environment(self):\n        env = self.get_process_environment()\n        yield env\n        self.setProcessEnvironment(env)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_input_channel_mode","title":"<code>set_input_channel_mode(self, mode: InputChannelModeStr)</code>","text":"<p>Set the input channel mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>InputChannelModeStr</code> <p>mode to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid mode</p> Source code in <code>prettyqt/core/process.py</code> <pre><code>def set_input_channel_mode(self, mode: InputChannelModeStr):\n\"\"\"Set the input channel mode.\n\n    Args:\n        mode: mode to set\n\n    Raises:\n        InvalidParamError: invalid mode\n    \"\"\"\n    if mode not in INPUT_CHANNEL_MODES:\n        raise InvalidParamError(mode, INPUT_CHANNEL_MODES)\n    self.setInputChannelMode(INPUT_CHANNEL_MODES[mode])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_process_channel_mode","title":"<code>set_process_channel_mode(self, mode: ProcessChannelModeStr)</code>","text":"<p>Set the process channel mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ProcessChannelModeStr</code> <p>mode to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid mode</p> Source code in <code>prettyqt/core/process.py</code> <pre><code>def set_process_channel_mode(self, mode: ProcessChannelModeStr):\n\"\"\"Set the process channel mode.\n\n    Args:\n        mode: mode to set\n\n    Raises:\n        InvalidParamError: invalid mode\n    \"\"\"\n    if mode not in PROCESS_CHANNEL_MODES:\n        raise InvalidParamError(mode, PROCESS_CHANNEL_MODES)\n    self.setProcessChannelMode(PROCESS_CHANNEL_MODES[mode])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_read_channel","title":"<code>set_read_channel(self, channel: ProcessChannelStr)</code>","text":"<p>Set the input channel channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>ProcessChannelStr</code> <p>channel to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid channel</p> Source code in <code>prettyqt/core/process.py</code> <pre><code>def set_read_channel(self, channel: ProcessChannelStr):\n\"\"\"Set the input channel channel.\n\n    Args:\n        channel: channel to set\n\n    Raises:\n        InvalidParamError: invalid channel\n    \"\"\"\n    if channel not in PROCESS_CHANNELS:\n        raise InvalidParamError(channel, PROCESS_CHANNELS)\n    self.setReadChannel(PROCESS_CHANNELS[channel])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.process.Process.set_state","title":"<code>set_state(self, state: ProcessStateStr)</code>","text":"<p>Set the process state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>ProcessStateStr</code> <p>state to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid state</p> Source code in <code>prettyqt/core/process.py</code> <pre><code>def set_state(self, state: ProcessStateStr):\n\"\"\"Set the process state.\n\n    Args:\n        state: state to set\n\n    Raises:\n        InvalidParamError: invalid state\n    \"\"\"\n    if state not in PROCESS_STATES:\n        raise InvalidParamError(state, PROCESS_STATES)\n    self.setProcessState(PROCESS_STATES[state])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.regularexpression","title":"<code>regularexpression</code>","text":""},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression","title":"<code> RegularExpression            (QRegularExpression)         </code>","text":"Source code in <code>prettyqt/core/regularexpression.py</code> <pre><code>class RegularExpression(QtCore.QRegularExpression):\n    def __init__(\n        self,\n        pattern: str | QtCore.QRegularExpression = \"\",\n        flags: QtCore.QRegularExpression.PatternOption = FLAGS[\"none\"],\n    ):\n        if isinstance(pattern, QtCore.QRegularExpression):\n            super().__init__(pattern)\n        else:\n            if isinstance(flags, int):\n                flags = core.RegularExpression.PatternOption(flags)  # type: ignore\n            super().__init__(pattern, flags)  # type: ignore\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.pattern()!r})\"\n\n    def __reduce__(self):\n        return type(self), (self.pattern(), self.flags)\n\n    def globalMatch(self, *args, **kwargs) -&gt; core.RegularExpressionMatchIterator:\n        it = super().globalMatch(*args, **kwargs)\n        return core.RegularExpressionMatchIterator(it)\n\n    def global_match(\n        self,\n        text: str,\n        offset: int = 0,\n        match_type: MatchTypeStr = \"normal\",\n        anchored: bool = False,\n    ):\n        options = MATCH_OPTIONS[\"anchored\"] if anchored else MATCH_OPTIONS[\"none\"]\n        return self.globalMatch(text, offset, MATCH_TYPE[match_type], options)\n\n    def match(  # type: ignore\n        self,\n        text: str,\n        offset: int = 0,\n        match_type: MatchTypeStr | QtCore.QRegularExpression.MatchType = \"normal\",\n        anchored: bool = False,\n    ) -&gt; core.RegularExpressionMatch:\n        if isinstance(match_type, str):\n            typ = MATCH_TYPE[match_type]\n        else:\n            typ = match_type\n        if isinstance(anchored, bool):\n            options = MATCH_OPTIONS[\"anchored\"] if anchored else MATCH_OPTIONS[\"none\"]\n        else:\n            options = anchored\n        match = super().match(text, offset, typ, options)\n        return core.RegularExpressionMatch(match)\n\n    def fullmatch(\n        self, string: str, pos: int = 0, endpos: int | None = None\n    ) -&gt; core.RegularExpressionMatch | None:\n        if endpos:\n            string = string[:endpos]\n        match = super().match(string, pos)\n        if match.hasMatch() and len(string) == match.end() - match.start():\n            return core.RegularExpressionMatch(match)\n        else:\n            return None\n\n    def finditer(\n        self, string: str, pos: int = 0, endpos: int | None = None\n    ) -&gt; Iterator[core.RegularExpressionMatch]:\n        for match in self.globalMatch(string[:endpos], offset=pos):\n            match.pos = pos\n            match.endpos = endpos\n            match.string = string\n            yield match\n\n    def findall(self, string: str, pos: int = 0, endpos: int | None = None) -&gt; list:\n        matches = list(self.globalMatch(string[:endpos], offset=pos))\n        return [m.groups() if len(m.groups()) &gt; 1 else m.group(0) for m in matches]\n\n    def subn(self, repl: str | Callable, string: str, count: int = 0) -&gt; tuple[str, int]:\n        result = string\n        matches = self.global_match(string)\n        matches = list(matches)\n        if count &gt; 0:\n            matches = matches[:count]\n        matches = list(reversed(matches))\n        for m in matches:\n            to_replace = repl if isinstance(repl, str) else repl(m)\n            for j in range(self.groups):\n                to_replace = to_replace.replace(rf\"\\g&lt;{j}&gt;\", m.group(j))\n            for k in self.groupindex.keys():\n                to_replace = to_replace.replace(rf\"\\g&lt;{k}&gt;\", m.group(k))\n            result = result[: m.start()] + to_replace + result[m.end() :]\n        return (result, min(len(matches), count))\n\n    def sub(self, repl: str | Callable, string: str, count: int = 0) -&gt; str:\n        res = self.subn(repl, string, count)\n        return res[0]\n\n    def search(self, string: str, pos: int = 0, endpos: int | None = None):\n        match = super().match(string[:endpos], pos)\n        return match if match.hasMatch() else None\n\n    def split(self, string: str, maxsplit: int = 0):\n        raise NotImplementedError()\n        # result = []\n        # matches = self.global_match(string)\n        # matches = list(matches)\n        # if 0 &lt; maxsplit &lt;= len(matches):\n        #     remainder = string[matches[maxsplit - 1].end() :]\n        #     print(remainder)\n        # else:\n        #     print(None)\n        #     remainder = None\n        # if maxsplit &gt; 0:\n        #     matches = matches[:maxsplit]\n        # prev_match = None\n        # m = matches[0]\n        # if m.start() == 0:\n        #     result.append(\"\")\n        # else:\n        #     result.append(string[0 : m.start()])\n        # for g in m.groups():\n        #     result.append(g)\n        # prev_match = m\n        # for m in matches[1:]:\n        #     result.append(string[prev_match.end() : m.start()])\n        #     for g in m.groups():\n        #         result.append(g)\n        #     if m.end() == len(string):\n        #         result.append(\"\")\n        #     prev_match = m\n        # if remainder:\n        #     result.append(remainder)\n        # return result\n\n    @property\n    def groups(self) -&gt; int:\n        return self.captureCount()\n\n    @property\n    def groupindex(self) -&gt; dict[str, int]:\n        return {k: i for i, k in enumerate(self.namedCaptureGroups()[1:], start=1)}\n\n    @property\n    def flags(self):\n        return self.patternOptions()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.globalMatch","title":"<code>globalMatch(self, *args, **kwargs) -&gt; core.RegularExpressionMatchIterator</code>","text":"<p>globalMatch(self, subject: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -&gt; PySide6.QtCore.QRegularExpressionMatchIterator globalMatch(self, subjectView: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -&gt; PySide6.QtCore.QRegularExpressionMatchIterator</p> Source code in <code>prettyqt/core/regularexpression.py</code> <pre><code>def globalMatch(self, *args, **kwargs) -&gt; core.RegularExpressionMatchIterator:\n    it = super().globalMatch(*args, **kwargs)\n    return core.RegularExpressionMatchIterator(it)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.match","title":"<code>match(self, text: str, offset: int = 0, match_type: MatchTypeStr | QtCore.QRegularExpression.MatchType = 'normal', anchored: bool = False) -&gt; core.RegularExpressionMatch</code>","text":"<p>match(self, subject: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -&gt; PySide6.QtCore.QRegularExpressionMatch match(self, subjectView: str, offset: int = 0, matchType: PySide6.QtCore.QRegularExpression.MatchType = Instance(PySide6.QtCore.QRegularExpression.MatchType.NormalMatch), matchOptions: PySide6.QtCore.QRegularExpression.MatchOption = Instance(PySide6.QtCore.QRegularExpression.MatchOption.NoMatchOption)) -&gt; PySide6.QtCore.QRegularExpressionMatch</p> Source code in <code>prettyqt/core/regularexpression.py</code> <pre><code>def match(  # type: ignore\n    self,\n    text: str,\n    offset: int = 0,\n    match_type: MatchTypeStr | QtCore.QRegularExpression.MatchType = \"normal\",\n    anchored: bool = False,\n) -&gt; core.RegularExpressionMatch:\n    if isinstance(match_type, str):\n        typ = MATCH_TYPE[match_type]\n    else:\n        typ = match_type\n    if isinstance(anchored, bool):\n        options = MATCH_OPTIONS[\"anchored\"] if anchored else MATCH_OPTIONS[\"none\"]\n    else:\n        options = anchored\n    match = super().match(text, offset, typ, options)\n    return core.RegularExpressionMatch(match)\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings","title":"<code>settings</code>","text":""},{"location":"api/core.html#prettyqt.core.settings.Settings","title":"<code> Settings            (ObjectMixin, QSettings)         </code>","text":"Source code in <code>prettyqt/core/settings.py</code> <pre><code>class Settings(core.ObjectMixin, QtCore.QSettings):\n    def __init__(self, *args, settings_id: str | None = None):\n        super().__init__(*args)\n        self.settings_id = settings_id\n\n    def __repr__(self):\n        return f\"{type(self).__name__}: {self.as_dict()}\"\n\n    def __contains__(self, key: str) -&gt; bool:\n        return self.contains(key)\n\n    def __enter__(self):\n        if self.settings_id:\n            self.beginGroup(self.settings_id)\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if self.settings_id:\n            self.endGroup()\n\n    def __getitem__(self, index: str):\n        return self.get_value(index)\n\n    def __setitem__(self, name: str, value):\n        return self.set_value(name, value)\n\n    def __delitem__(self, key: str):\n        if not self.contains(key):\n            raise KeyError(key)\n        return self.remove(key)\n\n    def __iter__(self) -&gt; Iterator[tuple[str, Any]]:\n        return iter(self.items())\n\n    def __len__(self) -&gt; int:\n        return len(self.allKeys())\n\n    @classmethod\n    def build_from_dict(cls, dct: dict[str, Any]):\n        settings = cls()\n        for k, v in dct.items():\n            settings.set_value(k, v)\n        return settings\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        return dict(self.items())\n\n    def set_value(self, key: str, value):\n        if not self.applicationName():\n            raise RuntimeError(\"no app name defined\")\n        self.setValue(key, dict(value=value))\n\n    def set_values(self, dct: dict[str, Any]):\n        for k, v in dct.items():\n            self.set_value(k, v)\n\n    def get_value(self, key: str, default=None):\n        if not self.contains(key):\n            return default\n        val = self.value(key)\n        # this is for migration\n        if not isinstance(val, dict) or \"value\" not in val:\n            self.set_value(key, val)\n            return val\n        return val[\"value\"]\n\n    @classmethod\n    def set_default_format(cls, fmt: FormatStr):\n\"\"\"Set the default format.\n\n        Args:\n            fmt: the default format to use\n\n        Raises:\n            InvalidParamError: invalid format\n        \"\"\"\n        if fmt not in FORMAT:\n            raise InvalidParamError(fmt, FORMAT)\n        cls.setDefaultFormat(FORMAT[fmt])\n\n    @classmethod\n    def get_default_format(cls) -&gt; FormatStr:\n\"\"\"Return default settings format.\n\n        Returns:\n            default settings format\n        \"\"\"\n        return FORMAT.inverse[cls.defaultFormat()]\n\n    def get_scope(self) -&gt; ScopeStr:\n\"\"\"Return scope.\n\n        Returns:\n            scope\n        \"\"\"\n        return SCOPE.inverse[self.scope()]\n\n    @classmethod\n    def set_path(cls, fmt: FormatStr, scope: ScopeStr, path: datatypes.PathType):\n\"\"\"Set the path to the settings file.\n\n        Args:\n            fmt: the default format to use\n            scope: the scope to use\n            path: the path to set\n\n        Raises:\n            InvalidParamError: invalid format or scope\n        \"\"\"\n        if fmt not in FORMAT:\n            raise InvalidParamError(fmt, FORMAT)\n        if scope not in SCOPE:\n            raise InvalidParamError(scope, SCOPE)\n        cls.setPath(FORMAT[fmt], SCOPE[scope], os.fspath(path))\n\n    @contextlib.contextmanager\n    def edit_group(self, prefix: str):\n\"\"\"Context manager for setting groups.\n\n        Args:\n            prefix: setting prefix for group\n        \"\"\"\n        self.beginGroup(prefix)\n        yield None\n        self.endGroup()\n\n    @contextlib.contextmanager\n    def write_array(self, prefix: str, size: int | None = None):\n\"\"\"Context manager for writing arrays.\n\n        Args:\n            prefix: prefix for settings array\n            size: size of settings array\n        \"\"\"\n        if size is None:\n            size = -1\n        self.beginWriteArray(prefix, size)\n        yield None\n        self.endArray()\n\n    @contextlib.contextmanager\n    def read_array(self, prefix: str):\n\"\"\"Context manager for reading arrays.\n\n        Args:\n            prefix: prefix for settings array\n        \"\"\"\n        self.beginReadArray(prefix)\n        yield None\n        self.endArray()\n\n    # Dictionary interface\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.get_value(key, default)\n\n    def setdefault(self, key: str, default: Any = None) -&gt; Any:\n        if not self.contains(key):\n            self.set_value(key, default)\n            return default\n        return self.get_value(key)\n\n    def keys(self) -&gt; list[str]:\n        return self.allKeys()\n\n    def values(self) -&gt; Iterator[Any]:\n        return (self.get_value(key) for key in self.allKeys())\n\n    def items(self):\n        return zip(self.keys(), self.values())\n\n    def pop(self, key: str):\n        if self.contains(key):\n            return self.get_value(key)\n        raise KeyError(key)\n\n    def popitem(self) -&gt; tuple[str, Any]:\n        key = self.keys()[0]\n        return (key, self.get_value(key))\n\n    def update(self, other: Mapping[str, Any]):\n        for k, v in other.items():\n            self.set_value(k, v)\n\n    @classmethod\n    def register_extensions(\n        cls,\n        *exts: str,\n        app_name: str | None = None,\n        app_path: None | datatypes.PathType = None,\n    ):\n        logger.debug(f\"assigning extensions {exts} to {app_name}\")\n        s = cls(\"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Classes\", Settings.Format.NativeFormat)\n        if app_path is None:\n            app_path = str(core.CoreApplication.get_application_file_path())\n        app_path = os.fspath(app_path)\n        if app_name is None:\n            app_name = core.CoreApplication.applicationName()\n        for ext in exts:\n            s.setValue(f\"{ext}/DefaultIcon/.\", app_path)  # perhaps ,0 after app_path\n            s.setValue(f\"{ext}/.\", app_name)\n        s.setValue(f\"{app_name}/shell/open/command/.\", f\"{app_path} %1\")\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.edit_group","title":"<code>edit_group(self, prefix: str)</code>","text":"<p>Context manager for setting groups.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>setting prefix for group</p> required Source code in <code>prettyqt/core/settings.py</code> <pre><code>@contextlib.contextmanager\ndef edit_group(self, prefix: str):\n\"\"\"Context manager for setting groups.\n\n    Args:\n        prefix: setting prefix for group\n    \"\"\"\n    self.beginGroup(prefix)\n    yield None\n    self.endGroup()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_default_format","title":"<code>get_default_format() -&gt; FormatStr</code>  <code>classmethod</code>","text":"<p>Return default settings format.</p> <p>Returns:</p> Type Description <code>FormatStr</code> <p>default settings format</p> Source code in <code>prettyqt/core/settings.py</code> <pre><code>@classmethod\ndef get_default_format(cls) -&gt; FormatStr:\n\"\"\"Return default settings format.\n\n    Returns:\n        default settings format\n    \"\"\"\n    return FORMAT.inverse[cls.defaultFormat()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_scope","title":"<code>get_scope(self) -&gt; ScopeStr</code>","text":"<p>Return scope.</p> <p>Returns:</p> Type Description <code>ScopeStr</code> <p>scope</p> Source code in <code>prettyqt/core/settings.py</code> <pre><code>def get_scope(self) -&gt; ScopeStr:\n\"\"\"Return scope.\n\n    Returns:\n        scope\n    \"\"\"\n    return SCOPE.inverse[self.scope()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.read_array","title":"<code>read_array(self, prefix: str)</code>","text":"<p>Context manager for reading arrays.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix for settings array</p> required Source code in <code>prettyqt/core/settings.py</code> <pre><code>@contextlib.contextmanager\ndef read_array(self, prefix: str):\n\"\"\"Context manager for reading arrays.\n\n    Args:\n        prefix: prefix for settings array\n    \"\"\"\n    self.beginReadArray(prefix)\n    yield None\n    self.endArray()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_default_format","title":"<code>set_default_format(fmt: FormatStr)</code>  <code>classmethod</code>","text":"<p>Set the default format.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>FormatStr</code> <p>the default format to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid format</p> Source code in <code>prettyqt/core/settings.py</code> <pre><code>@classmethod\ndef set_default_format(cls, fmt: FormatStr):\n\"\"\"Set the default format.\n\n    Args:\n        fmt: the default format to use\n\n    Raises:\n        InvalidParamError: invalid format\n    \"\"\"\n    if fmt not in FORMAT:\n        raise InvalidParamError(fmt, FORMAT)\n    cls.setDefaultFormat(FORMAT[fmt])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_path","title":"<code>set_path(fmt: FormatStr, scope: ScopeStr, path: datatypes.PathType)</code>  <code>classmethod</code>","text":"<p>Set the path to the settings file.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>FormatStr</code> <p>the default format to use</p> required <code>scope</code> <code>ScopeStr</code> <p>the scope to use</p> required <code>path</code> <code>datatypes.PathType</code> <p>the path to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid format or scope</p> Source code in <code>prettyqt/core/settings.py</code> <pre><code>@classmethod\ndef set_path(cls, fmt: FormatStr, scope: ScopeStr, path: datatypes.PathType):\n\"\"\"Set the path to the settings file.\n\n    Args:\n        fmt: the default format to use\n        scope: the scope to use\n        path: the path to set\n\n    Raises:\n        InvalidParamError: invalid format or scope\n    \"\"\"\n    if fmt not in FORMAT:\n        raise InvalidParamError(fmt, FORMAT)\n    if scope not in SCOPE:\n        raise InvalidParamError(scope, SCOPE)\n    cls.setPath(FORMAT[fmt], SCOPE[scope], os.fspath(path))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.settings.Settings.write_array","title":"<code>write_array(self, prefix: str, size: int | None = None)</code>","text":"<p>Context manager for writing arrays.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix for settings array</p> required <code>size</code> <code>int | None</code> <p>size of settings array</p> <code>None</code> Source code in <code>prettyqt/core/settings.py</code> <pre><code>@contextlib.contextmanager\ndef write_array(self, prefix: str, size: int | None = None):\n\"\"\"Context manager for writing arrays.\n\n    Args:\n        prefix: prefix for settings array\n        size: size of settings array\n    \"\"\"\n    if size is None:\n        size = -1\n    self.beginWriteArray(prefix, size)\n    yield None\n    self.endArray()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.socketnotifier","title":"<code>socketnotifier</code>","text":""},{"location":"api/core.html#prettyqt.core.socketnotifier.SocketNotifier","title":"<code> SocketNotifier            (ObjectMixin, QSocketNotifier)         </code>","text":"Source code in <code>prettyqt/core/socketnotifier.py</code> <pre><code>class SocketNotifier(core.ObjectMixin, QtCore.QSocketNotifier):\n    # def __repr__(self):\n    #     return f\"{type(self).__name__}({self.socket()}, {self.type()})\"\n\n    def get_type(self) -&gt; TypeStr:\n\"\"\"Return socket event type.\n\n        Returns:\n            socket event type\n        \"\"\"\n        return TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.socketnotifier.SocketNotifier.get_type","title":"<code>get_type(self) -&gt; TypeStr</code>","text":"<p>Return socket event type.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>socket event type</p> Source code in <code>prettyqt/core/socketnotifier.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return socket event type.\n\n    Returns:\n        socket event type\n    \"\"\"\n    return TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream","title":"<code>textstream</code>","text":""},{"location":"api/core.html#prettyqt.core.textstream.TextStream","title":"<code> TextStream            (QTextStream)         </code>","text":"Source code in <code>prettyqt/core/textstream.py</code> <pre><code>class TextStream(QtCore.QTextStream):\n    def set_field_alignment(self, alignment: FieldAlignmentStr):\n\"\"\"Set the field alignment.\n\n        Args:\n            alignment: field alignment\n\n        Raises:\n            InvalidParamError: invalid field alignment\n        \"\"\"\n        if alignment not in FIELD_ALIGNMENT:\n            raise InvalidParamError(alignment, FIELD_ALIGNMENT)\n        self.setFieldAlignment(FIELD_ALIGNMENT[alignment])\n\n    def get_field_alignment(self) -&gt; FieldAlignmentStr:\n\"\"\"Get current field alignment.\n\n        Returns:\n            current field alignment\n        \"\"\"\n        return FIELD_ALIGNMENT.inverse[self.fieldAlignment()]\n\n    def set_status(self, status: StatusStr):\n\"\"\"Set the status.\n\n        Args:\n            status: status\n\n        Raises:\n            InvalidParamError: invalid status\n        \"\"\"\n        if status not in STATUS:\n            raise InvalidParamError(status, STATUS)\n        self.setStatus(STATUS[status])\n\n    def get_status(self) -&gt; StatusStr:\n\"\"\"Get current status.\n\n        Returns:\n            current status\n        \"\"\"\n        return STATUS.inverse[self.status()]\n\n    def set_real_number_notation(self, notation: RealNumberNotationStr):\n\"\"\"Set the real number notation.\n\n        Args:\n            notation: real number notation\n\n        Raises:\n            InvalidParamError: invalid real number notation\n        \"\"\"\n        if notation not in REAL_NUMBER_NOTATION:\n            raise InvalidParamError(notation, REAL_NUMBER_NOTATION)\n        self.setRealNumberNotation(REAL_NUMBER_NOTATION[notation])\n\n    def get_real_number_notation(self) -&gt; RealNumberNotationStr:\n\"\"\"Get current real number notation.\n\n        Returns:\n            current real number notation\n        \"\"\"\n        return REAL_NUMBER_NOTATION.inverse[self.realNumberNotation()]\n\n    def set_codec(self, codec: bytes | str):\n        if isinstance(codec, str):\n            codec = codec.encode()\n        self.setCodec(codec)\n\n    def read_lines(self) -&gt; Iterator[str]:\n        while True:\n            msg = self.readLine()\n            if not msg:\n                return\n            yield msg\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_field_alignment","title":"<code>get_field_alignment(self) -&gt; FieldAlignmentStr</code>","text":"<p>Get current field alignment.</p> <p>Returns:</p> Type Description <code>FieldAlignmentStr</code> <p>current field alignment</p> Source code in <code>prettyqt/core/textstream.py</code> <pre><code>def get_field_alignment(self) -&gt; FieldAlignmentStr:\n\"\"\"Get current field alignment.\n\n    Returns:\n        current field alignment\n    \"\"\"\n    return FIELD_ALIGNMENT.inverse[self.fieldAlignment()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_real_number_notation","title":"<code>get_real_number_notation(self) -&gt; RealNumberNotationStr</code>","text":"<p>Get current real number notation.</p> <p>Returns:</p> Type Description <code>RealNumberNotationStr</code> <p>current real number notation</p> Source code in <code>prettyqt/core/textstream.py</code> <pre><code>def get_real_number_notation(self) -&gt; RealNumberNotationStr:\n\"\"\"Get current real number notation.\n\n    Returns:\n        current real number notation\n    \"\"\"\n    return REAL_NUMBER_NOTATION.inverse[self.realNumberNotation()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_status","title":"<code>get_status(self) -&gt; StatusStr</code>","text":"<p>Get current status.</p> <p>Returns:</p> Type Description <code>StatusStr</code> <p>current status</p> Source code in <code>prettyqt/core/textstream.py</code> <pre><code>def get_status(self) -&gt; StatusStr:\n\"\"\"Get current status.\n\n    Returns:\n        current status\n    \"\"\"\n    return STATUS.inverse[self.status()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_field_alignment","title":"<code>set_field_alignment(self, alignment: FieldAlignmentStr)</code>","text":"<p>Set the field alignment.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>FieldAlignmentStr</code> <p>field alignment</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid field alignment</p> Source code in <code>prettyqt/core/textstream.py</code> <pre><code>def set_field_alignment(self, alignment: FieldAlignmentStr):\n\"\"\"Set the field alignment.\n\n    Args:\n        alignment: field alignment\n\n    Raises:\n        InvalidParamError: invalid field alignment\n    \"\"\"\n    if alignment not in FIELD_ALIGNMENT:\n        raise InvalidParamError(alignment, FIELD_ALIGNMENT)\n    self.setFieldAlignment(FIELD_ALIGNMENT[alignment])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_real_number_notation","title":"<code>set_real_number_notation(self, notation: RealNumberNotationStr)</code>","text":"<p>Set the real number notation.</p> <p>Parameters:</p> Name Type Description Default <code>notation</code> <code>RealNumberNotationStr</code> <p>real number notation</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid real number notation</p> Source code in <code>prettyqt/core/textstream.py</code> <pre><code>def set_real_number_notation(self, notation: RealNumberNotationStr):\n\"\"\"Set the real number notation.\n\n    Args:\n        notation: real number notation\n\n    Raises:\n        InvalidParamError: invalid real number notation\n    \"\"\"\n    if notation not in REAL_NUMBER_NOTATION:\n        raise InvalidParamError(notation, REAL_NUMBER_NOTATION)\n    self.setRealNumberNotation(REAL_NUMBER_NOTATION[notation])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_status","title":"<code>set_status(self, status: StatusStr)</code>","text":"<p>Set the status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>StatusStr</code> <p>status</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid status</p> Source code in <code>prettyqt/core/textstream.py</code> <pre><code>def set_status(self, status: StatusStr):\n\"\"\"Set the status.\n\n    Args:\n        status: status\n\n    Raises:\n        InvalidParamError: invalid status\n    \"\"\"\n    if status not in STATUS:\n        raise InvalidParamError(status, STATUS)\n    self.setStatus(STATUS[status])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timeline","title":"<code>timeline</code>","text":""},{"location":"api/core.html#prettyqt.core.timeline.TimeLine","title":"<code> TimeLine            (ObjectMixin, QTimeLine)         </code>","text":"Source code in <code>prettyqt/core/timeline.py</code> <pre><code>class TimeLine(core.ObjectMixin, QtCore.QTimeLine):\n    def serialize_fields(self):\n        return dict(\n            current_time=self.currentTime(),\n            direction=self.get_direction(),\n            duration=self.duration(),\n            easing_curve=self.easingCurve(),\n            loop_count=self.loopCount(),\n            update_interval=self.updateInterval(),\n        )\n\n    def set_direction(self, direction: DirectionStr):\n\"\"\"Set the direction.\n\n        Args:\n            direction: direction\n\n        Raises:\n            InvalidParamError: direction does not exist\n        \"\"\"\n        if direction not in DIRECTION:\n            raise InvalidParamError(direction, DIRECTION)\n        self.setDirection(DIRECTION[direction])\n\n    def get_direction(self) -&gt; DirectionStr:\n\"\"\"Return current direction.\n\n        Returns:\n            direction\n        \"\"\"\n        return DIRECTION.inverse[self.direction()]\n\n    def get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n\n        Returns:\n            state\n        \"\"\"\n        return STATE.inverse[self.state()]\n\n    def set_easing(\n        self, easing_type: core.easingcurve.TypeStr | Callable[[float], float]\n    ) -&gt; core.EasingCurve:\n        curve = core.EasingCurve()\n        if isinstance(easing_type, str):\n            curve.set_type(easing_type)\n        else:\n            curve.set_custom_type(easing_type)\n        self.setEasingCurve(curve)\n        return curve\n\n    def get_easing(self) -&gt; core.easingcurve.TypeStr | Callable[[float], float]:\n        curve = core.EasingCurve(self.easingCurve())\n        typ = curve.get_type()\n        if typ == \"custom\":\n            return curve.get_custom_type()\n        else:\n            return typ\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_direction","title":"<code>get_direction(self) -&gt; DirectionStr</code>","text":"<p>Return current direction.</p> <p>Returns:</p> Type Description <code>DirectionStr</code> <p>direction</p> Source code in <code>prettyqt/core/timeline.py</code> <pre><code>def get_direction(self) -&gt; DirectionStr:\n\"\"\"Return current direction.\n\n    Returns:\n        direction\n    \"\"\"\n    return DIRECTION.inverse[self.direction()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_state","title":"<code>get_state(self) -&gt; StateStr</code>","text":"<p>Return current state.</p> <p>Returns:</p> Type Description <code>StateStr</code> <p>state</p> Source code in <code>prettyqt/core/timeline.py</code> <pre><code>def get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n\n    Returns:\n        state\n    \"\"\"\n    return STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.set_direction","title":"<code>set_direction(self, direction: DirectionStr)</code>","text":"<p>Set the direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>DirectionStr</code> <p>direction</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>direction does not exist</p> Source code in <code>prettyqt/core/timeline.py</code> <pre><code>def set_direction(self, direction: DirectionStr):\n\"\"\"Set the direction.\n\n    Args:\n        direction: direction\n\n    Raises:\n        InvalidParamError: direction does not exist\n    \"\"\"\n    if direction not in DIRECTION:\n        raise InvalidParamError(direction, DIRECTION)\n    self.setDirection(DIRECTION[direction])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timer","title":"<code>timer</code>","text":""},{"location":"api/core.html#prettyqt.core.timer.Timer","title":"<code> Timer            (ObjectMixin, QTimer)         </code>","text":"Source code in <code>prettyqt/core/timer.py</code> <pre><code>class Timer(core.ObjectMixin, QtCore.QTimer):\n    def serialize_fields(self):\n        return dict(\n            interval=self.interval(),\n            single_shot=self.isSingleShot(),\n            timer_type=self.get_type(),\n        )\n\n    @classmethod\n    def single_shot(cls, callback: Callable) -&gt; Timer:\n        timer = cls()\n        timer.timeout.connect(callback)\n        timer.setSingleShot(True)\n        return timer\n\n    def set_type(self, typ: constants.TimerTypeStr):\n\"\"\"Set the timer type.\n\n        Args:\n            typ: timer type\n\n        Raises:\n            InvalidParamError: timer type does not exist\n        \"\"\"\n        if typ not in constants.TIMER_TYPE:\n            raise InvalidParamError(typ, constants.TIMER_TYPE)\n        self.setTimerType(constants.TIMER_TYPE[typ])\n\n    def get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n\n        Returns:\n            timer type\n        \"\"\"\n        return constants.TIMER_TYPE.inverse[self.timerType()]\n\n    def set_interval(self, interval: int | str):\n        if isinstance(interval, str):\n            interval = helpers.parse_time(interval)\n        self.setInterval(interval)\n\n    def start_timer(self, interval: None | int | str = None):\n        if isinstance(interval, str):\n            interval = helpers.parse_time(interval)\n        if interval is None:\n            self.start()\n        else:\n            self.start(interval)\n\n    def restart(self):\n        self.stop()\n        self.start()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timer.Timer.get_type","title":"<code>get_type(self) -&gt; constants.TimerTypeStr</code>","text":"<p>Return current timer type.</p> <p>Returns:</p> Type Description <code>constants.TimerTypeStr</code> <p>timer type</p> Source code in <code>prettyqt/core/timer.py</code> <pre><code>def get_type(self) -&gt; constants.TimerTypeStr:\n\"\"\"Return current timer type.\n\n    Returns:\n        timer type\n    \"\"\"\n    return constants.TIMER_TYPE.inverse[self.timerType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.timer.Timer.set_type","title":"<code>set_type(self, typ: constants.TimerTypeStr)</code>","text":"<p>Set the timer type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>constants.TimerTypeStr</code> <p>timer type</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>timer type does not exist</p> Source code in <code>prettyqt/core/timer.py</code> <pre><code>def set_type(self, typ: constants.TimerTypeStr):\n\"\"\"Set the timer type.\n\n    Args:\n        typ: timer type\n\n    Raises:\n        InvalidParamError: timer type does not exist\n    \"\"\"\n    if typ not in constants.TIMER_TYPE:\n        raise InvalidParamError(typ, constants.TIMER_TYPE)\n    self.setTimerType(constants.TIMER_TYPE[typ])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.url","title":"<code>url</code>","text":""},{"location":"api/core.html#prettyqt.core.url.Url","title":"<code> Url            (QUrl)         </code>","text":"Source code in <code>prettyqt/core/url.py</code> <pre><code>class Url(QtCore.QUrl):\n    def __init__(self, path: datatypes.UrlType | datatypes.PathType | None = None):\n        if path is None:\n            super().__init__()\n        else:\n            if isinstance(path, QtCore.QUrl):\n                super().__init__(path)\n            else:\n                super().__init__(os.fspath(path))\n            if isinstance(path, os.PathLike):\n                self.setScheme(\"file\")\n\n    # def __str__(self):\n    #     return self.absolutePath()\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.toString()!r})\"\n\n    def __str__(self):\n        return self.toString()\n\n    def serialize_fields(self):\n        return dict(path=self.toString())\n\n    def serialize(self) -&gt; dict[str, Any]:\n        return self.serialize_fields()\n\n    def to_string(self) -&gt; str:\n        return self.toString()\n\n    def to_path(self) -&gt; pathlib.Path:\n\"\"\"Get pathlib object from the URL.\n\n        Returns:\n            Path\n        \"\"\"\n        return pathlib.Path(str(self))\n\n    def is_local_file(self) -&gt; bool:\n        return self.isLocalFile()\n\n    @classmethod\n    def from_user_input(cls, url: str, working_dir: str | None = None) -&gt; Url:\n        if working_dir is None:\n            working_dir = \"\"\n        return cls(cls.fromUserInput(url, working_dir))\n\n    @classmethod\n    def from_local_file(cls, path: datatypes.PathType) -&gt; Url:\n        url = cls.fromLocalFile(os.fspath(path))\n        return cls(url)\n\n    def _has_explicit_scheme(self) -&gt; bool:\n\"\"\"Check if a url has an explicit scheme given.\"\"\"\n        return bool(\n            self.isValid()\n            and self.scheme()\n            and (self.host() or self.path())\n            and not self.path().startswith(\":\")\n        )\n\n    def is_special_url(self) -&gt; bool:\n\"\"\"Return True if url is an about:... or other special URL.\"\"\"\n        if not self.isValid():\n            return False\n        return self.scheme() in (\"about\", \"file\")\n</code></pre>"},{"location":"api/core.html#prettyqt.core.url.Url.is_special_url","title":"<code>is_special_url(self) -&gt; bool</code>","text":"<p>Return True if url is an about:... or other special URL.</p> Source code in <code>prettyqt/core/url.py</code> <pre><code>def is_special_url(self) -&gt; bool:\n\"\"\"Return True if url is an about:... or other special URL.\"\"\"\n    if not self.isValid():\n        return False\n    return self.scheme() in (\"about\", \"file\")\n</code></pre>"},{"location":"api/core.html#prettyqt.core.url.Url.to_path","title":"<code>to_path(self) -&gt; pathlib.Path</code>","text":"<p>Get pathlib object from the URL.</p> <p>Returns:</p> Type Description <code>pathlib.Path</code> <p>Path</p> Source code in <code>prettyqt/core/url.py</code> <pre><code>def to_path(self) -&gt; pathlib.Path:\n\"\"\"Get pathlib object from the URL.\n\n    Returns:\n        Path\n    \"\"\"\n    return pathlib.Path(str(self))\n</code></pre>"},{"location":"api/core.html#prettyqt.core.uuid","title":"<code>uuid</code>","text":""},{"location":"api/core.html#prettyqt.core.uuid.UuidMixin","title":"<code> UuidMixin        </code>","text":"Source code in <code>prettyqt/core/uuid.py</code> <pre><code>class UuidMixin:\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.toString()!r})\"\n\n    def __str__(self):\n        return self.toString()\n\n    def __bool__(self):\n        return not self.isNull()\n\n    def __reduce__(self):\n        return type(self), (self.toString(),)\n\n    def get_variant(self) -&gt; VariantStr:\n        return VARIANTS.inverse[self.variant()]\n\n    def get_version(self) -&gt; VersionStr:\n        return VERSION.inverse[self.version()]\n\n    @classmethod\n    def create_uuid(cls) -&gt; Uuid:\n        # workaround for PySide2, not able to clone in ctor\n        return cls(cls.createUuid().toString())\n\n    def to_string(self, fmt: StringFormatStr = \"with_braces\") -&gt; str:\n\"\"\"Return string representation of the Uuid.\n\n        Allowed values are \"with_braces\", \"without_braces\", \"id_128\"\n\n        Args:\n            fmt: Uuid format to use\n\n        Raises:\n            InvalidParamError: Uuid format does not exist\n        \"\"\"\n        if fmt not in STRING_FORMATS:\n            raise InvalidParamError(fmt, STRING_FORMATS)\n        return self.toString(STRING_FORMATS[fmt])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.uuid.UuidMixin.to_string","title":"<code>to_string(self, fmt: StringFormatStr = 'with_braces') -&gt; str</code>","text":"<p>Return string representation of the Uuid.</p> <p>Allowed values are \"with_braces\", \"without_braces\", \"id_128\"</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>StringFormatStr</code> <p>Uuid format to use</p> <code>'with_braces'</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>Uuid format does not exist</p> Source code in <code>prettyqt/core/uuid.py</code> <pre><code>def to_string(self, fmt: StringFormatStr = \"with_braces\") -&gt; str:\n\"\"\"Return string representation of the Uuid.\n\n    Allowed values are \"with_braces\", \"without_braces\", \"id_128\"\n\n    Args:\n        fmt: Uuid format to use\n\n    Raises:\n        InvalidParamError: Uuid format does not exist\n    \"\"\"\n    if fmt not in STRING_FORMATS:\n        raise InvalidParamError(fmt, STRING_FORMATS)\n    return self.toString(STRING_FORMATS[fmt])\n</code></pre>"},{"location":"api/core.html#prettyqt.core.versionnumber","title":"<code>versionnumber</code>","text":""},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber","title":"<code> VersionNumber            (QVersionNumber)         </code>","text":"Source code in <code>prettyqt/core/versionnumber.py</code> <pre><code>class VersionNumber(QtCore.QVersionNumber):\n    def __init__(self, *args, **kwargs):\n        if len(args) == 1:\n            if isinstance(args[0], str):\n                args = tuple(int(i) for i in args[0].split(\".\"))\n            elif isinstance(args[0], tuple):\n                args = args[0]\n            # PySide6 Workaround:\n            elif isinstance(args[0], QtCore.QVersionNumber):\n                args = (\n                    args[0].majorVersion(),\n                    args[0].minorVersion(),\n                    args[0].microVersion(),\n                )\n        super().__init__(*args, **kwargs)\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.major()}, {self.minor()}, {self.micro()})\"\n\n    def __reduce__(self):\n        return type(self), (self.major(), self.minor(), self.micro())\n\n    def __str__(self):\n        return self.toString()\n\n    def __eq__(self, other):\n        if isinstance(other, (str, tuple)):\n            other = VersionNumber(other)\n        return super().__eq__(other)\n\n    def __hash__(self):\n        return hash((self.major(), self.minor(), self.micro()))\n\n    def __gt__(self, other: datatypes.SemanticVersionType):\n        if isinstance(other, (str, tuple)):\n            other = VersionNumber(other)\n        return super().__gt__(other)\n\n    def __ge__(self, other: datatypes.SemanticVersionType):\n        if isinstance(other, (str, tuple)):\n            other = VersionNumber(other)\n        return super().__ge__(other)\n\n    def __lt__(self, other: datatypes.SemanticVersionType):\n        if isinstance(other, (str, tuple)):\n            other = VersionNumber(other)\n        return super().__lt__(other)\n\n    def __le__(self, other: datatypes.SemanticVersionType):\n        if isinstance(other, (str, tuple)):\n            other = VersionNumber(other)\n        return super().__le__(other)\n\n    @classmethod\n    def get_qt_version(cls) -&gt; VersionNumber:\n        return cls(*[int(i) for i in QtCore.__version__.split(\".\")])\n\n    @classmethod\n    def get_python_version(cls) -&gt; VersionNumber:\n        return cls(*sys.version_info[:3])\n\n    def major(self) -&gt; int:\n\"\"\"An integer representing the major version.\"\"\"\n        return self.majorVersion()\n\n    def minor(self) -&gt; int:\n\"\"\"An integer representing the minor version.\"\"\"\n        return self.minorVersion()\n\n    def micro(self) -&gt; int:\n\"\"\"An integer representing the micro version.\"\"\"\n        return self.microVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.major","title":"<code>major(self) -&gt; int</code>","text":"<p>An integer representing the major version.</p> Source code in <code>prettyqt/core/versionnumber.py</code> <pre><code>def major(self) -&gt; int:\n\"\"\"An integer representing the major version.\"\"\"\n    return self.majorVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.micro","title":"<code>micro(self) -&gt; int</code>","text":"<p>An integer representing the micro version.</p> Source code in <code>prettyqt/core/versionnumber.py</code> <pre><code>def micro(self) -&gt; int:\n\"\"\"An integer representing the micro version.\"\"\"\n    return self.microVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.minor","title":"<code>minor(self) -&gt; int</code>","text":"<p>An integer representing the minor version.</p> Source code in <code>prettyqt/core/versionnumber.py</code> <pre><code>def minor(self) -&gt; int:\n\"\"\"An integer representing the minor version.\"\"\"\n    return self.minorVersion()\n</code></pre>"},{"location":"api/core.html#prettyqt.core.xmlstreamreader","title":"<code>xmlstreamreader</code>","text":""},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader","title":"<code> XmlStreamReader            (QXmlStreamReader)         </code>","text":"Source code in <code>prettyqt/core/xmlstreamreader.py</code> <pre><code>class XmlStreamReader(QtCore.QXmlStreamReader):\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        while not self.atEnd():\n            self.readNext()\n            if self.hasError():\n                raise RuntimeError(self.get_error())\n            return self\n        raise StopIteration\n\n    def get_error(self) -&gt; FileErrorStr:\n\"\"\"Return file error status.\n\n        Returns:\n            file error status\n        \"\"\"\n        return ERROR.inverse[self.error()]\n\n    def get_token_type(self) -&gt; TokenTypeStr:\n\"\"\"Get the current token type.\n\n        Returns:\n            token type\n        \"\"\"\n        return TOKEN_TYPE.inverse[self.tokenType()]\n\n    def read_next(self) -&gt; TokenTypeStr:\n\"\"\"Read the next token and returns its type.\n\n        Returns:\n            token type\n        \"\"\"\n        return TOKEN_TYPE.inverse[self.readNext()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.get_error","title":"<code>get_error(self) -&gt; FileErrorStr</code>","text":"<p>Return file error status.</p> <p>Returns:</p> Type Description <code>FileErrorStr</code> <p>file error status</p> Source code in <code>prettyqt/core/xmlstreamreader.py</code> <pre><code>def get_error(self) -&gt; FileErrorStr:\n\"\"\"Return file error status.\n\n    Returns:\n        file error status\n    \"\"\"\n    return ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.get_token_type","title":"<code>get_token_type(self) -&gt; TokenTypeStr</code>","text":"<p>Get the current token type.</p> <p>Returns:</p> Type Description <code>TokenTypeStr</code> <p>token type</p> Source code in <code>prettyqt/core/xmlstreamreader.py</code> <pre><code>def get_token_type(self) -&gt; TokenTypeStr:\n\"\"\"Get the current token type.\n\n    Returns:\n        token type\n    \"\"\"\n    return TOKEN_TYPE.inverse[self.tokenType()]\n</code></pre>"},{"location":"api/core.html#prettyqt.core.xmlstreamreader.XmlStreamReader.read_next","title":"<code>read_next(self) -&gt; TokenTypeStr</code>","text":"<p>Read the next token and returns its type.</p> <p>Returns:</p> Type Description <code>TokenTypeStr</code> <p>token type</p> Source code in <code>prettyqt/core/xmlstreamreader.py</code> <pre><code>def read_next(self) -&gt; TokenTypeStr:\n\"\"\"Read the next token and returns its type.\n\n    Returns:\n        token type\n    \"\"\"\n    return TOKEN_TYPE.inverse[self.readNext()]\n</code></pre>"},{"location":"api/custom_delegates.html","title":"custom_delegates module","text":"<p>Module containing custom delegate classes.</p>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate","title":"<code>buttondelegate</code>","text":""},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate","title":"<code> ButtonDelegate            (ItemDelegate)         </code>","text":"Source code in <code>prettyqt/custom_delegates/buttondelegate.py</code> <pre><code>class ButtonDelegate(widgets.ItemDelegate):\n    def __init__(\n        self, parent: QtWidgets.QWidget | None, role=QtCore.Qt.ItemDataRole.UserRole\n    ):\n        super().__init__(parent)\n        self.fn_role = role\n\n    def createEditor(self, parent, option, index) -&gt; widgets.PushButton:\n        label = index.data()\n        btn_callback = index.data(self.fn_role)\n        btn = widgets.PushButton(label, parent)\n        if not btn_callback:\n            btn.set_disabled()\n        else:\n            btn.clicked.connect(btn_callback)\n        return btn\n\n    def setEditorData(self, editor, index):\n        pass\n\n    def setModelData(self, editor, model, index):\n        pass\n\n    @core.Slot()\n    def currentIndexChanged(self):\n        self.commitData.emit(self.sender())\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.createEditor","title":"<code>createEditor(self, parent, option, index) -&gt; widgets.PushButton</code>","text":"<p>createEditor(self, parent: PySide6.QtWidgets.QWidget, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; PySide6.QtWidgets.QWidget</p> Source code in <code>prettyqt/custom_delegates/buttondelegate.py</code> <pre><code>def createEditor(self, parent, option, index) -&gt; widgets.PushButton:\n    label = index.data()\n    btn_callback = index.data(self.fn_role)\n    btn = widgets.PushButton(label, parent)\n    if not btn_callback:\n        btn.set_disabled()\n    else:\n        btn.clicked.connect(btn_callback)\n    return btn\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setEditorData","title":"<code>setEditorData(self, editor, index)</code>","text":"<p>setEditorData(self, editor: PySide6.QtWidgets.QWidget, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; None</p> Source code in <code>prettyqt/custom_delegates/buttondelegate.py</code> <pre><code>def setEditorData(self, editor, index):\n    pass\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setModelData","title":"<code>setModelData(self, editor, model, index)</code>","text":"<p>setModelData(self, editor: PySide6.QtWidgets.QWidget, model: PySide6.QtCore.QAbstractItemModel, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; None</p> Source code in <code>prettyqt/custom_delegates/buttondelegate.py</code> <pre><code>def setModelData(self, editor, model, index):\n    pass\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate","title":"<code>checkboxdelegate</code>","text":""},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate","title":"<code> CheckBoxDelegate            (ItemDelegate)         </code>","text":"Source code in <code>prettyqt/custom_delegates/checkboxdelegate.py</code> <pre><code>class CheckBoxDelegate(widgets.ItemDelegate):\n\"\"\"Delegate that places a CheckBox in every cell.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.selected = []\n\n    def createEditor(self, parent, option, index):\n\"\"\"Override.\n\n        instanciate the editor widget and initialize it\n        also connect currentIndexChanged signal.\n        \"\"\"\n        cb = widgets.CheckBox(parent)\n        cb.currentIndexChanged.connect(self.currentIndexChanged)\n        return cb\n\n    def setEditorData(self, cb, index):\n\"\"\"Override.\n\n        set correct initial value for editor widget\n        \"\"\"\n        current_selection = index.data()\n        with cb.block_signals():\n            cb.setCurrentText(current_selection)\n\n    @core.Slot()\n    def currentIndexChanged(self):\n        self.commitData.emit(self.sender())\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.createEditor","title":"<code>createEditor(self, parent, option, index)</code>","text":"<p>Override.</p> <p>instanciate the editor widget and initialize it also connect currentIndexChanged signal.</p> Source code in <code>prettyqt/custom_delegates/checkboxdelegate.py</code> <pre><code>def createEditor(self, parent, option, index):\n\"\"\"Override.\n\n    instanciate the editor widget and initialize it\n    also connect currentIndexChanged signal.\n    \"\"\"\n    cb = widgets.CheckBox(parent)\n    cb.currentIndexChanged.connect(self.currentIndexChanged)\n    return cb\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.setEditorData","title":"<code>setEditorData(self, cb, index)</code>","text":"<p>Override.</p> <p>set correct initial value for editor widget</p> Source code in <code>prettyqt/custom_delegates/checkboxdelegate.py</code> <pre><code>def setEditorData(self, cb, index):\n\"\"\"Override.\n\n    set correct initial value for editor widget\n    \"\"\"\n    current_selection = index.data()\n    with cb.block_signals():\n        cb.setCurrentText(current_selection)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate","title":"<code>icondelegate</code>","text":""},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate","title":"<code> IconDelegate            (StyledItemDelegate)         </code>","text":"Source code in <code>prettyqt/custom_delegates/icondelegate.py</code> <pre><code>class IconDelegate(widgets.StyledItemDelegate):\n    def paint(\n        self,\n        painter: QtGui.QPainter,\n        option: QtWidgets.QStyleOptionViewItem,\n        index: QtCore.QModelIndex,\n    ):\n\"\"\"Override to paint an icon based on given Pixmap / Color / Icon.\n\n        Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000'\n\n        Args:\n            painter (QtGui.QPainter): painter to paint the icon\n            option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed\n            index (QtCore.QModelIndex): index which gets decorated\n        \"\"\"\n        super().paint(painter, option, index)\n        value = index.data(ICON_ROLE)\n        if not value:\n            return\n        margin = 10\n        mode = gui.Icon.Mode.Normal\n\n        if not (option.state &amp; widgets.Style.StateFlag.State_Enabled):\n            mode = gui.Icon.Mode.Disabled\n        elif option.state &amp; widgets.Style.StateFlag.State_Selected:\n            mode = gui.Icon.Mode.Selected\n        match value:\n            case QtGui.QPixmap():\n                icon = QtGui.QIcon(value)\n                option.decorationSize = int(value.size() / value.devicePixelRatio())\n\n            case QtGui.QColor():\n                pixmap = QtGui.QPixmap(option.decorationSize)\n                pixmap.fill(value)\n                icon = QtGui.QIcon(pixmap)\n\n            case QtGui.QImage():\n                icon = QtGui.QIcon(QtGui.QPixmap.fromImage(value))\n                option.decorationSize = int(value.size() / value.devicePixelRatio())\n\n            case QtGui.QIcon():\n                icon = value\n                is_on = option.state &amp; widgets.Style.StateFlag.State_Open\n                state = gui.Icon.State.On if is_on else gui.Icon.State.Off\n                actual_size = option.icon.actualSize(option.decorationSize, mode, state)\n                option.decorationSize = option.decorationSize &amp; actual_size\n            case _:\n                raise ValueError(value)\n        r = core.Rect(core.Point(), option.decorationSize)\n        r.moveCenter(option.rect.center())\n        r.setRight(option.rect.right() - margin)\n        state = (\n            gui.Icon.State.On\n            if option.state &amp; widgets.Style.StateFlag.State_Open\n            else gui.Icon.State.Off\n        )\n        alignment = constants.ALIGN_RIGHT | constants.ALIGN_V_CENTER  # type: ignore\n        icon.paint(painter, r, alignment, mode, state)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate.paint","title":"<code>paint(self, painter: QtGui.QPainter, option: QtWidgets.QStyleOptionViewItem, index: QtCore.QModelIndex)</code>","text":"<p>Override to paint an icon based on given Pixmap / Color / Icon.</p> <p>Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000'</p> <p>Parameters:</p> Name Type Description Default <code>painter</code> <code>QtGui.QPainter</code> <p>painter to paint the icon</p> required <code>option</code> <code>QtWidgets.QStyleOptionViewItem</code> <p>state of the item to be displayed</p> required <code>index</code> <code>QtCore.QModelIndex</code> <p>index which gets decorated</p> required Source code in <code>prettyqt/custom_delegates/icondelegate.py</code> <pre><code>def paint(\n    self,\n    painter: QtGui.QPainter,\n    option: QtWidgets.QStyleOptionViewItem,\n    index: QtCore.QModelIndex,\n):\n\"\"\"Override to paint an icon based on given Pixmap / Color / Icon.\n\n    Pixmap / Color / Icon must be set to 'QtCore.Qt.ItemDataRole.UserRole + 1000'\n\n    Args:\n        painter (QtGui.QPainter): painter to paint the icon\n        option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed\n        index (QtCore.QModelIndex): index which gets decorated\n    \"\"\"\n    super().paint(painter, option, index)\n    value = index.data(ICON_ROLE)\n    if not value:\n        return\n    margin = 10\n    mode = gui.Icon.Mode.Normal\n\n    if not (option.state &amp; widgets.Style.StateFlag.State_Enabled):\n        mode = gui.Icon.Mode.Disabled\n    elif option.state &amp; widgets.Style.StateFlag.State_Selected:\n        mode = gui.Icon.Mode.Selected\n    match value:\n        case QtGui.QPixmap():\n            icon = QtGui.QIcon(value)\n            option.decorationSize = int(value.size() / value.devicePixelRatio())\n\n        case QtGui.QColor():\n            pixmap = QtGui.QPixmap(option.decorationSize)\n            pixmap.fill(value)\n            icon = QtGui.QIcon(pixmap)\n\n        case QtGui.QImage():\n            icon = QtGui.QIcon(QtGui.QPixmap.fromImage(value))\n            option.decorationSize = int(value.size() / value.devicePixelRatio())\n\n        case QtGui.QIcon():\n            icon = value\n            is_on = option.state &amp; widgets.Style.StateFlag.State_Open\n            state = gui.Icon.State.On if is_on else gui.Icon.State.Off\n            actual_size = option.icon.actualSize(option.decorationSize, mode, state)\n            option.decorationSize = option.decorationSize &amp; actual_size\n        case _:\n            raise ValueError(value)\n    r = core.Rect(core.Point(), option.decorationSize)\n    r.moveCenter(option.rect.center())\n    r.setRight(option.rect.right() - margin)\n    state = (\n        gui.Icon.State.On\n        if option.state &amp; widgets.Style.StateFlag.State_Open\n        else gui.Icon.State.Off\n    )\n    alignment = constants.ALIGN_RIGHT | constants.ALIGN_V_CENTER  # type: ignore\n    icon.paint(painter, r, alignment, mode, state)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate","title":"<code>nofocusdelegate</code>","text":""},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate","title":"<code> NoFocusDelegate            (StyledItemDelegate)         </code>","text":"Source code in <code>prettyqt/custom_delegates/nofocusdelegate.py</code> <pre><code>class NoFocusDelegate(widgets.StyledItemDelegate):\n    def paint(\n        self,\n        painter: QtGui.QPainter,\n        option: QtWidgets.QStyleOptionViewItem,\n        index: QtCore.QModelIndex,\n    ):\n        if option.state &amp; widgets.Style.StateFlag.State_HasFocus:\n            option.state = option.state ^ widgets.Style.StateFlag.State_HasFocus\n        super().paint(painter, option, index)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate.paint","title":"<code>paint(self, painter: QtGui.QPainter, option: QtWidgets.QStyleOptionViewItem, index: QtCore.QModelIndex)</code>","text":"<p>paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; None</p> Source code in <code>prettyqt/custom_delegates/nofocusdelegate.py</code> <pre><code>def paint(\n    self,\n    painter: QtGui.QPainter,\n    option: QtWidgets.QStyleOptionViewItem,\n    index: QtCore.QModelIndex,\n):\n    if option.state &amp; widgets.Style.StateFlag.State_HasFocus:\n        option.state = option.state ^ widgets.Style.StateFlag.State_HasFocus\n    super().paint(painter, option, index)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate","title":"<code>progressbardelegate</code>","text":""},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate.ProgressBarDelegate","title":"<code> ProgressBarDelegate            (StyledItemDelegate)         </code>","text":"Source code in <code>prettyqt/custom_delegates/progressbardelegate.py</code> <pre><code>class ProgressBarDelegate(widgets.StyledItemDelegate):\n    def paint(self, painter, option, index):\n        progress = index.data()\n        opt = widgets.StyleOptionProgressBar()\n        opt.rect = option.rect\n        opt.minimum = 0\n        opt.maximum = 100\n        opt.progress = progress\n        opt.text = f\"{progress}%\"\n        opt.textVisible = True\n        opt.state |= widgets.Style.StateFlag.State_Horizontal\n        widgets.Application.style().drawControl(\n            widgets.Style.ControlElement.CE_ProgressBar, opt, painter\n        )\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate.ProgressBarDelegate.paint","title":"<code>paint(self, painter, option, index)</code>","text":"<p>paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; None</p> Source code in <code>prettyqt/custom_delegates/progressbardelegate.py</code> <pre><code>def paint(self, painter, option, index):\n    progress = index.data()\n    opt = widgets.StyleOptionProgressBar()\n    opt.rect = option.rect\n    opt.minimum = 0\n    opt.maximum = 100\n    opt.progress = progress\n    opt.text = f\"{progress}%\"\n    opt.textVisible = True\n    opt.state |= widgets.Style.StateFlag.State_Horizontal\n    widgets.Application.style().drawControl(\n        widgets.Style.ControlElement.CE_ProgressBar, opt, painter\n    )\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate","title":"<code>radiodelegate</code>","text":""},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate","title":"<code> RadioDelegate            (StyledItemDelegate)         </code>","text":"Source code in <code>prettyqt/custom_delegates/radiodelegate.py</code> <pre><code>class RadioDelegate(widgets.StyledItemDelegate):\n    def __init__(self, parent: QtWidgets.QWidget, items: list[str]):\n        super().__init__(parent)\n        self.items = items\n        self.choices: list[int | None] = [None for i in self.items]\n\n    def createEditor(\n        self,\n        parent: QtWidgets.QWidget,\n        option: QtWidgets.QStyleOptionViewItem,\n        index: QtCore.QModelIndex,\n    ) -&gt; widgets.Widget:\n        editor = widgets.Widget(parent)\n        editor.set_margin(0)\n        editor.setAutoFillBackground(True)\n        # create a button group to keep track of the checked radio\n        editor.button_group = widgets.ButtonGroup()\n        # adding the widget as an argument to the layout constructor automatically\n        # applies it to the widget\n        layout = widgets.BoxLayout(\"horizontal\", parent=editor)\n        layout.set_margin(0)\n        for i, k in enumerate(self.items):\n            rb = widgets.RadioButton(k)\n            layout.addWidget(rb)\n            # prevent the radio to get focus from keyboard or mouse\n            rb.set_focus_policy(\"none\")\n            rb.installEventFilter(self)\n            editor.button_group.addButton(rb, i)\n        # add a stretch to always align contents to the left\n        layout.addStretch(1)\n\n        # set a property that will be used for the mask\n        editor.setProperty(\"offMask\", gui.Region(editor.rect()))  # type: ignore\n        editor.installEventFilter(self)\n        return editor\n\n    def eventFilter(self, source: QtWidgets.QWidget, event: QtCore.QEvent) -&gt; bool:\n        match event.type():\n            case core.Event.Type.MouseButtonPress:\n                if isinstance(source, QtWidgets.QRadioButton):\n                    if not source.parent().hasFocus():\n                        # the parent has no focus, set it and ignore the click\n                        source.parent().setFocus()\n                        return True\n                elif not source.hasFocus():\n                    # the container has been clicked, check\n                    source.setFocus()\n            case core.Event.Type.FocusIn:\n                # event received as a consequence of setFocus\n                # clear the mask to show it completely\n                source.clearMask()\n            case core.Event.Type.FocusOut:\n                # another widget has requested focus, set the mask\n                source.setMask(source.property(b\"offMask\"))\n                # update the table viewport to get rid of possible\n                # grid lines left after masking\n                source.parent().update()\n        return super().eventFilter(source, event)\n\n    def updateEditorGeometry(\n        self,\n        editor: QtWidgets.QWidget,\n        option: QtWidgets.QStyleOptionViewItem,\n        index: QtCore.QModelIndex,\n    ):\n        rect = core.Rect(option.rect)\n        min_width = editor.minimumSizeHint().width()\n        if rect.width() &lt; min_width:\n            rect.setWidth(min_width)\n        editor.setGeometry(rect)\n        # create a new mask based on the option rectangle, then apply it\n        mask = gui.Region(0, 0, option.rect.width(), option.rect.height())\n        editor.setProperty(\"offMask\", mask)  # type: ignore\n        editor.setMask(mask)\n\n    def setEditorData(self, editor: QtWidgets.QWidget, index: QtCore.QModelIndex):\n        value = index.data(constants.DISPLAY_ROLE)  # type: ignore\n        if value in self.items:\n            editor.button_group.button(self.items.index(value)).setChecked(True)\n\n    def setModelData(\n        self,\n        editor: QtWidgets.QWidget,\n        model: QtCore.QAbstractItemModel,\n        index: QtCore.QModelIndex,\n    ):\n        button = editor.button_group.checkedId()\n        if button &gt;= 0:\n            model.setData(\n                index, self.items[button], constants.DISPLAY_ROLE  # type: ignore\n            )\n            self.choices[button] = index.row()\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.createEditor","title":"<code>createEditor(self, parent: QtWidgets.QWidget, option: QtWidgets.QStyleOptionViewItem, index: QtCore.QModelIndex) -&gt; widgets.Widget</code>","text":"<p>createEditor(self, parent: PySide6.QtWidgets.QWidget, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; PySide6.QtWidgets.QWidget</p> Source code in <code>prettyqt/custom_delegates/radiodelegate.py</code> <pre><code>def createEditor(\n    self,\n    parent: QtWidgets.QWidget,\n    option: QtWidgets.QStyleOptionViewItem,\n    index: QtCore.QModelIndex,\n) -&gt; widgets.Widget:\n    editor = widgets.Widget(parent)\n    editor.set_margin(0)\n    editor.setAutoFillBackground(True)\n    # create a button group to keep track of the checked radio\n    editor.button_group = widgets.ButtonGroup()\n    # adding the widget as an argument to the layout constructor automatically\n    # applies it to the widget\n    layout = widgets.BoxLayout(\"horizontal\", parent=editor)\n    layout.set_margin(0)\n    for i, k in enumerate(self.items):\n        rb = widgets.RadioButton(k)\n        layout.addWidget(rb)\n        # prevent the radio to get focus from keyboard or mouse\n        rb.set_focus_policy(\"none\")\n        rb.installEventFilter(self)\n        editor.button_group.addButton(rb, i)\n    # add a stretch to always align contents to the left\n    layout.addStretch(1)\n\n    # set a property that will be used for the mask\n    editor.setProperty(\"offMask\", gui.Region(editor.rect()))  # type: ignore\n    editor.installEventFilter(self)\n    return editor\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.eventFilter","title":"<code>eventFilter(self, source: QtWidgets.QWidget, event: QtCore.QEvent) -&gt; bool</code>","text":"<p>eventFilter(self, object: PySide6.QtCore.QObject, event: PySide6.QtCore.QEvent) -&gt; bool</p> Source code in <code>prettyqt/custom_delegates/radiodelegate.py</code> <pre><code>def eventFilter(self, source: QtWidgets.QWidget, event: QtCore.QEvent) -&gt; bool:\n    match event.type():\n        case core.Event.Type.MouseButtonPress:\n            if isinstance(source, QtWidgets.QRadioButton):\n                if not source.parent().hasFocus():\n                    # the parent has no focus, set it and ignore the click\n                    source.parent().setFocus()\n                    return True\n            elif not source.hasFocus():\n                # the container has been clicked, check\n                source.setFocus()\n        case core.Event.Type.FocusIn:\n            # event received as a consequence of setFocus\n            # clear the mask to show it completely\n            source.clearMask()\n        case core.Event.Type.FocusOut:\n            # another widget has requested focus, set the mask\n            source.setMask(source.property(b\"offMask\"))\n            # update the table viewport to get rid of possible\n            # grid lines left after masking\n            source.parent().update()\n    return super().eventFilter(source, event)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setEditorData","title":"<code>setEditorData(self, editor: QtWidgets.QWidget, index: QtCore.QModelIndex)</code>","text":"<p>setEditorData(self, editor: PySide6.QtWidgets.QWidget, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; None</p> Source code in <code>prettyqt/custom_delegates/radiodelegate.py</code> <pre><code>def setEditorData(self, editor: QtWidgets.QWidget, index: QtCore.QModelIndex):\n    value = index.data(constants.DISPLAY_ROLE)  # type: ignore\n    if value in self.items:\n        editor.button_group.button(self.items.index(value)).setChecked(True)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setModelData","title":"<code>setModelData(self, editor: QtWidgets.QWidget, model: QtCore.QAbstractItemModel, index: QtCore.QModelIndex)</code>","text":"<p>setModelData(self, editor: PySide6.QtWidgets.QWidget, model: PySide6.QtCore.QAbstractItemModel, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; None</p> Source code in <code>prettyqt/custom_delegates/radiodelegate.py</code> <pre><code>def setModelData(\n    self,\n    editor: QtWidgets.QWidget,\n    model: QtCore.QAbstractItemModel,\n    index: QtCore.QModelIndex,\n):\n    button = editor.button_group.checkedId()\n    if button &gt;= 0:\n        model.setData(\n            index, self.items[button], constants.DISPLAY_ROLE  # type: ignore\n        )\n        self.choices[button] = index.row()\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.updateEditorGeometry","title":"<code>updateEditorGeometry(self, editor: QtWidgets.QWidget, option: QtWidgets.QStyleOptionViewItem, index: QtCore.QModelIndex)</code>","text":"<p>updateEditorGeometry(self, editor: PySide6.QtWidgets.QWidget, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; None</p> Source code in <code>prettyqt/custom_delegates/radiodelegate.py</code> <pre><code>def updateEditorGeometry(\n    self,\n    editor: QtWidgets.QWidget,\n    option: QtWidgets.QStyleOptionViewItem,\n    index: QtCore.QModelIndex,\n):\n    rect = core.Rect(option.rect)\n    min_width = editor.minimumSizeHint().width()\n    if rect.width() &lt; min_width:\n        rect.setWidth(min_width)\n    editor.setGeometry(rect)\n    # create a new mask based on the option rectangle, then apply it\n    mask = gui.Region(0, 0, option.rect.width(), option.rect.height())\n    editor.setProperty(\"offMask\", mask)  # type: ignore\n    editor.setMask(mask)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate","title":"<code>renderlinkdelegate</code>","text":""},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate.RenderLinkDelegate","title":"<code> RenderLinkDelegate            (StyledItemDelegate)         </code>","text":"Source code in <code>prettyqt/custom_delegates/renderlinkdelegate.py</code> <pre><code>class RenderLinkDelegate(widgets.StyledItemDelegate):\n    def paint(self, painter, option, index):\n        text = index.data()\n        if not text:\n            return\n\n        painter.save()\n\n        # I only wanted it for mouse over, but you'll probably want to remove\n        # this condition\n        if option.state and widgets.Style.StateFlag.State_MouseOver:\n            font = option.font\n            font.setUnderline(True)\n            painter.setFont(font)\n            painter.setPen(option.palette.link().color())\n        painter.drawText(\n            option.rect,\n            constants.ALIGN_LEFT | constants.ALIGN_V_CENTER,  # type: ignore\n        )\n        painter.restore()\n\n    def editorEvent(self, event, model, option, index):\n        text = index.data()\n        font = index.data(constants.FONT_ROLE)\n        # alignment = index.data(constants.ALIGNMENT_ROLE)\n        if font is None:\n            font = gui.GuiApplication.get_font()\n        fm = gui.FontMetricsF(font)\n        rect = fm.get_bounding_rect(\n            core.RectF(option.rect),\n            constants.ALIGN_LEFT | constants.ALIGN_V_CENTER,  # type: ignore\n            text,\n        )\n        if (\n            event.type() == QtCore.QEvent.Type.MouseButtonPress\n            and event.button() == QtCore.Qt.MouseButton.LeftButton\n            and event.localPos() in rect\n        ):\n            text = index.data()\n            gui.DesktopServices.open_url(text)\n            return True\n        return False\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate.RenderLinkDelegate.editorEvent","title":"<code>editorEvent(self, event, model, option, index)</code>","text":"<p>editorEvent(self, event: PySide6.QtCore.QEvent, model: PySide6.QtCore.QAbstractItemModel, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; bool</p> Source code in <code>prettyqt/custom_delegates/renderlinkdelegate.py</code> <pre><code>def editorEvent(self, event, model, option, index):\n    text = index.data()\n    font = index.data(constants.FONT_ROLE)\n    # alignment = index.data(constants.ALIGNMENT_ROLE)\n    if font is None:\n        font = gui.GuiApplication.get_font()\n    fm = gui.FontMetricsF(font)\n    rect = fm.get_bounding_rect(\n        core.RectF(option.rect),\n        constants.ALIGN_LEFT | constants.ALIGN_V_CENTER,  # type: ignore\n        text,\n    )\n    if (\n        event.type() == QtCore.QEvent.Type.MouseButtonPress\n        and event.button() == QtCore.Qt.MouseButton.LeftButton\n        and event.localPos() in rect\n    ):\n        text = index.data()\n        gui.DesktopServices.open_url(text)\n        return True\n    return False\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate.RenderLinkDelegate.paint","title":"<code>paint(self, painter, option, index)</code>","text":"<p>paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; None</p> Source code in <code>prettyqt/custom_delegates/renderlinkdelegate.py</code> <pre><code>def paint(self, painter, option, index):\n    text = index.data()\n    if not text:\n        return\n\n    painter.save()\n\n    # I only wanted it for mouse over, but you'll probably want to remove\n    # this condition\n    if option.state and widgets.Style.StateFlag.State_MouseOver:\n        font = option.font\n        font.setUnderline(True)\n        painter.setFont(font)\n        painter.setPen(option.palette.link().color())\n    painter.drawText(\n        option.rect,\n        constants.ALIGN_LEFT | constants.ALIGN_V_CENTER,  # type: ignore\n    )\n    painter.restore()\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate","title":"<code>stardelegate</code>","text":""},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate","title":"<code> StarDelegate            (StyledItemDelegate)         </code>","text":"Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>class StarDelegate(widgets.StyledItemDelegate):\n\"\"\"A delegate class that allows us to render our star ratings.\"\"\"\n\n    def paint(self, painter, option, index):\n        star_rating = StarRating(index.data())\n\n        # If the row is currently selected, we need to make sure we\n        # paint the background accordingly.\n        if option.state &amp; widgets.Style.StateFlag.State_Selected:\n            # The original C++ example used option.palette.foreground() to\n            # get the brush for painting, but there are a couple of\n            # problems with that:\n            #   - foreground() is obsolete now, use windowText() instead\n            #   - more importantly, windowText() just returns a brush\n            #     containing a flat color, where sometimes the style\n            #     would have a nice subtle gradient or something.\n            # Here we just use the brush of the painter object that's\n            # passed in to us, which keeps the row highlighting nice\n            # and consistent.\n            painter.fillRect(option.rect, painter.brush())\n\n        # Now that we've painted the background, call star_rating.paint()\n        # to paint the stars.\n        star_rating.paint(painter, option.rect, option.palette)\n\n    def sizeHint(self, option, index):\n\"\"\"Return the size needed to display the item in a QSize object.\"\"\"\n        star_rating = StarRating(index.data())\n        return star_rating.sizeHint()\n\n    # The next 4 methods handle the custom editing that we need to do.\n    # If this were just a display delegate, paint() and sizeHint() would\n    # be all we needed.\n\n    def createEditor(self, parent, option, index):\n\"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\"\n        editor = StarEditor(parent)\n        editor.editing_finished.connect(self.commitAndCloseEditor)\n        return editor\n\n    def setEditorData(self, editor, index):\n\"\"\"Set the data to be displayed and edited by our custom editor.\"\"\"\n        editor.set_star_rating(index.data())\n\n    def setModelData(self, editor, model, index):\n\"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\"\n        model.setData(index, editor.star_rating.star_count)\n\n    def commitAndCloseEditor(self):\n        editor = self.sender()\n\n        # The commitData signal must be emitted when we've finished editing\n        # and need to write our changed back to the model.\n        self.commitData.emit(editor)\n        self.closeEditor.emit(editor, self.NoHint)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.createEditor","title":"<code>createEditor(self, parent, option, index)</code>","text":"<p>Create and return the StarEditor object we'll use to edit the StarRating.</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def createEditor(self, parent, option, index):\n\"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\"\n    editor = StarEditor(parent)\n    editor.editing_finished.connect(self.commitAndCloseEditor)\n    return editor\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.paint","title":"<code>paint(self, painter, option, index)</code>","text":"<p>paint(self, painter: PySide6.QtGui.QPainter, option: PySide6.QtWidgets.QStyleOptionViewItem, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; None</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def paint(self, painter, option, index):\n    star_rating = StarRating(index.data())\n\n    # If the row is currently selected, we need to make sure we\n    # paint the background accordingly.\n    if option.state &amp; widgets.Style.StateFlag.State_Selected:\n        # The original C++ example used option.palette.foreground() to\n        # get the brush for painting, but there are a couple of\n        # problems with that:\n        #   - foreground() is obsolete now, use windowText() instead\n        #   - more importantly, windowText() just returns a brush\n        #     containing a flat color, where sometimes the style\n        #     would have a nice subtle gradient or something.\n        # Here we just use the brush of the painter object that's\n        # passed in to us, which keeps the row highlighting nice\n        # and consistent.\n        painter.fillRect(option.rect, painter.brush())\n\n    # Now that we've painted the background, call star_rating.paint()\n    # to paint the stars.\n    star_rating.paint(painter, option.rect, option.palette)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setEditorData","title":"<code>setEditorData(self, editor, index)</code>","text":"<p>Set the data to be displayed and edited by our custom editor.</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def setEditorData(self, editor, index):\n\"\"\"Set the data to be displayed and edited by our custom editor.\"\"\"\n    editor.set_star_rating(index.data())\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setModelData","title":"<code>setModelData(self, editor, model, index)</code>","text":"<p>Get the data from our custom editor and stuffs it into the model.</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def setModelData(self, editor, model, index):\n\"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\"\n    model.setData(index, editor.star_rating.star_count)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.sizeHint","title":"<code>sizeHint(self, option, index)</code>","text":"<p>Return the size needed to display the item in a QSize object.</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def sizeHint(self, option, index):\n\"\"\"Return the size needed to display the item in a QSize object.\"\"\"\n    star_rating = StarRating(index.data())\n    return star_rating.sizeHint()\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor","title":"<code> StarEditor            (Widget)         </code>","text":"Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>class StarEditor(widgets.Widget):\n\"\"\"The custom editor for editing StarRatings.\"\"\"\n\n    # A signal to tell the delegate when we've finished editing.\n    editing_finished = core.Signal()\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n\"\"\"Initialize the editor object, making sure we can watch mouse events.\"\"\"\n        super().__init__(parent)\n\n        self.setMouseTracking(True)\n        self.setAutoFillBackground(True)\n        self.star_rating = StarRating()\n\n    def sizeHint(self):\n\"\"\"Tell the caller how big we are.\"\"\"\n        return self.star_rating.sizeHint()\n\n    def paintEvent(self, event):\n\"\"\"Paint the editor, offloading the work to the StarRating class.\"\"\"\n        painter = gui.Painter(self)\n        self.star_rating.paint(painter, self.rect(), self.palette(), is_editable=True)\n\n    def mouseMoveEvent(self, event):\n\"\"\"Update stars on mouse move.\"\"\"\n        star = self.star_at_position(event.x())\n\n        if star != -1:\n            self.star_rating.star_count = star\n            self.update()\n\n    def mouseReleaseEvent(self, event):\n\"\"\"Once star rating was clicked, tell the delegate we're done editing.\"\"\"\n        self.editing_finished.emit()\n\n    def star_at_position(self, x: int) -&gt; int:\n\"\"\"Calculate which star the user's mouse cursor is currently hovering over.\"\"\"\n        val = x // (self.star_rating.sizeHint().width() // self.star_rating.max_stars) + 1\n        if not 0 &lt; val &lt;= self.star_rating.max_stars:\n            return -1\n        return val\n\n    def set_star_rating(self, rating: int):\n        self.star_rating.star_count = rating\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.__init__","title":"<code>__init__(self, parent: QtWidgets.QWidget | None = None)</code>  <code>special</code>","text":"<p>Initialize the editor object, making sure we can watch mouse events.</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget | None = None):\n\"\"\"Initialize the editor object, making sure we can watch mouse events.\"\"\"\n    super().__init__(parent)\n\n    self.setMouseTracking(True)\n    self.setAutoFillBackground(True)\n    self.star_rating = StarRating()\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.mouseMoveEvent","title":"<code>mouseMoveEvent(self, event)</code>","text":"<p>Update stars on mouse move.</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def mouseMoveEvent(self, event):\n\"\"\"Update stars on mouse move.\"\"\"\n    star = self.star_at_position(event.x())\n\n    if star != -1:\n        self.star_rating.star_count = star\n        self.update()\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.mouseReleaseEvent","title":"<code>mouseReleaseEvent(self, event)</code>","text":"<p>Once star rating was clicked, tell the delegate we're done editing.</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def mouseReleaseEvent(self, event):\n\"\"\"Once star rating was clicked, tell the delegate we're done editing.\"\"\"\n    self.editing_finished.emit()\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.paintEvent","title":"<code>paintEvent(self, event)</code>","text":"<p>Paint the editor, offloading the work to the StarRating class.</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def paintEvent(self, event):\n\"\"\"Paint the editor, offloading the work to the StarRating class.\"\"\"\n    painter = gui.Painter(self)\n    self.star_rating.paint(painter, self.rect(), self.palette(), is_editable=True)\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.sizeHint","title":"<code>sizeHint(self)</code>","text":"<p>Tell the caller how big we are.</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def sizeHint(self):\n\"\"\"Tell the caller how big we are.\"\"\"\n    return self.star_rating.sizeHint()\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.star_at_position","title":"<code>star_at_position(self, x: int) -&gt; int</code>","text":"<p>Calculate which star the user's mouse cursor is currently hovering over.</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def star_at_position(self, x: int) -&gt; int:\n\"\"\"Calculate which star the user's mouse cursor is currently hovering over.\"\"\"\n    val = x // (self.star_rating.sizeHint().width() // self.star_rating.max_stars) + 1\n    if not 0 &lt; val &lt;= self.star_rating.max_stars:\n        return -1\n    return val\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarRating","title":"<code> StarRating        </code>","text":"<p>Handle the actual painting of the stars themselves.</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>class StarRating:\n\"\"\"Handle the actual painting of the stars themselves.\"\"\"\n\n    def __init__(self, star_count: int = 1, max_stars: int = 5):\n        self.star_count = star_count\n        self.max_stars = max_stars\n\n    def sizeHint(self):\n        return PAINTING_SCALE_FACTOR * core.Size(self.max_stars, 1)\n\n    def paint(\n        self,\n        painter: QtGui.QPainter,\n        rect: QtCore.QRect,\n        palette: QtGui.QPalette,\n        is_editable: bool = False,\n    ):\n\"\"\"Paint the stars (and/or diamonds if we're in editing mode).\"\"\"\n        painter.save()\n        painter.setRenderHint(painter.RenderHint.Antialiasing, True)\n        painter.setPen(QtCore.Qt.PenStyle.NoPen)\n        painter.setBrush(palette.highlight() if is_editable else palette.windowText())\n        y_offset = (rect.height() - PAINTING_SCALE_FACTOR) / 2\n        painter.translate(rect.x(), rect.y() + y_offset)\n        painter.scale(PAINTING_SCALE_FACTOR, PAINTING_SCALE_FACTOR)\n        for i in range(self.max_stars):\n            if i &lt; self.star_count:\n                painter.drawPolygon(STAR_POLYGON, QtCore.Qt.FillRule.WindingFill)\n            elif is_editable:\n                painter.drawPolygon(DIAMOND_POLYGON, QtCore.Qt.FillRule.WindingFill)\n            else:\n                break\n            painter.translate(1.0, 0.0)\n        painter.restore()\n</code></pre>"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarRating.paint","title":"<code>paint(self, painter: QtGui.QPainter, rect: QtCore.QRect, palette: QtGui.QPalette, is_editable: bool = False)</code>","text":"<p>Paint the stars (and/or diamonds if we're in editing mode).</p> Source code in <code>prettyqt/custom_delegates/stardelegate.py</code> <pre><code>def paint(\n    self,\n    painter: QtGui.QPainter,\n    rect: QtCore.QRect,\n    palette: QtGui.QPalette,\n    is_editable: bool = False,\n):\n\"\"\"Paint the stars (and/or diamonds if we're in editing mode).\"\"\"\n    painter.save()\n    painter.setRenderHint(painter.RenderHint.Antialiasing, True)\n    painter.setPen(QtCore.Qt.PenStyle.NoPen)\n    painter.setBrush(palette.highlight() if is_editable else palette.windowText())\n    y_offset = (rect.height() - PAINTING_SCALE_FACTOR) / 2\n    painter.translate(rect.x(), rect.y() + y_offset)\n    painter.scale(PAINTING_SCALE_FACTOR, PAINTING_SCALE_FACTOR)\n    for i in range(self.max_stars):\n        if i &lt; self.star_count:\n            painter.drawPolygon(STAR_POLYGON, QtCore.Qt.FillRule.WindingFill)\n        elif is_editable:\n            painter.drawPolygon(DIAMOND_POLYGON, QtCore.Qt.FillRule.WindingFill)\n        else:\n            break\n        painter.translate(1.0, 0.0)\n    painter.restore()\n</code></pre>"},{"location":"api/custom_models.html","title":"custom_models module","text":"<p>Custom_models module.</p> <p>Contains custom models</p>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel","title":"<code>columnitemmodel</code>","text":""},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItem","title":"<code> ColumnItem        </code>  <code>dataclass</code>","text":"<p>Determines how an object attribute is shown.</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>@dataclass(frozen=True)\nclass ColumnItem:\n\"\"\"Determines how an object attribute is shown.\"\"\"\n\n    name: str\n    label: Callable[[treeitem.TreeItem], str] | None\n    checkstate: Callable[\n        [treeitem.TreeItem], constants.StateStr | QtCore.Qt.CheckState | bool\n    ] | None = None\n    sort_value: Callable[[treeitem.TreeItem], str | float] | None = None\n    tooltip: Callable[[treeitem.TreeItem], str] | None = None\n    doc: str = \"&lt;no help available&gt;\"\n    col_visible: bool = True\n    width: int | str = SMALL_COL_WIDTH\n    alignment: Callable | int | constants.AlignmentStr | None = None\n    line_wrap: gui.textoption.WordWrapModeStr = \"none\"\n    foreground_color: Callable | str | None = None\n    background_color: Callable | str | None = None\n    decoration: Callable | QtGui.QIcon | None = None\n    font: Callable | QtGui.QFont | None = None\n    selectable: bool = True\n    enabled: bool = True\n    editable: bool = False\n    checkable: bool = False\n    tristate: bool = False\n    set_edit: Callable | None = None\n    set_checkstate: Callable | None = None\n    user_data: dict | Callable | None = None\n\n    def get_name(self) -&gt; str:\n        return self.name\n\n    def get_flag(self, tree_item):\n        flag = constants.NO_FLAGS\n        if self.selectable:\n            flag |= constants.IS_SELECTABLE  # type: ignore\n        if self.enabled:\n            flag |= constants.IS_ENABLED  # type: ignore\n        if self.editable:\n            flag |= constants.IS_EDITABLE  # type: ignore\n        if self.checkable:\n            flag |= constants.IS_CHECKABLE  # type: ignore\n        if self.tristate:\n            flag |= constants.IS_USER_TRISTATE  # type: ignore\n        return flag\n\n    def get_label(self, tree_item) -&gt; str:\n        if self.label is None:\n            return \"\"\n        elif callable(self.label):\n            return self.label(tree_item)\n        return self.label\n\n    def get_sort_value(self, tree_item) -&gt; str | int:\n        if self.sort_value is None:\n            return self.get_label()\n        elif callable(self.sort_value):\n            return self.sort_value(tree_item)\n        return self.sort_value\n\n    def get_user_data(self, tree_item, role):\n        if self.user_data is None:\n            return \"\"\n        elif callable(self.user_data):\n            return self.user_data(tree_item, role)\n        return self.user_data[role](tree_item)\n\n    def get_tooltip(self, tree_item) -&gt; str:\n        if self.tooltip is None:\n            return \"\"\n        elif callable(self.tooltip):\n            return self.tooltip(tree_item)\n        return self.tooltip\n\n    def get_checkstate(self, tree_item) -&gt; bool | QtCore.Qt.CheckState | None:\n        if self.checkstate is None:\n            return None\n        elif callable(self.checkstate):\n            result = self.checkstate(tree_item)\n            if isinstance(result, str):\n                result = constants.STATE[result]\n            return result\n        return self.checkstate\n\n    def set_checkstate_value(\n        self, tree_item, value: bool | QtCore.Qt.CheckState | constants.StateStr | None\n    ):\n        if self.set_checkstate is None:\n            return None\n        if isinstance(value, str):\n            value = constants.STATE[value]\n        if callable(self.set_checkstate):\n            self.set_checkstate(tree_item, value)\n        else:\n            raise ValueError(self.set_checkstate)\n\n    def set_edit_value(self, tree_item, value: str):\n        if self.set_edit is None:\n            return None\n        if callable(self.set_edit):\n            self.set_edit(tree_item, value)\n        else:\n            raise ValueError(self.set_edit)\n\n    def get_font(self, tree_item) -&gt; QtGui.QFont | None:\n        if self.font is None:\n            return None\n        elif callable(self.font):\n            return self.font(tree_item)\n        return self.font\n\n    def get_foreground_color(self, tree_item) -&gt; QtGui.QColor | None:\n        if self.foreground_color is None:\n            return None\n        elif callable(self.foreground_color):\n            return self.foreground_color(tree_item)\n        return self.foreground_color\n\n    def get_background_color(self, tree_item) -&gt; QtGui.QColor | None:\n        if self.background_color is None:\n            return None\n        elif callable(self.background_color):\n            return self.background_color(tree_item)\n        return self.background_color\n\n    def get_decoration(\n        self, tree_item\n    ) -&gt; QtGui.QColor | QtGui.QPixmap | QtGui.QIcon | None:\n        if self.decoration is None:\n            return None\n        elif callable(self.decoration):\n            return self.decoration(tree_item)\n        return self.decoration\n\n    def get_alignment(self, tree_item) -&gt; int:\n        if self.alignment is None:\n            return constants.ALIGN_LEFT  # type: ignore\n        elif callable(self.alignment):\n            return self.alignment(tree_item)\n        elif isinstance(self.alignment, str):\n            return constants.ALIGNMENTS[self.alignment]\n        return self.alignment\n\n    def get_width(self) -&gt; int:\n        match self.width:\n            case \"small\":\n                return SMALL_COL_WIDTH\n            case \"medium\":\n                return MEDIUM_COL_WIDTH\n            case int():\n                return self.width\n            case _:\n                raise ValueError(self.width)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel","title":"<code> ColumnItemModel            (ColumnItemModelMixin, AbstractItemModel)         </code>","text":"Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>class ColumnItemModel(ColumnItemModelMixin, core.AbstractItemModel):\n    def __init__(self, *args, **kwargs):\n        self._root_item = core.ModelIndex()\n        super().__init__(*args, **kwargs)\n\n    def root_index(self) -&gt; core.ModelIndex:  # TODO: needed?\n\"\"\"Return the index that returns the root element (same as an invalid index).\"\"\"\n        return core.ModelIndex()\n\n    @property\n    def root_item(self) -&gt; treeitem.TreeItem:\n\"\"\"Return the root ObjectBrowserTreeItem.\"\"\"\n        return self._root_item\n\n    def tree_item(self, index: core.ModelIndex) -&gt; treeitem.TreeItem:\n        return index.internalPointer() if index.isValid() else self.root_item\n\n    def index(\n        self, row: int, column: int, parent: core.ModelIndex | None = None\n    ) -&gt; core.ModelIndex:\n        if parent is None:\n            logger.debug(\"parent is None\")\n            parent = core.ModelIndex()\n\n        parent_item = self.tree_item(parent)\n\n        if not self.hasIndex(row, column, parent):\n            return core.ModelIndex()\n\n        if child_item := parent_item.child(row):\n            return self.createIndex(row, column, child_item)\n        return core.ModelIndex()\n\n    def parent(self, index: core.ModelIndex) -&gt; QtCore.QModelIndex:  # type:ignore\n        if not index.isValid():\n            return core.ModelIndex()\n\n        child_item = index.internalPointer()\n        parent_item = child_item.parent()  # type: ignore\n\n        if parent_item is None or parent_item == self.root_item:\n            return core.ModelIndex()\n\n        return self.createIndex(parent_item.row(), 0, parent_item)\n\n    def rowCount(self, parent: core.ModelIndex | None = None):\n        parent = core.ModelIndex() if parent is None else parent\n        return 0 if parent.column() &gt; 0 else self.tree_item(parent).child_count()\n\n    def hasChildren(self, parent: core.ModelIndex | None = None):\n        parent = core.ModelIndex() if parent is None else parent\n        return 0 if parent.column() &gt; 0 else self.tree_item(parent).has_children\n\n    def canFetchMore(self, parent: core.ModelIndex | None = None):\n        parent = core.ModelIndex() if parent is None else parent\n        if parent.column() &gt; 0:\n            return 0\n        else:\n            return not self.tree_item(parent).children_fetched\n\n    def fetchMore(self, parent: core.ModelIndex | None = None):\n\"\"\"Fetch the children given the model index of a parent node.\n\n        Adds the children to the parent.\n        \"\"\"\n        parent = core.ModelIndex() if parent is None else parent\n        if parent.column() &gt; 0:\n            return\n\n        parent_item = self.tree_item(parent)\n        if parent_item.children_fetched:\n            return\n\n        tree_items = self._fetch_object_children(parent_item)\n\n        with self.insert_rows(0, len(tree_items) - 1, parent):\n            for tree_item in tree_items:\n                parent_item.append_child(tree_item)\n            parent_item.children_fetched = True\n\n    def _fetch_object_children(self, treeitem):\n        return []\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.root_item","title":"<code>root_item: treeitem.TreeItem</code>  <code>property</code> <code>readonly</code>","text":"<p>Return the root ObjectBrowserTreeItem.</p>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.__init__","title":"<code>__init__(self, *args, **kwargs)</code>  <code>special</code>","text":"<p>init(self, parent: Optional[PySide6.QtCore.QObject] = None) -&gt; None</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    self._root_item = core.ModelIndex()\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.canFetchMore","title":"<code>canFetchMore(self, parent: core.ModelIndex | None = None)</code>","text":"<p>canFetchMore(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; bool</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>def canFetchMore(self, parent: core.ModelIndex | None = None):\n    parent = core.ModelIndex() if parent is None else parent\n    if parent.column() &gt; 0:\n        return 0\n    else:\n        return not self.tree_item(parent).children_fetched\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.fetchMore","title":"<code>fetchMore(self, parent: core.ModelIndex | None = None)</code>","text":"<p>Fetch the children given the model index of a parent node.</p> <p>Adds the children to the parent.</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>def fetchMore(self, parent: core.ModelIndex | None = None):\n\"\"\"Fetch the children given the model index of a parent node.\n\n    Adds the children to the parent.\n    \"\"\"\n    parent = core.ModelIndex() if parent is None else parent\n    if parent.column() &gt; 0:\n        return\n\n    parent_item = self.tree_item(parent)\n    if parent_item.children_fetched:\n        return\n\n    tree_items = self._fetch_object_children(parent_item)\n\n    with self.insert_rows(0, len(tree_items) - 1, parent):\n        for tree_item in tree_items:\n            parent_item.append_child(tree_item)\n        parent_item.children_fetched = True\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.hasChildren","title":"<code>hasChildren(self, parent: core.ModelIndex | None = None)</code>","text":"<p>hasChildren(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -&gt; bool</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>def hasChildren(self, parent: core.ModelIndex | None = None):\n    parent = core.ModelIndex() if parent is None else parent\n    return 0 if parent.column() &gt; 0 else self.tree_item(parent).has_children\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.index","title":"<code>index(self, row: int, column: int, parent: core.ModelIndex | None = None) -&gt; core.ModelIndex</code>","text":"<p>index(self, row: int, column: int, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -&gt; PySide6.QtCore.QModelIndex</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>def index(\n    self, row: int, column: int, parent: core.ModelIndex | None = None\n) -&gt; core.ModelIndex:\n    if parent is None:\n        logger.debug(\"parent is None\")\n        parent = core.ModelIndex()\n\n    parent_item = self.tree_item(parent)\n\n    if not self.hasIndex(row, column, parent):\n        return core.ModelIndex()\n\n    if child_item := parent_item.child(row):\n        return self.createIndex(row, column, child_item)\n    return core.ModelIndex()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.parent","title":"<code>parent(self, index: core.ModelIndex) -&gt; QtCore.QModelIndex</code>","text":"<p>parent(self) -&gt; PySide6.QtCore.QObject parent(self, child: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; PySide6.QtCore.QModelIndex</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>def parent(self, index: core.ModelIndex) -&gt; QtCore.QModelIndex:  # type:ignore\n    if not index.isValid():\n        return core.ModelIndex()\n\n    child_item = index.internalPointer()\n    parent_item = child_item.parent()  # type: ignore\n\n    if parent_item is None or parent_item == self.root_item:\n        return core.ModelIndex()\n\n    return self.createIndex(parent_item.row(), 0, parent_item)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.root_index","title":"<code>root_index(self) -&gt; core.ModelIndex</code>","text":"<p>Return the index that returns the root element (same as an invalid index).</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>def root_index(self) -&gt; core.ModelIndex:  # TODO: needed?\n\"\"\"Return the index that returns the root element (same as an invalid index).\"\"\"\n    return core.ModelIndex()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.rowCount","title":"<code>rowCount(self, parent: core.ModelIndex | None = None)</code>","text":"<p>rowCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -&gt; int</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>def rowCount(self, parent: core.ModelIndex | None = None):\n    parent = core.ModelIndex() if parent is None else parent\n    return 0 if parent.column() &gt; 0 else self.tree_item(parent).child_count()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModelMixin","title":"<code> ColumnItemModelMixin        </code>","text":"Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>class ColumnItemModelMixin:\n    def __init__(\n        self,\n        attr_cols: list[ColumnItem] | None = None,\n        parent: QtCore.QObject | None = None,\n    ):\n        super().__init__(parent)\n        self._attr_cols = attr_cols or []\n\n    def columnCount(self, _parent=None):\n        return len(self._attr_cols)\n\n    def data(self, index, role):\n\"\"\"Return the tree item at the given index and role.\"\"\"\n        if not index.isValid():\n            return None\n\n        col = index.column()\n        tree_item = self.tree_item(index)\n\n        match role:\n            case constants.DISPLAY_ROLE | constants.EDIT_ROLE:\n                val = self._attr_cols[col].get_label(tree_item)\n                return val.replace(\"\\n\", \" \")\n            case constants.DECORATION_ROLE:\n                return self._attr_cols[col].get_decoration(tree_item)\n            case constants.CHECKSTATE_ROLE:\n                return self._attr_cols[col].get_checkstate(tree_item)\n            case constants.ALIGNMENT_ROLE:\n                return self._attr_cols[col].get_alignment(tree_item)\n            case constants.FOREGROUND_ROLE:\n                return self._attr_cols[col].get_foreground_color(tree_item)\n            case constants.BACKGROUND_ROLE:\n                return self._attr_cols[col].get_background_color(tree_item)\n            case constants.FONT_ROLE:\n                return self._attr_cols[col].get_font(tree_item)\n            case constants.SORT_ROLE:\n                return self._attr_cols[col].get_sort_value(tree_item)\n            case constants.TOOLTIP_ROLE:\n                return self._attr_cols[col].get_tooltip(tree_item)\n            case _:\n                if int(role) &gt;= int(constants.USER_ROLE):\n                    return self._attr_cols[col].get_user_data(tree_item, role)\n\n    def setData(self, index, value, role):\n        if not index.isValid():\n            return False\n        col = index.column()\n        tree_item = self.tree_item(index)\n        match role:\n            case constants.EDIT_ROLE:\n                self._attr_cols[col].set_edit_value(tree_item, value)\n                self.dataChanged.emit(index, index)\n                return True\n            case constants.CHECKSTATE_ROLE:\n                self._attr_cols[col].set_checkstate_value(tree_item, value)\n                self.dataChanged.emit(index, index)\n                return True\n\n    def flags(self, index):\n        if not index.isValid():\n            return constants.NO_CHILDREN\n        col = index.column()\n        tree_item = self.tree_item(index)\n        return self._attr_cols[col].get_flag(tree_item)\n\n    def headerData(self, section, orientation, role):\n        match orientation, role:\n            case constants.HORIZONTAL, constants.DISPLAY_ROLE:\n                return self._attr_cols[section].name\n            case _, _:\n                return None\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModelMixin.data","title":"<code>data(self, index, role)</code>","text":"<p>Return the tree item at the given index and role.</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>def data(self, index, role):\n\"\"\"Return the tree item at the given index and role.\"\"\"\n    if not index.isValid():\n        return None\n\n    col = index.column()\n    tree_item = self.tree_item(index)\n\n    match role:\n        case constants.DISPLAY_ROLE | constants.EDIT_ROLE:\n            val = self._attr_cols[col].get_label(tree_item)\n            return val.replace(\"\\n\", \" \")\n        case constants.DECORATION_ROLE:\n            return self._attr_cols[col].get_decoration(tree_item)\n        case constants.CHECKSTATE_ROLE:\n            return self._attr_cols[col].get_checkstate(tree_item)\n        case constants.ALIGNMENT_ROLE:\n            return self._attr_cols[col].get_alignment(tree_item)\n        case constants.FOREGROUND_ROLE:\n            return self._attr_cols[col].get_foreground_color(tree_item)\n        case constants.BACKGROUND_ROLE:\n            return self._attr_cols[col].get_background_color(tree_item)\n        case constants.FONT_ROLE:\n            return self._attr_cols[col].get_font(tree_item)\n        case constants.SORT_ROLE:\n            return self._attr_cols[col].get_sort_value(tree_item)\n        case constants.TOOLTIP_ROLE:\n            return self._attr_cols[col].get_tooltip(tree_item)\n        case _:\n            if int(role) &gt;= int(constants.USER_ROLE):\n                return self._attr_cols[col].get_user_data(tree_item, role)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnTableModel","title":"<code> ColumnTableModel            (ColumnItemModelMixin, AbstractTableModel)         </code>","text":"Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>class ColumnTableModel(ColumnItemModelMixin, core.AbstractTableModel):\n    def __init__(\n        self,\n        items: list,\n        columns: list[ColumnItem],\n        parent: QtCore.QObject | None = None,\n    ):\n        super().__init__(columns, parent)\n        self.items = items\n\n    def rowCount(self, parent=None):\n        return 0 if parent is None else len(self.items)\n\n    def tree_item(self, index: core.ModelIndex):\n        return self.items[index.row()]\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnTableModel.__init__","title":"<code>__init__(self, items: list, columns: list[ColumnItem], parent: QtCore.QObject | None = None)</code>  <code>special</code>","text":"<p>init(self, parent: Optional[PySide6.QtCore.QObject] = None) -&gt; None</p> <p>Initialize self.  See help(type(self)) for accurate signature.</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>def __init__(\n    self,\n    items: list,\n    columns: list[ColumnItem],\n    parent: QtCore.QObject | None = None,\n):\n    super().__init__(columns, parent)\n    self.items = items\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnTableModel.rowCount","title":"<code>rowCount(self, parent = None)</code>","text":"<p>rowCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -&gt; int</p> Source code in <code>prettyqt/custom_models/columnitemmodel.py</code> <pre><code>def rowCount(self, parent=None):\n    return 0 if parent is None else len(self.items)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel","title":"<code>importlibdistributionmodel</code>","text":""},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel","title":"<code> ImportlibDistributionModel            (AbstractTableModel)         </code>","text":"Source code in <code>prettyqt/custom_models/importlibdistributionmodel.py</code> <pre><code>class ImportlibDistributionModel(core.AbstractTableModel):\n    HEADER = [\"Name\", \"Version\", \"Summary\", \"Homepage\", \"Author\", \"License\"]\n\n    def __init__(\n        self,\n        distributions: Sequence[metadata.Distribution],\n        parent: QtCore.QObject | None = None,\n    ):\n        super().__init__(parent)\n        self.distributions = distributions\n\n    def rowCount(self, parent=core.ModelIndex()):\n        return 0 if parent.isValid() else len(self.distributions)\n\n    def columnCount(self, parent=core.ModelIndex()):\n        return 0 if parent.isValid() else len(self.HEADER)\n\n    def headerData(self, offset: int, orientation, role):  # type: ignore\n        match orientation, role:\n            case constants.HORIZONTAL, constants.DISPLAY_ROLE:\n                return self.HEADER[offset]\n\n    def data(self, index, role=constants.DISPLAY_ROLE):\n        if not index.isValid():\n            return None\n        dist = self.distributions[index.row()]\n        match role, index.column():\n            case constants.DISPLAY_ROLE, 0:\n                return dist.metadata[\"Name\"]\n            case constants.DISPLAY_ROLE, 1:\n                return dist.version\n            case constants.DISPLAY_ROLE, 2:\n                return dist.metadata[\"Summary\"]\n            case constants.DISPLAY_ROLE, 3:\n                return dist.metadata[\"Home-Page\"]\n            case constants.DISPLAY_ROLE, 4:\n                return dist.metadata[\"Author\"]\n            case constants.DISPLAY_ROLE, 5:\n                return dist.metadata[\"License\"]\n            case constants.USER_ROLE, _:\n                return dist\n\n    @classmethod\n    def from_system(\n        cls, parent: QtCore.QObject | None = None\n    ) -&gt; ImportlibDistributionModel:\n        distributions = list_system_modules()\n        return cls(distributions, parent)\n\n    @classmethod\n    def from_package(\n        cls, package_name: str, parent: QtCore.QObject | None = None\n    ) -&gt; ImportlibDistributionModel:\n        distributions = list_package_requirements(package_name)\n        return cls(distributions, parent)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.columnCount","title":"<code>columnCount(self, parent = &lt;PySide6.QtCore.QModelIndex(-1,-1,0x0,QObject(0x0)) at 0x7f2940f06c00&gt;)</code>","text":"<p>columnCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -&gt; int</p> Source code in <code>prettyqt/custom_models/importlibdistributionmodel.py</code> <pre><code>def columnCount(self, parent=core.ModelIndex()):\n    return 0 if parent.isValid() else len(self.HEADER)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.data","title":"<code>data(self, index, role = &lt;ItemDataRole.DisplayRole: 0&gt;)</code>","text":"<p>data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -&gt; Any</p> Source code in <code>prettyqt/custom_models/importlibdistributionmodel.py</code> <pre><code>def data(self, index, role=constants.DISPLAY_ROLE):\n    if not index.isValid():\n        return None\n    dist = self.distributions[index.row()]\n    match role, index.column():\n        case constants.DISPLAY_ROLE, 0:\n            return dist.metadata[\"Name\"]\n        case constants.DISPLAY_ROLE, 1:\n            return dist.version\n        case constants.DISPLAY_ROLE, 2:\n            return dist.metadata[\"Summary\"]\n        case constants.DISPLAY_ROLE, 3:\n            return dist.metadata[\"Home-Page\"]\n        case constants.DISPLAY_ROLE, 4:\n            return dist.metadata[\"Author\"]\n        case constants.DISPLAY_ROLE, 5:\n            return dist.metadata[\"License\"]\n        case constants.USER_ROLE, _:\n            return dist\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.headerData","title":"<code>headerData(self, offset: int, orientation, role)</code>","text":"<p>headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -&gt; Any</p> Source code in <code>prettyqt/custom_models/importlibdistributionmodel.py</code> <pre><code>def headerData(self, offset: int, orientation, role):  # type: ignore\n    match orientation, role:\n        case constants.HORIZONTAL, constants.DISPLAY_ROLE:\n            return self.HEADER[offset]\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.rowCount","title":"<code>rowCount(self, parent = &lt;PySide6.QtCore.QModelIndex(-1,-1,0x0,QObject(0x0)) at 0x7f2940f06f00&gt;)</code>","text":"<p>rowCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -&gt; int</p> Source code in <code>prettyqt/custom_models/importlibdistributionmodel.py</code> <pre><code>def rowCount(self, parent=core.ModelIndex()):\n    return 0 if parent.isValid() else len(self.distributions)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.jsonmodel","title":"<code>jsonmodel</code>","text":""},{"location":"api/custom_models.html#prettyqt.custom_models.jsonmodel.JsonModel","title":"<code> JsonModel            (NestedModel)         </code>","text":"Source code in <code>prettyqt/custom_models/jsonmodel.py</code> <pre><code>class JsonModel(custom_models.NestedModel):\n    HEADER = [\"Key\", \"Value\", \"Type\"]\n\n    def __init__(self, parent: QtCore.QObject | None = None):\n        super().__init__(parent=parent)\n        self.root = JsonTreeItem()  # type: ignore\n        self.items = self.root.children\n\n    def __repr__(self):\n        return str(self.root.as_json())  # type: ignore\n\n    def load(self, document):\n\"\"\"Load from dictionary.\n\n        Arguments:\n            document (dict): JSON-compatible dictionary\n\n        \"\"\"\n        assert isinstance(\n            document, (dict, list, tuple)\n        ), \"`document` must be of dict, list or tuple, \" \"not %s\" % type(document)\n\n        with self.reset_model():\n            self.root = JsonTreeItem.load(document)\n            self.root.type = type(document)  # type: ignore\n            self.items = self.root.children\n        return True\n\n    def data(self, index, role):\n        if not index.isValid():\n            return None\n\n        item = index.internalPointer()\n        match role, index.column():\n            case constants.DISPLAY_ROLE | constants.EDIT_ROLE, 0:\n                return repr(item.key)\n            case constants.DISPLAY_ROLE, 1:\n                return \"\" if item.type in (dict, list, tuple) else repr(item.value)\n            case constants.EDIT_ROLE, 1:\n                return \"\" if item.type in (dict, list, tuple) else item.value\n            case constants.DISPLAY_ROLE | constants.EDIT_ROLE, 2:\n                return item.type.__name__\n\n    def setData(self, index, value, role):\n        if role == constants.EDIT_ROLE:\n            if index.column() == 1:\n                item = index.internalPointer()\n                item.value = str(value)\n                self.update_row(index.row())\n                return True\n        return False\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.jsonmodel.JsonModel.data","title":"<code>data(self, index, role)</code>","text":"<p>data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -&gt; Any</p> Source code in <code>prettyqt/custom_models/jsonmodel.py</code> <pre><code>def data(self, index, role):\n    if not index.isValid():\n        return None\n\n    item = index.internalPointer()\n    match role, index.column():\n        case constants.DISPLAY_ROLE | constants.EDIT_ROLE, 0:\n            return repr(item.key)\n        case constants.DISPLAY_ROLE, 1:\n            return \"\" if item.type in (dict, list, tuple) else repr(item.value)\n        case constants.EDIT_ROLE, 1:\n            return \"\" if item.type in (dict, list, tuple) else item.value\n        case constants.DISPLAY_ROLE | constants.EDIT_ROLE, 2:\n            return item.type.__name__\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.jsonmodel.JsonModel.load","title":"<code>load(self, document)</code>","text":"<p>Load from dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>dict</code> <p>JSON-compatible dictionary</p> required Source code in <code>prettyqt/custom_models/jsonmodel.py</code> <pre><code>def load(self, document):\n\"\"\"Load from dictionary.\n\n    Arguments:\n        document (dict): JSON-compatible dictionary\n\n    \"\"\"\n    assert isinstance(\n        document, (dict, list, tuple)\n    ), \"`document` must be of dict, list or tuple, \" \"not %s\" % type(document)\n\n    with self.reset_model():\n        self.root = JsonTreeItem.load(document)\n        self.root.type = type(document)  # type: ignore\n        self.items = self.root.children\n    return True\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.jsonmodel.JsonModel.setData","title":"<code>setData(self, index, value, role)</code>","text":"<p>setData(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], value: Any, role: int = Instance(Qt.EditRole)) -&gt; bool</p> Source code in <code>prettyqt/custom_models/jsonmodel.py</code> <pre><code>def setData(self, index, value, role):\n    if role == constants.EDIT_ROLE:\n        if index.column() == 1:\n            item = index.internalPointer()\n            item.value = str(value)\n            self.update_row(index.row())\n            return True\n    return False\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin","title":"<code>listmixin</code>","text":""},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin","title":"<code> ListMixin        </code>","text":"Source code in <code>prettyqt/custom_models/listmixin.py</code> <pre><code>class ListMixin:\n    remove_rows: Callable\n    SORT_METHODS: dict[int, Callable]\n    change_layout: Callable\n    insert_rows: Callable\n    removeRow: Callable\n    # setData: Callable\n    update_row: Callable\n    MIME_TYPE: str\n    DATA_ROLE = constants.USER_ROLE\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)  # type: ignore\n        self.items = []\n\n    def setData(self, index, value, role):\n        if role == self.DATA_ROLE:\n            self.items[index.row()] = value\n            self.update_row(index.row())\n            return True\n        return super().setData(index, value, role)  # type: ignore\n\n    def removeRows(self, row: int, count: int, parent):\n        end_row = row + count - 1\n        with self.remove_rows(row, end_row, parent):\n            for i in range(end_row, row - 1, -1):\n                self.items.pop(i)\n        return True\n\n    def rowCount(self, parent=None):\n\"\"\"Required override for AbstractitemModels.\"\"\"\n        return len(self.items)\n\n    def data_by_index(self, index):\n        return self.items[index.row()]\n\n    def dropMimeData(self, mime_data, action, row, column, parent_index):\n        if not mime_data.hasFormat(self.MIME_TYPE):\n            return False\n        # Since we only drop in between items, parent_index must be invalid,\n        # and we use the row arg to know where the drop took place.\n        if parent_index.isValid():\n            return False\n        indexes = mime_data.get_json_data(self.MIME_TYPE)\n        pos = row if row &lt; len(self.items) and row != -1 else len(self.items)\n        rem_offset = sum(i &lt;= pos for i in indexes)\n        new = [self.items[i] for i in indexes]\n        with self.change_layout():\n            for i in sorted(indexes, reverse=True):\n                self.items.pop(i)\n            for item in reversed(new):\n                self.items.insert(pos - rem_offset, item)\n        return False\n\n    def sort(self, ncol: int, order):\n\"\"\"Sort table by given column number.\"\"\"\n        is_asc = order == constants.ASCENDING\n        if sorter := self.SORT_METHODS.get(ncol):\n            with self.change_layout():\n                self.items.sort(key=sorter, reverse=is_asc)\n\n    def add(self, item: Any, position: int | None = None):\n\"\"\"Append provided item to the list.\"\"\"\n        self.add_items(items=[item], position=position)\n        return item\n\n    def add_items(self, items: Iterable[Any], position: int | None = None):\n\"\"\"Append a list of items to the list.\"\"\"\n        if position is None:\n            position = len(self.items)\n        items = list(items)\n        with self.insert_rows(position, position + len(items) - 1):\n            for i in range(len(items)):\n                self.items.insert(i + position, items[i])\n            # self.items.extend(items)\n        return items\n\n    def remove_items(self, offsets: Iterable[int]):\n        for offset in sorted(offsets, reverse=True):\n            self.removeRow(offset)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.add","title":"<code>add(self, item: Any, position: int | None = None)</code>","text":"<p>Append provided item to the list.</p> Source code in <code>prettyqt/custom_models/listmixin.py</code> <pre><code>def add(self, item: Any, position: int | None = None):\n\"\"\"Append provided item to the list.\"\"\"\n    self.add_items(items=[item], position=position)\n    return item\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.add_items","title":"<code>add_items(self, items: Iterable, position: int | None = None)</code>","text":"<p>Append a list of items to the list.</p> Source code in <code>prettyqt/custom_models/listmixin.py</code> <pre><code>def add_items(self, items: Iterable[Any], position: int | None = None):\n\"\"\"Append a list of items to the list.\"\"\"\n    if position is None:\n        position = len(self.items)\n    items = list(items)\n    with self.insert_rows(position, position + len(items) - 1):\n        for i in range(len(items)):\n            self.items.insert(i + position, items[i])\n        # self.items.extend(items)\n    return items\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.rowCount","title":"<code>rowCount(self, parent = None)</code>","text":"<p>Required override for AbstractitemModels.</p> Source code in <code>prettyqt/custom_models/listmixin.py</code> <pre><code>def rowCount(self, parent=None):\n\"\"\"Required override for AbstractitemModels.\"\"\"\n    return len(self.items)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.listmixin.ListMixin.sort","title":"<code>sort(self, ncol: int, order)</code>","text":"<p>Sort table by given column number.</p> Source code in <code>prettyqt/custom_models/listmixin.py</code> <pre><code>def sort(self, ncol: int, order):\n\"\"\"Sort table by given column number.\"\"\"\n    is_asc = order == constants.ASCENDING\n    if sorter := self.SORT_METHODS.get(ncol):\n        with self.change_layout():\n            self.items.sort(key=sorter, reverse=is_asc)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.modelmixin","title":"<code>modelmixin</code>","text":""},{"location":"api/custom_models.html#prettyqt.custom_models.modelmixin.ModelMixin","title":"<code> ModelMixin        </code>","text":"Source code in <code>prettyqt/custom_models/modelmixin.py</code> <pre><code>class ModelMixin:\n    DATA_ROLE = constants.USER_ROLE\n    DTYPE_ROLE = constants.USER_ROLE + 1  # type: ignore\n    NAME_ROLE = constants.USER_ROLE + 2  # type: ignore\n    SORT_ROLE = constants.USER_ROLE + 3  # type: ignore\n    MAX_ROWS = 1_000_000\n    HEADER = [\"Name\"]\n    DEFAULT_FLAGS = (\n        constants.DRAG_ENABLED  # type: ignore\n        | constants.IS_ENABLED\n        | constants.IS_SELECTABLE\n        | constants.NO_CHILDREN\n    )\n    LABELS: dict = {}\n    CHECKSTATE: dict = {}\n    TOOLTIPS: dict = {}\n    DECORATIONS: dict = {}\n    SET_DATA: dict = {}\n    content_type = \"\"\n    data_by_index: Callable\n    update_row: Callable\n\n    def headerData(self, offset: int, orientation, role):\n        match orientation, role:\n            case constants.HORIZONTAL, constants.DISPLAY_ROLE:\n                return self.HEADER[offset]\n\n    def columnCount(self, parent=None):\n        return len(self.HEADER)\n\n    def flags(self, index):\n\"\"\"Override for AbstractitemModel base method.\n\n        returns corresponding flags for cell of supplied index\n        \"\"\"\n        if not index.isValid():\n            return constants.DROP_ENABLED\n        if index.column() in self.SET_DATA:\n            return self.DEFAULT_FLAGS | constants.IS_EDITABLE\n        return self.DEFAULT_FLAGS\n\n    def data(self, index, role=constants.DISPLAY_ROLE):\n        if not index.isValid():\n            return None\n        item = self.data_by_index(index)\n        match role:\n            case constants.DECORATION_ROLE:\n                if fn := self.DECORATIONS.get(index.column()):\n                    return fn(item)\n            case constants.DISPLAY_ROLE | constants.EDIT_ROLE:\n                if fn := self.LABELS.get(index.column()):\n                    return fn(item)\n            case constants.TOOLTIP_ROLE:\n                if fn := self.TOOLTIPS.get(index.column()):\n                    return fn(item)\n            case constants.CHECKSTATE_ROLE:\n                if fn := self.CHECKSTATE.get(index.column()):\n                    return fn(item)\n            case self.DATA_ROLE:\n                return item\n            case _:\n                return None\n\n    def setData(self, index, value, role):\n        if role == constants.EDIT_ROLE:\n            if not value:\n                return False\n            item = self.data_by_index(index)\n            if fn := self.SET_DATA.get(index.column()):\n                fn(item, value)\n                self.update_row(index.row())\n                return True\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.modelmixin.ModelMixin.flags","title":"<code>flags(self, index)</code>","text":"<p>Override for AbstractitemModel base method.</p> <p>returns corresponding flags for cell of supplied index</p> Source code in <code>prettyqt/custom_models/modelmixin.py</code> <pre><code>def flags(self, index):\n\"\"\"Override for AbstractitemModel base method.\n\n    returns corresponding flags for cell of supplied index\n    \"\"\"\n    if not index.isValid():\n        return constants.DROP_ENABLED\n    if index.column() in self.SET_DATA:\n        return self.DEFAULT_FLAGS | constants.IS_EDITABLE\n    return self.DEFAULT_FLAGS\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem","title":"<code>nesteditem</code>","text":""},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem.NestedItem","title":"<code> NestedItem        </code>","text":"Source code in <code>prettyqt/custom_models/nesteditem.py</code> <pre><code>class NestedItem:\n    item_name = \"not_defined\"\n\n    def __init__(\n        self,\n        parent: NestedItem | None = None,\n        dynamic_name: str | None = None,\n        count: int | None = None,\n        children: list[NestedItem] | None = None,\n    ):\n        self.parent = parent\n        self.dynamic_name = dynamic_name or self.item_name\n        self.count = count\n        # self.timestamp = kwargs.pop(\"timestamp\", time.time())\n        self.children: list[NestedItem] = []\n        if children:\n            self.add_children(children)\n\n    def __iter__(self) -&gt; Iterator[NestedItem]:\n        return iter(self.children)\n\n    def add_children(self, children: Iterable[NestedItem]):\n        for child in children:\n            child.parent = self\n        self.children.extend(children)\n\n    def append_child(self, item: NestedItem):\n        self.children.append(item)\n\n    def child(self, row: int) -&gt; NestedItem:\n        return self.children[row]\n\n    def row(self) -&gt; int:\n\"\"\"Return row number.\n\n        returns row position of item inside parent\u00b4s children\n        returns 0 if no parent available\n\n        Returns:\n            row number\n        \"\"\"\n        return self.parent.children.index(self) if self.parent else 0\n\n    def iter_tree(\n        self,\n        name: str | None = None,\n        yield_self: bool = True,\n        recursive: bool = True,\n        level: int = 0,\n        count: int = 0,\n        assign_names: bool = True,\n    ):\n\"\"\"Yield children from bottom to top, yield self at end.\n\n        assigns dynamic vars count, level and dynamic name\n        \"\"\"\n        if name is None:\n            name = self.item_name\n        for i, c in enumerate(self.children, start=1):\n            count += 1\n            level += 1\n            with_suffix = f\"{name}_{i}\" if len(self.children) &gt; 1 else name\n            if recursive:\n                yield from c.iter_tree(\n                    with_suffix, yield_self=False, level=level, count=count\n                )\n            if assign_names:\n                c.dynamic_name, c.count = with_suffix, count\n            yield c\n            level -= 1\n        if yield_self:\n            if assign_names:\n                self.dynamic_name, self.count = name, 0\n            yield self\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem.NestedItem.iter_tree","title":"<code>iter_tree(self, name: str | None = None, yield_self: bool = True, recursive: bool = True, level: int = 0, count: int = 0, assign_names: bool = True)</code>","text":"<p>Yield children from bottom to top, yield self at end.</p> <p>assigns dynamic vars count, level and dynamic name</p> Source code in <code>prettyqt/custom_models/nesteditem.py</code> <pre><code>def iter_tree(\n    self,\n    name: str | None = None,\n    yield_self: bool = True,\n    recursive: bool = True,\n    level: int = 0,\n    count: int = 0,\n    assign_names: bool = True,\n):\n\"\"\"Yield children from bottom to top, yield self at end.\n\n    assigns dynamic vars count, level and dynamic name\n    \"\"\"\n    if name is None:\n        name = self.item_name\n    for i, c in enumerate(self.children, start=1):\n        count += 1\n        level += 1\n        with_suffix = f\"{name}_{i}\" if len(self.children) &gt; 1 else name\n        if recursive:\n            yield from c.iter_tree(\n                with_suffix, yield_self=False, level=level, count=count\n            )\n        if assign_names:\n            c.dynamic_name, c.count = with_suffix, count\n        yield c\n        level -= 1\n    if yield_self:\n        if assign_names:\n            self.dynamic_name, self.count = name, 0\n        yield self\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nesteditem.NestedItem.row","title":"<code>row(self) -&gt; int</code>","text":"<p>Return row number.</p> <p>returns row position of item inside parent\u00b4s children returns 0 if no parent available</p> <p>Returns:</p> Type Description <code>int</code> <p>row number</p> Source code in <code>prettyqt/custom_models/nesteditem.py</code> <pre><code>def row(self) -&gt; int:\n\"\"\"Return row number.\n\n    returns row position of item inside parent\u00b4s children\n    returns 0 if no parent available\n\n    Returns:\n        row number\n    \"\"\"\n    return self.parent.children.index(self) if self.parent else 0\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel","title":"<code>nestedmodel</code>","text":""},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel","title":"<code> NestedModel            (ListMixin, ModelMixin, AbstractItemModel)         </code>","text":"Source code in <code>prettyqt/custom_models/nestedmodel.py</code> <pre><code>class NestedModel(  # type: ignore\n    custom_models.ListMixin, custom_models.ModelMixin, core.AbstractItemModel\n):\n    DEFAULT_FLAGS = (\n        constants.DRAG_ENABLED  # type: ignore\n        | constants.IS_ENABLED\n        | constants.IS_SELECTABLE\n    )\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.root = Root()\n        self.items = self.root.children\n\n    def flags(self, index):\n        if not index.isValid():\n            return constants.NO_FLAGS\n        if index.column() in self.SET_DATA:\n            return self.DEFAULT_FLAGS | constants.IS_EDITABLE\n        return self.DEFAULT_FLAGS\n\n    def rowCount(self, parent=core.ModelIndex()) -&gt; int:\n        if parent.column() &gt; 0:\n            return 0\n        if not parent.isValid():\n            return len(self.items)\n        return len(parent.internalPointer().children)\n\n    def index(self, row, column, parent):\n        if not self.hasIndex(row, column, parent):\n            return core.ModelIndex()\n\n        parent_item = parent.internalPointer()\n        if not parent_item:\n            parent_item = self.root\n\n        return self.createIndex(row, column, parent_item.children[row])\n\n    def parent(self, index):\n        if not index.isValid():\n            return core.ModelIndex()\n\n        item = index.internalPointer()\n        if not item:\n            return core.ModelIndex()\n\n        if item.parent in [self.root, None]:\n            return core.ModelIndex()\n\n        return self.createIndex(item.parent.row(), 0, item.parent)\n\n    def data_by_index(self, index):\n        return index.internalPointer()\n\n    def json(self, root=None) -&gt; dict:\n\"\"\"Serialise model as JSON-compliant dictionary.\n\n        Arguments:\n            root (JsonTreeItem, optional): Serialise from here\n                defaults to the the top-level item\n\n        Returns:\n            model as dict\n        \"\"\"\n        root = root if root else self.root\n        return root.as_json()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.flags","title":"<code>flags(self, index)</code>","text":"<p>Override for AbstractitemModel base method.</p> <p>returns corresponding flags for cell of supplied index</p> Source code in <code>prettyqt/custom_models/nestedmodel.py</code> <pre><code>def flags(self, index):\n    if not index.isValid():\n        return constants.NO_FLAGS\n    if index.column() in self.SET_DATA:\n        return self.DEFAULT_FLAGS | constants.IS_EDITABLE\n    return self.DEFAULT_FLAGS\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.index","title":"<code>index(self, row, column, parent)</code>","text":"<p>index(self, row: int, column: int, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -&gt; PySide6.QtCore.QModelIndex</p> Source code in <code>prettyqt/custom_models/nestedmodel.py</code> <pre><code>def index(self, row, column, parent):\n    if not self.hasIndex(row, column, parent):\n        return core.ModelIndex()\n\n    parent_item = parent.internalPointer()\n    if not parent_item:\n        parent_item = self.root\n\n    return self.createIndex(row, column, parent_item.children[row])\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.json","title":"<code>json(self, root = None) -&gt; dict</code>","text":"<p>Serialise model as JSON-compliant dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>JsonTreeItem</code> <p>Serialise from here defaults to the the top-level item</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>model as dict</p> Source code in <code>prettyqt/custom_models/nestedmodel.py</code> <pre><code>def json(self, root=None) -&gt; dict:\n\"\"\"Serialise model as JSON-compliant dictionary.\n\n    Arguments:\n        root (JsonTreeItem, optional): Serialise from here\n            defaults to the the top-level item\n\n    Returns:\n        model as dict\n    \"\"\"\n    root = root if root else self.root\n    return root.as_json()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.parent","title":"<code>parent(self, index)</code>","text":"<p>parent(self) -&gt; PySide6.QtCore.QObject parent(self, child: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; PySide6.QtCore.QModelIndex</p> Source code in <code>prettyqt/custom_models/nestedmodel.py</code> <pre><code>def parent(self, index):\n    if not index.isValid():\n        return core.ModelIndex()\n\n    item = index.internalPointer()\n    if not item:\n        return core.ModelIndex()\n\n    if item.parent in [self.root, None]:\n        return core.ModelIndex()\n\n    return self.createIndex(item.parent.row(), 0, item.parent)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.nestedmodel.NestedModel.rowCount","title":"<code>rowCount(self, parent = &lt;PySide6.QtCore.QModelIndex(-1,-1,0x0,QObject(0x0)) at 0x7f2940fa37c0&gt;) -&gt; int</code>","text":"<p>Required override for AbstractitemModels.</p> Source code in <code>prettyqt/custom_models/nestedmodel.py</code> <pre><code>def rowCount(self, parent=core.ModelIndex()) -&gt; int:\n    if parent.column() &gt; 0:\n        return 0\n    if not parent.isValid():\n        return len(self.items)\n    return len(parent.internalPointer().children)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel","title":"<code>regexmatchesmodel</code>","text":""},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel","title":"<code> RegexMatchesModel            (AbstractTableModel)         </code>","text":"Source code in <code>prettyqt/custom_models/regexmatchesmodel.py</code> <pre><code>class RegexMatchesModel(core.AbstractTableModel):\n    HEADER = [\"Start\", \"End\", \"Value\", \"Groups\"]\n\n    def __init__(self, matches: list | None = None, parent: QtCore.QObject | None = None):\n        super().__init__(parent=parent)\n        self.matches = matches or []\n\n    def columnCount(self, parent=None):\n        return len(self.HEADER)\n\n    def headerData(  # type: ignore\n        self, section: int, orientation: QtCore.Qt.Orientation, role: int\n    ) -&gt; str | None:\n        match orientation, role:\n            case constants.HORIZONTAL, constants.DISPLAY_ROLE:\n                return self.HEADER[section]\n\n    def data(self, index, role):\n        if not index.isValid():\n            return None\n        item = self.matches[index.row()]\n        match role, index.column():\n            case constants.DISPLAY_ROLE, 0:\n                return str(item.span()[0])\n            case constants.DISPLAY_ROLE, 1:\n                return str(item.span()[1])\n            case constants.DISPLAY_ROLE, 2:\n                return repr(item.group())\n            case constants.DISPLAY_ROLE, 3:\n                return str(len(item.groups()))\n            case constants.USER_ROLE, _:\n                return item.span()\n\n    def rowCount(self, parent=None):\n\"\"\"Override for AbstractitemModel base method.\"\"\"\n        return len(self.matches)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.columnCount","title":"<code>columnCount(self, parent = None)</code>","text":"<p>columnCount(self, parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex] = Invalid(PySide6.QtCore.QModelIndex)) -&gt; int</p> Source code in <code>prettyqt/custom_models/regexmatchesmodel.py</code> <pre><code>def columnCount(self, parent=None):\n    return len(self.HEADER)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.data","title":"<code>data(self, index, role)</code>","text":"<p>data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -&gt; Any</p> Source code in <code>prettyqt/custom_models/regexmatchesmodel.py</code> <pre><code>def data(self, index, role):\n    if not index.isValid():\n        return None\n    item = self.matches[index.row()]\n    match role, index.column():\n        case constants.DISPLAY_ROLE, 0:\n            return str(item.span()[0])\n        case constants.DISPLAY_ROLE, 1:\n            return str(item.span()[1])\n        case constants.DISPLAY_ROLE, 2:\n            return repr(item.group())\n        case constants.DISPLAY_ROLE, 3:\n            return str(len(item.groups()))\n        case constants.USER_ROLE, _:\n            return item.span()\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.headerData","title":"<code>headerData(self, section: int, orientation: QtCore.Qt.Orientation, role: int) -&gt; str | None</code>","text":"<p>headerData(self, section: int, orientation: PySide6.QtCore.Qt.Orientation, role: int = Instance(Qt.DisplayRole)) -&gt; Any</p> Source code in <code>prettyqt/custom_models/regexmatchesmodel.py</code> <pre><code>def headerData(  # type: ignore\n    self, section: int, orientation: QtCore.Qt.Orientation, role: int\n) -&gt; str | None:\n    match orientation, role:\n        case constants.HORIZONTAL, constants.DISPLAY_ROLE:\n            return self.HEADER[section]\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.rowCount","title":"<code>rowCount(self, parent = None)</code>","text":"<p>Override for AbstractitemModel base method.</p> Source code in <code>prettyqt/custom_models/regexmatchesmodel.py</code> <pre><code>def rowCount(self, parent=None):\n\"\"\"Override for AbstractitemModel base method.\"\"\"\n    return len(self.matches)\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.subsequencesortfilterproxymodel","title":"<code>subsequencesortfilterproxymodel</code>","text":""},{"location":"api/custom_models.html#prettyqt.custom_models.subsequencesortfilterproxymodel.SubsequenceSortFilterProxyModel","title":"<code> SubsequenceSortFilterProxyModel            (SortFilterProxyModel)         </code>","text":"Source code in <code>prettyqt/custom_models/subsequencesortfilterproxymodel.py</code> <pre><code>class SubsequenceSortFilterProxyModel(core.SortFilterProxyModel):\n\"\"\"Performs subsequence matching/sorting.\"\"\"\n\n    def __init__(self, case_sensitivity: bool, parent=None):\n        super().__init__(parent)\n        self.case_sensitivity = case_sensitivity\n\n    def set_prefix(self, prefix: str):\n        self.filter_patterns = []\n        self.filter_patterns_case_sensitive = []\n        self.sort_patterns = []\n        flags = re.IGNORECASE if self.case_sensitivity is False else 0\n        for i in reversed(range(1, len(prefix) + 1)):\n            ptrn = f\".*{prefix[0:i]}.*{prefix[i:]}\"\n            try:\n                self.filter_patterns.append(re.compile(ptrn, flags))\n                self.filter_patterns_case_sensitive.append(re.compile(ptrn, 0))\n                ptrn = f\"{prefix[0:i]}.*{prefix[i:]}\"\n                self.sort_patterns.append(re.compile(ptrn, flags))\n            except Exception:\n                continue\n        self.prefix = prefix\n\n    def filterAcceptsRow(self, row, _):\n        completion = self.sourceModel().data(self.sourceModel().index(row, 0))\n        if completion is None or self.prefix is None:\n            return False\n        if len(completion) &lt; len(self.prefix):\n            return False\n        if len(self.prefix) == 1:\n            try:\n                prefix = self.prefix\n                if self.case_sensitivity is False:\n                    completion = completion.lower()\n                    prefix = self.prefix.lower()\n                rank = completion.index(prefix)\n                idx = self.sourceModel().index(row, 0)\n                self.sourceModel().setData(idx, rank, USER_ROLE)  # type: ignore\n                return prefix in completion\n            except ValueError:\n                return False\n        for i, patterns in enumerate(\n            zip(\n                self.filter_patterns,\n                self.filter_patterns_case_sensitive,\n                self.sort_patterns,\n            )\n        ):\n            pattern, pattern_case, sort_pattern = patterns\n            match = re.match(pattern, completion)\n            if match:\n                # compute rank, the lowest rank the closer it is from the\n                # completion\n                start = MAX_SIZE\n                for m in sort_pattern.finditer(completion):\n                    start, end = m.span()\n                rank = start + i * 10\n                if re.match(pattern_case, completion):\n                    # favorise completions where case is matched\n                    rank -= 10\n                self.sourceModel().setData(idx, rank, USER_ROLE)  # type: ignore\n                return True\n        return len(self.prefix) == 0\n</code></pre>"},{"location":"api/custom_models.html#prettyqt.custom_models.subsequencesortfilterproxymodel.SubsequenceSortFilterProxyModel.filterAcceptsRow","title":"<code>filterAcceptsRow(self, row, _)</code>","text":"<p>filterAcceptsRow(self, source_row: int, source_parent: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; bool</p> Source code in <code>prettyqt/custom_models/subsequencesortfilterproxymodel.py</code> <pre><code>def filterAcceptsRow(self, row, _):\n    completion = self.sourceModel().data(self.sourceModel().index(row, 0))\n    if completion is None or self.prefix is None:\n        return False\n    if len(completion) &lt; len(self.prefix):\n        return False\n    if len(self.prefix) == 1:\n        try:\n            prefix = self.prefix\n            if self.case_sensitivity is False:\n                completion = completion.lower()\n                prefix = self.prefix.lower()\n            rank = completion.index(prefix)\n            idx = self.sourceModel().index(row, 0)\n            self.sourceModel().setData(idx, rank, USER_ROLE)  # type: ignore\n            return prefix in completion\n        except ValueError:\n            return False\n    for i, patterns in enumerate(\n        zip(\n            self.filter_patterns,\n            self.filter_patterns_case_sensitive,\n            self.sort_patterns,\n        )\n    ):\n        pattern, pattern_case, sort_pattern = patterns\n        match = re.match(pattern, completion)\n        if match:\n            # compute rank, the lowest rank the closer it is from the\n            # completion\n            start = MAX_SIZE\n            for m in sort_pattern.finditer(completion):\n                start, end = m.span()\n            rank = start + i * 10\n            if re.match(pattern_case, completion):\n                # favorise completions where case is matched\n                rank -= 10\n            self.sourceModel().setData(idx, rank, USER_ROLE)  # type: ignore\n            return True\n    return len(self.prefix) == 0\n</code></pre>"},{"location":"api/custom_validators.html","title":"custom_validators module","text":"<p>Custom_validators module.</p> <p>Contains custom validators</p>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator","title":"<code>compositevalidator</code>","text":""},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator","title":"<code> CompositeValidator            (Validator)         </code>","text":"Source code in <code>prettyqt/custom_validators/compositevalidator.py</code> <pre><code>class CompositeValidator(gui.Validator):\n    def __init__(\n        self,\n        validators: list[gui.Validator] | None = None,\n        parent: QtCore.QObject | None = None,\n    ):\n        super().__init__(parent)\n        self.validators = validators if validators is not None else []\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.validators})\"\n\n    def __getitem__(self, index: int) -&gt; gui.Validator:\n        return self.validators[index]\n\n    def __setitem__(self, index: int, value: gui.Validator):\n        self.validators[index] = value\n\n    def __delitem__(self, index: int):\n        del self.validators[index]\n\n    def __contains__(self, index: int):\n        return index in self.validators\n\n    def __iter__(self) -&gt; Iterator[gui.Validator]:\n        return iter(self.validators)\n\n    def __reduce__(self):\n        return type(self), (self.validators,)\n\n    def __len__(self):\n        return len(self.validators)\n\n    def __eq__(self, other: object):\n        if not isinstance(other, type(self)):\n            return False\n        return self.validators == other.validators\n\n    def validate(  # type: ignore\n        self, text: str, pos: int = 0\n    ) -&gt; tuple[QtGui.QValidator.State, str, int]:\n        vals = [v.validate(text, pos)[0] for v in self.validators]  # type: ignore\n        if self.State.Invalid in vals:\n            return self.State.Invalid, text, pos\n        elif self.State.Intermediate in vals:\n            return self.State.Intermediate, text, pos\n        else:\n            return self.State.Acceptable, text, pos\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator.validate","title":"<code>validate(self, text: str, pos: int = 0) -&gt; tuple[QtGui.QValidator.State, str, int]</code>","text":"<p>validate(self, arg__1: str, arg__2: int) -&gt; object</p> Source code in <code>prettyqt/custom_validators/compositevalidator.py</code> <pre><code>def validate(  # type: ignore\n    self, text: str, pos: int = 0\n) -&gt; tuple[QtGui.QValidator.State, str, int]:\n    vals = [v.validate(text, pos)[0] for v in self.validators]  # type: ignore\n    if self.State.Invalid in vals:\n        return self.State.Invalid, text, pos\n    elif self.State.Intermediate in vals:\n        return self.State.Intermediate, text, pos\n    else:\n        return self.State.Acceptable, text, pos\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.integervalidator","title":"<code>integervalidator</code>","text":""},{"location":"api/custom_validators.html#prettyqt.custom_validators.integervalidator.IntegerValidator","title":"<code> IntegerValidator            (Validator)         </code>","text":"Source code in <code>prettyqt/custom_validators/integervalidator.py</code> <pre><code>class IntegerValidator(gui.Validator):\n    def __init__(self, parent: QtCore.QObject | None = None):\n        super().__init__(parent)\n        self.range: tuple[int | None, int | None] = (None, None)\n\n    def set_range(self, lower: int | None, upper: int | None):\n        self.range = (lower, upper)\n\n    def validate(self, text: str, pos: int):\n        if not text.lstrip(\"-\"):\n            return self.State.Intermediate, text, len(text)\n        if text.lstrip(\"-\").isnumeric():\n            left = float(\"-inf\") if self.range[0] is None else self.range[0]\n            right = float(\"inf\") if self.range[1] is None else self.range[1]\n            if left &lt;= int(text) &lt;= right:\n                return self.State.Acceptable, text, len(text)\n        return self.State.Invalid, text, len(text)\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.integervalidator.IntegerValidator.validate","title":"<code>validate(self, text: str, pos: int)</code>","text":"<p>validate(self, arg__1: str, arg__2: int) -&gt; object</p> Source code in <code>prettyqt/custom_validators/integervalidator.py</code> <pre><code>def validate(self, text: str, pos: int):\n    if not text.lstrip(\"-\"):\n        return self.State.Intermediate, text, len(text)\n    if text.lstrip(\"-\").isnumeric():\n        left = float(\"-inf\") if self.range[0] is None else self.range[0]\n        right = float(\"inf\") if self.range[1] is None else self.range[1]\n        if left &lt;= int(text) &lt;= right:\n            return self.State.Acceptable, text, len(text)\n    return self.State.Invalid, text, len(text)\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator","title":"<code>notemptyvalidator</code>","text":""},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator","title":"<code> NotEmptyValidator            (Validator)         </code>","text":"Source code in <code>prettyqt/custom_validators/notemptyvalidator.py</code> <pre><code>class NotEmptyValidator(gui.Validator):\n    def __eq__(self, other: object):\n        return isinstance(other, NotEmptyValidator)\n\n    def validate(  # type: ignore\n        self, text: str, pos: int = 0\n    ) -&gt; tuple[QtGui.QValidator.State, str, int]:\n        if text == \"\":\n            return (self.State.Intermediate, text, pos)\n        return self.State.Acceptable, text, pos\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator.validate","title":"<code>validate(self, text: str, pos: int = 0) -&gt; tuple[QtGui.QValidator.State, str, int]</code>","text":"<p>validate(self, arg__1: str, arg__2: int) -&gt; object</p> Source code in <code>prettyqt/custom_validators/notemptyvalidator.py</code> <pre><code>def validate(  # type: ignore\n    self, text: str, pos: int = 0\n) -&gt; tuple[QtGui.QValidator.State, str, int]:\n    if text == \"\":\n        return (self.State.Intermediate, text, pos)\n    return self.State.Acceptable, text, pos\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator","title":"<code>notzerovalidator</code>","text":""},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator","title":"<code> NotZeroValidator            (Validator)         </code>","text":"Source code in <code>prettyqt/custom_validators/notzerovalidator.py</code> <pre><code>class NotZeroValidator(gui.Validator):\n    def validate(  # type: ignore\n        self, text: str, pos: int = 0\n    ) -&gt; tuple[QtGui.QValidator.State, str, int]:\n        if text == \"0\":\n            return self.State.Intermediate, text, pos\n        return self.State.Acceptable, text, pos\n\n    def __eq__(self, other: object):\n        return isinstance(other, NotZeroValidator)\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator.validate","title":"<code>validate(self, text: str, pos: int = 0) -&gt; tuple[QtGui.QValidator.State, str, int]</code>","text":"<p>validate(self, arg__1: str, arg__2: int) -&gt; object</p> Source code in <code>prettyqt/custom_validators/notzerovalidator.py</code> <pre><code>def validate(  # type: ignore\n    self, text: str, pos: int = 0\n) -&gt; tuple[QtGui.QValidator.State, str, int]:\n    if text == \"0\":\n        return self.State.Intermediate, text, pos\n    return self.State.Acceptable, text, pos\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator","title":"<code>pathvalidator</code>","text":""},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator","title":"<code> PathValidator            (Validator)         </code>","text":"Source code in <code>prettyqt/custom_validators/pathvalidator.py</code> <pre><code>class PathValidator(gui.Validator):\n    def __eq__(self, other: object):\n        return isinstance(other, PathValidator)\n\n    def validate(self, text: str, pos: int = 0):\n        if pathlib.Path(text).exists():\n            return self.State.Acceptable, text, pos\n        return self.State.Intermediate, text, pos\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator.validate","title":"<code>validate(self, text: str, pos: int = 0)</code>","text":"<p>validate(self, arg__1: str, arg__2: int) -&gt; object</p> Source code in <code>prettyqt/custom_validators/pathvalidator.py</code> <pre><code>def validate(self, text: str, pos: int = 0):\n    if pathlib.Path(text).exists():\n        return self.State.Acceptable, text, pos\n    return self.State.Intermediate, text, pos\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator","title":"<code>regexpatternvalidator</code>","text":""},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator","title":"<code> RegexPatternValidator            (Validator)         </code>","text":"Source code in <code>prettyqt/custom_validators/regexpatternvalidator.py</code> <pre><code>class RegexPatternValidator(gui.Validator):\n    error_occured = core.Signal(str)\n    pattern_updated = core.Signal(object)\n\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    def __eq__(self, other: object):\n        return isinstance(other, type(self))\n\n    def validate(  # type: ignore\n        self, text: str, pos: int = 0\n    ) -&gt; tuple[QtGui.QValidator.State, str, int]:\n        # if text == \"\":\n        #     self.compiled = None\n        #     return (self.Intermediate, text, pos)\n        try:\n            compiled = re.compile(text)\n        except sre_constants.error as e:\n            self.error_occured.emit(str(e))\n            self.pattern_updated.emit(None)\n            return self.State.Intermediate, text, pos\n        except re._regex_core.error as e:\n            self.error_occured.emit(str(e))\n            self.pattern_updated.emit(None)\n            return self.State.Intermediate, text, pos\n        else:\n            self.error_occured.emit(\"\")\n            self.pattern_updated.emit(compiled)\n            return self.State.Acceptable, text, pos\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator.validate","title":"<code>validate(self, text: str, pos: int = 0) -&gt; tuple[QtGui.QValidator.State, str, int]</code>","text":"<p>validate(self, arg__1: str, arg__2: int) -&gt; object</p> Source code in <code>prettyqt/custom_validators/regexpatternvalidator.py</code> <pre><code>def validate(  # type: ignore\n    self, text: str, pos: int = 0\n) -&gt; tuple[QtGui.QValidator.State, str, int]:\n    # if text == \"\":\n    #     self.compiled = None\n    #     return (self.Intermediate, text, pos)\n    try:\n        compiled = re.compile(text)\n    except sre_constants.error as e:\n        self.error_occured.emit(str(e))\n        self.pattern_updated.emit(None)\n        return self.State.Intermediate, text, pos\n    except re._regex_core.error as e:\n        self.error_occured.emit(str(e))\n        self.pattern_updated.emit(None)\n        return self.State.Intermediate, text, pos\n    else:\n        self.error_occured.emit(\"\")\n        self.pattern_updated.emit(compiled)\n        return self.State.Acceptable, text, pos\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators","title":"<code>regexvalidators</code>","text":""},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator","title":"<code> BaseRegexValidator            (Validator)         </code>","text":"Source code in <code>prettyqt/custom_validators/regexvalidators.py</code> <pre><code>class BaseRegexValidator(gui.Validator):\n    def __init__(\n        self, parent: QtCore.QObject | None = None, regex: PatternType | None = None\n    ):\n        super().__init__(parent)\n        self.regex: Pattern | None = None\n        if regex:\n            self.set_regex(regex)\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.get_regex()!r})\"\n\n    def __reduce__(self):\n        return type(self), (self.get_regex(),)\n\n    def __eq__(self, other: object):\n        if not isinstance(other, type(self)):\n            return False\n        return self.regex == other.regex\n\n    def set_regex(self, regex: PatternType):\n        if isinstance(regex, str):\n            self.regex = re.compile(regex)\n        else:\n            self.regex = regex\n\n    def get_regex(self) -&gt; str:\n        if self.regex is None:\n            raise TypeError(\"Validator not initialized\")\n        return self.regex.pattern\n\n    def validate(  # type: ignore\n        self, text: str, pos: int = 0\n    ) -&gt; tuple[QtGui.QValidator.State, str, int]:\n        if self.regex is None:\n            raise TypeError(\"Validator not initialized\")\n        if text == \"\":\n            return self.State.Intermediate, text, pos\n        match = self.regex.match(text, partial=True)  # type: ignore\n        if match is None:\n            return self.State.Invalid, text, pos\n        elif match.partial:  # type: ignore\n            return self.State.Intermediate, text, pos\n        else:\n            return self.State.Acceptable, text, pos\n</code></pre>"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator.validate","title":"<code>validate(self, text: str, pos: int = 0) -&gt; tuple[QtGui.QValidator.State, str, int]</code>","text":"<p>validate(self, arg__1: str, arg__2: int) -&gt; object</p> Source code in <code>prettyqt/custom_validators/regexvalidators.py</code> <pre><code>def validate(  # type: ignore\n    self, text: str, pos: int = 0\n) -&gt; tuple[QtGui.QValidator.State, str, int]:\n    if self.regex is None:\n        raise TypeError(\"Validator not initialized\")\n    if text == \"\":\n        return self.State.Intermediate, text, pos\n    match = self.regex.match(text, partial=True)  # type: ignore\n    if match is None:\n        return self.State.Invalid, text, pos\n    elif match.partial:  # type: ignore\n        return self.State.Intermediate, text, pos\n    else:\n        return self.State.Acceptable, text, pos\n</code></pre>"},{"location":"api/custom_widgets.html","title":"custom_widgets module","text":"<p>Module containing custom widget classes.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout","title":"<code>borderlayout</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout","title":"<code> BorderLayout            (Layout)         </code>","text":"Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>class BorderLayout(widgets.Layout):\n    class Position(enum.IntEnum):\n\"\"\"Item position.\"\"\"\n\n        West = 0\n        North = 1\n        South = 2\n        East = 3\n        Center = 4\n\n    core.Enum(Position)\n\n    def __init__(\n        self,\n        parent: QtWidgets.QWidget | None = None,\n        margin: int = 0,\n        spacing: int | None = None,\n    ):\n        super().__init__(parent)  # type: ignore\n        self.set_margin(margin)\n        self.setSpacing(spacing if spacing is not None else -1)\n        self.items: list[ItemWrapper] = []\n\n    def __del__(self):\n        item = self.takeAt(0)\n        while item:\n            item = self.takeAt(0)\n\n    def addItem(self, item: QtWidgets.QWidgetItem):\n        self.add_widgetitem(item, BorderLayout.Position.West)\n\n    def addWidget(\n        self,\n        widget: QtWidgets.QWidget,\n        position: Position = Position.West,\n    ):\n        self.add_widgetitem(widgets.WidgetItem(widget), position)\n\n    def expandingDirections(self):\n        return constants.HORIZONTAL | constants.VERTICAL  # type: ignore\n\n    def hasHeightForWidth(self) -&gt; bool:\n        return False\n\n    def count(self) -&gt; int:\n        return len(self.items)\n\n    def itemAt(self, index: int) -&gt; QtWidgets.QWidgetItem | None:  # type: ignore\n        if index &lt; len(self.items):\n            return self.items[index].item\n        return None\n\n    def minimumSize(self):\n        return self.calculate_size(\"minimum\")\n\n    def setGeometry(self, rect: QtCore.QRect):\n        center = None\n        east_width = 0\n        west_width = 0\n        north_height = 0\n        south_height = 0\n\n        super().setGeometry(rect)\n\n        for wrapper in self.items:\n            item = wrapper.item\n            match wrapper.position:\n                case BorderLayout.Position.North:\n                    geom = core.Rect(\n                        rect.x(), north_height, rect.width(), item.sizeHint().height()\n                    )\n                    item.setGeometry(geom)\n\n                    north_height += item.geometry().height() + self.spacing()\n\n                case BorderLayout.Position.South:\n                    geom = core.Rect(\n                        item.geometry().x(),\n                        item.geometry().y(),\n                        rect.width(),\n                        item.sizeHint().height(),\n                    )\n                    item.setGeometry(geom)\n\n                    south_height += item.geometry().height() + self.spacing()\n                    geom = core.Rect(\n                        rect.x(),\n                        rect.y() + rect.height() - south_height + self.spacing(),\n                        item.geometry().width(),\n                        item.geometry().height(),\n                    )\n                    item.setGeometry(geom)\n\n                case BorderLayout.Position.Center:\n                    center = wrapper\n\n        center_height = rect.height() - north_height - south_height\n\n        for wrapper in self.items:\n            item = wrapper.item\n            match wrapper.position:\n                case BorderLayout.Position.West:\n                    geom = core.Rect(\n                        rect.x() + west_width,\n                        north_height,\n                        item.sizeHint().width(),\n                        center_height,\n                    )\n                    item.setGeometry(geom)\n\n                    west_width += item.geometry().width() + self.spacing()\n\n                case BorderLayout.Position.East:\n                    geom = core.Rect(\n                        item.geometry().x(),\n                        item.geometry().y(),\n                        item.sizeHint().width(),\n                        center_height,\n                    )\n                    item.setGeometry(geom)\n\n                    east_width += item.geometry().width() + self.spacing()\n\n                    geom = core.Rect(\n                        rect.x() + rect.width() - east_width + self.spacing(),\n                        north_height,\n                        item.geometry().width(),\n                        item.geometry().height(),\n                    )\n                    item.setGeometry(geom)\n\n        if center:\n            rect = core.Rect(\n                west_width,\n                north_height,\n                rect.width() - east_width - west_width,\n                center_height,\n            )\n            center.item.setGeometry(rect)\n\n    def sizeHint(self) -&gt; core.Size:\n        return self.calculate_size(\"size_hint\")\n\n    def takeAt(self, index: int) -&gt; QtWidgets.QWidgetItem | None:  # type: ignore\n        if 0 &lt;= index &lt; len(self.items):\n            layout_struct = self.items.pop(index)\n            return layout_struct.item\n\n        return None\n\n    def add_widgetitem(self, item: QtWidgets.QWidgetItem, position: Position):\n        self.items.append(ItemWrapper(item, position))\n\n    def calculate_size(self, size_type: Literal[\"minimum\", \"size_hint\"]) -&gt; core.Size:\n        total_size = core.Size()\n\n        for wrapper in self.items:\n            position = wrapper.position\n            if size_type == \"minimum\":\n                item_size = wrapper.item.minimumSize()\n            else:  # size_type == \"size_hint\"\n                item_size = wrapper.item.sizeHint()\n\n            if position in (\n                BorderLayout.Position.North,\n                BorderLayout.Position.South,\n                BorderLayout.Position.Center,\n            ):\n                total_size.setHeight(total_size.height() + item_size.height())\n\n            if position in (\n                BorderLayout.Position.West,\n                BorderLayout.Position.East,\n                BorderLayout.Position.Center,\n            ):\n                total_size.setWidth(total_size.width() + item_size.width())\n\n        return total_size\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.Position","title":"<code> Position            (IntEnum)         </code>","text":"<p>Item position.</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>class Position(enum.IntEnum):\n\"\"\"Item position.\"\"\"\n\n    West = 0\n    North = 1\n    South = 2\n    East = 3\n    Center = 4\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.addItem","title":"<code>addItem(self, item: QtWidgets.QWidgetItem)</code>","text":"<p>addItem(self, arg__1: PySide6.QtWidgets.QLayoutItem) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>def addItem(self, item: QtWidgets.QWidgetItem):\n    self.add_widgetitem(item, BorderLayout.Position.West)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.addWidget","title":"<code>addWidget(self, widget: QtWidgets.QWidget, position: Position = &lt;Position.West: 0&gt;)</code>","text":"<p>addWidget(self, w: PySide6.QtWidgets.QWidget) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>def addWidget(\n    self,\n    widget: QtWidgets.QWidget,\n    position: Position = Position.West,\n):\n    self.add_widgetitem(widgets.WidgetItem(widget), position)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.count","title":"<code>count(self) -&gt; int</code>","text":"<p>count(self) -&gt; int</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>def count(self) -&gt; int:\n    return len(self.items)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.expandingDirections","title":"<code>expandingDirections(self)</code>","text":"<p>expandingDirections(self) -&gt; PySide6.QtCore.Qt.Orientation</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>def expandingDirections(self):\n    return constants.HORIZONTAL | constants.VERTICAL  # type: ignore\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.hasHeightForWidth","title":"<code>hasHeightForWidth(self) -&gt; bool</code>","text":"<p>hasHeightForWidth(self) -&gt; bool</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>def hasHeightForWidth(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.itemAt","title":"<code>itemAt(self, index: int) -&gt; QtWidgets.QWidgetItem | None</code>","text":"<p>itemAt(self, index: int) -&gt; PySide6.QtWidgets.QLayoutItem</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>def itemAt(self, index: int) -&gt; QtWidgets.QWidgetItem | None:  # type: ignore\n    if index &lt; len(self.items):\n        return self.items[index].item\n    return None\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.minimumSize","title":"<code>minimumSize(self)</code>","text":"<p>minimumSize(self) -&gt; PySide6.QtCore.QSize</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>def minimumSize(self):\n    return self.calculate_size(\"minimum\")\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.setGeometry","title":"<code>setGeometry(self, rect: QtCore.QRect)</code>","text":"<p>setGeometry(self, arg__1: PySide6.QtCore.QRect) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>def setGeometry(self, rect: QtCore.QRect):\n    center = None\n    east_width = 0\n    west_width = 0\n    north_height = 0\n    south_height = 0\n\n    super().setGeometry(rect)\n\n    for wrapper in self.items:\n        item = wrapper.item\n        match wrapper.position:\n            case BorderLayout.Position.North:\n                geom = core.Rect(\n                    rect.x(), north_height, rect.width(), item.sizeHint().height()\n                )\n                item.setGeometry(geom)\n\n                north_height += item.geometry().height() + self.spacing()\n\n            case BorderLayout.Position.South:\n                geom = core.Rect(\n                    item.geometry().x(),\n                    item.geometry().y(),\n                    rect.width(),\n                    item.sizeHint().height(),\n                )\n                item.setGeometry(geom)\n\n                south_height += item.geometry().height() + self.spacing()\n                geom = core.Rect(\n                    rect.x(),\n                    rect.y() + rect.height() - south_height + self.spacing(),\n                    item.geometry().width(),\n                    item.geometry().height(),\n                )\n                item.setGeometry(geom)\n\n            case BorderLayout.Position.Center:\n                center = wrapper\n\n    center_height = rect.height() - north_height - south_height\n\n    for wrapper in self.items:\n        item = wrapper.item\n        match wrapper.position:\n            case BorderLayout.Position.West:\n                geom = core.Rect(\n                    rect.x() + west_width,\n                    north_height,\n                    item.sizeHint().width(),\n                    center_height,\n                )\n                item.setGeometry(geom)\n\n                west_width += item.geometry().width() + self.spacing()\n\n            case BorderLayout.Position.East:\n                geom = core.Rect(\n                    item.geometry().x(),\n                    item.geometry().y(),\n                    item.sizeHint().width(),\n                    center_height,\n                )\n                item.setGeometry(geom)\n\n                east_width += item.geometry().width() + self.spacing()\n\n                geom = core.Rect(\n                    rect.x() + rect.width() - east_width + self.spacing(),\n                    north_height,\n                    item.geometry().width(),\n                    item.geometry().height(),\n                )\n                item.setGeometry(geom)\n\n    if center:\n        rect = core.Rect(\n            west_width,\n            north_height,\n            rect.width() - east_width - west_width,\n            center_height,\n        )\n        center.item.setGeometry(rect)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.sizeHint","title":"<code>sizeHint(self) -&gt; core.Size</code>","text":"<p>sizeHint(self) -&gt; PySide6.QtCore.QSize</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>def sizeHint(self) -&gt; core.Size:\n    return self.calculate_size(\"size_hint\")\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.BorderLayout.takeAt","title":"<code>takeAt(self, index: int) -&gt; QtWidgets.QWidgetItem | None</code>","text":"<p>takeAt(self, index: int) -&gt; PySide6.QtWidgets.QLayoutItem</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>def takeAt(self, index: int) -&gt; QtWidgets.QWidgetItem | None:  # type: ignore\n    if 0 &lt;= index &lt; len(self.items):\n        layout_struct = self.items.pop(index)\n        return layout_struct.item\n\n    return None\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.borderlayout.ItemWrapper","title":"<code> ItemWrapper        </code>  <code>dataclass</code>","text":"<p>ItemWrapper(item: 'QtWidgets.QWidgetItem', position: 'BorderLayout.Position')</p> Source code in <code>prettyqt/custom_widgets/borderlayout.py</code> <pre><code>@dataclass\nclass ItemWrapper:\n    item: QtWidgets.QWidgetItem\n    position: BorderLayout.Position\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor","title":"<code>codeeditor</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor","title":"<code> CodeEditor            (PlainTextEdit)         </code>","text":"Source code in <code>prettyqt/custom_widgets/codeeditor.py</code> <pre><code>class CodeEditor(widgets.PlainTextEdit):\n    def __init__(self, language: str = \"python\", parent: QtWidgets.QWidget | None = None):\n        super().__init__(parent=parent)\n        self.line_area = LineNumberArea(self)\n        self.blockCountChanged.connect(self.update_line_area_width)\n        self.updateRequest.connect(self.update_line_area)\n        self.cursorPositionChanged.connect(self.highlight_current_line)\n        self.set_font(\"Consolas\")\n        self.update_line_area_width(0)\n        self.highlight_current_line()\n        self.set_syntaxhighlighter(language)\n\n    def resizeEvent(self, event):\n        super().resizeEvent(event)\n\n        cr = self.contentsRect()\n        rect = core.Rect(cr.left(), cr.top(), self.line_area_width(), cr.height())\n        self.line_area.setGeometry(rect)\n\n    def text(self) -&gt; str:\n        return self.toPlainText()\n\n    def line_area_width(self) -&gt; int:\n        digits = len(str(self.blockCount()))\n        return 3 + self.fontMetrics().boundingRect(\"9\").width() * digits\n\n    def update_line_area_width(self, _):\n        self.setViewportMargins(self.line_area_width(), 0, 0, 0)\n\n    def update_line_area(self, rect: QtCore.QRect, dy: int):\n        if dy:\n            self.line_area.scroll(0, dy)\n        else:\n            self.line_area.update(0, rect.y(), self.line_area.width(), rect.height())\n\n        if rect.contains(self.viewport().rect()):\n            self.update_line_area_width(0)\n\n    def line_area_paintevent(self, event):\n        with gui.Painter(self.line_area) as painter:\n            painter.fill_rect(event.rect(), \"lightgray\")\n\n            block = self.firstVisibleBlock()\n            block_number = block.blockNumber()\n            top = self.blockBoundingGeometry(block).translated(self.contentOffset()).top()\n            bottom = top + self.blockBoundingRect(block).height()\n            width = self.line_area.width()\n            height = self.fontMetrics().height()\n            painter.set_color(\"black\")\n            while block.isValid() and (top &lt;= event.rect().bottom()):\n                if block.isVisible() and (bottom &gt;= event.rect().top()):\n                    number = str(block_number + 1)\n                    painter.drawText(\n                        0, int(top), width, height, constants.ALIGN_RIGHT, number\n                    )\n                block = block.next()\n                top = bottom\n                bottom = top + self.blockBoundingRect(block).height()\n                block_number += 1\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor.resizeEvent","title":"<code>resizeEvent(self, event)</code>","text":"<p>resizeEvent(self, e: PySide6.QtGui.QResizeEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/codeeditor.py</code> <pre><code>def resizeEvent(self, event):\n    super().resizeEvent(event)\n\n    cr = self.contentsRect()\n    rect = core.Rect(cr.left(), cr.top(), self.line_area_width(), cr.height())\n    self.line_area.setGeometry(rect)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea","title":"<code> LineNumberArea            (Widget)         </code>","text":"Source code in <code>prettyqt/custom_widgets/codeeditor.py</code> <pre><code>class LineNumberArea(widgets.Widget):\n    def __init__(self, editor: CodeEditor):\n        super().__init__(editor)\n        self.editor = editor\n\n    def sizeHint(self) -&gt; core.Size:\n        return core.Size(self.editor.line_area_width(), 0)\n\n    def paintEvent(self, event):\n        self.editor.line_area_paintevent(event)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.paintEvent","title":"<code>paintEvent(self, event)</code>","text":"<p>paintEvent(self, event: PySide6.QtGui.QPaintEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/codeeditor.py</code> <pre><code>def paintEvent(self, event):\n    self.editor.line_area_paintevent(event)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.sizeHint","title":"<code>sizeHint(self) -&gt; core.Size</code>","text":"<p>sizeHint(self) -&gt; PySide6.QtCore.QSize</p> Source code in <code>prettyqt/custom_widgets/codeeditor.py</code> <pre><code>def sizeHint(self) -&gt; core.Size:\n    return core.Size(self.editor.line_area_width(), 0)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget","title":"<code>completionwidget</code>","text":"<p>A dropdown completer widget for the text edits.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget","title":"<code> CompletionWidget            (ListWidget)         </code>","text":"Source code in <code>prettyqt/custom_widgets/completionwidget.py</code> <pre><code>class CompletionWidget(widgets.ListWidget):\n    def __init__(self, textedit: QtWidgets.QTextEdit | QtWidgets.QPlainTextEdit):\n        super().__init__(parent=textedit)\n\n        self._text_edit = textedit\n        self.set_edit_triggers(\"none\")\n        self.set_selection_behaviour(\"rows\")\n        self.set_selection_mode(\"single\")\n\n        # We need Popup style to ensure correct mouse interaction\n        # (dialog would dissappear on mouse click with ToolTip style)\n        self.setWindowFlags(QtCore.Qt.WindowType.Popup)  # type: ignore\n\n        self.setAttribute(QtCore.Qt.WidgetAttribute.WA_StaticContents)\n        original_policy = self._text_edit.focusPolicy()\n\n        self.set_focus_policy(\"none\")\n        self._text_edit.setFocusPolicy(original_policy)\n\n        # Ensure that the text edit keeps focus when widget is displayed.\n        self.setFocusProxy(self._text_edit)\n\n        self.set_frame_shadow(\"plain\")\n        self.set_frame_shape(\"styled_panel\")\n\n        self.itemActivated.connect(self._complete_current)\n\n    def eventFilter(self, obj, event):\n\"\"\"Handle mouse input and to auto-hide when losing focus.\"\"\"\n        if obj is self:\n            if event.type() == QtCore.QEvent.Type.MouseButtonPress:\n                pos = self.mapToGlobal(event.pos())\n                target = QtWidgets.QApplication.widgetAt(pos)\n                if target and self.isAncestorOf(target) or target is self:\n                    return False\n                else:\n                    self.cancel_completion()\n\n        return super().eventFilter(obj, event)\n\n    def keyPressEvent(self, event):\n        match event.key():\n            case (\n                QtCore.Qt.Key.Key_Return | QtCore.Qt.Key.Key_Enter | QtCore.Qt.Key.Key_Tab\n            ):\n                self._complete_current()\n            case QtCore.Qt.Key.Key_Escape:\n                self.hide()\n            case (\n                QtCore.Qt.Key.Key_Up\n                | QtCore.Qt.Key.Key_Down\n                | QtCore.Qt.Key.Key_PageUp\n                | QtCore.Qt.Key.Key_PageDown\n                | QtCore.Qt.Key.Key_Home\n                | QtCore.Qt.Key.Key_End\n            ):\n                return super().keyPressEvent(event)\n            case _:\n                QtWidgets.QApplication.sendEvent(self._text_edit, event)\n\n    # 'QWidget' interface\n\n    def hideEvent(self, event):\n\"\"\"Disconnect signal handlers and event filter.\"\"\"\n        super().hideEvent(event)\n        try:\n            self._text_edit.cursorPositionChanged.disconnect(self._update_current)\n        except TypeError:\n            pass\n        self.removeEventFilter(self)\n\n    def showEvent(self, event):\n\"\"\"Connect signal handlers and event filter.\"\"\"\n        super().showEvent(event)\n        self._text_edit.cursorPositionChanged.connect(self._update_current)\n        self.installEventFilter(self)\n\n    # 'CompletionWidget' interface\n\n    def show_items(self, cursor, items: list[str], prefix_length: int = 0):\n\"\"\"Show the widget with 'items' at the position specified by 'cursor'.\"\"\"\n        point = self._get_top_left_position(cursor)\n        self.clear()\n        path_items = []\n        for item in items:\n            # Check if the item could refer to a file or dir. The replacing\n            # of '\"' is needed for items on Windows\n            path = os.path.abspath(item.replace('\"', \"\"))\n            if os.path.isfile(path) or os.path.isdir(path):\n                path_items.append(item.replace('\"', \"\"))\n            else:\n                list_item = widgets.ListWidgetItem()\n                list_item.setData(QtCore.Qt.ItemDataRole.UserRole, item)  # type: ignore\n                # Need to split to only show last element of a dot completion\n                list_item.setText(item.split(\".\")[-1])\n                self.addItem(list_item)\n\n        common_prefix = os.path.dirname(os.path.commonprefix(path_items))\n        for path_item in path_items:\n            list_item = widgets.ListWidgetItem()\n            list_item.setData(QtCore.Qt.ItemDataRole.UserRole, path_item)  # type: ignore\n            text = path_item.split(common_prefix)[-1] if common_prefix else path_item\n            list_item.setText(text)\n            self.addItem(list_item)\n\n        height = self.sizeHint().height()\n        screen_rect = self.get_screen().availableGeometry()\n        if screen_rect.size().height() + screen_rect.y() - point.y() - height &lt; 0:\n            point = self._text_edit.mapToGlobal(self._text_edit.cursorRect().topRight())\n            point.setY(int(point.y() - height))\n        scrollbar_width = self.verticalScrollBar().sizeHint().width()\n        w = self.sizeHintForColumn(0) + scrollbar_width + 2 * self.frameWidth()\n        self.setGeometry(point.x(), point.y(), w, height)\n\n        # Move cursor to start of the prefix to replace it\n        # when a item is selected\n        cursor.movePosition(QtGui.QTextCursor.MoveOperation.Left, n=prefix_length)\n        self._start_position = cursor.position()\n        self.setCurrentRow(0)\n        self.raise_()\n        self.show()\n\n    # Protected interface\n\n    def _get_top_left_position(self, cursor: QtGui.QTextCursor) -&gt; QtCore.QPoint:\n\"\"\"Get top left position for this widget.\"\"\"\n        point = self._text_edit.cursorRect(cursor).center()\n        point_size = self._text_edit.font().pointSize()\n        factor = 1.05 if os.name == \"nt\" else 0.98\n        delta = int((point_size * 1.20) ** factor)\n        y = delta - (point_size // 2)\n        point.setY(int(point.y() + y))\n        point = self._text_edit.mapToGlobal(point)\n        return point\n\n    def _complete_current(self):\n\"\"\"Perform the completion with the currently selected item.\"\"\"\n        text = self.currentItem().data(QtCore.Qt.ItemDataRole.UserRole)  # type: ignore\n        self._current_text_cursor().insertText(text)\n        self.hide()\n\n    def _current_text_cursor(self) -&gt; gui.TextCursor:\n\"\"\"Return a cursor with text between the start  and currentposition selected.\"\"\"\n        cursor = self._text_edit.get_text_cursor()\n        if cursor.position() &gt;= self._start_position:\n            cursor.setPosition(self._start_position, gui.TextCursor.MoveMode.KeepAnchor)\n        return cursor\n\n    def _update_current(self):\n\"\"\"Update the current item based on the current text and the widget position.\"\"\"\n        # Update widget position\n        cursor = self._text_edit.get_text_cursor()\n        point = self._get_top_left_position(cursor)\n        self.move(point)\n\n        # Update current item\n        prefix = self._current_text_cursor().selection().toPlainText()\n        if prefix:\n            flags = (\n                QtCore.Qt.MatchFlag.MatchStartsWith  # type: ignore\n                | QtCore.Qt.MatchFlag.MatchCaseSensitive\n            )\n            items = self.findItems(prefix, flags)\n            if items:\n                self.setCurrentItem(items[0])\n            else:\n                self.hide()\n        else:\n            self.hide()\n\n    def cancel_completion(self):\n        self.hide()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.eventFilter","title":"<code>eventFilter(self, obj, event)</code>","text":"<p>Handle mouse input and to auto-hide when losing focus.</p> Source code in <code>prettyqt/custom_widgets/completionwidget.py</code> <pre><code>def eventFilter(self, obj, event):\n\"\"\"Handle mouse input and to auto-hide when losing focus.\"\"\"\n    if obj is self:\n        if event.type() == QtCore.QEvent.Type.MouseButtonPress:\n            pos = self.mapToGlobal(event.pos())\n            target = QtWidgets.QApplication.widgetAt(pos)\n            if target and self.isAncestorOf(target) or target is self:\n                return False\n            else:\n                self.cancel_completion()\n\n    return super().eventFilter(obj, event)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.hideEvent","title":"<code>hideEvent(self, event)</code>","text":"<p>Disconnect signal handlers and event filter.</p> Source code in <code>prettyqt/custom_widgets/completionwidget.py</code> <pre><code>def hideEvent(self, event):\n\"\"\"Disconnect signal handlers and event filter.\"\"\"\n    super().hideEvent(event)\n    try:\n        self._text_edit.cursorPositionChanged.disconnect(self._update_current)\n    except TypeError:\n        pass\n    self.removeEventFilter(self)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.keyPressEvent","title":"<code>keyPressEvent(self, event)</code>","text":"<p>keyPressEvent(self, event: PySide6.QtGui.QKeyEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/completionwidget.py</code> <pre><code>def keyPressEvent(self, event):\n    match event.key():\n        case (\n            QtCore.Qt.Key.Key_Return | QtCore.Qt.Key.Key_Enter | QtCore.Qt.Key.Key_Tab\n        ):\n            self._complete_current()\n        case QtCore.Qt.Key.Key_Escape:\n            self.hide()\n        case (\n            QtCore.Qt.Key.Key_Up\n            | QtCore.Qt.Key.Key_Down\n            | QtCore.Qt.Key.Key_PageUp\n            | QtCore.Qt.Key.Key_PageDown\n            | QtCore.Qt.Key.Key_Home\n            | QtCore.Qt.Key.Key_End\n        ):\n            return super().keyPressEvent(event)\n        case _:\n            QtWidgets.QApplication.sendEvent(self._text_edit, event)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.showEvent","title":"<code>showEvent(self, event)</code>","text":"<p>Connect signal handlers and event filter.</p> Source code in <code>prettyqt/custom_widgets/completionwidget.py</code> <pre><code>def showEvent(self, event):\n\"\"\"Connect signal handlers and event filter.\"\"\"\n    super().showEvent(event)\n    self._text_edit.cursorPositionChanged.connect(self._update_current)\n    self.installEventFilter(self)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.completionwidget.CompletionWidget.show_items","title":"<code>show_items(self, cursor, items: list[str], prefix_length: int = 0)</code>","text":"<p>Show the widget with 'items' at the position specified by 'cursor'.</p> Source code in <code>prettyqt/custom_widgets/completionwidget.py</code> <pre><code>def show_items(self, cursor, items: list[str], prefix_length: int = 0):\n\"\"\"Show the widget with 'items' at the position specified by 'cursor'.\"\"\"\n    point = self._get_top_left_position(cursor)\n    self.clear()\n    path_items = []\n    for item in items:\n        # Check if the item could refer to a file or dir. The replacing\n        # of '\"' is needed for items on Windows\n        path = os.path.abspath(item.replace('\"', \"\"))\n        if os.path.isfile(path) or os.path.isdir(path):\n            path_items.append(item.replace('\"', \"\"))\n        else:\n            list_item = widgets.ListWidgetItem()\n            list_item.setData(QtCore.Qt.ItemDataRole.UserRole, item)  # type: ignore\n            # Need to split to only show last element of a dot completion\n            list_item.setText(item.split(\".\")[-1])\n            self.addItem(list_item)\n\n    common_prefix = os.path.dirname(os.path.commonprefix(path_items))\n    for path_item in path_items:\n        list_item = widgets.ListWidgetItem()\n        list_item.setData(QtCore.Qt.ItemDataRole.UserRole, path_item)  # type: ignore\n        text = path_item.split(common_prefix)[-1] if common_prefix else path_item\n        list_item.setText(text)\n        self.addItem(list_item)\n\n    height = self.sizeHint().height()\n    screen_rect = self.get_screen().availableGeometry()\n    if screen_rect.size().height() + screen_rect.y() - point.y() - height &lt; 0:\n        point = self._text_edit.mapToGlobal(self._text_edit.cursorRect().topRight())\n        point.setY(int(point.y() - height))\n    scrollbar_width = self.verticalScrollBar().sizeHint().width()\n    w = self.sizeHintForColumn(0) + scrollbar_width + 2 * self.frameWidth()\n    self.setGeometry(point.x(), point.y(), w, height)\n\n    # Move cursor to start of the prefix to replace it\n    # when a item is selected\n    cursor.movePosition(QtGui.QTextCursor.MoveOperation.Left, n=prefix_length)\n    self._start_position = cursor.position()\n    self.setCurrentRow(0)\n    self.raise_()\n    self.show()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset","title":"<code>dataset</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem","title":"<code> DataItem        </code>","text":"Source code in <code>prettyqt/custom_widgets/dataset.py</code> <pre><code>class DataItem:\n    def __init__(\n        self,\n        label: str,\n        value=None,\n        optional: str | None = None,\n        include: bool = True,\n        enabled_on=None,\n        disabled_on=None,\n    ):\n        self.set_value(value)\n        self.enabled_on = [enabled_on] if enabled_on else []\n        self.disabled_on = [disabled_on] if disabled_on else []\n        self.name = None\n        self.label = label\n        self.optional = optional\n        self.include = include\n        self.colspan = 1\n        self.label_col = 0\n        self.is_enabled = True\n\n    def __get__(self, instance, owner):\n        return self.value\n\n    def set_pos(self, col=0, colspan=None):\n\"\"\"Set data item's position on a GUI layout.\"\"\"\n        self.label_col = col\n        self.colspan = colspan\n        return self\n\n    def set_value(self, value):\n        self.value = value\n\n    def store(self, prop):\n        # self.set_prop(\"display\", store=prop)\n        return self\n\n    def is_valid(self):\n        return True\n\n    def create_widget(self):\n        widget = self._create_widget()\n        if self.optional:\n            return custom_widgets.OptionalWidget(widget, self.optional)\n        return widget\n\n    def _create_widget(self):\n        return None\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem.set_pos","title":"<code>set_pos(self, col = 0, colspan = None)</code>","text":"<p>Set data item's position on a GUI layout.</p> Source code in <code>prettyqt/custom_widgets/dataset.py</code> <pre><code>def set_pos(self, col=0, colspan=None):\n\"\"\"Set data item's position on a GUI layout.\"\"\"\n    self.label_col = col\n    self.colspan = colspan\n    return self\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta","title":"<code> DataSetMeta            (type)         </code>","text":"Source code in <code>prettyqt/custom_widgets/dataset.py</code> <pre><code>class DataSetMeta(type):\n    def __new__(mcs, name, bases, dct):\n        filtered = [b for b in bases if getattr(b, \"__metaclass__\", None) is DataSetMeta]\n        items = {item._name: item for b in filtered for item in b._items}\n        # items should contain DataItems of parent classes\n        for attrname, value in list(dct.items()):\n            if isinstance(value, DataItem):\n                value.name = attrname\n                items[attrname] = value\n        dct[\"_items\"] = items\n        return type.__new__(mcs, name, bases, dct)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta.__new__","title":"<code>__new__(mcs, name, bases, dct)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p> Source code in <code>prettyqt/custom_widgets/dataset.py</code> <pre><code>def __new__(mcs, name, bases, dct):\n    filtered = [b for b in bases if getattr(b, \"__metaclass__\", None) is DataSetMeta]\n    items = {item._name: item for b in filtered for item in b._items}\n    # items should contain DataItems of parent classes\n    for attrname, value in list(dct.items()):\n        if isinstance(value, DataItem):\n            value.name = attrname\n            items[attrname] = value\n    dct[\"_items\"] = items\n    return type.__new__(mcs, name, bases, dct)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.elidedlabel","title":"<code>elidedlabel</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.elidedlabel.ElidedLabel","title":"<code> ElidedLabel            (Frame)         </code>","text":"Source code in <code>prettyqt/custom_widgets/elidedlabel.py</code> <pre><code>class ElidedLabel(widgets.Frame):\n    elision_changed = core.Signal(bool)\n\n    def __init__(\n        self,\n        text: str = \"\",\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        super().__init__(parent=parent)\n        self.elided = False\n        self.content = text\n        self.set_size_policy(\"expanding\", \"preferred\")\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.text()!r})\"\n\n    def set_text(self, text: str):\n        self.content = text\n        self.update()\n\n    def paintEvent(self, event):\n        super().paintEvent(event)\n        painter = gui.Painter(self)\n        metrics = painter.get_font_metrics()\n        did_elide = False\n        line_spacing = metrics.lineSpacing()\n        y = 0\n        layout = gui.TextLayout(self.content, painter.font())\n        with layout.process_layout():\n            while True:\n                line = layout.createLine()\n\n                if not line.isValid():\n                    break\n\n                line.setLineWidth(self.width())\n                next_line_y = y + line_spacing\n\n                if self.height() &gt;= next_line_y + line_spacing:\n                    line.draw(painter, core.Point(0, y))\n                    y = next_line_y\n                else:\n                    last_line = self.content[line.textStart() :]\n                    elided_line = metrics.elided_text(last_line, \"right\", self.width())\n                    painter.drawText(0, y + metrics.ascent(), elided_line)\n                    line = layout.createLine()\n                    did_elide = line.isValid()\n                    break\n        if did_elide != self.elided:\n            self.elided = did_elide\n            self.elision_changed.emit(did_elide)\n\n    # def paintEvent(self, event):\n    #     painter = gui.Painter(self)\n    #     metrics = gui.FontMetrics(self.font())\n    #     elided = metrics.elided_text(self.text(), \"right\", self.width())\n    #     painter.drawText(self.rect(), self.alignment(), elided)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.elidedlabel.ElidedLabel.paintEvent","title":"<code>paintEvent(self, event)</code>","text":"<p>paintEvent(self, arg__1: PySide6.QtGui.QPaintEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/elidedlabel.py</code> <pre><code>def paintEvent(self, event):\n    super().paintEvent(event)\n    painter = gui.Painter(self)\n    metrics = painter.get_font_metrics()\n    did_elide = False\n    line_spacing = metrics.lineSpacing()\n    y = 0\n    layout = gui.TextLayout(self.content, painter.font())\n    with layout.process_layout():\n        while True:\n            line = layout.createLine()\n\n            if not line.isValid():\n                break\n\n            line.setLineWidth(self.width())\n            next_line_y = y + line_spacing\n\n            if self.height() &gt;= next_line_y + line_spacing:\n                line.draw(painter, core.Point(0, y))\n                y = next_line_y\n            else:\n                last_line = self.content[line.textStart() :]\n                elided_line = metrics.elided_text(last_line, \"right\", self.width())\n                painter.drawText(0, y + metrics.ascent(), elided_line)\n                line = layout.createLine()\n                did_elide = line.isValid()\n                break\n    if did_elide != self.elided:\n        self.elided = did_elide\n        self.elision_changed.emit(did_elide)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton","title":"<code>filechooserbutton</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton","title":"<code> FileChooserButton            (Widget)         </code>","text":"Source code in <code>prettyqt/custom_widgets/filechooserbutton.py</code> <pre><code>class FileChooserButton(widgets.Widget):\n    value_changed = core.Signal(pathlib.Path)\n\n    def __init__(\n        self,\n        extensions: dict[str, list[str]] | None = None,\n        mode: widgets.filedialog.AcceptModeStr = \"save\",\n        file_mode: widgets.filedialog.FileModeStr = \"existing_files\",\n        root: None | str | pathlib.Path = None,\n        parent: QtWidgets.QWidget | None = None,\n    ):\n\"\"\"Initialize FileChooserButton.\n\n        Args:\n            extensions: dict allowed extensions\n                        form: \"'name': ['.ext1', '.ext2']\"\n            mode: Accept mode (\"save\" or \"load\")\n            file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\",\n                                  or \"directory\")\n            root: Root path\n            parent: parent widget\n        \"\"\"\n        super().__init__(parent)\n        self.path: pathlib.Path | None = None\n        self.extensions = extensions\n        self.mode: widgets.filedialog.AcceptModeStr = mode\n        self.file_mode: widgets.filedialog.FileModeStr = file_mode\n        self.root = root\n        layout = widgets.BoxLayout(\"horizontal\", self)\n        layout.set_margin(0)\n        self.lineedit = widgets.LineEdit()\n        self.lineedit.set_read_only()\n        layout.add(self.lineedit)\n        action = widgets.Action()\n        if self.file_mode == \"directory\":\n            action.set_icon(\"mdi.folder-outline\")\n        else:\n            action.set_icon(\"mdi.file-outline\")\n        action.triggered.connect(self.open_file)\n\n        self.button = widgets.ToolButton()\n        self.button.setDefaultAction(action)\n        layout.add(self.button)\n\n    def serialize_fields(self):\n        return dict(path=self.path, extensions=self.extensions, enabled=self.isEnabled())\n\n    def __setstate__(self, state):\n        self.set_path(state[\"path\"])\n        self.set_enabled(state.get(\"enabled\", True))\n\n    def __reduce__(self):\n        return type(self), (self.extensions,), self.__getstate__()\n\n    @core.Slot()\n    def open_file(self):\n        dialog = widgets.FileDialog(\n            parent=self,\n            path_id=\"file_path\",\n            mode=self.mode,\n            path=self.root,\n            file_mode=self.file_mode,\n        )\n        if self.extensions:\n            dialog.set_extension_filter(self.extensions)\n        if not dialog.choose():\n            return\n        self.set_path(dialog.selected_file())\n        self.value_changed.emit(self.path)\n\n    def set_path(self, path: datatypes.PathType | None):\n        if path is None:\n            self.path = None\n            self.lineedit.set_text(\"\")\n        else:\n            self.path = pathlib.Path(path)\n            self.lineedit.set_text(os.fspath(path))\n\n    def get_value(self) -&gt; pathlib.Path | None:\n        return self.path\n\n    def set_value(self, value: datatypes.PathType | None):\n        self.set_path(value)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton.__init__","title":"<code>__init__(self, extensions: dict[str, list[str]] | None = None, mode: widgets.filedialog.AcceptModeStr = 'save', file_mode: widgets.filedialog.FileModeStr = 'existing_files', root: None | str | pathlib.Path = None, parent: QtWidgets.QWidget | None = None)</code>  <code>special</code>","text":"<p>Initialize FileChooserButton.</p> <p>Parameters:</p> Name Type Description Default <code>extensions</code> <code>dict[str, list[str]] | None</code> <p>dict allowed extensions         form: \"'name': ['.ext1', '.ext2']\"</p> <code>None</code> <code>mode</code> <code>widgets.filedialog.AcceptModeStr</code> <p>Accept mode (\"save\" or \"load\")</p> <code>'save'</code> <code>file_mode</code> <code>widgets.filedialog.FileModeStr</code> <p>File mode (\"existing_files\", \"existing_file\", \"any_file\",                   or \"directory\")</p> <code>'existing_files'</code> <code>root</code> <code>None | str | pathlib.Path</code> <p>Root path</p> <code>None</code> <code>parent</code> <code>QtWidgets.QWidget | None</code> <p>parent widget</p> <code>None</code> Source code in <code>prettyqt/custom_widgets/filechooserbutton.py</code> <pre><code>def __init__(\n    self,\n    extensions: dict[str, list[str]] | None = None,\n    mode: widgets.filedialog.AcceptModeStr = \"save\",\n    file_mode: widgets.filedialog.FileModeStr = \"existing_files\",\n    root: None | str | pathlib.Path = None,\n    parent: QtWidgets.QWidget | None = None,\n):\n\"\"\"Initialize FileChooserButton.\n\n    Args:\n        extensions: dict allowed extensions\n                    form: \"'name': ['.ext1', '.ext2']\"\n        mode: Accept mode (\"save\" or \"load\")\n        file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\",\n                              or \"directory\")\n        root: Root path\n        parent: parent widget\n    \"\"\"\n    super().__init__(parent)\n    self.path: pathlib.Path | None = None\n    self.extensions = extensions\n    self.mode: widgets.filedialog.AcceptModeStr = mode\n    self.file_mode: widgets.filedialog.FileModeStr = file_mode\n    self.root = root\n    layout = widgets.BoxLayout(\"horizontal\", self)\n    layout.set_margin(0)\n    self.lineedit = widgets.LineEdit()\n    self.lineedit.set_read_only()\n    layout.add(self.lineedit)\n    action = widgets.Action()\n    if self.file_mode == \"directory\":\n        action.set_icon(\"mdi.folder-outline\")\n    else:\n        action.set_icon(\"mdi.file-outline\")\n    action.triggered.connect(self.open_file)\n\n    self.button = widgets.ToolButton()\n    self.button.setDefaultAction(action)\n    layout.add(self.button)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout","title":"<code>flowlayout</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout","title":"<code> FlowLayout            (Layout)         </code>","text":"Source code in <code>prettyqt/custom_widgets/flowlayout.py</code> <pre><code>class FlowLayout(widgets.Layout):\n    def __init__(\n        self,\n        parent: QtWidgets.QWidget | None = None,\n        margin: int | None = None,\n        spacing: int = -1,\n    ):\n        super().__init__(parent)  # type: ignore\n        if margin is not None:\n            self.set_margin(margin)\n        self.set_spacing(spacing)\n        self.items: list[QtWidgets.QLayoutItem] = []\n\n    def serialize_fields(self):\n        return dict(items=self.get_children())\n\n    def __add__(self, other: QtWidgets.QWidget | QtWidgets.QLayout) -&gt; FlowLayout:\n        if not isinstance(other, (QtWidgets.QWidget, QtWidgets.QLayout)):\n            raise TypeError()\n        self.add(other)\n        return self\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __setstate__(self, state):\n        for item in state[\"items\"]:\n            self.add(item)\n\n    def __del__(self):\n        item = self.takeAt(0)\n        while item:\n            item = self.takeAt(0)\n\n    def addItem(self, item: QtWidgets.QLayoutItem):\n        self.items.append(item)\n\n    def count(self) -&gt; int:\n        return len(self.items)\n\n    def itemAt(self, index: int) -&gt; QtWidgets.QLayoutItem | None:  # type: ignore\n        if 0 &lt;= index &lt; len(self.items):\n            return self.items[index]\n        return None\n\n    def takeAt(self, index: int) -&gt; QtWidgets.QLayoutItem | None:  # type: ignore\n        if 0 &lt;= index &lt; len(self.items):\n            return self.items.pop(index)\n        return None\n\n    # def expandingDirections(self) -&gt; QtCore.Qt.Orientations:\n    #     return QtCore.Qt.Orientations(0)\n\n    def hasHeightForWidth(self) -&gt; bool:\n        return True\n\n    def heightForWidth(self, width: int) -&gt; int:\n        rect = QtCore.QRect(0, 0, width, 0)\n        return self.do_layout(rect, True)\n\n    def setGeometry(self, rect: QtCore.QRect):\n        super().setGeometry(rect)\n        self.do_layout(rect, False)\n\n    def sizeHint(self) -&gt; QtCore.QSize:\n        return self.minimumSize()\n\n    def minimumSize(self) -&gt; QtCore.QSize:\n        size = QtCore.QSize()\n\n        for item in self.items:\n            size = size.expandedTo(item.minimumSize())\n\n        margin_width = 2 * self.contentsMargins().top()\n        size += QtCore.QSize(margin_width, margin_width)\n        return size\n\n    def do_layout(self, rect: QtCore.QRect, test_only: bool) -&gt; int:\n        x = rect.x()\n        y = rect.y()\n        line_height = 0\n        space = self.spacing()\n        pb = widgets.SizePolicy.ControlType.PushButton\n        for item in self.items:\n            wid = item.widget()\n            space_x = space + wid.style().layoutSpacing(pb, pb, constants.HORIZONTAL)\n            next_x = x + item.sizeHint().width() + space_x\n            if next_x - space_x &gt; rect.right() and line_height &gt; 0:\n                x = rect.x()\n                space_y = space + wid.style().layoutSpacing(pb, pb, constants.VERTICAL)\n                y = y + line_height + space_y\n                next_x = x + item.sizeHint().width() + space_x\n                line_height = 0\n\n            if not test_only:\n                item.setGeometry(core.Rect(core.Point(x, y), item.sizeHint()))\n\n            x = next_x\n            line_height = max(line_height, item.sizeHint().height())\n\n        return y + line_height - rect.y()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.addItem","title":"<code>addItem(self, item: QtWidgets.QLayoutItem)</code>","text":"<p>addItem(self, arg__1: PySide6.QtWidgets.QLayoutItem) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/flowlayout.py</code> <pre><code>def addItem(self, item: QtWidgets.QLayoutItem):\n    self.items.append(item)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.count","title":"<code>count(self) -&gt; int</code>","text":"<p>count(self) -&gt; int</p> Source code in <code>prettyqt/custom_widgets/flowlayout.py</code> <pre><code>def count(self) -&gt; int:\n    return len(self.items)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.hasHeightForWidth","title":"<code>hasHeightForWidth(self) -&gt; bool</code>","text":"<p>hasHeightForWidth(self) -&gt; bool</p> Source code in <code>prettyqt/custom_widgets/flowlayout.py</code> <pre><code>def hasHeightForWidth(self) -&gt; bool:\n    return True\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.heightForWidth","title":"<code>heightForWidth(self, width: int) -&gt; int</code>","text":"<p>heightForWidth(self, arg__1: int) -&gt; int</p> Source code in <code>prettyqt/custom_widgets/flowlayout.py</code> <pre><code>def heightForWidth(self, width: int) -&gt; int:\n    rect = QtCore.QRect(0, 0, width, 0)\n    return self.do_layout(rect, True)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.itemAt","title":"<code>itemAt(self, index: int) -&gt; QtWidgets.QLayoutItem | None</code>","text":"<p>itemAt(self, index: int) -&gt; PySide6.QtWidgets.QLayoutItem</p> Source code in <code>prettyqt/custom_widgets/flowlayout.py</code> <pre><code>def itemAt(self, index: int) -&gt; QtWidgets.QLayoutItem | None:  # type: ignore\n    if 0 &lt;= index &lt; len(self.items):\n        return self.items[index]\n    return None\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.minimumSize","title":"<code>minimumSize(self) -&gt; QtCore.QSize</code>","text":"<p>minimumSize(self) -&gt; PySide6.QtCore.QSize</p> Source code in <code>prettyqt/custom_widgets/flowlayout.py</code> <pre><code>def minimumSize(self) -&gt; QtCore.QSize:\n    size = QtCore.QSize()\n\n    for item in self.items:\n        size = size.expandedTo(item.minimumSize())\n\n    margin_width = 2 * self.contentsMargins().top()\n    size += QtCore.QSize(margin_width, margin_width)\n    return size\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.setGeometry","title":"<code>setGeometry(self, rect: QtCore.QRect)</code>","text":"<p>setGeometry(self, arg__1: PySide6.QtCore.QRect) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/flowlayout.py</code> <pre><code>def setGeometry(self, rect: QtCore.QRect):\n    super().setGeometry(rect)\n    self.do_layout(rect, False)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.sizeHint","title":"<code>sizeHint(self) -&gt; QtCore.QSize</code>","text":"<p>sizeHint(self) -&gt; PySide6.QtCore.QSize</p> Source code in <code>prettyqt/custom_widgets/flowlayout.py</code> <pre><code>def sizeHint(self) -&gt; QtCore.QSize:\n    return self.minimumSize()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.takeAt","title":"<code>takeAt(self, index: int) -&gt; QtWidgets.QLayoutItem | None</code>","text":"<p>takeAt(self, index: int) -&gt; PySide6.QtWidgets.QLayoutItem</p> Source code in <code>prettyqt/custom_widgets/flowlayout.py</code> <pre><code>def takeAt(self, index: int) -&gt; QtWidgets.QLayoutItem | None:  # type: ignore\n    if 0 &lt;= index &lt; len(self.items):\n        return self.items.pop(index)\n    return None\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow","title":"<code>framelesswindow</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.CustomTitleBar","title":"<code> CustomTitleBar            (Frame)         </code>","text":"Source code in <code>prettyqt/custom_widgets/framelesswindow.py</code> <pre><code>class CustomTitleBar(widgets.Frame):\n    def __init__(self, window_widget: QtWidgets.QWidget):\n        super().__init__(window_widget)\n\n        self.window_widget = window_widget\n        self.minimize_button = TitleBarIcon(\"\ud83d\uddd5\")\n        self.maximize_button = TitleBarIcon(\"\ud83d\uddd6\")\n        self.exit_button = TitleBarIcon(\"\u2715\")\n        self.setObjectName(\"ControlWidget\")\n        state = QtCore.Qt.WindowState.WindowMinimized\n        self.minimize_button.clicked.connect(\n            lambda: window_widget.setWindowState(state)  # type: ignore\n        )\n        self.maximize_button.clicked.connect(\n            lambda: (\n                window_widget.showNormal()\n                if window_widget.isMaximized()\n                else window_widget.showMaximized()\n            )\n        )\n        self.exit_button.clicked.connect(window_widget.close)\n\n        self.set_layout(\"horizontal\")\n        spacer_item = QtWidgets.QSpacerItem(0, 0, QtWidgets.QSizePolicy.Expanding)\n        self.box.addSpacerItem(spacer_item)\n        for widget in [\n            self.minimize_button,\n            self.maximize_button,\n            self.exit_button,\n        ]:\n            self.box.addWidget(widget)\n\n        self.setStyleSheet(\"width: 100%;\" \"padding: 0;\" \"margin: 0;\")\n        self.set_margin(0)\n        self.box.set_margin(0)\n        self.box.setSpacing(0)\n\n    def mousePressEvent(self, a0: QtGui.QMouseEvent) -&gt; None:\n        self.window_widget.windowHandle().startSystemMove()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.CustomTitleBar.mousePressEvent","title":"<code>mousePressEvent(self, a0: QtGui.QMouseEvent) -&gt; None</code>","text":"<p>mousePressEvent(self, event: PySide6.QtGui.QMouseEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/framelesswindow.py</code> <pre><code>def mousePressEvent(self, a0: QtGui.QMouseEvent) -&gt; None:\n    self.window_widget.windowHandle().startSystemMove()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.EdgeGrip","title":"<code> EdgeGrip            (Widget)         </code>","text":"Source code in <code>prettyqt/custom_widgets/framelesswindow.py</code> <pre><code>class EdgeGrip(widgets.Widget):\n    def __init__(self, edges: str, grip_size=6, parent=None):\n        super().__init__(parent)\n        self.edges = edges\n        self.grip_size = grip_size\n        # Sides\n        match edges:\n            case \"top\":\n                self.setCursor(QtCore.Qt.CursorShape.SizeVerCursor)\n                self.setFixedHeight(self.grip_size)\n            case \"right\":\n                self.setCursor(QtCore.Qt.CursorShape.SizeHorCursor)\n                self.setFixedWidth(self.grip_size)\n            case \"bottom\":\n                self.setCursor(QtCore.Qt.CursorShape.SizeVerCursor)\n                self.setFixedHeight(self.grip_size)\n            case \"left\":\n                self.setCursor(QtCore.Qt.CursorShape.SizeHorCursor)\n                self.setFixedWidth(self.grip_size)\n            # Corners\n            case \"top_left\":\n                self.setCursor(QtCore.Qt.CursorShape.SizeFDiagCursor)\n            case \"top_right\":\n                self.setCursor(QtCore.Qt.CursorShape.SizeBDiagCursor)\n            case \"bottom_left\":\n                self.setCursor(QtCore.Qt.CursorShape.SizeBDiagCursor)\n            case \"bottom_right\":\n                self.setCursor(QtCore.Qt.CursorShape.SizeFDiagCursor)\n\n    def mousePressEvent(self, event):\n        if event.button() == QtCore.Qt.MouseButton.LeftButton:\n            self.parent().windowHandle().startSystemResize(self.edges)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.EdgeGrip.mousePressEvent","title":"<code>mousePressEvent(self, event)</code>","text":"<p>mousePressEvent(self, event: PySide6.QtGui.QMouseEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/framelesswindow.py</code> <pre><code>def mousePressEvent(self, event):\n    if event.button() == QtCore.Qt.MouseButton.LeftButton:\n        self.parent().windowHandle().startSystemResize(self.edges)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.FramelessWindow","title":"<code> FramelessWindow            (Widget)         </code>","text":"Source code in <code>prettyqt/custom_widgets/framelesswindow.py</code> <pre><code>class FramelessWindow(widgets.Widget):\n    BORDER_WIDTH = 5\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(parent)\n\n        # Remove window title bar and frame\n        self.setWindowFlags(\n            QtCore.Qt.WindowType.Window  # type: ignore\n            | QtCore.Qt.WindowType.FramelessWindowHint\n        )\n\n        self.title_bar = CustomTitleBar(self)\n        self.main_widget = widgets.MainWindow()\n\n        # Set up layout\n        self.main_layout = widgets.BoxLayout(\"vertical\")\n        self.main_layout.addWidget(self.title_bar)\n        self.main_layout.addWidget(self.main_widget)\n\n        self.main_layout.set_margin(0)\n        self.main_layout.setSpacing(0)\n\n        self.grip_layout = widgets.GridLayout()\n\n        self.grip_layout.addLayout(self.main_layout, 1, 1)\n        self.grip_layout.addWidget(EdgeGrip(\"top\"), 0, 1)\n        self.grip_layout.addWidget(EdgeGrip(\"right\"), 1, 2)\n        self.grip_layout.addWidget(EdgeGrip(\"bottom\"), 2, 1)\n        self.grip_layout.addWidget(EdgeGrip(\"left\"), 1, 0)\n        self.grip_layout.addWidget(EdgeGrip(\"top_left\"), 0, 0)\n        self.grip_layout.addWidget(EdgeGrip(\"top_right\"), 0, 2)\n        self.grip_layout.addWidget(EdgeGrip(\"bottom_left\"), 2, 0)\n        self.grip_layout.addWidget(EdgeGrip(\"bottom_right\"), 2, 2)\n        self.grip_layout.set_margin(0)\n        self.grip_layout.setSpacing(0)\n        self.setLayout(self.grip_layout)\n\n        if sys.platform == \"win32\":\n            self.hwnd = self.winId().__int__()\n            window_style = win32gui.GetWindowLong(self.hwnd, GWL_STYLE)\n            win32gui.SetWindowLong(\n                self.hwnd,\n                GWL_STYLE,\n                window_style\n                | WS_POPUP\n                | WS_THICKFRAME\n                | WS_CAPTION\n                | WS_SYSMENU\n                | WS_MAXIMIZEBOX\n                | WS_MINIMIZEBOX,\n            )\n\n            # if QtWin.isCompositionEnabled():\n            #     # Aero Shadow\n            #     QtWin.extendFrameIntoClientArea(self, -1, -1, -1, -1)\n            # else:\n            #     QtWin.resetExtendedFrame(self)\n\n    def __getattr__(self, attr: str):\n        return getattr(self.main_widget, attr)\n\n    def changeEvent(self, event):\n        # not sure if this should be done on non-windows\n        if event.type() == event.Type.WindowStateChange:\n            if self.windowState() &amp; QtCore.Qt.WindowState.WindowMaximized:  # type: ignore\n                margin = abs(self.mapToGlobal(self.rect().topLeft()).y())\n                self.set_margin(margin)\n            else:\n                self.set_margin(0)\n\n        return super().changeEvent(event)\n\n    def nativeEvent(self, event, message):\n        return_value, result = super().nativeEvent(event, message)\n        if sys.platform != \"win32\":\n            return return_value, result\n        # if you use Windows OS\n        if event == b\"windows_generic_MSG\":\n            msg = ctypes.wintypes.MSG.from_address(message.__int__())\n            # Get the coordinates when the mouse moves.\n            x = win32api.LOWORD(LONG(msg.lParam).value)  # type: ignore\n            # converted an unsigned int to int (for dual monitor issue)\n            if x &amp; 32768:\n                x = x | -65536\n            y = win32api.HIWORD(LONG(msg.lParam).value)  # type: ignore\n            if y &amp; 32768:\n                y = y | -65536\n\n            x -= self.frameGeometry().x()\n            y -= self.frameGeometry().y()\n\n            # Determine whether there are other widgets at the mouse position.\n            if self.childAt(x, y) is not None and self.childAt(\n                x, y\n            ) is not self.findChild(widgets.Widget, \"ControlWidget\"):\n                # passing\n                if (\n                    self.width() - self.BORDER_WIDTH &gt; x &gt; self.BORDER_WIDTH\n                    and y &lt; self.height() - self.BORDER_WIDTH\n                ):\n                    return return_value, result\n\n            if msg.message == WM_NCCALCSIZE:\n                # Remove system title\n                return True, 0\n\n            elif msg.message == WM_NCHITTEST:\n                w, h = self.width(), self.height()\n                lx = x &lt; self.BORDER_WIDTH\n                rx = x &gt; w - self.BORDER_WIDTH\n                ty = y &lt; self.BORDER_WIDTH\n                by = y &gt; h - self.BORDER_WIDTH\n                match lx, ty, rx, by:\n                    case True, True, _, _:\n                        return True, HTTOPLEFT\n                    case _, _, True, True:\n                        return True, HTBOTTOMRIGHT\n                    case _, True, True, _:\n                        return True, HTTOPRIGHT\n                    case True, _, _, True:\n                        return True, HTBOTTOMLEFT\n                    case _, True, _, _:\n                        return True, HTTOP\n                    case _, _, _, True:\n                        return True, HTBOTTOM\n                    case True, _, _, _:\n                        return True, HTLEFT\n                    case _, _, True, _:\n                        return True, HTRIGHT\n                    case _, _, _, _:\n                        return True, HTCAPTION\n\n        return return_value, result\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.FramelessWindow.changeEvent","title":"<code>changeEvent(self, event)</code>","text":"<p>changeEvent(self, event: PySide6.QtCore.QEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/framelesswindow.py</code> <pre><code>def changeEvent(self, event):\n    # not sure if this should be done on non-windows\n    if event.type() == event.Type.WindowStateChange:\n        if self.windowState() &amp; QtCore.Qt.WindowState.WindowMaximized:  # type: ignore\n            margin = abs(self.mapToGlobal(self.rect().topLeft()).y())\n            self.set_margin(margin)\n        else:\n            self.set_margin(0)\n\n    return super().changeEvent(event)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.framelesswindow.FramelessWindow.nativeEvent","title":"<code>nativeEvent(self, event, message)</code>","text":"<p>nativeEvent(self, eventType: Union[PySide6.QtCore.QByteArray, bytes], message: int) -&gt; object</p> Source code in <code>prettyqt/custom_widgets/framelesswindow.py</code> <pre><code>def nativeEvent(self, event, message):\n    return_value, result = super().nativeEvent(event, message)\n    if sys.platform != \"win32\":\n        return return_value, result\n    # if you use Windows OS\n    if event == b\"windows_generic_MSG\":\n        msg = ctypes.wintypes.MSG.from_address(message.__int__())\n        # Get the coordinates when the mouse moves.\n        x = win32api.LOWORD(LONG(msg.lParam).value)  # type: ignore\n        # converted an unsigned int to int (for dual monitor issue)\n        if x &amp; 32768:\n            x = x | -65536\n        y = win32api.HIWORD(LONG(msg.lParam).value)  # type: ignore\n        if y &amp; 32768:\n            y = y | -65536\n\n        x -= self.frameGeometry().x()\n        y -= self.frameGeometry().y()\n\n        # Determine whether there are other widgets at the mouse position.\n        if self.childAt(x, y) is not None and self.childAt(\n            x, y\n        ) is not self.findChild(widgets.Widget, \"ControlWidget\"):\n            # passing\n            if (\n                self.width() - self.BORDER_WIDTH &gt; x &gt; self.BORDER_WIDTH\n                and y &lt; self.height() - self.BORDER_WIDTH\n            ):\n                return return_value, result\n\n        if msg.message == WM_NCCALCSIZE:\n            # Remove system title\n            return True, 0\n\n        elif msg.message == WM_NCHITTEST:\n            w, h = self.width(), self.height()\n            lx = x &lt; self.BORDER_WIDTH\n            rx = x &gt; w - self.BORDER_WIDTH\n            ty = y &lt; self.BORDER_WIDTH\n            by = y &gt; h - self.BORDER_WIDTH\n            match lx, ty, rx, by:\n                case True, True, _, _:\n                    return True, HTTOPLEFT\n                case _, _, True, True:\n                    return True, HTBOTTOMRIGHT\n                case _, True, True, _:\n                    return True, HTTOPRIGHT\n                case True, _, _, True:\n                    return True, HTBOTTOMLEFT\n                case _, True, _, _:\n                    return True, HTTOP\n                case _, _, _, True:\n                    return True, HTBOTTOM\n                case True, _, _, _:\n                    return True, HTLEFT\n                case _, _, True, _:\n                    return True, HTRIGHT\n                case _, _, _, _:\n                    return True, HTCAPTION\n\n    return return_value, result\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser","title":"<code>iconbrowser</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconListView","title":"<code> IconListView            (ListView)         </code>","text":"Source code in <code>prettyqt/custom_widgets/iconbrowser.py</code> <pre><code>class IconListView(widgets.ListView):\n\"\"\"A QListView that scales its grid size to always show same amount of items.\"\"\"\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(parent)\n        self.set_vertical_scrollbar_policy(\"always_on\")\n        self.VIEW_COLUMNS = 5\n\n    def resizeEvent(self, event):\n\"\"\"Re-calculate the grid size to provide scaling icons.\"\"\"\n        width = self.viewport().width() - 30\n        # The minus 30 above ensures we don't end up with an item width that\n        # can't be drawn the expected number of times across the view without\n        # being wrapped. Without this, the view can flicker during resize\n        tile_width = int(width / self.VIEW_COLUMNS)\n        icon_width = int(tile_width * 0.8)\n        self.set_grid_size((tile_width, tile_width))\n        self.set_icon_size((icon_width, icon_width))\n\n        return super().resizeEvent(event)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconListView.resizeEvent","title":"<code>resizeEvent(self, event)</code>","text":"<p>Re-calculate the grid size to provide scaling icons.</p> Source code in <code>prettyqt/custom_widgets/iconbrowser.py</code> <pre><code>def resizeEvent(self, event):\n\"\"\"Re-calculate the grid size to provide scaling icons.\"\"\"\n    width = self.viewport().width() - 30\n    # The minus 30 above ensures we don't end up with an item width that\n    # can't be drawn the expected number of times across the view without\n    # being wrapped. Without this, the view can flicker during resize\n    tile_width = int(width / self.VIEW_COLUMNS)\n    icon_width = int(tile_width * 0.8)\n    self.set_grid_size((tile_width, tile_width))\n    self.set_icon_size((icon_width, icon_width))\n\n    return super().resizeEvent(event)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconModel","title":"<code> IconModel            (StringListModel)         </code>","text":"Source code in <code>prettyqt/custom_widgets/iconbrowser.py</code> <pre><code>class IconModel(core.StringListModel):\n    def __init__(self, icon_color: QtGui.QColor):\n        super().__init__()\n        self._icon_color = icon_color\n\n    def flags(self, index):\n        return constants.IS_ENABLED | constants.IS_SELECTABLE  # type: ignore\n\n    def data(self, index, role):\n        if role == constants.DECORATION_ROLE:\n            icon_string = self.data(index, role=constants.DISPLAY_ROLE)\n            return iconprovider._icon(icon_string, color=self._icon_color)\n        return super().data(index, role)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconModel.data","title":"<code>data(self, index, role)</code>","text":"<p>data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -&gt; Any</p> Source code in <code>prettyqt/custom_widgets/iconbrowser.py</code> <pre><code>def data(self, index, role):\n    if role == constants.DECORATION_ROLE:\n        icon_string = self.data(index, role=constants.DISPLAY_ROLE)\n        return iconprovider._icon(icon_string, color=self._icon_color)\n    return super().data(index, role)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconModel.flags","title":"<code>flags(self, index)</code>","text":"<p>flags(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex]) -&gt; PySide6.QtCore.Qt.ItemFlag</p> Source code in <code>prettyqt/custom_widgets/iconbrowser.py</code> <pre><code>def flags(self, index):\n    return constants.IS_ENABLED | constants.IS_SELECTABLE  # type: ignore\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget","title":"<code>iconwidget</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget","title":"<code> IconWidget            (Label)         </code>","text":"Source code in <code>prettyqt/custom_widgets/iconwidget.py</code> <pre><code>class IconWidget(widgets.Label):\n\"\"\"IconWidget gives the ability to display an icon as a widget.\n\n    if supports the same arguments as icon()\n    for example\n    music_icon = qta.IconWidget('fa5s.music',\n                                color='blue',\n                                color_active='orange')\n\n    it also have setIcon() and setIconSize() functions\n    \"\"\"\n\n    def __init__(self, *names, parent: QtWidgets.QWidget | None = None, **kwargs):\n        super().__init__(parent=parent)\n        self._icon: QtGui.QIcon | None = None\n        self._size = core.Size(16, 16)\n        self.set_icon(iconprovider._icon(*names, **kwargs))\n\n    def set_icon(self, _icon: datatypes.IconType):\n\"\"\"Set a new icon().\n\n        Parameters\n        ----------\n        _icon: qtawesome.icon\n            icon to set\n        \"\"\"\n        self._icon = iconprovider.get_icon(_icon)\n        self.setPixmap(self._icon.pixmap(self._size))\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n        if isinstance(size, tuple):\n            size = QtCore.QSize(*size)\n        elif isinstance(size, int):\n            size = QtCore.QSize(size, size)\n        self._size = size\n        self.update()\n\n    def update(self, *args, **kwargs):\n        if self._icon:\n            self.setPixmap(self._icon.pixmap(self._size))\n        return super().update(*args, **kwargs)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.set_icon","title":"<code>set_icon(self, _icon: datatypes.IconType)</code>","text":"<p>Set a new icon().</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.set_icon--parameters","title":"Parameters","text":"<p>qtawesome.icon</p> <p>icon to set</p> Source code in <code>prettyqt/custom_widgets/iconwidget.py</code> <pre><code>def set_icon(self, _icon: datatypes.IconType):\n\"\"\"Set a new icon().\n\n    Parameters\n    ----------\n    _icon: qtawesome.icon\n        icon to set\n    \"\"\"\n    self._icon = iconprovider.get_icon(_icon)\n    self.setPixmap(self._icon.pixmap(self._size))\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.update","title":"<code>update(self, *args, **kwargs)</code>","text":"<p>update(self) -&gt; None update(self, arg__1: PySide6.QtCore.QRect) -&gt; None update(self, arg__1: Union[PySide6.QtGui.QRegion, PySide6.QtGui.QBitmap, PySide6.QtGui.QPolygon, PySide6.QtCore.QRect]) -&gt; None update(self, x: int, y: int, w: int, h: int) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/iconwidget.py</code> <pre><code>def update(self, *args, **kwargs):\n    if self._icon:\n        self.setPixmap(self._icon.pixmap(self._size))\n    return super().update(*args, **kwargs)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton","title":"<code>joystickbutton</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton","title":"<code> JoystickButton            (PushButton)         </code>","text":"Source code in <code>prettyqt/custom_widgets/joystickbutton.py</code> <pre><code>class JoystickButton(widgets.PushButton):\n    state_changed = core.Signal(object)\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(parent)\n        self.radius = 200\n        self.setCheckable(True)\n        self.state = [0, 0]\n        self.set_state(0, 0)\n        self.setFixedWidth(50)\n        self.setFixedHeight(50)\n\n    def mousePressEvent(self, ev):\n        self.setChecked(True)\n        self.press_pos = ev.position()\n        ev.accept()\n\n    def mouseMoveEvent(self, ev):\n        dif = ev.position() - self.press_pos\n        self.set_state(dif.x(), -dif.y())\n\n    def mouseReleaseEvent(self, ev):\n        self.setChecked(False)\n        self.set_state(0, 0)\n\n    def wheelEvent(self, ev):\n        ev.accept()\n\n    def doubleClickEvent(self, ev):\n        ev.accept()\n\n    def get_state(self):\n        return self.state\n\n    def set_state(self, x, y):\n        xy = [x, y]\n        d = hypot(xy[0], xy[1])  # length\n        nxy = [0, 0]\n        for i in [0, 1]:\n            if xy[i] == 0:\n                nxy[i] = 0\n            else:\n                nxy[i] = xy[i] / d\n\n        if d &gt; self.radius:\n            d = self.radius\n        d = (d / self.radius) ** 2\n        xy = [nxy[0] * d, nxy[1] * d]\n\n        w2 = self.width() / 2\n        h2 = self.height() / 2\n        self.spot_pos = core.Point(int(w2 * (1 + xy[0])), int(h2 * (1 - xy[1])))\n        self.update()\n        if self.state == xy:\n            return\n        self.state = xy\n        self.state_changed.emit(self.state)\n\n    def paintEvent(self, ev):\n        super().paintEvent(ev)\n        p = QtGui.QPainter(self)\n        p.setBrush(QtGui.QBrush(QtGui.QColor(0, 0, 0)))\n        p.drawEllipse(self.spot_pos.x() - 3, self.spot_pos.y() - 3, 6, 6)\n\n    def resizeEvent(self, ev):\n        self.set_state(*self.state)\n        super().resizeEvent(ev)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.mouseMoveEvent","title":"<code>mouseMoveEvent(self, ev)</code>","text":"<p>mouseMoveEvent(self, arg__1: PySide6.QtGui.QMouseEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/joystickbutton.py</code> <pre><code>def mouseMoveEvent(self, ev):\n    dif = ev.position() - self.press_pos\n    self.set_state(dif.x(), -dif.y())\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.mousePressEvent","title":"<code>mousePressEvent(self, ev)</code>","text":"<p>mousePressEvent(self, e: PySide6.QtGui.QMouseEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/joystickbutton.py</code> <pre><code>def mousePressEvent(self, ev):\n    self.setChecked(True)\n    self.press_pos = ev.position()\n    ev.accept()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.mouseReleaseEvent","title":"<code>mouseReleaseEvent(self, ev)</code>","text":"<p>mouseReleaseEvent(self, e: PySide6.QtGui.QMouseEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/joystickbutton.py</code> <pre><code>def mouseReleaseEvent(self, ev):\n    self.setChecked(False)\n    self.set_state(0, 0)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.paintEvent","title":"<code>paintEvent(self, ev)</code>","text":"<p>paintEvent(self, arg__1: PySide6.QtGui.QPaintEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/joystickbutton.py</code> <pre><code>def paintEvent(self, ev):\n    super().paintEvent(ev)\n    p = QtGui.QPainter(self)\n    p.setBrush(QtGui.QBrush(QtGui.QColor(0, 0, 0)))\n    p.drawEllipse(self.spot_pos.x() - 3, self.spot_pos.y() - 3, 6, 6)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.resizeEvent","title":"<code>resizeEvent(self, ev)</code>","text":"<p>resizeEvent(self, event: PySide6.QtGui.QResizeEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/joystickbutton.py</code> <pre><code>def resizeEvent(self, ev):\n    self.set_state(*self.state)\n    super().resizeEvent(ev)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.joystickbutton.JoystickButton.wheelEvent","title":"<code>wheelEvent(self, ev)</code>","text":"<p>wheelEvent(self, event: PySide6.QtGui.QWheelEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/joystickbutton.py</code> <pre><code>def wheelEvent(self, ev):\n    ev.accept()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider","title":"<code>labeledslider</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider","title":"<code> LabeledSlider            (Widget)         </code>","text":"Source code in <code>prettyqt/custom_widgets/labeledslider.py</code> <pre><code>class LabeledSlider(widgets.Widget):\n    value_changed = core.Signal(int)\n\n    def __init__(\n        self,\n        labels: Sequence[str],\n        orientation: constants.OrientationStr = \"horizontal\",\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        super().__init__(parent=parent)\n\n        if not isinstance(labels, Sequence):\n            raise ValueError(\"&lt;labels&gt; must be a sequence.\")\n        self.levels = list(enumerate(labels))\n        self.set_layout(orientation)\n\n        # gives some space to print labels\n        self.left_margin = 10\n        self.top_margin = 10\n        self.right_margin = 10\n        self.bottom_margin = 10\n        self.box.set_margin(10)\n\n        self.sl = widgets.Slider(orientation)\n        self.sl.value_changed.connect(self.value_changed)\n        self.sl.set_range(0, len(self.levels) - 1)\n        self.sl.set_value(0)\n        if orientation == \"horizontal\":\n            self.sl.set_tick_position(\"below\")\n            self.sl.setMinimumWidth(300)\n        else:\n            self.sl.set_tick_position(\"left\")\n            self.sl.setMinimumHeight(300)\n        self.sl.setTickInterval(1)\n        self.sl.setSingleStep(1)\n\n        self.box.add(self.sl)\n\n    def paintEvent(self, e):\n        super().paintEvent(e)\n\n        style = self.sl.style()\n        st_slider = widgets.StyleOptionSlider()\n        st_slider.initFrom(self.sl)\n        st_slider.orientation = self.sl.orientation()\n\n        length = style.pixelMetric(\n            widgets.Style.PixelMetric.PM_SliderLength, st_slider, self.sl\n        )\n        available = style.pixelMetric(\n            widgets.Style.PixelMetric.PM_SliderSpaceAvailable, st_slider, self.sl\n        )\n\n        painter = gui.Painter(self)\n        for v, v_str in self.levels:\n            # get the size of the label\n            rect = painter.get_text_rect(v_str)\n\n            if self.sl.is_horizontal():\n                x_loc = widgets.Style.sliderPositionFromValue(\n                    self.sl.minimum(), self.sl.maximum(), v, available\n                )\n                # I assume the offset is half the length of slider, therefore\n                # + length//2\n                x_loc += length // 2\n\n                # left bound of the text = center - half of text width + L_margin\n                left = x_loc - rect.width() // 2 + self.left_margin\n                bottom = self.rect().bottom()\n                # enlarge margins if clipping\n                if v == self.sl.minimum():\n                    if left &lt;= 0:\n                        self.left_margin = rect.width() // 2 - x_loc\n                    self.bottom_margin = max(self.bottom_margin, rect.height())\n                    self.adjust_margins()\n                if v == self.sl.maximum() and rect.width() // 2 &gt;= self.right_margin:\n                    self.right_margin = rect.width() // 2\n                    self.adjust_margins()\n            else:\n                y_loc = widgets.Style.sliderPositionFromValue(\n                    self.sl.minimum(), self.sl.maximum(), v, available, upsideDown=True\n                )\n\n                bottom = y_loc + length // 2 + rect.height() // 2 + self.top_margin - 3\n                # there is a 3 px offset that I can't attribute to any metric\n\n                left = self.left_margin - rect.width()\n                if left &lt;= 0:\n                    self.left_margin = rect.width() + 2\n                    self.adjust_margins()\n            painter.drawText(left, bottom, v_str)\n\n    def adjust_margins(self):\n        self.box.setContentsMargins(\n            self.left_margin,\n            self.top_margin,\n            self.right_margin,\n            self.bottom_margin,\n        )\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider.paintEvent","title":"<code>paintEvent(self, e)</code>","text":"<p>paintEvent(self, event: PySide6.QtGui.QPaintEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/labeledslider.py</code> <pre><code>def paintEvent(self, e):\n    super().paintEvent(e)\n\n    style = self.sl.style()\n    st_slider = widgets.StyleOptionSlider()\n    st_slider.initFrom(self.sl)\n    st_slider.orientation = self.sl.orientation()\n\n    length = style.pixelMetric(\n        widgets.Style.PixelMetric.PM_SliderLength, st_slider, self.sl\n    )\n    available = style.pixelMetric(\n        widgets.Style.PixelMetric.PM_SliderSpaceAvailable, st_slider, self.sl\n    )\n\n    painter = gui.Painter(self)\n    for v, v_str in self.levels:\n        # get the size of the label\n        rect = painter.get_text_rect(v_str)\n\n        if self.sl.is_horizontal():\n            x_loc = widgets.Style.sliderPositionFromValue(\n                self.sl.minimum(), self.sl.maximum(), v, available\n            )\n            # I assume the offset is half the length of slider, therefore\n            # + length//2\n            x_loc += length // 2\n\n            # left bound of the text = center - half of text width + L_margin\n            left = x_loc - rect.width() // 2 + self.left_margin\n            bottom = self.rect().bottom()\n            # enlarge margins if clipping\n            if v == self.sl.minimum():\n                if left &lt;= 0:\n                    self.left_margin = rect.width() // 2 - x_loc\n                self.bottom_margin = max(self.bottom_margin, rect.height())\n                self.adjust_margins()\n            if v == self.sl.maximum() and rect.width() // 2 &gt;= self.right_margin:\n                self.right_margin = rect.width() // 2\n                self.adjust_margins()\n        else:\n            y_loc = widgets.Style.sliderPositionFromValue(\n                self.sl.minimum(), self.sl.maximum(), v, available, upsideDown=True\n            )\n\n            bottom = y_loc + length // 2 + rect.height() // 2 + self.top_margin - 3\n            # there is a 3 px offset that I can't attribute to any metric\n\n            left = self.left_margin - rect.width()\n            if left &lt;= 0:\n                self.left_margin = rect.width() + 2\n                self.adjust_margins()\n        painter.drawText(left, bottom, v_str)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles","title":"<code>menurecentfiles</code>","text":"<p>Provides a menu that display the list of recent files and a RecentFilesManager.</p> <p>Application's QSettings are used to store the list of recent files.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.MenuRecentFiles","title":"<code> MenuRecentFiles            (Menu)         </code>","text":"Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>class MenuRecentFiles(widgets.Menu):\n\"\"\"Menu that manage the list of recent files.\n\n    To use the menu, simply connect to the open_requested signal.\n\n    \"\"\"\n\n    #: Signal emitted when the user clicked on a recent file action.\n    #: The parameter is the path of the file to open.\n    open_requested = core.Signal(str)\n    clear_requested = core.Signal()\n\n    def __init__(\n        self,\n        parent,\n        recent_files_manager=None,\n        title=\"Recent files\",\n        icon_provider=None,\n        clear_icon=None,\n    ):\n\"\"\"Init.\n\n        :param parent: parent object\n        :param icon_provider: Object that provides icon based on the file path.\n        :type icon_provider: QtWidgets.QFileIconProvider\n        :param clear_icon: Clear action icon. This parameter is a tuple made up\n            of the icon theme name and the fallback icon path (from your\n            resources). Default is None, clear action has no icons.\n        \"\"\"\n        super().__init__(title, parent)\n        if icon_provider is None:\n            self.icon_provider = widgets.FileIconProvider()\n        else:\n            self.icon_provider = icon_provider\n        self.clear_icon = clear_icon\n        #: Recent files manager\n        self.manager = recent_files_manager\n        #: List of recent files actions\n        self.recent_files_actions = []\n        self.update_actions()\n\n    def update_actions(self):\n\"\"\"Updates the list of actions.\"\"\"\n        self.clear()\n        self.recent_files_actions[:] = []\n        for file in self.manager.get_recent_files():\n            action = widgets.Action(self)\n            action.setText(os.path.split(file)[1])\n            action.setToolTip(file)\n            action.setStatusTip(file)\n            action.setData(file)\n            action.setIcon(self.icon_provider.icon(core.FileInfo(file)))\n            action.triggered.connect(self._on_action_triggered)\n            self.addAction(action)\n            self.recent_files_actions.append(action)\n        self.addSeparator()\n        action_clear = widgets.Action(parent=self, text=\"Clear list\")\n        action_clear.triggered.connect(self.clear_recent_files)\n        action_clear.setIcon(iconprovider.get_icon(\"fa.times-circle\"))\n        self.addAction(action_clear)\n\n    def clear_recent_files(self):\n\"\"\"Clear recent files and menu.\"\"\"\n        self.manager.clear()\n        self.update_actions()\n        self.clear_requested.emit()\n\n    def _on_action_triggered(self):\n\"\"\"Emits open_requested when a recent file action has been triggered.\"\"\"\n        action = self.sender()\n        assert isinstance(action, widgets.Action)\n        path = action.data()\n        self.open_requested.emit(path)\n        self.update_actions()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.MenuRecentFiles.__init__","title":"<code>__init__(self, parent, recent_files_manager = None, title = 'Recent files', icon_provider = None, clear_icon = None)</code>  <code>special</code>","text":"<p>Init.</p> <p>:param parent: parent object :param icon_provider: Object that provides icon based on the file path. :type icon_provider: QtWidgets.QFileIconProvider :param clear_icon: Clear action icon. This parameter is a tuple made up     of the icon theme name and the fallback icon path (from your     resources). Default is None, clear action has no icons.</p> Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>def __init__(\n    self,\n    parent,\n    recent_files_manager=None,\n    title=\"Recent files\",\n    icon_provider=None,\n    clear_icon=None,\n):\n\"\"\"Init.\n\n    :param parent: parent object\n    :param icon_provider: Object that provides icon based on the file path.\n    :type icon_provider: QtWidgets.QFileIconProvider\n    :param clear_icon: Clear action icon. This parameter is a tuple made up\n        of the icon theme name and the fallback icon path (from your\n        resources). Default is None, clear action has no icons.\n    \"\"\"\n    super().__init__(title, parent)\n    if icon_provider is None:\n        self.icon_provider = widgets.FileIconProvider()\n    else:\n        self.icon_provider = icon_provider\n    self.clear_icon = clear_icon\n    #: Recent files manager\n    self.manager = recent_files_manager\n    #: List of recent files actions\n    self.recent_files_actions = []\n    self.update_actions()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.MenuRecentFiles.clear_recent_files","title":"<code>clear_recent_files(self)</code>","text":"<p>Clear recent files and menu.</p> Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>def clear_recent_files(self):\n\"\"\"Clear recent files and menu.\"\"\"\n    self.manager.clear()\n    self.update_actions()\n    self.clear_requested.emit()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.MenuRecentFiles.update_actions","title":"<code>update_actions(self)</code>","text":"<p>Updates the list of actions.</p> Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>def update_actions(self):\n\"\"\"Updates the list of actions.\"\"\"\n    self.clear()\n    self.recent_files_actions[:] = []\n    for file in self.manager.get_recent_files():\n        action = widgets.Action(self)\n        action.setText(os.path.split(file)[1])\n        action.setToolTip(file)\n        action.setStatusTip(file)\n        action.setData(file)\n        action.setIcon(self.icon_provider.icon(core.FileInfo(file)))\n        action.triggered.connect(self._on_action_triggered)\n        self.addAction(action)\n        self.recent_files_actions.append(action)\n    self.addSeparator()\n    action_clear = widgets.Action(parent=self, text=\"Clear list\")\n    action_clear.triggered.connect(self.clear_recent_files)\n    action_clear.setIcon(iconprovider.get_icon(\"fa.times-circle\"))\n    self.addAction(action_clear)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager","title":"<code> RecentFilesManager            (Object)         </code>","text":"Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>class RecentFilesManager(core.Object):\n\"\"\"Manages a list of recent files. The list of files is stored in QSettings.\"\"\"\n\n    #: Maximum number of files kept in the list.\n    max_recent_files = 15\n    updated = core.Signal()\n\n    def __init__(self, organisation, application, qsettings=None):\n        super().__init__()\n        if qsettings is None:\n            self._settings = core.Settings(organisation, application)\n        else:\n            self._settings = qsettings\n\n    def clear(self):\n\"\"\"Clears recent files in QSettings.\"\"\"\n        self.set_value(\"list\", [])\n        self.updated.emit()\n\n    def remove(self, filename):\n\"\"\"Remove a file path from the list of recent files.\n\n        :param filename: Path of the file to remove\n        \"\"\"\n        files = self.get_value(\"list\", [])\n        files.remove(filename)\n        self.set_value(\"list\", files)\n        self.updated.emit()\n\n    def get_value(self, key, default=None):\n\"\"\"Reads value from QSettings.\n\n        :param key: value key\n        :param default: default value.\n        :return: value\n        \"\"\"\n\n        def unique(seq, idfun=None):\n            if idfun is None:\n\n                def idfun(x):\n                    return x\n\n            # order preserving\n            seen = {}\n            result = []\n            for item in seq:\n                marker = idfun(item)\n                if marker in seen:\n                    continue\n                seen[marker] = 1\n                result.append(item)\n            return result\n\n        val = self._settings.value(\"recent_files/%s\" % key, default)\n        if val is None:\n            lst: list[str] = []\n        elif isinstance(val, str):\n            lst = [val]\n        else:\n            lst = val  # type: ignore\n        return unique([os.path.normpath(pth) for pth in lst])\n\n    def set_value(self, key, value):\n\"\"\"Set the recent files value in QSettings.\n\n        :param key: value key\n        :param value: new value\n        \"\"\"\n        if value is None:\n            value = []\n        value = [os.path.normpath(pth) for pth in value]\n        self._settings.setValue(\"recent_files/%s\" % key, value)\n\n    def get_recent_files(self):\n\"\"\"Gets the list of recent files.\n\n        Files that do not exists anymore are automatically filtered\n        \"\"\"\n        ret_val = []\n        files = self.get_value(\"list\", [])\n        # filter files, remove files that do not exist anymore\n        for file in files:\n            if file is not None and os.path.exists(file):\n                if (\n                    os.path.ismount(file)\n                    and sys.platform == \"win32\"\n                    and not file.endswith(\"\\\\\")\n                ):\n                    file += \"\\\\\"\n                if file not in ret_val:\n                    ret_val.append(file)\n        return ret_val\n\n    def open_file(self, file):\n\"\"\"Adds a file to the list (and move it to top if the file already exists).\n\n        :param file: file path to add the list of recent files.\n        \"\"\"\n        files = self.get_recent_files()\n        try:\n            files.remove(file)\n        except ValueError:\n            pass\n        files.insert(0, file)\n        # discard old files\n        del files[self.max_recent_files :]\n        self.set_value(\"list\", files)\n        self.updated.emit()\n\n    def last_file(self):\n\"\"\"Returns the path to the last opened file.\"\"\"\n        files = self.get_recent_files()\n        try:\n            return files[0]\n        except IndexError:\n            return None\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.clear","title":"<code>clear(self)</code>","text":"<p>Clears recent files in QSettings.</p> Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>def clear(self):\n\"\"\"Clears recent files in QSettings.\"\"\"\n    self.set_value(\"list\", [])\n    self.updated.emit()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.get_recent_files","title":"<code>get_recent_files(self)</code>","text":"<p>Gets the list of recent files.</p> <p>Files that do not exists anymore are automatically filtered</p> Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>def get_recent_files(self):\n\"\"\"Gets the list of recent files.\n\n    Files that do not exists anymore are automatically filtered\n    \"\"\"\n    ret_val = []\n    files = self.get_value(\"list\", [])\n    # filter files, remove files that do not exist anymore\n    for file in files:\n        if file is not None and os.path.exists(file):\n            if (\n                os.path.ismount(file)\n                and sys.platform == \"win32\"\n                and not file.endswith(\"\\\\\")\n            ):\n                file += \"\\\\\"\n            if file not in ret_val:\n                ret_val.append(file)\n    return ret_val\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.get_value","title":"<code>get_value(self, key, default = None)</code>","text":"<p>Reads value from QSettings.</p> <p>:param key: value key :param default: default value. :return: value</p> Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>def get_value(self, key, default=None):\n\"\"\"Reads value from QSettings.\n\n    :param key: value key\n    :param default: default value.\n    :return: value\n    \"\"\"\n\n    def unique(seq, idfun=None):\n        if idfun is None:\n\n            def idfun(x):\n                return x\n\n        # order preserving\n        seen = {}\n        result = []\n        for item in seq:\n            marker = idfun(item)\n            if marker in seen:\n                continue\n            seen[marker] = 1\n            result.append(item)\n        return result\n\n    val = self._settings.value(\"recent_files/%s\" % key, default)\n    if val is None:\n        lst: list[str] = []\n    elif isinstance(val, str):\n        lst = [val]\n    else:\n        lst = val  # type: ignore\n    return unique([os.path.normpath(pth) for pth in lst])\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.last_file","title":"<code>last_file(self)</code>","text":"<p>Returns the path to the last opened file.</p> Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>def last_file(self):\n\"\"\"Returns the path to the last opened file.\"\"\"\n    files = self.get_recent_files()\n    try:\n        return files[0]\n    except IndexError:\n        return None\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.open_file","title":"<code>open_file(self, file)</code>","text":"<p>Adds a file to the list (and move it to top if the file already exists).</p> <p>:param file: file path to add the list of recent files.</p> Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>def open_file(self, file):\n\"\"\"Adds a file to the list (and move it to top if the file already exists).\n\n    :param file: file path to add the list of recent files.\n    \"\"\"\n    files = self.get_recent_files()\n    try:\n        files.remove(file)\n    except ValueError:\n        pass\n    files.insert(0, file)\n    # discard old files\n    del files[self.max_recent_files :]\n    self.set_value(\"list\", files)\n    self.updated.emit()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.remove","title":"<code>remove(self, filename)</code>","text":"<p>Remove a file path from the list of recent files.</p> <p>:param filename: Path of the file to remove</p> Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>def remove(self, filename):\n\"\"\"Remove a file path from the list of recent files.\n\n    :param filename: Path of the file to remove\n    \"\"\"\n    files = self.get_value(\"list\", [])\n    files.remove(filename)\n    self.set_value(\"list\", files)\n    self.updated.emit()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.menurecentfiles.RecentFilesManager.set_value","title":"<code>set_value(self, key, value)</code>","text":"<p>Set the recent files value in QSettings.</p> <p>:param key: value key :param value: new value</p> Source code in <code>prettyqt/custom_widgets/menurecentfiles.py</code> <pre><code>def set_value(self, key, value):\n\"\"\"Set the recent files value in QSettings.\n\n    :param key: value key\n    :param value: new value\n    \"\"\"\n    if value is None:\n        value = []\n    value = [os.path.normpath(pth) for pth in value]\n    self._settings.setValue(\"recent_files/%s\" % key, value)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification","title":"<code>notification</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.MessageLabel","title":"<code> MessageLabel            (Label)         </code>","text":"Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>class MessageLabel(widgets.Label):\n\"\"\"Subclass of QLabel, which reimplements the resizeEvent() function.\n\n    This is necessary because otherwise the notifications take up too much vertical\n    space when texts they display become longer. This is because normally the height\n    of a notification is calculated as the minimum height necessary for the text\n    when the widget is horizontally resized to its minimum.\n    \"\"\"\n\n    def resizeEvent(self, event):\n        super().resizeEvent(event)\n        if (\n            self.wordWrap()\n            and self.sizePolicy().verticalPolicy() == widgets.SizePolicy.Minimum\n        ):\n            new_height = self.heightForWidth(self.width())\n            if new_height &lt; 1:\n                return\n            self.setMaximumHeight(new_height)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.MessageLabel.resizeEvent","title":"<code>resizeEvent(self, event)</code>","text":"<p>resizeEvent(self, event: PySide6.QtGui.QResizeEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def resizeEvent(self, event):\n    super().resizeEvent(event)\n    if (\n        self.wordWrap()\n        and self.sizePolicy().verticalPolicy() == widgets.SizePolicy.Minimum\n    ):\n        new_height = self.heightForWidth(self.width())\n        if new_height &lt; 1:\n            return\n        self.setMaximumHeight(new_height)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification","title":"<code> Notification            (Widget)         </code>","text":"Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>class Notification(widgets.Widget):\n\"\"\"Class representing a single notification.\"\"\"\n\n    close_clicked = core.Signal()\n\n    def __init__(\n        self,\n        message: str,\n        category: CategoryStr,\n        timeout=None,\n        autohide: bool = False,\n        buttontext: str | None = None,\n        *args,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        # Store instance variables\n        self.message = message\n        self.category = category\n        self.timeout = timeout\n        self.autohide = autohide\n\n        # Set Object name for reference\n        self.setObjectName(category)\n        self.set_layout(\"horizontal\", margin=0)\n\n        # Create a message area\n        message_area = widgets.BoxLayout(\"horizontal\")\n        message_area.set_margin(0)\n\n        # Create the layout\n        self.message_display = MessageLabel()\n        self.message_display.setObjectName(\"message\")\n        self.message_display.set_size_policy(\"minimum\", \"minimum\")\n        self.message_display.setWordWrap(True)\n\n        # Create a button that can close notifications\n        if not buttontext:\n            close_button = widgets.PushButton(\"\\u2715\")\n        else:\n            close_button = widgets.PushButton(buttontext)\n            close_button.setStyleSheet(\"text-decoration: underline;\")\n        close_button.set_size_policy(\"fixed\", \"fixed\")\n        close_button.setFlat(True)\n        close_button.setObjectName(\"closeButton\")\n        close_button.clicked.connect(self.close_clicked)\n\n        # Add everything together\n        message_area.addWidget(self.message_display)\n        # message_area.addStretch(1)\n        message_area.addWidget(close_button)\n        self.layout().addLayout(message_area)\n\n        # Initialize some variables\n        # self.setStyle(category)\n        self.setVisible(False)\n\n        # Flag that is set if notification is being removed. This can be used to\n        # make sure that even though the notification has not been really removed\n        # yet (because it is for example in a fade out animation), it is in the\n        # process of being removed\n        self.is_being_removed = False\n        self.is_fading_in = False\n        self.opacity_effect = widgets.GraphicsOpacityEffect(self)\n\n        # Fade in animation\n        self.fade_in_anim = core.PropertyAnimation()\n        self.fade_in_anim.apply_to(self.opacity_effect, \"opacity\")\n        self.fade_in_anim.set_range(0.0, 1.0)\n\n        # Fade out animation\n        self.fade_out_anim = core.PropertyAnimation()\n        self.fade_out_anim.apply_to(self.opacity_effect, \"opacity\")\n        self.fade_in_anim.set_range(1.0, 0.0)\n\n    def display(self):\n\"\"\"Display the notification.\"\"\"\n        self.message_display.setText(self.message)\n        self.show()\n        self.raise_()\n\n    def close(self):\n\"\"\"Close the notification.\"\"\"\n        super().close()\n        self.deleteLater()\n\n    def fade_in(self, duration: int):\n\"\"\"Fade in the notification.\n\n        Arguments:\n            duration : int\n                The desired duration of the animation\n\n        Raises:\n            TypeError: duration is not an integer\n        \"\"\"\n        if type(duration) != int:\n            raise TypeError(\"duration should be an integer\")\n        self.setGraphicsEffect(self.opacity_effect)\n        self.fade_in_anim.setDuration(duration)\n        self.is_fading_in = True\n        self.fade_in_anim.finished.connect(self.on_fade_in_finished)\n        self.display()\n        self.fade_in_anim.start()\n\n    def on_fade_in_finished(self):\n        self.is_fading_in = False\n\n    def fade_out(self, finished_callback: Callable, duration: int):\n\"\"\"Fade out the notification.\n\n        Parameters\n        ----------\n        finished_callback : callable\n            The function to call after the animation has finished (to for instance\n            clean up the notification)\n        duration : int\n            The desired duration of the animation\n\n        Raises\n        ------\n        TypeError: the wrong datatype is specified for any of the parameters.\n\n        \"\"\"\n        if not callable(finished_callback):\n            raise TypeError(\"finished_callback should be a callable\")\n        if type(duration) != int:\n            raise TypeError(\"duration should be an integer\")\n\n        self.setGraphicsEffect(self.opacity_effect)\n        self.fade_out_anim.setDuration(duration)\n        self.fade_out_anim.finished.connect(lambda: finished_callback(self))\n        self.is_being_removed = True\n        self.fade_out_anim.start()\n\n    def paintEvent(self, pe):\n\"\"\"Redefinition of paintEvent, do not call directly.\n\n        Makes class Notification available in style sheets. Interal Qt function.\n        Should not be called directly.\n        \"\"\"\n        o = widgets.StyleOption.based_on(self)\n        p = gui.Painter(self)\n        self.style().drawPrimitive(widgets.Style.PE_Widget, o, p, self)\n\n    @property\n    def message(self) -&gt; str:\n\"\"\"The currently set message to display.\"\"\"\n        return self._message\n\n    @message.setter\n    def message(self, value: str):\n\"\"\"Set the message to display.\"\"\"\n        self._message = value\n\n    @property\n    def category(self) -&gt; CategoryStr:\n\"\"\"The currently set category of this notification.\"\"\"\n        return self._category\n\n    @category.setter\n    def category(self, value: CategoryStr):\n\"\"\"Set the category of this notification.\n\n        Arguments:\n            value : {'primary','success','info','warning','danger'}\n                The category specification\n\n        Raises:\n            ValueError: The category is other than one of the expected values.\n        \"\"\"\n        allowed_values = [\"primary\", \"success\", \"info\", \"warning\", \"danger\"]\n        if value not in allowed_values:\n            raise ValueError(\n                f\"{value!r} is not a valid value. Should be one of {allowed_values}\"\n            )\n        self._category = value\n\n    def enterEvent(self, e):\n\"\"\"When the notification is set to auto-hide, mouseover closes it.\"\"\"\n        if self.autohide:\n            self.close_clicked.emit()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.category","title":"<code>category: CategoryStr</code>  <code>property</code> <code>writable</code>","text":"<p>The currently set category of this notification.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.message","title":"<code>message: str</code>  <code>property</code> <code>writable</code>","text":"<p>The currently set message to display.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.close","title":"<code>close(self)</code>","text":"<p>Close the notification.</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def close(self):\n\"\"\"Close the notification.\"\"\"\n    super().close()\n    self.deleteLater()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.display","title":"<code>display(self)</code>","text":"<p>Display the notification.</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def display(self):\n\"\"\"Display the notification.\"\"\"\n    self.message_display.setText(self.message)\n    self.show()\n    self.raise_()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.enterEvent","title":"<code>enterEvent(self, e)</code>","text":"<p>When the notification is set to auto-hide, mouseover closes it.</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def enterEvent(self, e):\n\"\"\"When the notification is set to auto-hide, mouseover closes it.\"\"\"\n    if self.autohide:\n        self.close_clicked.emit()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.fade_in","title":"<code>fade_in(self, duration: int)</code>","text":"<p>Fade in the notification.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <p>int The desired duration of the animation</p> required <p>Exceptions:</p> Type Description <code>TypeError</code> <p>duration is not an integer</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def fade_in(self, duration: int):\n\"\"\"Fade in the notification.\n\n    Arguments:\n        duration : int\n            The desired duration of the animation\n\n    Raises:\n        TypeError: duration is not an integer\n    \"\"\"\n    if type(duration) != int:\n        raise TypeError(\"duration should be an integer\")\n    self.setGraphicsEffect(self.opacity_effect)\n    self.fade_in_anim.setDuration(duration)\n    self.is_fading_in = True\n    self.fade_in_anim.finished.connect(self.on_fade_in_finished)\n    self.display()\n    self.fade_in_anim.start()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.fade_out","title":"<code>fade_out(self, finished_callback: Callable, duration: int)</code>","text":"<p>Fade out the notification.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.fade_out--parameters","title":"Parameters","text":"<p>finished_callback : callable     The function to call after the animation has finished (to for instance     clean up the notification) duration : int     The desired duration of the animation</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.fade_out--raises","title":"Raises","text":"<p>TypeError: the wrong datatype is specified for any of the parameters.</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def fade_out(self, finished_callback: Callable, duration: int):\n\"\"\"Fade out the notification.\n\n    Parameters\n    ----------\n    finished_callback : callable\n        The function to call after the animation has finished (to for instance\n        clean up the notification)\n    duration : int\n        The desired duration of the animation\n\n    Raises\n    ------\n    TypeError: the wrong datatype is specified for any of the parameters.\n\n    \"\"\"\n    if not callable(finished_callback):\n        raise TypeError(\"finished_callback should be a callable\")\n    if type(duration) != int:\n        raise TypeError(\"duration should be an integer\")\n\n    self.setGraphicsEffect(self.opacity_effect)\n    self.fade_out_anim.setDuration(duration)\n    self.fade_out_anim.finished.connect(lambda: finished_callback(self))\n    self.is_being_removed = True\n    self.fade_out_anim.start()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.Notification.paintEvent","title":"<code>paintEvent(self, pe)</code>","text":"<p>Redefinition of paintEvent, do not call directly.</p> <p>Makes class Notification available in style sheets. Interal Qt function. Should not be called directly.</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def paintEvent(self, pe):\n\"\"\"Redefinition of paintEvent, do not call directly.\n\n    Makes class Notification available in style sheets. Interal Qt function.\n    Should not be called directly.\n    \"\"\"\n    o = widgets.StyleOption.based_on(self)\n    p = gui.Painter(self)\n    self.style().drawPrimitive(widgets.Style.PE_Widget, o, p, self)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea","title":"<code> NotificationArea            (Widget)         </code>","text":"Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>class NotificationArea(widgets.Widget):\n\"\"\"Notification area to show notifications in.\n\n    Will be projected on top of another QWidget which should be passed as an argument\n    to this class.\n    \"\"\"\n\n    def __init__(\n        self,\n        target_widget: QtWidgets.QWidget,\n        use_global_css: bool = False,\n        use_queue: bool = True,\n        max_messages: int = 2,\n    ):\n\"\"\"Constructor.\n\n        Arguments:\n            target_widget : QtWidgets.QWidget\n                The widget to project the notifications on\n            use_global_css : bool (default: False)\n                Flag which indicates whether global style sheets should be used\n                (which have been set at app-level). If False, the default style sheets\n                stored at DEFAULT_NOTIFICATION_STYLES will be loaded.\n            use_queue : bool (default: True)\n                Indicates whether a message queue should be implemented. This will only\n                show *max_messages* at the same time and will put all other messages in a\n                queue. Once a message disappears, the next one in the queue will be shown\n                (up to max_messages at the same time)\n            max_messages : int (default: 2)\n                The number of messages to display at the same time.\n\n        Raises:\n            TypeError : target_widget is not an object that inherits QWidget\n        \"\"\"\n        if not isinstance(target_widget, QtWidgets.QWidget):\n            raise TypeError(\"target_widget is not a QWidget (or child of it\")\n\n        # Pop some variables from kwargs.\n        self.use_queue = use_queue\n        self.max_messages = max_messages\n        super().__init__(parent=target_widget)\n\n        if not use_global_css:\n            self.setStyleSheet(DEFAULT_NOTIFICATION_STYLES)\n\n        if self.use_queue:\n            self.queue: Queue[Notification] = Queue()\n\n        self.target_widget = target_widget\n        self.set_margin(0)\n\n        notification_area_layout = widgets.BoxLayout(\"vertical\")\n        self.setLayout(notification_area_layout)\n\n        # Init effects to None\n        self.entry_effect: FadeInValue = None\n        self.entry_effect_duration = 250\n        self.exit_effect: FadeOutValue = None\n        self.exit_effect_duration = 500\n\n        # Store original target classes resizeEvent to be called in our own\n        # function\n        self.target_resize_event = target_widget.resizeEvent\n        # Overwrite resizeEvent function of target_widget to capture it ourself\n        # (parent's resizeEvent will be called in our function too)\n        self.target_widget.resizeEvent = self.resizeEvent  # type: ignore\n        self.hide()\n\n    def __delete_notification(self, notification: Notification):\n\"\"\"Close and destroy the supplied notification.\"\"\"\n        notification.close()\n        self.layout().removeWidget(notification)\n\n        self.adjustSize()\n        # Hide notification area if it doesn't contain any items\n        if self.layout().count() == 0:\n            self.hide()\n\n        if self.use_queue:\n            try:\n                notification = self.queue.get(False)\n                self._show_notification(notification)\n            except Empty:\n                pass\n\n    # Public functions\n    def set_entry_effect(self, effect: FadeInValue, duration: int = 250):\n\"\"\"Set the effect with which the notifications are to appear.\n\n        Arguments:\n            effect : {'fade_in', None}\n                The effect which should be used (for now only 'fade_in' is available)\n                if None is passed for this argument, no effect will be used and the\n                notifcations will just appear directly.\n            duration : int (default: 250 ms)\n                The duration of the effect in milliseconds\n\n        Raises:\n            TypeError: the object passed for duration is not an int\n            ValueError: duration is less than 0, or effect has an invalid value\n        \"\"\"\n        if effect not in [\"fade_in\", None]:\n            raise ValueError(\"Invalid entry effect\")\n        if not isinstance(duration, int):\n            raise TypeError(\"Duration should be an int\")\n        if duration &lt; 0:\n            raise ValueError(\"Duration should be larger than 0\")\n\n        self.entry_effect = effect\n        self.entry_effect_duration = duration\n\n    def set_exit_effect(self, effect: FadeOutValue, duration: int = 500):\n\"\"\"Set the effect with which the notifications are to disappear.\n\n        Arguments:\n            effect : {'fade_out', None}\n                the effect which should be used (for now only 'fade_out' is available)\n                if None is passed for this argument, no effect will be used and the\n                notifcations will just appear directly.\n            duration : int (default: 1000 ms)\n                The duration of the effect in milliseconds\n\n        Raises:\n            TypeError: the object passed for duration is not an int\n            ValueError: duration is less than 0, or effect has an invalid value\n        \"\"\"\n        if effect not in [\"fade_out\", None]:\n            raise ValueError(\"Invalid exit effect\")\n        if not isinstance(duration, int):\n            raise TypeError(\"Duration should be an int\")\n        if duration &lt; 0:\n            raise ValueError(\"Duration should be larger than 0\")\n\n        self.exit_effect = effect\n        self.exit_effect_duration = duration\n\n    @core.Slot(str, str, int, bool)\n    @core.Slot(str, str, int, bool, str)\n    def display(\n        self,\n        message: str,\n        category: CategoryStr,\n        timeout: int = 5000,\n        autohide: bool = False,\n        buttontext: str | None = None,\n    ):\n\"\"\"Display a notification.\n\n        If a queue is used, then the notification will only be shown directly\n        if the number of notifications shown is smaller than max_messages.\n\n        Arguments:\n            message : str\n                The message to display\n            category : {'primary', 'success', 'info', 'warning', 'danger'}\n                The type of notification that should be shown. Adheres to bootstrap\n                standards which are primary, success, info, warning and danger\n            timeout : int, optional\n                The duration for which the notification should be shown. If None then\n                the notification will be shown indefinitely\n            autohide: bool, optional\n                Whether to automatically hide the notification on mouseover\n            buttontext : str, optional\n                The text to display on the closing button. If not provided a cross\n                will be shown.\n\n        Raises:\n            ValueError: the category is other than one of the expected values.\n        \"\"\"\n        notification = Notification(\n            message, category, timeout, autohide, buttontext, self\n        )\n        notification.close_clicked.connect(self.remove)\n\n        # Queue if max amount of notifications is shown\n        if self.use_queue and self.layout().count() &gt;= self.max_messages:\n            self.queue.put(notification)\n        else:\n            self._show_notification(notification)\n\n    def _cursor_in_area(self) -&gt; bool:\n        geom = self.geometry()\n        top_left = self.mapToGlobal(geom.topLeft())\n        bottom_right = self.mapToGlobal(geom.bottomRight())\n        geom = core.Rect(top_left, bottom_right)\n        geom.setTop(geom.top() - CURSOR_MARGIN_TOP)\n        geom.setBottom(geom.bottom() + CURSOR_MARGIN_BOTTOM)\n        geom.setLeft(geom.left() - CURSOR_MARGIN_LEFT)\n        geom.setRight(geom.right() + CURSOR_MARGIN_RIGHT)\n        cursor_pos = gui.Cursor.get_position()\n        return geom.contains(cursor_pos)\n\n    def _show_notification(self, notification: Notification):\n        if self._cursor_in_area():\n            core.Timer.singleShot(1000, lambda: self._show_notification(notification))\n            return\n        if not self.isVisible():\n            self.show()\n            self.raise_()\n        self.layout().addWidget(notification)\n        # Check for entry effects\n        if self.entry_effect is not None:\n            if self.entry_effect == \"fade_in\":\n                notification.fade_in(self.entry_effect_duration)\n        else:\n            notification.display()\n\n        self.adjustSize()\n        if notification.timeout is not None and notification.timeout &gt; 0:\n            core.Timer.singleShot(notification.timeout, lambda: self.remove(notification))\n\n    @core.Slot()\n    def remove(self, notification: Notification | None = None):\n\"\"\"Removes a notification.\n\n        Arguments:\n            notification : Notification (default: None)\n                The notification to remove. This function also serves as a PyQt slot\n                for signals emitted from a Notification. In this case, the Notification\n                object is retrieved by using self.sender()\n\n        Raises:\n            ValueError: notification is not None or a Notification\n\n        \"\"\"\n        # This function also functions as a pyqt slot. In that case, no\n        # notification argument is passed, but this is set as self.sender()\n        if notification is None:\n            notification = self.sender()\n        if notification.is_being_removed or notification.is_fading_in:\n            return\n        notification.is_being_removed = True\n\n        # Check if notification is still present (and has not manually been\n        # closed before this function is called by a timeout)\n        if notification not in self.layout():\n            return\n\n        # Implement animation here\n        if self.exit_effect == \"fade_out\":\n            notification.fade_out(self.__delete_notification, self.exit_effect_duration)\n        else:\n            self.__delete_notification(notification)\n\n    # Internal Qt functions\n    def resizeEvent(self, event):\n\"\"\"Internal QT function (do not call directly).\"\"\"\n        self.target_resize_event(event)\n        newsize = event.size()\n        self.setFixedWidth(newsize.width())\n        self.adjustSize()\n\n    def paintEvent(self, pe):\n\"\"\"Redefinition of paintEvent.\n\n        Makes class NotificationArea available in style sheets.\n        Internal QT function (do not call directly).\n        \"\"\"\n        o = widgets.StyleOption.based_on(self)\n        p = gui.Painter(self)\n        self.style().drawPrimitive(widgets.Style.PE_Widget, o, p, self)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.__init__","title":"<code>__init__(self, target_widget: QtWidgets.QWidget, use_global_css: bool = False, use_queue: bool = True, max_messages: int = 2)</code>  <code>special</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>target_widget</code> <p>QtWidgets.QWidget The widget to project the notifications on</p> required <code>use_global_css</code> <p>bool (default: False) Flag which indicates whether global style sheets should be used (which have been set at app-level). If False, the default style sheets stored at DEFAULT_NOTIFICATION_STYLES will be loaded.</p> <code>False</code> <code>use_queue</code> <p>bool (default: True) Indicates whether a message queue should be implemented. This will only show max_messages at the same time and will put all other messages in a queue. Once a message disappears, the next one in the queue will be shown (up to max_messages at the same time)</p> <code>True</code> <code>max_messages</code> <p>int (default: 2) The number of messages to display at the same time.</p> <code>2</code> <p>Exceptions:</p> Type Description <code>TypeError </code> <p>target_widget is not an object that inherits QWidget</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def __init__(\n    self,\n    target_widget: QtWidgets.QWidget,\n    use_global_css: bool = False,\n    use_queue: bool = True,\n    max_messages: int = 2,\n):\n\"\"\"Constructor.\n\n    Arguments:\n        target_widget : QtWidgets.QWidget\n            The widget to project the notifications on\n        use_global_css : bool (default: False)\n            Flag which indicates whether global style sheets should be used\n            (which have been set at app-level). If False, the default style sheets\n            stored at DEFAULT_NOTIFICATION_STYLES will be loaded.\n        use_queue : bool (default: True)\n            Indicates whether a message queue should be implemented. This will only\n            show *max_messages* at the same time and will put all other messages in a\n            queue. Once a message disappears, the next one in the queue will be shown\n            (up to max_messages at the same time)\n        max_messages : int (default: 2)\n            The number of messages to display at the same time.\n\n    Raises:\n        TypeError : target_widget is not an object that inherits QWidget\n    \"\"\"\n    if not isinstance(target_widget, QtWidgets.QWidget):\n        raise TypeError(\"target_widget is not a QWidget (or child of it\")\n\n    # Pop some variables from kwargs.\n    self.use_queue = use_queue\n    self.max_messages = max_messages\n    super().__init__(parent=target_widget)\n\n    if not use_global_css:\n        self.setStyleSheet(DEFAULT_NOTIFICATION_STYLES)\n\n    if self.use_queue:\n        self.queue: Queue[Notification] = Queue()\n\n    self.target_widget = target_widget\n    self.set_margin(0)\n\n    notification_area_layout = widgets.BoxLayout(\"vertical\")\n    self.setLayout(notification_area_layout)\n\n    # Init effects to None\n    self.entry_effect: FadeInValue = None\n    self.entry_effect_duration = 250\n    self.exit_effect: FadeOutValue = None\n    self.exit_effect_duration = 500\n\n    # Store original target classes resizeEvent to be called in our own\n    # function\n    self.target_resize_event = target_widget.resizeEvent\n    # Overwrite resizeEvent function of target_widget to capture it ourself\n    # (parent's resizeEvent will be called in our function too)\n    self.target_widget.resizeEvent = self.resizeEvent  # type: ignore\n    self.hide()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.display","title":"<code>display(self, message: str, category: CategoryStr, timeout: int = 5000, autohide: bool = False, buttontext: str | None = None)</code>","text":"<p>Display a notification.</p> <p>If a queue is used, then the notification will only be shown directly if the number of notifications shown is smaller than max_messages.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <p>str The message to display</p> required <code>category</code> <p>{'primary', 'success', 'info', 'warning', 'danger'} The type of notification that should be shown. Adheres to bootstrap standards which are primary, success, info, warning and danger</p> required <code>timeout</code> <p>int, optional The duration for which the notification should be shown. If None then the notification will be shown indefinitely</p> <code>5000</code> <code>autohide</code> <code>bool</code> <p>bool, optional Whether to automatically hide the notification on mouseover</p> <code>False</code> <code>buttontext</code> <p>str, optional The text to display on the closing button. If not provided a cross will be shown.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>the category is other than one of the expected values.</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>@core.Slot(str, str, int, bool)\n@core.Slot(str, str, int, bool, str)\ndef display(\n    self,\n    message: str,\n    category: CategoryStr,\n    timeout: int = 5000,\n    autohide: bool = False,\n    buttontext: str | None = None,\n):\n\"\"\"Display a notification.\n\n    If a queue is used, then the notification will only be shown directly\n    if the number of notifications shown is smaller than max_messages.\n\n    Arguments:\n        message : str\n            The message to display\n        category : {'primary', 'success', 'info', 'warning', 'danger'}\n            The type of notification that should be shown. Adheres to bootstrap\n            standards which are primary, success, info, warning and danger\n        timeout : int, optional\n            The duration for which the notification should be shown. If None then\n            the notification will be shown indefinitely\n        autohide: bool, optional\n            Whether to automatically hide the notification on mouseover\n        buttontext : str, optional\n            The text to display on the closing button. If not provided a cross\n            will be shown.\n\n    Raises:\n        ValueError: the category is other than one of the expected values.\n    \"\"\"\n    notification = Notification(\n        message, category, timeout, autohide, buttontext, self\n    )\n    notification.close_clicked.connect(self.remove)\n\n    # Queue if max amount of notifications is shown\n    if self.use_queue and self.layout().count() &gt;= self.max_messages:\n        self.queue.put(notification)\n    else:\n        self._show_notification(notification)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.paintEvent","title":"<code>paintEvent(self, pe)</code>","text":"<p>Redefinition of paintEvent.</p> <p>Makes class NotificationArea available in style sheets. Internal QT function (do not call directly).</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def paintEvent(self, pe):\n\"\"\"Redefinition of paintEvent.\n\n    Makes class NotificationArea available in style sheets.\n    Internal QT function (do not call directly).\n    \"\"\"\n    o = widgets.StyleOption.based_on(self)\n    p = gui.Painter(self)\n    self.style().drawPrimitive(widgets.Style.PE_Widget, o, p, self)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.remove","title":"<code>remove(self, notification: Notification | None = None)</code>","text":"<p>Removes a notification.</p> <p>Parameters:</p> Name Type Description Default <code>notification</code> <p>Notification (default: None) The notification to remove. This function also serves as a PyQt slot for signals emitted from a Notification. In this case, the Notification object is retrieved by using self.sender()</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>notification is not None or a Notification</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>@core.Slot()\ndef remove(self, notification: Notification | None = None):\n\"\"\"Removes a notification.\n\n    Arguments:\n        notification : Notification (default: None)\n            The notification to remove. This function also serves as a PyQt slot\n            for signals emitted from a Notification. In this case, the Notification\n            object is retrieved by using self.sender()\n\n    Raises:\n        ValueError: notification is not None or a Notification\n\n    \"\"\"\n    # This function also functions as a pyqt slot. In that case, no\n    # notification argument is passed, but this is set as self.sender()\n    if notification is None:\n        notification = self.sender()\n    if notification.is_being_removed or notification.is_fading_in:\n        return\n    notification.is_being_removed = True\n\n    # Check if notification is still present (and has not manually been\n    # closed before this function is called by a timeout)\n    if notification not in self.layout():\n        return\n\n    # Implement animation here\n    if self.exit_effect == \"fade_out\":\n        notification.fade_out(self.__delete_notification, self.exit_effect_duration)\n    else:\n        self.__delete_notification(notification)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.resizeEvent","title":"<code>resizeEvent(self, event)</code>","text":"<p>Internal QT function (do not call directly).</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def resizeEvent(self, event):\n\"\"\"Internal QT function (do not call directly).\"\"\"\n    self.target_resize_event(event)\n    newsize = event.size()\n    self.setFixedWidth(newsize.width())\n    self.adjustSize()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.set_entry_effect","title":"<code>set_entry_effect(self, effect: FadeInValue, duration: int = 250)</code>","text":"<p>Set the effect with which the notifications are to appear.</p> <p>Parameters:</p> Name Type Description Default <code>effect</code> <p>{'fade_in', None} The effect which should be used (for now only 'fade_in' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly.</p> required <code>duration</code> <p>int (default: 250 ms) The duration of the effect in milliseconds</p> <code>250</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>the object passed for duration is not an int</p> <code>ValueError</code> <p>duration is less than 0, or effect has an invalid value</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def set_entry_effect(self, effect: FadeInValue, duration: int = 250):\n\"\"\"Set the effect with which the notifications are to appear.\n\n    Arguments:\n        effect : {'fade_in', None}\n            The effect which should be used (for now only 'fade_in' is available)\n            if None is passed for this argument, no effect will be used and the\n            notifcations will just appear directly.\n        duration : int (default: 250 ms)\n            The duration of the effect in milliseconds\n\n    Raises:\n        TypeError: the object passed for duration is not an int\n        ValueError: duration is less than 0, or effect has an invalid value\n    \"\"\"\n    if effect not in [\"fade_in\", None]:\n        raise ValueError(\"Invalid entry effect\")\n    if not isinstance(duration, int):\n        raise TypeError(\"Duration should be an int\")\n    if duration &lt; 0:\n        raise ValueError(\"Duration should be larger than 0\")\n\n    self.entry_effect = effect\n    self.entry_effect_duration = duration\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.notification.NotificationArea.set_exit_effect","title":"<code>set_exit_effect(self, effect: FadeOutValue, duration: int = 500)</code>","text":"<p>Set the effect with which the notifications are to disappear.</p> <p>Parameters:</p> Name Type Description Default <code>effect</code> <p>{'fade_out', None} the effect which should be used (for now only 'fade_out' is available) if None is passed for this argument, no effect will be used and the notifcations will just appear directly.</p> required <code>duration</code> <p>int (default: 1000 ms) The duration of the effect in milliseconds</p> <code>500</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>the object passed for duration is not an int</p> <code>ValueError</code> <p>duration is less than 0, or effect has an invalid value</p> Source code in <code>prettyqt/custom_widgets/notification.py</code> <pre><code>def set_exit_effect(self, effect: FadeOutValue, duration: int = 500):\n\"\"\"Set the effect with which the notifications are to disappear.\n\n    Arguments:\n        effect : {'fade_out', None}\n            the effect which should be used (for now only 'fade_out' is available)\n            if None is passed for this argument, no effect will be used and the\n            notifcations will just appear directly.\n        duration : int (default: 1000 ms)\n            The duration of the effect in milliseconds\n\n    Raises:\n        TypeError: the object passed for duration is not an int\n        ValueError: duration is less than 0, or effect has an invalid value\n    \"\"\"\n    if effect not in [\"fade_out\", None]:\n        raise ValueError(\"Invalid exit effect\")\n    if not isinstance(duration, int):\n        raise TypeError(\"Duration should be an int\")\n    if duration &lt; 0:\n        raise ValueError(\"Duration should be larger than 0\")\n\n    self.exit_effect = effect\n    self.exit_effect_duration = duration\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo","title":"<code>popupinfo</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo","title":"<code> PopupInfo            (Dialog)         </code>","text":"Source code in <code>prettyqt/custom_widgets/popupinfo.py</code> <pre><code>class PopupInfo(widgets.Dialog):\n\"\"\"Dialog overlay to show some info to user.\"\"\"\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None, text: str | None = None):\n        super().__init__(parent=parent)\n        self.timer = core.Timer.single_shot(callback=self.close)\n        self.label = widgets.Label()\n        self.set_flags(stay_on_top=True, frameless=True, tool=True)\n        layout = widgets.BoxLayout(\"vertical\")\n        layout.set_margin(20)\n        self.set_layout(layout)\n        self.set_background_color(\"black\")\n        self.label.set_color(\"white\")\n        layout.add(self.label)\n        # signals.signals.popup_info.connect(self.popup)\n\n    def show(self):\n        self.hide()\n        screen_geo = gui.GuiApplication.primaryScreen().geometry()\n        size = self.label.sizeHint()\n        x = (screen_geo.width() - size.width()) // 2\n        y = (screen_geo.height() - size.height()) // 2\n        self.move(x, y - 200)\n        super().show()\n        self.timer.start(2500)\n\n    def show_popup(self, text: str):\n        self.label.setText(text)\n        self.show()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo.show","title":"<code>show(self)</code>","text":"<p>show(self) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/popupinfo.py</code> <pre><code>def show(self):\n    self.hide()\n    screen_geo = gui.GuiApplication.primaryScreen().geometry()\n    size = self.label.sizeHint()\n    x = (screen_geo.width() - size.width()) // 2\n    y = (screen_geo.height() - size.height()) // 2\n    self.move(x, y - 200)\n    super().show()\n    self.timer.start(2500)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor","title":"<code>regexeditor</code>  <code>special</code>","text":"<p>Module containing classes related to the RegEx editor.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.__main__","title":"<code>__main__</code>  <code>special</code>","text":"<p>This module contains the editor widget implementation.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.quick_ref","title":"<code>quick_ref</code>","text":"<p>Contains the quick reference widget.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.regexeditorwidget","title":"<code>regexeditorwidget</code>","text":"<p>This module contains the editor widget implementation.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar","title":"<code>roundprogressbar</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar.RoundProgressBar","title":"<code> RoundProgressBar            (Widget)         </code>","text":"Source code in <code>prettyqt/custom_widgets/roundprogressbar.py</code> <pre><code>class RoundProgressBar(widgets.Widget):\n    # CONSTANTS\n\n    POSITION_LEFT = 180.0\n    POSITION_TOP = 90.0\n    POSITION_RIGHT = 0.0\n    POSITION_BOTTOM = -90.0\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(parent)\n        self._min_value = 0.0\n        self._max_value = 100.0\n        self.current_value = 0.0\n        self.null_pos = self.POSITION_TOP\n        self.bar_style: BarStyleStr = \"donut\"\n        self.outline_pen_width = 1.0\n        self.data_pen_width = 1.0\n        self._rebuild_brush = False\n        self.number_format = \"%p%\"\n        self.decimals = 1\n        self._update_flags: ValueTypeStr = \"percent\"\n        self.gradient_data: list[QtGui.QColor] = []\n\n    def minimum(self):\n        return self._min_value\n\n    def maximum(self):\n        return self._max_value\n\n    # SETTERS -------------------------------------------------------\n\n    def set_null_position(self, position: float):\n        if position != self.null_pos:\n            self.null_pos = position\n            self._rebuild_brush = True\n            self.update()\n\n    def set_bar_style(self, style: BarStyleStr):\n        if style not in BAR_STYLE:\n            raise InvalidParamError(style, BAR_STYLE)\n        if style != self.bar_style:\n            self.bar_style = style\n            self._rebuild_brush = True\n            self.update()\n\n    def set_outline_pen_width(self, width: float):\n        if width != self.outline_pen_width:\n            self.outline_pen_width = width\n            self.update()\n\n    def set_data_pen_width(self, width: float):\n        if width != self.data_pen_width:\n            self.data_pen_width = width\n            self.update()\n\n    def set_data_colors(self, stop_points: list[QtGui.QColor]):\n        if stop_points != self.gradient_data:\n            self.gradient_data = stop_points\n            self._rebuild_brush = True\n            self.update()\n\n    def set_format(self, val: str):\n        if val != self.number_format:\n            self.number_format = val\n            self._value_format_changed()\n\n    def set_decimals(self, count: int):\n        if count &gt;= 0 and count != self.decimals:\n            self.decimals = count\n            self._value_format_changed()\n\n    # SLOTS ---------------------------------------------------------\n\n    @core.Slot(float, float)\n    def set_range(self, minval: float, maxval: float):\n        self._min_value = min(minval, maxval)\n        self._max_value = max(minval, maxval)\n        self.current_value = min(\n            self._max_value, max(self._min_value, self.current_value)\n        )\n        self._rebuild_brush = True\n        self.update()\n\n    @core.Slot(float)\n    def setMinimum(self, val: float):\n        self.set_range(val, self._max_value)\n\n    @core.Slot(float)\n    def setMaximum(self, val: float):\n        self.set_range(self._min_value, val)\n\n    @core.Slot(float)\n    def set_value(self, val: float):\n        if self.current_value != val:\n            self.current_value = min(self._max_value, max(self._min_value, val))\n            self.update()\n\n    def get_value(self) -&gt; float:\n        return self.current_value\n\n    # PAINTING ------------------------------------------------------\n\n    def paintEvent(self, event: gui.PaintEvent):\n        outer_radius = min(self.width(), self.height())\n        rect = core.RectF(1, 1, outer_radius - 2, outer_radius - 2)\n        with gui.Painter(self) as painter:\n            painter.use_antialiasing()\n            if self.bar_style != \"line\":\n                self._rebuild_data_brush_if_needed()\n            painter.fillRect(0, 0, outer_radius, outer_radius, self.palette().window())\n            self._draw_base(painter, rect)\n            self._draw_value(painter, rect, self.current_value)\n            inner_rect, inner_radius = self._calculate_inner_rect(outer_radius)\n            self._draw_inner_background(painter, inner_rect)\n            self._draw_text(painter, inner_rect, inner_radius, self.current_value)\n\n    def _draw_base(self, painter: gui.Painter, rect: core.RectF):\n        match self.bar_style:\n            case \"donut\":\n                color = self.palette().shadow().color()\n                painter.set_pen(color=color, width=self.outline_pen_width)\n                painter.setBrush(self.palette().base())\n                painter.drawEllipse(rect)\n            case \"line\":\n                base_color = self.palette().base().color()\n                painter.set_pen(color=base_color, width=self.outline_pen_width)\n                painter.setBrush(QtCore.Qt.BrushStyle.NoBrush)\n                width = self.outline_pen_width / 2\n                adjusted = rect.adjusted(width, width, -width, -width)\n                painter.drawEllipse(adjusted)\n            case \"pie\" | \"expand\":\n                base_color = self.palette().base().color()\n                painter.set_pen(color=base_color, width=self.outline_pen_width)\n                painter.setBrush(self.palette().base())\n                painter.drawEllipse(rect)\n\n    def _draw_value(self, painter: gui.Painter, rect: core.RectF, value: float):\n        if value == self._min_value:\n            return\n        diff = self.current_value - self._min_value\n        value_range = self._max_value - self._min_value\n        delta = max(value_range / diff, 0)\n        match self.bar_style:\n            case \"expand\":\n                painter.setBrush(self.palette().highlight())\n                color = self.palette().shadow().color()\n                painter.set_pen(color=color, width=self.data_pen_width)\n                radius = (rect.height() / 2) / delta\n                painter.drawEllipse(rect.center(), radius, radius)\n            case \"line\":\n                color = self.palette().highlight().color()\n                painter.set_pen(color=color, width=self.data_pen_width)\n                painter.setBrush(QtCore.Qt.BrushStyle.NoBrush)\n                pen_width = self.outline_pen_width / 2\n                adjusted = rect.adjusted(pen_width, pen_width, -pen_width, -pen_width)\n                if value == self._max_value:\n                    painter.drawEllipse(adjusted)\n                else:\n                    arc_length = 360 / delta\n                    arc_length = int(-arc_length * 16)\n                    painter.drawArc(adjusted, int(self.null_pos * 16), arc_length)\n            case \"donut\" | \"pie\":\n                data_path = gui.PainterPath()\n                data_path.set_fill_rule(\"winding\")\n                if value == self._max_value:\n                    data_path.addEllipse(rect)\n                else:\n                    arc_length = 360 / delta\n                    center_point = rect.center()\n                    data_path.moveTo(center_point)\n                    data_path.arcTo(rect, self.null_pos, -arc_length)\n                    data_path.lineTo(center_point)\n                painter.setBrush(self.palette().highlight())\n                shadow_color = self.palette().shadow().color()\n                painter.set_pen(color=shadow_color, width=self.data_pen_width)\n                painter.drawPath(data_path)\n\n    def _calculate_inner_rect(self, outer_radius: float) -&gt; tuple[core.RectF, float]:\n        if self.bar_style in (\"line\", \"expand\"):\n            inner_radius = outer_radius - self.outline_pen_width\n        else:\n            inner_radius = outer_radius * 0.75\n        delta = (outer_radius - inner_radius) / 2\n        inner_rect = core.RectF(delta, delta, inner_radius, inner_radius)\n        return inner_rect, inner_radius\n\n    def _draw_inner_background(self, painter: gui.Painter, inner_rect: core.RectF):\n        if self.bar_style == \"donut\":\n            painter.setBrush(self.palette().base())\n            painter.drawEllipse(inner_rect)\n\n    def _draw_text(\n        self,\n        painter: gui.Painter,\n        inner_rect: core.RectF,\n        inner_radius: float,\n        value: float,\n    ):\n        if not self.number_format:\n            return\n        font = self.get_font()\n        font.setPixelSize(10)\n        metrics = gui.FontMetricsF(font)\n        max_width = metrics.width(self._value_to_text(self._max_value))\n        delta = inner_radius / max_width\n        font_size = int(font.pixelSize() * delta * 0.75)\n        font.setPixelSize(max(font_size, 1))\n        painter.setFont(font)\n        painter.setPen(self.palette().text().color())\n        text = self._value_to_text(value)\n        painter.drawText(inner_rect, constants.ALIGN_CENTER, text)  # type: ignore\n\n    def _value_to_text(self, value: float) -&gt; str:\n        text_to_draw = self.number_format\n        match self._update_flags:\n            case \"value\":\n                val = round(value, self.decimals)\n                return text_to_draw.replace(r\"%v\", str(val))\n            case \"percent\":\n                diff = self._max_value - self._min_value\n                pct = (value - self._min_value) / diff * 100\n                val = round(pct, self.decimals)\n                return text_to_draw.replace(r\"%p\", str(val))\n            case \"max\":\n                val = round(self._max_value - self._min_value + 1, self.decimals)\n                return text_to_draw.replace(r\"%m\", str(val))\n            case _:\n                return ValueError()\n\n    def _value_format_changed(self):\n        for k, v in VALUE_MAP.items():\n            if k in self.number_format:\n                self._update_flags = v\n        self.update()\n\n    def _rebuild_data_brush_if_needed(self):\n        if not self._rebuild_brush or not self.gradient_data:\n            return\n        self._rebuild_brush = False\n        if self.bar_style == \"expand\":\n            data_brush = gui.RadialGradient(0.5, 0.5, 0.5, 0.5, 0.5)\n            for i in self.gradient_data:\n                data_brush[i[0]] = i[1]\n        else:\n            data_brush = gui.ConicalGradient(0.5, 0.5, self.null_pos)\n            for i in self.gradient_data:\n                data_brush[1 - i[0]] = i[1]\n        data_brush.set_coordinate_mode(\"stretch_to_device\")\n        with self.edit_palette() as palette:\n            palette.set_brush(\"highlight\", data_brush)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar.RoundProgressBar.paintEvent","title":"<code>paintEvent(self, event: gui.PaintEvent)</code>","text":"<p>paintEvent(self, event: PySide6.QtGui.QPaintEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/roundprogressbar.py</code> <pre><code>def paintEvent(self, event: gui.PaintEvent):\n    outer_radius = min(self.width(), self.height())\n    rect = core.RectF(1, 1, outer_radius - 2, outer_radius - 2)\n    with gui.Painter(self) as painter:\n        painter.use_antialiasing()\n        if self.bar_style != \"line\":\n            self._rebuild_data_brush_if_needed()\n        painter.fillRect(0, 0, outer_radius, outer_radius, self.palette().window())\n        self._draw_base(painter, rect)\n        self._draw_value(painter, rect, self.current_value)\n        inner_rect, inner_radius = self._calculate_inner_rect(outer_radius)\n        self._draw_inner_background(painter, inner_rect)\n        self._draw_text(painter, inner_rect, inner_radius, self.current_value)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider","title":"<code>spanslider</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider","title":"<code> SpanSlider            (Slider)         </code>","text":"Source code in <code>prettyqt/custom_widgets/spanslider.py</code> <pre><code>class SpanSlider(widgets.Slider):\n    value_changed = core.Signal(object)\n    lower_pos_changed = core.Signal(float)\n    upper_pos_changed = core.Signal(float)\n    slider_pressed = core.Signal(object)\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(\"horizontal\", parent)\n        self.rangeChanged.connect(self.update_range)\n        self.sliderReleased.connect(self._move_pressed_handle)\n\n        self.lower_val = 0.0\n        self.upper_val = 0.0\n        self.lower_pos = 0.0\n        self.upper_pos = 0.0\n        self.offset = 0\n        self.position = 0.0\n        self.last_pressed: str | None = None\n        self.upper_pressed = widgets.Style.SubControl.SC_None\n        self.lower_pressed = widgets.Style.SubControl.SC_None\n        self.movement: MovementModeStr = \"no_crossing\"\n        self._main_control: Literal[\"lower\", \"upper\"] = \"lower\"\n        self._first_movement = False\n        self._block_tracking = False\n        dark_color = self.palette().color(gui.Palette.ColorRole.Dark)\n        self.gradient_left = dark_color.lighter(110)\n        self.gradient_right = dark_color.lighter(110)\n\n    def mousePressEvent(self, event):\n        if self.minimum() == self.maximum() or event.buttons() ^ event.button():\n            event.ignore()\n            return\n\n        self.upper_pressed = self._handle_mouse_press(\n            event.position(), self.upper_pressed, self.upper_val, \"upper\"\n        )\n        if self.upper_pressed != HANDLE_STYLE:\n            self.lower_pressed = self._handle_mouse_press(\n                event.position(), self.lower_pressed, self.lower_val, \"lower\"\n            )\n\n        self._first_movement = True\n        event.accept()\n\n    def mouseMoveEvent(self, event):\n        if self.lower_pressed != HANDLE_STYLE and self.upper_pressed != HANDLE_STYLE:\n            event.ignore()\n            return\n\n        opt = widgets.StyleOptionSlider()\n        self.initStyleOption(opt)\n        m = self.style().pixelMetric(\n            widgets.Style.PixelMetric.PM_MaximumDragDistance, opt, self\n        )\n        pixel_pos = self.pick(event.position()) - self.offset\n        new_pos = float(self._pixel_pos_to_value(pixel_pos))\n        if m &gt;= 0:\n            r = self.rect().adjusted(-m, -m, m, m)\n            if not r.contains(event.position().toPoint()):\n                new_pos = self.position\n\n        # pick the preferred handle on the first movement\n        if self._first_movement:\n            if self.lower_val == self.upper_val:\n                if new_pos &lt; self.lower_value:\n                    self._swap_controls()\n                    self._first_movement = False\n            else:\n                self._first_movement = False\n\n        match HANDLE_STYLE, self.movement:\n            case self.lower_pressed, \"no_crossing\":\n                new_pos = min(new_pos, self.upper_val)\n                self.set_lower_pos(new_pos)\n            case self.lower_pressed, \"no_overlap\":\n                new_pos = min(new_pos, self.upper_val - 1)\n                self.set_lower_pos(new_pos)\n            case self.lower_pressed, \"free\" if new_pos &gt; self.upper_val:\n                self._swap_controls()\n                self.set_upper_pos(new_pos)\n            case self.upper_pressed, \"no_crossing\":\n                new_pos = max(new_pos, self.lower_value)\n                self.set_upper_pos(new_pos)\n            case self.upper_pressed, \"no_overlap\":\n                new_pos = max(new_pos, self.lower_value + 1)\n                self.set_upper_pos(new_pos)\n            case self.upper_pressed, \"free\" if new_pos &lt; self.lower_val:\n                self._swap_controls()\n                self.set_lower_pos(new_pos)\n        event.accept()\n\n    def mouseReleaseEvent(self, event):\n        super().mouseReleaseEvent(event)\n        self.setSliderDown(False)\n        self.lower_pressed = self.upper_pressed = widgets.Style.SubControl.SC_None\n        self.update()\n\n    def paintEvent(self, event):\n        painter = widgets.StylePainter(self)\n\n        # ticks\n        opt = widgets.StyleOptionSlider()\n        self.initStyleOption(opt)\n        opt.subControls = widgets.Style.SubControl.SC_SliderTickmarks\n        painter.draw_complex_control(\"slider\", opt)\n\n        # groove\n        opt.sliderPosition = 20\n        opt.sliderValue = 0\n        opt.subControls = GROOVE_STYLE\n        painter.draw_complex_control(\"slider\", opt)\n\n        # handle rects\n        opt.sliderPosition = self.lower_pos\n        lr = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\n        lrv = self.pick(lr.center())\n        opt.sliderPosition = self.upper_pos\n        ur = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\n        urv = self.pick(ur.center())\n\n        # span\n        minv = min(lrv, urv)\n        maxv = max(lrv, urv)\n        c = self.style().subControlRect(SLIDER_STYLE, opt, GROOVE_STYLE, self).center()\n        if self.is_horizontal():\n            rect = core.Rect(core.Point(minv, c.y() - 2), core.Point(maxv, c.y() + 1))\n        else:\n            rect = core.Rect(core.Point(c.x() - 2, minv), core.Point(c.x() + 1, maxv))\n        self._draw_span(painter, rect)\n\n        # handles\n        if self.last_pressed == \"lower\":\n            self.draw_handle(painter, \"upper\")\n            self.draw_handle(painter, \"lower\")\n        else:\n            self.draw_handle(painter, \"lower\")\n            self.draw_handle(painter, \"upper\")\n\n    @core.Property(float)\n    def lower_value(self) -&gt; float:\n        return min(self.lower_val, self.upper_val)\n\n    def set_lower_value(self, lower: float):\n        self.set_span(lower, self.upper_val)\n\n    @core.Property(float)\n    def upper_value(self) -&gt; float:\n        return max(self.lower_val, self.upper_val)\n\n    def set_upper_value(self, upper: float):\n        self.set_span(self.lower_val, upper)\n\n    def on_value_change(self):\n        self.value_changed.emit((self.lower_val, self.upper_val))\n\n    def get_value(self) -&gt; tuple[float, float]:\n        return (self.lower_val, self.upper_val)\n\n    def set_value(self, value: tuple[float, float]):\n        self.set_lower_value(value[0])\n        self.set_upper_value(value[1])\n\n    def get_movement_mode(self) -&gt; MovementModeStr:\n        return self.movement\n\n    def set_movement_mode(self, mode: MovementModeStr):\n\"\"\"Set movement mode.\n\n        Args:\n            mode: movement mode for the main window\n\n        Raises:\n            ValueError: movement mode type does not exist\n        \"\"\"\n        if mode not in MOVEMENT_MODE:\n            raise ValueError(\"Invalid movement mode\")\n        self.movement = mode\n\n    def set_span(self, lower: float, upper: float):\n        low = clamp(min(lower, upper), self.minimum(), self.maximum())\n        upp = clamp(max(lower, upper), self.minimum(), self.maximum())\n        changed = False\n        if low != self.lower_val:\n            self.lower_val = low\n            self.lower_pos = low\n            changed = True\n        if upp != self.upper_val:\n            self.upper_val = upp\n            self.upper_pos = upp\n            changed = True\n        if changed:\n            self.on_value_change()\n            self.update()\n\n    def set_lower_pos(self, lower: float):\n        if self.lower_pos == lower:\n            return\n        self.lower_pos = lower\n        if not self.hasTracking():\n            self.update()\n        if self.isSliderDown():\n            self.lower_pos_changed.emit(lower)\n        if self.hasTracking() and not self._block_tracking:\n            main = self._main_control == \"lower\"\n            self.trigger_action(\"move\", main)\n\n    def set_upper_pos(self, upper: float):\n        if self.upper_pos == upper:\n            return\n        self.upper_pos = upper\n        if not self.hasTracking():\n            self.update()\n        if self.isSliderDown():\n            self.upper_pos_changed.emit(upper)\n        if self.hasTracking() and not self._block_tracking:\n            main = self._main_control == \"upper\"\n            self.trigger_action(\"move\", main)\n\n    def set_left_color(self, color: datatypes.ColorType):\n        self.gradient_left = colors.get_color(color)\n        self.update()\n\n    def set_right_color(self, color: datatypes.ColorType):\n        self.gradient_right = colors.get_color(color)\n        self.update()\n\n    def _move_pressed_handle(self):\n        if self.last_pressed == \"lower\":\n            if self.lower_pos != self.lower_val:\n                main = self._main_control == \"lower\"\n                self.trigger_action(\"move\", main)\n        elif self.last_pressed == \"upper\":\n            if self.upper_pos != self.upper_val:\n                main = self._main_control == \"upper\"\n                self.trigger_action(\"move\", main)\n\n    def pick(self, p: datatypes.PointType) -&gt; int:\n        if isinstance(p, tuple):\n            return p[0] if self.is_horizontal() else p[1]\n        else:\n            return p.x() if self.is_horizontal() else p.y()\n\n    def trigger_action(self, action: ActionStr, main: bool):\n        value = 0.0\n        no = False\n        up = False\n        my_min = self.minimum()\n        my_max = self.maximum()\n        self._block_tracking = True\n        main_control = main and self._main_control == \"upper\"\n        alt_control = not main and self._main_control == \"lower\"\n        is_upper_handle = main_control or alt_control\n        val = self.upper_val if is_upper_handle else self.lower_val\n        match action:\n            case \"single_step_add\":\n                up = is_upper_handle\n                value = clamp(val + self.singleStep(), my_min, my_max)\n            case \"single_step_sub\":\n                up = is_upper_handle\n                value = clamp(val - self.singleStep(), my_min, my_max)\n            case \"to_minimum\":\n                up = is_upper_handle\n                value = my_min\n            case \"to_maximum\":\n                up = is_upper_handle\n                value = my_max\n            case \"move\":\n                up = is_upper_handle\n                no = True\n            case \"none\":\n                no = True\n\n        if not no and not up:\n            match self.movement:\n                case \"no_crossing\":\n                    value = min(value, self.upper_val)\n                case \"no_overlap\":\n                    value = min(value, self.upper_val - 1)\n\n                case \"free\" if value &gt; self.upper_val:\n                    self._swap_controls()\n                    self.set_upper_pos(value)\n                case \"free\":\n                    self.set_lower_pos(value)\n        elif not no:\n            match self.movement:\n                case \"no_crossing\":\n                    value = max(value, self.lower_val)\n                case \"no_overlap\":\n                    value = max(value, self.lower_val + 1)\n\n                case \"free\" if value &lt; self.lower_val:\n                    self._swap_controls()\n                    self.set_lower_pos(value)\n                case \"free\":\n                    self.set_upper_pos(value)\n\n        self._block_tracking = False\n        self.set_lower_value(self.lower_pos)\n        self.set_upper_value(self.upper_pos)\n\n    def _swap_controls(self):\n        self.lower_val, self.upper_val = self.upper_val, self.lower_val\n        self.lower_pressed, self.upper_pressed = self.upper_pressed, self.lower_pressed\n        self.last_pressed = \"upper\" if self.last_pressed == \"lower\" else \"lower\"\n        self._main_control = \"upper\" if self._main_control == \"lower\" else \"lower\"\n\n    def update_range(self, min_, max_):\n        # set_span() takes care of keeping span in range\n        self.set_span(self.lower_val, self.upper_val)\n\n    def _setup_painter(\n        self,\n        painter: widgets.StylePainter,\n        orientation: Literal[\"horizontal\", \"vertical\"],\n        x1: int,\n        y1: int,\n        x2: int,\n        y2: int,\n    ):\n        highlight = self.palette().color(gui.Palette.ColorRole.Highlight)\n        gradient = gui.LinearGradient(x1, y1, x2, y2)\n        gradient[0] = highlight.darker(120)\n        gradient[1] = highlight.lighter(108)\n        painter.setBrush(gradient)\n\n        val = 130 if orientation == \"horizontal\" else 150\n        painter.set_pen(color=highlight.darker(val), width=0)\n\n    def _draw_span(self, painter: widgets.StylePainter, rect: core.Rect):\n        opt = widgets.StyleOptionSlider()\n        self.initStyleOption(opt)\n        painter.set_pen(color=self.gradient_left, width=0)\n        groove = self.style().subControlRect(SLIDER_STYLE, opt, GROOVE_STYLE, self)\n        if opt.is_horizontal():\n            groove.adjust(0, 0, -1, 0)\n            self._setup_painter(\n                painter,\n                opt.get_orientation(),\n                groove.center().x(),\n                groove.top(),\n                groove.center().x(),\n                groove.bottom(),\n            )\n        else:\n            groove.adjust(0, 0, 0, -1)\n            self._setup_painter(\n                painter,\n                opt.get_orientation(),\n                groove.left(),\n                groove.center().y(),\n                groove.right(),\n                groove.center().y(),\n            )\n\n        # draw groove\n        intersected = core.RectF(rect.intersected(groove))\n        gradient = gui.LinearGradient(intersected.topLeft(), intersected.topRight())\n        gradient[0] = self.gradient_left\n        gradient[1] = self.gradient_right\n        painter.fillRect(intersected, gradient)\n\n    def draw_handle(self, painter: widgets.StylePainter, handle: HandleStr):\n        opt = self.get_style_option(handle)\n        opt.subControls = HANDLE_STYLE\n        pressed = self.upper_pressed\n        if handle == \"lower\":\n            pressed = self.lower_pressed\n\n        if pressed == HANDLE_STYLE:\n            opt.activeSubControls = pressed\n            opt.state |= widgets.Style.StateFlag.State_Sunken\n        painter.draw_complex_control(\"slider\", opt)\n\n    def get_style_option(self, handle: HandleStr) -&gt; widgets.StyleOptionSlider:\n        option = widgets.StyleOptionSlider()\n        self.initStyleOption(option)\n        if handle == \"lower\":\n            option.sliderPosition = self.lower_pos\n            option.sliderValue = self.lower_val\n        else:\n            option.sliderPosition = self.upper_pos\n            option.sliderValue = self.upper_val\n        return option\n\n    def _handle_mouse_press(\n        self, pos: QtCore.QPoint, control, value: float, handle: HandleStr\n    ):\n        opt = self.get_style_option(handle)\n        old_control = control\n        control = self.style().hitTestComplexControl(\n            SLIDER_STYLE, opt, pos.toPoint(), self\n        )\n        sr = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\n        if control == HANDLE_STYLE:\n            self.position = value\n            self.offset = self.pick(pos - sr.topLeft())\n            self.last_pressed = handle\n            self.setSliderDown(True)\n            self.slider_pressed.emit(handle)\n        if control != old_control:\n            self.update(sr)\n        return control\n\n    def _pixel_pos_to_value(self, pos: int) -&gt; int:\n        opt = widgets.StyleOptionSlider()\n        self.initStyleOption(opt)\n        gr = self.style().subControlRect(SLIDER_STYLE, opt, GROOVE_STYLE, self)\n        sr = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\n        if self.is_horizontal():\n            len_slider = sr.width()\n            slider_min = gr.x()\n            slider_end = gr.right()\n        else:\n            len_slider = sr.height()\n            slider_min = gr.y()\n            slider_end = gr.bottom()\n\n        return widgets.Style.sliderValueFromPosition(\n            self.minimum(),\n            self.maximum(),\n            pos - slider_min,\n            slider_end - len_slider + 1 - slider_min,\n            opt.upsideDown,\n        )\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseMoveEvent","title":"<code>mouseMoveEvent(self, event)</code>","text":"<p>mouseMoveEvent(self, ev: PySide6.QtGui.QMouseEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/spanslider.py</code> <pre><code>def mouseMoveEvent(self, event):\n    if self.lower_pressed != HANDLE_STYLE and self.upper_pressed != HANDLE_STYLE:\n        event.ignore()\n        return\n\n    opt = widgets.StyleOptionSlider()\n    self.initStyleOption(opt)\n    m = self.style().pixelMetric(\n        widgets.Style.PixelMetric.PM_MaximumDragDistance, opt, self\n    )\n    pixel_pos = self.pick(event.position()) - self.offset\n    new_pos = float(self._pixel_pos_to_value(pixel_pos))\n    if m &gt;= 0:\n        r = self.rect().adjusted(-m, -m, m, m)\n        if not r.contains(event.position().toPoint()):\n            new_pos = self.position\n\n    # pick the preferred handle on the first movement\n    if self._first_movement:\n        if self.lower_val == self.upper_val:\n            if new_pos &lt; self.lower_value:\n                self._swap_controls()\n                self._first_movement = False\n        else:\n            self._first_movement = False\n\n    match HANDLE_STYLE, self.movement:\n        case self.lower_pressed, \"no_crossing\":\n            new_pos = min(new_pos, self.upper_val)\n            self.set_lower_pos(new_pos)\n        case self.lower_pressed, \"no_overlap\":\n            new_pos = min(new_pos, self.upper_val - 1)\n            self.set_lower_pos(new_pos)\n        case self.lower_pressed, \"free\" if new_pos &gt; self.upper_val:\n            self._swap_controls()\n            self.set_upper_pos(new_pos)\n        case self.upper_pressed, \"no_crossing\":\n            new_pos = max(new_pos, self.lower_value)\n            self.set_upper_pos(new_pos)\n        case self.upper_pressed, \"no_overlap\":\n            new_pos = max(new_pos, self.lower_value + 1)\n            self.set_upper_pos(new_pos)\n        case self.upper_pressed, \"free\" if new_pos &lt; self.lower_val:\n            self._swap_controls()\n            self.set_lower_pos(new_pos)\n    event.accept()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mousePressEvent","title":"<code>mousePressEvent(self, event)</code>","text":"<p>mousePressEvent(self, ev: PySide6.QtGui.QMouseEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/spanslider.py</code> <pre><code>def mousePressEvent(self, event):\n    if self.minimum() == self.maximum() or event.buttons() ^ event.button():\n        event.ignore()\n        return\n\n    self.upper_pressed = self._handle_mouse_press(\n        event.position(), self.upper_pressed, self.upper_val, \"upper\"\n    )\n    if self.upper_pressed != HANDLE_STYLE:\n        self.lower_pressed = self._handle_mouse_press(\n            event.position(), self.lower_pressed, self.lower_val, \"lower\"\n        )\n\n    self._first_movement = True\n    event.accept()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseReleaseEvent","title":"<code>mouseReleaseEvent(self, event)</code>","text":"<p>mouseReleaseEvent(self, ev: PySide6.QtGui.QMouseEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/spanslider.py</code> <pre><code>def mouseReleaseEvent(self, event):\n    super().mouseReleaseEvent(event)\n    self.setSliderDown(False)\n    self.lower_pressed = self.upper_pressed = widgets.Style.SubControl.SC_None\n    self.update()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.paintEvent","title":"<code>paintEvent(self, event)</code>","text":"<p>paintEvent(self, ev: PySide6.QtGui.QPaintEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/spanslider.py</code> <pre><code>def paintEvent(self, event):\n    painter = widgets.StylePainter(self)\n\n    # ticks\n    opt = widgets.StyleOptionSlider()\n    self.initStyleOption(opt)\n    opt.subControls = widgets.Style.SubControl.SC_SliderTickmarks\n    painter.draw_complex_control(\"slider\", opt)\n\n    # groove\n    opt.sliderPosition = 20\n    opt.sliderValue = 0\n    opt.subControls = GROOVE_STYLE\n    painter.draw_complex_control(\"slider\", opt)\n\n    # handle rects\n    opt.sliderPosition = self.lower_pos\n    lr = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\n    lrv = self.pick(lr.center())\n    opt.sliderPosition = self.upper_pos\n    ur = self.style().subControlRect(SLIDER_STYLE, opt, HANDLE_STYLE, self)\n    urv = self.pick(ur.center())\n\n    # span\n    minv = min(lrv, urv)\n    maxv = max(lrv, urv)\n    c = self.style().subControlRect(SLIDER_STYLE, opt, GROOVE_STYLE, self).center()\n    if self.is_horizontal():\n        rect = core.Rect(core.Point(minv, c.y() - 2), core.Point(maxv, c.y() + 1))\n    else:\n        rect = core.Rect(core.Point(c.x() - 2, minv), core.Point(c.x() + 1, maxv))\n    self._draw_span(painter, rect)\n\n    # handles\n    if self.last_pressed == \"lower\":\n        self.draw_handle(painter, \"upper\")\n        self.draw_handle(painter, \"lower\")\n    else:\n        self.draw_handle(painter, \"lower\")\n        self.draw_handle(painter, \"upper\")\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.set_movement_mode","title":"<code>set_movement_mode(self, mode: MovementModeStr)</code>","text":"<p>Set movement mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>MovementModeStr</code> <p>movement mode for the main window</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>movement mode type does not exist</p> Source code in <code>prettyqt/custom_widgets/spanslider.py</code> <pre><code>def set_movement_mode(self, mode: MovementModeStr):\n\"\"\"Set movement mode.\n\n    Args:\n        mode: movement mode for the main window\n\n    Raises:\n        ValueError: movement mode type does not exist\n    \"\"\"\n    if mode not in MOVEMENT_MODE:\n        raise ValueError(\"Invalid movement mode\")\n    self.movement = mode\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.trigger_action","title":"<code>trigger_action(self, action: ActionStr, main: bool)</code>","text":"<p>Trigger slider action.</p> Source code in <code>prettyqt/custom_widgets/spanslider.py</code> <pre><code>def trigger_action(self, action: ActionStr, main: bool):\n    value = 0.0\n    no = False\n    up = False\n    my_min = self.minimum()\n    my_max = self.maximum()\n    self._block_tracking = True\n    main_control = main and self._main_control == \"upper\"\n    alt_control = not main and self._main_control == \"lower\"\n    is_upper_handle = main_control or alt_control\n    val = self.upper_val if is_upper_handle else self.lower_val\n    match action:\n        case \"single_step_add\":\n            up = is_upper_handle\n            value = clamp(val + self.singleStep(), my_min, my_max)\n        case \"single_step_sub\":\n            up = is_upper_handle\n            value = clamp(val - self.singleStep(), my_min, my_max)\n        case \"to_minimum\":\n            up = is_upper_handle\n            value = my_min\n        case \"to_maximum\":\n            up = is_upper_handle\n            value = my_max\n        case \"move\":\n            up = is_upper_handle\n            no = True\n        case \"none\":\n            no = True\n\n    if not no and not up:\n        match self.movement:\n            case \"no_crossing\":\n                value = min(value, self.upper_val)\n            case \"no_overlap\":\n                value = min(value, self.upper_val - 1)\n\n            case \"free\" if value &gt; self.upper_val:\n                self._swap_controls()\n                self.set_upper_pos(value)\n            case \"free\":\n                self.set_lower_pos(value)\n    elif not no:\n        match self.movement:\n            case \"no_crossing\":\n                value = max(value, self.lower_val)\n            case \"no_overlap\":\n                value = max(value, self.lower_val + 1)\n\n            case \"free\" if value &lt; self.lower_val:\n                self._swap_controls()\n                self.set_lower_pos(value)\n            case \"free\":\n                self.set_upper_pos(value)\n\n    self._block_tracking = False\n    self.set_lower_value(self.lower_pos)\n    self.set_upper_value(self.upper_pos)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.subsequencecompleter","title":"<code>subsequencecompleter</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.subsequencecompleter.SubsequenceCompleter","title":"<code> SubsequenceCompleter            (Completer)         </code>","text":"Source code in <code>prettyqt/custom_widgets/subsequencecompleter.py</code> <pre><code>class SubsequenceCompleter(widgets.Completer):\n\"\"\"QCompleter specialised for subsequence matching.\"\"\"\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        self.local_completion_prefix = \"\"\n        self.source_model = None\n        self.proxy_model = custom_models.SubsequenceSortFilterProxyModel(\n            self.is_case_sensitive(), parent=self\n        )\n        self.proxy_model.set_sort_role(\"user\")\n        self._force_next_update = True\n\n    def setModel(self, model: QtCore.QAbstractItemModel):\n        self.source_model = model\n        self.proxy_model = custom_models.SubsequenceSortFilterProxyModel(\n            self.is_case_sensitive(), parent=self\n        )\n        self.proxy_model.set_sort_role(\"user\")\n        self.proxy_model.set_prefix(self.local_completion_prefix)\n        self.proxy_model.setSourceModel(self.source_model)\n        super().setModel(self.proxy_model)\n        self.proxy_model.invalidate()\n        self.proxy_model.sort(0)\n        self._force_next_update = True\n\n    def update_model(self):\n        count = self.completionCount()\n        if count or len(self.local_completion_prefix) &lt;= 1 or self._force_next_update:\n            self.proxy_model.set_prefix(self.local_completion_prefix)\n            self.proxy_model.invalidate()  # force sorting/filtering\n        if count &gt; 1:\n            self.proxy_model.sort(0)\n        self._force_next_update = False\n\n    def splitPath(self, path: str) -&gt; list[str]:\n        self.local_completion_prefix = path\n        self.update_model()\n        return [\"\"]\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.subsequencecompleter.SubsequenceCompleter.setModel","title":"<code>setModel(self, model: QtCore.QAbstractItemModel)</code>","text":"<p>setModel(self, c: PySide6.QtCore.QAbstractItemModel) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/subsequencecompleter.py</code> <pre><code>def setModel(self, model: QtCore.QAbstractItemModel):\n    self.source_model = model\n    self.proxy_model = custom_models.SubsequenceSortFilterProxyModel(\n        self.is_case_sensitive(), parent=self\n    )\n    self.proxy_model.set_sort_role(\"user\")\n    self.proxy_model.set_prefix(self.local_completion_prefix)\n    self.proxy_model.setSourceModel(self.source_model)\n    super().setModel(self.proxy_model)\n    self.proxy_model.invalidate()\n    self.proxy_model.sort(0)\n    self._force_next_update = True\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.subsequencecompleter.SubsequenceCompleter.splitPath","title":"<code>splitPath(self, path: str) -&gt; list[str]</code>","text":"<p>splitPath(self, path: str) -&gt; List[str]</p> Source code in <code>prettyqt/custom_widgets/subsequencecompleter.py</code> <pre><code>def splitPath(self, path: str) -&gt; list[str]:\n    self.local_completion_prefix = path\n    self.update_model()\n    return [\"\"]\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline","title":"<code>timeline</code>","text":""},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline","title":"<code> Timeline            (Widget)         </code>","text":"Source code in <code>prettyqt/custom_widgets/timeline.py</code> <pre><code>class Timeline(widgets.Widget):\n    position_changed = core.Signal(int)\n    selection_changed = core.Signal(VideoSample)\n\n    def __init__(self, duration: int, length: int):\n        super().__init__()\n        self.set_title(\"Timeline\")\n        self.duration = duration\n        self.length = length\n\n        # Set variables\n        self.set_background_color(BACKGROUND_COLOR)\n        self.set_text_color(TEXT_COLOR)\n        self.set_text_font(FONT)\n        self._position = None\n        self.pointer_time_pos = 0.0\n        self.selected_sample = None\n        self._clicking = False  # Check if mouse left button is being pressed\n        self._is_in = False  # check if user is in the widget\n        self.video_samples: list[VideoSample] = []  # List of video samples\n        self.setMouseTracking(True)  # Mouse events\n        self.setAutoFillBackground(True)  # background\n        self.setGeometry(300, 300, self.length, 200)\n\n        # Set Background\n        with self.edit_palette() as pal:\n            pal.set_color(\"window\", self.background_color)\n\n    def __len__(self):\n        return len(self.video_samples)\n\n    def __getitem__(self, index: int) -&gt; VideoSample:\n        return self.video_samples[index]\n\n    def __setitem__(self, index: int, value: VideoSample):\n        self.video_samples[index] = value\n\n    def __add__(self, other: VideoSample) -&gt; Timeline:\n        self.add(other)\n        return self\n\n    def add_sample(\n        self,\n        duration: int,\n        color: datatypes.ColorType = \"yellow\",\n        picture: QtGui.QPixmap | None = None,\n    ) -&gt; VideoSample:\n        sample = VideoSample(duration, color, picture)\n        self.add(sample)\n        return sample\n\n    def add(self, sample: VideoSample):\n        self.video_samples.append(sample)\n\n    def paintEvent(self, event):\n        # Draw time\n        scale = self.get_scale()\n        with gui.Painter(self) as qp:\n            qp.set_color(self.text_color)\n            qp.setFont(self.text_font)\n            qp.use_antialiasing()\n            w = 0\n            while (w := w + 100) &lt;= self.width():\n                time_string = helpers.format_seconds(w * scale)\n                rect = core.Rect(w - 50, 0, 100, 100)\n                qp.drawText(rect, constants.ALIGN_H_CENTER, time_string)\n            # Draw down line\n            qp.set_pen(color=PEN_COLOR, width=5)\n            qp.drawLine(0, 40, self.width(), 40)\n\n            # Draw dash lines\n            point = 0\n            qp.set_pen(color=self.text_color)\n            qp.drawLine(0, 40, self.width(), 40)\n            while point &lt;= self.width():\n                y2 = 30 if point % 30 != 0 else 20\n                qp.drawLine(3 * point, 40, 3 * point, y2)\n                point += 10\n\n            if self._position is not None and self._is_in:\n                qp.drawLine(self._position.x(), 0, self._position.x(), 40)\n\n            poly = gui.Polygon()\n            if self._position is not None:\n                val = self.pointer_time_pos / self.get_scale()\n                line = core.Line(val, 40, val, self.height())\n                poly.add_points((val - 10, 20), (val + 10, 20), (val, 40))\n            else:\n                line = core.Line(0, 0, 0, self.height())\n                poly.add_points((-10, 20), (10, 20), (0, 40))\n\n            # Draw samples\n            t = 0.0\n            for sample in self.video_samples:\n                scaled_dur = sample.duration / scale\n                scaled_t = t / scale\n                t += sample.duration\n                # Clear clip path\n                with qp.clip_path() as path:\n                    rect = core.RectF(scaled_t, 50, scaled_dur, 200)\n                    path.addRoundedRect(rect, 10, 10)\n\n                # Draw sample\n                path = gui.PainterPath()\n                qp.set_pen(color=sample.color)\n                rect = core.RectF(scaled_t, 50, scaled_dur, 50)\n                path.addRoundedRect(rect, 10, 10)\n                sample.start_pos = scaled_t\n                sample.end_pos = scaled_t + scaled_dur\n                qp.fillPath(path, sample.color)\n                qp.drawPath(path)\n\n                # Draw preview pictures\n                if sample.picture is None:\n                    continue\n                pic_width = sample.picture.size().width()\n                if pic_width &lt; scaled_dur:\n                    width = float(pic_width)\n                    pic = sample.picture\n                else:\n                    width = scaled_dur\n                    pic = sample.picture.copy(0, 0, int(scaled_dur), 45)\n                with qp.clip_path() as path:\n                    rect = core.RectF(scaled_t, 52.5, width, 45)\n                    path.addRoundedRect(rect, 10, 10)\n                qp.drawPixmap(int(scaled_t), int(52.5), int(width), 45, pic)\n\n            # Clear clip path\n            with qp.clip_path() as path:\n                path.add_rect(self.rect())\n\n            # Draw pointer\n            qp.set_color(PEN_COLOR)\n            qp.set_brush(PEN_COLOR)\n\n            qp.drawPolygon(poly)\n            qp.drawLine(line)\n\n    def mouseMoveEvent(self, e):\n        self._position = e.position()\n\n        # if mouse is being pressed, update pointer\n        if self._clicking:\n            x = self._position.x()\n            self.position_changed.emit(x)\n            self._check_selection(x)\n            self.pointer_time_pos = x * self.get_scale()\n\n        self.update()\n\n    def mousePressEvent(self, e):\n        if e.button() == QtCore.Qt.MouseButton.LeftButton:\n            x = e.position().x()\n            self.position_changed.emit(x)\n            self.pointer_time_pos = x * self.get_scale()\n\n            self._check_selection(x)\n\n            self.update()\n            self._clicking = True  # Set clicking check to true\n\n    def mouseReleaseEvent(self, e):\n        if e.button() == QtCore.Qt.MouseButton.LeftButton:\n            self._clicking = False  # Set clicking check to false\n\n    def enterEvent(self, e):\n        self._is_in = True\n\n    def leaveEvent(self, e):\n        self._is_in = False\n        self.update()\n\n    def _check_selection(self, x: int):\n        # Check if user clicked in video sample\n        for sample in self.video_samples:\n            if sample.start_pos &lt; x &lt; sample.end_pos:\n                sample.color = gui.Color(PEN_COLOR)\n                if self.selected_sample is not sample:\n                    self.selected_sample = sample\n                    self.selection_changed.emit(sample)\n            else:\n                sample.color = sample.def_color\n\n    def get_scale(self) -&gt; float:\n        return self.duration / self.width()\n\n    def set_background_color(self, color: datatypes.ColorType):\n        color = colors.get_color(color)\n        self.background_color = color\n\n    def set_text_color(self, color: datatypes.ColorType):\n        color = colors.get_color(color)\n        self.text_color = color\n\n    def set_text_font(self, font: QtGui.QFont):\n        self.text_font = font\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.enterEvent","title":"<code>enterEvent(self, e)</code>","text":"<p>enterEvent(self, event: PySide6.QtGui.QEnterEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/timeline.py</code> <pre><code>def enterEvent(self, e):\n    self._is_in = True\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.leaveEvent","title":"<code>leaveEvent(self, e)</code>","text":"<p>leaveEvent(self, event: PySide6.QtCore.QEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/timeline.py</code> <pre><code>def leaveEvent(self, e):\n    self._is_in = False\n    self.update()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mouseMoveEvent","title":"<code>mouseMoveEvent(self, e)</code>","text":"<p>mouseMoveEvent(self, event: PySide6.QtGui.QMouseEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/timeline.py</code> <pre><code>def mouseMoveEvent(self, e):\n    self._position = e.position()\n\n    # if mouse is being pressed, update pointer\n    if self._clicking:\n        x = self._position.x()\n        self.position_changed.emit(x)\n        self._check_selection(x)\n        self.pointer_time_pos = x * self.get_scale()\n\n    self.update()\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mousePressEvent","title":"<code>mousePressEvent(self, e)</code>","text":"<p>mousePressEvent(self, event: PySide6.QtGui.QMouseEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/timeline.py</code> <pre><code>def mousePressEvent(self, e):\n    if e.button() == QtCore.Qt.MouseButton.LeftButton:\n        x = e.position().x()\n        self.position_changed.emit(x)\n        self.pointer_time_pos = x * self.get_scale()\n\n        self._check_selection(x)\n\n        self.update()\n        self._clicking = True  # Set clicking check to true\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mouseReleaseEvent","title":"<code>mouseReleaseEvent(self, e)</code>","text":"<p>mouseReleaseEvent(self, event: PySide6.QtGui.QMouseEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/timeline.py</code> <pre><code>def mouseReleaseEvent(self, e):\n    if e.button() == QtCore.Qt.MouseButton.LeftButton:\n        self._clicking = False  # Set clicking check to false\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.paintEvent","title":"<code>paintEvent(self, event)</code>","text":"<p>paintEvent(self, event: PySide6.QtGui.QPaintEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/timeline.py</code> <pre><code>def paintEvent(self, event):\n    # Draw time\n    scale = self.get_scale()\n    with gui.Painter(self) as qp:\n        qp.set_color(self.text_color)\n        qp.setFont(self.text_font)\n        qp.use_antialiasing()\n        w = 0\n        while (w := w + 100) &lt;= self.width():\n            time_string = helpers.format_seconds(w * scale)\n            rect = core.Rect(w - 50, 0, 100, 100)\n            qp.drawText(rect, constants.ALIGN_H_CENTER, time_string)\n        # Draw down line\n        qp.set_pen(color=PEN_COLOR, width=5)\n        qp.drawLine(0, 40, self.width(), 40)\n\n        # Draw dash lines\n        point = 0\n        qp.set_pen(color=self.text_color)\n        qp.drawLine(0, 40, self.width(), 40)\n        while point &lt;= self.width():\n            y2 = 30 if point % 30 != 0 else 20\n            qp.drawLine(3 * point, 40, 3 * point, y2)\n            point += 10\n\n        if self._position is not None and self._is_in:\n            qp.drawLine(self._position.x(), 0, self._position.x(), 40)\n\n        poly = gui.Polygon()\n        if self._position is not None:\n            val = self.pointer_time_pos / self.get_scale()\n            line = core.Line(val, 40, val, self.height())\n            poly.add_points((val - 10, 20), (val + 10, 20), (val, 40))\n        else:\n            line = core.Line(0, 0, 0, self.height())\n            poly.add_points((-10, 20), (10, 20), (0, 40))\n\n        # Draw samples\n        t = 0.0\n        for sample in self.video_samples:\n            scaled_dur = sample.duration / scale\n            scaled_t = t / scale\n            t += sample.duration\n            # Clear clip path\n            with qp.clip_path() as path:\n                rect = core.RectF(scaled_t, 50, scaled_dur, 200)\n                path.addRoundedRect(rect, 10, 10)\n\n            # Draw sample\n            path = gui.PainterPath()\n            qp.set_pen(color=sample.color)\n            rect = core.RectF(scaled_t, 50, scaled_dur, 50)\n            path.addRoundedRect(rect, 10, 10)\n            sample.start_pos = scaled_t\n            sample.end_pos = scaled_t + scaled_dur\n            qp.fillPath(path, sample.color)\n            qp.drawPath(path)\n\n            # Draw preview pictures\n            if sample.picture is None:\n                continue\n            pic_width = sample.picture.size().width()\n            if pic_width &lt; scaled_dur:\n                width = float(pic_width)\n                pic = sample.picture\n            else:\n                width = scaled_dur\n                pic = sample.picture.copy(0, 0, int(scaled_dur), 45)\n            with qp.clip_path() as path:\n                rect = core.RectF(scaled_t, 52.5, width, 45)\n                path.addRoundedRect(rect, 10, 10)\n            qp.drawPixmap(int(scaled_t), int(52.5), int(width), 45, pic)\n\n        # Clear clip path\n        with qp.clip_path() as path:\n            path.add_rect(self.rect())\n\n        # Draw pointer\n        qp.set_color(PEN_COLOR)\n        qp.set_brush(PEN_COLOR)\n\n        qp.drawPolygon(poly)\n        qp.drawLine(line)\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner","title":"<code>waitingspinner</code>","text":"<p>The MIT License (MIT).</p> <p>Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner","title":"<code> BaseWaitingSpinner            (Widget)         </code>","text":"Source code in <code>prettyqt/custom_widgets/waitingspinner.py</code> <pre><code>class BaseWaitingSpinner(widgets.Widget):\n    def __init__(\n        self,\n        parent: QtWidgets.QWidget | None,\n        modality: constants.ModalityStr = \"none\",\n    ):\n        super().__init__(parent=parent)\n\n        # WAS IN initialize()\n        self._color = self.get_palette().get_color(\"text\")\n        self._roundness = 100.0\n        self._minimum_trail_opacity = 3.14159265358979323846\n        self._trail_fade_percentage = 80.0\n        self._revolutions_per_second = 1.57079632679489661923\n        self._line_num = 20\n        self._line_length = 10\n        self._line_width = 2\n        self._inner_radius = 10\n        self._current_counter = 0\n        self._timer = core.Timer(self)\n        self._timer.timeout.connect(self._rotate)\n        self._update_size()\n        self._update_timer()\n        self.hide()\n        # END initialize()\n\n        self.set_modality(modality)\n        # self.setAttribute(QtCore.Qt.WA_TranslucentBackground)\n\n    def paintEvent(self, event):\n        painter = gui.Painter(self)\n        painter.fill_rect(self.rect(), \"transparent\")\n        painter.use_antialiasing()\n\n        if self._current_counter &gt;= self._line_num:\n            self._current_counter = 0\n\n        painter.set_pen(style=\"none\")\n        painter.translate(\n            self._inner_radius + self._line_length, self._inner_radius + self._line_length\n        )\n        for i in range(self._line_num):\n            with painter.backup_state():\n                rotate_angle = 360 * i / self._line_num\n                painter.rotate(rotate_angle)\n                painter.translate(self._inner_radius, 0)\n                distance = self._linecount_distance_from_primary(\n                    i, self._current_counter, self._line_num\n                )\n                color = self._current_line_color(\n                    distance,\n                    self._line_num,\n                    self._trail_fade_percentage,\n                    self._minimum_trail_opacity,\n                    self._color,\n                )\n                painter.setBrush(color)\n                painter.draw_rounded_rect(\n                    (0, -self._line_width / 2, self._line_length, self._line_width),\n                    self._roundness,\n                    self._roundness,\n                    relative=True,\n                )\n\n    def start(self):\n        self.show()\n        if not self._timer.isActive():\n            self._timer.start()\n            self._current_counter = 0\n\n    def stop(self):\n        self.hide()\n        if self._timer.isActive():\n            self._timer.stop()\n            self._current_counter = 0\n\n    def set_line_num(self, lines: int):\n        self._line_num = lines\n        self._current_counter = 0\n        self._update_timer()\n\n    def set_line_length(self, length: int):\n        self._line_length = length\n        self._update_size()\n\n    def set_line_width(self, width: int):\n        self._line_width = width\n\n    def set_inner_radius(self, radius: int):\n        self._inner_radius = radius\n        self._update_size()\n\n    def color(self) -&gt; gui.Color:\n        return self._color\n\n    def roundness(self) -&gt; float:\n        return self._roundness\n\n    def minimum_trail_opacity(self) -&gt; float:\n        return self._minimum_trail_opacity\n\n    def trail_fade_percentage(self) -&gt; float:\n        return self._trail_fade_percentage\n\n    def revolutions_per_second(self) -&gt; float:\n        return self._revolutions_per_second\n\n    def line_num(self) -&gt; int:\n        return self._line_num\n\n    def line_length(self) -&gt; int:\n        return self._line_length\n\n    def line_width(self) -&gt; int:\n        return self._line_width\n\n    def inner_radius(self) -&gt; int:\n        return self._inner_radius\n\n    def is_spinning(self) -&gt; bool:\n        return self._timer.isActive()\n\n    def set_roundness(self, roundness: float):\n        self._roundness = max(0.0, min(100.0, roundness))\n\n    def set_color(self, color: datatypes.ColorType = \"black\"):\n        self._color = colors.get_color(color)\n\n    def set_revolutions_per_second(self, _revolutions_per_second: float):\n        self._revolutions_per_second = _revolutions_per_second\n        self._update_timer()\n\n    def set_trail_fade_percentage(self, trail: float):\n        self._trail_fade_percentage = trail\n\n    def set_minimum_trail_opacity(self, minimum_trail_opacity: float):\n        self._minimum_trail_opacity = minimum_trail_opacity\n\n    def _rotate(self):\n        self._current_counter += 1\n        if self._current_counter &gt;= self._line_num:\n            self._current_counter = 0\n        self.update()\n\n    def _update_size(self):\n        size = (self._inner_radius + self._line_length) * 2\n        self.setFixedSize(size, size)\n\n    def _update_timer(self):\n        divider = int(self._line_num * self._revolutions_per_second)\n        self._timer.setInterval(1000 // divider)\n\n    def _linecount_distance_from_primary(\n        self, current: int, primary: int, total_lines: int\n    ) -&gt; int:\n        distance = primary - current\n        if distance &lt; 0:\n            distance += total_lines\n        return distance\n\n    def _current_line_color(\n        self,\n        count_distance: int,\n        total_lines: int,\n        fade_perc: float,\n        min_opacity: float,\n        color: gui.Color,\n    ) -&gt; gui.Color:\n        color = gui.Color(color)\n        if count_distance == 0:\n            return color\n        min_alpha_f = min_opacity / 100\n        dist_threshold = int(math.ceil((total_lines - 1) * fade_perc / 100))\n        if count_distance &gt; dist_threshold:\n            color.setAlphaF(min_alpha_f)\n        else:\n            alpha = color.alphaF()\n            alpha_diff = alpha - min_alpha_f\n            gradient = alpha_diff / (dist_threshold + 1)\n            result_alpha = alpha - gradient * count_distance\n            # If alpha is out of bounds, clip it.\n            result_alpha = min(1.0, max(0.0, result_alpha))\n            color.setAlphaF(result_alpha)\n        return color\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner.paintEvent","title":"<code>paintEvent(self, event)</code>","text":"<p>paintEvent(self, event: PySide6.QtGui.QPaintEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/waitingspinner.py</code> <pre><code>def paintEvent(self, event):\n    painter = gui.Painter(self)\n    painter.fill_rect(self.rect(), \"transparent\")\n    painter.use_antialiasing()\n\n    if self._current_counter &gt;= self._line_num:\n        self._current_counter = 0\n\n    painter.set_pen(style=\"none\")\n    painter.translate(\n        self._inner_radius + self._line_length, self._inner_radius + self._line_length\n    )\n    for i in range(self._line_num):\n        with painter.backup_state():\n            rotate_angle = 360 * i / self._line_num\n            painter.rotate(rotate_angle)\n            painter.translate(self._inner_radius, 0)\n            distance = self._linecount_distance_from_primary(\n                i, self._current_counter, self._line_num\n            )\n            color = self._current_line_color(\n                distance,\n                self._line_num,\n                self._trail_fade_percentage,\n                self._minimum_trail_opacity,\n                self._color,\n            )\n            painter.setBrush(color)\n            painter.draw_rounded_rect(\n                (0, -self._line_width / 2, self._line_length, self._line_width),\n                self._roundness,\n                self._roundness,\n                relative=True,\n            )\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner","title":"<code> WaitingSpinner            (BaseWaitingSpinner)         </code>","text":"Source code in <code>prettyqt/custom_widgets/waitingspinner.py</code> <pre><code>class WaitingSpinner(BaseWaitingSpinner):\n    def __init__(\n        self,\n        parent: QtWidgets.QWidget | None,\n        center_on_parent: bool = True,\n        disable_parent: bool = True,\n        modality: constants.ModalityStr = \"none\",\n        additional_disabled=None,\n    ):\n        super().__init__(parent=parent, modality=modality)\n        self._center_on_parent = center_on_parent\n        self._disable_parent = disable_parent\n        self.additional_disabled = additional_disabled or []\n\n    def paintEvent(self, event):\n        self._update_position()\n        super().paintEvent(event)\n\n    def start(self):\n        self._update_position()\n        super().start()\n        if self.parentWidget and self._disable_parent:\n            self.parentWidget().setEnabled(False)\n            for item in self.additional_disabled:\n                item.setEnabled(False)\n\n    def stop(self):\n        super().stop()\n        if self.parentWidget() and self._disable_parent:\n            self.parentWidget().setEnabled(True)\n            for item in self.additional_disabled:\n                item.setEnabled(True)\n\n    def _update_position(self):\n        parent = self.parentWidget()\n        if parent and self._center_on_parent:\n            self.move(\n                parent.width() // 2 - self.width() // 2,\n                parent.height() // 2 - self.height() // 2,\n            )\n</code></pre>"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner.paintEvent","title":"<code>paintEvent(self, event)</code>","text":"<p>paintEvent(self, event: PySide6.QtGui.QPaintEvent) -&gt; None</p> Source code in <code>prettyqt/custom_widgets/waitingspinner.py</code> <pre><code>def paintEvent(self, event):\n    self._update_position()\n    super().paintEvent(event)\n</code></pre>"},{"location":"api/gui.html","title":"gui module","text":"<p>Gui module.</p> <p>Contains QtGui-based classes</p>"},{"location":"api/gui.html#prettyqt.gui.color","title":"<code>color</code>","text":""},{"location":"api/gui.html#prettyqt.gui.color.Color","title":"<code> Color            (QColor)         </code>","text":"Source code in <code>prettyqt/gui/color.py</code> <pre><code>class Color(QtGui.QColor):\n    def __init__(self, *args):\n        # PySide2 workaround\n        if len(args) == 1:\n            if isinstance(args[0], QtGui.QColor):\n                super().__init__(args[0].name())\n            elif isinstance(args[0], str):\n                super().__init__()\n                self.set_color(args[0])\n            else:\n                super().__init__(*args)\n        else:\n            super().__init__(*args)\n\n    def __repr__(self):\n        return (\n            f\"{type(self).__name__}({self.red()}, {self.green()}, \"\n            f\"{self.blue()}, {self.alpha()})\"\n        )\n\n    def __str__(self):\n        return self.name() if self.alpha() == 255 else self.name(self.NameFormat.HexArgb)\n\n    def __reduce__(self):\n        return type(self), (self.red(), self.green(), self.blue(), self.alpha())\n\n    def serialize_fields(self):\n        return dict(color=self.toString())\n\n    def serialize(self) -&gt; dict[str, Any]:\n        return self.serialize_fields()\n\n    def set_color(self, color: str | tuple):\n        if isinstance(color, str):\n            self.setNamedColor(color)\n        else:\n            self.setRgb(*color)\n\n    @classmethod\n    def from_text(cls, text: str) -&gt; Color:\n\"\"\"Create a QColor from specified string.\"\"\"\n        color = cls()\n        if text.startswith(\"#\") and len(text) == 7:\n            correct = \"#0123456789abcdef\"\n            for char in text:\n                if char.lower() not in correct:\n                    return color\n        elif text not in list(cls.colorNames()):\n            return color\n        color.setNamedColor(text)\n        return color\n\n    @classmethod\n    def from_cmyk(cls, c: float, m: float, y: float, k: float, a: float = 1.0) -&gt; Color:\n        return cls(cls.fromCmykF(c, m, y, k, a))\n\n    @classmethod\n    def from_hsv(cls, h: float, s: float, v: float, a: float = 1.0) -&gt; Color:\n        return cls(cls.fromHsvF(h, s, v, a))\n\n    @classmethod\n    def interpolate_color(\n        cls,\n        start: QtGui.QColor,\n        end: QtGui.QColor,\n        percent: int,\n        colorspace: SpecStr | None = \"rgb\",\n    ) -&gt; Color:\n\"\"\"Get an interpolated color value.\n\n        Args:\n            start: The start color.\n            end: The end color.\n            percent: Which value to get (0 - 100)\n            colorspace: The desired interpolation color system,\n                        QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum)\n                        If None, start is used except when percent is 100.\n\n        Return:\n            The interpolated QColor, with the same spec as the given start color.\n        \"\"\"\n        if colorspace is None:\n            if percent == 100:\n                return cls(*end.getRgb())\n            else:\n                return cls(*start.getRgb())\n        if colorspace not in SPEC:\n            raise InvalidParamError(colorspace, SPEC)\n        out = cls()\n        match colorspace:\n            case \"rgb\":\n                components = helpers.get_color_percentage(\n                    start.getRgb(), end.getRgb(), percent  # type: ignore\n                )\n                out.setRgb(*components)\n            case \"hsv\":\n                components = helpers.get_color_percentage(\n                    start.getHsv(), end.getHsv(), percent  # type: ignore\n                )\n                out.setHsv(*components)\n            case \"hsl\":\n                components = helpers.get_color_percentage(\n                    start.getHsl(), end.getHsl(), percent  # type: ignore\n                )\n                out.setHsl(*components)\n            case _:\n                raise ValueError(\"Invalid colorspace!\")\n        out = out.convertTo(start.spec())\n        return out\n\n    def is_dark(self) -&gt; bool:\n\"\"\"Check whether a color is 'dark'.\"\"\"\n        return self.lightness() &lt; 128\n\n    def get_spec(self) -&gt; SpecStr:\n        return SPEC.inverse[self.spec()]\n\n    def convert_to(self, spec: SpecStr) -&gt; Color:\n        # return Color(self.convertTo(SPEC[spec]))\n        color = Color()\n        match spec:\n            case \"rgb\":\n                rgb = self.getRgb()\n                color.setRgb(*rgb)\n            case \"hsv\":\n                hsv = self.getHsv()\n                color.setHsv(*hsv)\n            case \"cmyk\":\n                cmyk = self.getCmyk()\n                color.setCmyk(*cmyk)\n            case \"hsl\":\n                hsl = self.getHsl()\n                color.setHsl(*hsl)\n            case \"extended_rgb\":\n                ergb = self.getRgbF()\n                color.setRgbF(*ergb)\n        return color\n\n    def get_name(self, name_format: NameStr = \"hex_argb\") -&gt; str:\n        match name_format:\n            case \"svg_rgb\" | \"svg_argb\" if not self.isValid():\n                return 'fill=\"\"'\n            case \"svg_rgb\":\n                return f'fill=\"rgb({self.red()}, {self.green()}, {self.blue()})\"'\n            case \"svg_argb\":\n                fill_str = f\"rgb({self.red()}, {self.green()}, {self.blue()})\"\n                return f'fill=\"{fill_str}\" fill-opacity=\"{self.alpha()}\"'\n            case \"qcss_argb\":\n                return (\n                    f\"rgba({self.red()}, {self.green()}, {self.blue()}, {self.alpha()})\"\n                )\n            case \"qcss_rgb\":\n                return f\"rgb({self.red()}, {self.green()}, {self.blue()})\"\n            case _:\n                return self.name(NAME_FORMAT[name_format])\n\n    @deprecated(reason=\"This method is deprecated, use Color.get_name instead.\")\n    def to_qsscolor(self) -&gt; str:\n\"\"\"Convert Color to a string that can be used in a QStyleSheet.\"\"\"\n        return f\"rgba({self.red()}, {self.green()}, {self.blue()}, {self.alpha()})\"\n\n    def as_qt(self) -&gt; QtGui.QColor:\n        return self.convertTo(self.spec())\n\n    def inverted(self, invert_alpha: bool = False) -&gt; Color:\n        return Color(\n            255 - self.red(),\n            255 - self.green(),\n            255 - self.blue(),\n            255 - self.alpha() if invert_alpha else self.alpha(),\n        )\n\n    @classmethod\n    def drift_color(cls, color: datatypes.ColorAndBrushType, factor: int = 110):\n\"\"\"Return color that is lighter or darker than the base color.\n\n        If base_color.lightness is higher than 128, the returned color is darker\n        otherwise is is lighter.\n        :param base_color: The base color to drift from\n        ;:param factor: drift factor (%)\n        :return A lighter or darker color.\n        \"\"\"\n        base_color = cls(color)\n        if base_color.lightness() &gt; 128:\n            return base_color.darker(factor)\n        else:\n            if base_color == Color(\"#000000\"):\n                return cls.drift_color(cls(\"#101010\"), factor + 20)\n            else:\n                return base_color.lighter(factor + 10)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.drift_color","title":"<code>drift_color(color: datatypes.ColorAndBrushType, factor: int = 110)</code>  <code>classmethod</code>","text":"<p>Return color that is lighter or darker than the base color.</p> <p>If base_color.lightness is higher than 128, the returned color is darker otherwise is is lighter. :param base_color: The base color to drift from ;:param factor: drift factor (%) :return A lighter or darker color.</p> Source code in <code>prettyqt/gui/color.py</code> <pre><code>@classmethod\ndef drift_color(cls, color: datatypes.ColorAndBrushType, factor: int = 110):\n\"\"\"Return color that is lighter or darker than the base color.\n\n    If base_color.lightness is higher than 128, the returned color is darker\n    otherwise is is lighter.\n    :param base_color: The base color to drift from\n    ;:param factor: drift factor (%)\n    :return A lighter or darker color.\n    \"\"\"\n    base_color = cls(color)\n    if base_color.lightness() &gt; 128:\n        return base_color.darker(factor)\n    else:\n        if base_color == Color(\"#000000\"):\n            return cls.drift_color(cls(\"#101010\"), factor + 20)\n        else:\n            return base_color.lighter(factor + 10)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.from_text","title":"<code>from_text(text: str) -&gt; Color</code>  <code>classmethod</code>","text":"<p>Create a QColor from specified string.</p> Source code in <code>prettyqt/gui/color.py</code> <pre><code>@classmethod\ndef from_text(cls, text: str) -&gt; Color:\n\"\"\"Create a QColor from specified string.\"\"\"\n    color = cls()\n    if text.startswith(\"#\") and len(text) == 7:\n        correct = \"#0123456789abcdef\"\n        for char in text:\n            if char.lower() not in correct:\n                return color\n    elif text not in list(cls.colorNames()):\n        return color\n    color.setNamedColor(text)\n    return color\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.interpolate_color","title":"<code>interpolate_color(start: QtGui.QColor, end: QtGui.QColor, percent: int, colorspace: SpecStr | None = 'rgb') -&gt; Color</code>  <code>classmethod</code>","text":"<p>Get an interpolated color value.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>QtGui.QColor</code> <p>The start color.</p> required <code>end</code> <code>QtGui.QColor</code> <p>The end color.</p> required <code>percent</code> <code>int</code> <p>Which value to get (0 - 100)</p> required <code>colorspace</code> <code>SpecStr | None</code> <p>The desired interpolation color system,         QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum)         If None, start is used except when percent is 100.</p> <code>'rgb'</code> <p>Returns:</p> Type Description <code>Color</code> <p>The interpolated QColor, with the same spec as the given start color.</p> Source code in <code>prettyqt/gui/color.py</code> <pre><code>@classmethod\ndef interpolate_color(\n    cls,\n    start: QtGui.QColor,\n    end: QtGui.QColor,\n    percent: int,\n    colorspace: SpecStr | None = \"rgb\",\n) -&gt; Color:\n\"\"\"Get an interpolated color value.\n\n    Args:\n        start: The start color.\n        end: The end color.\n        percent: Which value to get (0 - 100)\n        colorspace: The desired interpolation color system,\n                    QColor::{Rgb,Hsv,Hsl} (from QColor::Spec enum)\n                    If None, start is used except when percent is 100.\n\n    Return:\n        The interpolated QColor, with the same spec as the given start color.\n    \"\"\"\n    if colorspace is None:\n        if percent == 100:\n            return cls(*end.getRgb())\n        else:\n            return cls(*start.getRgb())\n    if colorspace not in SPEC:\n        raise InvalidParamError(colorspace, SPEC)\n    out = cls()\n    match colorspace:\n        case \"rgb\":\n            components = helpers.get_color_percentage(\n                start.getRgb(), end.getRgb(), percent  # type: ignore\n            )\n            out.setRgb(*components)\n        case \"hsv\":\n            components = helpers.get_color_percentage(\n                start.getHsv(), end.getHsv(), percent  # type: ignore\n            )\n            out.setHsv(*components)\n        case \"hsl\":\n            components = helpers.get_color_percentage(\n                start.getHsl(), end.getHsl(), percent  # type: ignore\n            )\n            out.setHsl(*components)\n        case _:\n            raise ValueError(\"Invalid colorspace!\")\n    out = out.convertTo(start.spec())\n    return out\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.is_dark","title":"<code>is_dark(self) -&gt; bool</code>","text":"<p>Check whether a color is 'dark'.</p> Source code in <code>prettyqt/gui/color.py</code> <pre><code>def is_dark(self) -&gt; bool:\n\"\"\"Check whether a color is 'dark'.\"\"\"\n    return self.lightness() &lt; 128\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.color.Color.to_qsscolor","title":"<code>to_qsscolor(self) -&gt; str</code>","text":"<p>Convert Color to a string that can be used in a QStyleSheet.</p> Source code in <code>prettyqt/gui/color.py</code> <pre><code>@deprecated(reason=\"This method is deprecated, use Color.get_name instead.\")\ndef to_qsscolor(self) -&gt; str:\n\"\"\"Convert Color to a string that can be used in a QStyleSheet.\"\"\"\n    return f\"rgba({self.red()}, {self.green()}, {self.blue()}, {self.alpha()})\"\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace","title":"<code>colorspace</code>","text":""},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace","title":"<code> ColorSpace            (QColorSpace)         </code>","text":"Source code in <code>prettyqt/gui/colorspace.py</code> <pre><code>class ColorSpace(QtGui.QColorSpace):\n    def __getstate__(self):\n        return bytes(self)\n\n    def __setstate__(self, ba):\n        super().__init__()\n        core.DataStream.write_bytearray(ba, self)\n\n    def __bytes__(self):\n        ba = core.DataStream.create_bytearray(self)\n        return bytes(ba)\n\n    def __bool__(self):\n        return self.isValid()\n\n    def set_primaries(self, primaries: PrimariesStr):\n\"\"\"Set primaries.\n\n        Args:\n            primaries: primaries to use\n\n        Raises:\n            InvalidParamError: primaries do not exist\n        \"\"\"\n        if primaries not in PRIMARIES:\n            raise InvalidParamError(primaries, PRIMARIES)\n        self.setPrimaries(PRIMARIES[primaries])\n\n    def get_primaries(self) -&gt; PrimariesStr:\n\"\"\"Return current primaries.\n\n        Returns:\n            primaries\n        \"\"\"\n        return PRIMARIES.inverse[self.primaries()]\n\n    def set_transfer_function(self, fn: TransformFunctionStr, gamma: float = 0.0):\n\"\"\"Set transfer function.\n\n        Args:\n            fn: transfer function to use\n            gamma: gamma value\n\n        Raises:\n            InvalidParamError: transfer function do not exist\n        \"\"\"\n        if fn not in TRANSFER_FUNCTION:\n            raise InvalidParamError(fn, TRANSFER_FUNCTION)\n        self.setTransferFunction(TRANSFER_FUNCTION[fn], gamma)\n\n    def get_transfer_function(self) -&gt; TransformFunctionStr:\n\"\"\"Return current transfer function.\n\n        Returns:\n            transfer function\n        \"\"\"\n        return TRANSFER_FUNCTION.inverse[self.transferFunction()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_primaries","title":"<code>get_primaries(self) -&gt; PrimariesStr</code>","text":"<p>Return current primaries.</p> <p>Returns:</p> Type Description <code>PrimariesStr</code> <p>primaries</p> Source code in <code>prettyqt/gui/colorspace.py</code> <pre><code>def get_primaries(self) -&gt; PrimariesStr:\n\"\"\"Return current primaries.\n\n    Returns:\n        primaries\n    \"\"\"\n    return PRIMARIES.inverse[self.primaries()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_transfer_function","title":"<code>get_transfer_function(self) -&gt; TransformFunctionStr</code>","text":"<p>Return current transfer function.</p> <p>Returns:</p> Type Description <code>TransformFunctionStr</code> <p>transfer function</p> Source code in <code>prettyqt/gui/colorspace.py</code> <pre><code>def get_transfer_function(self) -&gt; TransformFunctionStr:\n\"\"\"Return current transfer function.\n\n    Returns:\n        transfer function\n    \"\"\"\n    return TRANSFER_FUNCTION.inverse[self.transferFunction()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_primaries","title":"<code>set_primaries(self, primaries: PrimariesStr)</code>","text":"<p>Set primaries.</p> <p>Parameters:</p> Name Type Description Default <code>primaries</code> <code>PrimariesStr</code> <p>primaries to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>primaries do not exist</p> Source code in <code>prettyqt/gui/colorspace.py</code> <pre><code>def set_primaries(self, primaries: PrimariesStr):\n\"\"\"Set primaries.\n\n    Args:\n        primaries: primaries to use\n\n    Raises:\n        InvalidParamError: primaries do not exist\n    \"\"\"\n    if primaries not in PRIMARIES:\n        raise InvalidParamError(primaries, PRIMARIES)\n    self.setPrimaries(PRIMARIES[primaries])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_transfer_function","title":"<code>set_transfer_function(self, fn: TransformFunctionStr, gamma: float = 0.0)</code>","text":"<p>Set transfer function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>TransformFunctionStr</code> <p>transfer function to use</p> required <code>gamma</code> <code>float</code> <p>gamma value</p> <code>0.0</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>transfer function do not exist</p> Source code in <code>prettyqt/gui/colorspace.py</code> <pre><code>def set_transfer_function(self, fn: TransformFunctionStr, gamma: float = 0.0):\n\"\"\"Set transfer function.\n\n    Args:\n        fn: transfer function to use\n        gamma: gamma value\n\n    Raises:\n        InvalidParamError: transfer function do not exist\n    \"\"\"\n    if fn not in TRANSFER_FUNCTION:\n        raise InvalidParamError(fn, TRANSFER_FUNCTION)\n    self.setTransferFunction(TRANSFER_FUNCTION[fn], gamma)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.cursor","title":"<code>cursor</code>","text":""},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor","title":"<code> Cursor            (QCursor)         </code>","text":"Source code in <code>prettyqt/gui/cursor.py</code> <pre><code>class Cursor(QtGui.QCursor):\n    def __getstate__(self):\n        return bytes(self)\n\n    def __setstate__(self, ba):\n        super().__init__()\n        core.DataStream.write_bytearray(ba, self)\n\n    def __bytes__(self):\n        ba = core.DataStream.create_bytearray(self)\n        return bytes(ba)\n\n    def serialize_fields(self) -&gt; dict[str, Any]:\n        return dict(shape=self.get_shape())\n\n    def set_shape(self, shape: constants.CursorShapeStr):\n\"\"\"Set cursor shape.\n\n        Args:\n            shape: shape to use\n\n        Raises:\n            InvalidParamError: shape does not exist\n        \"\"\"\n        if shape not in constants.CURSOR_SHAPE:\n            raise InvalidParamError(shape, constants.CURSOR_SHAPE)\n        self.setShape(constants.CURSOR_SHAPE[shape])\n\n    def get_shape(self) -&gt; constants.CursorShapeStr:\n\"\"\"Return current cursor shape.\n\n        Returns:\n            cursor shape\n        \"\"\"\n        return constants.CURSOR_SHAPE.inverse[self.shape()]\n\n    @classmethod\n    def get_position(cls) -&gt; core.Point:\n        return core.Point(cls.pos())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.get_shape","title":"<code>get_shape(self) -&gt; constants.CursorShapeStr</code>","text":"<p>Return current cursor shape.</p> <p>Returns:</p> Type Description <code>constants.CursorShapeStr</code> <p>cursor shape</p> Source code in <code>prettyqt/gui/cursor.py</code> <pre><code>def get_shape(self) -&gt; constants.CursorShapeStr:\n\"\"\"Return current cursor shape.\n\n    Returns:\n        cursor shape\n    \"\"\"\n    return constants.CURSOR_SHAPE.inverse[self.shape()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.set_shape","title":"<code>set_shape(self, shape: constants.CursorShapeStr)</code>","text":"<p>Set cursor shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>constants.CursorShapeStr</code> <p>shape to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>shape does not exist</p> Source code in <code>prettyqt/gui/cursor.py</code> <pre><code>def set_shape(self, shape: constants.CursorShapeStr):\n\"\"\"Set cursor shape.\n\n    Args:\n        shape: shape to use\n\n    Raises:\n        InvalidParamError: shape does not exist\n    \"\"\"\n    if shape not in constants.CURSOR_SHAPE:\n        raise InvalidParamError(shape, constants.CURSOR_SHAPE)\n    self.setShape(constants.CURSOR_SHAPE[shape])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font","title":"<code>font</code>","text":""},{"location":"api/gui.html#prettyqt.gui.font.Font","title":"<code> Font            (PrettyPrinter, QFont)         </code>","text":"Source code in <code>prettyqt/gui/font.py</code> <pre><code>class Font(prettyprinter.PrettyPrinter, QtGui.QFont):\n    def __repr__(self):\n        return (\n            f\"{type(self).__name__}({self.family()!r}, {self.pointSize()}, \"\n            f\"{self.weight()}, {self.italic()})\"\n        )\n\n    def __getstate__(self):\n        return dict(\n            family=self.family(),\n            pointsize=self.pointSize(),\n            weight=self.weight(),\n            italic=self.italic(),\n        )\n\n    def __setstate__(self, state):\n        self.setFamily(state[\"family\"])\n        if state[\"pointsize\"] &gt; -1:\n            self.setPointSize(state[\"pointsize\"])\n        self.setWeight(state[\"weight\"])\n        self.setItalic(state[\"italic\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def serialize(self) -&gt; dict[str, Any]:\n        return self.__getstate__()\n\n    @property\n    def metrics(self):\n        return gui.FontMetrics(self)\n\n    def set_size(self, size: int):\n        self.setPointSize(size)\n\n    @classmethod\n    def mono(cls, size=8):\n        return cls(\"Consolas\", size)\n        # font.setStyleHint()\n\n    def set_style_hint(self, hint: StyleHintStr):\n\"\"\"Set the style hint.\n\n        Args:\n            hint: style hint\n\n        Raises:\n            InvalidParamError: invalid style hint\n        \"\"\"\n        if hint not in STYLE_HINTS:\n            raise InvalidParamError(hint, STYLE_HINTS)\n        self.setStyleHint(STYLE_HINTS[hint])\n\n    def set_weight(self, weight: WeightStr):\n\"\"\"Set the font weight.\n\n        Args:\n            weight: font weight\n\n        Raises:\n            InvalidParamError: invalid font weight\n        \"\"\"\n        if weight not in WEIGHT:\n            raise InvalidParamError(weight, WEIGHT)\n        self.setWeight(WEIGHT[weight])\n\n    def get_weight(self) -&gt; WeightStr:\n\"\"\"Get current font weight.\n\n        Returns:\n            current font weight\n        \"\"\"\n        return WEIGHT.inverse[self.weight()]\n\n    def set_capitalization(self, capitalization: CapitalizationStr):\n\"\"\"Set the font capitalization.\n\n        Args:\n            capitalization: font capitalization\n\n        Raises:\n            InvalidParamError: invalid font capitalization\n        \"\"\"\n        if capitalization not in CAPITALIZATION:\n            raise InvalidParamError(capitalization, CAPITALIZATION)\n        self.setCapitalization(CAPITALIZATION[capitalization])\n\n    def get_capitalization(self) -&gt; CapitalizationStr:\n\"\"\"Get current font capitalization.\n\n        Returns:\n            current font capitalization\n        \"\"\"\n        return CAPITALIZATION.inverse[self.capitalization()]\n\n    def set_hinting_preference(self, preference: HintingPreferenceStr):\n\"\"\"Set the hinting preference.\n\n        Args:\n            preference: hinting preference\n\n        Raises:\n            InvalidParamError: invalid hinting preference\n        \"\"\"\n        if preference not in HINTING_PREFERENCE:\n            raise InvalidParamError(preference, HINTING_PREFERENCE)\n        self.setHintingPreference(HINTING_PREFERENCE[preference])\n\n    def get_hinting_preference(self) -&gt; HintingPreferenceStr:\n\"\"\"Get current hinting preference.\n\n        Returns:\n            current hinting preference\n        \"\"\"\n        return HINTING_PREFERENCE.inverse[self.hintingPreference()]\n\n    def set_letter_spacing(self, typ: SpacingTypeStr, spacing: float):\n\"\"\"Set the letter spacing.\n\n        Args:\n            typ: letter spacing type\n            spacing: spacing\n\n        Raises:\n            InvalidParamError: invalid letter spacing type\n        \"\"\"\n        if typ not in SPACING_TYPE:\n            raise InvalidParamError(typ, SPACING_TYPE)\n        self.setLetterSpacing(SPACING_TYPE[typ], spacing)\n\n    def get_letter_spacing_type(self) -&gt; SpacingTypeStr:\n\"\"\"Get current letter spacing type.\n\n        Returns:\n            current letter spacing type\n        \"\"\"\n        return SPACING_TYPE.inverse[self.letterSpacingType()]\n\n    def set_style(self, style: StyleStr):\n\"\"\"Set the font style.\n\n        Args:\n            style: font style\n\n        Raises:\n            InvalidParamError: invalid font style\n        \"\"\"\n        if style not in STYLE:\n            raise InvalidParamError(style, STYLE)\n        self.setStyle(STYLE[style])\n\n    def get_style(self) -&gt; StyleStr:\n\"\"\"Get current font style.\n\n        Returns:\n            current font style\n        \"\"\"\n        return STYLE.inverse[self.style()]\n\n    def set_family(self, family: str, fallback: str | None = None):\n\"\"\"Set the font family.\n\n        Args:\n            family: font family\n            fallback: fallback font family\n        \"\"\"\n        self.setFamily(family)\n        font_info = gui.FontInfo(self)\n        if fallback is not None and font_info.family() != family:\n            self.setFamily(fallback)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_capitalization","title":"<code>get_capitalization(self) -&gt; CapitalizationStr</code>","text":"<p>Get current font capitalization.</p> <p>Returns:</p> Type Description <code>CapitalizationStr</code> <p>current font capitalization</p> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def get_capitalization(self) -&gt; CapitalizationStr:\n\"\"\"Get current font capitalization.\n\n    Returns:\n        current font capitalization\n    \"\"\"\n    return CAPITALIZATION.inverse[self.capitalization()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_hinting_preference","title":"<code>get_hinting_preference(self) -&gt; HintingPreferenceStr</code>","text":"<p>Get current hinting preference.</p> <p>Returns:</p> Type Description <code>HintingPreferenceStr</code> <p>current hinting preference</p> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def get_hinting_preference(self) -&gt; HintingPreferenceStr:\n\"\"\"Get current hinting preference.\n\n    Returns:\n        current hinting preference\n    \"\"\"\n    return HINTING_PREFERENCE.inverse[self.hintingPreference()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_letter_spacing_type","title":"<code>get_letter_spacing_type(self) -&gt; SpacingTypeStr</code>","text":"<p>Get current letter spacing type.</p> <p>Returns:</p> Type Description <code>SpacingTypeStr</code> <p>current letter spacing type</p> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def get_letter_spacing_type(self) -&gt; SpacingTypeStr:\n\"\"\"Get current letter spacing type.\n\n    Returns:\n        current letter spacing type\n    \"\"\"\n    return SPACING_TYPE.inverse[self.letterSpacingType()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_style","title":"<code>get_style(self) -&gt; StyleStr</code>","text":"<p>Get current font style.</p> <p>Returns:</p> Type Description <code>StyleStr</code> <p>current font style</p> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def get_style(self) -&gt; StyleStr:\n\"\"\"Get current font style.\n\n    Returns:\n        current font style\n    \"\"\"\n    return STYLE.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_weight","title":"<code>get_weight(self) -&gt; WeightStr</code>","text":"<p>Get current font weight.</p> <p>Returns:</p> Type Description <code>WeightStr</code> <p>current font weight</p> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def get_weight(self) -&gt; WeightStr:\n\"\"\"Get current font weight.\n\n    Returns:\n        current font weight\n    \"\"\"\n    return WEIGHT.inverse[self.weight()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_capitalization","title":"<code>set_capitalization(self, capitalization: CapitalizationStr)</code>","text":"<p>Set the font capitalization.</p> <p>Parameters:</p> Name Type Description Default <code>capitalization</code> <code>CapitalizationStr</code> <p>font capitalization</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid font capitalization</p> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def set_capitalization(self, capitalization: CapitalizationStr):\n\"\"\"Set the font capitalization.\n\n    Args:\n        capitalization: font capitalization\n\n    Raises:\n        InvalidParamError: invalid font capitalization\n    \"\"\"\n    if capitalization not in CAPITALIZATION:\n        raise InvalidParamError(capitalization, CAPITALIZATION)\n    self.setCapitalization(CAPITALIZATION[capitalization])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_family","title":"<code>set_family(self, family: str, fallback: str | None = None)</code>","text":"<p>Set the font family.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <code>str</code> <p>font family</p> required <code>fallback</code> <code>str | None</code> <p>fallback font family</p> <code>None</code> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def set_family(self, family: str, fallback: str | None = None):\n\"\"\"Set the font family.\n\n    Args:\n        family: font family\n        fallback: fallback font family\n    \"\"\"\n    self.setFamily(family)\n    font_info = gui.FontInfo(self)\n    if fallback is not None and font_info.family() != family:\n        self.setFamily(fallback)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_hinting_preference","title":"<code>set_hinting_preference(self, preference: HintingPreferenceStr)</code>","text":"<p>Set the hinting preference.</p> <p>Parameters:</p> Name Type Description Default <code>preference</code> <code>HintingPreferenceStr</code> <p>hinting preference</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid hinting preference</p> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def set_hinting_preference(self, preference: HintingPreferenceStr):\n\"\"\"Set the hinting preference.\n\n    Args:\n        preference: hinting preference\n\n    Raises:\n        InvalidParamError: invalid hinting preference\n    \"\"\"\n    if preference not in HINTING_PREFERENCE:\n        raise InvalidParamError(preference, HINTING_PREFERENCE)\n    self.setHintingPreference(HINTING_PREFERENCE[preference])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_letter_spacing","title":"<code>set_letter_spacing(self, typ: SpacingTypeStr, spacing: float)</code>","text":"<p>Set the letter spacing.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>SpacingTypeStr</code> <p>letter spacing type</p> required <code>spacing</code> <code>float</code> <p>spacing</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid letter spacing type</p> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def set_letter_spacing(self, typ: SpacingTypeStr, spacing: float):\n\"\"\"Set the letter spacing.\n\n    Args:\n        typ: letter spacing type\n        spacing: spacing\n\n    Raises:\n        InvalidParamError: invalid letter spacing type\n    \"\"\"\n    if typ not in SPACING_TYPE:\n        raise InvalidParamError(typ, SPACING_TYPE)\n    self.setLetterSpacing(SPACING_TYPE[typ], spacing)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style","title":"<code>set_style(self, style: StyleStr)</code>","text":"<p>Set the font style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>StyleStr</code> <p>font style</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid font style</p> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def set_style(self, style: StyleStr):\n\"\"\"Set the font style.\n\n    Args:\n        style: font style\n\n    Raises:\n        InvalidParamError: invalid font style\n    \"\"\"\n    if style not in STYLE:\n        raise InvalidParamError(style, STYLE)\n    self.setStyle(STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style_hint","title":"<code>set_style_hint(self, hint: StyleHintStr)</code>","text":"<p>Set the style hint.</p> <p>Parameters:</p> Name Type Description Default <code>hint</code> <code>StyleHintStr</code> <p>style hint</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid style hint</p> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def set_style_hint(self, hint: StyleHintStr):\n\"\"\"Set the style hint.\n\n    Args:\n        hint: style hint\n\n    Raises:\n        InvalidParamError: invalid style hint\n    \"\"\"\n    if hint not in STYLE_HINTS:\n        raise InvalidParamError(hint, STYLE_HINTS)\n    self.setStyleHint(STYLE_HINTS[hint])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_weight","title":"<code>set_weight(self, weight: WeightStr)</code>","text":"<p>Set the font weight.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>WeightStr</code> <p>font weight</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid font weight</p> Source code in <code>prettyqt/gui/font.py</code> <pre><code>def set_weight(self, weight: WeightStr):\n\"\"\"Set the font weight.\n\n    Args:\n        weight: font weight\n\n    Raises:\n        InvalidParamError: invalid font weight\n    \"\"\"\n    if weight not in WEIGHT:\n        raise InvalidParamError(weight, WEIGHT)\n    self.setWeight(WEIGHT[weight])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient","title":"<code>gradient</code>","text":""},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin","title":"<code> GradientMixin        </code>","text":"Source code in <code>prettyqt/gui/gradient.py</code> <pre><code>class GradientMixin:\n    def __setitem__(self, key: float, value):\n        self.setColorAt(key, value)\n\n    def serialize_fields(self):\n        return dict(\n            coordinate_mode=self.get_coordinate_mode(),\n            spread=self.get_spread(),\n            stops=self.get_stops(),\n        )\n\n    def serialize(self) -&gt; dict[str, Any]:\n        return self.serialize_fields()\n\n    def set_coordinate_mode(self, mode: CoordinateModeStr):\n\"\"\"Set the coordinate mode.\n\n        Args:\n            mode: coordinate mode\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in COORDINATE_MODE:\n            raise InvalidParamError(mode, COORDINATE_MODE)\n        self.setCoordinateMode(COORDINATE_MODE[mode])\n\n    def get_coordinate_mode(self) -&gt; CoordinateModeStr:\n\"\"\"Return current coordinate mode.\n\n        Returns:\n            coordinate mode\n        \"\"\"\n        return COORDINATE_MODE.inverse[self.coordinateMode()]\n\n    def set_spread(self, method: SpreadStr):\n\"\"\"Set the spread method.\n\n        Args:\n            method: spread method\n\n        Raises:\n            InvalidParamError: method does not exist\n        \"\"\"\n        if method not in SPREAD:\n            raise InvalidParamError(method, SPREAD)\n        self.setSpread(SPREAD[method])\n\n    def get_spread(self) -&gt; SpreadStr:\n\"\"\"Return current spread method.\n\n        Returns:\n            spread method\n        \"\"\"\n        return SPREAD.inverse[self.spread()]\n\n    def get_type(self) -&gt; TypeStr:\n\"\"\"Return current gradient type.\n\n        Returns:\n            gradient type\n        \"\"\"\n        return TYPE.inverse[self.type()]\n\n    def get_stops(self) -&gt; list[tuple[float, gui.Color]]:\n        return [(i, gui.Color(j)) for (i, j) in self.stops()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.get_coordinate_mode","title":"<code>get_coordinate_mode(self) -&gt; CoordinateModeStr</code>","text":"<p>Return current coordinate mode.</p> <p>Returns:</p> Type Description <code>CoordinateModeStr</code> <p>coordinate mode</p> Source code in <code>prettyqt/gui/gradient.py</code> <pre><code>def get_coordinate_mode(self) -&gt; CoordinateModeStr:\n\"\"\"Return current coordinate mode.\n\n    Returns:\n        coordinate mode\n    \"\"\"\n    return COORDINATE_MODE.inverse[self.coordinateMode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.get_spread","title":"<code>get_spread(self) -&gt; SpreadStr</code>","text":"<p>Return current spread method.</p> <p>Returns:</p> Type Description <code>SpreadStr</code> <p>spread method</p> Source code in <code>prettyqt/gui/gradient.py</code> <pre><code>def get_spread(self) -&gt; SpreadStr:\n\"\"\"Return current spread method.\n\n    Returns:\n        spread method\n    \"\"\"\n    return SPREAD.inverse[self.spread()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.get_type","title":"<code>get_type(self) -&gt; TypeStr</code>","text":"<p>Return current gradient type.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>gradient type</p> Source code in <code>prettyqt/gui/gradient.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return current gradient type.\n\n    Returns:\n        gradient type\n    \"\"\"\n    return TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.set_coordinate_mode","title":"<code>set_coordinate_mode(self, mode: CoordinateModeStr)</code>","text":"<p>Set the coordinate mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CoordinateModeStr</code> <p>coordinate mode</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/gui/gradient.py</code> <pre><code>def set_coordinate_mode(self, mode: CoordinateModeStr):\n\"\"\"Set the coordinate mode.\n\n    Args:\n        mode: coordinate mode\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in COORDINATE_MODE:\n        raise InvalidParamError(mode, COORDINATE_MODE)\n    self.setCoordinateMode(COORDINATE_MODE[mode])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.gradient.GradientMixin.set_spread","title":"<code>set_spread(self, method: SpreadStr)</code>","text":"<p>Set the spread method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>SpreadStr</code> <p>spread method</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>method does not exist</p> Source code in <code>prettyqt/gui/gradient.py</code> <pre><code>def set_spread(self, method: SpreadStr):\n\"\"\"Set the spread method.\n\n    Args:\n        method: spread method\n\n    Raises:\n        InvalidParamError: method does not exist\n    \"\"\"\n    if method not in SPREAD:\n        raise InvalidParamError(method, SPREAD)\n    self.setSpread(SPREAD[method])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication","title":"<code>guiapplication</code>","text":""},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin","title":"<code> GuiApplicationMixin            (CoreApplicationMixin)         </code>","text":"Source code in <code>prettyqt/gui/guiapplication.py</code> <pre><code>class GuiApplicationMixin(core.CoreApplicationMixin):\n    def serialize_fields(self):\n        return dict(icon=self.get_icon())\n\n    @classmethod\n    @contextlib.contextmanager\n    def override_cursor(cls, cursor: constants.CursorShapeStr):\n        cls.set_override_cursor(cursor)\n        yield cursor\n        cls.restore_override_cursor()\n\n    @classmethod\n    def set_override_cursor(cls, cursor: constants.CursorShapeStr):\n        crs = gui.Cursor(constants.CURSOR_SHAPE[cursor])\n        cls.setOverrideCursor(crs)\n\n    @classmethod\n    def restore_override_cursor(cls):\n        cls.restoreOverrideCursor()\n\n    @classmethod\n    def get_clipboard(cls) -&gt; gui.Clipboard:\n        return gui.Clipboard(cls.clipboard())\n\n    @classmethod\n    @contextlib.contextmanager\n    def edit_palette(cls) -&gt; Iterator[gui.Palette]:\n        palette = gui.Palette(cls.palette())\n        yield palette\n        cls.setPalette(palette)\n\n    def set_layout_direction(self, direction: constants.LayoutDirectionStr):\n\"\"\"Set layout direction.\n\n        Args:\n            direction: layout direction\n\n        Raises:\n            InvalidParamError: layout direction does not exist\n        \"\"\"\n        if direction not in constants.LAYOUT_DIRECTION:\n            raise InvalidParamError(direction, constants.LAYOUT_DIRECTION)\n        self.setLayoutDirection(constants.LAYOUT_DIRECTION[direction])\n\n    def get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n\n        Returns:\n            layout direction\n        \"\"\"\n        return constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\n\n    @classmethod\n    def set_high_dpi_scale_factor_rounding_policy(\n        cls, policy: constants.HighDpiScaleFactorRoundingPolicyStr\n    ):\n\"\"\"Set high dpi scale factor rounding policy.\n\n        Args:\n            policy: rounding policy\n\n        Raises:\n            InvalidParamError: rounding policy does not exist\n        \"\"\"\n        if policy not in constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY:\n            raise InvalidParamError(\n                policy, constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY\n            )\n        cls.setHighDpiScaleFactorRoundingPolicy(\n            constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY[policy]\n        )\n\n    @classmethod\n    def get_high_dpi_scale_factor_rounding_policy(\n        cls,\n    ) -&gt; constants.HighDpiScaleFactorRoundingPolicyStr:\n\"\"\"Get the current high dpi scale factor rounding policy.\n\n        Returns:\n            rounding policy\n        \"\"\"\n        return constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY.inverse[\n            cls.highDpiScaleFactorRoundingPolicy()\n        ]\n\n    @classmethod\n    def get_application_state(cls) -&gt; list[constants.ApplicationStateStr]:\n\"\"\"Get the current application state.\n\n        Returns:\n            application state\n        \"\"\"\n        return [\n            k\n            for k, v in constants.APPLICATION_STATES.items()\n            if v &amp; cls.applicationState()  # type: ignore\n        ]\n\n    def get_primary_screen(self) -&gt; gui.Screen:\n        return gui.Screen(self.primaryScreen())\n\n    def get_screen_at(self, point: datatypes.PointType) -&gt; gui.Screen:\n        if isinstance(point, tuple):\n            point = QtCore.QPoint(*point)\n        return gui.Screen(self.screenAt(point))\n\n    def get_screens(self) -&gt; list[gui.Screen]:\n        return [gui.Screen(i) for i in self.screens()]\n\n    @classmethod\n    def get_input_method(cls) -&gt; gui.InputMethod:\n        return gui.InputMethod(cls.inputMethod())\n\n    @classmethod\n    def copy_to_clipboard(cls, text: str):\n\"\"\"Sets clipboard to supplied text.\"\"\"\n        cb = cls.clipboard()\n        cb.clear(mode=cb.Mode.Clipboard)\n        cb.setText(text, mode=cb.Mode.Clipboard)\n\n    @classmethod\n    def get_font(cls) -&gt; gui.Font:\n        return gui.Font(cls.font())\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the default window icon.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\n        self.setWindowIcon(icon)\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.windowIcon()\n        if icon.isNull():\n            return None\n        return gui.Icon(self.windowIcon())\n\n    @classmethod\n    def set_palette(cls, palette: constants.ThemeStr | QtGui.QPalette):\n        if palette == \"default\":\n            pal = gui.Palette()\n        elif palette == \"dark\":\n            pal = gui.Palette.create_dark_palette()\n        else:\n            pal = palette\n        cls.setPalette(pal)\n\n    @classmethod\n    def get_palette(cls) -&gt; gui.Palette:\n        return gui.Palette(cls.palette())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.copy_to_clipboard","title":"<code>copy_to_clipboard(text: str)</code>  <code>classmethod</code>","text":"<p>Sets clipboard to supplied text.</p> Source code in <code>prettyqt/gui/guiapplication.py</code> <pre><code>@classmethod\ndef copy_to_clipboard(cls, text: str):\n\"\"\"Sets clipboard to supplied text.\"\"\"\n    cb = cls.clipboard()\n    cb.clear(mode=cb.Mode.Clipboard)\n    cb.setText(text, mode=cb.Mode.Clipboard)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.get_application_state","title":"<code>get_application_state() -&gt; list[constants.ApplicationStateStr]</code>  <code>classmethod</code>","text":"<p>Get the current application state.</p> <p>Returns:</p> Type Description <code>list[constants.ApplicationStateStr]</code> <p>application state</p> Source code in <code>prettyqt/gui/guiapplication.py</code> <pre><code>@classmethod\ndef get_application_state(cls) -&gt; list[constants.ApplicationStateStr]:\n\"\"\"Get the current application state.\n\n    Returns:\n        application state\n    \"\"\"\n    return [\n        k\n        for k, v in constants.APPLICATION_STATES.items()\n        if v &amp; cls.applicationState()  # type: ignore\n    ]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.get_high_dpi_scale_factor_rounding_policy","title":"<code>get_high_dpi_scale_factor_rounding_policy() -&gt; constants.HighDpiScaleFactorRoundingPolicyStr</code>  <code>classmethod</code>","text":"<p>Get the current high dpi scale factor rounding policy.</p> <p>Returns:</p> Type Description <code>constants.HighDpiScaleFactorRoundingPolicyStr</code> <p>rounding policy</p> Source code in <code>prettyqt/gui/guiapplication.py</code> <pre><code>@classmethod\ndef get_high_dpi_scale_factor_rounding_policy(\n    cls,\n) -&gt; constants.HighDpiScaleFactorRoundingPolicyStr:\n\"\"\"Get the current high dpi scale factor rounding policy.\n\n    Returns:\n        rounding policy\n    \"\"\"\n    return constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY.inverse[\n        cls.highDpiScaleFactorRoundingPolicy()\n    ]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.get_layout_direction","title":"<code>get_layout_direction(self) -&gt; constants.LayoutDirectionStr</code>","text":"<p>Get the current layout direction.</p> <p>Returns:</p> Type Description <code>constants.LayoutDirectionStr</code> <p>layout direction</p> Source code in <code>prettyqt/gui/guiapplication.py</code> <pre><code>def get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n\n    Returns:\n        layout direction\n    \"\"\"\n    return constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.set_high_dpi_scale_factor_rounding_policy","title":"<code>set_high_dpi_scale_factor_rounding_policy(policy: constants.HighDpiScaleFactorRoundingPolicyStr)</code>  <code>classmethod</code>","text":"<p>Set high dpi scale factor rounding policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>constants.HighDpiScaleFactorRoundingPolicyStr</code> <p>rounding policy</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>rounding policy does not exist</p> Source code in <code>prettyqt/gui/guiapplication.py</code> <pre><code>@classmethod\ndef set_high_dpi_scale_factor_rounding_policy(\n    cls, policy: constants.HighDpiScaleFactorRoundingPolicyStr\n):\n\"\"\"Set high dpi scale factor rounding policy.\n\n    Args:\n        policy: rounding policy\n\n    Raises:\n        InvalidParamError: rounding policy does not exist\n    \"\"\"\n    if policy not in constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY:\n        raise InvalidParamError(\n            policy, constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY\n        )\n    cls.setHighDpiScaleFactorRoundingPolicy(\n        constants.HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY[policy]\n    )\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.set_icon","title":"<code>set_icon(self, icon: datatypes.IconType)</code>","text":"<p>Set the default window icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt/gui/guiapplication.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the default window icon.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\n    self.setWindowIcon(icon)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplicationMixin.set_layout_direction","title":"<code>set_layout_direction(self, direction: constants.LayoutDirectionStr)</code>","text":"<p>Set layout direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>constants.LayoutDirectionStr</code> <p>layout direction</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>layout direction does not exist</p> Source code in <code>prettyqt/gui/guiapplication.py</code> <pre><code>def set_layout_direction(self, direction: constants.LayoutDirectionStr):\n\"\"\"Set layout direction.\n\n    Args:\n        direction: layout direction\n\n    Raises:\n        InvalidParamError: layout direction does not exist\n    \"\"\"\n    if direction not in constants.LAYOUT_DIRECTION:\n        raise InvalidParamError(direction, constants.LAYOUT_DIRECTION)\n    self.setLayoutDirection(constants.LAYOUT_DIRECTION[direction])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.icon","title":"<code>icon</code>","text":""},{"location":"api/gui.html#prettyqt.gui.icon.Icon","title":"<code> Icon            (QIcon)         </code>","text":"Source code in <code>prettyqt/gui/icon.py</code> <pre><code>class Icon(QtGui.QIcon):\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    def __bool__(self):\n        return not self.isNull()\n\n    def __getstate__(self):\n        pixmap = self.pixmap(256, 256)\n        return bytes(core.DataStream.create_bytearray(pixmap))\n\n    def __setstate__(self, ba):\n        px = QtGui.QPixmap()\n        core.DataStream.write_bytearray(ba, px)\n        super().__init__(px)\n\n    @classmethod\n    def for_color(cls, color_str: str) -&gt; Icon:\n        color = gui.Color.from_text(color_str)\n        if not color.isValid():\n            raise TypeError()\n        bitmap = gui.Pixmap(16, 16)\n        bitmap.fill(color)\n        return cls(bitmap)\n\n    @classmethod\n    def from_char(cls, char: str, background=\"black\", color=\"white\") -&gt; Icon:\n\"\"\"Create a QIcon with a given character.\"\"\"\n        icon = cls()\n        for size in (16, 32, 64):\n            px = gui.Pixmap.create_char(\n                char, background=background, color=color, size=size\n            )\n            icon.addPixmap(px)\n        return icon\n\n    @classmethod\n    def from_image(cls, image: QtGui.QImage) -&gt; Icon:\n        return cls(gui.Pixmap.fromImage(image))\n\n    def get_available_sizes(\n        self, mode: ModeStr = \"normal\", state: StateStr = \"off\"\n    ) -&gt; list[core.Size]:\n        if mode not in MODE:\n            raise InvalidParamError(mode, MODE)\n        if state not in STATE:\n            raise InvalidParamError(state, STATE)\n        return [core.Size(i) for i in self.availableSizes(MODE[mode], STATE[state])]\n\n    def add_pixmap(\n        self,\n        data: QtCore.QByteArray | QtGui.QPixmap | bytes,\n        mode: ModeStr = \"normal\",\n        state: StateStr = \"off\",\n    ):\n        if mode not in MODE:\n            raise InvalidParamError(mode, MODE)\n        if state not in STATE:\n            raise InvalidParamError(state, STATE)\n        if isinstance(data, bytes):\n            data = QtCore.QByteArray(data)\n        if isinstance(data, QtCore.QByteArray):\n            pixmap = QtGui.QPixmap()\n            pixmap.loadFromData(data)\n        else:\n            pixmap = data\n        self.addPixmap(pixmap, MODE[mode], STATE[state])\n\n    def get_pixmap(\n        self,\n        size: datatypes.SizeType | int,\n        mode: ModeStr = \"normal\",\n        state: StateStr = \"off\",\n    ) -&gt; QtGui.QPixmap:\n        if mode not in MODE:\n            raise InvalidParamError(mode, MODE)\n        if state not in STATE:\n            raise InvalidParamError(state, STATE)\n        if isinstance(size, tuple):\n            size = core.Size(*size)\n        elif isinstance(size, int):\n            size = core.Size(size, size)\n        return self.pixmap(size, MODE[mode], STATE[state])\n\n    def get_actual_size(\n        self,\n        size: datatypes.SizeType | int,\n        mode: ModeStr = \"normal\",\n        state: StateStr = \"off\",\n    ) -&gt; core.Size:\n        if mode not in MODE:\n            raise InvalidParamError(mode, MODE)\n        if state not in STATE:\n            raise InvalidParamError(state, STATE)\n        if isinstance(size, tuple):\n            size = core.Size(*size)\n        elif isinstance(size, int):\n            size = core.Size(size, size)\n        return core.Size(self.actualSize(size, MODE[mode], STATE[state]))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.icon.Icon.from_char","title":"<code>from_char(char: str, background = 'black', color = 'white') -&gt; Icon</code>  <code>classmethod</code>","text":"<p>Create a QIcon with a given character.</p> Source code in <code>prettyqt/gui/icon.py</code> <pre><code>@classmethod\ndef from_char(cls, char: str, background=\"black\", color=\"white\") -&gt; Icon:\n\"\"\"Create a QIcon with a given character.\"\"\"\n    icon = cls()\n    for size in (16, 32, 64):\n        px = gui.Pixmap.create_char(\n            char, background=background, color=color, size=size\n        )\n        icon.addPixmap(px)\n    return icon\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imageiohandler","title":"<code>imageiohandler</code>","text":""},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler","title":"<code> ImageIOHandler            (QImageIOHandler)         </code>","text":"Source code in <code>prettyqt/gui/imageiohandler.py</code> <pre><code>class ImageIOHandler(mod):\n    def __getitem__(self, key: ImageOptionStr) -&gt; datatypes.Variant:\n        return self.get_option(key)\n\n    def __setitem__(self, key: ImageOptionStr, value: datatypes.Variant):\n        self.set_option(key, value)\n\n    def get_format(self) -&gt; str:\n        return bytes(self.format()).decode()\n\n    def set_option(self, option: ImageOptionStr, value: datatypes.Variant):\n\"\"\"Set option to given value.\n\n        Args:\n            option: option to use\n            value: value to set\n\n        Raises:\n            InvalidParamError: option does not exist\n        \"\"\"\n        if option not in IMAGE_OPTION:\n            raise InvalidParamError(option, IMAGE_OPTION)\n        self.setOption(IMAGE_OPTION[option], value)\n\n    def get_option(self, option: ImageOptionStr) -&gt; datatypes.Variant:\n\"\"\"Return the value assigned to option.\n\n        Args:\n            option: option to get\n\n        Returns:\n            option\n        \"\"\"\n        if option not in IMAGE_OPTION:\n            raise InvalidParamError(option, IMAGE_OPTION)\n        return self.option(IMAGE_OPTION[option])\n\n    def supports_option(self, option: ImageOptionStr) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n\n        Args:\n            option: option to check\n\n        Returns:\n            option\n        \"\"\"\n        if option not in IMAGE_OPTION:\n            raise InvalidParamError(option, IMAGE_OPTION)\n        return self.supportsOption(IMAGE_OPTION[option])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.get_option","title":"<code>get_option(self, option: ImageOptionStr) -&gt; datatypes.Variant</code>","text":"<p>Return the value assigned to option.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>ImageOptionStr</code> <p>option to get</p> required <p>Returns:</p> Type Description <code>datatypes.Variant</code> <p>option</p> Source code in <code>prettyqt/gui/imageiohandler.py</code> <pre><code>def get_option(self, option: ImageOptionStr) -&gt; datatypes.Variant:\n\"\"\"Return the value assigned to option.\n\n    Args:\n        option: option to get\n\n    Returns:\n        option\n    \"\"\"\n    if option not in IMAGE_OPTION:\n        raise InvalidParamError(option, IMAGE_OPTION)\n    return self.option(IMAGE_OPTION[option])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.set_option","title":"<code>set_option(self, option: ImageOptionStr, value: datatypes.Variant)</code>","text":"<p>Set option to given value.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>ImageOptionStr</code> <p>option to use</p> required <code>value</code> <code>datatypes.Variant</code> <p>value to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>option does not exist</p> Source code in <code>prettyqt/gui/imageiohandler.py</code> <pre><code>def set_option(self, option: ImageOptionStr, value: datatypes.Variant):\n\"\"\"Set option to given value.\n\n    Args:\n        option: option to use\n        value: value to set\n\n    Raises:\n        InvalidParamError: option does not exist\n    \"\"\"\n    if option not in IMAGE_OPTION:\n        raise InvalidParamError(option, IMAGE_OPTION)\n    self.setOption(IMAGE_OPTION[option], value)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.supports_option","title":"<code>supports_option(self, option: ImageOptionStr) -&gt; bool</code>","text":"<p>Return whether the image handler supports given option.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>ImageOptionStr</code> <p>option to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>option</p> Source code in <code>prettyqt/gui/imageiohandler.py</code> <pre><code>def supports_option(self, option: ImageOptionStr) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n\n    Args:\n        option: option to check\n\n    Returns:\n        option\n    \"\"\"\n    if option not in IMAGE_OPTION:\n        raise InvalidParamError(option, IMAGE_OPTION)\n    return self.supportsOption(IMAGE_OPTION[option])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagereader","title":"<code>imagereader</code>","text":""},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader","title":"<code> ImageReader            (QImageReader)         </code>","text":"Source code in <code>prettyqt/gui/imagereader.py</code> <pre><code>class ImageReader(QtGui.QImageReader):\n    def __getitem__(self, key: str) -&gt; str:\n        return self.text(key)\n\n    def get_error(self) -&gt; ImageReaderErrorStr:\n\"\"\"Return error type.\n\n        Returns:\n            error type\n        \"\"\"\n        return IMAGE_READER_ERROR.inverse[self.error()]\n\n    def get_background_color(self) -&gt; gui.Color:\n        return gui.Color(self.backgroundColor())\n\n    def get_clip_rect(self) -&gt; core.Rect:\n        return core.Rect(self.clipRect())\n\n    def get_current_image_rect(self) -&gt; core.Rect:\n        return core.Rect(self.currentImageRect())\n\n    def get_scaled_clip_rect(self) -&gt; core.Rect:\n        return core.Rect(self.scaledClipRect())\n\n    def get_size(self) -&gt; core.Size:\n        return core.Size(self.size())\n\n    def get_scaled_size(self) -&gt; core.Size:\n        return core.Size(self.scaledSize())\n\n    def get_format(self) -&gt; str:\n        return bytes(self.format()).decode()\n\n    def get_subtype(self) -&gt; str:\n        return bytes(self.subType()).decode()\n\n    def get_supported_subtypes(self) -&gt; list[str]:\n        return [bytes(i).decode() for i in self.supportedSubTypes()]\n\n    def set_format(self, fmt: datatypes.ByteArrayType):\n        if isinstance(fmt, str):\n            fmt = fmt.encode()\n        if isinstance(fmt, bytes):\n            fmt = QtCore.QByteArray(fmt)\n        self.setFormat(fmt)\n\n    def get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n\n        Returns:\n            transformation\n        \"\"\"\n        return gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\n\n    def read_image(self) -&gt; gui.Image:\n        return gui.Image(self.read())\n\n    def supports_option(self, option: gui.imageiohandler.ImageOptionStr) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n\n        Args:\n            option: option to check\n\n        Returns:\n            option\n        \"\"\"\n        if option not in gui.imageiohandler.IMAGE_OPTION:\n            raise InvalidParamError(option, gui.imageiohandler.IMAGE_OPTION)\n        return self.supportsOption(gui.imageiohandler.IMAGE_OPTION[option])\n\n    @staticmethod\n    def get_image_format(obj: str | QtCore.QIODevice) -&gt; str:\n        return bytes(ImageReader.imageFormat(obj)).decode()\n\n    @staticmethod\n    def get_supported_image_formats() -&gt; list[str]:\n        return [bytes(i).decode() for i in ImageReader.supportedImageFormats()]\n\n    @staticmethod\n    def get_supported_mime_types() -&gt; list[str]:\n        return [bytes(i).decode() for i in ImageReader.supportedMimeTypes()]\n\n    @staticmethod\n    def get_image_formats_for_mime_type(typ: datatypes.ByteArrayType) -&gt; list[str]:\n        if isinstance(typ, str):\n            typ = typ.encode()\n        if isinstance(typ, bytes):\n            typ = QtCore.QByteArray(typ)\n        return [bytes(i).decode() for i in ImageReader.imageFormatsForMimeType(typ)]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_error","title":"<code>get_error(self) -&gt; ImageReaderErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ImageReaderErrorStr</code> <p>error type</p> Source code in <code>prettyqt/gui/imagereader.py</code> <pre><code>def get_error(self) -&gt; ImageReaderErrorStr:\n\"\"\"Return error type.\n\n    Returns:\n        error type\n    \"\"\"\n    return IMAGE_READER_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_transformation","title":"<code>get_transformation(self) -&gt; gui.imageiohandler.TransformationStr</code>","text":"<p>Return the transformation and orientation the image has been set to.</p> <p>Returns:</p> Type Description <code>gui.imageiohandler.TransformationStr</code> <p>transformation</p> Source code in <code>prettyqt/gui/imagereader.py</code> <pre><code>def get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n\n    Returns:\n        transformation\n    \"\"\"\n    return gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.supports_option","title":"<code>supports_option(self, option: gui.imageiohandler.ImageOptionStr) -&gt; bool</code>","text":"<p>Return whether the image handler supports given option.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>gui.imageiohandler.ImageOptionStr</code> <p>option to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>option</p> Source code in <code>prettyqt/gui/imagereader.py</code> <pre><code>def supports_option(self, option: gui.imageiohandler.ImageOptionStr) -&gt; bool:\n\"\"\"Return whether the image handler supports given option.\n\n    Args:\n        option: option to check\n\n    Returns:\n        option\n    \"\"\"\n    if option not in gui.imageiohandler.IMAGE_OPTION:\n        raise InvalidParamError(option, gui.imageiohandler.IMAGE_OPTION)\n    return self.supportsOption(gui.imageiohandler.IMAGE_OPTION[option])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagewriter","title":"<code>imagewriter</code>","text":""},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter","title":"<code> ImageWriter            (QImageWriter)         </code>","text":"Source code in <code>prettyqt/gui/imagewriter.py</code> <pre><code>class ImageWriter(QtGui.QImageWriter):\n    def __setitem__(self, key: str, val: str):\n        self.setText(key, val)\n\n    def get_error(self) -&gt; ImageWriterErrorStr:\n\"\"\"Return error type.\n\n        Returns:\n            error type\n        \"\"\"\n        return IMAGE_WRITER_ERROR.inverse[self.error()]\n\n    def get_format(self) -&gt; str:\n        return bytes(self.format()).decode()\n\n    def get_subtype(self) -&gt; str:\n        return bytes(self.subType()).decode()\n\n    def get_supported_image_formats(self) -&gt; list[str]:\n        return [bytes(i).decode() for i in self.supportedImageFormats()]\n\n    def get_supported_subtypes(self) -&gt; list[str]:\n        return [bytes(i).decode() for i in self.supportedSubTypes()]\n\n    def set_subtype(self, subtype: datatypes.ByteArrayType):\n        if isinstance(subtype, str):\n            subtype = subtype.encode()\n        if isinstance(subtype, bytes):\n            subtype = QtCore.QByteArray(subtype)\n        self.setSubType(subtype)\n\n    def set_format(self, fmt: datatypes.ByteArrayType):\n        if isinstance(fmt, str):\n            fmt = fmt.encode()\n        if isinstance(fmt, bytes):\n            fmt = QtCore.QByteArray(fmt)\n        self.setFormat(fmt)\n\n    def set_transformation(self, origin: gui.imageiohandler.TransformationStr):\n\"\"\"Set the image transformations metadata including orientation.\n\n        Args:\n            origin: transformation to use\n\n        Raises:\n            InvalidParamError: transformation does not exist\n        \"\"\"\n        if origin not in gui.imageiohandler.TRANSFORMATION:\n            raise InvalidParamError(origin, gui.imageiohandler.TRANSFORMATION)\n        self.setTransformation(gui.imageiohandler.TRANSFORMATION[origin])\n\n    def get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n\n        Returns:\n            transformation\n        \"\"\"\n        return gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_error","title":"<code>get_error(self) -&gt; ImageWriterErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ImageWriterErrorStr</code> <p>error type</p> Source code in <code>prettyqt/gui/imagewriter.py</code> <pre><code>def get_error(self) -&gt; ImageWriterErrorStr:\n\"\"\"Return error type.\n\n    Returns:\n        error type\n    \"\"\"\n    return IMAGE_WRITER_ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_transformation","title":"<code>get_transformation(self) -&gt; gui.imageiohandler.TransformationStr</code>","text":"<p>Return the transformation and orientation the image has been set to.</p> <p>Returns:</p> Type Description <code>gui.imageiohandler.TransformationStr</code> <p>transformation</p> Source code in <code>prettyqt/gui/imagewriter.py</code> <pre><code>def get_transformation(self) -&gt; gui.imageiohandler.TransformationStr:\n\"\"\"Return the transformation and orientation the image has been set to.\n\n    Returns:\n        transformation\n    \"\"\"\n    return gui.imageiohandler.TRANSFORMATION.inverse[self.transformation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.set_transformation","title":"<code>set_transformation(self, origin: gui.imageiohandler.TransformationStr)</code>","text":"<p>Set the image transformations metadata including orientation.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>gui.imageiohandler.TransformationStr</code> <p>transformation to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>transformation does not exist</p> Source code in <code>prettyqt/gui/imagewriter.py</code> <pre><code>def set_transformation(self, origin: gui.imageiohandler.TransformationStr):\n\"\"\"Set the image transformations metadata including orientation.\n\n    Args:\n        origin: transformation to use\n\n    Raises:\n        InvalidParamError: transformation does not exist\n    \"\"\"\n    if origin not in gui.imageiohandler.TRANSFORMATION:\n        raise InvalidParamError(origin, gui.imageiohandler.TRANSFORMATION)\n    self.setTransformation(gui.imageiohandler.TRANSFORMATION[origin])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.movie","title":"<code>movie</code>","text":""},{"location":"api/gui.html#prettyqt.gui.movie.Movie","title":"<code> Movie            (ObjectMixin, QMovie)         </code>","text":"Source code in <code>prettyqt/gui/movie.py</code> <pre><code>class Movie(core.ObjectMixin, QtGui.QMovie):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.fileName()!r}, {self.get_format()!r})\"\n\n    def serialize_fields(self):\n        return dict(\n            speed=self.speed(),\n            cache_mode=self.get_cache_mode(),\n            scaled_size=self.scaledSize(),\n            background_color=self.backgroundColor(),\n        )\n\n    def set_cache_mode(self, mode: CacheModeStr):\n\"\"\"Set cache mode.\n\n        Args:\n            mode: cache mode\n\n        Raises:\n            InvalidParamError: cache mode does not exist\n        \"\"\"\n        if mode not in CACHE_MODE:\n            raise InvalidParamError(mode, CACHE_MODE)\n        self.setCacheMode(CACHE_MODE[mode])\n\n    def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current cache mode.\n\n        Returns:\n            cache mode\n        \"\"\"\n        return CACHE_MODE.inverse[self.cacheMode()]\n\n    def get_state(self) -&gt; MovieStateStr:\n\"\"\"Get the current state.\n\n        Returns:\n            state\n        \"\"\"\n        return MOVIE_STATE.inverse[self.state()]\n\n    def get_format(self) -&gt; bytes:\n        return bytes(self.format())\n\n    @classmethod\n    def get_supported_formats(cls) -&gt; list[str]:\n        return [bytes(i).decode() for i in cls.supportedFormats()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_cache_mode","title":"<code>get_cache_mode(self) -&gt; CacheModeStr</code>","text":"<p>Get the current cache mode.</p> <p>Returns:</p> Type Description <code>CacheModeStr</code> <p>cache mode</p> Source code in <code>prettyqt/gui/movie.py</code> <pre><code>def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current cache mode.\n\n    Returns:\n        cache mode\n    \"\"\"\n    return CACHE_MODE.inverse[self.cacheMode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_state","title":"<code>get_state(self) -&gt; MovieStateStr</code>","text":"<p>Get the current state.</p> <p>Returns:</p> Type Description <code>MovieStateStr</code> <p>state</p> Source code in <code>prettyqt/gui/movie.py</code> <pre><code>def get_state(self) -&gt; MovieStateStr:\n\"\"\"Get the current state.\n\n    Returns:\n        state\n    \"\"\"\n    return MOVIE_STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.set_cache_mode","title":"<code>set_cache_mode(self, mode: CacheModeStr)</code>","text":"<p>Set cache mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CacheModeStr</code> <p>cache mode</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>cache mode does not exist</p> Source code in <code>prettyqt/gui/movie.py</code> <pre><code>def set_cache_mode(self, mode: CacheModeStr):\n\"\"\"Set cache mode.\n\n    Args:\n        mode: cache mode\n\n    Raises:\n        InvalidParamError: cache mode does not exist\n    \"\"\"\n    if mode not in CACHE_MODE:\n        raise InvalidParamError(mode, CACHE_MODE)\n    self.setCacheMode(CACHE_MODE[mode])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout","title":"<code>pagelayout</code>","text":""},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout","title":"<code> PageLayout            (QPageLayout)         </code>","text":"Source code in <code>prettyqt/gui/pagelayout.py</code> <pre><code>class PageLayout(QtGui.QPageLayout):\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    def serialize_fields(self):\n        return dict(\n            margins=self.margins(),\n            minimum_margins=self.minimumMargins(),\n            mode=self.get_mode(),\n            orientation=self.get_orientation(),\n            page_size=self.get_page_size(),\n            units=self.get_units(),\n        )\n\n    def set_units(self, unit: UnitStr):\n\"\"\"Set unit.\n\n        Args:\n            unit: unit\n\n        Raises:\n            InvalidParamError: unit does not exist\n        \"\"\"\n        if unit not in UNITS:\n            raise InvalidParamError(unit, UNITS)\n        self.setUnits(UNITS[unit])\n\n    def get_units(self) -&gt; UnitStr:\n\"\"\"Get the current unit.\n\n        Returns:\n            unit\n        \"\"\"\n        return UNITS.inverse[self.units()]\n\n    def set_mode(self, mode: ModeStr):\n\"\"\"Set mode.\n\n        Args:\n            mode: mode\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in MODES:\n            raise InvalidParamError(mode, MODES)\n        self.setMode(MODES[mode])\n\n    def get_mode(self) -&gt; ModeStr:\n\"\"\"Get the current mode.\n\n        Returns:\n            mode\n        \"\"\"\n        return MODES.inverse[self.mode()]\n\n    def set_orientation(self, orientation: OrientationStr):\n\"\"\"Set orientation.\n\n        Args:\n            orientation: orientation\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in ORIENTATIONS:\n            raise InvalidParamError(orientation, ORIENTATIONS)\n        self.setOrientation(ORIENTATIONS[orientation])\n\n    def get_orientation(self) -&gt; OrientationStr:\n\"\"\"Get the current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return ORIENTATIONS.inverse[self.orientation()]\n\n    def get_page_size(self) -&gt; gui.PageSize:\n        return gui.PageSize(self.pageSize())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_mode","title":"<code>get_mode(self) -&gt; ModeStr</code>","text":"<p>Get the current mode.</p> <p>Returns:</p> Type Description <code>ModeStr</code> <p>mode</p> Source code in <code>prettyqt/gui/pagelayout.py</code> <pre><code>def get_mode(self) -&gt; ModeStr:\n\"\"\"Get the current mode.\n\n    Returns:\n        mode\n    \"\"\"\n    return MODES.inverse[self.mode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_orientation","title":"<code>get_orientation(self) -&gt; OrientationStr</code>","text":"<p>Get the current orientation.</p> <p>Returns:</p> Type Description <code>OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt/gui/pagelayout.py</code> <pre><code>def get_orientation(self) -&gt; OrientationStr:\n\"\"\"Get the current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return ORIENTATIONS.inverse[self.orientation()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_units","title":"<code>get_units(self) -&gt; UnitStr</code>","text":"<p>Get the current unit.</p> <p>Returns:</p> Type Description <code>UnitStr</code> <p>unit</p> Source code in <code>prettyqt/gui/pagelayout.py</code> <pre><code>def get_units(self) -&gt; UnitStr:\n\"\"\"Get the current unit.\n\n    Returns:\n        unit\n    \"\"\"\n    return UNITS.inverse[self.units()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_mode","title":"<code>set_mode(self, mode: ModeStr)</code>","text":"<p>Set mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ModeStr</code> <p>mode</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/gui/pagelayout.py</code> <pre><code>def set_mode(self, mode: ModeStr):\n\"\"\"Set mode.\n\n    Args:\n        mode: mode\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in MODES:\n        raise InvalidParamError(mode, MODES)\n    self.setMode(MODES[mode])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_orientation","title":"<code>set_orientation(self, orientation: OrientationStr)</code>","text":"<p>Set orientation.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>OrientationStr</code> <p>orientation</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt/gui/pagelayout.py</code> <pre><code>def set_orientation(self, orientation: OrientationStr):\n\"\"\"Set orientation.\n\n    Args:\n        orientation: orientation\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in ORIENTATIONS:\n        raise InvalidParamError(orientation, ORIENTATIONS)\n    self.setOrientation(ORIENTATIONS[orientation])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_units","title":"<code>set_units(self, unit: UnitStr)</code>","text":"<p>Set unit.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>UnitStr</code> <p>unit</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>unit does not exist</p> Source code in <code>prettyqt/gui/pagelayout.py</code> <pre><code>def set_units(self, unit: UnitStr):\n\"\"\"Set unit.\n\n    Args:\n        unit: unit\n\n    Raises:\n        InvalidParamError: unit does not exist\n    \"\"\"\n    if unit not in UNITS:\n        raise InvalidParamError(unit, UNITS)\n    self.setUnits(UNITS[unit])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagesize","title":"<code>pagesize</code>","text":""},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize","title":"<code> PageSize            (QPageSize)         </code>","text":"Source code in <code>prettyqt/gui/pagesize.py</code> <pre><code>class PageSize(QtGui.QPageSize):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.get_id()!r})\"\n\n    def __reduce__(self):\n        return type(self), (self.id(),)\n\n    def get_definition_units(self) -&gt; UnitStr:\n\"\"\"Get the definition unit.\n\n        Returns:\n            unit\n        \"\"\"\n        units = self.definitionUnits()\n        if units.value == -1:\n            raise ValueError(\"Invalid page size\")\n        return UNITS.inverse[units]\n\n    def get_id(self) -&gt; str:\n\"\"\"Get the standard page size id.\n\n        Returns:\n            page size id\n        \"\"\"\n        return PAGE_SIZE_ID.inverse[self.id()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_definition_units","title":"<code>get_definition_units(self) -&gt; UnitStr</code>","text":"<p>Get the definition unit.</p> <p>Returns:</p> Type Description <code>UnitStr</code> <p>unit</p> Source code in <code>prettyqt/gui/pagesize.py</code> <pre><code>def get_definition_units(self) -&gt; UnitStr:\n\"\"\"Get the definition unit.\n\n    Returns:\n        unit\n    \"\"\"\n    units = self.definitionUnits()\n    if units.value == -1:\n        raise ValueError(\"Invalid page size\")\n    return UNITS.inverse[units]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_id","title":"<code>get_id(self) -&gt; str</code>","text":"<p>Get the standard page size id.</p> <p>Returns:</p> Type Description <code>str</code> <p>page size id</p> Source code in <code>prettyqt/gui/pagesize.py</code> <pre><code>def get_id(self) -&gt; str:\n\"\"\"Get the standard page size id.\n\n    Returns:\n        page size id\n    \"\"\"\n    return PAGE_SIZE_ID.inverse[self.id()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.paintdevice","title":"<code>paintdevice</code>","text":""},{"location":"api/gui.html#prettyqt.gui.paintdevice.PaintDeviceMixin","title":"<code> PaintDeviceMixin        </code>","text":"Source code in <code>prettyqt/gui/paintdevice.py</code> <pre><code>class PaintDeviceMixin:\n    def get_metric(self, metric: MetricStr) -&gt; int:\n\"\"\"Return metric information.\n\n        Args:\n            metric: metric information to get\n\n        Returns:\n            metric information\n        \"\"\"\n        if metric not in METRICS:\n            raise InvalidParamError(metric, METRICS)\n        return self.metric(METRICS[metric])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.paintdevice.PaintDeviceMixin.get_metric","title":"<code>get_metric(self, metric: MetricStr) -&gt; int</code>","text":"<p>Return metric information.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>MetricStr</code> <p>metric information to get</p> required <p>Returns:</p> Type Description <code>int</code> <p>metric information</p> Source code in <code>prettyqt/gui/paintdevice.py</code> <pre><code>def get_metric(self, metric: MetricStr) -&gt; int:\n\"\"\"Return metric information.\n\n    Args:\n        metric: metric information to get\n\n    Returns:\n        metric information\n    \"\"\"\n    if metric not in METRICS:\n        raise InvalidParamError(metric, METRICS)\n    return self.metric(METRICS[metric])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter","title":"<code>painter</code>","text":""},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin","title":"<code> PainterMixin        </code>","text":"Source code in <code>prettyqt/gui/painter.py</code> <pre><code>class PainterMixin:\n    def __enter__(self):\n        return self\n\n    def __exit__(self, typ, value, traceback):\n        self.end()\n\n    @contextlib.contextmanager\n    def paint_on(self, obj) -&gt; Iterator[Painter]:\n        self.begin(obj)\n        yield self\n        self.end()\n\n    @contextlib.contextmanager\n    def backup_state(self) -&gt; Iterator[Painter]:\n        self.save()\n        yield self\n        self.restore()\n\n    @contextlib.contextmanager\n    def native_mode(self) -&gt; Iterator[Painter]:\n        self.beginNativePainting()\n        yield self\n        self.endNativePainting()\n\n    @contextlib.contextmanager\n    def edit_pen(self) -&gt; Iterator[gui.Pen]:\n        pen = gui.Pen(self.pen())\n        yield pen\n        self.setPen(pen)\n\n    @contextlib.contextmanager\n    def edit_font(self) -&gt; Iterator[gui.Font]:\n        font = gui.Font(self.font())\n        yield font\n        self.setFont(font)\n\n    def draw_text(\n        self,\n        position: datatypes.PointType | datatypes.RectType | datatypes.RectFType,\n        text: str,\n        alignment: constants.AlignmentStr = \"center\",\n    ):\n        match position:\n            case (_, _):\n                position = core.Point(*position)\n            case (_, _, _, _):\n                position = core.RectF(*position)\n        self.drawText(position, text, constants.ALIGNMENTS[alignment])\n\n    def draw_image(\n        self,\n        target: QtCore.QPoint | QtCore.QPointF | QtCore.QRect | QtCore.QRectF,\n        frame_buffer: QtGui.QImage,\n    ):\n        self.set_composition_mode(\"source_atop\")\n        self.drawImage(target, frame_buffer)\n\n    def draw_polygon(\n        self,\n        points: (\n            QtGui.QPolygon | QtGui.QPolygonF | list[QtCore.QPoint] | list[QtCore.QPointF]\n        ),\n        fill_rule: constants.FillRuleStr = \"odd_even\",\n    ):\n        if fill_rule not in constants.FILL_RULE:\n            raise InvalidParamError(fill_rule, constants.FILL_RULE)\n        self.drawPolygon(points, fillRule=constants.FILL_RULE[fill_rule])  # type: ignore\n\n    def draw_rounded_rect(\n        self,\n        rect: datatypes.RectType | datatypes.RectFType,\n        x_radius: float,\n        y_radius: float,\n        relative: bool = False,\n    ):\n        flag = (\n            QtCore.Qt.SizeMode.RelativeSize\n            if relative\n            else QtCore.Qt.SizeMode.AbsoluteSize\n        )\n        if isinstance(rect, tuple):\n            rect = QtCore.QRectF(*rect)\n        self.drawRoundedRect(rect, flag)\n\n    def use_antialiasing(self):\n        self.setRenderHint(self.RenderHint.Antialiasing, True)\n\n    def fill_rect(\n        self,\n        rect: datatypes.RectType | datatypes.RectFType,\n        color: datatypes.ColorType,\n        pattern: constants.BrushStyleStr = \"solid\",\n    ):\n        if pattern not in constants.BRUSH_STYLE:\n            raise InvalidParamError(pattern, constants.BRUSH_STYLE)\n        if isinstance(rect, tuple):\n            rect = core.RectF(*rect)\n        color = colors.get_color(color)\n        if pattern != \"solid\":\n            color = gui.Brush(color, constants.BRUSH_STYLE[pattern])\n        self.fillRect(rect, color)\n\n    def set_pen(\n        self,\n        style: constants.PenStyleStr | None = \"solid\",\n        width: float = 1.0,\n        color: datatypes.ColorType = \"black\",\n        brush: QtGui.QBrush | None = None,\n        miter_limit: float = 2.0,\n        join_style: constants.JoinStyleStr = \"bevel\",\n        cap_style: constants.CapStyleStr = \"square\",\n    ) -&gt; gui.Pen:\n\"\"\"Set pen to use.\n\n        Args:\n            style: pen style\n            width: pen width\n            color: pen color\n            brush: pen brush\n            miter_limit: miter limit\n            join_style: pen join style\n            cap_style: pen cap style\n        \"\"\"\n        pen = gui.Pen()\n        pen.set_style(style)\n        if style in [\"none\", None]:\n            self.setPen(pen)\n            return pen\n        pen.set_cap_style(cap_style)\n        pen.set_join_style(join_style)\n        pen.setMiterLimit(miter_limit)\n        pen.setWidthF(width)\n        if brush is not None:\n            pen.setBrush(brush)\n        pen.set_color(color)\n        self.setPen(pen)\n        return pen\n\n    def get_pen(self) -&gt; gui.Pen:\n\"\"\"Return current pen.\n\n        Returns:\n            current pen\n        \"\"\"\n        return gui.Pen(self.pen())\n\n    def set_color(self, color: datatypes.ColorType):\n        color = colors.get_color(color)\n        self.setPen(color)\n\n    def set_brush(self, brush: QtGui.QBrush | datatypes.ColorType):\n        if not isinstance(brush, QtGui.QBrush):\n            brush = colors.get_color(brush)\n        self.setBrush(brush)\n\n    def set_transparent_background(self, transparent: bool = True):\n        mode = (\n            QtCore.Qt.BGMode.TransparentMode\n            if transparent\n            else QtCore.Qt.BGMode.OpaqueMode\n        )\n        self.setBackgroundMode(mode)\n\n    def set_composition_mode(self, mode: CompositionModeStr):\n\"\"\"Set the current composition mode.\n\n        Raises:\n            InvalidParamError: composition mode does not exist\n        \"\"\"\n        if mode not in COMPOSITION_MODE:\n            raise InvalidParamError(mode, COMPOSITION_MODE)\n        self.setCompositionMode(COMPOSITION_MODE[mode])\n\n    def get_composition_mode(self) -&gt; CompositionModeStr:\n\"\"\"Get the current composition mode.\n\n        Returns:\n            composition mode\n        \"\"\"\n        return COMPOSITION_MODE.inverse[self.compositionMode()]\n\n    def set_transform(self, transform: datatypes.TransformType, combine: bool = False):\n        if isinstance(transform, tuple):\n            transform = gui.Transform(*transform)\n        self.setTransform(transform, combine)\n\n    def get_font_metrics(self) -&gt; gui.FontMetrics:\n        return gui.FontMetrics(self.fontMetrics())\n\n    def set_clip_path(\n        self, path: QtGui.QPainterPath, operation: constants.ClipOperationStr = \"replace\"\n    ):\n        if operation not in constants.CLIP_OPERATION:\n            raise InvalidParamError(operation, constants.CLIP_OPERATION)\n        self.setClipPath(path, constants.CLIP_OPERATION[operation])\n\n    def get_text_rect(self, text: str) -&gt; core.Rect:\n        return self.drawText(\n            core.Rect(), QtCore.Qt.TextFlag.TextDontPrint, text\n        )  # type: ignore\n\n    @contextlib.contextmanager\n    def clip_path(\n        self, operation: constants.ClipOperationStr = \"replace\"\n    ) -&gt; Iterator[gui.PainterPath]:\n        path = gui.PainterPath()\n        yield path\n        self.set_clip_path(path, operation)\n\n    @contextlib.contextmanager\n    def apply_transform(self, combine: bool = True) -&gt; Iterator[gui.Transform]:\n        transform = gui.Transform()\n        yield transform\n        self.setTransform(transform, combine)\n\n    @contextlib.contextmanager\n    def offset_by(self, x: int = 0, y: int = 0) -&gt; Iterator[Painter]:\n        self.translate(x, y)\n        yield self\n        self.translate(-x, -y)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.get_composition_mode","title":"<code>get_composition_mode(self) -&gt; CompositionModeStr</code>","text":"<p>Get the current composition mode.</p> <p>Returns:</p> Type Description <code>CompositionModeStr</code> <p>composition mode</p> Source code in <code>prettyqt/gui/painter.py</code> <pre><code>def get_composition_mode(self) -&gt; CompositionModeStr:\n\"\"\"Get the current composition mode.\n\n    Returns:\n        composition mode\n    \"\"\"\n    return COMPOSITION_MODE.inverse[self.compositionMode()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.get_pen","title":"<code>get_pen(self) -&gt; gui.Pen</code>","text":"<p>Return current pen.</p> <p>Returns:</p> Type Description <code>gui.Pen</code> <p>current pen</p> Source code in <code>prettyqt/gui/painter.py</code> <pre><code>def get_pen(self) -&gt; gui.Pen:\n\"\"\"Return current pen.\n\n    Returns:\n        current pen\n    \"\"\"\n    return gui.Pen(self.pen())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.set_composition_mode","title":"<code>set_composition_mode(self, mode: CompositionModeStr)</code>","text":"<p>Set the current composition mode.</p> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>composition mode does not exist</p> Source code in <code>prettyqt/gui/painter.py</code> <pre><code>def set_composition_mode(self, mode: CompositionModeStr):\n\"\"\"Set the current composition mode.\n\n    Raises:\n        InvalidParamError: composition mode does not exist\n    \"\"\"\n    if mode not in COMPOSITION_MODE:\n        raise InvalidParamError(mode, COMPOSITION_MODE)\n    self.setCompositionMode(COMPOSITION_MODE[mode])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painter.PainterMixin.set_pen","title":"<code>set_pen(self, style: constants.PenStyleStr | None = 'solid', width: float = 1.0, color: datatypes.ColorType = 'black', brush: QtGui.QBrush | None = None, miter_limit: float = 2.0, join_style: constants.JoinStyleStr = 'bevel', cap_style: constants.CapStyleStr = 'square') -&gt; gui.Pen</code>","text":"<p>Set pen to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.PenStyleStr | None</code> <p>pen style</p> <code>'solid'</code> <code>width</code> <code>float</code> <p>pen width</p> <code>1.0</code> <code>color</code> <code>datatypes.ColorType</code> <p>pen color</p> <code>'black'</code> <code>brush</code> <code>QtGui.QBrush | None</code> <p>pen brush</p> <code>None</code> <code>miter_limit</code> <code>float</code> <p>miter limit</p> <code>2.0</code> <code>join_style</code> <code>constants.JoinStyleStr</code> <p>pen join style</p> <code>'bevel'</code> <code>cap_style</code> <code>constants.CapStyleStr</code> <p>pen cap style</p> <code>'square'</code> Source code in <code>prettyqt/gui/painter.py</code> <pre><code>def set_pen(\n    self,\n    style: constants.PenStyleStr | None = \"solid\",\n    width: float = 1.0,\n    color: datatypes.ColorType = \"black\",\n    brush: QtGui.QBrush | None = None,\n    miter_limit: float = 2.0,\n    join_style: constants.JoinStyleStr = \"bevel\",\n    cap_style: constants.CapStyleStr = \"square\",\n) -&gt; gui.Pen:\n\"\"\"Set pen to use.\n\n    Args:\n        style: pen style\n        width: pen width\n        color: pen color\n        brush: pen brush\n        miter_limit: miter limit\n        join_style: pen join style\n        cap_style: pen cap style\n    \"\"\"\n    pen = gui.Pen()\n    pen.set_style(style)\n    if style in [\"none\", None]:\n        self.setPen(pen)\n        return pen\n    pen.set_cap_style(cap_style)\n    pen.set_join_style(join_style)\n    pen.setMiterLimit(miter_limit)\n    pen.setWidthF(width)\n    if brush is not None:\n        pen.setBrush(brush)\n    pen.set_color(color)\n    self.setPen(pen)\n    return pen\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpath","title":"<code>painterpath</code>","text":""},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath","title":"<code> PainterPath            (QPainterPath)         </code>","text":"Source code in <code>prettyqt/gui/painterpath.py</code> <pre><code>class PainterPath(QtGui.QPainterPath):\n    def serialize_fields(self):\n        return dict(fill_rule=self.get_fill_rule(), elements=list(self))\n\n    def __len__(self):\n        return self.elementCount()\n\n    def __getitem__(self, index: int) -&gt; QtGui.QPainterPath.Element:\n        return self.elementAt(index)\n\n    def __iter__(self) -&gt; Iterator[QtGui.QPainterPath.Element]:\n        return iter(self.elementAt(i) for i in range(self.elementCount()))\n\n    def __setitem__(self, index: int, value: tuple[int, int]):\n        self.setElementPositionAt(index, *value)\n\n    def __bool__(self):\n        return not self.isEmpty()\n\n    def __contains__(self, item: QtCore.QPointF | QtCore.QRectF | QtGui.QPainterPath):\n        return self.contains(item)\n\n    def add_rect(self, rect: datatypes.RectType | datatypes.RectFType):\n        if isinstance(rect, QtCore.QRect):\n            rect = QtCore.QRectF(rect)\n        elif isinstance(rect, tuple):\n            rect = QtCore.QRectF(*rect)\n        self.addRect(rect)\n\n    def set_fill_rule(self, rule: constants.FillRuleStr):\n\"\"\"Set fill rule.\n\n        Args:\n            rule: fill rule to use\n\n        Raises:\n            InvalidParamError: fill rule does not exist\n        \"\"\"\n        if rule not in constants.FILL_RULE:\n            raise InvalidParamError(rule, constants.FILL_RULE)\n        self.setFillRule(constants.FILL_RULE[rule])\n\n    def get_fill_rule(self) -&gt; constants.FillRuleStr:\n\"\"\"Return current fill rule.\n\n        Returns:\n            fill rule\n        \"\"\"\n        return constants.FILL_RULE.inverse[self.fillRule()]\n\n    def get_bounding_rect(self) -&gt; core.RectF:\n        return core.RectF(self.boundingRect())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.get_fill_rule","title":"<code>get_fill_rule(self) -&gt; constants.FillRuleStr</code>","text":"<p>Return current fill rule.</p> <p>Returns:</p> Type Description <code>constants.FillRuleStr</code> <p>fill rule</p> Source code in <code>prettyqt/gui/painterpath.py</code> <pre><code>def get_fill_rule(self) -&gt; constants.FillRuleStr:\n\"\"\"Return current fill rule.\n\n    Returns:\n        fill rule\n    \"\"\"\n    return constants.FILL_RULE.inverse[self.fillRule()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.set_fill_rule","title":"<code>set_fill_rule(self, rule: constants.FillRuleStr)</code>","text":"<p>Set fill rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>constants.FillRuleStr</code> <p>fill rule to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>fill rule does not exist</p> Source code in <code>prettyqt/gui/painterpath.py</code> <pre><code>def set_fill_rule(self, rule: constants.FillRuleStr):\n\"\"\"Set fill rule.\n\n    Args:\n        rule: fill rule to use\n\n    Raises:\n        InvalidParamError: fill rule does not exist\n    \"\"\"\n    if rule not in constants.FILL_RULE:\n        raise InvalidParamError(rule, constants.FILL_RULE)\n    self.setFillRule(constants.FILL_RULE[rule])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker","title":"<code>painterpathstroker</code>","text":""},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker","title":"<code> PainterPathStroker            (QPainterPathStroker)         </code>","text":"Source code in <code>prettyqt/gui/painterpathstroker.py</code> <pre><code>class PainterPathStroker(QtGui.QPainterPathStroker):\n    def set_cap_style(self, style: constants.CapStyleStr):\n\"\"\"Set cap style to use.\n\n        Args:\n            style: cap style to use\n\n        Raises:\n            InvalidParamError: cap style does not exist\n        \"\"\"\n        if style not in constants.CAP_STYLE:\n            raise InvalidParamError(style, constants.CAP_STYLE)\n        self.setCapStyle(constants.CAP_STYLE[style])\n\n    def get_cap_style(self) -&gt; constants.CapStyleStr:\n\"\"\"Return current cap style.\n\n        Returns:\n            cap style\n        \"\"\"\n        return constants.CAP_STYLE.inverse[self.capStyle()]\n\n    def set_join_style(self, style: constants.JoinStyleStr):\n\"\"\"Set join style to use.\n\n        Args:\n            style: join style to use\n\n        Raises:\n            InvalidParamError: join style does not exist\n        \"\"\"\n        if style not in constants.JOIN_STYLE:\n            raise InvalidParamError(style, constants.JOIN_STYLE)\n        self.setJoinStyle(constants.JOIN_STYLE[style])\n\n    def get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n\n        Returns:\n            join style\n        \"\"\"\n        return constants.JOIN_STYLE.inverse[self.joinStyle()]\n\n    def create_stroke(self, path: QtGui.QPainterPath) -&gt; gui.PainterPath:\n        return gui.PainterPath(self.createStroke(path))\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_cap_style","title":"<code>get_cap_style(self) -&gt; constants.CapStyleStr</code>","text":"<p>Return current cap style.</p> <p>Returns:</p> Type Description <code>constants.CapStyleStr</code> <p>cap style</p> Source code in <code>prettyqt/gui/painterpathstroker.py</code> <pre><code>def get_cap_style(self) -&gt; constants.CapStyleStr:\n\"\"\"Return current cap style.\n\n    Returns:\n        cap style\n    \"\"\"\n    return constants.CAP_STYLE.inverse[self.capStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_join_style","title":"<code>get_join_style(self) -&gt; constants.JoinStyleStr</code>","text":"<p>Return current join style.</p> <p>Returns:</p> Type Description <code>constants.JoinStyleStr</code> <p>join style</p> Source code in <code>prettyqt/gui/painterpathstroker.py</code> <pre><code>def get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n\n    Returns:\n        join style\n    \"\"\"\n    return constants.JOIN_STYLE.inverse[self.joinStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_cap_style","title":"<code>set_cap_style(self, style: constants.CapStyleStr)</code>","text":"<p>Set cap style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.CapStyleStr</code> <p>cap style to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>cap style does not exist</p> Source code in <code>prettyqt/gui/painterpathstroker.py</code> <pre><code>def set_cap_style(self, style: constants.CapStyleStr):\n\"\"\"Set cap style to use.\n\n    Args:\n        style: cap style to use\n\n    Raises:\n        InvalidParamError: cap style does not exist\n    \"\"\"\n    if style not in constants.CAP_STYLE:\n        raise InvalidParamError(style, constants.CAP_STYLE)\n    self.setCapStyle(constants.CAP_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_join_style","title":"<code>set_join_style(self, style: constants.JoinStyleStr)</code>","text":"<p>Set join style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.JoinStyleStr</code> <p>join style to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>join style does not exist</p> Source code in <code>prettyqt/gui/painterpathstroker.py</code> <pre><code>def set_join_style(self, style: constants.JoinStyleStr):\n\"\"\"Set join style to use.\n\n    Args:\n        style: join style to use\n\n    Raises:\n        InvalidParamError: join style does not exist\n    \"\"\"\n    if style not in constants.JOIN_STYLE:\n        raise InvalidParamError(style, constants.JOIN_STYLE)\n    self.setJoinStyle(constants.JOIN_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.palette","title":"<code>palette</code>","text":""},{"location":"api/gui.html#prettyqt.gui.palette.Palette","title":"<code> Palette            (QPalette)         </code>","text":"Source code in <code>prettyqt/gui/palette.py</code> <pre><code>class Palette(QtGui.QPalette):\n    def __getstate__(self):\n        return bytes(self)\n\n    def __setstate__(self, ba):\n        core.DataStream.write_bytearray(ba, self)\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __getitem__(self, index: RoleStr) -&gt; gui.Color:\n        return self.get_color(index)\n\n    def __setitem__(self, index: RoleStr, value: datatypes.ColorType):\n        self.set_color(index, value)\n\n    def __bytes__(self):\n        ba = core.DataStream.create_bytearray(self)\n        return bytes(ba)\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self['button']}, {self['window']})\"\n\n    def highlight_inactive(self):\n        color = self.color(self.ColorGroup.Active, self.ColorRole.Highlight)\n        self.setColor(self.ColorGroup.Inactive, self.ColorRole.Highlight, color)\n\n    def set_color(\n        self, role: RoleStr, color: datatypes.ColorType, group: GroupStr = \"active\"\n    ):\n        color = colors.get_color(color)\n        self.setColor(GROUP[group], ROLE[role], color)\n\n    def get_colors(self, group: GroupStr = \"active\") -&gt; dict[str, gui.Color]:\n        return {k: self.get_color(k, group) for k in ROLE.keys()}\n\n    def get_color(self, role: RoleStr, group: GroupStr = \"active\") -&gt; gui.Color:\n        return gui.Color(self.color(GROUP[group], ROLE[role]))\n\n    def set_brush(\n        self,\n        role: RoleStr,\n        brush: datatypes.ColorAndBrushType,\n        group: GroupStr = \"active\",\n    ):\n        if not isinstance(brush, QtGui.QBrush):\n            brush = gui.Brush(colors.get_color(brush))\n        self.setBrush(GROUP[group], ROLE[role], brush)\n\n    def get_brushes(self, group: GroupStr = \"active\") -&gt; dict[str, gui.Brush]:\n        return {k: self.get_brush(k, group) for k in ROLE.keys()}\n\n    def get_brush(self, role: RoleStr, group: GroupStr = \"active\") -&gt; gui.Brush:\n        return gui.Brush(self.brush(GROUP[group], ROLE[role]))\n\n    def set_color_group(self, group: GroupStr, **kwargs):\n\"\"\"Set the color group.\n\n        Args:\n            group: color group to use\n            kwargs: keyword arguments passed to setColorGroup\n\n        Raises:\n            InvalidParamError: invalid color group\n        \"\"\"\n        if group not in GROUP:\n            raise InvalidParamError(group, GROUP)\n        self.setColorGroup(GROUP[group], **kwargs)\n\n    def get_color_group(self) -&gt; GroupStr:\n\"\"\"Return color group.\n\n        Returns:\n            color group\n        \"\"\"\n        return GROUP.inverse[self.colorGroup()]\n\n    def inverted(self) -&gt; Palette:\n        pal = Palette()\n        for group in GROUP:\n            for role in ROLE:\n                color = self.get_color(role, group)\n                pal.set_color(role, color.inverted(), group)\n        return pal\n\n    @classmethod\n    def create_dark_palette(cls) -&gt; Palette:\n        pal = cls()\n        pal.set_color(\"window\", gui.Color(53, 53, 53))\n        pal.set_color(\"window_text\", \"white\")\n        pal.set_color(\"window_text\", \"grey\", group=\"disabled\")\n        pal.set_color(\"base\", gui.Color(25, 25, 25))\n        pal.set_color(\"alternate_base\", gui.Color(53, 53, 53))\n        pal.set_color(\"tool_tip_base\", \"slategrey\")\n        pal.set_color(\"tool_tip_base\", \"slategrey\", group=\"inactive\")\n        pal.set_color(\"tool_tip_text\", \"white\")\n        pal.set_color(\"tool_tip_text\", \"white\", group=\"inactive\")\n        pal.set_color(\"text\", \"white\")\n        pal.set_color(\"text\", \"grey\", group=\"disabled\")\n        pal.set_color(\"button\", gui.Color(53, 53, 53))\n        pal.set_color(\"button_text\", \"white\")\n        pal.set_color(\"button_text\", \"grey\", group=\"disabled\")\n        pal.set_color(\"bright_text\", \"red\")\n        pal.set_color(\"link\", \"dodgerblue\")\n        pal.set_color(\"highlight\", \"dodgerblue\")\n        pal.set_color(\"highlight\", gui.Color(80, 80, 80), group=\"disabled\")\n        pal.set_color(\"highlighted_text\", \"black\")\n        pal.set_color(\"highlighted_text\", \"grey\", group=\"disabled\")\n        return pal\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.palette.Palette.get_color_group","title":"<code>get_color_group(self) -&gt; GroupStr</code>","text":"<p>Return color group.</p> <p>Returns:</p> Type Description <code>GroupStr</code> <p>color group</p> Source code in <code>prettyqt/gui/palette.py</code> <pre><code>def get_color_group(self) -&gt; GroupStr:\n\"\"\"Return color group.\n\n    Returns:\n        color group\n    \"\"\"\n    return GROUP.inverse[self.colorGroup()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.palette.Palette.set_color_group","title":"<code>set_color_group(self, group: GroupStr, **kwargs)</code>","text":"<p>Set the color group.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>GroupStr</code> <p>color group to use</p> required <code>kwargs</code> <p>keyword arguments passed to setColorGroup</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid color group</p> Source code in <code>prettyqt/gui/palette.py</code> <pre><code>def set_color_group(self, group: GroupStr, **kwargs):\n\"\"\"Set the color group.\n\n    Args:\n        group: color group to use\n        kwargs: keyword arguments passed to setColorGroup\n\n    Raises:\n        InvalidParamError: invalid color group\n    \"\"\"\n    if group not in GROUP:\n        raise InvalidParamError(group, GROUP)\n    self.setColorGroup(GROUP[group], **kwargs)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen","title":"<code>pen</code>","text":""},{"location":"api/gui.html#prettyqt.gui.pen.Pen","title":"<code> Pen            (QPen)         </code>","text":"Source code in <code>prettyqt/gui/pen.py</code> <pre><code>class Pen(QtGui.QPen):\n    def __getstate__(self):\n        return bytes(self)\n\n    def __setstate__(self, ba):\n        core.DataStream.write_bytearray(ba, self)\n\n    def __bytes__(self):\n        ba = core.DataStream.create_bytearray(self)\n        return bytes(ba)\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.get_color()})\"\n\n    def set_color(self, color: datatypes.ColorType):\n        color = colors.get_color(color)\n        self.setColor(color)\n\n    def get_color(self) -&gt; gui.Color:\n        return gui.Color(self.color())\n\n    def get_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.brush())\n\n    def set_cap_style(self, style: constants.CapStyleStr):\n\"\"\"Set cap style to use.\n\n        Args:\n            style: cap style to use\n\n        Raises:\n            InvalidParamError: cap style does not exist\n        \"\"\"\n        if style not in constants.CAP_STYLE:\n            raise InvalidParamError(style, constants.CAP_STYLE)\n        self.setCapStyle(constants.CAP_STYLE[style])\n\n    def get_cap_style(self) -&gt; constants.CapStyleStr:\n\"\"\"Return current cap style.\n\n        Returns:\n            cap style\n        \"\"\"\n        return constants.CAP_STYLE.inverse[self.capStyle()]\n\n    def set_join_style(self, style: constants.JoinStyleStr):\n\"\"\"Set join style to use.\n\n        Args:\n            style: join style to use\n\n        Raises:\n            InvalidParamError: join style does not exist\n        \"\"\"\n        if style not in constants.JOIN_STYLE:\n            raise InvalidParamError(style, constants.JOIN_STYLE)\n        self.setJoinStyle(constants.JOIN_STYLE[style])\n\n    def get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n\n        Returns:\n            join style\n        \"\"\"\n        return constants.JOIN_STYLE.inverse[self.joinStyle()]\n\n    def set_style(self, style: constants.PenStyleStr | list[float] | None):\n\"\"\"Set pen style to use.\n\n        Args:\n            style: pen style to use\n\n        Raises:\n            InvalidParamError: pen style does not exist\n        \"\"\"\n        if isinstance(style, list):\n            self.setDashPattern(style)\n        else:\n            if style is None:\n                style = \"none\"\n            if style not in constants.PEN_STYLE:\n                raise InvalidParamError(style, constants.PEN_STYLE)\n            self.setStyle(constants.PEN_STYLE[style])\n\n    def get_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return current pen style.\n\n        Returns:\n            pen style\n        \"\"\"\n        return constants.PEN_STYLE.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_cap_style","title":"<code>get_cap_style(self) -&gt; constants.CapStyleStr</code>","text":"<p>Return current cap style.</p> <p>Returns:</p> Type Description <code>constants.CapStyleStr</code> <p>cap style</p> Source code in <code>prettyqt/gui/pen.py</code> <pre><code>def get_cap_style(self) -&gt; constants.CapStyleStr:\n\"\"\"Return current cap style.\n\n    Returns:\n        cap style\n    \"\"\"\n    return constants.CAP_STYLE.inverse[self.capStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_join_style","title":"<code>get_join_style(self) -&gt; constants.JoinStyleStr</code>","text":"<p>Return current join style.</p> <p>Returns:</p> Type Description <code>constants.JoinStyleStr</code> <p>join style</p> Source code in <code>prettyqt/gui/pen.py</code> <pre><code>def get_join_style(self) -&gt; constants.JoinStyleStr:\n\"\"\"Return current join style.\n\n    Returns:\n        join style\n    \"\"\"\n    return constants.JOIN_STYLE.inverse[self.joinStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_style","title":"<code>get_style(self) -&gt; constants.PenStyleStr</code>","text":"<p>Return current pen style.</p> <p>Returns:</p> Type Description <code>constants.PenStyleStr</code> <p>pen style</p> Source code in <code>prettyqt/gui/pen.py</code> <pre><code>def get_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return current pen style.\n\n    Returns:\n        pen style\n    \"\"\"\n    return constants.PEN_STYLE.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_cap_style","title":"<code>set_cap_style(self, style: constants.CapStyleStr)</code>","text":"<p>Set cap style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.CapStyleStr</code> <p>cap style to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>cap style does not exist</p> Source code in <code>prettyqt/gui/pen.py</code> <pre><code>def set_cap_style(self, style: constants.CapStyleStr):\n\"\"\"Set cap style to use.\n\n    Args:\n        style: cap style to use\n\n    Raises:\n        InvalidParamError: cap style does not exist\n    \"\"\"\n    if style not in constants.CAP_STYLE:\n        raise InvalidParamError(style, constants.CAP_STYLE)\n    self.setCapStyle(constants.CAP_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_join_style","title":"<code>set_join_style(self, style: constants.JoinStyleStr)</code>","text":"<p>Set join style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.JoinStyleStr</code> <p>join style to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>join style does not exist</p> Source code in <code>prettyqt/gui/pen.py</code> <pre><code>def set_join_style(self, style: constants.JoinStyleStr):\n\"\"\"Set join style to use.\n\n    Args:\n        style: join style to use\n\n    Raises:\n        InvalidParamError: join style does not exist\n    \"\"\"\n    if style not in constants.JOIN_STYLE:\n        raise InvalidParamError(style, constants.JOIN_STYLE)\n    self.setJoinStyle(constants.JOIN_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_style","title":"<code>set_style(self, style: constants.PenStyleStr | list[float] | None)</code>","text":"<p>Set pen style to use.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.PenStyleStr | list[float] | None</code> <p>pen style to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>pen style does not exist</p> Source code in <code>prettyqt/gui/pen.py</code> <pre><code>def set_style(self, style: constants.PenStyleStr | list[float] | None):\n\"\"\"Set pen style to use.\n\n    Args:\n        style: pen style to use\n\n    Raises:\n        InvalidParamError: pen style does not exist\n    \"\"\"\n    if isinstance(style, list):\n        self.setDashPattern(style)\n    else:\n        if style is None:\n            style = \"none\"\n        if style not in constants.PEN_STYLE:\n            raise InvalidParamError(style, constants.PEN_STYLE)\n        self.setStyle(constants.PEN_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pixmap","title":"<code>pixmap</code>","text":""},{"location":"api/gui.html#prettyqt.gui.pixmap.PixmapMixin","title":"<code> PixmapMixin            (PaintDeviceMixin)         </code>","text":"Source code in <code>prettyqt/gui/pixmap.py</code> <pre><code>class PixmapMixin(gui.PaintDeviceMixin):\n    def __bool__(self):\n        return not self.isNull()\n\n    def __getstate__(self):\n        return bytes(self)\n\n    def __setstate__(self, ba):\n        core.DataStream.write_bytearray(ba, self)\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __bytes__(self):\n        ba = core.DataStream.create_bytearray(self)\n        return bytes(ba)\n\n    def __eq__(self, other):\n        if not isinstance(other, Pixmap):\n            return False\n        # return bytes(self) == bytes(other)\n        return self.toImage() == other.toImage()\n\n    def __hash__(self):\n        return self.cacheKey()\n\n    @classmethod\n    def from_file(cls, path: datatypes.PathType) -&gt; Pixmap:\n        path = pathlib.Path(path)\n        with path.open(mode=\"rb\") as f:\n            data = f.read()\n        # Create widget\n        pixmap = cls()\n        pixmap.loadFromData(QtCore.QByteArray(data))\n        return pixmap\n\n    @classmethod\n    def from_image(cls, img: QtGui.QImage, flags) -&gt; Pixmap:\n        return cls(cls.fromImage(img, flags))\n\n    def get_size(self) -&gt; core.Size:\n        return core.Size(self.size())\n\n    def get_rect(self) -&gt; core.Rect:\n        return core.Rect(self.rect())\n\n    def to_image(self) -&gt; gui.Image:\n        return gui.Image(self.toImage())\n\n    def rotated(self, rotation: int) -&gt; Pixmap:\n        w, h = self.width(), self.height()\n        pixmap = self.transformed(gui.Transform().rotate(rotation))\n        return pixmap.copy((pixmap.width() - w) // 2, (pixmap.height() - h) // 2, w, h)\n\n    def get_image_data_url(self) -&gt; str:\n\"\"\"Render the contents of the pixmap as a data URL (RFC-2397).\n\n        Returns:\n            datauri : str\n        \"\"\"\n        device = core.Buffer()\n        assert device.open_file(\"read_write\")\n        self.save(device, b\"png\")\n        device.close()\n        data = bytes(device.data())\n        payload = base64.b64encode(data).decode(\"ascii\")\n        return \"data:image/png;base64,\" + payload\n\n    @classmethod\n    def create_dot(cls, color: datatypes.ColorType = \"black\", size: int = 16) -&gt; Pixmap:\n        col = colors.get_color(color)\n        px = cls(size, size)\n        px.fill(QtCore.Qt.GlobalColor.transparent)  # type: ignore\n        px_size = px.rect().adjusted(1, 1, -1, -1)\n        with gui.Painter(px) as painter:\n            painter.use_antialiasing()\n            painter.setBrush(col)\n            pen_color = gui.Color(15, 15, 15)\n            painter.set_pen(color=pen_color, width=1)\n            painter.drawEllipse(px_size)\n        return px\n\n    @classmethod\n    def create_checkerboard_pattern(\n        cls, n: int, color_1: datatypes.ColorType, color_2: datatypes.ColorType\n    ):\n\"\"\"Construct tileable checkerboard pattern for paint events.\"\"\"\n        # Brush will be an n\u00d7n checkerboard pattern\n        pat = gui.Pixmap(2 * n, 2 * n)\n        bg0 = colors.get_color(color_1)\n        bg1 = colors.get_color(color_2)\n        with gui.Painter(pat) as p:\n            p.setPen(QtCore.Qt.PenStyle.NoPen)\n            # Paint a checkerboard pattern for the color to be overlaid on\n            p.fillRect(pat.rect(), bg0)\n            p.fillRect(0, 0, n, n, bg1)\n            p.fillRect(n, n, 2 * n, 2 * n, bg1)\n        return pat\n\n    @classmethod\n    def create_char(\n        cls,\n        char: str,\n        size: int,\n        background: datatypes.ColorType = \"black\",\n        color: datatypes.ColorType = \"white\",\n    ):\n        pixmap = cls(size, size)\n        pixmap.fill(QtCore.Qt.GlobalColor.transparent)\n        with gui.Painter(pixmap) as painter:\n            painter.setRenderHints(\n                painter.RenderHint.Antialiasing\n                | painter.RenderHint.TextAntialiasing\n                | painter.RenderHint.SmoothPixmapTransform\n            )\n            painter.set_pen(background)\n            painter.set_brush(background)\n            margin = 1 + size // 16\n            text_margin = size // 20\n            w = size - 2 * margin\n            rect = core.Rect(margin, margin, w, w)\n            painter.draw_rounded_rect(rect, 30, 30, relative=True)\n            painter.set_pen(color)\n            with painter.edit_font() as font:  # type: QtGui.QFont\n                font.setPixelSize(size - 2 * margin - 2 * text_margin)\n            painter.draw_text(rect, char, alignment=\"center\")\n        return pixmap\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pixmap.PixmapMixin.create_checkerboard_pattern","title":"<code>create_checkerboard_pattern(n: int, color_1: datatypes.ColorType, color_2: datatypes.ColorType)</code>  <code>classmethod</code>","text":"<p>Construct tileable checkerboard pattern for paint events.</p> Source code in <code>prettyqt/gui/pixmap.py</code> <pre><code>@classmethod\ndef create_checkerboard_pattern(\n    cls, n: int, color_1: datatypes.ColorType, color_2: datatypes.ColorType\n):\n\"\"\"Construct tileable checkerboard pattern for paint events.\"\"\"\n    # Brush will be an n\u00d7n checkerboard pattern\n    pat = gui.Pixmap(2 * n, 2 * n)\n    bg0 = colors.get_color(color_1)\n    bg1 = colors.get_color(color_2)\n    with gui.Painter(pat) as p:\n        p.setPen(QtCore.Qt.PenStyle.NoPen)\n        # Paint a checkerboard pattern for the color to be overlaid on\n        p.fillRect(pat.rect(), bg0)\n        p.fillRect(0, 0, n, n, bg1)\n        p.fillRect(n, n, 2 * n, 2 * n, bg1)\n    return pat\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.pixmap.PixmapMixin.get_image_data_url","title":"<code>get_image_data_url(self) -&gt; str</code>","text":"<p>Render the contents of the pixmap as a data URL (RFC-2397).</p> <p>Returns:</p> Type Description <code>datauri </code> <p>str</p> Source code in <code>prettyqt/gui/pixmap.py</code> <pre><code>def get_image_data_url(self) -&gt; str:\n\"\"\"Render the contents of the pixmap as a data URL (RFC-2397).\n\n    Returns:\n        datauri : str\n    \"\"\"\n    device = core.Buffer()\n    assert device.open_file(\"read_write\")\n    self.save(device, b\"png\")\n    device.close()\n    data = bytes(device.data())\n    payload = base64.b64encode(data).decode(\"ascii\")\n    return \"data:image/png;base64,\" + payload\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.sessionmanager","title":"<code>sessionmanager</code>","text":""},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager","title":"<code> SessionManager            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/gui/sessionmanager.py</code> <pre><code>class SessionManager(core.ObjectMixin):\n    def __init__(self, item: QtGui.QSessionManager):\n        self.item = item\n\n    def __getattr__(self, val):\n        return getattr(self.item, val)\n\n    def set_restart_hint(self, style: RestartHintStr):\n\"\"\"Set the restart hint.\n\n        Args:\n            style: restart hint\n\n        Raises:\n            InvalidParamError: restart hint does not exist\n        \"\"\"\n        if style not in RESTART_HINT:\n            raise InvalidParamError(style, RESTART_HINT)\n        self.setRestartHint(RESTART_HINT[style])\n\n    def get_restart_hint(self) -&gt; RestartHintStr:\n\"\"\"Return current restart hint.\n\n        Returns:\n            restart hint\n        \"\"\"\n        return RESTART_HINT.inverse[self.restartHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.get_restart_hint","title":"<code>get_restart_hint(self) -&gt; RestartHintStr</code>","text":"<p>Return current restart hint.</p> <p>Returns:</p> Type Description <code>RestartHintStr</code> <p>restart hint</p> Source code in <code>prettyqt/gui/sessionmanager.py</code> <pre><code>def get_restart_hint(self) -&gt; RestartHintStr:\n\"\"\"Return current restart hint.\n\n    Returns:\n        restart hint\n    \"\"\"\n    return RESTART_HINT.inverse[self.restartHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.set_restart_hint","title":"<code>set_restart_hint(self, style: RestartHintStr)</code>","text":"<p>Set the restart hint.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>RestartHintStr</code> <p>restart hint</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>restart hint does not exist</p> Source code in <code>prettyqt/gui/sessionmanager.py</code> <pre><code>def set_restart_hint(self, style: RestartHintStr):\n\"\"\"Set the restart hint.\n\n    Args:\n        style: restart hint\n\n    Raises:\n        InvalidParamError: restart hint does not exist\n    \"\"\"\n    if style not in RESTART_HINT:\n        raise InvalidParamError(style, RESTART_HINT)\n    self.setRestartHint(RESTART_HINT[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem","title":"<code>standarditem</code>","text":""},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem","title":"<code> StandardItem            (QStandardItem)         </code>","text":"Source code in <code>prettyqt/gui/standarditem.py</code> <pre><code>class StandardItem(QtGui.QStandardItem):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.get_icon()}, {self.text()!r})\"\n\n    def serialize_fields(self):\n        return dict(\n            text=self.text(),\n            tool_tip=self.toolTip(),\n            status_tip=self.statusTip(),\n            icon=self.get_icon(),\n            data=self.data(),\n        )\n\n    def __getstate__(self):\n        return bytes(self)\n\n    def __setstate__(self, ba):\n        core.DataStream.write_bytearray(ba, self)\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __bytes__(self):\n        ba = core.DataStream.create_bytearray(self)\n        return bytes(ba)\n\n    def __getitem__(\n        self, index: int | tuple[int, int] | QtCore.QModelIndex\n    ) -&gt; QtGui.QStandardItem:\n        match index:\n            case int():\n                return self.child(index)\n            case tuple():\n                return self.child(*index)\n            case _:\n                raise KeyError(index)\n\n    def __delitem__(self, index: int | tuple[int, int]):\n        if isinstance(index, int):\n            item = self.takeRow(index)\n        else:\n            item = self.takeChild(*index)\n        if item is None:\n            raise KeyError(index)\n        return item\n\n    def __iter__(self) -&gt; Iterator[QtGui.QStandardItem]:\n        return iter(self.get_children())\n\n    def __add__(self, other: str | QtGui.QStandardItem) -&gt; StandardItem:\n        if isinstance(other, (QtGui.QStandardItem, str)):\n            self.add(other)\n            return self\n        raise TypeError(\"wrong type for addition\")\n\n    def get_children(self) -&gt; list[QtGui.QStandardItem]:\n        return [self.child(index) for index in range(self.rowCount())]\n\n    def add(self, *item: str | QtGui.QStandardItem):\n        for i in item:\n            if isinstance(i, str):\n                i = gui.StandardItem(i)\n            self.appendRow([i])\n\n    def clone(self):\n        item = type(self)()\n        core.DataStream.copy_data(self, item)\n        assert type(item) == StandardItem\n        return item\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n        Args:\n            state: checkstate to use\n\n        Raises:\n            InvalidParamError: invalid checkstate\n        \"\"\"\n        if state not in constants.STATE:\n            raise InvalidParamError(state, constants.STATE)\n        self.setCheckState(constants.STATE[state])\n\n    def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n        Returns:\n            checkstate\n        \"\"\"\n        return constants.STATE.inverse[self.checkState()]\n\n    def get_background(self) -&gt; gui.Brush:\n        return gui.Brush(self.background())\n\n    def get_foreground(self) -&gt; gui.Brush:\n        return gui.Brush(self.foreground())\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        if icon.isNull():\n            return None\n        return gui.Icon(icon)\n\n    def set_tooltip(\n        self,\n        tooltip: str | datatypes.PathType,\n        size: datatypes.SizeType | None = None,\n    ):\n        if isinstance(tooltip, os.PathLike):\n            path = os.fspath(tooltip)\n            if size is None:\n                tooltip = f\"&lt;img src={path!r}&gt;\"\n            else:\n                if isinstance(size, QtCore.QSize):\n                    size = (size.width(), size.height())\n                tooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\n        self.setToolTip(tooltip)\n\n    def set_size_hint(self, hint: datatypes.SizeType):\n        if isinstance(hint, tuple):\n            hint = QtCore.QSize(*hint)\n        self.setSizeHint(hint)\n\n    def add_item(\n        self,\n        name: str = \"\",\n        icon: datatypes.IconType = None,\n        data: dict | None = None,\n        foreground: QtGui.QBrush | None = None,\n        background: QtGui.QBrush | None = None,\n        font: QtGui.QFont | None = None,\n        selectable: bool = True,\n        enabled: bool = True,\n        editable: bool = False,\n        status_tip: str | None = None,\n        tool_tip: str | None = None,\n        whats_this: str | None = None,\n        # text_alignment: Optional[str] = None,\n        checkstate: constants.StateStr | None = None,\n        flags: QtCore.Qt.ItemFlags | None = None,\n        size_hint: datatypes.SizeType | None = None,\n        is_user_type: bool = False,\n    ) -&gt; StandardItem:\n        item = StandardItem(name)\n        if icon is not None:\n            icon = iconprovider.get_icon(icon)\n            item.setIcon(icon)\n        if data is not None:\n            for k, v in data.items():\n                item.setData(v, k)\n        if foreground is not None:\n            item.setForeground(foreground)\n        if background is not None:\n            item.setBackground(background)\n        if font is not None:\n            item.setFont(font)\n        if flags is not None:\n            item.setFlags(flags)\n        if enabled:\n            item.setEnabled(enabled)\n        if editable:\n            item.setEditable(editable)\n        if selectable:\n            item.setSelectable(selectable)\n        if status_tip:\n            item.setStatusTip(status_tip)\n        if tool_tip:\n            item.setToolTip(tool_tip)\n        if whats_this:\n            item.setWhatsThis(whats_this)\n        if size_hint is not None:\n            item.set_size_hint(size_hint)\n        if checkstate is not None:\n            item.set_checkstate(checkstate)\n        self.appendRow([item])\n        return item\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.clone","title":"<code>clone(self)</code>","text":"<p>clone(self) -&gt; PySide6.QtGui.QStandardItem</p> Source code in <code>prettyqt/gui/standarditem.py</code> <pre><code>def clone(self):\n    item = type(self)()\n    core.DataStream.copy_data(self, item)\n    assert type(item) == StandardItem\n    return item\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.get_checkstate","title":"<code>get_checkstate(self) -&gt; constants.StateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.StateStr</code> <p>checkstate</p> Source code in <code>prettyqt/gui/standarditem.py</code> <pre><code>def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n    Returns:\n        checkstate\n    \"\"\"\n    return constants.STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_checkstate","title":"<code>set_checkstate(self, state: constants.StateStr)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.StateStr</code> <p>checkstate to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid checkstate</p> Source code in <code>prettyqt/gui/standarditem.py</code> <pre><code>def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n    Args:\n        state: checkstate to use\n\n    Raises:\n        InvalidParamError: invalid checkstate\n    \"\"\"\n    if state not in constants.STATE:\n        raise InvalidParamError(state, constants.STATE)\n    self.setCheckState(constants.STATE[state])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_icon","title":"<code>set_icon(self, icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt/gui/standarditem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext","title":"<code>statictext</code>","text":""},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText","title":"<code> StaticText            (QStaticText)         </code>","text":"Source code in <code>prettyqt/gui/statictext.py</code> <pre><code>class StaticText(QtGui.QStaticText):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.text()!r})\"\n\n    def __str__(self):\n        return self.text()\n\n    def get_size(self) -&gt; core.Size:\n        return core.Size(self.size())\n\n    def set_text_format(self, text_format: str):\n\"\"\"Set the text format.\n\n        Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"\n\n        Args:\n            text_format: text format to use\n\n        Raises:\n            InvalidParamError: text format does not exist\n        \"\"\"\n        if text_format not in TEXT_FORMAT:\n            raise InvalidParamError(text_format, TEXT_FORMAT)\n        self.setTextFormat(TEXT_FORMAT[text_format])\n\n    def get_text_format(self) -&gt; str:\n\"\"\"Return current text format.\n\n        Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"\n\n        Returns:\n            text format\n        \"\"\"\n        return TEXT_FORMAT.inverse[self.textFormat()]\n\n    def set_performance_hint(self, hint: PerformanceHintStr):\n\"\"\"Set the performance hint.\n\n        Args:\n            hint: performance hint to use\n\n        Raises:\n            InvalidParamError: performance hint does not exist\n        \"\"\"\n        if hint not in PERFORMANCE_HINT:\n            raise InvalidParamError(hint, PERFORMANCE_HINT)\n        self.setPerformanceHint(PERFORMANCE_HINT[hint])\n\n    def get_performance_hint(self) -&gt; PerformanceHintStr:\n\"\"\"Return current performance hint.\n\n        Returns:\n            performance hint\n        \"\"\"\n        return PERFORMANCE_HINT.inverse[self.performanceHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_performance_hint","title":"<code>get_performance_hint(self) -&gt; PerformanceHintStr</code>","text":"<p>Return current performance hint.</p> <p>Returns:</p> Type Description <code>PerformanceHintStr</code> <p>performance hint</p> Source code in <code>prettyqt/gui/statictext.py</code> <pre><code>def get_performance_hint(self) -&gt; PerformanceHintStr:\n\"\"\"Return current performance hint.\n\n    Returns:\n        performance hint\n    \"\"\"\n    return PERFORMANCE_HINT.inverse[self.performanceHint()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_text_format","title":"<code>get_text_format(self) -&gt; str</code>","text":"<p>Return current text format.</p> <p>Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"</p> <p>Returns:</p> Type Description <code>str</code> <p>text format</p> Source code in <code>prettyqt/gui/statictext.py</code> <pre><code>def get_text_format(self) -&gt; str:\n\"\"\"Return current text format.\n\n    Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"\n\n    Returns:\n        text format\n    \"\"\"\n    return TEXT_FORMAT.inverse[self.textFormat()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_performance_hint","title":"<code>set_performance_hint(self, hint: PerformanceHintStr)</code>","text":"<p>Set the performance hint.</p> <p>Parameters:</p> Name Type Description Default <code>hint</code> <code>PerformanceHintStr</code> <p>performance hint to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>performance hint does not exist</p> Source code in <code>prettyqt/gui/statictext.py</code> <pre><code>def set_performance_hint(self, hint: PerformanceHintStr):\n\"\"\"Set the performance hint.\n\n    Args:\n        hint: performance hint to use\n\n    Raises:\n        InvalidParamError: performance hint does not exist\n    \"\"\"\n    if hint not in PERFORMANCE_HINT:\n        raise InvalidParamError(hint, PERFORMANCE_HINT)\n    self.setPerformanceHint(PERFORMANCE_HINT[hint])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_text_format","title":"<code>set_text_format(self, text_format: str)</code>","text":"<p>Set the text format.</p> <p>Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"</p> <p>Parameters:</p> Name Type Description Default <code>text_format</code> <code>str</code> <p>text format to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>text format does not exist</p> Source code in <code>prettyqt/gui/statictext.py</code> <pre><code>def set_text_format(self, text_format: str):\n\"\"\"Set the text format.\n\n    Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"\n\n    Args:\n        text_format: text format to use\n\n    Raises:\n        InvalidParamError: text format does not exist\n    \"\"\"\n    if text_format not in TEXT_FORMAT:\n        raise InvalidParamError(text_format, TEXT_FORMAT)\n    self.setTextFormat(TEXT_FORMAT[text_format])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.stylehints","title":"<code>stylehints</code>","text":""},{"location":"api/gui.html#prettyqt.gui.stylehints.StyleHintsMixin","title":"<code> StyleHintsMixin            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/gui/stylehints.py</code> <pre><code>class StyleHintsMixin(core.ObjectMixin):\n    def get_color_scheme(self) -&gt; constants.ColorSchemeStr:\n\"\"\"Return current color scheme of the system.\n\n        Returns:\n            color scheme\n        \"\"\"\n        return constants.COLOR_SCHEME.inverse[self.colorScheme()]\n\n    def get_tab_focus_behavior(self) -&gt; constants.TabFocusBehaviorStr:\n\"\"\"Return current focus behavior on press of the tab key.\n\n        Returns:\n            focus behavior\n        \"\"\"\n        return constants.TAB_FOCUS_BEHAVIOR.inverse[self.tabFocusBehavior()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.stylehints.StyleHintsMixin.get_color_scheme","title":"<code>get_color_scheme(self) -&gt; constants.ColorSchemeStr</code>","text":"<p>Return current color scheme of the system.</p> <p>Returns:</p> Type Description <code>constants.ColorSchemeStr</code> <p>color scheme</p> Source code in <code>prettyqt/gui/stylehints.py</code> <pre><code>def get_color_scheme(self) -&gt; constants.ColorSchemeStr:\n\"\"\"Return current color scheme of the system.\n\n    Returns:\n        color scheme\n    \"\"\"\n    return constants.COLOR_SCHEME.inverse[self.colorScheme()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.stylehints.StyleHintsMixin.get_tab_focus_behavior","title":"<code>get_tab_focus_behavior(self) -&gt; constants.TabFocusBehaviorStr</code>","text":"<p>Return current focus behavior on press of the tab key.</p> <p>Returns:</p> Type Description <code>constants.TabFocusBehaviorStr</code> <p>focus behavior</p> Source code in <code>prettyqt/gui/stylehints.py</code> <pre><code>def get_tab_focus_behavior(self) -&gt; constants.TabFocusBehaviorStr:\n\"\"\"Return current focus behavior on press of the tab key.\n\n    Returns:\n        focus behavior\n    \"\"\"\n    return constants.TAB_FOCUS_BEHAVIOR.inverse[self.tabFocusBehavior()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.surface","title":"<code>surface</code>","text":""},{"location":"api/gui.html#prettyqt.gui.surface.SurfaceMixin","title":"<code> SurfaceMixin        </code>","text":"Source code in <code>prettyqt/gui/surface.py</code> <pre><code>class SurfaceMixin:\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    def get_surface_class(self) -&gt; SurfaceClassStr:\n\"\"\"Get the current surface class.\n\n        Returns:\n            surface class\n        \"\"\"\n        return SURFACE_CLASS.inverse[self.surfaceClass()]\n\n    def get_surface_type(self) -&gt; SurfaceTypeStr:\n\"\"\"Get the current surface type.\n\n        Returns:\n            surface type\n        \"\"\"\n        return SURFACE_TYPES.inverse[self.surfaceType()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.surface.SurfaceMixin.get_surface_class","title":"<code>get_surface_class(self) -&gt; SurfaceClassStr</code>","text":"<p>Get the current surface class.</p> <p>Returns:</p> Type Description <code>SurfaceClassStr</code> <p>surface class</p> Source code in <code>prettyqt/gui/surface.py</code> <pre><code>def get_surface_class(self) -&gt; SurfaceClassStr:\n\"\"\"Get the current surface class.\n\n    Returns:\n        surface class\n    \"\"\"\n    return SURFACE_CLASS.inverse[self.surfaceClass()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.surface.SurfaceMixin.get_surface_type","title":"<code>get_surface_type(self) -&gt; SurfaceTypeStr</code>","text":"<p>Get the current surface type.</p> <p>Returns:</p> Type Description <code>SurfaceTypeStr</code> <p>surface type</p> Source code in <code>prettyqt/gui/surface.py</code> <pre><code>def get_surface_type(self) -&gt; SurfaceTypeStr:\n\"\"\"Get the current surface type.\n\n    Returns:\n        surface type\n    \"\"\"\n    return SURFACE_TYPES.inverse[self.surfaceType()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter","title":"<code>syntaxhighlighter</code>","text":""},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighterMixin","title":"<code> SyntaxHighlighterMixin            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/gui/syntaxhighlighter.py</code> <pre><code>class SyntaxHighlighterMixin(core.ObjectMixin):\n    RULES: list = []\n\n    def __init__(self, parent: QtCore.QObject | None = None):\n        super().__init__(parent)  # type: ignore\n\n    def get_current_block(self) -&gt; gui.TextBlock:\n        return gui.TextBlock(self.currentBlock())\n\n    def get_format(self, position: int) -&gt; gui.TextBlock:\n        return gui.TextCharFormat(self.format(position))\n\n    @classmethod\n    def yield_rules(cls) -&gt; Iterator[tuple[Pattern, int, gui.TextCharFormat]]:\n        for Rule in cls.RULES:\n            if isinstance(Rule.compiled, list):\n                for i in Rule.compiled:\n                    yield (i, Rule.nth, Rule.fmt)\n            else:\n                yield (Rule.compiled, Rule.nth, Rule.fmt)\n\n    def highlightBlock(self, text: str):\n\"\"\"Apply syntax highlighting to the given block of text.\"\"\"\n        # Do other syntax formatting\n        for expression, nth, fmt in self.yield_rules():\n            for match in expression.finditer(text):\n                span = match.span(nth)\n                self.setFormat(span[0], span[1] - span[0], fmt)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighterMixin.highlightBlock","title":"<code>highlightBlock(self, text: str)</code>","text":"<p>Apply syntax highlighting to the given block of text.</p> Source code in <code>prettyqt/gui/syntaxhighlighter.py</code> <pre><code>def highlightBlock(self, text: str):\n\"\"\"Apply syntax highlighting to the given block of text.\"\"\"\n    # Do other syntax formatting\n    for expression, nth, fmt in self.yield_rules():\n        for match in expression.finditer(text):\n            span = match.span(nth)\n            self.setFormat(span[0], span[1] - span[0], fmt)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock","title":"<code>textblock</code>","text":""},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock","title":"<code> TextBlock            (QTextBlock)         </code>","text":"Source code in <code>prettyqt/gui/textblock.py</code> <pre><code>class TextBlock(QtGui.QTextBlock):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.text()!r})\"\n\n    def __contains__(self, position: int):\n        return self.contains(position)\n\n    def __bool__(self):\n        return self.isValid()\n\n    def __str__(self):\n        return self.text()\n\n    def get_previous(self) -&gt; TextBlock:\n        return TextBlock(self.previous())\n\n    def get_next(self) -&gt; TextBlock:\n        return TextBlock(self.next())\n\n    def get_text_direction(self) -&gt; constants.LayoutDirectionStr:\n        return constants.LAYOUT_DIRECTION.inverse[self.textDirection()]\n\n    def set_user_data(self, data):\n        if isinstance(data, QtGui.QTextBlockUserData):\n            self.setUserData(data)\n            return None\n        user_data = UserData(data)\n        self.setUserData(user_data)\n\n    def get_user_data(self):\n        user_data = self.userData()\n        if isinstance(user_data, UserData):\n            return user_data.data\n        return user_data\n\n    @contextlib.contextmanager\n    def edit_user_state(self):\n        state = self.userState()\n        yield state\n        self.setUserState(state)\n\n    def get_state(self) -&gt; int:\n\"\"\"Get the user state, generally used for syntax highlighting.\n\n        :return: The block state\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            return state\n        return state &amp; 0x0000FFFF\n\n    def set_state(self, state: int):\n\"\"\"Set the user state, generally used for syntax highlighting.\n\n        :param state: new state value.\n        \"\"\"\n        user_state = self.userState()\n        if user_state == -1:\n            user_state = 0\n        higher_part = user_state &amp; 0x7FFF0000\n        state &amp;= 0x0000FFFF\n        state |= higher_part\n        self.setUserState(state)\n\n    def get_fold_level(self) -&gt; int:\n\"\"\"Get the block fold level.\n\n        :return: The block fold level\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        return (state &amp; 0x03FF0000) &gt;&gt; 16\n\n    def set_fold_level(self, val: int):\n\"\"\"Set the block fold level.\n\n        :param val: The new fold level [0-7]\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        if val &gt;= 0x3FF:\n            val = 0x3FF\n        state &amp;= 0x7C00FFFF\n        state |= val &lt;&lt; 16\n        self.setUserState(state)\n\n    def is_fold_trigger(self) -&gt; bool:\n\"\"\"Check if the block is a fold trigger.\n\n        :return: True if the block is a fold trigger (represented as a node in\n            the fold panel)\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        return bool(state &amp; 0x04000000)\n\n    def set_fold_trigger(self, val: int):\n\"\"\"Set the block fold trigger flag (True means the block is a fold trigger).\n\n        :param val: value to set\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        state &amp;= 0x7BFFFFFF\n        state |= int(val) &lt;&lt; 26\n        self.setUserState(state)\n\n    def is_collapsed(self) -&gt; bool:\n\"\"\"Check if the block is expanded or collased.\n\n        :return: False for an open trigger, True for for closed trigger\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        return bool(state &amp; 0x08000000)\n\n    def set_collapsed(self, val: int):\n\"\"\"Set the fold trigger state (collapsed or expanded).\n\n        :param val: The new trigger state (True=collapsed, False=expanded)\n        \"\"\"\n        state = self.userState()\n        if state == -1:\n            state = 0\n        state &amp;= 0x77FFFFFF\n        state |= int(val) &lt;&lt; 27\n        self.setUserState(state)\n\n    def find_parent_scope(self, limit: int = 5000) -&gt; TextBlock | None:\n\"\"\"Find parent scope, if the block is not a fold trigger.\"\"\"\n        # if we moved up for more than n lines, just give up otherwise this\n        # would take too much time.\n        counter = 0\n        original = TextBlock(self)\n        start = TextBlock(self)\n        if not self.is_fold_trigger():\n            # search level of next non blank line\n            while start.text().strip() == \"\" and start.isValid():\n                start = start.next()\n            ref_level = self.get_fold_level() - 1\n            start = original\n            while (\n                start.blockNumber()\n                and counter &lt; limit\n                and (not self.is_fold_trigger() or self.get_fold_level() &gt; ref_level)\n            ):\n                counter += 1\n                start = start.previous()\n        if counter &lt; limit:\n            return TextBlock(start)\n        return None\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.find_parent_scope","title":"<code>find_parent_scope(self, limit: int = 5000) -&gt; TextBlock | None</code>","text":"<p>Find parent scope, if the block is not a fold trigger.</p> Source code in <code>prettyqt/gui/textblock.py</code> <pre><code>def find_parent_scope(self, limit: int = 5000) -&gt; TextBlock | None:\n\"\"\"Find parent scope, if the block is not a fold trigger.\"\"\"\n    # if we moved up for more than n lines, just give up otherwise this\n    # would take too much time.\n    counter = 0\n    original = TextBlock(self)\n    start = TextBlock(self)\n    if not self.is_fold_trigger():\n        # search level of next non blank line\n        while start.text().strip() == \"\" and start.isValid():\n            start = start.next()\n        ref_level = self.get_fold_level() - 1\n        start = original\n        while (\n            start.blockNumber()\n            and counter &lt; limit\n            and (not self.is_fold_trigger() or self.get_fold_level() &gt; ref_level)\n        ):\n            counter += 1\n            start = start.previous()\n    if counter &lt; limit:\n        return TextBlock(start)\n    return None\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.get_fold_level","title":"<code>get_fold_level(self) -&gt; int</code>","text":"<p>Get the block fold level.</p> <p>:return: The block fold level</p> Source code in <code>prettyqt/gui/textblock.py</code> <pre><code>def get_fold_level(self) -&gt; int:\n\"\"\"Get the block fold level.\n\n    :return: The block fold level\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    return (state &amp; 0x03FF0000) &gt;&gt; 16\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.get_state","title":"<code>get_state(self) -&gt; int</code>","text":"<p>Get the user state, generally used for syntax highlighting.</p> <p>:return: The block state</p> Source code in <code>prettyqt/gui/textblock.py</code> <pre><code>def get_state(self) -&gt; int:\n\"\"\"Get the user state, generally used for syntax highlighting.\n\n    :return: The block state\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        return state\n    return state &amp; 0x0000FFFF\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.is_collapsed","title":"<code>is_collapsed(self) -&gt; bool</code>","text":"<p>Check if the block is expanded or collased.</p> <p>:return: False for an open trigger, True for for closed trigger</p> Source code in <code>prettyqt/gui/textblock.py</code> <pre><code>def is_collapsed(self) -&gt; bool:\n\"\"\"Check if the block is expanded or collased.\n\n    :return: False for an open trigger, True for for closed trigger\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    return bool(state &amp; 0x08000000)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.is_fold_trigger","title":"<code>is_fold_trigger(self) -&gt; bool</code>","text":"<p>Check if the block is a fold trigger.</p> <p>:return: True if the block is a fold trigger (represented as a node in     the fold panel)</p> Source code in <code>prettyqt/gui/textblock.py</code> <pre><code>def is_fold_trigger(self) -&gt; bool:\n\"\"\"Check if the block is a fold trigger.\n\n    :return: True if the block is a fold trigger (represented as a node in\n        the fold panel)\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    return bool(state &amp; 0x04000000)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_collapsed","title":"<code>set_collapsed(self, val: int)</code>","text":"<p>Set the fold trigger state (collapsed or expanded).</p> <p>:param val: The new trigger state (True=collapsed, False=expanded)</p> Source code in <code>prettyqt/gui/textblock.py</code> <pre><code>def set_collapsed(self, val: int):\n\"\"\"Set the fold trigger state (collapsed or expanded).\n\n    :param val: The new trigger state (True=collapsed, False=expanded)\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    state &amp;= 0x77FFFFFF\n    state |= int(val) &lt;&lt; 27\n    self.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_fold_level","title":"<code>set_fold_level(self, val: int)</code>","text":"<p>Set the block fold level.</p> <p>:param val: The new fold level [0-7]</p> Source code in <code>prettyqt/gui/textblock.py</code> <pre><code>def set_fold_level(self, val: int):\n\"\"\"Set the block fold level.\n\n    :param val: The new fold level [0-7]\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    if val &gt;= 0x3FF:\n        val = 0x3FF\n    state &amp;= 0x7C00FFFF\n    state |= val &lt;&lt; 16\n    self.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_fold_trigger","title":"<code>set_fold_trigger(self, val: int)</code>","text":"<p>Set the block fold trigger flag (True means the block is a fold trigger).</p> <p>:param val: value to set</p> Source code in <code>prettyqt/gui/textblock.py</code> <pre><code>def set_fold_trigger(self, val: int):\n\"\"\"Set the block fold trigger flag (True means the block is a fold trigger).\n\n    :param val: value to set\n    \"\"\"\n    state = self.userState()\n    if state == -1:\n        state = 0\n    state &amp;= 0x7BFFFFFF\n    state |= int(val) &lt;&lt; 26\n    self.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textblock.TextBlock.set_state","title":"<code>set_state(self, state: int)</code>","text":"<p>Set the user state, generally used for syntax highlighting.</p> <p>:param state: new state value.</p> Source code in <code>prettyqt/gui/textblock.py</code> <pre><code>def set_state(self, state: int):\n\"\"\"Set the user state, generally used for syntax highlighting.\n\n    :param state: new state value.\n    \"\"\"\n    user_state = self.userState()\n    if user_state == -1:\n        user_state = 0\n    higher_part = user_state &amp; 0x7FFF0000\n    state &amp;= 0x0000FFFF\n    state |= higher_part\n    self.setUserState(state)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat","title":"<code>textcharformat</code>","text":""},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin","title":"<code> TextCharFormatMixin            (TextFormatMixin)         </code>","text":"Source code in <code>prettyqt/gui/textcharformat.py</code> <pre><code>class TextCharFormatMixin(gui.TextFormatMixin):\n    def __init__(\n        self,\n        text_color: datatypes.ColorType | QtGui.QBrush = None,\n        bold: bool = False,\n        italic: bool = False,\n    ):\n        super().__init__()\n        if text_color is not None:\n            self.set_foreground_color(text_color)\n        if bold:\n            self.set_font_weight(\"bold\")\n        self.setFontItalic(italic)\n\n    def set_foreground_color(self, color: datatypes.ColorType | QtGui.QBrush):\n        if not isinstance(color, QtGui.QBrush):\n            color = colors.get_color(color)\n        self.setForeground(color)\n\n    def set_background_color(self, color: datatypes.ColorType | QtGui.QBrush):\n        if not isinstance(color, QtGui.QBrush):\n            color = colors.get_color(color)\n        self.setBackground(color)\n\n    def set_font_weight(self, weight: gui.font.WeightStr):\n\"\"\"Set the font weight.\n\n        Args:\n            weight: font weight\n\n        Raises:\n            InvalidParamError: invalid font weight\n        \"\"\"\n        if weight not in gui.font.WEIGHT:\n            raise InvalidParamError(weight, gui.font.WEIGHT)\n        self.setFontWeight(gui.font.WEIGHT[weight])\n\n    def get_font_weight(self) -&gt; gui.font.WeightStr:\n\"\"\"Get current font weight.\n\n        Returns:\n            current font weight\n        \"\"\"\n        return gui.font.WEIGHT.inverse[self.fontWeight()]\n\n    def set_underline_style(self, style: UnderlineStyleStr):\n\"\"\"Set the underline style.\n\n        Args:\n            style: underline style\n\n        Raises:\n            InvalidParamError: invalid underline style\n        \"\"\"\n        if style not in UNDERLINE_STYLE:\n            raise InvalidParamError(style, UNDERLINE_STYLE)\n        self.setUnderlineStyle(UNDERLINE_STYLE[style])\n\n    def get_underline_style(self) -&gt; UnderlineStyleStr:\n\"\"\"Get current underline style.\n\n        Returns:\n            current underline style\n        \"\"\"\n        return UNDERLINE_STYLE.inverse[self.underlineStyle()]\n\n    def set_vertical_alignment(self, alignment: VerticalAlignmentStr):\n\"\"\"Set the vertical alignment.\n\n        Args:\n            alignment: vertical alignment\n\n        Raises:\n            InvalidParamError: invalid vertical alignment\n        \"\"\"\n        if alignment not in VERTICAL_ALIGNMENT:\n            raise InvalidParamError(alignment, VERTICAL_ALIGNMENT)\n        self.setVerticalAlignment(VERTICAL_ALIGNMENT[alignment])\n\n    def get_vertical_alignment(self) -&gt; VerticalAlignmentStr:\n\"\"\"Get current vertical alignment.\n\n        Returns:\n            current vertical alignment\n        \"\"\"\n        return VERTICAL_ALIGNMENT.inverse[self.verticalAlignment()]\n\n    def set_font_style_hint(self, hint: gui.font.StyleHintStr):\n\"\"\"Set the font style hint.\n\n        Args:\n            hint: font style hint\n\n        Raises:\n            InvalidParamError: invalid font style hint\n        \"\"\"\n        if hint not in gui.font.STYLE_HINTS:\n            raise InvalidParamError(hint, gui.font.STYLE_HINTS)\n        self.setFontStyleHint(gui.font.STYLE_HINTS[hint])\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.get_font_weight","title":"<code>get_font_weight(self) -&gt; gui.font.WeightStr</code>","text":"<p>Get current font weight.</p> <p>Returns:</p> Type Description <code>gui.font.WeightStr</code> <p>current font weight</p> Source code in <code>prettyqt/gui/textcharformat.py</code> <pre><code>def get_font_weight(self) -&gt; gui.font.WeightStr:\n\"\"\"Get current font weight.\n\n    Returns:\n        current font weight\n    \"\"\"\n    return gui.font.WEIGHT.inverse[self.fontWeight()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.get_underline_style","title":"<code>get_underline_style(self) -&gt; UnderlineStyleStr</code>","text":"<p>Get current underline style.</p> <p>Returns:</p> Type Description <code>UnderlineStyleStr</code> <p>current underline style</p> Source code in <code>prettyqt/gui/textcharformat.py</code> <pre><code>def get_underline_style(self) -&gt; UnderlineStyleStr:\n\"\"\"Get current underline style.\n\n    Returns:\n        current underline style\n    \"\"\"\n    return UNDERLINE_STYLE.inverse[self.underlineStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.get_vertical_alignment","title":"<code>get_vertical_alignment(self) -&gt; VerticalAlignmentStr</code>","text":"<p>Get current vertical alignment.</p> <p>Returns:</p> Type Description <code>VerticalAlignmentStr</code> <p>current vertical alignment</p> Source code in <code>prettyqt/gui/textcharformat.py</code> <pre><code>def get_vertical_alignment(self) -&gt; VerticalAlignmentStr:\n\"\"\"Get current vertical alignment.\n\n    Returns:\n        current vertical alignment\n    \"\"\"\n    return VERTICAL_ALIGNMENT.inverse[self.verticalAlignment()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_font_style_hint","title":"<code>set_font_style_hint(self, hint: gui.font.StyleHintStr)</code>","text":"<p>Set the font style hint.</p> <p>Parameters:</p> Name Type Description Default <code>hint</code> <code>gui.font.StyleHintStr</code> <p>font style hint</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid font style hint</p> Source code in <code>prettyqt/gui/textcharformat.py</code> <pre><code>def set_font_style_hint(self, hint: gui.font.StyleHintStr):\n\"\"\"Set the font style hint.\n\n    Args:\n        hint: font style hint\n\n    Raises:\n        InvalidParamError: invalid font style hint\n    \"\"\"\n    if hint not in gui.font.STYLE_HINTS:\n        raise InvalidParamError(hint, gui.font.STYLE_HINTS)\n    self.setFontStyleHint(gui.font.STYLE_HINTS[hint])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_font_weight","title":"<code>set_font_weight(self, weight: gui.font.WeightStr)</code>","text":"<p>Set the font weight.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>gui.font.WeightStr</code> <p>font weight</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid font weight</p> Source code in <code>prettyqt/gui/textcharformat.py</code> <pre><code>def set_font_weight(self, weight: gui.font.WeightStr):\n\"\"\"Set the font weight.\n\n    Args:\n        weight: font weight\n\n    Raises:\n        InvalidParamError: invalid font weight\n    \"\"\"\n    if weight not in gui.font.WEIGHT:\n        raise InvalidParamError(weight, gui.font.WEIGHT)\n    self.setFontWeight(gui.font.WEIGHT[weight])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_underline_style","title":"<code>set_underline_style(self, style: UnderlineStyleStr)</code>","text":"<p>Set the underline style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>UnderlineStyleStr</code> <p>underline style</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid underline style</p> Source code in <code>prettyqt/gui/textcharformat.py</code> <pre><code>def set_underline_style(self, style: UnderlineStyleStr):\n\"\"\"Set the underline style.\n\n    Args:\n        style: underline style\n\n    Raises:\n        InvalidParamError: invalid underline style\n    \"\"\"\n    if style not in UNDERLINE_STYLE:\n        raise InvalidParamError(style, UNDERLINE_STYLE)\n    self.setUnderlineStyle(UNDERLINE_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormatMixin.set_vertical_alignment","title":"<code>set_vertical_alignment(self, alignment: VerticalAlignmentStr)</code>","text":"<p>Set the vertical alignment.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>VerticalAlignmentStr</code> <p>vertical alignment</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid vertical alignment</p> Source code in <code>prettyqt/gui/textcharformat.py</code> <pre><code>def set_vertical_alignment(self, alignment: VerticalAlignmentStr):\n\"\"\"Set the vertical alignment.\n\n    Args:\n        alignment: vertical alignment\n\n    Raises:\n        InvalidParamError: invalid vertical alignment\n    \"\"\"\n    if alignment not in VERTICAL_ALIGNMENT:\n        raise InvalidParamError(alignment, VERTICAL_ALIGNMENT)\n    self.setVerticalAlignment(VERTICAL_ALIGNMENT[alignment])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor","title":"<code>textcursor</code>","text":""},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor","title":"<code> TextCursor            (QTextCursor)         </code>","text":"Source code in <code>prettyqt/gui/textcursor.py</code> <pre><code>class TextCursor(QtGui.QTextCursor):\n    def __str__(self):\n        return self.selectedText().replace(\"\\u2029\", \"\\n\")\n\n    def move_position(\n        self, operation: MoveOperationStr, mode: MoveModeStr = \"move\", n: int = 1\n    ) -&gt; bool:\n        return self.movePosition(MOVE_OPERATION[operation], MOVE_MODE[mode], n)\n\n    def set_position(self, pos: int, mode: MoveModeStr = \"move\"):\n\"\"\"Set cursor to given position.\n\n        Args:\n            pos: Cursor position\n            mode: Move mode\n        \"\"\"\n        self.setPosition(pos, MOVE_MODE[mode])\n\n    def select(self, selection: SelectionTypeStr | QtGui.QTextCursor.SelectionType):\n        if isinstance(selection, QtGui.QTextCursor.SelectionType):\n            sel = selection\n        else:\n            sel = SELECTION_TYPE[selection]\n        super().select(sel)\n\n    def span(self) -&gt; tuple[int, int]:\n        return (self.anchor(), self.position())\n\n    def get_cursor_position(self) -&gt; tuple[int, int]:\n\"\"\"Return the QTextCursor position.\n\n        The position is a tuple made up of\n        the line number (0 based) and the column number (0 based).\n        :return: tuple(line, column)\n        \"\"\"\n        return (self.blockNumber(), self.columnNumber())\n\n    def get_selection(self) -&gt; gui.TextDocumentFragment:\n        return gui.TextDocumentFragment(self.selection())\n\n    def select_text(\n        self,\n        start_pos: int | MoveOperationStr,\n        end_pos: int | MoveOperationStr,\n    ) -&gt; str:\n\"\"\"Select text from start position to end position.\n\n        Positions can be either an integer index or a move operation\n\n        Args:\n            start_pos: Start position\n            end_pos: End position\n        \"\"\"\n        if isinstance(start_pos, int):\n            self.set_position(start_pos)\n        else:\n            self.move_position(start_pos)\n        if isinstance(end_pos, int):\n            self.set_position(end_pos, mode=\"keep\")\n        else:\n            self.move_position(end_pos, mode=\"keep\")\n        return self.selectedText()\n\n    def replace_text(\n        self,\n        start_pos: int,\n        end_pos: MoveOperationStr | int,\n        to_replace: str,\n    ):\n        self.set_position(start_pos)\n        if isinstance(end_pos, int):\n            self.set_position(end_pos, mode=\"keep\")\n        else:\n            self.move_position(end_pos, mode=\"keep\")\n        self.insertText(to_replace)\n        self.select_text(start_pos, start_pos + len(to_replace))\n\n    @contextlib.contextmanager\n    def edit_block(self):\n\"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\"\n        self.beginEditBlock()\n        yield\n        self.endEditBlock()\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.edit_block","title":"<code>edit_block(self)</code>","text":"<p>Context manager for edit blocks. Can be used for undo actions.</p> Source code in <code>prettyqt/gui/textcursor.py</code> <pre><code>@contextlib.contextmanager\ndef edit_block(self):\n\"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\"\n    self.beginEditBlock()\n    yield\n    self.endEditBlock()\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.get_cursor_position","title":"<code>get_cursor_position(self) -&gt; tuple[int, int]</code>","text":"<p>Return the QTextCursor position.</p> <p>The position is a tuple made up of the line number (0 based) and the column number (0 based). :return: tuple(line, column)</p> Source code in <code>prettyqt/gui/textcursor.py</code> <pre><code>def get_cursor_position(self) -&gt; tuple[int, int]:\n\"\"\"Return the QTextCursor position.\n\n    The position is a tuple made up of\n    the line number (0 based) and the column number (0 based).\n    :return: tuple(line, column)\n    \"\"\"\n    return (self.blockNumber(), self.columnNumber())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select","title":"<code>select(self, selection: SelectionTypeStr | QtGui.QTextCursor.SelectionType)</code>","text":"<p>select(self, selection: PySide6.QtGui.QTextCursor.SelectionType) -&gt; None</p> Source code in <code>prettyqt/gui/textcursor.py</code> <pre><code>def select(self, selection: SelectionTypeStr | QtGui.QTextCursor.SelectionType):\n    if isinstance(selection, QtGui.QTextCursor.SelectionType):\n        sel = selection\n    else:\n        sel = SELECTION_TYPE[selection]\n    super().select(sel)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select_text","title":"<code>select_text(self, start_pos: int | MoveOperationStr, end_pos: int | MoveOperationStr) -&gt; str</code>","text":"<p>Select text from start position to end position.</p> <p>Positions can be either an integer index or a move operation</p> <p>Parameters:</p> Name Type Description Default <code>start_pos</code> <code>int | MoveOperationStr</code> <p>Start position</p> required <code>end_pos</code> <code>int | MoveOperationStr</code> <p>End position</p> required Source code in <code>prettyqt/gui/textcursor.py</code> <pre><code>def select_text(\n    self,\n    start_pos: int | MoveOperationStr,\n    end_pos: int | MoveOperationStr,\n) -&gt; str:\n\"\"\"Select text from start position to end position.\n\n    Positions can be either an integer index or a move operation\n\n    Args:\n        start_pos: Start position\n        end_pos: End position\n    \"\"\"\n    if isinstance(start_pos, int):\n        self.set_position(start_pos)\n    else:\n        self.move_position(start_pos)\n    if isinstance(end_pos, int):\n        self.set_position(end_pos, mode=\"keep\")\n    else:\n        self.move_position(end_pos, mode=\"keep\")\n    return self.selectedText()\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.set_position","title":"<code>set_position(self, pos: int, mode: MoveModeStr = 'move')</code>","text":"<p>Set cursor to given position.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>int</code> <p>Cursor position</p> required <code>mode</code> <code>MoveModeStr</code> <p>Move mode</p> <code>'move'</code> Source code in <code>prettyqt/gui/textcursor.py</code> <pre><code>def set_position(self, pos: int, mode: MoveModeStr = \"move\"):\n\"\"\"Set cursor to given position.\n\n    Args:\n        pos: Cursor position\n        mode: Move mode\n    \"\"\"\n    self.setPosition(pos, MOVE_MODE[mode])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textdocument","title":"<code>textdocument</code>","text":""},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocumentMixin","title":"<code> TextDocumentMixin            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/gui/textdocument.py</code> <pre><code>class TextDocumentMixin(core.ObjectMixin):\n    def __getitem__(self, index: int) -&gt; gui.TextBlock:\n        return gui.TextBlock(self.findBlockByNumber(index))\n\n    def __len__(self) -&gt; int:\n        return self.blockCount()\n\n    def __iter__(self) -&gt; Iterator[gui.TextBlock]:\n        return iter(\n            gui.TextBlock(self.findBlockByNumber(i)) for i in range(self.blockCount())\n        )\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.toPlainText()!r})\"\n\n    def get_first_block(self) -&gt; gui.TextBlock:\n        return gui.TextBlock(self.firstBlock())\n\n    def get_last_block(self) -&gt; gui.TextBlock:\n        return gui.TextBlock(self.lastBlock())\n\n    def find_block_by_number(self, number: int) -&gt; gui.TextBlock:\n        block = self.findBlockByNumber(number)\n        if not block.isValid():\n            raise ValueError(\n                f\"{number} not a valid block index. Block count: {self.blockCount()}\"\n            )\n        return gui.TextBlock(block)\n\n    def find_block_by_line_number(self, line_number: int) -&gt; gui.TextBlock:\n        block = self.findBlockByLineNumber(line_number)\n        if not block.isValid():\n            raise ValueError(\n                f\"{line_number} not a valid line index. Line count: {self.lineCount()}\"\n            )\n        return gui.TextBlock(block)\n\n    def set_text(self, text: str):\n        self.setPlainText(text)\n\n    def serialize_fields(self):\n        return dict(\n            base_url=self.get_base_url(),\n            default_font=self.get_default_font(),\n            default_stylesheet=self.defaultStyleSheet(),\n            default_text_option=self.get_default_text_option(),\n            document_margin=self.documentMargin(),\n            maximum_block_count=self.maximumBlockCount(),\n            is_modified=self.isModified(),\n            page_size=self.pageSize(),\n            text_width=self.textWidth(),\n            indent_width=self.indentWidth(),\n            undo_redo_enabled=self.isUndoRedoEnabled(),\n            use_design_metrics=self.useDesignMetrics(),\n        )\n\n    def get_base_url(self) -&gt; core.Url:\n        return core.Url(self.baseUrl())\n\n    def get_default_font(self) -&gt; gui.Font:\n        return gui.Font(self.defaultFont())\n\n    def set_default_text_option(self, opt: QtGui.QTextOption):\n        self.setDefaultTextOption(gui.TextOption(opt))\n\n    def get_default_text_option(self) -&gt; gui.TextOption:\n        return gui.TextOption(self.defaultTextOption())\n\n    def set_flags(self, **flags):\n        current = self.flags()\n        for k, v in flags.items():\n            if v:\n                current = current | gui.textoption.FLAG[k]\n            else:\n                current = current &amp; ~gui.textoption.FLAG[k]\n        self.setFlags(current)\n        # if show:\n        #     self.setFlags(self.flags() | QtGui.QTextOption.ShowTabsAndSpaces)\n        # else:\n        #     self.setFlags(self.flags() &amp; ~QtGui.QTextOption.ShowTabsAndSpaces)\n\n    def clear_stacks(self, stack: StackStr):\n\"\"\"Clear undo / redo stack.\n\n        Args:\n            stack: stack to clear\n\n        Raises:\n            InvalidParamError: stack type does not exist\n        \"\"\"\n        if stack not in STACKS:\n            raise InvalidParamError(stack, STACKS)\n        self.clearUndoRedoStacks(STACKS[stack])\n\n    def set_default_cursor_move_style(self, style: constants.CursorMoveStyleStr):\n\"\"\"Set the cursor move style.\n\n        Args:\n            style: cursor move style\n\n        Raises:\n            InvalidParamError: cursor move style does not exist\n        \"\"\"\n        if style not in constants.CURSOR_MOVE_STYLE:\n            raise InvalidParamError(style, constants.CURSOR_MOVE_STYLE)\n        self.setDefaultCursorMoveStyle(constants.CURSOR_MOVE_STYLE[style])\n\n    def get_default_cursor_move_style(self) -&gt; constants.CursorMoveStyleStr:\n\"\"\"Return current cursor move style.\n\n        Returns:\n            cursor move style\n        \"\"\"\n        return constants.CURSOR_MOVE_STYLE.inverse[self.defaultCursorMoveStyle()]\n\n    def set_meta_information(self, info: MetaInformationStr, value: str):\n\"\"\"Set meta information.\n\n        Args:\n            info: meta information type\n            value: value to set\n\n        Raises:\n            InvalidParamError: meta information type does not exist\n        \"\"\"\n        if info not in META_INFORMATION:\n            raise InvalidParamError(info, META_INFORMATION)\n        self.setMetaInformation(META_INFORMATION[info], value)\n\n    def get_meta_information(self, info: MetaInformationStr) -&gt; str:\n\"\"\"Return specififed meta information.\n\n        Args:\n            info: meta information type\n\n        Returns:\n            meta information\n        \"\"\"\n        if info not in META_INFORMATION:\n            raise InvalidParamError(info, META_INFORMATION)\n        return self.metaInformation(META_INFORMATION[info])\n\n    def add_resource(\n        self, resource_type: ResourceTypeStr, name: datatypes.PathType, resource\n    ):\n        if resource_type not in RESOURCE_TYPES:\n            raise InvalidParamError(resource_type, RESOURCE_TYPES)\n        url = core.Url(name)\n        self.addResource(RESOURCE_TYPES[resource_type], url, resource)\n\n    @contextlib.contextmanager\n    def edit_default_stylesheet(self) -&gt; Iterator[qstylizer.style.StyleSheet]:\n        ss = self.get_default_stylesheet()\n        yield ss\n        self.set_default_stylesheet(ss)\n\n    def set_default_stylesheet(\n        self, ss: None | str | qstylizer.style.StyleSheet | datatypes.PathType\n    ):\n        if isinstance(ss, os.PathLike):\n            ss = pathlib.Path(ss).read_text()\n        elif ss is None:\n            ss = \"\"\n        self.setDefaultStyleSheet(str(ss))\n\n    def get_default_stylesheet(self) -&gt; qstylizer.style.StyleSheet:\n        return qstylizer.parser.parse(self.defaultStyleSheet())\n\n    def find_line_position(self, line_no: int) -&gt; int:\n        lines = self.blockCount()\n        assert 1 &lt;= line_no &lt;= lines\n        return self.findBlockByLineNumber(line_no - 1).position()\n\n    def write_to_file(\n        self,\n        path: datatypes.PathType,\n        fmt: gui.textdocumentwriter.FormatStr | bytes | QtCore.QByteArray = \"plaintext\",\n    ):\n        writer = gui.TextDocumentWriter()\n        writer.set_format(fmt)\n        writer.set_file_name(path)\n        return writer.write(self)\n\n    def show_whitespace_and_tabs(self, show: bool):\n\"\"\"Set show white spaces flag.\"\"\"\n        options = self.get_default_text_option()\n        flag = QtGui.QTextOption.Flag.ShowTabsAndSpaces\n        if show:\n            options.setFlags(options.flags() | flag)  # type: ignore\n        else:\n            options.setFlags(options.flags() &amp; ~flag)  # type: ignore\n        self.setDefaultTextOption(options)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocumentMixin.clear_stacks","title":"<code>clear_stacks(self, stack: StackStr)</code>","text":"<p>Clear undo / redo stack.</p> <p>Parameters:</p> Name Type Description Default <code>stack</code> <code>StackStr</code> <p>stack to clear</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>stack type does not exist</p> Source code in <code>prettyqt/gui/textdocument.py</code> <pre><code>def clear_stacks(self, stack: StackStr):\n\"\"\"Clear undo / redo stack.\n\n    Args:\n        stack: stack to clear\n\n    Raises:\n        InvalidParamError: stack type does not exist\n    \"\"\"\n    if stack not in STACKS:\n        raise InvalidParamError(stack, STACKS)\n    self.clearUndoRedoStacks(STACKS[stack])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocumentMixin.get_default_cursor_move_style","title":"<code>get_default_cursor_move_style(self) -&gt; constants.CursorMoveStyleStr</code>","text":"<p>Return current cursor move style.</p> <p>Returns:</p> Type Description <code>constants.CursorMoveStyleStr</code> <p>cursor move style</p> Source code in <code>prettyqt/gui/textdocument.py</code> <pre><code>def get_default_cursor_move_style(self) -&gt; constants.CursorMoveStyleStr:\n\"\"\"Return current cursor move style.\n\n    Returns:\n        cursor move style\n    \"\"\"\n    return constants.CURSOR_MOVE_STYLE.inverse[self.defaultCursorMoveStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocumentMixin.get_meta_information","title":"<code>get_meta_information(self, info: MetaInformationStr) -&gt; str</code>","text":"<p>Return specififed meta information.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>MetaInformationStr</code> <p>meta information type</p> required <p>Returns:</p> Type Description <code>str</code> <p>meta information</p> Source code in <code>prettyqt/gui/textdocument.py</code> <pre><code>def get_meta_information(self, info: MetaInformationStr) -&gt; str:\n\"\"\"Return specififed meta information.\n\n    Args:\n        info: meta information type\n\n    Returns:\n        meta information\n    \"\"\"\n    if info not in META_INFORMATION:\n        raise InvalidParamError(info, META_INFORMATION)\n    return self.metaInformation(META_INFORMATION[info])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocumentMixin.set_default_cursor_move_style","title":"<code>set_default_cursor_move_style(self, style: constants.CursorMoveStyleStr)</code>","text":"<p>Set the cursor move style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.CursorMoveStyleStr</code> <p>cursor move style</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>cursor move style does not exist</p> Source code in <code>prettyqt/gui/textdocument.py</code> <pre><code>def set_default_cursor_move_style(self, style: constants.CursorMoveStyleStr):\n\"\"\"Set the cursor move style.\n\n    Args:\n        style: cursor move style\n\n    Raises:\n        InvalidParamError: cursor move style does not exist\n    \"\"\"\n    if style not in constants.CURSOR_MOVE_STYLE:\n        raise InvalidParamError(style, constants.CURSOR_MOVE_STYLE)\n    self.setDefaultCursorMoveStyle(constants.CURSOR_MOVE_STYLE[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocumentMixin.set_meta_information","title":"<code>set_meta_information(self, info: MetaInformationStr, value: str)</code>","text":"<p>Set meta information.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>MetaInformationStr</code> <p>meta information type</p> required <code>value</code> <code>str</code> <p>value to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>meta information type does not exist</p> Source code in <code>prettyqt/gui/textdocument.py</code> <pre><code>def set_meta_information(self, info: MetaInformationStr, value: str):\n\"\"\"Set meta information.\n\n    Args:\n        info: meta information type\n        value: value to set\n\n    Raises:\n        InvalidParamError: meta information type does not exist\n    \"\"\"\n    if info not in META_INFORMATION:\n        raise InvalidParamError(info, META_INFORMATION)\n    self.setMetaInformation(META_INFORMATION[info], value)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocumentMixin.show_whitespace_and_tabs","title":"<code>show_whitespace_and_tabs(self, show: bool)</code>","text":"<p>Set show white spaces flag.</p> Source code in <code>prettyqt/gui/textdocument.py</code> <pre><code>def show_whitespace_and_tabs(self, show: bool):\n\"\"\"Set show white spaces flag.\"\"\"\n    options = self.get_default_text_option()\n    flag = QtGui.QTextOption.Flag.ShowTabsAndSpaces\n    if show:\n        options.setFlags(options.flags() | flag)  # type: ignore\n    else:\n        options.setFlags(options.flags() &amp; ~flag)  # type: ignore\n    self.setDefaultTextOption(options)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textformat","title":"<code>textformat</code>","text":""},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormatMixin","title":"<code> TextFormatMixin        </code>","text":"Source code in <code>prettyqt/gui/textformat.py</code> <pre><code>class TextFormatMixin:\n    def __getitem__(self, key: int):\n        return self.property(key)\n\n    def __setitem__(self, key: int, value):\n        self.setProperty(key, value)\n\n    def __contains__(self, key: int):\n        return self.hasProperty(key)\n\n    def __bool__(self):\n        return self.isValid()\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.type()})\"\n\n    def get_background(self) -&gt; gui.Brush:\n        return gui.Brush(self.background())\n\n    def get_foreground(self) -&gt; gui.Brush:\n        return gui.Brush(self.foreground())\n\n    def get_brush_property(self, property_id: int) -&gt; gui.Brush:\n        return gui.Brush(self.brushProperty(property_id))\n\n    def get_color_property(self, property_id: int) -&gt; gui.Color:\n        return gui.Color(self.colorProperty(property_id))\n\n    def get_pen_property(self, property_id: int) -&gt; gui.Pen:\n        return gui.Pen(self.penProperty(property_id))\n\n    def set_layout_direction(self, direction: constants.LayoutDirectionStr):\n\"\"\"Set layout direction.\n\n        Args:\n            direction: layout direction\n\n        Raises:\n            InvalidParamError: layout direction does not exist\n        \"\"\"\n        if direction not in constants.LAYOUT_DIRECTION:\n            raise InvalidParamError(direction, constants.LAYOUT_DIRECTION)\n        self.setLayoutDirection(constants.LAYOUT_DIRECTION[direction])\n\n    def get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n\n        Returns:\n            layout direction\n        \"\"\"\n        return constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\n\n    def select_full_width(self, value: bool = True):\n        prop = QtGui.QTextFormat.Property.FullWidthSelection\n        self.setProperty(prop, value)  # type: ignore\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormatMixin.get_layout_direction","title":"<code>get_layout_direction(self) -&gt; constants.LayoutDirectionStr</code>","text":"<p>Get the current layout direction.</p> <p>Returns:</p> Type Description <code>constants.LayoutDirectionStr</code> <p>layout direction</p> Source code in <code>prettyqt/gui/textformat.py</code> <pre><code>def get_layout_direction(self) -&gt; constants.LayoutDirectionStr:\n\"\"\"Get the current layout direction.\n\n    Returns:\n        layout direction\n    \"\"\"\n    return constants.LAYOUT_DIRECTION.inverse[self.layoutDirection()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormatMixin.set_layout_direction","title":"<code>set_layout_direction(self, direction: constants.LayoutDirectionStr)</code>","text":"<p>Set layout direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>constants.LayoutDirectionStr</code> <p>layout direction</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>layout direction does not exist</p> Source code in <code>prettyqt/gui/textformat.py</code> <pre><code>def set_layout_direction(self, direction: constants.LayoutDirectionStr):\n\"\"\"Set layout direction.\n\n    Args:\n        direction: layout direction\n\n    Raises:\n        InvalidParamError: layout direction does not exist\n    \"\"\"\n    if direction not in constants.LAYOUT_DIRECTION:\n        raise InvalidParamError(direction, constants.LAYOUT_DIRECTION)\n    self.setLayoutDirection(constants.LAYOUT_DIRECTION[direction])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat","title":"<code>textframeformat</code>","text":""},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat","title":"<code> TextFrameFormat            (TextFormatMixin, QTextFrameFormat)         </code>","text":"Source code in <code>prettyqt/gui/textframeformat.py</code> <pre><code>class TextFrameFormat(gui.TextFormatMixin, QtGui.QTextFrameFormat):\n    def get_height(self) -&gt; gui.TextLength:\n        length = self.height()\n        return gui.TextLength(length.type(), length.rawValue())\n\n    def get_width(self) -&gt; gui.TextLength:\n        length = self.width()\n        return gui.TextLength(length.type(), length.rawValue())\n\n    def get_border_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.borderBrush())\n\n    def set_border_style(self, style: BorderStyleStr):\n\"\"\"Set border style.\n\n        Args:\n            style: border style\n\n        Raises:\n            InvalidParamError: border style does not exist\n        \"\"\"\n        if style not in BORDER_STYLES:\n            raise InvalidParamError(style, BORDER_STYLES)\n        self.setBorderStyle(BORDER_STYLES[style])\n\n    def get_border_style(self) -&gt; BorderStyleStr:\n\"\"\"Get the current border style.\n\n        Returns:\n            border style\n        \"\"\"\n        return BORDER_STYLES.inverse[self.borderStyle()]\n\n    def set_page_break_policy(self, policy: gui.textformat.PageBreakFlagStr):\n\"\"\"Set page break policy.\n\n        Args:\n            policy: page break policy\n\n        Raises:\n            InvalidParamError: page break policy does not exist\n        \"\"\"\n        if policy not in gui.textformat.PAGE_BREAK_FLAG:\n            raise InvalidParamError(policy, gui.textformat.PAGE_BREAK_FLAG)\n        self.setPageBreakPolicy(gui.textformat.PAGE_BREAK_FLAG[policy])\n\n    def get_page_break_policy(self) -&gt; gui.textformat.PageBreakFlagStr:\n\"\"\"Get the current page break policy.\n\n        Returns:\n            page break policy\n        \"\"\"\n        return gui.textformat.PAGE_BREAK_FLAG.inverse[self.pageBreakPolicy()]\n\n    def set_position(self, position: PositionStr):\n\"\"\"Set position.\n\n        Args:\n            position: position\n\n        Raises:\n            InvalidParamError: position does not exist\n        \"\"\"\n        if position not in POSITIONS:\n            raise InvalidParamError(position, POSITIONS)\n        self.setPosition(POSITIONS[position])\n\n    def get_position(self) -&gt; PositionStr:\n\"\"\"Get the current position.\n\n        Returns:\n            position\n        \"\"\"\n        return POSITIONS.inverse[self.position()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_border_style","title":"<code>get_border_style(self) -&gt; BorderStyleStr</code>","text":"<p>Get the current border style.</p> <p>Returns:</p> Type Description <code>BorderStyleStr</code> <p>border style</p> Source code in <code>prettyqt/gui/textframeformat.py</code> <pre><code>def get_border_style(self) -&gt; BorderStyleStr:\n\"\"\"Get the current border style.\n\n    Returns:\n        border style\n    \"\"\"\n    return BORDER_STYLES.inverse[self.borderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_page_break_policy","title":"<code>get_page_break_policy(self) -&gt; gui.textformat.PageBreakFlagStr</code>","text":"<p>Get the current page break policy.</p> <p>Returns:</p> Type Description <code>gui.textformat.PageBreakFlagStr</code> <p>page break policy</p> Source code in <code>prettyqt/gui/textframeformat.py</code> <pre><code>def get_page_break_policy(self) -&gt; gui.textformat.PageBreakFlagStr:\n\"\"\"Get the current page break policy.\n\n    Returns:\n        page break policy\n    \"\"\"\n    return gui.textformat.PAGE_BREAK_FLAG.inverse[self.pageBreakPolicy()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_position","title":"<code>get_position(self) -&gt; PositionStr</code>","text":"<p>Get the current position.</p> <p>Returns:</p> Type Description <code>PositionStr</code> <p>position</p> Source code in <code>prettyqt/gui/textframeformat.py</code> <pre><code>def get_position(self) -&gt; PositionStr:\n\"\"\"Get the current position.\n\n    Returns:\n        position\n    \"\"\"\n    return POSITIONS.inverse[self.position()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_border_style","title":"<code>set_border_style(self, style: BorderStyleStr)</code>","text":"<p>Set border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>BorderStyleStr</code> <p>border style</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>border style does not exist</p> Source code in <code>prettyqt/gui/textframeformat.py</code> <pre><code>def set_border_style(self, style: BorderStyleStr):\n\"\"\"Set border style.\n\n    Args:\n        style: border style\n\n    Raises:\n        InvalidParamError: border style does not exist\n    \"\"\"\n    if style not in BORDER_STYLES:\n        raise InvalidParamError(style, BORDER_STYLES)\n    self.setBorderStyle(BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_page_break_policy","title":"<code>set_page_break_policy(self, policy: gui.textformat.PageBreakFlagStr)</code>","text":"<p>Set page break policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>gui.textformat.PageBreakFlagStr</code> <p>page break policy</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>page break policy does not exist</p> Source code in <code>prettyqt/gui/textframeformat.py</code> <pre><code>def set_page_break_policy(self, policy: gui.textformat.PageBreakFlagStr):\n\"\"\"Set page break policy.\n\n    Args:\n        policy: page break policy\n\n    Raises:\n        InvalidParamError: page break policy does not exist\n    \"\"\"\n    if policy not in gui.textformat.PAGE_BREAK_FLAG:\n        raise InvalidParamError(policy, gui.textformat.PAGE_BREAK_FLAG)\n    self.setPageBreakPolicy(gui.textformat.PAGE_BREAK_FLAG[policy])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_position","title":"<code>set_position(self, position: PositionStr)</code>","text":"<p>Set position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>PositionStr</code> <p>position</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>position does not exist</p> Source code in <code>prettyqt/gui/textframeformat.py</code> <pre><code>def set_position(self, position: PositionStr):\n\"\"\"Set position.\n\n    Args:\n        position: position\n\n    Raises:\n        InvalidParamError: position does not exist\n    \"\"\"\n    if position not in POSITIONS:\n        raise InvalidParamError(position, POSITIONS)\n    self.setPosition(POSITIONS[position])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textlength","title":"<code>textlength</code>","text":""},{"location":"api/gui.html#prettyqt.gui.textlength.TextLength","title":"<code> TextLength            (QTextLength)         </code>","text":"Source code in <code>prettyqt/gui/textlength.py</code> <pre><code>class TextLength(QtGui.QTextLength):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.type()}, {self.rawValue()})\"\n\n    def get_type(self) -&gt; TypeStr:\n\"\"\"Return type of this length object.\n\n        Returns:\n            timer type\n        \"\"\"\n        return TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textlength.TextLength.get_type","title":"<code>get_type(self) -&gt; TypeStr</code>","text":"<p>Return type of this length object.</p> <p>Returns:</p> Type Description <code>TypeStr</code> <p>timer type</p> Source code in <code>prettyqt/gui/textlength.py</code> <pre><code>def get_type(self) -&gt; TypeStr:\n\"\"\"Return type of this length object.\n\n    Returns:\n        timer type\n    \"\"\"\n    return TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textlistformat","title":"<code>textlistformat</code>","text":""},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat","title":"<code> TextListFormat            (TextFormatMixin, QTextListFormat)         </code>","text":"Source code in <code>prettyqt/gui/textlistformat.py</code> <pre><code>class TextListFormat(gui.TextFormatMixin, QtGui.QTextListFormat):\n    def set_style(self, style: StyleStr):\n\"\"\"Set the style.\n\n        Args:\n            style: style\n\n        Raises:\n            InvalidParamError: invalid style\n        \"\"\"\n        if style not in STYLES:\n            raise InvalidParamError(style, STYLES)\n        self.setStyle(STYLES[style])\n\n    def get_style(self) -&gt; StyleStr:\n\"\"\"Get current style.\n\n        Returns:\n            current style\n        \"\"\"\n        return STYLES.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.get_style","title":"<code>get_style(self) -&gt; StyleStr</code>","text":"<p>Get current style.</p> <p>Returns:</p> Type Description <code>StyleStr</code> <p>current style</p> Source code in <code>prettyqt/gui/textlistformat.py</code> <pre><code>def get_style(self) -&gt; StyleStr:\n\"\"\"Get current style.\n\n    Returns:\n        current style\n    \"\"\"\n    return STYLES.inverse[self.style()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.set_style","title":"<code>set_style(self, style: StyleStr)</code>","text":"<p>Set the style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>StyleStr</code> <p>style</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid style</p> Source code in <code>prettyqt/gui/textlistformat.py</code> <pre><code>def set_style(self, style: StyleStr):\n\"\"\"Set the style.\n\n    Args:\n        style: style\n\n    Raises:\n        InvalidParamError: invalid style\n    \"\"\"\n    if style not in STYLES:\n        raise InvalidParamError(style, STYLES)\n    self.setStyle(STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat","title":"<code>texttablecellformat</code>","text":""},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat","title":"<code> TextTableCellFormat            (TextCharFormatMixin, QTextTableCellFormat)         </code>","text":"Source code in <code>prettyqt/gui/texttablecellformat.py</code> <pre><code>class TextTableCellFormat(gui.TextCharFormatMixin, QtGui.QTextTableCellFormat):\n    def get_bottom_border_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.bottomBorderBrush())\n\n    def set_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set border style.\n\n        Args:\n            style: border style\n\n        Raises:\n            InvalidParamError: border style does not exist\n        \"\"\"\n        if style not in gui.textframeformat.BORDER_STYLES:\n            raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n        self.setBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n\n    def set_bottom_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set bottom border style.\n\n        Args:\n            style: bottom border style\n\n        Raises:\n            InvalidParamError: bottom border style does not exist\n        \"\"\"\n        if style not in gui.textframeformat.BORDER_STYLES:\n            raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n        self.setBottomBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n\n    def get_bottom_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current bottom border style.\n\n        Returns:\n            bottom border style\n        \"\"\"\n        return gui.textframeformat.BORDER_STYLES.inverse[self.bottomBorderStyle()]\n\n    def get_left_border_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.leftBorderBrush())\n\n    def set_left_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set left border style.\n\n        Args:\n            style: left border style\n\n        Raises:\n            InvalidParamError: left border style does not exist\n        \"\"\"\n        if style not in gui.textframeformat.BORDER_STYLES:\n            raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n        self.setLeftBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n\n    def get_left_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current left border style.\n\n        Returns:\n            left border style\n        \"\"\"\n        return gui.textframeformat.BORDER_STYLES.inverse[self.leftBorderStyle()]\n\n    def get_right_border_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.rightBorderBrush())\n\n    def set_right_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set right border style.\n\n        Args:\n            style: right border style\n\n        Raises:\n            InvalidParamError: right border style does not exist\n        \"\"\"\n        if style not in gui.textframeformat.BORDER_STYLES:\n            raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n        self.setRightBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n\n    def get_right_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current right border style.\n\n        Returns:\n            right border style\n        \"\"\"\n        return gui.textframeformat.BORDER_STYLES.inverse[self.rightBorderStyle()]\n\n    def get_top_border_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.topBorderBrush())\n\n    def set_top_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set top border style.\n\n        Args:\n            style: top border style\n\n        Raises:\n            InvalidParamError: top border style does not exist\n        \"\"\"\n        if style not in gui.textframeformat.BORDER_STYLES:\n            raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n        self.setTopBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n\n    def get_top_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current top border style.\n\n        Returns:\n            top border style\n        \"\"\"\n        return gui.textframeformat.BORDER_STYLES.inverse[self.topBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_bottom_border_style","title":"<code>get_bottom_border_style(self) -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current bottom border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>bottom border style</p> Source code in <code>prettyqt/gui/texttablecellformat.py</code> <pre><code>def get_bottom_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current bottom border style.\n\n    Returns:\n        bottom border style\n    \"\"\"\n    return gui.textframeformat.BORDER_STYLES.inverse[self.bottomBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_left_border_style","title":"<code>get_left_border_style(self) -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current left border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>left border style</p> Source code in <code>prettyqt/gui/texttablecellformat.py</code> <pre><code>def get_left_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current left border style.\n\n    Returns:\n        left border style\n    \"\"\"\n    return gui.textframeformat.BORDER_STYLES.inverse[self.leftBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_right_border_style","title":"<code>get_right_border_style(self) -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current right border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>right border style</p> Source code in <code>prettyqt/gui/texttablecellformat.py</code> <pre><code>def get_right_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current right border style.\n\n    Returns:\n        right border style\n    \"\"\"\n    return gui.textframeformat.BORDER_STYLES.inverse[self.rightBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_top_border_style","title":"<code>get_top_border_style(self) -&gt; gui.textframeformat.BorderStyleStr</code>","text":"<p>Get the current top border style.</p> <p>Returns:</p> Type Description <code>gui.textframeformat.BorderStyleStr</code> <p>top border style</p> Source code in <code>prettyqt/gui/texttablecellformat.py</code> <pre><code>def get_top_border_style(self) -&gt; gui.textframeformat.BorderStyleStr:\n\"\"\"Get the current top border style.\n\n    Returns:\n        top border style\n    \"\"\"\n    return gui.textframeformat.BORDER_STYLES.inverse[self.topBorderStyle()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_border_style","title":"<code>set_border_style(self, style: gui.textframeformat.BorderStyleStr)</code>","text":"<p>Set border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr</code> <p>border style</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>border style does not exist</p> Source code in <code>prettyqt/gui/texttablecellformat.py</code> <pre><code>def set_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set border style.\n\n    Args:\n        style: border style\n\n    Raises:\n        InvalidParamError: border style does not exist\n    \"\"\"\n    if style not in gui.textframeformat.BORDER_STYLES:\n        raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n    self.setBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_bottom_border_style","title":"<code>set_bottom_border_style(self, style: gui.textframeformat.BorderStyleStr)</code>","text":"<p>Set bottom border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr</code> <p>bottom border style</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>bottom border style does not exist</p> Source code in <code>prettyqt/gui/texttablecellformat.py</code> <pre><code>def set_bottom_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set bottom border style.\n\n    Args:\n        style: bottom border style\n\n    Raises:\n        InvalidParamError: bottom border style does not exist\n    \"\"\"\n    if style not in gui.textframeformat.BORDER_STYLES:\n        raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n    self.setBottomBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_left_border_style","title":"<code>set_left_border_style(self, style: gui.textframeformat.BorderStyleStr)</code>","text":"<p>Set left border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr</code> <p>left border style</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>left border style does not exist</p> Source code in <code>prettyqt/gui/texttablecellformat.py</code> <pre><code>def set_left_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set left border style.\n\n    Args:\n        style: left border style\n\n    Raises:\n        InvalidParamError: left border style does not exist\n    \"\"\"\n    if style not in gui.textframeformat.BORDER_STYLES:\n        raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n    self.setLeftBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_right_border_style","title":"<code>set_right_border_style(self, style: gui.textframeformat.BorderStyleStr)</code>","text":"<p>Set right border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr</code> <p>right border style</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>right border style does not exist</p> Source code in <code>prettyqt/gui/texttablecellformat.py</code> <pre><code>def set_right_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set right border style.\n\n    Args:\n        style: right border style\n\n    Raises:\n        InvalidParamError: right border style does not exist\n    \"\"\"\n    if style not in gui.textframeformat.BORDER_STYLES:\n        raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n    self.setRightBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_top_border_style","title":"<code>set_top_border_style(self, style: gui.textframeformat.BorderStyleStr)</code>","text":"<p>Set top border style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>gui.textframeformat.BorderStyleStr</code> <p>top border style</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>top border style does not exist</p> Source code in <code>prettyqt/gui/texttablecellformat.py</code> <pre><code>def set_top_border_style(self, style: gui.textframeformat.BorderStyleStr):\n\"\"\"Set top border style.\n\n    Args:\n        style: top border style\n\n    Raises:\n        InvalidParamError: top border style does not exist\n    \"\"\"\n    if style not in gui.textframeformat.BORDER_STYLES:\n        raise InvalidParamError(style, gui.textframeformat.BORDER_STYLES)\n    self.setTopBorderStyle(gui.textframeformat.BORDER_STYLES[style])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.validator","title":"<code>validator</code>","text":""},{"location":"api/gui.html#prettyqt.gui.validator.ValidatorMixin","title":"<code> ValidatorMixin            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/gui/validator.py</code> <pre><code>class ValidatorMixin(core.ObjectMixin):\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    def __add__(self, other: Validator):\n        from prettyqt import custom_validators\n\n        return custom_validators.CompositeValidator([self, other])\n\n    def __radd__(self, other: QtGui.QValidator):\n\"\"\"Needed for sum().\"\"\"\n        return self.__add__(other)\n\n    def is_valid_value(self, value: str, pos: int = 0) -&gt; bool:\n        val = self.validate(value, pos)\n        return val[0] == self.State.Acceptable  # type: ignore\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.validator.ValidatorMixin.__radd__","title":"<code>__radd__(self, other: QtGui.QValidator)</code>  <code>special</code>","text":"<p>Needed for sum().</p> Source code in <code>prettyqt/gui/validator.py</code> <pre><code>def __radd__(self, other: QtGui.QValidator):\n\"\"\"Needed for sum().\"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.window","title":"<code>window</code>","text":""},{"location":"api/gui.html#prettyqt.gui.window.WindowMixin","title":"<code> WindowMixin            (ObjectMixin, SurfaceMixin)         </code>","text":"Source code in <code>prettyqt/gui/window.py</code> <pre><code>class WindowMixin(core.ObjectMixin, gui.SurfaceMixin):\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    # def serialize_fields(self):\n    #     return dict(\n    #         speed=self.speed(),\n    #         visibility=self.get_visibility(),\n    #         scaled_size=self.scaledSize(),\n    #         background_color=self.backgroundColor(),\n    #     )\n\n    def set_visibility(self, visibility: VisibilityStr):\n\"\"\"Set window visibility.\n\n        Args:\n            visibility: window visibility\n\n        Raises:\n            InvalidParamError: window visibility does not exist\n        \"\"\"\n        if visibility not in VISIBILITY:\n            raise InvalidParamError(visibility, VISIBILITY)\n        self.setVisibility(VISIBILITY[visibility])\n\n    def get_visibility(self) -&gt; VisibilityStr:\n\"\"\"Get the current window visibility.\n\n        Returns:\n            window visibility\n        \"\"\"\n        return VISIBILITY.inverse[self.visibility()]\n\n    def start_system_resize(self, edge: constants.EdgeStr) -&gt; bool:\n\"\"\"Start system resize.\n\n        Args:\n            edge: edge to resize\n\n        Raises:\n            InvalidParamError: edge does not exist\n        \"\"\"\n        if edge not in constants.EDGES:\n            raise InvalidParamError(edge, constants.EDGES)\n        return self.startSystemResize(constants.EDGES[edge])\n\n    def get_screen(self) -&gt; gui.Screen:\n        return gui.Screen(self.screen())\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.window.WindowMixin.get_visibility","title":"<code>get_visibility(self) -&gt; VisibilityStr</code>","text":"<p>Get the current window visibility.</p> <p>Returns:</p> Type Description <code>VisibilityStr</code> <p>window visibility</p> Source code in <code>prettyqt/gui/window.py</code> <pre><code>def get_visibility(self) -&gt; VisibilityStr:\n\"\"\"Get the current window visibility.\n\n    Returns:\n        window visibility\n    \"\"\"\n    return VISIBILITY.inverse[self.visibility()]\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.window.WindowMixin.set_visibility","title":"<code>set_visibility(self, visibility: VisibilityStr)</code>","text":"<p>Set window visibility.</p> <p>Parameters:</p> Name Type Description Default <code>visibility</code> <code>VisibilityStr</code> <p>window visibility</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>window visibility does not exist</p> Source code in <code>prettyqt/gui/window.py</code> <pre><code>def set_visibility(self, visibility: VisibilityStr):\n\"\"\"Set window visibility.\n\n    Args:\n        visibility: window visibility\n\n    Raises:\n        InvalidParamError: window visibility does not exist\n    \"\"\"\n    if visibility not in VISIBILITY:\n        raise InvalidParamError(visibility, VISIBILITY)\n    self.setVisibility(VISIBILITY[visibility])\n</code></pre>"},{"location":"api/gui.html#prettyqt.gui.window.WindowMixin.start_system_resize","title":"<code>start_system_resize(self, edge: constants.EdgeStr) -&gt; bool</code>","text":"<p>Start system resize.</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>constants.EdgeStr</code> <p>edge to resize</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>edge does not exist</p> Source code in <code>prettyqt/gui/window.py</code> <pre><code>def start_system_resize(self, edge: constants.EdgeStr) -&gt; bool:\n\"\"\"Start system resize.\n\n    Args:\n        edge: edge to resize\n\n    Raises:\n        InvalidParamError: edge does not exist\n    \"\"\"\n    if edge not in constants.EDGES:\n        raise InvalidParamError(edge, constants.EDGES)\n    return self.startSystemResize(constants.EDGES[edge])\n</code></pre>"},{"location":"api/network.html","title":"network module","text":"<p>Network module.</p> <p>Contains QtNetWork-based classes</p>"},{"location":"api/network.html#prettyqt.network.abstractsocket","title":"<code>abstractsocket</code>","text":""},{"location":"api/network.html#prettyqt.network.abstractsocket.AbstractSocketMixin","title":"<code> AbstractSocketMixin            (IODeviceMixin)         </code>","text":"Source code in <code>prettyqt/network/abstractsocket.py</code> <pre><code>class AbstractSocketMixin(core.IODeviceMixin):\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    def bind_to(\n        self,\n        address: str | QtNetwork.QHostAddress,\n        port: int = 0,\n        bind_mode: (\n            QtNetwork.QAbstractSocket.BindMode | BindModeStr\n        ) = \"default_for_platform\",\n    ) -&gt; bool:\n        if isinstance(address, str):\n            address = QtNetwork.QHostAddress(address)\n        if bind_mode in BIND_MODE:\n            mode = BIND_MODE[bind_mode]\n        else:\n            mode = bind_mode\n        return self.bind(address, port, mode)\n\n    def connect_to_host(\n        self,\n        hostname: str,\n        port: int,\n        open_mode: (QtCore.QIODevice.OpenMode | core.iodevice.OpenModeStr) = \"read_write\",\n        protocol: (\n            QtNetwork.QAbstractSocket.NetworkLayerProtocol | NetworkLayerProtocolStr\n        ) = \"any_ip\",\n    ):\n        if isinstance(open_mode, QtCore.QIODevice.OpenMode):\n            mode = open_mode\n        else:\n            mode = core.iodevice.OPEN_MODES[open_mode]\n        if isinstance(protocol, QtNetwork.QAbstractSocket.NetworkLayerProtocol):\n            prot = protocol\n        else:\n            prot = NETWORK_LAYER_PROTOCOL[protocol]\n        self.connectToHost(hostname, port, mode, prot)\n\n    def get_error(self) -&gt; SocketErrorStr:\n        return SOCKET_ERROR.inverse[self.error()]\n\n    def set_pause_mode(self, mode: PauseModeStr):\n\"\"\"Set pause mode.\n\n        Args:\n            mode: pause mode\n\n        Raises:\n            InvalidParamError: pause mode does not exist\n        \"\"\"\n        if mode not in PAUSE_MODES:\n            raise InvalidParamError(mode, PAUSE_MODES)\n        self.setPauseMode(PAUSE_MODES[mode])\n\n    def get_pause_mode(self) -&gt; PauseModeStr:\n        return PAUSE_MODES.inverse[self.pauseMode()]\n\n    def get_proxy(self) -&gt; network.NetworkProxy:\n        return network.NetworkProxy(self.proxy())\n\n    # def set_socket_option(self, name: str, value):\n    #     if name not in SOCKET_OPTION:\n    #         raise InvalidParamError(name, SOCKET_OPTION)\n    #     self.setSocketOption(SOCKET_OPTION[name], value)\n\n    # def get_socket_option(self, name: str):\n    #     return self.socketOption(SOCKET_OPTION[name])\n\n    # def set_type_of_service(self, typ: str):\n    #     if typ not in TYPE_OF_SERVICE:\n    #         raise InvalidParamError(typ, TYPE_OF_SERVICE)\n    #     self.set_socket_option(\"type_of_service\", TYPE_OF_SERVICE[typ])\n\n    # def get_type_of_service(self):\n    #     opt = self.get_socket_option(\"type_of_service\")\n    #     return TYPE_OF_SERVICE.inverse[opt]\n\n    def get_socket_type(self) -&gt; SocketTypeStr:\n        return SOCKET_TYPE.inverse[self.socketType()]\n\n    def get_state(self) -&gt; SocketStateStr:\n        return SOCKET_STATE.inverse[self.state()]\n\n    def get_local_address(self) -&gt; network.HostAddress:\n        return network.HostAddress(self.localAddress())\n</code></pre>"},{"location":"api/network.html#prettyqt.network.abstractsocket.AbstractSocketMixin.set_pause_mode","title":"<code>set_pause_mode(self, mode: PauseModeStr)</code>","text":"<p>Set pause mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>PauseModeStr</code> <p>pause mode</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>pause mode does not exist</p> Source code in <code>prettyqt/network/abstractsocket.py</code> <pre><code>def set_pause_mode(self, mode: PauseModeStr):\n\"\"\"Set pause mode.\n\n    Args:\n        mode: pause mode\n\n    Raises:\n        InvalidParamError: pause mode does not exist\n    \"\"\"\n    if mode not in PAUSE_MODES:\n        raise InvalidParamError(mode, PAUSE_MODES)\n    self.setPauseMode(PAUSE_MODES[mode])\n</code></pre>"},{"location":"api/network.html#prettyqt.network.httpmultipart","title":"<code>httpmultipart</code>","text":""},{"location":"api/network.html#prettyqt.network.httpmultipart.HttpMultiPart","title":"<code> HttpMultiPart            (ObjectMixin, QHttpMultiPart)         </code>","text":"Source code in <code>prettyqt/network/httpmultipart.py</code> <pre><code>class HttpMultiPart(core.ObjectMixin, QtNetwork.QHttpMultiPart):\n    def __add__(self, other: QtNetwork.QHttpPart):\n        self.append(other)\n        return self\n\n    def set_content_type(self, typ: ContentTypeStr):\n\"\"\"Set content type.\n\n        Args:\n            typ: content type\n\n        Raises:\n            InvalidParamError: content type does not exist\n        \"\"\"\n        if typ not in CONTENT_TYPES:\n            raise InvalidParamError(typ, CONTENT_TYPES)\n        self.setContentType(CONTENT_TYPES[typ])\n\n    def set_boundary(self, boundary: datatypes.ByteArrayType):\n        if isinstance(boundary, str):\n            boundary = boundary.encode()\n        if isinstance(boundary, bytes):\n            boundary = QtCore.QByteArray(boundary)\n        self.setBoundary(boundary)\n\n    def get_boundary(self) -&gt; str:\n        return bytes(self.boundary()).decode()\n</code></pre>"},{"location":"api/network.html#prettyqt.network.httpmultipart.HttpMultiPart.set_content_type","title":"<code>set_content_type(self, typ: ContentTypeStr)</code>","text":"<p>Set content type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>ContentTypeStr</code> <p>content type</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>content type does not exist</p> Source code in <code>prettyqt/network/httpmultipart.py</code> <pre><code>def set_content_type(self, typ: ContentTypeStr):\n\"\"\"Set content type.\n\n    Args:\n        typ: content type\n\n    Raises:\n        InvalidParamError: content type does not exist\n    \"\"\"\n    if typ not in CONTENT_TYPES:\n        raise InvalidParamError(typ, CONTENT_TYPES)\n    self.setContentType(CONTENT_TYPES[typ])\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaccessmanager","title":"<code>networkaccessmanager</code>","text":""},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager","title":"<code> NetworkAccessManager            (ObjectMixin, QNetworkAccessManager)         </code>","text":"Source code in <code>prettyqt/network/networkaccessmanager.py</code> <pre><code>class NetworkAccessManager(core.ObjectMixin, QtNetwork.QNetworkAccessManager):\n    # def request(\n    #     self,\n    #     method,\n    #     url,\n    #     headers=None,\n    #     cookies=None,\n    #     files=None,\n    #     auth=None,\n    #     timeout=None,\n    #     allow_redirects=True,\n    # ):\n    #     req = network.NetworkRequest()\n    #     if allow_redirects:\n    #         pass\n\n    def get(self, request: datatypes.UrlType | QtNetwork.QNetworkRequest):\n        if isinstance(request, str):\n            request = core.Url(request)\n        request = network.NetworkRequest(request)\n        return super().get(request)\n\n    # def post(self, url, data=None, json=None):\n    #     pass\n\n    # def put(self, url, data=None, json=None):\n    #     pass\n\n    # def patch(self, url, data=None):\n    #     pass\n\n    # def delete(self, url):\n    #     pass\n\n    def set_redirect_policy(self, policy: network.networkrequest.RedirectPolicyStr):\n\"\"\"Set redirect policy.\n\n        Args:\n            policy: redirect policy\n\n        Raises:\n            InvalidParamError: redirect policy does not exist\n        \"\"\"\n        if policy not in network.networkrequest.REDIRECT_POLICIES:\n            raise InvalidParamError(policy, network.networkrequest.REDIRECT_POLICIES)\n        self.setRedirectPolicy(network.networkrequest.REDIRECT_POLICIES[policy])\n\n    def get_redirect_policy(self) -&gt; network.networkrequest.RedirectPolicyStr:\n\"\"\"Get the current redirect policy.\n\n        Returns:\n            redirect policy\n        \"\"\"\n        return network.networkrequest.REDIRECT_POLICIES.inverse[self.redirectPolicy()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.get","title":"<code>get(self, request: datatypes.UrlType | QtNetwork.QNetworkRequest)</code>","text":"<p>get(self, request: PySide6.QtNetwork.QNetworkRequest) -&gt; PySide6.QtNetwork.QNetworkReply</p> Source code in <code>prettyqt/network/networkaccessmanager.py</code> <pre><code>def get(self, request: datatypes.UrlType | QtNetwork.QNetworkRequest):\n    if isinstance(request, str):\n        request = core.Url(request)\n    request = network.NetworkRequest(request)\n    return super().get(request)\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.get_redirect_policy","title":"<code>get_redirect_policy(self) -&gt; network.networkrequest.RedirectPolicyStr</code>","text":"<p>Get the current redirect policy.</p> <p>Returns:</p> Type Description <code>network.networkrequest.RedirectPolicyStr</code> <p>redirect policy</p> Source code in <code>prettyqt/network/networkaccessmanager.py</code> <pre><code>def get_redirect_policy(self) -&gt; network.networkrequest.RedirectPolicyStr:\n\"\"\"Get the current redirect policy.\n\n    Returns:\n        redirect policy\n    \"\"\"\n    return network.networkrequest.REDIRECT_POLICIES.inverse[self.redirectPolicy()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.set_redirect_policy","title":"<code>set_redirect_policy(self, policy: network.networkrequest.RedirectPolicyStr)</code>","text":"<p>Set redirect policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>network.networkrequest.RedirectPolicyStr</code> <p>redirect policy</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>redirect policy does not exist</p> Source code in <code>prettyqt/network/networkaccessmanager.py</code> <pre><code>def set_redirect_policy(self, policy: network.networkrequest.RedirectPolicyStr):\n\"\"\"Set redirect policy.\n\n    Args:\n        policy: redirect policy\n\n    Raises:\n        InvalidParamError: redirect policy does not exist\n    \"\"\"\n    if policy not in network.networkrequest.REDIRECT_POLICIES:\n        raise InvalidParamError(policy, network.networkrequest.REDIRECT_POLICIES)\n    self.setRedirectPolicy(network.networkrequest.REDIRECT_POLICIES[policy])\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaddressentry","title":"<code>networkaddressentry</code>","text":""},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry","title":"<code> NetworkAddressEntry            (QNetworkAddressEntry)         </code>","text":"Source code in <code>prettyqt/network/networkaddressentry.py</code> <pre><code>class NetworkAddressEntry(QtNetwork.QNetworkAddressEntry):\n    def get_dns_eligibility(self) -&gt; DnsEligibilityStatusStr:\n\"\"\"Return whether this address is eligible for publication in the DNS.\n\n        Returns:\n            DNS eligibility\n        \"\"\"\n        return DNS_ELIGIBILITY_STATUS.inverse[self.dnsEligibility()]\n\n    def set_dns_eligibility(self, status: DnsEligibilityStatusStr):\n\"\"\"Set the DNS eligibility flag for this address to status.\n\n        Args:\n            status: DNS eligibility status\n\n        Raises:\n            InvalidParamError: dns eligibility status does not exist\n        \"\"\"\n        if status not in DNS_ELIGIBILITY_STATUS:\n            raise InvalidParamError(status, DNS_ELIGIBILITY_STATUS)\n        self.setDnsEligibility(DNS_ELIGIBILITY_STATUS[status])\n\n    def get_ip(self) -&gt; network.HostAddress:\n        return network.HostAddress(self.ip())\n\n    def set_ip(self, ip: QtNetwork.QHostAddress | str):\n        self.setIp(network.HostAddress(ip))\n\n    def get_netmask(self) -&gt; network.HostAddress:\n        return network.HostAddress(self.netmask())\n\n    def set_netmask(self, netmask: QtNetwork.QHostAddress | str):\n        self.setNetmask(network.HostAddress(netmask))\n\n    def get_preferred_lifetime(self) -&gt; core.DeadlineTimer:\n        return core.DeadlineTimer(self.preferredLifetime())\n\n    def get_validity_lifetime(self) -&gt; core.DeadlineTimer:\n        return core.DeadlineTimer(self.validityLifetime())\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.get_dns_eligibility","title":"<code>get_dns_eligibility(self) -&gt; DnsEligibilityStatusStr</code>","text":"<p>Return whether this address is eligible for publication in the DNS.</p> <p>Returns:</p> Type Description <code>DnsEligibilityStatusStr</code> <p>DNS eligibility</p> Source code in <code>prettyqt/network/networkaddressentry.py</code> <pre><code>def get_dns_eligibility(self) -&gt; DnsEligibilityStatusStr:\n\"\"\"Return whether this address is eligible for publication in the DNS.\n\n    Returns:\n        DNS eligibility\n    \"\"\"\n    return DNS_ELIGIBILITY_STATUS.inverse[self.dnsEligibility()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.set_dns_eligibility","title":"<code>set_dns_eligibility(self, status: DnsEligibilityStatusStr)</code>","text":"<p>Set the DNS eligibility flag for this address to status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>DnsEligibilityStatusStr</code> <p>DNS eligibility status</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>dns eligibility status does not exist</p> Source code in <code>prettyqt/network/networkaddressentry.py</code> <pre><code>def set_dns_eligibility(self, status: DnsEligibilityStatusStr):\n\"\"\"Set the DNS eligibility flag for this address to status.\n\n    Args:\n        status: DNS eligibility status\n\n    Raises:\n        InvalidParamError: dns eligibility status does not exist\n    \"\"\"\n    if status not in DNS_ELIGIBILITY_STATUS:\n        raise InvalidParamError(status, DNS_ELIGIBILITY_STATUS)\n    self.setDnsEligibility(DNS_ELIGIBILITY_STATUS[status])\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkinterface","title":"<code>networkinterface</code>","text":""},{"location":"api/network.html#prettyqt.network.networkinterface.NetworkInterface","title":"<code> NetworkInterface            (QNetworkInterface)         </code>","text":"Source code in <code>prettyqt/network/networkinterface.py</code> <pre><code>class NetworkInterface(QtNetwork.QNetworkInterface):\n    # def __bool__(self):\n    #     return self.isValid()\n\n    def get_type(self) -&gt; InterfaceTypeStr:\n\"\"\"Get the interface type.\n\n        Returns:\n            interface type\n        \"\"\"\n        return INTERFACE_TYPE.inverse[self.type()]\n\n    def get_address_entries(self) -&gt; list[network.NetworkAddressEntry]:\n        return [network.NetworkAddressEntry(i) for i in self.addressEntries()]\n\n    @staticmethod\n    def get_all_addresses() -&gt; list[network.HostAddress]:\n        return [network.HostAddress(i) for i in NetworkInterface.allAddresses()]\n\n    @staticmethod\n    def get_all_interfaces() -&gt; list[network.HostAddress]:\n        return [network.NetworkInterface(i) for i in NetworkInterface.allInterfaces()]\n\n    @staticmethod\n    def get_interface_from_name(name: str) -&gt; NetworkInterface:\n        interface = NetworkInterface.interfaceFromName(name)\n        # if not interface:\n        #     return None\n        return NetworkInterface(interface)\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkinterface.NetworkInterface.get_type","title":"<code>get_type(self) -&gt; InterfaceTypeStr</code>","text":"<p>Get the interface type.</p> <p>Returns:</p> Type Description <code>InterfaceTypeStr</code> <p>interface type</p> Source code in <code>prettyqt/network/networkinterface.py</code> <pre><code>def get_type(self) -&gt; InterfaceTypeStr:\n\"\"\"Get the interface type.\n\n    Returns:\n        interface type\n    \"\"\"\n    return INTERFACE_TYPE.inverse[self.type()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkproxy","title":"<code>networkproxy</code>","text":""},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy","title":"<code> NetworkProxy            (QNetworkProxy)         </code>","text":"Source code in <code>prettyqt/network/networkproxy.py</code> <pre><code>class NetworkProxy(QtNetwork.QNetworkProxy):\n    def get_capabilities(self) -&gt; list[CapabilityStr]:\n        return [k for k, v in CAPABILITIES.items() if v &amp; self.capabilities()]\n\n    def set_capabilities(self, *capability: CapabilityStr):\n        for item in capability:\n            if item not in CAPABILITIES:\n                raise InvalidParamError(item, CAPABILITIES)\n        flags = helpers.merge_flags(capability, CAPABILITIES)\n        self.setCapabilities(flags)\n\n    def get_header(self, name: network.networkrequest.KnownHeaderStr) -&gt; str:\n        if name not in network.networkrequest.KNOWN_HEADER:\n            raise InvalidParamError(name, network.networkrequest.KNOWN_HEADER)\n        return self.header(network.networkrequest.KNOWN_HEADER[name])\n\n    def set_header(self, name: network.networkrequest.KnownHeaderStr, value: str):\n        if name not in network.networkrequest.KNOWN_HEADER:\n            raise InvalidParamError(name, network.networkrequest.KNOWN_HEADER)\n        self.setHeader(network.networkrequest.KNOWN_HEADER[name], value)\n\n    def get_headers(self) -&gt; dict[str, str]:\n        return {\n            bytes(h).decode(): bytes(self.rawHeader(h)).decode()\n            for h in self.rawHeaderList()\n        }\n\n    def set_headers(self, headers: dict[str, str]):\n        for k, v in headers.items():\n            self.setRawHeader(\n                QtCore.QByteArray(k.encode()), QtCore.QByteArray(v.encode())\n            )\n\n    def set_type(self, typ: ProxyTypeStr):\n\"\"\"Set proxy type.\n\n        Args:\n            typ: proxy type\n\n        Raises:\n            InvalidParamError: proxy type does not exist\n        \"\"\"\n        if typ not in PROXY_TYPES:\n            raise InvalidParamError(typ, PROXY_TYPES)\n        self.setType(PROXY_TYPES[typ])\n\n    def get_type(self) -&gt; ProxyTypeStr:\n\"\"\"Get the proxy type.\n\n        Returns:\n            type\n        \"\"\"\n        return PROXY_TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.get_type","title":"<code>get_type(self) -&gt; ProxyTypeStr</code>","text":"<p>Get the proxy type.</p> <p>Returns:</p> Type Description <code>ProxyTypeStr</code> <p>type</p> Source code in <code>prettyqt/network/networkproxy.py</code> <pre><code>def get_type(self) -&gt; ProxyTypeStr:\n\"\"\"Get the proxy type.\n\n    Returns:\n        type\n    \"\"\"\n    return PROXY_TYPES.inverse[self.type()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.set_type","title":"<code>set_type(self, typ: ProxyTypeStr)</code>","text":"<p>Set proxy type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>ProxyTypeStr</code> <p>proxy type</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>proxy type does not exist</p> Source code in <code>prettyqt/network/networkproxy.py</code> <pre><code>def set_type(self, typ: ProxyTypeStr):\n\"\"\"Set proxy type.\n\n    Args:\n        typ: proxy type\n\n    Raises:\n        InvalidParamError: proxy type does not exist\n    \"\"\"\n    if typ not in PROXY_TYPES:\n        raise InvalidParamError(typ, PROXY_TYPES)\n    self.setType(PROXY_TYPES[typ])\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkrequest","title":"<code>networkrequest</code>","text":""},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest","title":"<code> NetworkRequest            (QNetworkRequest)         </code>","text":"Source code in <code>prettyqt/network/networkrequest.py</code> <pre><code>class NetworkRequest(QtNetwork.QNetworkRequest):\n    def __init__(self, obj: datatypes.UrlType | QtNetwork.QNetworkRequest | None = None):\n        if isinstance(obj, QtNetwork.QNetworkRequest):\n            super().__init__(obj)\n        else:\n            super().__init__()\n            if obj is not None:\n                self.set_url(obj)\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.get_url()})\"\n\n    def set_header(self, name: KnownHeaderStr, value: str):\n        if name not in KNOWN_HEADER:\n            raise InvalidParamError(name, KNOWN_HEADER)\n        self.setHeader(KNOWN_HEADER[name], value)\n\n    def get_header(self, name: KnownHeaderStr) -&gt; str:\n        if name not in KNOWN_HEADER:\n            raise InvalidParamError(name, KNOWN_HEADER)\n        return self.header(KNOWN_HEADER[name])\n\n    def set_headers(self, headers: dict[str, str]):\n        for k, v in headers.items():\n            self.setRawHeader(\n                QtCore.QByteArray(k.encode()), QtCore.QByteArray(v.encode())\n            )\n\n    def get_headers(self) -&gt; dict[str, str]:\n        return {\n            bytes(h).decode(): bytes(self.rawHeader(h)).decode()\n            for h in self.rawHeaderList()\n        }\n\n    def set_url(self, url: str | QtCore.QUrl):\n        url = core.Url(url)\n        self.setUrl(url)\n\n    def get_url(self) -&gt; core.Url:\n        return core.Url(self.url())\n\n    def set_priority(self, priority: PriorityStr):\n\"\"\"Set priority.\n\n        Args:\n            priority: priority\n\n        Raises:\n            InvalidParamError: priority does not exist\n        \"\"\"\n        if priority not in PRIORITY:\n            raise InvalidParamError(priority, PRIORITY)\n        self.setPriority(PRIORITY[priority])\n\n    def get_priority(self) -&gt; PriorityStr:\n\"\"\"Get the current priority.\n\n        Returns:\n            priority\n        \"\"\"\n        return PRIORITY.inverse[self.priority()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.get_priority","title":"<code>get_priority(self) -&gt; PriorityStr</code>","text":"<p>Get the current priority.</p> <p>Returns:</p> Type Description <code>PriorityStr</code> <p>priority</p> Source code in <code>prettyqt/network/networkrequest.py</code> <pre><code>def get_priority(self) -&gt; PriorityStr:\n\"\"\"Get the current priority.\n\n    Returns:\n        priority\n    \"\"\"\n    return PRIORITY.inverse[self.priority()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.set_priority","title":"<code>set_priority(self, priority: PriorityStr)</code>","text":"<p>Set priority.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>PriorityStr</code> <p>priority</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>priority does not exist</p> Source code in <code>prettyqt/network/networkrequest.py</code> <pre><code>def set_priority(self, priority: PriorityStr):\n\"\"\"Set priority.\n\n    Args:\n        priority: priority\n\n    Raises:\n        InvalidParamError: priority does not exist\n    \"\"\"\n    if priority not in PRIORITY:\n        raise InvalidParamError(priority, PRIORITY)\n    self.setPriority(PRIORITY[priority])\n</code></pre>"},{"location":"api/network.html#prettyqt.network.tcpserver","title":"<code>tcpserver</code>","text":""},{"location":"api/network.html#prettyqt.network.tcpserver.TcpServer","title":"<code> TcpServer            (ObjectMixin, QTcpServer)         </code>","text":"Source code in <code>prettyqt/network/tcpserver.py</code> <pre><code>class TcpServer(core.ObjectMixin, QtNetwork.QTcpServer):\n    def listen(  # type: ignore\n        self, address: str | QtNetwork.QHostAddress, port: int = 0\n    ) -&gt; bool:\n        if isinstance(address, str):\n            address = network.HostAddress(address)\n        return super().listen(address, port)\n\n    def get_server_address(self) -&gt; network.HostAddress:\n        return network.HostAddress(self.serverAddress())\n\n    def get_proxy(self) -&gt; network.NetworkProxy:\n        return network.NetworkProxy(self.proxy())\n\n    def get_server_error(self) -&gt; network.abstractsocket.SocketErrorStr:\n        return network.abstractsocket.SOCKET_ERROR.inverse[self.serverError()]\n</code></pre>"},{"location":"api/network.html#prettyqt.network.tcpserver.TcpServer.listen","title":"<code>listen(self, address: str | QtNetwork.QHostAddress, port: int = 0) -&gt; bool</code>","text":"<p>listen(self, address: Union[PySide6.QtNetwork.QHostAddress, PySide6.QtNetwork.QHostAddress.SpecialAddress] = Instance(QHostAddress.Any), port: int = 0) -&gt; bool</p> Source code in <code>prettyqt/network/tcpserver.py</code> <pre><code>def listen(  # type: ignore\n    self, address: str | QtNetwork.QHostAddress, port: int = 0\n) -&gt; bool:\n    if isinstance(address, str):\n        address = network.HostAddress(address)\n    return super().listen(address, port)\n</code></pre>"},{"location":"api/objbrowser.html","title":"objbrowser module","text":"<p>Objbrowser package.</p>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.attribute_model","title":"<code>attribute_model</code>","text":"<p>Module that defines AttributeModel.</p>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.attribute_model.safe_data_fn","title":"<code>safe_data_fn(obj_fn: Callable, log_exceptions: bool = False) -&gt; Callable</code>","text":"<p>Create a function that returns an empty string in case of an exception.</p> <p>:param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function</p> Source code in <code>prettyqt/objbrowser/attribute_model.py</code> <pre><code>def safe_data_fn(\n    obj_fn: Callable,\n    log_exceptions: bool = False,\n) -&gt; Callable:\n\"\"\"Create a function that returns an empty string in case of an exception.\n\n    :param fnobj_fn: function that will be wrapped\n    :type obj_fn: object to basestring function\n    :returns: function that can be used as AttributeModel data_fn attribute\n    :rtype: custom_models.treeitem.TreeItem to string function\n    \"\"\"\n\n    def data_fn(tree_item: treeitem.TreeItem) -&gt; str:\n\"\"\"Call the obj_fn(tree_item.obj).\n\n        Returns empty string in case of an error\n        \"\"\"\n        try:\n            return str(obj_fn(tree_item.obj))\n        except Exception as ex:\n            if log_exceptions:\n                logger.exception(ex)\n            return \"\"\n\n    return data_fn\n</code></pre>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser","title":"<code>objectbrowser</code>","text":"<p>Object browser GUI in Qt.</p>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser","title":"<code> ObjectBrowser            (MainWindow)         </code>","text":"Source code in <code>prettyqt/objbrowser/objectbrowser.py</code> <pre><code>class ObjectBrowser(widgets.MainWindow):\n\"\"\"Object browser main application window.\"\"\"\n\n    _app = None  # Reference to the global application.\n    _browsers: list[ObjectBrowser | None] = []  # Keep lists of browser windows.\n\n    def __init__(self, obj, name: str = \"\"):\n        super().__init__()\n        self.set_title(\"Object browser\")\n        self._instance_nr = self._add_instance()\n        self.set_icon(\"mdi.language-python\")\n        self._attr_cols = DEFAULT_ATTR_COLS\n        self._attr_details = DEFAULT_ATTR_DETAILS\n\n        logger.debug(\"Reading model settings for window: %d\", self._instance_nr)\n        with core.Settings(settings_id=self._settings_group_name(\"model\")) as settings:\n            self._auto_refresh = settings.get(\"auto_refresh\", False)\n            self._refresh_rate = settings.get(\"refresh_rate\", 2)\n            show_callable_attrs = settings.get(\"show_callable_attrs\", True)\n            show_special_attrs = settings.get(\"show_special_attrs\", True)\n        self._tree_model = objectbrowsertreemodel.ObjectBrowserTreeModel(\n            obj, name, attr_cols=self._attr_cols\n        )\n\n        self._proxy_tree_model = objectbrowsertreemodel.ObjectBrowserTreeProxyModel(\n            show_callable_attrs=show_callable_attrs,\n            show_special_attrs=show_special_attrs,\n        )\n\n        self._proxy_tree_model.setSourceModel(self._tree_model)\n        # self._proxy_tree_model.setSortRole(RegistryTableModel.SORT_ROLE)\n        self._proxy_tree_model.setDynamicSortFilter(True)\n        # self._proxy_tree_model.setSortCaseSensitivity(Qt.CaseInsensitive)\n\n        # Views\n        self._setup_actions()\n        self.central_splitter = widgets.Splitter(\n            parent=self, orientation=constants.VERTICAL\n        )\n        self.setCentralWidget(self.central_splitter)\n\n        # Tree widget\n        self.obj_tree = widgets.TreeView()\n        self.obj_tree.setRootIsDecorated(True)\n        self.obj_tree.setAlternatingRowColors(True)\n        self.obj_tree.set_model(self._proxy_tree_model)\n        self.obj_tree.set_selection_behaviour(\"rows\")\n        self.obj_tree.setUniformRowHeights(True)\n        self.obj_tree.setAnimated(True)\n\n        # Stretch last column?\n        # It doesn't play nice when columns are hidden and then shown again.\n        self.obj_tree.h_header.set_id(\"table_header\")\n        self.obj_tree.h_header.setSectionsMovable(True)\n        self.obj_tree.h_header.setStretchLastSection(False)\n        self.central_splitter.addWidget(self.obj_tree)\n\n        # Bottom pane\n        bottom_pane_widget = widgets.Widget()\n        bottom_pane_widget.set_layout(\"horizontal\", spacing=0, margin=5)\n        self.central_splitter.addWidget(bottom_pane_widget)\n\n        group_box = widgets.GroupBox(\"Details\")\n        bottom_pane_widget.box.addWidget(group_box)\n\n        group_box.set_layout(\"horizontal\", margin=2)\n\n        # Radio buttons\n        radio_widget = widgets.Widget()\n        radio_widget.set_layout(\"vertical\", margin=0)\n\n        self.button_group = widgets.ButtonGroup(self)\n        for button_id, attr_detail in enumerate(self._attr_details):\n            radio_button = widgets.RadioButton(attr_detail.name)\n            radio_widget.box.addWidget(radio_button)\n            self.button_group.addButton(radio_button, button_id)\n\n        self.button_group.buttonClicked.connect(self._change_details_field)\n        self.button_group.button(0).setChecked(True)\n\n        radio_widget.box.addStretch(1)\n        group_box.box.addWidget(radio_widget)\n\n        # Editor widget\n        font = gui.Font(\"Courier\")\n        font.setFixedPitch(True)\n        # font.setPointSize(14)\n\n        self.editor = widgets.PlainTextEdit()\n        self.editor.setReadOnly(True)\n        self.editor.setFont(font)\n        group_box.box.addWidget(self.editor)\n\n        # Splitter parameters\n        self.central_splitter.setCollapsible(0, False)\n        self.central_splitter.setCollapsible(1, True)\n        self.central_splitter.setSizes([400, 200])\n        self.central_splitter.setStretchFactor(0, 10)\n        self.central_splitter.setStretchFactor(1, 0)\n\n        selection_model = self.obj_tree.selectionModel()\n        selection_model.currentChanged.connect(self._update_details)\n        menubar = self.menuBar()\n        file_menu = menubar.add_menu(\"&amp;File\")\n        close_action = widgets.Action(\n            text=\"C&amp;lose\", callback=self.close, shortcut=\"Ctrl+W\"\n        )\n        file_menu.addAction(close_action)\n        exit_action = widgets.Action(\n            text=\"E&amp;xit\",\n            callback=lambda: widgets.app().closeAllWindows(),\n            shortcut=\"Ctrl+Q\",\n        )\n        file_menu.addAction(exit_action)\n\n        view_menu = menubar.add_menu(\"&amp;View\")\n        refresh_action = widgets.Action(\n            text=\"&amp;Refresh\",\n            callback=self._tree_model.refresh_tree,\n            shortcut=\"Ctrl+R\",\n        )\n        view_menu.addAction(refresh_action)\n        view_menu.addAction(self.toggle_auto_refresh_action)\n\n        view_menu.addSeparator()\n        self.show_cols_submenu = widgets.Menu(\"Table columns\")\n        view_menu.add_menu(self.show_cols_submenu)\n        actions = self.obj_tree.h_header.get_header_actions()\n        self.show_cols_submenu.add_actions(actions)\n        view_menu.addSeparator()\n        view_menu.addAction(self.toggle_callable_action)\n        view_menu.addAction(self.toggle_special_attribute_action)\n\n        assert self._refresh_rate &gt; 0\n        self._refresh_timer = core.Timer(self)\n        self._refresh_timer.setInterval(self._refresh_rate * 1000)\n        self._refresh_timer.timeout.connect(self._tree_model.refresh_tree)\n\n        # Update views with model\n        self.toggle_special_attribute_action.setChecked(show_special_attrs)\n        self.toggle_callable_action.setChecked(show_callable_attrs)\n        self.toggle_auto_refresh_action.setChecked(self._auto_refresh)\n\n        # Select first row so that a hidden root node will not be selected.\n        first_row_index = self._proxy_tree_model.first_item_index()\n        self.obj_tree.setCurrentIndex(first_row_index)\n        if self._tree_model.inspected_node_is_visible:\n            self.obj_tree.expand(first_row_index)\n\n    def _add_instance(self) -&gt; int:\n\"\"\"Adds the browser window to the list of browser references.\n\n        If a None is present in the list it is inserted at that position, otherwise\n        it is appended to the list. The index number is returned.\n\n        This mechanism is used so that repeatedly creating and closing windows does not\n        increase the instance number, which is used in writing the persistent settings.\n        \"\"\"\n        try:\n            idx = self._browsers.index(None)\n        except ValueError:\n            self._browsers.append(self)\n            idx = len(self._browsers) - 1\n        else:\n            self._browsers[idx] = self\n\n        return idx\n\n    def _setup_actions(self):\n\"\"\"Create the main window actions.\"\"\"\n        # Show/hide callable objects\n        self.toggle_callable_action = widgets.Action(\n            text=\"Show callable attributes\",\n            parent=self,\n            checkable=True,\n            shortcut=gui.KeySequence(\"Alt+C\"),\n            statustip=\"Shows/hides callable attributes (functions, methods, etc.)\",\n        )\n        self.toggle_callable_action.toggled.connect(\n            self._proxy_tree_model.set_show_callables\n        )\n\n        # Show/hide special attributes\n        self.toggle_special_attribute_action = widgets.Action(\n            text=\"Show __special__ attributes\",\n            parent=self,\n            checkable=True,\n            shortcut=gui.KeySequence(\"Alt+S\"),\n            statustip=\"Shows or hides __special__ attributes\",\n        )\n        self.toggle_special_attribute_action.toggled.connect(\n            self._proxy_tree_model.set_show_special_attrs\n        )\n\n        # Toggle auto-refresh on/off\n        self.toggle_auto_refresh_action = widgets.Action(\n            text=\"Auto-refresh\",\n            parent=self,\n            checkable=True,\n            statustip=f\"Auto refresh every {self._refresh_rate} seconds\",\n        )\n        self.toggle_auto_refresh_action.toggled.connect(self.toggle_auto_refresh)\n\n        # Add another refresh action with a different shortcut. An action must be added to\n        # a visible widget for it to receive events. It is added to the main windows to\n        # prevent it from being displayed again in the menu\n        self.refresh_action_f5 = widgets.Action(self, text=\"&amp;Refresh2\", shortcut=\"F5\")\n        self.refresh_action_f5.triggered.connect(self._tree_model.refresh_tree)\n        self.addAction(self.refresh_action_f5)\n\n    def _settings_group_name(self, postfix: str) -&gt; str:\n\"\"\"Construct a group name for the persistent settings.\n\n        Because the columns in the main table are extendible, we must store the settings\n        in a different group if a different combination of columns is used. Therefore the\n        settings group name contains a hash that is calculated from the used column names.\n        Furthermore the window number is included in the settings group name. Finally a\n        postfix string is appended.\n        \"\"\"\n        column_names = \",\".join([col.name for col in self._attr_cols])\n        columns_hash = hashlib.md5(column_names.encode(\"utf-8\")).hexdigest()\n        return f\"{columns_hash}_win{self._instance_nr}_{postfix}\"\n\n    def _write_model_settings(self):\n\"\"\"Write the model settings to the persistent store.\"\"\"\n        logger.debug(\"Writing model settings for window: %d\", self._instance_nr)\n        new = dict(\n            auto_refresh=self._auto_refresh,\n            refresh_rate=self._refresh_rate,\n            show_callable_attrs=self._proxy_tree_model.get_show_callables(),\n            show_special_attrs=self._proxy_tree_model.get_show_special_attrs(),\n        )\n        settings_id = self._settings_group_name(\"model\")\n        logger.debug(f\"New settings: {new}\")\n        with core.Settings(settings_id=settings_id) as settings:\n            settings.set_values(new)\n\n    @core.Slot(core.ModelIndex, core.ModelIndex)\n    def _update_details(\n        self, current_index: core.ModelIndex, _previous_index: core.ModelIndex\n    ):\n\"\"\"Show the object details in the editor given an index.\"\"\"\n        tree_item = self._proxy_tree_model.tree_item(current_index)\n        self._update_details_for_item(tree_item)\n\n    def _change_details_field(self, _button_id=None):\n\"\"\"Change the field that is displayed in the details pane.\"\"\"\n        # logger.debug(\"_change_details_field: {}\".format(_button_id))\n        current_index = self.obj_tree.selectionModel().currentIndex()\n        tree_item = self._proxy_tree_model.tree_item(current_index)\n        self._update_details_for_item(tree_item)\n\n    def _update_details_for_item(self, tree_item):\n\"\"\"Show the object details in the editor given an tree_item.\"\"\"\n        with self.editor.edit_stylesheet() as ss:\n            ss.color.setValue(\"black\")\n        try:\n            # obj = tree_item.obj\n            button_id = self.button_group.checkedId()\n            assert button_id &gt;= 0, \"No radio button selected. Please report this bug.\"\n            attr_details = self._attr_details[button_id]\n            data = attr_details.get_label(tree_item)\n            self.editor.set_text(data)\n            self.editor.set_word_wrap_mode(attr_details.line_wrap)\n\n        except Exception as ex:\n            with self.editor.edit_stylesheet() as ss:\n                ss.color.setValue(\"red\")\n            stack_trace = traceback.format_exc()\n            self.editor.set_text(f\"{ex}\\n\\n{stack_trace}\")\n            self.editor.set_wrap_mode(\"boundary_or_anywhere\")\n\n    def toggle_auto_refresh(self, checked):\n\"\"\"Toggle auto-refresh on/off.\"\"\"\n        if checked:\n            logger.info(\"Auto-refresh on. Rate %g seconds\", self._refresh_rate)\n            self._refresh_timer.start()\n        else:\n            logger.info(\"Auto-refresh off\")\n            self._refresh_timer.stop()\n        self._auto_refresh = checked\n\n    def closeEvent(self, event):\n\"\"\"Called when the window is closed.\"\"\"\n        logger.debug(\"closeEvent\")\n        self._write_model_settings()\n        self._refresh_timer.stop()\n        self._refresh_timer.timeout.disconnect(self._tree_model.refresh_tree)\n        self.toggle_callable_action.toggled.disconnect(\n            self._proxy_tree_model.set_show_callables\n        )\n        self.toggle_special_attribute_action.toggled.disconnect(\n            self._proxy_tree_model.set_show_special_attrs\n        )\n        self.toggle_auto_refresh_action.toggled.disconnect(self.toggle_auto_refresh)\n        self.refresh_action_f5.triggered.disconnect(self._tree_model.refresh_tree)\n        self.button_group.buttonClicked.disconnect(self._change_details_field)\n        selection_model = self.obj_tree.selectionModel()\n        selection_model.currentChanged.disconnect(self._update_details)\n        self.close()\n        event.accept()\n\"\"\"Set the reference in the browser list to None.\"\"\"\n        idx = self._browsers.index(self)\n        self._browsers[idx] = None\n        logger.debug(\"Closed window %s\", self._instance_nr)\n\n    @classmethod\n    def browse(cls, *args, **kwargs):\n\"\"\"Create and run object browser.\n\n        For this, the following three steps are done:\n        1) Create QApplication object if it doesn't yet exist\n        2) Create and show an ObjectBrowser window\n        3) Start the Qt event loop.\n\n        The *args and **kwargs will be passed to the ObjectBrowser constructor.\n        \"\"\"\n        cls.app = widgets.app()  # keeping reference to prevent garbage collection.\n        cls.app.setOrganizationName(\"phil65\")\n        cls.app.setApplicationName(\"PrettyQt\")\n        object_browser = cls(*args, **kwargs)\n        object_browser.show()\n        object_browser.raise_()\n        return cls.app.main_loop()\n</code></pre>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.browse","title":"<code>browse(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create and run object browser.</p> <p>For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop.</p> <p>The args and *kwargs will be passed to the ObjectBrowser constructor.</p> Source code in <code>prettyqt/objbrowser/objectbrowser.py</code> <pre><code>@classmethod\ndef browse(cls, *args, **kwargs):\n\"\"\"Create and run object browser.\n\n    For this, the following three steps are done:\n    1) Create QApplication object if it doesn't yet exist\n    2) Create and show an ObjectBrowser window\n    3) Start the Qt event loop.\n\n    The *args and **kwargs will be passed to the ObjectBrowser constructor.\n    \"\"\"\n    cls.app = widgets.app()  # keeping reference to prevent garbage collection.\n    cls.app.setOrganizationName(\"phil65\")\n    cls.app.setApplicationName(\"PrettyQt\")\n    object_browser = cls(*args, **kwargs)\n    object_browser.show()\n    object_browser.raise_()\n    return cls.app.main_loop()\n</code></pre>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.closeEvent","title":"<code>closeEvent(self, event)</code>","text":"<p>Called when the window is closed.</p> Source code in <code>prettyqt/objbrowser/objectbrowser.py</code> <pre><code>def closeEvent(self, event):\n\"\"\"Called when the window is closed.\"\"\"\n    logger.debug(\"closeEvent\")\n    self._write_model_settings()\n    self._refresh_timer.stop()\n    self._refresh_timer.timeout.disconnect(self._tree_model.refresh_tree)\n    self.toggle_callable_action.toggled.disconnect(\n        self._proxy_tree_model.set_show_callables\n    )\n    self.toggle_special_attribute_action.toggled.disconnect(\n        self._proxy_tree_model.set_show_special_attrs\n    )\n    self.toggle_auto_refresh_action.toggled.disconnect(self.toggle_auto_refresh)\n    self.refresh_action_f5.triggered.disconnect(self._tree_model.refresh_tree)\n    self.button_group.buttonClicked.disconnect(self._change_details_field)\n    selection_model = self.obj_tree.selectionModel()\n    selection_model.currentChanged.disconnect(self._update_details)\n    self.close()\n    event.accept()\n\"\"\"Set the reference in the browser list to None.\"\"\"\n    idx = self._browsers.index(self)\n    self._browsers[idx] = None\n    logger.debug(\"Closed window %s\", self._instance_nr)\n</code></pre>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.toggle_auto_refresh","title":"<code>toggle_auto_refresh(self, checked)</code>","text":"<p>Toggle auto-refresh on/off.</p> Source code in <code>prettyqt/objbrowser/objectbrowser.py</code> <pre><code>def toggle_auto_refresh(self, checked):\n\"\"\"Toggle auto-refresh on/off.\"\"\"\n    if checked:\n        logger.info(\"Auto-refresh on. Rate %g seconds\", self._refresh_rate)\n        self._refresh_timer.start()\n    else:\n        logger.info(\"Auto-refresh off\")\n        self._refresh_timer.stop()\n    self._auto_refresh = checked\n</code></pre>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel","title":"<code>objectbrowsertreemodel</code>","text":"<p>Module that defines the TreeModel.</p> <p>Based on: PySide examples/itemviews/simpletreemodel See: https://github.com/PySide/Examples/blob/master/examples/itemviews/simpletreemodel /simpletreemodel.py</p>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem","title":"<code> ObjectBrowserTreeItem            (TreeItem)         </code>","text":"<p>Tree node class that can be used to build trees of objects.</p> Source code in <code>prettyqt/objbrowser/objectbrowsertreemodel.py</code> <pre><code>class ObjectBrowserTreeItem(treeitem.TreeItem):\n\"\"\"Tree node class that can be used to build trees of objects.\"\"\"\n\n    def __init__(\n        self,\n        obj,\n        name: str,\n        obj_path,\n        is_attribute: bool,\n        parent: ObjectBrowserTreeItem | None = None,\n    ):\n        super().__init__(obj, parent=parent)\n        # self.parent_item = parent\n        # self.obj = obj\n        # self.child_items: List[ObjectBrowserTreeItem] = []\n        # self.has_children = True\n        # self.children_fetched = False\n        self.obj_name = name\n        self.obj_path = str(obj_path)\n        self.is_attribute = is_attribute\n\n    @property\n    def is_special_attribute(self) -&gt; bool:\n\"\"\"Return true if the item represents a dunder attribute.\"\"\"\n        return (\n            self.is_attribute\n            and self.obj_name.startswith(\"__\")\n            and self.obj_name.endswith(\"__\")\n        )\n\n    @property\n    def is_callable_attribute(self) -&gt; bool:\n\"\"\"Return true if the items is an attribute and it is callable.\"\"\"\n        return self.is_attribute and callable(self.obj)\n</code></pre>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem.is_callable_attribute","title":"<code>is_callable_attribute: bool</code>  <code>property</code> <code>readonly</code>","text":"<p>Return true if the items is an attribute and it is callable.</p>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem.is_special_attribute","title":"<code>is_special_attribute: bool</code>  <code>property</code> <code>readonly</code>","text":"<p>Return true if the item represents a dunder attribute.</p>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel","title":"<code> ObjectBrowserTreeModel            (ColumnItemModel)         </code>","text":"Source code in <code>prettyqt/objbrowser/objectbrowsertreemodel.py</code> <pre><code>class ObjectBrowserTreeModel(custom_models.ColumnItemModel):\n\"\"\"Model that provides an interface to an objectree that is build of tree items.\"\"\"\n\n    def __init__(\n        self,\n        obj: Any,\n        obj_name: str = \"\",\n        attr_cols: list[custom_models.ColumnItem] | None = None,\n        parent: QtCore.QObject | None = None,\n    ):\n        super().__init__(attr_cols=attr_cols, parent=parent)\n        # The root_item is always invisible. If the obj_name is the empty string, the\n        # inspectedItem will be the invisible root_item. If the obj_name is given,\n        # an invisible root item will be added and the inspectedItem will be its\n        # only child. In that case the inspected item will be visible.\n        self._inspected_node_is_visible = obj_name != \"\"\n\n        if self._inspected_node_is_visible:\n            self._root_item = ObjectBrowserTreeItem(\n                obj=None,\n                name=\"&lt;invisible_root&gt;\",\n                obj_path=\"&lt;invisible_root&gt;\",\n                is_attribute=None,\n            )\n            self._root_item.children_fetched = True\n            self.inspected_item = ObjectBrowserTreeItem(\n                obj=obj, name=obj_name, obj_path=obj_name, is_attribute=None\n            )\n            self._root_item.append_child(self.inspected_item)\n        else:\n            # The root itself will be invisible\n            self._root_item = ObjectBrowserTreeItem(\n                obj=obj, name=obj_name, obj_path=obj_name, is_attribute=None\n            )\n            self.inspected_item = self._root_item\n\n            # Fetch all items of the root so we can select the first row in the ctor.\n            root_index = self.index(0, 0)\n            self.fetchMore(root_index)\n\n    @property\n    def inspected_node_is_visible(self):\n\"\"\"Return True if the inspected node is visible.\n\n        In that case an invisible root node has been added.\n        \"\"\"\n        return self._inspected_node_is_visible\n\n    def _fetch_object_children(\n        self, treeitem: treeitem.TreeItem\n    ) -&gt; list[ObjectBrowserTreeItem]:\n\"\"\"Fetch the children of a Python object.\n\n        Returns: list of ObjectBrowserTreeItems\n        \"\"\"\n        obj_children = []\n        path_strings = []\n        obj = treeitem.obj\n        obj_path = treeitem.obj_path\n        if isinstance(obj, (list, tuple, set, frozenset)):\n            obj_children = [(str(i), j) for i, j in sorted(enumerate(obj))]\n            path_strings = [\n                f\"{obj_path}[{i[0]}]\" if obj_path else i[0] for i in obj_children\n            ]\n        # elif isinstance(obj, (set, frozenset)):\n        #     obj_children = [(\"pop()\", elem) for elem in obj]\n        #     path_strings = [\n        #         \"{0}.pop()\".format(obj_path) if obj_path else item[0]\n        #         for item in obj_children\n        #     ]\n        elif hasattr(obj, \"items\") and callable(getattr(obj, \"items\")):  # dicts etc.\n            try:\n                obj_children = list(obj.items())\n            except Exception as ex:\n                # Can happen if the items method expects an argument, for instance the\n                # types.DictType.items method expects a dictionary.\n                logger.warn(\"No items expanded. Objects items() call failed: %s\", ex)\n                obj_children = []\n\n            # Sort keys, except when the object is an OrderedDict.\n            if not isinstance(obj, OrderedDict):\n                try:\n                    obj_children = sorted(obj.items())\n                except Exception as ex:\n                    logger.debug(\"Unable to sort dictionary keys: %s\", ex)\n\n            path_strings = [\n                f\"{obj_path}[{item[0]!r}]\" if obj_path else item[0]\n                for item in obj_children\n            ]\n\n        is_attr_list = [False] * len(obj_children)\n\n        # Object attributes\n        for attr_name, attr_value in sorted(inspect.getmembers(obj)):\n            obj_children.append((attr_name, attr_value))\n            path_strings.append(f\"{obj_path}.{attr_name}\" if obj_path else attr_name)\n            is_attr_list.append(True)\n\n        tree_items = [\n            ObjectBrowserTreeItem(obj=val, name=name, obj_path=p, is_attribute=is_attr)\n            for (name, val), p, is_attr in zip(obj_children, path_strings, is_attr_list)\n        ]\n        return tree_items\n\n    def _aux_refresh_tree(self, tree_index: core.ModelIndex):\n\"\"\"Refresh the tree nodes recursively, auxiliary.\n\n        If the underlying Python object has been changed, we don't want to delete the old\n        tree model and create a new one from scratch because this loses all information\n        about which nodes are fetched and expanded. Instead the old tree model is updated.\n        Using the difflib from the standard library it is determined for a parent node\n        which child nodes should be added or removed. This is done based on the node names\n        only, not on the node contents (the underlying Python objects). Testing the\n        underlying nodes for equality is potentially slow. It is faster to let the\n        refreshNode function emit the dataChanged signal for all cells.\n        \"\"\"\n        tree_item = self.tree_item(tree_index)\n        if not tree_item.children_fetched:\n            return None\n        old_items = tree_item.child_items\n        new_items = self._fetch_object_children(tree_item)\n\n        old_item_names = [(item.obj_name, item.is_attribute) for item in old_items]\n        new_item_names = [(item.obj_name, item.is_attribute) for item in new_items]\n        seq_matcher = SequenceMatcher(\n            isjunk=None, a=old_item_names, b=new_item_names, autojunk=False\n        )\n        opcodes = seq_matcher.get_opcodes()\n\n        logger.debug(\"(reversed) opcodes: %s\", list(reversed(opcodes)))\n\n        for tag, i1, i2, j1, j2 in reversed(opcodes):\n            # logger.debug(\n            #     \"  {:7s}, a[{}:{}] ({}), b[{}:{}] ({})\".format(\n            #         tag, i1, i2, old_item_names[i1:i2], j1, j2, new_item_names[j1:j2]\n            #     )\n            # )\n            match tag:\n                case \"equal\":\n                    # when node names are equal is aux_refresh_tree called recursively.\n                    for old_row, new_row in zip(range(i1, i2), range(j1, j2)):\n                        old_items[old_row].obj = new_items[new_row].obj\n                        child_index = self.index(old_row, 0, parent=tree_index)\n                        self._aux_refresh_tree(child_index)\n\n                case \"replace\":\n                    # Remove the old item and insert the new. The old item may have child\n                    # nodes which indices must be removed by Qt, otherwise it crashes.\n                    first = i1  # row number of first that will be removed\n                    last = i1 + i2 - 1  # row number of last element after insertion\n                    with self.remove_rows(first, last, tree_index):\n                        del tree_item.child_items[i1:i2]\n\n                    first = i1  # row number of first element after insertion\n                    last = i1 + j2 - j1 - 1  # row number of last element after insertion\n                    with self.insert_rows(first, last, tree_index):\n                        tree_item.insert_children(i1, new_items[j1:j2])\n\n                case \"delete\":\n                    first = i1  # row number of first that will be removed\n                    last = i1 + i2 - 1  # row number of last element after insertion\n                    with self.remove_rows(first, last, tree_index):\n                        del tree_item.child_items[i1:i2]\n\n                case \"insert\":\n                    first = i1\n                    last = i1 + j2 - j1 - 1\n                    with self.insert_rows(first, last, tree_index):\n                        tree_item.insert_children(i1, new_items[j1:j2])\n                case _:\n                    raise ValueError(f\"Invalid tag: {tag}\")\n\n    def refresh_tree(self):\n        if self._inspected_node_is_visible:\n            index = self.createIndex(0, 0, self.inspected_item)\n        else:\n            index = self.root_index()\n\"\"\"Refresh the tree model from the underlying root object.\"\"\"\n        self._aux_refresh_tree(index)\n        # Emit the dataChanged signal for all cells. This is faster than checking which\n        # nodes have changed, which may be slow for some underlying Python objects.\n        self.update_all()\n</code></pre>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.inspected_node_is_visible","title":"<code>inspected_node_is_visible</code>  <code>property</code> <code>readonly</code>","text":"<p>Return True if the inspected node is visible.</p> <p>In that case an invisible root node has been added.</p>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel","title":"<code> ObjectBrowserTreeProxyModel            (SortFilterProxyModel)         </code>","text":"Source code in <code>prettyqt/objbrowser/objectbrowsertreemodel.py</code> <pre><code>class ObjectBrowserTreeProxyModel(core.SortFilterProxyModel):\n\"\"\"Proxy model that overrides the sorting and can filter out items.\"\"\"\n\n    def __init__(\n        self,\n        show_callable_attrs: bool = True,\n        show_special_attrs: bool = True,\n        parent=None,\n    ):\n        super().__init__(parent)\n\n        self._show_callables = show_callable_attrs\n        self._show_special_attrs = show_special_attrs\n\n    def tree_item(self, proxy_index: core.ModelIndex) -&gt; ObjectBrowserTreeItem:\n        index = self.mapToSource(proxy_index)\n        return self.sourceModel().tree_item(index)\n\n    def filterAcceptsRow(self, source_row: int, source_parent_index: core.ModelIndex):\n\"\"\"Return true if the item should be included in the model.\"\"\"\n        parent_item = self.sourceModel().tree_item(source_parent_index)\n        tree_item = parent_item.child(source_row)\n\n        accept = (self._show_special_attrs or not tree_item.is_special_attribute) and (\n            self._show_callables or not tree_item.is_callable_attribute\n        )\n\n        # logger.debug(\"filterAcceptsRow = {}: {}\".format(accept, tree_item))\n        return accept\n\n    def get_show_callables(self) -&gt; bool:\n        return self._show_callables\n\n    def set_show_callables(self, show_callables: bool):\n\"\"\"Show/hide show_callables which have a __call__ attribute.\"\"\"\n        logger.debug(\"set_show_callables: %s\", show_callables)\n        self._show_callables = show_callables\n        self.invalidateFilter()\n\n    def get_show_special_attrs(self) -&gt; bool:\n        return self._show_special_attrs\n\n    def set_show_special_attrs(self, show_special_attrs: bool):\n\"\"\"Show/hide special attributes which begin with an underscore.\"\"\"\n        logger.debug(\"set_show_special_attrs: %s\", show_special_attrs)\n        self._show_special_attrs = show_special_attrs\n        self.invalidateFilter()\n</code></pre>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.filterAcceptsRow","title":"<code>filterAcceptsRow(self, source_row: int, source_parent_index: core.ModelIndex)</code>","text":"<p>Return true if the item should be included in the model.</p> Source code in <code>prettyqt/objbrowser/objectbrowsertreemodel.py</code> <pre><code>def filterAcceptsRow(self, source_row: int, source_parent_index: core.ModelIndex):\n\"\"\"Return true if the item should be included in the model.\"\"\"\n    parent_item = self.sourceModel().tree_item(source_parent_index)\n    tree_item = parent_item.child(source_row)\n\n    accept = (self._show_special_attrs or not tree_item.is_special_attribute) and (\n        self._show_callables or not tree_item.is_callable_attribute\n    )\n\n    # logger.debug(\"filterAcceptsRow = {}: {}\".format(accept, tree_item))\n    return accept\n</code></pre>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.set_show_callables","title":"<code>set_show_callables(self, show_callables: bool)</code>","text":"<p>Show/hide show_callables which have a call attribute.</p> Source code in <code>prettyqt/objbrowser/objectbrowsertreemodel.py</code> <pre><code>def set_show_callables(self, show_callables: bool):\n\"\"\"Show/hide show_callables which have a __call__ attribute.\"\"\"\n    logger.debug(\"set_show_callables: %s\", show_callables)\n    self._show_callables = show_callables\n    self.invalidateFilter()\n</code></pre>"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.set_show_special_attrs","title":"<code>set_show_special_attrs(self, show_special_attrs: bool)</code>","text":"<p>Show/hide special attributes which begin with an underscore.</p> Source code in <code>prettyqt/objbrowser/objectbrowsertreemodel.py</code> <pre><code>def set_show_special_attrs(self, show_special_attrs: bool):\n\"\"\"Show/hide special attributes which begin with an underscore.\"\"\"\n    logger.debug(\"set_show_special_attrs: %s\", show_special_attrs)\n    self._show_special_attrs = show_special_attrs\n    self.invalidateFilter()\n</code></pre>"},{"location":"api/positioning.html","title":"positioning module","text":"<p>Positioning module.</p> <p>Contains QtPositioning-based classes</p>"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource","title":"<code>geoareamonitorsource</code>","text":""},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource.GeoAreaMonitorSource","title":"<code> GeoAreaMonitorSource            (ObjectMixin, QGeoAreaMonitorSource)         </code>","text":"Source code in <code>prettyqt/positioning/geoareamonitorsource.py</code> <pre><code>class GeoAreaMonitorSource(core.ObjectMixin, QtPositioning.QGeoAreaMonitorSource):\n    def __str__(self):\n        return self.sourceName()\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.name()!r})\"\n\n    def get_error(self) -&gt; AreaMonitorFeatureStr:\n\"\"\"Return error type.\n\n        Returns:\n            error type\n        \"\"\"\n        return ERRORS.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource.GeoAreaMonitorSource.get_error","title":"<code>get_error(self) -&gt; AreaMonitorFeatureStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>AreaMonitorFeatureStr</code> <p>error type</p> Source code in <code>prettyqt/positioning/geoareamonitorsource.py</code> <pre><code>def get_error(self) -&gt; AreaMonitorFeatureStr:\n\"\"\"Return error type.\n\n    Returns:\n        error type\n    \"\"\"\n    return ERRORS.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource","title":"<code>geopositioninfosource</code>","text":""},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin","title":"<code> GeoPositionInfoSourceMixin            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/positioning/geopositioninfosource.py</code> <pre><code>class GeoPositionInfoSourceMixin(core.ObjectMixin):\n    def serialize_fields(self):\n        return dict(\n            minimum_update_interval=self.minimumUpdateInterval(),\n            source_name=self.sourceName(),\n            update_interval=self.updateInterval(),\n        )\n\n    def __str__(self):\n        return self.sourceName()\n\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n\n        Returns:\n            error type\n        \"\"\"\n        return ERRORS.inverse[self.error()]\n\n    def set_preferred_positioning_methods(self, *methods: PositioningMethodStr):\n\"\"\"Set preferred positioning methods.\n\n        Args:\n            methods: positioning methods to use\n\n        Raises:\n            InvalidParamError: invalid positioning methods\n        \"\"\"\n        for item in methods:\n            if item not in POSITIONING_METHODS:\n                raise InvalidParamError(item, POSITIONING_METHODS)\n        flags = helpers.merge_flags(methods, POSITIONING_METHODS)\n        self.setPreferredPositioningMethods(flags)\n\n    def get_preferred_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of preferred positioning methods.\n\n        Returns:\n            list of preferred positioning methods\n        \"\"\"\n        return [\n            k\n            for k, v in POSITIONING_METHODS.items()\n            if v &amp; self.preferredPositioningMethods()\n        ]\n\n    def get_supported_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of supported positioning methods.\n\n        Returns:\n            list of supported positioning methods\n        \"\"\"\n        return [\n            k\n            for k, v in POSITIONING_METHODS.items()\n            if v &amp; self.supportedPositioningMethods()\n        ]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.get_error","title":"<code>get_error(self) -&gt; ErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>error type</p> Source code in <code>prettyqt/positioning/geopositioninfosource.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n\n    Returns:\n        error type\n    \"\"\"\n    return ERRORS.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.get_preferred_positioning_methods","title":"<code>get_preferred_positioning_methods(self) -&gt; list[PositioningMethodStr]</code>","text":"<p>Return list of preferred positioning methods.</p> <p>Returns:</p> Type Description <code>list[PositioningMethodStr]</code> <p>list of preferred positioning methods</p> Source code in <code>prettyqt/positioning/geopositioninfosource.py</code> <pre><code>def get_preferred_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of preferred positioning methods.\n\n    Returns:\n        list of preferred positioning methods\n    \"\"\"\n    return [\n        k\n        for k, v in POSITIONING_METHODS.items()\n        if v &amp; self.preferredPositioningMethods()\n    ]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.get_supported_positioning_methods","title":"<code>get_supported_positioning_methods(self) -&gt; list[PositioningMethodStr]</code>","text":"<p>Return list of supported positioning methods.</p> <p>Returns:</p> Type Description <code>list[PositioningMethodStr]</code> <p>list of supported positioning methods</p> Source code in <code>prettyqt/positioning/geopositioninfosource.py</code> <pre><code>def get_supported_positioning_methods(self) -&gt; list[PositioningMethodStr]:\n\"\"\"Return list of supported positioning methods.\n\n    Returns:\n        list of supported positioning methods\n    \"\"\"\n    return [\n        k\n        for k, v in POSITIONING_METHODS.items()\n        if v &amp; self.supportedPositioningMethods()\n    ]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSourceMixin.set_preferred_positioning_methods","title":"<code>set_preferred_positioning_methods(self, *methods: PositioningMethodStr)</code>","text":"<p>Set preferred positioning methods.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>PositioningMethodStr</code> <p>positioning methods to use</p> <code>()</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid positioning methods</p> Source code in <code>prettyqt/positioning/geopositioninfosource.py</code> <pre><code>def set_preferred_positioning_methods(self, *methods: PositioningMethodStr):\n\"\"\"Set preferred positioning methods.\n\n    Args:\n        methods: positioning methods to use\n\n    Raises:\n        InvalidParamError: invalid positioning methods\n    \"\"\"\n    for item in methods:\n        if item not in POSITIONING_METHODS:\n            raise InvalidParamError(item, POSITIONING_METHODS)\n    flags = helpers.merge_flags(methods, POSITIONING_METHODS)\n    self.setPreferredPositioningMethods(flags)\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo","title":"<code>geosatelliteinfo</code>","text":""},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo","title":"<code> GeoSatelliteInfo            (QGeoSatelliteInfo)         </code>","text":"Source code in <code>prettyqt/positioning/geosatelliteinfo.py</code> <pre><code>class GeoSatelliteInfo(QtPositioning.QGeoSatelliteInfo):\n    def __getitem__(self, index: AttributeStr):\n        return self.attribute(ATTRIBUTE[index])\n\n    def __setitem__(self, index: AttributeStr, value: float):\n        self.setAttribute(ATTRIBUTE[index], value)\n\n    def __delitem__(self, index: AttributeStr):\n        self.removeAttribute(ATTRIBUTE[index])\n\n    def __contains__(self, value: AttributeStr):\n        return self.hasAttribute(ATTRIBUTE[value])\n\n    def __int__(self):\n        return self.satelliteIdentifier()\n\n    def set_satellite_system(self, system: SatelliteSystemStr):\n\"\"\"Set satellite system.\n\n        Args:\n            system: satellite system to use\n\n        Raises:\n            InvalidParamError: invalid system\n        \"\"\"\n        if system not in SATELLITE_SYSTEMS:\n            raise InvalidParamError(system, SATELLITE_SYSTEMS)\n        self.setSatelliteSystem(SATELLITE_SYSTEMS[system])\n\n    def get_satellite_system(self) -&gt; SatelliteSystemStr:\n\"\"\"Return satellite system.\n\n        Returns:\n            satellite system\n        \"\"\"\n        return SATELLITE_SYSTEMS.inverse[self.satelliteSystem()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.get_satellite_system","title":"<code>get_satellite_system(self) -&gt; SatelliteSystemStr</code>","text":"<p>Return satellite system.</p> <p>Returns:</p> Type Description <code>SatelliteSystemStr</code> <p>satellite system</p> Source code in <code>prettyqt/positioning/geosatelliteinfo.py</code> <pre><code>def get_satellite_system(self) -&gt; SatelliteSystemStr:\n\"\"\"Return satellite system.\n\n    Returns:\n        satellite system\n    \"\"\"\n    return SATELLITE_SYSTEMS.inverse[self.satelliteSystem()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.set_satellite_system","title":"<code>set_satellite_system(self, system: SatelliteSystemStr)</code>","text":"<p>Set satellite system.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>SatelliteSystemStr</code> <p>satellite system to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid system</p> Source code in <code>prettyqt/positioning/geosatelliteinfo.py</code> <pre><code>def set_satellite_system(self, system: SatelliteSystemStr):\n\"\"\"Set satellite system.\n\n    Args:\n        system: satellite system to use\n\n    Raises:\n        InvalidParamError: invalid system\n    \"\"\"\n    if system not in SATELLITE_SYSTEMS:\n        raise InvalidParamError(system, SATELLITE_SYSTEMS)\n    self.setSatelliteSystem(SATELLITE_SYSTEMS[system])\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource","title":"<code>geosatelliteinfosource</code>","text":""},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource.GeoSatelliteInfoSource","title":"<code> GeoSatelliteInfoSource            (ObjectMixin, QGeoSatelliteInfoSource)         </code>","text":"Source code in <code>prettyqt/positioning/geosatelliteinfosource.py</code> <pre><code>class GeoSatelliteInfoSource(core.ObjectMixin, QtPositioning.QGeoSatelliteInfoSource):\n    def serialize_fields(self):\n        return dict(\n            minimum_update_interval=self.minimumUpdateInterval(),\n            update_interval=self.updateInterval(),\n        )\n\n    def __str__(self):\n        return self.sourceName()\n\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n\n        Returns:\n            error type\n        \"\"\"\n        return ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource.GeoSatelliteInfoSource.get_error","title":"<code>get_error(self) -&gt; ErrorStr</code>","text":"<p>Return error type.</p> <p>Returns:</p> Type Description <code>ErrorStr</code> <p>error type</p> Source code in <code>prettyqt/positioning/geosatelliteinfosource.py</code> <pre><code>def get_error(self) -&gt; ErrorStr:\n\"\"\"Return error type.\n\n    Returns:\n        error type\n    \"\"\"\n    return ERROR.inverse[self.error()]\n</code></pre>"},{"location":"api/qml.html","title":"qml module","text":"<p>Qml module.</p> <p>Contains QtQml-based classes</p>"},{"location":"api/qml.html#prettyqt.qml.jsvalue","title":"<code>jsvalue</code>","text":""},{"location":"api/qml.html#prettyqt.qml.jsvalue.JSValue","title":"<code> JSValue            (QJSValue)         </code>","text":"Source code in <code>prettyqt/qml/jsvalue.py</code> <pre><code>class JSValue(QtQml.QJSValue):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.toVariant()})\"\n\n    def __len__(self):\n        return self.property(\"length\").toVariant()\n\n    def __getitem__(self, index: int | str):\n        return self.property(index).toVariant()\n\n    def __delitem__(self, index: str):\n        self.deleteProperty(index)\n\n    def __setitem__(self, index: int | str, value):\n        self.setProperty(index, value)\n\n    def __iter__(self):\n        iterator = qml.JSValueIterator(self)\n        return iter(list(iterator))\n\n    def __contains__(self, index: str):\n        return self.hasProperty(index)\n\n    def __call__(self, *args) -&gt; JSValue:\n        result = self.call(args)\n        return JSValue(result)\n\n    def get_value(self):\n        return self.toVariant()\n\n    def get_error_type(self) -&gt; ErrorTypeStr | None:\n        error_type = self.errorType()\n        return ERROR_TYPES.inverse.get(error_type)\n\n    @classmethod\n    def from_object(cls, obj, jsengine: QtQml.QJSEngine) -&gt; JSValue:\n\"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\"\n        match obj:\n            case None:\n                return cls()\n            case list() | tuple():\n                length = len(obj)\n                array = JSValue(jsengine.newArray(length))\n                for i, v in enumerate(obj):\n                    array.setProperty(i, cls.from_object(v, jsengine))\n                return array\n            case dict():\n                array = JSValue(jsengine.newArray())\n                for k, v in obj.items():\n                    array.setProperty(k, cls.from_object(v, jsengine))\n                return array\n            case _:\n                try:\n                    return cls(obj)\n                except TypeError:\n                    logger.debug(\"unknown type: \" + str(obj))\n                    return cls()\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.jsvalue.JSValue.from_object","title":"<code>from_object(obj, jsengine: QtQml.QJSEngine) -&gt; JSValue</code>  <code>classmethod</code>","text":"<p>Convert any python object into a QJSValue (must happen in GUI thread).</p> Source code in <code>prettyqt/qml/jsvalue.py</code> <pre><code>@classmethod\ndef from_object(cls, obj, jsengine: QtQml.QJSEngine) -&gt; JSValue:\n\"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\"\n    match obj:\n        case None:\n            return cls()\n        case list() | tuple():\n            length = len(obj)\n            array = JSValue(jsengine.newArray(length))\n            for i, v in enumerate(obj):\n                array.setProperty(i, cls.from_object(v, jsengine))\n            return array\n        case dict():\n            array = JSValue(jsengine.newArray())\n            for k, v in obj.items():\n                array.setProperty(k, cls.from_object(v, jsengine))\n            return array\n        case _:\n            try:\n                return cls(obj)\n            except TypeError:\n                logger.debug(\"unknown type: \" + str(obj))\n                return cls()\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.qmlengine","title":"<code>qmlengine</code>","text":""},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngineMixin","title":"<code> QmlEngineMixin            (JSEngineMixin)         </code>","text":"Source code in <code>prettyqt/qml/qmlengine.py</code> <pre><code>class QmlEngineMixin(qml.JSEngineMixin):\n    def set_object_ownership(self, obj: QtCore.QObject, mode: ObjectOwnershipStr):\n\"\"\"Set the object ownership.\n\n        Args:\n            obj: object to set ownership for\n            mode: object ownership to use\n\n        Raises:\n            InvalidParamError: invalid object ownership\n        \"\"\"\n        if mode not in OBJECT_OWNERSHIP:\n            raise InvalidParamError(mode, OBJECT_OWNERSHIP)\n        self.setObjectOwnership(obj, OBJECT_OWNERSHIP[mode])\n\n    def get_object_ownership(self, obj: QtCore.QObject) -&gt; ObjectOwnershipStr:\n\"\"\"Return object ownership.\n\n        Returns:\n            object ownership\n        \"\"\"\n        return OBJECT_OWNERSHIP.inverse[self.objectOwnership(obj)]\n\n    def add_import_path(self, path: datatypes.PathType):\n        self.addImportPath(os.fspath(path))\n\n    def add_plugin_path(self, path: datatypes.PathType):\n        self.addPluginPath(os.fspath(path))\n\n    def get_plugin_paths(self) -&gt; list[pathlib.Path]:\n        return [pathlib.Path(p) for p in self.pluginPathList()]\n\n    def get_import_paths(self) -&gt; list[pathlib.Path]:\n        return [pathlib.Path(p) for p in self.importPathList()]\n\n    def set_base_url(self, url: str | QtCore.QUrl):\n        if isinstance(url, str):\n            url = QtCore.QUrl(url)\n        self.setBaseUrl(url)\n\n    def get_base_url(self) -&gt; core.Url:\n        return core.Url(self.baseUrl())\n\n    def set_offline_storage_path(self, path: datatypes.PathType):\n        self.setOfflineStoragePath(os.fspath(path))\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngineMixin.get_object_ownership","title":"<code>get_object_ownership(self, obj: QtCore.QObject) -&gt; ObjectOwnershipStr</code>","text":"<p>Return object ownership.</p> <p>Returns:</p> Type Description <code>ObjectOwnershipStr</code> <p>object ownership</p> Source code in <code>prettyqt/qml/qmlengine.py</code> <pre><code>def get_object_ownership(self, obj: QtCore.QObject) -&gt; ObjectOwnershipStr:\n\"\"\"Return object ownership.\n\n    Returns:\n        object ownership\n    \"\"\"\n    return OBJECT_OWNERSHIP.inverse[self.objectOwnership(obj)]\n</code></pre>"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngineMixin.set_object_ownership","title":"<code>set_object_ownership(self, obj: QtCore.QObject, mode: ObjectOwnershipStr)</code>","text":"<p>Set the object ownership.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>QtCore.QObject</code> <p>object to set ownership for</p> required <code>mode</code> <code>ObjectOwnershipStr</code> <p>object ownership to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid object ownership</p> Source code in <code>prettyqt/qml/qmlengine.py</code> <pre><code>def set_object_ownership(self, obj: QtCore.QObject, mode: ObjectOwnershipStr):\n\"\"\"Set the object ownership.\n\n    Args:\n        obj: object to set ownership for\n        mode: object ownership to use\n\n    Raises:\n        InvalidParamError: invalid object ownership\n    \"\"\"\n    if mode not in OBJECT_OWNERSHIP:\n        raise InvalidParamError(mode, OBJECT_OWNERSHIP)\n    self.setObjectOwnership(obj, OBJECT_OWNERSHIP[mode])\n</code></pre>"},{"location":"api/qthelp.html","title":"qthelp module","text":"<p>qthelp module.</p> <p>contains QtHelp-based classes</p>"},{"location":"api/quick.html","title":"quick module","text":"<p>quick module.</p> <p>contains QtQuick-based classes</p>"},{"location":"api/quick.html#prettyqt.quick.quickitem","title":"<code>quickitem</code>","text":""},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItemMixin","title":"<code> QuickItemMixin            (ObjectMixin, QmlParserStatusMixin)         </code>","text":"Source code in <code>prettyqt/quick/quickitem.py</code> <pre><code>class QuickItemMixin(core.ObjectMixin, qml.QmlParserStatusMixin):\n    def get_children_rect(self) -&gt; core.RectF:\n        return core.RectF(self.childrenRect())\n\n    def get_cursor(self) -&gt; gui.Cursor:\n        return gui.Cursor(self.cursor())\n\n    def get_flags(self):\n        pass\n\n    def set_transform_origin(self, origin: TransformOriginStr):\n\"\"\"Set the origin point around which scale and rotation transform.\n\n        The default is \"center\".\n\n        Args:\n            origin: transform origin to use\n\n        Raises:\n            InvalidParamError: transform origin does not exist\n        \"\"\"\n        if origin not in TRANSFORM_ORIGIN:\n            raise InvalidParamError(origin, TRANSFORM_ORIGIN)\n        self.setTransformOrigin(TRANSFORM_ORIGIN[origin])\n\n    def get_transform_origin(self) -&gt; TransformOriginStr:\n\"\"\"Return the render type of text-like elements in Qt Quick.\n\n        Returns:\n            transform origin\n        \"\"\"\n        return TRANSFORM_ORIGIN.inverse[self.transformOrigin()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItemMixin.get_transform_origin","title":"<code>get_transform_origin(self) -&gt; TransformOriginStr</code>","text":"<p>Return the render type of text-like elements in Qt Quick.</p> <p>Returns:</p> Type Description <code>TransformOriginStr</code> <p>transform origin</p> Source code in <code>prettyqt/quick/quickitem.py</code> <pre><code>def get_transform_origin(self) -&gt; TransformOriginStr:\n\"\"\"Return the render type of text-like elements in Qt Quick.\n\n    Returns:\n        transform origin\n    \"\"\"\n    return TRANSFORM_ORIGIN.inverse[self.transformOrigin()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItemMixin.set_transform_origin","title":"<code>set_transform_origin(self, origin: TransformOriginStr)</code>","text":"<p>Set the origin point around which scale and rotation transform.</p> <p>The default is \"center\".</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>TransformOriginStr</code> <p>transform origin to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>transform origin does not exist</p> Source code in <code>prettyqt/quick/quickitem.py</code> <pre><code>def set_transform_origin(self, origin: TransformOriginStr):\n\"\"\"Set the origin point around which scale and rotation transform.\n\n    The default is \"center\".\n\n    Args:\n        origin: transform origin to use\n\n    Raises:\n        InvalidParamError: transform origin does not exist\n    \"\"\"\n    if origin not in TRANSFORM_ORIGIN:\n        raise InvalidParamError(origin, TRANSFORM_ORIGIN)\n    self.setTransformOrigin(TRANSFORM_ORIGIN[origin])\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem","title":"<code>quickpainteditem</code>","text":""},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem","title":"<code> QuickPaintedItem            (QuickItemMixin, QQuickPaintedItem)         </code>","text":"Source code in <code>prettyqt/quick/quickpainteditem.py</code> <pre><code>class QuickPaintedItem(quick.QuickItemMixin, QtQuick.QQuickPaintedItem):\n    def get_fill_color(self) -&gt; gui.Color:\n        return gui.Color(self.fillColor())\n\n    def get_texture_size(self) -&gt; core.Size:\n        return core.Size(self.textureSize())\n\n    def set_render_target(self, target: RenderTargetStr):\n\"\"\"Set the render target.\n\n        Args:\n            target: render target to use\n\n        Raises:\n            InvalidParamError: render target does not exist\n        \"\"\"\n        if target not in RENDER_TARGET:\n            raise InvalidParamError(target, RENDER_TARGET)\n        self.setRenderTarget(RENDER_TARGET[target])\n\n    def get_render_target(self) -&gt; RenderTargetStr:\n\"\"\"Return the render target.\n\n        Returns:\n            render target\n        \"\"\"\n        return RENDER_TARGET.inverse[self.renderTarget()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.get_render_target","title":"<code>get_render_target(self) -&gt; RenderTargetStr</code>","text":"<p>Return the render target.</p> <p>Returns:</p> Type Description <code>RenderTargetStr</code> <p>render target</p> Source code in <code>prettyqt/quick/quickpainteditem.py</code> <pre><code>def get_render_target(self) -&gt; RenderTargetStr:\n\"\"\"Return the render target.\n\n    Returns:\n        render target\n    \"\"\"\n    return RENDER_TARGET.inverse[self.renderTarget()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.set_render_target","title":"<code>set_render_target(self, target: RenderTargetStr)</code>","text":"<p>Set the render target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>RenderTargetStr</code> <p>render target to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>render target does not exist</p> Source code in <code>prettyqt/quick/quickpainteditem.py</code> <pre><code>def set_render_target(self, target: RenderTargetStr):\n\"\"\"Set the render target.\n\n    Args:\n        target: render target to use\n\n    Raises:\n        InvalidParamError: render target does not exist\n    \"\"\"\n    if target not in RENDER_TARGET:\n        raise InvalidParamError(target, RENDER_TARGET)\n    self.setRenderTarget(RENDER_TARGET[target])\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickwindow","title":"<code>quickwindow</code>","text":""},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow","title":"<code> QuickWindow            (WindowMixin, QQuickWindow)         </code>","text":"Source code in <code>prettyqt/quick/quickwindow.py</code> <pre><code>class QuickWindow(gui.WindowMixin, QtQuick.QQuickWindow):\n    def create_texture_from_image(self, image: QtGui.QImage, **kwargs):\n        flag = self.CreateTextureOption(0)\n        for key, val in kwargs.items():\n            if val is True:\n                v = CREATE_TEXTURE_OPTION[key]\n                flag |= v\n        return self.createTextureFromImage(image, flag)  # type: ignore\n\n    def grab_window(self) -&gt; gui.Image:\n        return gui.Image(self.grabWindow())\n\n    def get_color(self) -&gt; gui.Color:\n        return gui.Color(self.color())\n\n    @staticmethod\n    def set_text_render_type(typ: TextRenderTypeStr):\n\"\"\"Set the default render type of text-like elements in Qt Quick.\n\n        Note: setting the render type will only affect elements created afterwards;\n        the render type of existing elements will not be modified.\n\n        Args:\n            typ: text render type to use\n\n        Raises:\n            InvalidParamError: text render type does not exist\n        \"\"\"\n        if typ not in TEXT_RENDER_TYPE:\n            raise InvalidParamError(typ, TEXT_RENDER_TYPE)\n        QuickWindow.setTextRenderType(TEXT_RENDER_TYPE[typ])\n\n    @staticmethod\n    def get_text_render_type() -&gt; TextRenderTypeStr:\n\"\"\"Return the render type of text-like elements in Qt Quick.\n\n        Returns:\n            text render type\n        \"\"\"\n        return TEXT_RENDER_TYPE.inverse[QuickWindow.textRenderType()]\n\n    @contextlib.contextmanager\n    def external_commands(self):\n        self.beginExternalCommands()\n        yield self\n        self.endExternalCommands()\n\n    def schedule_render_job(self, job: QtCore.QRunnable, render_stage: RenderStageStr):\n        if render_stage not in RENDER_STAGE:\n            raise InvalidParamError(render_stage, RENDER_STAGE)\n        self.scheduleRenderJob(job, RENDER_STAGE[render_stage])\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow.get_text_render_type","title":"<code>get_text_render_type() -&gt; TextRenderTypeStr</code>  <code>staticmethod</code>","text":"<p>Return the render type of text-like elements in Qt Quick.</p> <p>Returns:</p> Type Description <code>TextRenderTypeStr</code> <p>text render type</p> Source code in <code>prettyqt/quick/quickwindow.py</code> <pre><code>@staticmethod\ndef get_text_render_type() -&gt; TextRenderTypeStr:\n\"\"\"Return the render type of text-like elements in Qt Quick.\n\n    Returns:\n        text render type\n    \"\"\"\n    return TEXT_RENDER_TYPE.inverse[QuickWindow.textRenderType()]\n</code></pre>"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow.set_text_render_type","title":"<code>set_text_render_type(typ: TextRenderTypeStr)</code>  <code>staticmethod</code>","text":"<p>Set the default render type of text-like elements in Qt Quick.</p> <p>Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TextRenderTypeStr</code> <p>text render type to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>text render type does not exist</p> Source code in <code>prettyqt/quick/quickwindow.py</code> <pre><code>@staticmethod\ndef set_text_render_type(typ: TextRenderTypeStr):\n\"\"\"Set the default render type of text-like elements in Qt Quick.\n\n    Note: setting the render type will only affect elements created afterwards;\n    the render type of existing elements will not be modified.\n\n    Args:\n        typ: text render type to use\n\n    Raises:\n        InvalidParamError: text render type does not exist\n    \"\"\"\n    if typ not in TEXT_RENDER_TYPE:\n        raise InvalidParamError(typ, TEXT_RENDER_TYPE)\n    QuickWindow.setTextRenderType(TEXT_RENDER_TYPE[typ])\n</code></pre>"},{"location":"api/svg.html","title":"svg module","text":"<p>svg module.</p> <p>contains QtSvg-based classes</p>"},{"location":"api/svg.html#prettyqt.svg.svgrenderer","title":"<code>svgrenderer</code>","text":""},{"location":"api/svg.html#prettyqt.svg.svgrenderer.SvgRenderer","title":"<code> SvgRenderer            (ObjectMixin, QSvgRenderer)         </code>","text":"Source code in <code>prettyqt/svg/svgrenderer.py</code> <pre><code>class SvgRenderer(core.ObjectMixin, QtSvg.QSvgRenderer):\n    def load_file(self, path: datatypes.PathType):\n        result = self.load(os.fspath(path))\n        if not result:\n            raise ValueError(\"invalid path\")\n\n    def set_aspect_ratio_mode(self, mode: constants.AspectRatioModeStr):\n\"\"\"Set the aspect ratio mode.\n\n        Args:\n            mode: aspect ratio mode\n\n        Raises:\n            InvalidParamError: aspect ratio mode does not exist\n        \"\"\"\n        if mode not in constants.ASPECT_RATIO_MODE:\n            raise InvalidParamError(mode, constants.ASPECT_RATIO_MODE)\n        self.setAspectRatioMode(constants.ASPECT_RATIO_MODE[mode])\n\n    def get_aspect_ratio_mode(self) -&gt; constants.AspectRatioModeStr:\n\"\"\"Return current aspect ratio mode.\n\n        Returns:\n            aspect ratio mode\n        \"\"\"\n        return constants.ASPECT_RATIO_MODE.inverse[self.aspectRatioMode()]\n</code></pre>"},{"location":"api/svg.html#prettyqt.svg.svgrenderer.SvgRenderer.get_aspect_ratio_mode","title":"<code>get_aspect_ratio_mode(self) -&gt; constants.AspectRatioModeStr</code>","text":"<p>Return current aspect ratio mode.</p> <p>Returns:</p> Type Description <code>constants.AspectRatioModeStr</code> <p>aspect ratio mode</p> Source code in <code>prettyqt/svg/svgrenderer.py</code> <pre><code>def get_aspect_ratio_mode(self) -&gt; constants.AspectRatioModeStr:\n\"\"\"Return current aspect ratio mode.\n\n    Returns:\n        aspect ratio mode\n    \"\"\"\n    return constants.ASPECT_RATIO_MODE.inverse[self.aspectRatioMode()]\n</code></pre>"},{"location":"api/svg.html#prettyqt.svg.svgrenderer.SvgRenderer.set_aspect_ratio_mode","title":"<code>set_aspect_ratio_mode(self, mode: constants.AspectRatioModeStr)</code>","text":"<p>Set the aspect ratio mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.AspectRatioModeStr</code> <p>aspect ratio mode</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>aspect ratio mode does not exist</p> Source code in <code>prettyqt/svg/svgrenderer.py</code> <pre><code>def set_aspect_ratio_mode(self, mode: constants.AspectRatioModeStr):\n\"\"\"Set the aspect ratio mode.\n\n    Args:\n        mode: aspect ratio mode\n\n    Raises:\n        InvalidParamError: aspect ratio mode does not exist\n    \"\"\"\n    if mode not in constants.ASPECT_RATIO_MODE:\n        raise InvalidParamError(mode, constants.ASPECT_RATIO_MODE)\n    self.setAspectRatioMode(constants.ASPECT_RATIO_MODE[mode])\n</code></pre>"},{"location":"api/syntaxhighlighters.html","title":"syntaxhighlighters module","text":"<p>syntaxhighlighters module.</p> <p>contains some custom syntax highlighers</p>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule","title":"<code>highlightrule</code>","text":""},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule","title":"<code> HighlightRule        </code>  <code>dataclass</code>","text":"<p>HighlightRule(regex: 'str | list[str]' = '', color: 'str' = 'black', italic: 'bool' = False, bold: 'bool' = False, minimal: 'bool' = False, font_size: 'float | None' = None, nth: 'int' = 0, fmt: 'gui.TextCharFormat' = ) Source code in <code>prettyqt/syntaxhighlighters/highlightrule.py</code> <pre><code>@dataclass\nclass HighlightRule:\n    regex: str | list[str] = \"\"\n    color: str = \"black\"\n    italic: bool = False\n    bold: bool = False\n    minimal: bool = False\n    font_size: float | None = None\n    nth: int = 0\n    compiled = None\n    fmt: gui.TextCharFormat = field(default_factory=gui.TextCharFormat)\n\n    def __init_subclass__(cls):\n        super().__init_subclass__()\n        if isinstance(cls.regex, str):\n            cls.compiled = re.compile(cls.regex)\n            # cls.compiled.setMinimal(True)\n        else:\n            cls.compiled = [re.compile(r) for r in cls.regex]\n        cls.fmt = cls.get_format()\n\n    @classmethod\n    def get_format(cls) -&gt; gui.TextCharFormat:\n        fmt = gui.TextCharFormat()\n        fmt.setFontItalic(cls.italic)\n        fmt.set_foreground_color(cls.color)\n        if cls.font_size:\n            fmt.setFontPointSize(cls.font_size)\n        if cls.bold:\n            fmt.set_font_weight(\"bold\")\n        return fmt\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule.__init_subclass__","title":"<code>__init_subclass__()</code>  <code>classmethod</code> <code>special</code>","text":"<p>This method is called when a class is subclassed.</p> <p>The default implementation does nothing. It may be overridden to extend subclasses.</p> Source code in <code>prettyqt/syntaxhighlighters/highlightrule.py</code> <pre><code>def __init_subclass__(cls):\n    super().__init_subclass__()\n    if isinstance(cls.regex, str):\n        cls.compiled = re.compile(cls.regex)\n        # cls.compiled.setMinimal(True)\n    else:\n        cls.compiled = [re.compile(r) for r in cls.regex]\n    cls.fmt = cls.get_format()\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter","title":"<code>jsonhighlighter</code>","text":""},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter","title":"<code> JsonHighlighter            (SyntaxHighlighter)         </code>","text":"Source code in <code>prettyqt/syntaxhighlighters/jsonhighlighter.py</code> <pre><code>class JsonHighlighter(gui.SyntaxHighlighter):\n    def highlightBlock(self, text: str):\n\"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\"\n        for m in BRACKETS.finditer(text):\n            self.setFormat(m.span()[0], m.span()[1] - m.span()[0], SYMBOL_FORMAT)\n\n        text.replace('\\\\\"', \"  \")\n        for m in REGEXP1.finditer(text):\n            self.setFormat(m.span()[0], m.span()[1] - m.span()[0], NAME_FORMAT)\n        for m in REGEXP2.finditer(text):\n            self.setFormat(m.span()[0], m.span()[1] - m.span()[0], VALUE_FORMAT)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter.highlightBlock","title":"<code>highlightBlock(self, text: str)</code>","text":"<p>Highlight a block of code using the rules outlined in the Constructor.</p> Source code in <code>prettyqt/syntaxhighlighters/jsonhighlighter.py</code> <pre><code>def highlightBlock(self, text: str):\n\"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\"\n    for m in BRACKETS.finditer(text):\n        self.setFormat(m.span()[0], m.span()[1] - m.span()[0], SYMBOL_FORMAT)\n\n    text.replace('\\\\\"', \"  \")\n    for m in REGEXP1.finditer(text):\n        self.setFormat(m.span()[0], m.span()[1] - m.span()[0], NAME_FORMAT)\n    for m in REGEXP2.finditer(text):\n        self.setFormat(m.span()[0], m.span()[1] - m.span()[0], VALUE_FORMAT)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter","title":"<code>markdownhighlighter</code>","text":"<p>Syntax highlighter for Markdown markup language.</p>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter","title":"<code> MarkdownHighlighter            (SyntaxHighlighter)         </code>","text":"Source code in <code>prettyqt/syntaxhighlighters/markdownhighlighter.py</code> <pre><code>class MarkdownHighlighter(gui.SyntaxHighlighter):\n    RULES = Rule.__subclasses__()\n\n    def highlightBlock(self, text: str):\n        super().highlightBlock(text)\n        self.setCurrentBlockState(0)\n        self._match_multiline(text, *TRI_SINGLE)\n\n    def _match_multiline(\n        self, text: str, delimiter: core.RegularExpression, style: gui.TextCharFormat\n    ):\n        # If inside triple-single quotes, start at 0\n        if self.previousBlockState() == 1:\n            start = 0\n            add = 0\n        # Otherwise, look for the delimiter on this line\n        else:\n            match = delimiter.match(text)\n            if not match.hasMatch():\n                return\n            start = match.capturedStart()\n            add = match.capturedLength()\n\n        # As long as there's a delimiter match on this line...\n        while start &gt;= 0:\n            # Look for the ending delimiter\n            match = delimiter.match(text, start + add)\n            end = match.capturedStart()\n            # Ending delimiter on this line?\n            if end &gt;= add:\n                length = end + match.capturedLength()\n                self.setCurrentBlockState(0)\n            # No; multi-line string\n            else:\n                self.setCurrentBlockState(1)\n                length = len(text)\n            self.setFormat(start, length - start + add, style)\n            # Look for the next match\n            start = delimiter.match(text, start + length).capturedStart()\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter.highlightBlock","title":"<code>highlightBlock(self, text: str)</code>","text":"<p>Apply syntax highlighting to the given block of text.</p> Source code in <code>prettyqt/syntaxhighlighters/markdownhighlighter.py</code> <pre><code>def highlightBlock(self, text: str):\n    super().highlightBlock(text)\n    self.setCurrentBlockState(0)\n    self._match_multiline(text, *TRI_SINGLE)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter","title":"<code>pygmentshighlighter</code>","text":""},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter","title":"<code> PygmentsHighlighter            (SyntaxHighlighter)         </code>","text":"Source code in <code>prettyqt/syntaxhighlighters/pygmentshighlighter.py</code> <pre><code>class PygmentsHighlighter(gui.SyntaxHighlighter):\n\"\"\"Syntax highlighter that uses Pygments for parsing.\"\"\"\n\n    # ---------------------------------------------------------------------------\n    #  \"QSyntaxHighlighter\" interface\n    # ---------------------------------------------------------------------------\n\n    def __init__(self, parent: QtGui.QTextDocument, lexer: str, style: str = \"default\"):\n        super().__init__(parent)\n        self._document = self.document()\n        self._formatter = HtmlFormatter(nowrap=True)\n        self.set_style(style)\n        if lexer == \"regex\":\n            self._lexer = load_lexer_from_file(str(paths.RE_LEXER_PATH))\n        else:\n            self._lexer = get_lexer_by_name(lexer)\n\n    def __repr__(self):\n        return f\"{type(self).__name__}(lexer={self._lexer.aliases[0]!r})\"\n\n    def highlightBlock(self, string):\n\"\"\"Highlight a block of text.\"\"\"\n        prev_data = self.currentBlock().previous().userData()\n        if prev_data is not None:\n            self._lexer._saved_state_stack = prev_data.syntax_stack\n        elif hasattr(self._lexer, \"_saved_state_stack\"):\n            del self._lexer._saved_state_stack\n\n        # Lex the text using Pygments\n        index = 0\n        for token, text in self._lexer.get_tokens(string):\n            length = qstring_length(text)\n            self.setFormat(index, length, self._get_format(token))\n            index += length\n\n        if hasattr(self._lexer, \"_saved_state_stack\"):\n            data = gui.TextBlockUserData(syntax_stack=self._lexer._saved_state_stack)\n            self.currentBlock().setUserData(data)\n            # Clean up for the next go-round.\n            del self._lexer._saved_state_stack\n\n    # ---------------------------------------------------------------------------\n    # \"PygmentsHighlighter\" interface\n    # ---------------------------------------------------------------------------\n\n    def set_style(self, style: None | str | Style):\n        if style is None:\n            style = get_style_by_name(\"default\")\n        elif isinstance(style, str):\n            style = get_style_by_name(style)\n        self._style = style\n        self._clear_caches()\n\n    def set_style_sheet(self, stylesheet: str):\n\"\"\"Sets a CSS stylesheet.\n\n        The classes in the stylesheet should correspond to those generated by:\n\n            pygmentize -S &lt;style&gt; -f html\n\n        Note that \"set_style\" and \"set_style_sheet\" completely override each\n        other, i.e. they cannot be used in conjunction.\n        \"\"\"\n        self._document.setDefaultStyleSheet(stylesheet)\n        self._style = None\n        self._clear_caches()\n\n    # ---------------------------------------------------------------------------\n    # Protected interface\n    # ---------------------------------------------------------------------------\n\n    def _clear_caches(self):\n\"\"\"Clear caches for brushes and formats.\"\"\"\n        self._get_brush.cache_clear()\n        self._get_format.cache_clear()\n\n    @functools.cache\n    def _get_format(self, token: str) -&gt; QtGui.QTextCharFormat:\n\"\"\"Returns a QTextCharFormat for token or None.\"\"\"\n        if self._style is None:\n            return self._get_format_from_document(token, self._document)\n        else:\n            return self._get_format_from_style(token, self._style)\n\n    def _get_format_from_document(\n        self, token: str, document: QtGui.QTextDocument\n    ) -&gt; QtGui.QTextCharFormat:\n\"\"\"Return a QTextCharFormat for token from document.\"\"\"\n        code, html = next(self._formatter._format_lines([(token, \"dummy\")]))\n        self._document.setHtml(html)\n        return gui.TextCursor(self._document).charFormat()\n\n    def _get_format_from_style(self, token: str, style: Style) -&gt; gui.TextCharFormat:\n\"\"\"Return a QTextCharFormat for token by reading a Pygments style.\"\"\"\n        result = gui.TextCharFormat()\n        try:\n            token_style = style.style_for_token(token)\n        except KeyError:\n            return result\n        for key, value in token_style.items():\n            if value:\n                match key:\n                    case \"color\":\n                        result.set_foreground_color(self._get_brush(value))\n                    case \"bgcolor\":\n                        result.set_background_color(self._get_brush(value))\n                    case \"bold\":\n                        result.set_font_weight(\"bold\")\n                    case \"italic\":\n                        result.setFontItalic(True)\n                    case \"underline\":\n                        result.set_underline_style(\"single\")\n                    case \"sans\":\n                        result.set_font_style_hint(\"sans_serif\")\n                    case \"roman\":\n                        result.set_font_style_hint(\"serif\")\n                    case \"mono\":\n                        result.set_font_style_hint(\"typewriter\")\n        return result\n\n    @functools.cache\n    def _get_brush(self, color: str) -&gt; gui.Brush:\n\"\"\"Return a brush for the color.\"\"\"\n        qcolor = gui.Color(f\"#{color[:6]}\")\n        return gui.Brush(qcolor)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.highlightBlock","title":"<code>highlightBlock(self, string)</code>","text":"<p>Highlight a block of text.</p> Source code in <code>prettyqt/syntaxhighlighters/pygmentshighlighter.py</code> <pre><code>def highlightBlock(self, string):\n\"\"\"Highlight a block of text.\"\"\"\n    prev_data = self.currentBlock().previous().userData()\n    if prev_data is not None:\n        self._lexer._saved_state_stack = prev_data.syntax_stack\n    elif hasattr(self._lexer, \"_saved_state_stack\"):\n        del self._lexer._saved_state_stack\n\n    # Lex the text using Pygments\n    index = 0\n    for token, text in self._lexer.get_tokens(string):\n        length = qstring_length(text)\n        self.setFormat(index, length, self._get_format(token))\n        index += length\n\n    if hasattr(self._lexer, \"_saved_state_stack\"):\n        data = gui.TextBlockUserData(syntax_stack=self._lexer._saved_state_stack)\n        self.currentBlock().setUserData(data)\n        # Clean up for the next go-round.\n        del self._lexer._saved_state_stack\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style_sheet","title":"<code>set_style_sheet(self, stylesheet: str)</code>","text":"<p>Sets a CSS stylesheet.</p> <p>The classes in the stylesheet should correspond to those generated by:</p> <pre><code>pygmentize -S &lt;style&gt; -f html\n</code></pre> <p>Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction.</p> Source code in <code>prettyqt/syntaxhighlighters/pygmentshighlighter.py</code> <pre><code>def set_style_sheet(self, stylesheet: str):\n\"\"\"Sets a CSS stylesheet.\n\n    The classes in the stylesheet should correspond to those generated by:\n\n        pygmentize -S &lt;style&gt; -f html\n\n    Note that \"set_style\" and \"set_style_sheet\" completely override each\n    other, i.e. they cannot be used in conjunction.\n    \"\"\"\n    self._document.setDefaultStyleSheet(stylesheet)\n    self._style = None\n    self._clear_caches()\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.get_tokens_unprocessed","title":"<code>get_tokens_unprocessed(self, text: str, stack = ('root',))</code>","text":"<p>Split <code>text</code> into (tokentype, text) pairs.</p> <p>Monkeypatched to store the final stack on the object itself.</p> <p>The <code>text</code> parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line.</p> Source code in <code>prettyqt/syntaxhighlighters/pygmentshighlighter.py</code> <pre><code>def get_tokens_unprocessed(self, text: str, stack=(\"root\",)):\n\"\"\"Split ``text`` into (tokentype, text) pairs.\n\n    Monkeypatched to store the final stack on the object itself.\n\n    The `text` parameter this gets passed is only the current line, so to\n    highlight things like multiline strings correctly, we need to retrieve\n    the state from the previous line (this is done in PygmentsHighlighter,\n    below), and use it to continue processing the current line.\n    \"\"\"\n    pos = 0\n    tokendefs = self._tokens\n    if hasattr(self, \"_saved_state_stack\"):\n        statestack = list(self._saved_state_stack)\n    else:\n        statestack = list(stack)\n    statetokens = tokendefs[statestack[-1]]\n    while True:\n        for rexmatch, action, new_state in statetokens:\n            m = rexmatch(text, pos)\n            if not m:\n                continue\n            if action is not None:\n                if isinstance(action, _TokenType):\n                    yield pos, action, m.group()\n                else:\n                    yield from action(self, m)\n            pos = m.end()\n            match new_state:\n                case None:\n                    break\n                case tuple():\n                    for state in new_state:\n                        match state:\n                            case \"#pop\":\n                                statestack.pop()\n                            case \"#push\":\n                                statestack.append(statestack[-1])\n                            case _:\n                                statestack.append(state)\n                case int():\n                    del statestack[new_state:]\n                case \"#push\":\n                    statestack.append(statestack[-1])\n                case _:\n                    assert False, f\"wrong state def: {new_state!r}\"\n            statetokens = tokendefs[statestack[-1]]\n            break\n        else:\n            try:\n                if text[pos] == \"\\n\":\n                    # at EOL, reset state to \"root\"\n                    statestack = [\"root\"]\n                    statetokens = tokendefs[\"root\"]\n                    yield pos + 1, Text, \"\\n\"\n                else:\n                    yield pos, Error, text[pos]\n                pos += 1\n            except IndexError:\n                break\n    self._saved_state_stack = list(statestack)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.qstring_length","title":"<code>qstring_length(text: str) -&gt; int</code>","text":"<p>Tries to compute what the length of an utf16-encoded QString would be.</p> Source code in <code>prettyqt/syntaxhighlighters/pygmentshighlighter.py</code> <pre><code>def qstring_length(text: str) -&gt; int:\n\"\"\"Tries to compute what the length of an utf16-encoded QString would be.\"\"\"\n    utf16_text = text.encode(\"utf16\")\n    length = len(utf16_text) // 2\n    # Remove Byte order mark.\n    # TODO: All unicode Non-characters should be removed\n    if utf16_text[:2] in [b\"\\xff\\xfe\", b\"\\xff\\xff\", b\"\\xfe\\xff\"]:\n        length -= 1\n    return length\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter","title":"<code>pythonhighlighter</code>","text":"<p>Syntax highlighter for the programming language Python.</p>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter","title":"<code> PythonHighlighter            (SyntaxHighlighter)         </code>","text":"Source code in <code>prettyqt/syntaxhighlighters/pythonhighlighter.py</code> <pre><code>class PythonHighlighter(gui.SyntaxHighlighter):\n\"\"\"Syntax highlighter for the Python language.\"\"\"\n\n    RULES = Rule.__subclasses__()\n\n    def highlightBlock(self, text: str):\n\"\"\"Apply syntax highlighting to the given block of text.\"\"\"\n        # Do other syntax formatting\n        super().highlightBlock(text)\n        self.setCurrentBlockState(0)\n        # Do multi-line strings\n        if not self.match_multiline(text, *TRI_SINGLE):\n            self.match_multiline(text, *TRI_DOUBLE)\n\n    def match_multiline(\n        self,\n        text: str,\n        delimiter: core.RegularExpression,\n        in_state: int,\n        style: gui.TextCharFormat,\n    ):\n\"\"\"Do highlighting of multi-line strings.\n\n        ``delimiter`` should be a\n        ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and\n        ``in_state`` should be a unique integer to represent the corresponding\n        state changes when inside those strings. Returns True if we're still\n        inside a multi-line string when this function is finished.\n        \"\"\"\n        # If inside triple-single quotes, start at 0\n        if self.previousBlockState() == in_state:\n            start = 0\n            add = 0\n        # Otherwise, look for the delimiter on this line\n        else:\n            match = delimiter.match(text)\n            if not match.hasMatch():\n                return\n            start = match.capturedStart()\n            add = match.capturedLength()\n\n        # As long as there's a delimiter match on this line...\n        while start &gt;= 0:\n            # Look for the ending delimiter\n            match = delimiter.match(text, start + add)\n            end = match.capturedStart()\n            # Ending delimiter on this line?\n            if end &gt;= add:\n                length = end - start + add + match.capturedLength()\n                self.setCurrentBlockState(0)\n            # No; multi-line string\n            else:\n                self.setCurrentBlockState(in_state)\n                length = len(text) - start + add\n            # Apply formatting\n            self.setFormat(start, length, style)\n            # Look for the next match\n            start = delimiter.match(text, start + length).capturedStart()\n\n        # Return True if still inside a multi-line string, False otherwise\n        return self.currentBlockState() == in_state\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.highlightBlock","title":"<code>highlightBlock(self, text: str)</code>","text":"<p>Apply syntax highlighting to the given block of text.</p> Source code in <code>prettyqt/syntaxhighlighters/pythonhighlighter.py</code> <pre><code>def highlightBlock(self, text: str):\n\"\"\"Apply syntax highlighting to the given block of text.\"\"\"\n    # Do other syntax formatting\n    super().highlightBlock(text)\n    self.setCurrentBlockState(0)\n    # Do multi-line strings\n    if not self.match_multiline(text, *TRI_SINGLE):\n        self.match_multiline(text, *TRI_DOUBLE)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.match_multiline","title":"<code>match_multiline(self, text: str, delimiter: core.RegularExpression, in_state: int, style: gui.TextCharFormat)</code>","text":"<p>Do highlighting of multi-line strings.</p> <p><code>delimiter</code> should be a <code>core.RegExp</code> for triple-single-quotes or triple-double-quotes, and <code>in_state</code> should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished.</p> Source code in <code>prettyqt/syntaxhighlighters/pythonhighlighter.py</code> <pre><code>def match_multiline(\n    self,\n    text: str,\n    delimiter: core.RegularExpression,\n    in_state: int,\n    style: gui.TextCharFormat,\n):\n\"\"\"Do highlighting of multi-line strings.\n\n    ``delimiter`` should be a\n    ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and\n    ``in_state`` should be a unique integer to represent the corresponding\n    state changes when inside those strings. Returns True if we're still\n    inside a multi-line string when this function is finished.\n    \"\"\"\n    # If inside triple-single quotes, start at 0\n    if self.previousBlockState() == in_state:\n        start = 0\n        add = 0\n    # Otherwise, look for the delimiter on this line\n    else:\n        match = delimiter.match(text)\n        if not match.hasMatch():\n            return\n        start = match.capturedStart()\n        add = match.capturedLength()\n\n    # As long as there's a delimiter match on this line...\n    while start &gt;= 0:\n        # Look for the ending delimiter\n        match = delimiter.match(text, start + add)\n        end = match.capturedStart()\n        # Ending delimiter on this line?\n        if end &gt;= add:\n            length = end - start + add + match.capturedLength()\n            self.setCurrentBlockState(0)\n        # No; multi-line string\n        else:\n            self.setCurrentBlockState(in_state)\n            length = len(text) - start + add\n        # Apply formatting\n        self.setFormat(start, length, style)\n        # Look for the next match\n        start = delimiter.match(text, start + length).capturedStart()\n\n    # Return True if still inside a multi-line string, False otherwise\n    return self.currentBlockState() == in_state\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter","title":"<code>regexmatchhighlighter</code>","text":""},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter","title":"<code> RegexMatchHighlighter            (SyntaxHighlighter)         </code>","text":"Source code in <code>prettyqt/syntaxhighlighters/regexmatchhighlighter.py</code> <pre><code>class RegexMatchHighlighter(gui.SyntaxHighlighter):\n    def __init__(self, document=None):\n        super().__init__(document)\n        self.spans: list[tuple[int, int]] | None = []\n\n    def set_spans(self, spans: list[tuple[int, int]] | None):\n        self.spans = spans\n        # print(self.spans)\n        self.rehighlight()\n\n    def _colorize(self, line_pos: int, match_len: int, match_num: int):\n        fmt = FORMAT_1 if match_num % 2 == 0 else FORMAT_2\n        self.setFormat(line_pos, match_len, fmt)\n\n    def highlightBlock(self, text: str):\n        block = self.currentBlock()\n        # line_no = block.blockNumber()\n        # if line_no == 0:\n        #     self.setCurrentBlockState(-1)\n        start_char = block.position()\n        end_char = start_char + block.length()\n        # print(f\"\\nline {line_no} ({start_char} - {end_char})\")\n        # print(f\"prev block state: {self.previousBlockState()}\")\n        if not self.spans or not text:\n            return None\n        for i, (start, end) in enumerate(self.spans):\n            if end &lt; start_char:\n                continue\n            if start &gt; end_char:\n                break\n            starts_in_line = start_char &lt;= start &lt;= end_char\n            ends_in_line = start_char &lt;= end &lt;= end_char\n            if starts_in_line and ends_in_line:\n                # print(f\"in line: {line_pos} - {line_pos + match_len}\")\n                self._colorize(start - start_char, end - start, i)\n            elif ends_in_line:\n                # if self.previousBlockState() == 1:\n                # print(f\"ends: {end}\")\n                self._colorize(0, end - start, i)\n                # self.setCurrentBlockState(-1)\n            elif starts_in_line:\n                # print(f\"starts: {line_pos}\")\n                # self.setCurrentBlockState(1)\n                self._colorize(start - start_char, end - start, i)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter.highlightBlock","title":"<code>highlightBlock(self, text: str)</code>","text":"<p>Apply syntax highlighting to the given block of text.</p> Source code in <code>prettyqt/syntaxhighlighters/regexmatchhighlighter.py</code> <pre><code>def highlightBlock(self, text: str):\n    block = self.currentBlock()\n    # line_no = block.blockNumber()\n    # if line_no == 0:\n    #     self.setCurrentBlockState(-1)\n    start_char = block.position()\n    end_char = start_char + block.length()\n    # print(f\"\\nline {line_no} ({start_char} - {end_char})\")\n    # print(f\"prev block state: {self.previousBlockState()}\")\n    if not self.spans or not text:\n        return None\n    for i, (start, end) in enumerate(self.spans):\n        if end &lt; start_char:\n            continue\n        if start &gt; end_char:\n            break\n        starts_in_line = start_char &lt;= start &lt;= end_char\n        ends_in_line = start_char &lt;= end &lt;= end_char\n        if starts_in_line and ends_in_line:\n            # print(f\"in line: {line_pos} - {line_pos + match_len}\")\n            self._colorize(start - start_char, end - start, i)\n        elif ends_in_line:\n            # if self.previousBlockState() == 1:\n            # print(f\"ends: {end}\")\n            self._colorize(0, end - start, i)\n            # self.setCurrentBlockState(-1)\n        elif starts_in_line:\n            # print(f\"starts: {line_pos}\")\n            # self.setCurrentBlockState(1)\n            self._colorize(start - start_char, end - start, i)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter","title":"<code>xmlhighlighter</code>","text":"<p>Based on http://www.yasinuludag.com/blog/?p=49 .</p>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter","title":"<code> XmlHighlighter            (SyntaxHighlighter)         </code>","text":"Source code in <code>prettyqt/syntaxhighlighters/xmlhighlighter.py</code> <pre><code>class XmlHighlighter(gui.SyntaxHighlighter):\n    RULES = Rule.__subclasses__()\n\n    def highlightBlock(self, text: str):\n        super().highlightBlock(text)\n        # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \"..\n        # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD\n        # TO BE COLORED\n        self.setCurrentBlockState(0)\n        start_index = 0\n        if self.previousBlockState() != 1:\n            start_index = VALUE_START_EXPRESSION.match(text).capturedStart()\n        while start_index &gt;= 0:\n            match = VALUE_END_EXPRESSION.match(text, start_index)\n            end_index = match.capturedStart()\n            if end_index == -1:\n                self.setCurrentBlockState(1)\n                comment_len = len(text) - start_index\n            else:\n                comment_len = end_index - start_index + match.capturedLength()\n            self.setFormat(start_index, comment_len, VALUE_FORMAT)\n            start_index = VALUE_START_EXPRESSION.match(\n                text, start_index + comment_len\n            ).capturedStart()\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter.highlightBlock","title":"<code>highlightBlock(self, text: str)</code>","text":"<p>Apply syntax highlighting to the given block of text.</p> Source code in <code>prettyqt/syntaxhighlighters/xmlhighlighter.py</code> <pre><code>def highlightBlock(self, text: str):\n    super().highlightBlock(text)\n    # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \"..\n    # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD\n    # TO BE COLORED\n    self.setCurrentBlockState(0)\n    start_index = 0\n    if self.previousBlockState() != 1:\n        start_index = VALUE_START_EXPRESSION.match(text).capturedStart()\n    while start_index &gt;= 0:\n        match = VALUE_END_EXPRESSION.match(text, start_index)\n        end_index = match.capturedStart()\n        if end_index == -1:\n            self.setCurrentBlockState(1)\n            comment_len = len(text) - start_index\n        else:\n            comment_len = end_index - start_index + match.capturedLength()\n        self.setFormat(start_index, comment_len, VALUE_FORMAT)\n        start_index = VALUE_START_EXPRESSION.match(\n            text, start_index + comment_len\n        ).capturedStart()\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter","title":"<code>yamlhighlighter</code>","text":""},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter","title":"<code> YamlHighlighter            (SyntaxHighlighter)         </code>","text":"Source code in <code>prettyqt/syntaxhighlighters/yamlhighlighter.py</code> <pre><code>class YamlHighlighter(gui.SyntaxHighlighter):\n    RULES = Rule.__subclasses__()\n\n    def highlightBlock(self, text: str):\n        super().highlightBlock(text)\n        self.setCurrentBlockState(0)\n        start_index = 0\n        if self.previousBlockState() != 1:\n            start_index = COMMENT_START.match(text).capturedStart()\n            if start_index &gt;= 0:\n                comment_len = len(text) - start_index\n                self.setFormat(start_index, comment_len, COMMENT_FORMAT)\n</code></pre>"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter.highlightBlock","title":"<code>highlightBlock(self, text: str)</code>","text":"<p>Apply syntax highlighting to the given block of text.</p> Source code in <code>prettyqt/syntaxhighlighters/yamlhighlighter.py</code> <pre><code>def highlightBlock(self, text: str):\n    super().highlightBlock(text)\n    self.setCurrentBlockState(0)\n    start_index = 0\n    if self.previousBlockState() != 1:\n        start_index = COMMENT_START.match(text).capturedStart()\n        if start_index &gt;= 0:\n            comment_len = len(text) - start_index\n            self.setFormat(start_index, comment_len, COMMENT_FORMAT)\n</code></pre>"},{"location":"api/webenginecore.html","title":"webenginecore module","text":"<p>Webenginewidgets module.</p> <p>contains QtWebEngineCore-based classes</p>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest","title":"<code>webenginedownloadrequest</code>","text":""},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest","title":"<code> WebEngineDownloadRequest        </code>","text":"Source code in <code>prettyqt/webenginecore/webenginedownloadrequest.py</code> <pre><code>class WebEngineDownloadRequest:\n    def __init__(self, item: QtWebEngineCore.QWebEngineDownloadRequest):\n        self.item = item\n\n    def __getattr__(self, val):\n        return getattr(self.item, val)\n\n    def get_interrupt_reason(self) -&gt; DownloadInterruptReasonStr:\n        return DOWNLOAD_INTERRUPT_REASONS.inverse[self.item.interruptReason()]\n\n    def get_state(self) -&gt; DownloadStateStr:\n        return DOWNLOAD_STATE.inverse[self.item.state()]\n\n    def set_save_page_format(self, fmt: SavePageFormatStr):\n\"\"\"Set the save page format.\n\n        Args:\n            fmt: save page format for the layout\n\n        Raises:\n            InvalidParamError: save page format does not exist\n        \"\"\"\n        if fmt not in SAVE_PAGE_FORMAT:\n            raise InvalidParamError(fmt, SAVE_PAGE_FORMAT)\n        self.item.setSavePageFormat(SAVE_PAGE_FORMAT[fmt])\n\n    def get_save_page_format(self) -&gt; SavePageFormatStr:\n\"\"\"Return current save page format.\n\n        Returns:\n            Save page format\n        \"\"\"\n        return SAVE_PAGE_FORMAT.inverse[self.item.savePageFormat()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest.get_save_page_format","title":"<code>get_save_page_format(self) -&gt; SavePageFormatStr</code>","text":"<p>Return current save page format.</p> <p>Returns:</p> Type Description <code>SavePageFormatStr</code> <p>Save page format</p> Source code in <code>prettyqt/webenginecore/webenginedownloadrequest.py</code> <pre><code>def get_save_page_format(self) -&gt; SavePageFormatStr:\n\"\"\"Return current save page format.\n\n    Returns:\n        Save page format\n    \"\"\"\n    return SAVE_PAGE_FORMAT.inverse[self.item.savePageFormat()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginedownloadrequest.WebEngineDownloadRequest.set_save_page_format","title":"<code>set_save_page_format(self, fmt: SavePageFormatStr)</code>","text":"<p>Set the save page format.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>SavePageFormatStr</code> <p>save page format for the layout</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>save page format does not exist</p> Source code in <code>prettyqt/webenginecore/webenginedownloadrequest.py</code> <pre><code>def set_save_page_format(self, fmt: SavePageFormatStr):\n\"\"\"Set the save page format.\n\n    Args:\n        fmt: save page format for the layout\n\n    Raises:\n        InvalidParamError: save page format does not exist\n    \"\"\"\n    if fmt not in SAVE_PAGE_FORMAT:\n        raise InvalidParamError(fmt, SAVE_PAGE_FORMAT)\n    self.item.setSavePageFormat(SAVE_PAGE_FORMAT[fmt])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest","title":"<code>webenginehttprequest</code>","text":""},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest","title":"<code> WebEngineHttpRequest            (QWebEngineHttpRequest)         </code>","text":"Source code in <code>prettyqt/webenginecore/webenginehttprequest.py</code> <pre><code>class WebEngineHttpRequest(QtWebEngineCore.QWebEngineHttpRequest):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.get_url()})\"\n\n    def set_headers(self, headers: dict[str, str]):\n        for k, v in headers.items():\n            self.setHeader(QtCore.QByteArray(k.encode()), QtCore.QByteArray(v.encode()))\n\n    def get_headers(self) -&gt; dict[str, str]:\n        return {bytes(h).decode(): bytes(self.header(h)).decode() for h in self.headers()}\n\n    def set_url(self, url: datatypes.UrlType):\n        url = core.Url(url)\n        self.setUrl(url)\n\n    def get_url(self) -&gt; core.Url:\n        return core.Url(self.url())\n\n    def get_post_data(self) -&gt; str:\n        return bytes(self.postData()).decode()\n\n    def set_method(self, method: MethodStr):\n\"\"\"Set method this WebEngine request is using.\n\n        Args:\n            method: method\n\n        Raises:\n            InvalidParamError: method does not exist\n        \"\"\"\n        if method not in METHODS:\n            raise InvalidParamError(method, METHODS)\n        self.setMethod(METHODS[method])\n\n    def get_method(self) -&gt; MethodStr:\n\"\"\"Get the method this WebEngine request is using.\n\n        Returns:\n            method\n        \"\"\"\n        return METHODS.inverse[self.method()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.get_method","title":"<code>get_method(self) -&gt; MethodStr</code>","text":"<p>Get the method this WebEngine request is using.</p> <p>Returns:</p> Type Description <code>MethodStr</code> <p>method</p> Source code in <code>prettyqt/webenginecore/webenginehttprequest.py</code> <pre><code>def get_method(self) -&gt; MethodStr:\n\"\"\"Get the method this WebEngine request is using.\n\n    Returns:\n        method\n    \"\"\"\n    return METHODS.inverse[self.method()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.set_method","title":"<code>set_method(self, method: MethodStr)</code>","text":"<p>Set method this WebEngine request is using.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>MethodStr</code> <p>method</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>method does not exist</p> Source code in <code>prettyqt/webenginecore/webenginehttprequest.py</code> <pre><code>def set_method(self, method: MethodStr):\n\"\"\"Set method this WebEngine request is using.\n\n    Args:\n        method: method\n\n    Raises:\n        InvalidParamError: method does not exist\n    \"\"\"\n    if method not in METHODS:\n        raise InvalidParamError(method, METHODS)\n    self.setMethod(METHODS[method])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage","title":"<code>webenginepage</code>","text":""},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage","title":"<code> WebEnginePage            (ObjectMixin, QWebEnginePage)         </code>","text":"Source code in <code>prettyqt/webenginecore/webenginepage.py</code> <pre><code>class WebEnginePage(core.ObjectMixin, QtWebEngineCore.QWebEnginePage):\n\"\"\"A web engine page holds the HTML document contents, link history + actions.\"\"\"\n\n    def serialize_fields(self):\n        return dict(\n            audio_muted=self.isAudioMuted(),\n            background_color=self.backgroundColor(),\n            # has_selection=self.hasSelection(),\n            lifecycle_state=self.get_lifecycle_state(),\n            # scroll_position=self.scrollPosition(),\n            url=core.Url(self.url()),\n            visible=self.isVisible(),\n            history=core.DataStream.create_bytearray(self.history()),\n            zoom_factor=self.zoomFactor(),\n        )\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        if icon.isNull():\n            return None\n        return gui.Icon(icon)\n\n    def set_url(self, url: datatypes.PathType):\n\"\"\"Set the url of the WebEnginePage.\n\n        Clears the Page and loads the URL.\n\n        Args:\n            url: URL to set\n        \"\"\"\n        if isinstance(url, os.PathLike):\n            url = core.Url.fromLocalFile(os.fspath(url))\n        elif isinstance(url, str):\n            url = core.Url(url)\n        self.setUrl(url)\n\n    def get_url(self) -&gt; core.Url:\n        return core.Url(self.url())\n\n    def get_icon_url(self) -&gt; core.Url:\n        return core.Url(self.iconUrl())\n\n    def get_requested_url(self) -&gt; core.Url:\n        return core.Url(self.requestedUrl())\n\n    def get_scroll_position(self) -&gt; core.PointF:\n        return core.PointF(self.scrollPosition())\n\n    def get_contents_size(self) -&gt; core.SizeF:\n        return core.SizeF(self.contentsSize())\n\n    def load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n\n        Loads the specified url and displays it.\n\n        Note: The Page remains the same until enough data has arrived\n        to display the new URL.\n\n        Args:\n            url: URL to load\n        \"\"\"\n        if isinstance(url, os.PathLike):\n            url = core.Url.fromLocalFile(os.fspath(url))\n        elif isinstance(url, str):\n            url = core.Url(url)\n        self.load(url)\n\n    def set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the Page.\n\n        Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n\n        Args:\n            zoom: Zoom factor\n        \"\"\"\n        self.setZoomFactor(zoom)\n\n    def find_text(\n        self,\n        string: str,\n        backward: bool = False,\n        case_sensitive: bool = False,\n        callback: Callable[[bool], None] | None = None,\n    ):\n\"\"\"Find text in the current page.\n\n        Finds the specified string, subString, in the page, using the given options.\n        The findTextFinished() signal is emitted when a string search is completed.\n\n        To clear the search highlight, just pass an empty string.\n\n        The resultCallback must take a boolean parameter.\n        It will be called with a value of true if the subString was found;\n        otherwise the callback value will be false.\n\n        Warning: It is guaranteed that the callback is always called,\n        but it might be done during page destruction. When WebEnginePage is deleted,\n        the callback is triggered with an invalid value and it is not safe to use\n        the corresponding QWebEnginePage or QWebEnginePage instance inside it.\n\n        Args:\n            string: string to search for\n            backward: search backwards\n            case_sensitive: case-sensitive search\n            callback: result callback\n        \"\"\"\n        if callback is None:\n\n            def do_nothing(x):\n                pass\n\n            callback = do_nothing\n        flag = QtWebEngineCore.QWebEnginePage.FindFlag(0)\n        if case_sensitive:\n            flag |= self.FindFlag.FindCaseSensitively\n        if backward:\n            flag |= self.FindFlag.FindBackward\n        self.findText(string, flag, callback)\n\n    def set_lifecycle_state(self, state: LifecycleStateStr):\n\"\"\"Set lifecycle state.\n\n        Args:\n            state: lifecycle state\n\n        Raises:\n            InvalidParamError: lifecycle state does not exist\n        \"\"\"\n        if state not in LIFECYCLE_STATE:\n            raise InvalidParamError(state, LIFECYCLE_STATE)\n        self.setLifecycleState(LIFECYCLE_STATE[state])\n\n    def get_lifecycle_state(self) -&gt; LifecycleStateStr:\n\"\"\"Get the current lifecycle state.\n\n        Returns:\n            lifecycle state\n        \"\"\"\n        return LIFECYCLE_STATE.inverse[self.lifecycleState()]\n\n    def trigger_action(self, action: WebActionStr, checked: bool = False):\n        self.triggerAction(WEB_ACTION[action], checked)\n\n    def set_feature_permission(\n        self,\n        url: datatypes.UrlType,\n        feature: FeatureStr,\n        policy: PermissionPolicyStr,\n    ):\n        url = core.Url(url)\n        self.setFeaturePermission(url, FEATURE[feature], PERMISSION_POLICY[policy])\n\n    def get_history(self) -&gt; webenginecore.WebEngineHistory:\n        hist = self.history()\n        return webenginecore.WebEngineHistory(hist)\n\n    def get_settings(self) -&gt; webenginecore.WebEngineSettings:\n        settings = self.settings()\n        return webenginecore.WebEngineSettings(settings)\n\n    def set_setting(\n        self,\n        setting_name: webenginecore.webenginesettings.WebAttributeStr,\n        value: bool,\n    ):\n        self.get_settings()[setting_name] = value\n\n    def get_setting(\n        self, setting_name: webenginecore.webenginesettings.WebAttributeStr\n    ) -&gt; bool:\n        return self.get_settings()[setting_name]\n\n    def get_scripts(self) -&gt; webenginecore.WebEngineScriptCollection:\n        return webenginecore.WebEngineScriptCollection(self.scripts())\n\n    def get_context_menu_data(self) -&gt; webenginecore.WebEngineContextMenuRequest:\n        return webenginecore.WebEngineContextMenuRequest(self.contextMenuData())\n\n    def open_in_browser(self):\n        try:\n            webbrowser.open(self.getUrl().toString())\n        except ValueError as e:\n            logger.exception(e)\n\n    # def choose_files(\n    #     self,\n    #     mode: FileSelectionModeStr,\n    #     old_files: List[str],\n    #     mimetypes: List[str],\n    # ) -&gt; List[str]:\n    #     if mode not in FILE_SELECTION_MODE:\n    #         raise InvalidParamError(mode, FILE_SELECTION_MODE)\n    #     return self.chooseFiles(FILE_SELECTION_MODE[mode], old_files, mimetypes)\n\n    def mousedown(self, selector: str, btn: int = 0):\n\"\"\"Simulate a mousedown event on the targeted element.\n\n        :param selector: A CSS3 selector to targeted element.\n        :param btn: The number of mouse button.\n            0 - left button,\n            1 - middle button,\n            2 - right button\n        \"\"\"\n        return self.runJavaScript(\n            f\"\"\"\n            (function () {{\n                var element = document.querySelector({selector!r});\n                var evt = document.createEvent(\"MouseEvents\");\n                evt.initMouseEvent(\"mousedown\", true, true, window,\n                                   1, 1, 1, 1, 1, false, false, false, false,\n{btn!r}, element);\n                return element.dispatchEvent(evt);\n}})();\n        \"\"\"\n        )\n\n    def set_input_value(self, selector: str, value):\n\"\"\"Set the value of the input matched by given selector.\"\"\"\n        script = f'document.querySelector({selector!r}).setAttribute(\"value\", \"{value}\")'\n        self.runJavaScript(script)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.find_text","title":"<code>find_text(self, string: str, backward: bool = False, case_sensitive: bool = False, callback: Callable[[bool], None] | None = None)</code>","text":"<p>Find text in the current page.</p> <p>Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed.</p> <p>To clear the search highlight, just pass an empty string.</p> <p>The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false.</p> <p>Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>string to search for</p> required <code>backward</code> <code>bool</code> <p>search backwards</p> <code>False</code> <code>case_sensitive</code> <code>bool</code> <p>case-sensitive search</p> <code>False</code> <code>callback</code> <code>Callable[[bool], None] | None</code> <p>result callback</p> <code>None</code> Source code in <code>prettyqt/webenginecore/webenginepage.py</code> <pre><code>def find_text(\n    self,\n    string: str,\n    backward: bool = False,\n    case_sensitive: bool = False,\n    callback: Callable[[bool], None] | None = None,\n):\n\"\"\"Find text in the current page.\n\n    Finds the specified string, subString, in the page, using the given options.\n    The findTextFinished() signal is emitted when a string search is completed.\n\n    To clear the search highlight, just pass an empty string.\n\n    The resultCallback must take a boolean parameter.\n    It will be called with a value of true if the subString was found;\n    otherwise the callback value will be false.\n\n    Warning: It is guaranteed that the callback is always called,\n    but it might be done during page destruction. When WebEnginePage is deleted,\n    the callback is triggered with an invalid value and it is not safe to use\n    the corresponding QWebEnginePage or QWebEnginePage instance inside it.\n\n    Args:\n        string: string to search for\n        backward: search backwards\n        case_sensitive: case-sensitive search\n        callback: result callback\n    \"\"\"\n    if callback is None:\n\n        def do_nothing(x):\n            pass\n\n        callback = do_nothing\n    flag = QtWebEngineCore.QWebEnginePage.FindFlag(0)\n    if case_sensitive:\n        flag |= self.FindFlag.FindCaseSensitively\n    if backward:\n        flag |= self.FindFlag.FindBackward\n    self.findText(string, flag, callback)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.get_lifecycle_state","title":"<code>get_lifecycle_state(self) -&gt; LifecycleStateStr</code>","text":"<p>Get the current lifecycle state.</p> <p>Returns:</p> Type Description <code>LifecycleStateStr</code> <p>lifecycle state</p> Source code in <code>prettyqt/webenginecore/webenginepage.py</code> <pre><code>def get_lifecycle_state(self) -&gt; LifecycleStateStr:\n\"\"\"Get the current lifecycle state.\n\n    Returns:\n        lifecycle state\n    \"\"\"\n    return LIFECYCLE_STATE.inverse[self.lifecycleState()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.load_url","title":"<code>load_url(self, url: datatypes.UrlType | datatypes.PathType)</code>","text":"<p>Load the URL.</p> <p>Loads the specified url and displays it.</p> <p>Note: The Page remains the same until enough data has arrived to display the new URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.UrlType | datatypes.PathType</code> <p>URL to load</p> required Source code in <code>prettyqt/webenginecore/webenginepage.py</code> <pre><code>def load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n\n    Loads the specified url and displays it.\n\n    Note: The Page remains the same until enough data has arrived\n    to display the new URL.\n\n    Args:\n        url: URL to load\n    \"\"\"\n    if isinstance(url, os.PathLike):\n        url = core.Url.fromLocalFile(os.fspath(url))\n    elif isinstance(url, str):\n        url = core.Url(url)\n    self.load(url)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.mousedown","title":"<code>mousedown(self, selector: str, btn: int = 0)</code>","text":"<p>Simulate a mousedown event on the targeted element.</p> <p>:param selector: A CSS3 selector to targeted element. :param btn: The number of mouse button.     0 - left button,     1 - middle button,     2 - right button</p> Source code in <code>prettyqt/webenginecore/webenginepage.py</code> <pre><code>def mousedown(self, selector: str, btn: int = 0):\n\"\"\"Simulate a mousedown event on the targeted element.\n\n    :param selector: A CSS3 selector to targeted element.\n    :param btn: The number of mouse button.\n        0 - left button,\n        1 - middle button,\n        2 - right button\n    \"\"\"\n    return self.runJavaScript(\n        f\"\"\"\n        (function () {{\n            var element = document.querySelector({selector!r});\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"mousedown\", true, true, window,\n                               1, 1, 1, 1, 1, false, false, false, false,\n{btn!r}, element);\n            return element.dispatchEvent(evt);\n}})();\n    \"\"\"\n    )\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_input_value","title":"<code>set_input_value(self, selector: str, value)</code>","text":"<p>Set the value of the input matched by given selector.</p> Source code in <code>prettyqt/webenginecore/webenginepage.py</code> <pre><code>def set_input_value(self, selector: str, value):\n\"\"\"Set the value of the input matched by given selector.\"\"\"\n    script = f'document.querySelector({selector!r}).setAttribute(\"value\", \"{value}\")'\n    self.runJavaScript(script)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_lifecycle_state","title":"<code>set_lifecycle_state(self, state: LifecycleStateStr)</code>","text":"<p>Set lifecycle state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>LifecycleStateStr</code> <p>lifecycle state</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>lifecycle state does not exist</p> Source code in <code>prettyqt/webenginecore/webenginepage.py</code> <pre><code>def set_lifecycle_state(self, state: LifecycleStateStr):\n\"\"\"Set lifecycle state.\n\n    Args:\n        state: lifecycle state\n\n    Raises:\n        InvalidParamError: lifecycle state does not exist\n    \"\"\"\n    if state not in LIFECYCLE_STATE:\n        raise InvalidParamError(state, LIFECYCLE_STATE)\n    self.setLifecycleState(LIFECYCLE_STATE[state])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_url","title":"<code>set_url(self, url: datatypes.PathType)</code>","text":"<p>Set the url of the WebEnginePage.</p> <p>Clears the Page and loads the URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.PathType</code> <p>URL to set</p> required Source code in <code>prettyqt/webenginecore/webenginepage.py</code> <pre><code>def set_url(self, url: datatypes.PathType):\n\"\"\"Set the url of the WebEnginePage.\n\n    Clears the Page and loads the URL.\n\n    Args:\n        url: URL to set\n    \"\"\"\n    if isinstance(url, os.PathLike):\n        url = core.Url.fromLocalFile(os.fspath(url))\n    elif isinstance(url, str):\n        url = core.Url(url)\n    self.setUrl(url)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginepage.WebEnginePage.set_zoom","title":"<code>set_zoom(self, zoom: float)</code>","text":"<p>Set the zoom factor for the Page.</p> <p>Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom factor</p> required Source code in <code>prettyqt/webenginecore/webenginepage.py</code> <pre><code>def set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the Page.\n\n    Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n\n    Args:\n        zoom: Zoom factor\n    \"\"\"\n    self.setZoomFactor(zoom)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile","title":"<code>webengineprofile</code>","text":""},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile","title":"<code> WebEngineProfile            (ObjectMixin, QWebEngineProfile)         </code>","text":"Source code in <code>prettyqt/webenginecore/webengineprofile.py</code> <pre><code>class WebEngineProfile(core.ObjectMixin, QtWebEngineCore.QWebEngineProfile):\n    def set_persistent_cookie_policy(self, policy: PersistentCookiePolicyStr):\n\"\"\"Set the persistent cookie policy.\n\n        Args:\n            policy: persistent cookie policy\n\n        Raises:\n            InvalidParamError: Policy does not exist\n        \"\"\"\n        if policy not in PERSISTENT_COOKIE_POLICY:\n            raise InvalidParamError(policy, PERSISTENT_COOKIE_POLICY)\n        self.setPersistentCookiesPolicy(PERSISTENT_COOKIE_POLICY[policy])\n\n    def get_persistent_cookie_policy(self) -&gt; PersistentCookiePolicyStr:\n\"\"\"Return current persistent cookie policy.\n\n        Returns:\n            Persistent cookie policy\n        \"\"\"\n        return PERSISTENT_COOKIE_POLICY.inverse[self.persistentCookiesPolicy()]\n\n    def set_http_cache_type(self, typ: HttpCacheTypeStr):\n\"\"\"Set the http cache type.\n\n        Args:\n            typ: http cache type\n\n        Raises:\n            InvalidParamError: Cache type does not exist\n        \"\"\"\n        if typ not in HTTP_CACHE_TYPE:\n            raise InvalidParamError(typ, HTTP_CACHE_TYPE)\n        self.setHttpCacheType(HTTP_CACHE_TYPE[typ])\n\n    def get_http_cache_type(self) -&gt; HttpCacheTypeStr:\n\"\"\"Return current http cache type.\n\n        Returns:\n            Http cache type\n        \"\"\"\n        return HTTP_CACHE_TYPE.inverse[self.httpCacheType()]\n\n    def get_scripts(self) -&gt; webenginecore.WebEngineScriptCollection:\n        return webenginecore.WebEngineScriptCollection(self.scripts())\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.get_http_cache_type","title":"<code>get_http_cache_type(self) -&gt; HttpCacheTypeStr</code>","text":"<p>Return current http cache type.</p> <p>Returns:</p> Type Description <code>HttpCacheTypeStr</code> <p>Http cache type</p> Source code in <code>prettyqt/webenginecore/webengineprofile.py</code> <pre><code>def get_http_cache_type(self) -&gt; HttpCacheTypeStr:\n\"\"\"Return current http cache type.\n\n    Returns:\n        Http cache type\n    \"\"\"\n    return HTTP_CACHE_TYPE.inverse[self.httpCacheType()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.get_persistent_cookie_policy","title":"<code>get_persistent_cookie_policy(self) -&gt; PersistentCookiePolicyStr</code>","text":"<p>Return current persistent cookie policy.</p> <p>Returns:</p> Type Description <code>PersistentCookiePolicyStr</code> <p>Persistent cookie policy</p> Source code in <code>prettyqt/webenginecore/webengineprofile.py</code> <pre><code>def get_persistent_cookie_policy(self) -&gt; PersistentCookiePolicyStr:\n\"\"\"Return current persistent cookie policy.\n\n    Returns:\n        Persistent cookie policy\n    \"\"\"\n    return PERSISTENT_COOKIE_POLICY.inverse[self.persistentCookiesPolicy()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.set_http_cache_type","title":"<code>set_http_cache_type(self, typ: HttpCacheTypeStr)</code>","text":"<p>Set the http cache type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>HttpCacheTypeStr</code> <p>http cache type</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>Cache type does not exist</p> Source code in <code>prettyqt/webenginecore/webengineprofile.py</code> <pre><code>def set_http_cache_type(self, typ: HttpCacheTypeStr):\n\"\"\"Set the http cache type.\n\n    Args:\n        typ: http cache type\n\n    Raises:\n        InvalidParamError: Cache type does not exist\n    \"\"\"\n    if typ not in HTTP_CACHE_TYPE:\n        raise InvalidParamError(typ, HTTP_CACHE_TYPE)\n    self.setHttpCacheType(HTTP_CACHE_TYPE[typ])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineprofile.WebEngineProfile.set_persistent_cookie_policy","title":"<code>set_persistent_cookie_policy(self, policy: PersistentCookiePolicyStr)</code>","text":"<p>Set the persistent cookie policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>PersistentCookiePolicyStr</code> <p>persistent cookie policy</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>Policy does not exist</p> Source code in <code>prettyqt/webenginecore/webengineprofile.py</code> <pre><code>def set_persistent_cookie_policy(self, policy: PersistentCookiePolicyStr):\n\"\"\"Set the persistent cookie policy.\n\n    Args:\n        policy: persistent cookie policy\n\n    Raises:\n        InvalidParamError: Policy does not exist\n    \"\"\"\n    if policy not in PERSISTENT_COOKIE_POLICY:\n        raise InvalidParamError(policy, PERSISTENT_COOKIE_POLICY)\n    self.setPersistentCookiesPolicy(PERSISTENT_COOKIE_POLICY[policy])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript","title":"<code>webenginescript</code>","text":""},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript.WebEngineScript","title":"<code> WebEngineScript            (QWebEngineScript)         </code>","text":"Source code in <code>prettyqt/webenginecore/webenginescript.py</code> <pre><code>class WebEngineScript(QtWebEngineCore.QWebEngineScript):\n    def set_injection_point(self, point: InjectionPointStr):\n\"\"\"Set injection point.\n\n        Args:\n            point: injection point to use\n\n        Raises:\n            InvalidParamError: injection point does not exist\n        \"\"\"\n        if point not in INJECTION_POINT:\n            raise InvalidParamError(point, INJECTION_POINT)\n        self.setInjectionPoint(INJECTION_POINT[point])\n\n    def get_injection_point(self) -&gt; InjectionPointStr:\n\"\"\"Return injection point.\n\n        Returns:\n            injection point\n        \"\"\"\n        return INJECTION_POINT.inverse[self.injectionPoint()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript.WebEngineScript.get_injection_point","title":"<code>get_injection_point(self) -&gt; InjectionPointStr</code>","text":"<p>Return injection point.</p> <p>Returns:</p> Type Description <code>InjectionPointStr</code> <p>injection point</p> Source code in <code>prettyqt/webenginecore/webenginescript.py</code> <pre><code>def get_injection_point(self) -&gt; InjectionPointStr:\n\"\"\"Return injection point.\n\n    Returns:\n        injection point\n    \"\"\"\n    return INJECTION_POINT.inverse[self.injectionPoint()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginescript.WebEngineScript.set_injection_point","title":"<code>set_injection_point(self, point: InjectionPointStr)</code>","text":"<p>Set injection point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>InjectionPointStr</code> <p>injection point to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>injection point does not exist</p> Source code in <code>prettyqt/webenginecore/webenginescript.py</code> <pre><code>def set_injection_point(self, point: InjectionPointStr):\n\"\"\"Set injection point.\n\n    Args:\n        point: injection point to use\n\n    Raises:\n        InvalidParamError: injection point does not exist\n    \"\"\"\n    if point not in INJECTION_POINT:\n        raise InvalidParamError(point, INJECTION_POINT)\n    self.setInjectionPoint(INJECTION_POINT[point])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings","title":"<code>webenginesettings</code>","text":""},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings","title":"<code> WebEngineSettings        </code>","text":"Source code in <code>prettyqt/webenginecore/webenginesettings.py</code> <pre><code>class WebEngineSettings:\n    def __init__(self, item: QtWebEngineCore.QWebEngineSettings):\n        self.item = item\n\n    def __getattr__(self, val):\n        return getattr(self.item, val)\n\n    def __setitem__(self, index: WebAttributeStr, value: bool):\n        self.item.setAttribute(WEB_ATTRIBUTES[index], value)\n\n    def __getitem__(self, index: WebAttributeStr) -&gt; bool:\n        return self.item.testAttribute(WEB_ATTRIBUTES[index])\n\n    def __delitem__(self, index: WebAttributeStr):\n        return self.item.resetAttribute(WEB_ATTRIBUTES[index])\n\n    def set_unknown_url_scheme_policy(self, policy: UnknownUrlSchemePolicyStr):\n\"\"\"Set the unknown url scheme policy.\n\n        Args:\n            policy: unknown url scheme policy\n\n        Raises:\n            InvalidParamError: Policy does not exist\n        \"\"\"\n        if policy not in UNKNOWN_URL_SCHEME_POLICY:\n            raise InvalidParamError(policy, UNKNOWN_URL_SCHEME_POLICY)\n        self.item.setUnknownUrlSchemePolicy(UNKNOWN_URL_SCHEME_POLICY[policy])\n\n    def get_unknown_url_scheme_policy(self) -&gt; UnknownUrlSchemePolicyStr:\n\"\"\"Return current unknown url scheme policy.\n\n        Returns:\n            Unknown url scheme policy\n        \"\"\"\n        return UNKNOWN_URL_SCHEME_POLICY.inverse[self.item.unknownUrlSchemePolicy()]\n\n    def set_font_family(self, which: FontFamilyStr, family: str):\n\"\"\"Set the actual font family to family for the specified generic family, which.\n\n        Args:\n            which: family to set\n            family: generic family\n\n        Raises:\n            InvalidParamError: Font family does not exist\n        \"\"\"\n        if which not in FONT_FAMILY:\n            raise InvalidParamError(which, FONT_FAMILY)\n        self.item.setFontFamily(FONT_FAMILY[which], family)\n\n    def get_font_family(self, family: FontFamilyStr) -&gt; str:\n\"\"\"Return the actual font family for the specified generic font family.\n\n        Args:\n            family: generic font family\n\n        Returns:\n            Font family\n        \"\"\"\n        return self.item.fontFamily(FONT_FAMILY[family])\n\n    def set_font_size(self, typ: FontSizeStr, size: int):\n\"\"\"Set the font size for type to size in pixels.\n\n        Args:\n            typ: font size type\n            size: size in pixels\n\n        Raises:\n            InvalidParamError: Font size does not exist\n        \"\"\"\n        if typ not in FONT_SIZE:\n            raise InvalidParamError(typ, FONT_SIZE)\n        self.item.setFontSize(FONT_SIZE[typ], size)\n\n    def get_font_size(self, typ: FontSizeStr) -&gt; int:\n\"\"\"Return the default font size for type in pixels.\n\n        Args:\n            typ: font size type\n\n        Returns:\n            Font size\n        \"\"\"\n        return self.item.fontSize(FONT_SIZE[typ])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_font_family","title":"<code>get_font_family(self, family: FontFamilyStr) -&gt; str</code>","text":"<p>Return the actual font family for the specified generic font family.</p> <p>Parameters:</p> Name Type Description Default <code>family</code> <code>FontFamilyStr</code> <p>generic font family</p> required <p>Returns:</p> Type Description <code>str</code> <p>Font family</p> Source code in <code>prettyqt/webenginecore/webenginesettings.py</code> <pre><code>def get_font_family(self, family: FontFamilyStr) -&gt; str:\n\"\"\"Return the actual font family for the specified generic font family.\n\n    Args:\n        family: generic font family\n\n    Returns:\n        Font family\n    \"\"\"\n    return self.item.fontFamily(FONT_FAMILY[family])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_font_size","title":"<code>get_font_size(self, typ: FontSizeStr) -&gt; int</code>","text":"<p>Return the default font size for type in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>FontSizeStr</code> <p>font size type</p> required <p>Returns:</p> Type Description <code>int</code> <p>Font size</p> Source code in <code>prettyqt/webenginecore/webenginesettings.py</code> <pre><code>def get_font_size(self, typ: FontSizeStr) -&gt; int:\n\"\"\"Return the default font size for type in pixels.\n\n    Args:\n        typ: font size type\n\n    Returns:\n        Font size\n    \"\"\"\n    return self.item.fontSize(FONT_SIZE[typ])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.get_unknown_url_scheme_policy","title":"<code>get_unknown_url_scheme_policy(self) -&gt; UnknownUrlSchemePolicyStr</code>","text":"<p>Return current unknown url scheme policy.</p> <p>Returns:</p> Type Description <code>UnknownUrlSchemePolicyStr</code> <p>Unknown url scheme policy</p> Source code in <code>prettyqt/webenginecore/webenginesettings.py</code> <pre><code>def get_unknown_url_scheme_policy(self) -&gt; UnknownUrlSchemePolicyStr:\n\"\"\"Return current unknown url scheme policy.\n\n    Returns:\n        Unknown url scheme policy\n    \"\"\"\n    return UNKNOWN_URL_SCHEME_POLICY.inverse[self.item.unknownUrlSchemePolicy()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_font_family","title":"<code>set_font_family(self, which: FontFamilyStr, family: str)</code>","text":"<p>Set the actual font family to family for the specified generic family, which.</p> <p>Parameters:</p> Name Type Description Default <code>which</code> <code>FontFamilyStr</code> <p>family to set</p> required <code>family</code> <code>str</code> <p>generic family</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>Font family does not exist</p> Source code in <code>prettyqt/webenginecore/webenginesettings.py</code> <pre><code>def set_font_family(self, which: FontFamilyStr, family: str):\n\"\"\"Set the actual font family to family for the specified generic family, which.\n\n    Args:\n        which: family to set\n        family: generic family\n\n    Raises:\n        InvalidParamError: Font family does not exist\n    \"\"\"\n    if which not in FONT_FAMILY:\n        raise InvalidParamError(which, FONT_FAMILY)\n    self.item.setFontFamily(FONT_FAMILY[which], family)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_font_size","title":"<code>set_font_size(self, typ: FontSizeStr, size: int)</code>","text":"<p>Set the font size for type to size in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>FontSizeStr</code> <p>font size type</p> required <code>size</code> <code>int</code> <p>size in pixels</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>Font size does not exist</p> Source code in <code>prettyqt/webenginecore/webenginesettings.py</code> <pre><code>def set_font_size(self, typ: FontSizeStr, size: int):\n\"\"\"Set the font size for type to size in pixels.\n\n    Args:\n        typ: font size type\n        size: size in pixels\n\n    Raises:\n        InvalidParamError: Font size does not exist\n    \"\"\"\n    if typ not in FONT_SIZE:\n        raise InvalidParamError(typ, FONT_SIZE)\n    self.item.setFontSize(FONT_SIZE[typ], size)\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginesettings.WebEngineSettings.set_unknown_url_scheme_policy","title":"<code>set_unknown_url_scheme_policy(self, policy: UnknownUrlSchemePolicyStr)</code>","text":"<p>Set the unknown url scheme policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>UnknownUrlSchemePolicyStr</code> <p>unknown url scheme policy</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>Policy does not exist</p> Source code in <code>prettyqt/webenginecore/webenginesettings.py</code> <pre><code>def set_unknown_url_scheme_policy(self, policy: UnknownUrlSchemePolicyStr):\n\"\"\"Set the unknown url scheme policy.\n\n    Args:\n        policy: unknown url scheme policy\n\n    Raises:\n        InvalidParamError: Policy does not exist\n    \"\"\"\n    if policy not in UNKNOWN_URL_SCHEME_POLICY:\n        raise InvalidParamError(policy, UNKNOWN_URL_SCHEME_POLICY)\n    self.item.setUnknownUrlSchemePolicy(UNKNOWN_URL_SCHEME_POLICY[policy])\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme","title":"<code>webengineurlscheme</code>","text":""},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme","title":"<code> WebEngineUrlScheme            (QWebEngineUrlScheme)         </code>","text":"Source code in <code>prettyqt/webenginecore/webengineurlscheme.py</code> <pre><code>class WebEngineUrlScheme(QtWebEngineCore.QWebEngineUrlScheme):\n    def get_name(self) -&gt; str:\n        return bytes(self.name()).decode()\n\n    @classmethod\n    def get_scheme_by_name(cls, name: str) -&gt; WebEngineUrlScheme:\n        scheme = cls.schemeByName(QtCore.QByteArray(name.encode()))\n        return cls(scheme)\n\n    def set_name(self, name: str):\n        self.setName(QtCore.QByteArray(name.encode()))\n\n    def set_syntax(self, syntax: SyntaxStr):\n\"\"\"Set syntax.\n\n        Args:\n            syntax: syntax to use\n\n        Raises:\n            InvalidParamError: syntax does not exist\n        \"\"\"\n        if syntax not in SYNTAX:\n            raise InvalidParamError(syntax, SYNTAX)\n        self.setSyntax(SYNTAX[syntax])\n\n    def get_syntax(self) -&gt; SyntaxStr:\n\"\"\"Return syntax.\n\n        Returns:\n            syntax\n        \"\"\"\n        return SYNTAX.inverse[self.syntax()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.get_syntax","title":"<code>get_syntax(self) -&gt; SyntaxStr</code>","text":"<p>Return syntax.</p> <p>Returns:</p> Type Description <code>SyntaxStr</code> <p>syntax</p> Source code in <code>prettyqt/webenginecore/webengineurlscheme.py</code> <pre><code>def get_syntax(self) -&gt; SyntaxStr:\n\"\"\"Return syntax.\n\n    Returns:\n        syntax\n    \"\"\"\n    return SYNTAX.inverse[self.syntax()]\n</code></pre>"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.set_syntax","title":"<code>set_syntax(self, syntax: SyntaxStr)</code>","text":"<p>Set syntax.</p> <p>Parameters:</p> Name Type Description Default <code>syntax</code> <code>SyntaxStr</code> <p>syntax to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>syntax does not exist</p> Source code in <code>prettyqt/webenginecore/webengineurlscheme.py</code> <pre><code>def set_syntax(self, syntax: SyntaxStr):\n\"\"\"Set syntax.\n\n    Args:\n        syntax: syntax to use\n\n    Raises:\n        InvalidParamError: syntax does not exist\n    \"\"\"\n    if syntax not in SYNTAX:\n        raise InvalidParamError(syntax, SYNTAX)\n    self.setSyntax(SYNTAX[syntax])\n</code></pre>"},{"location":"api/webenginewidgets.html","title":"webenginewidgets module","text":"<p>Webenginewidgets module.</p> <p>contains QtWebEngineWidgets-based classes</p>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview","title":"<code>webengineview</code>","text":""},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView","title":"<code> WebEngineView            (WidgetMixin, QWebEngineView)         </code>","text":"Source code in <code>prettyqt/webenginewidgets/webengineview.py</code> <pre><code>class WebEngineView(widgets.WidgetMixin, QtWebEngineWidgets.QWebEngineView):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.setPage(webenginecore.WebEnginePage(self))\n\n    def set_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Set the url of the WebEngineView.\n\n        Clears the view and loads the URL.\n\n        Args:\n            url: URL to set\n        \"\"\"\n        if isinstance(url, os.PathLike):\n            url = core.Url.fromLocalFile(os.fspath(url))\n        elif isinstance(url, str):\n            url = core.Url(url)\n        self.setUrl(url)\n\n    def get_url(self) -&gt; core.Url:\n        return core.Url(self.url())\n\n    def load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n\n        Loads the specified url and displays it.\n\n        Note: The view remains the same until enough data has arrived\n        to display the new URL.\n\n        Args:\n            url: URL to load\n        \"\"\"\n        if isinstance(url, os.PathLike):\n            url = core.Url.fromLocalFile(os.fspath(url))\n        elif isinstance(url, str):\n            url = core.Url(url)\n        self.load(url)\n\n    def set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the view.\n\n        Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n\n        Args:\n            zoom: Zoom factor\n        \"\"\"\n        self.setZoomFactor(zoom)\n\n    def find_text(\n        self,\n        string: str,\n        backward: bool = False,\n        case_sensitive: bool = False,\n        callback: Callable[[bool], None] = None,\n    ):\n\"\"\"Find text in the current page.\n\n        Finds the specified string, subString, in the page, using the given options.\n        The findTextFinished() signal is emitted when a string search is completed.\n\n        To clear the search highlight, just pass an empty string.\n\n        The resultCallback must take a boolean parameter.\n        It will be called with a value of true if the subString was found;\n        otherwise the callback value will be false.\n\n        Warning: It is guaranteed that the callback is always called,\n        but it might be done during page destruction. When WebEnginePage is deleted,\n        the callback is triggered with an invalid value and it is not safe to use\n        the corresponding QWebEnginePage or QWebEngineView instance inside it.\n\n        Args:\n            string: string to search for\n            backward: search backwards\n            case_sensitive: case-sensitive search\n            callback: result callback\n        \"\"\"\n        if callback is None:\n\n            def do_nothing(x):\n                pass\n\n            callback = do_nothing\n        flag = webenginecore.WebEnginePage.FindFlag(0)\n        if case_sensitive:\n            flag |= webenginecore.WebEnginePage.FindFlag.FindCaseSensitively\n        if backward:\n            flag |= webenginecore.WebEnginePage.FindFlag.FindBackward\n        self.findText(string, flag, callback)\n\n    def get_settings(self) -&gt; webenginecore.WebEngineSettings:\n        settings = self.settings()\n        return webenginecore.WebEngineSettings(settings)\n\n    def set_setting(\n        self,\n        setting_name: webenginecore.webenginesettings.WebAttributeStr,\n        value: bool,\n    ):\n        self.get_settings()[setting_name] = value\n\n    def get_setting(\n        self, setting_name: webenginecore.webenginesettings.WebAttributeStr\n    ) -&gt; bool:\n        return self.get_settings()[setting_name]\n\n    @classmethod\n    def register_as_browser(cls, tabwidget: widgets.TabWidget):\n        class BuiltInBrowser(webbrowser.BaseBrowser):\n            def open(self, url: str, new: int = 0, autoraise: bool = True):\n                # logger.info(f\"opening {url} with builtin browser..\")\n                webview = cls()\n                webview.load_url(url)\n                if new == 1:\n                    webview.show()\n                else:\n                    tabwidget.add_tab(webview, str(url), show=autoraise)\n\n        webbrowser.register(\"BuiltInBrowser\", BuiltInBrowser)\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.find_text","title":"<code>find_text(self, string: str, backward: bool = False, case_sensitive: bool = False, callback: Callable[[bool], None] = None)</code>","text":"<p>Find text in the current page.</p> <p>Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed.</p> <p>To clear the search highlight, just pass an empty string.</p> <p>The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false.</p> <p>Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>string to search for</p> required <code>backward</code> <code>bool</code> <p>search backwards</p> <code>False</code> <code>case_sensitive</code> <code>bool</code> <p>case-sensitive search</p> <code>False</code> <code>callback</code> <code>Callable[[bool], None]</code> <p>result callback</p> <code>None</code> Source code in <code>prettyqt/webenginewidgets/webengineview.py</code> <pre><code>def find_text(\n    self,\n    string: str,\n    backward: bool = False,\n    case_sensitive: bool = False,\n    callback: Callable[[bool], None] = None,\n):\n\"\"\"Find text in the current page.\n\n    Finds the specified string, subString, in the page, using the given options.\n    The findTextFinished() signal is emitted when a string search is completed.\n\n    To clear the search highlight, just pass an empty string.\n\n    The resultCallback must take a boolean parameter.\n    It will be called with a value of true if the subString was found;\n    otherwise the callback value will be false.\n\n    Warning: It is guaranteed that the callback is always called,\n    but it might be done during page destruction. When WebEnginePage is deleted,\n    the callback is triggered with an invalid value and it is not safe to use\n    the corresponding QWebEnginePage or QWebEngineView instance inside it.\n\n    Args:\n        string: string to search for\n        backward: search backwards\n        case_sensitive: case-sensitive search\n        callback: result callback\n    \"\"\"\n    if callback is None:\n\n        def do_nothing(x):\n            pass\n\n        callback = do_nothing\n    flag = webenginecore.WebEnginePage.FindFlag(0)\n    if case_sensitive:\n        flag |= webenginecore.WebEnginePage.FindFlag.FindCaseSensitively\n    if backward:\n        flag |= webenginecore.WebEnginePage.FindFlag.FindBackward\n    self.findText(string, flag, callback)\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.load_url","title":"<code>load_url(self, url: datatypes.UrlType | datatypes.PathType)</code>","text":"<p>Load the URL.</p> <p>Loads the specified url and displays it.</p> <p>Note: The view remains the same until enough data has arrived to display the new URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.UrlType | datatypes.PathType</code> <p>URL to load</p> required Source code in <code>prettyqt/webenginewidgets/webengineview.py</code> <pre><code>def load_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Load the URL.\n\n    Loads the specified url and displays it.\n\n    Note: The view remains the same until enough data has arrived\n    to display the new URL.\n\n    Args:\n        url: URL to load\n    \"\"\"\n    if isinstance(url, os.PathLike):\n        url = core.Url.fromLocalFile(os.fspath(url))\n    elif isinstance(url, str):\n        url = core.Url(url)\n    self.load(url)\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_url","title":"<code>set_url(self, url: datatypes.UrlType | datatypes.PathType)</code>","text":"<p>Set the url of the WebEngineView.</p> <p>Clears the view and loads the URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>datatypes.UrlType | datatypes.PathType</code> <p>URL to set</p> required Source code in <code>prettyqt/webenginewidgets/webengineview.py</code> <pre><code>def set_url(self, url: datatypes.UrlType | datatypes.PathType):\n\"\"\"Set the url of the WebEngineView.\n\n    Clears the view and loads the URL.\n\n    Args:\n        url: URL to set\n    \"\"\"\n    if isinstance(url, os.PathLike):\n        url = core.Url.fromLocalFile(os.fspath(url))\n    elif isinstance(url, str):\n        url = core.Url(url)\n    self.setUrl(url)\n</code></pre>"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_zoom","title":"<code>set_zoom(self, zoom: float)</code>","text":"<p>Set the zoom factor for the view.</p> <p>Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom factor</p> required Source code in <code>prettyqt/webenginewidgets/webengineview.py</code> <pre><code>def set_zoom(self, zoom: float):\n\"\"\"Set the zoom factor for the view.\n\n    Valid values are within the range from 0.25 to 5.0. The default factor is 1.0.\n\n    Args:\n        zoom: Zoom factor\n    \"\"\"\n    self.setZoomFactor(zoom)\n</code></pre>"},{"location":"api/widgets.html","title":"widgets module","text":"<p>widgets module.</p> <p>contains QtWidgets-based classes</p>"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton","title":"<code>abstractbutton</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButtonMixin","title":"<code> AbstractButtonMixin            (WidgetMixin)         </code>","text":"Source code in <code>prettyqt/widgets/abstractbutton.py</code> <pre><code>class AbstractButtonMixin(widgets.WidgetMixin):\n    def serialize_fields(self):\n        return dict(\n            text=self.text(),\n            icon=self.get_icon(),\n            checkable=self.isCheckable(),\n            checked=self.isChecked(),\n            auto_exclusive=self.autoExclusive(),\n            auto_repeat=self.autoRepeat(),\n            auto_repeat_delay=self.autoRepeatDelay(),\n            auto_repeat_interval=self.autoRepeatInterval(),\n            is_down=self.isDown(),\n            icon_size=self.get_icon_size(),\n            shortcut=self.get_shortcut(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.setText(state[\"text\"])\n        self.set_icon(state[\"icon\"])\n        self.setChecked(state.get(\"checked\", False))\n        self.setCheckable(state[\"checkable\"])\n        self.setAutoExclusive(state[\"auto_exclusive\"])\n        self.setAutoRepeat(state[\"auto_repeat\"])\n        self.setAutoRepeatDelay(state[\"auto_repeat_delay\"])\n        self.setAutoRepeatInterval(state[\"auto_repeat_interval\"])\n        self.setDown(state[\"is_down\"])\n        self.set_icon_size(state[\"icon_size\"])\n        self.setShortcut(state[\"shortcut\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __bool__(self):\n        return self.isChecked()\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the button.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        if icon.isNull():\n            return None\n        return gui.Icon(icon)\n\n    def set_style_icon(self, icon: widgets.style.StandardPixmapStr, size: int = 15):\n\"\"\"Set theme icon for the button.\n\n        Args:\n            icon: icon to use\n            size: icon size\n        \"\"\"\n        if icon not in widgets.style.STANDARD_PIXMAP:\n            raise InvalidParamError(icon, widgets.style.STANDARD_PIXMAP)\n        qicon = self.style().standardIcon(widgets.style.STANDARD_PIXMAP[icon], None, self)\n        self.set_icon(qicon)\n        self.setIconSize(core.Size(size, size))\n\n    def set_shortcut(self, shortcut: None | QtGui.QKeySequence | str):\n        if shortcut is None:\n            shortcut = \"\"\n        if isinstance(shortcut, str):\n            shortcut = gui.KeySequence(\n                shortcut, gui.KeySequence.SequenceFormat.PortableText\n            )\n        self.setShortcut(shortcut)\n\n    def get_shortcut(self) -&gt; gui.KeySequence:\n        return gui.KeySequence(\n            self.shortcut().toString(), gui.KeySequence.SequenceFormat.PortableText\n        )\n\n    def set_text(self, text: str):\n        self.setText(text)\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icon.\"\"\"\n        if isinstance(size, int):\n            size = core.Size(size, size)\n        elif isinstance(size, tuple):\n            size = core.Size(*size)\n        self.setIconSize(size)\n\n    def get_icon_size(self) -&gt; core.Size:\n        return core.Size(self.iconSize())\n\n    def get_value(self) -&gt; bool:\n        return self.isChecked()\n\n    def set_value(self, value: bool):\n        self.setChecked(value)\n\n    @property\n    def is_on(self) -&gt; bool:\n        return self.isChecked()\n\n    @is_on.setter\n    def is_on(self, state: bool):\n        self.setChecked(state)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButtonMixin.set_icon","title":"<code>set_icon(self, icon: datatypes.IconType)</code>","text":"<p>Set the icon for the button.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt/widgets/abstractbutton.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the button.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButtonMixin.set_icon_size","title":"<code>set_icon_size(self, size: int | datatypes.SizeType)</code>","text":"<p>Set size of the icon.</p> Source code in <code>prettyqt/widgets/abstractbutton.py</code> <pre><code>def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icon.\"\"\"\n    if isinstance(size, int):\n        size = core.Size(size, size)\n    elif isinstance(size, tuple):\n        size = core.Size(*size)\n    self.setIconSize(size)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButtonMixin.set_style_icon","title":"<code>set_style_icon(self, icon: widgets.style.StandardPixmapStr, size: int = 15)</code>","text":"<p>Set theme icon for the button.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>widgets.style.StandardPixmapStr</code> <p>icon to use</p> required <code>size</code> <code>int</code> <p>icon size</p> <code>15</code> Source code in <code>prettyqt/widgets/abstractbutton.py</code> <pre><code>def set_style_icon(self, icon: widgets.style.StandardPixmapStr, size: int = 15):\n\"\"\"Set theme icon for the button.\n\n    Args:\n        icon: icon to use\n        size: icon size\n    \"\"\"\n    if icon not in widgets.style.STANDARD_PIXMAP:\n        raise InvalidParamError(icon, widgets.style.STANDARD_PIXMAP)\n    qicon = self.style().standardIcon(widgets.style.STANDARD_PIXMAP[icon], None, self)\n    self.set_icon(qicon)\n    self.setIconSize(core.Size(size, size))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview","title":"<code>abstractitemview</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin","title":"<code> AbstractItemViewMixin            (AbstractScrollAreaMixin)         </code>","text":"Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>class AbstractItemViewMixin(widgets.AbstractScrollAreaMixin):\n    def __len__(self) -&gt; int:\n        if (model := self.model()) is not None:\n            return model.rowCount()\n        return 0\n\n    def selectAll(self):\n\"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\"\n        if self.model() is None:\n            return\n        if self.model().rowCount() * self.model().columnCount() &gt; 1_000_000:\n            logger.warning(\"Too many cells to select.\")\n            return\n        super().selectAll()\n\n    def set_model(self, model: QtCore.QAbstractItemModel | None):\n\"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\"\n        old_model = self.model()\n        old_sel_model = self.selectionModel()\n        if old_model is not None or model is not None:\n            self.setModel(model)  # type: ignore\n        # if old_model:\n        #     old_model.deleteLater()\n        #     del old_model\n        if old_sel_model:\n            old_sel_model.deleteLater()\n            del old_sel_model\n\n    def set_delegate(\n        self,\n        delegate: QtWidgets.QItemDelegate,\n        column: int | None = None,\n        row: int | None = None,\n        persistent: bool = False,\n    ):\n        if column is not None:\n            self.setItemDelegateForColumn(column, delegate)\n            if persistent:\n                model = self.model()\n                for i in range(model.rowCount()):\n                    self.openPersistentEditor(model.index(i, column))\n        elif row is not None:\n            self.setItemDelegateForRow(row, delegate)\n            if persistent:\n                model = self.model()\n                for i in range(model.columnCount()):\n                    self.openPersistentEditor(model.index(row, i))\n        else:\n            self.setItemDelegate(delegate)\n\n    def toggle_select_all(self):\n\"\"\"Select all items from list (deselect when all selected).\"\"\"\n        if self.selectionModel() is None:\n            return\n        if self.selectionModel().hasSelection():\n            self.clearSelection()\n        else:\n            self.selectAll()\n\n    def set_table_color(self, color: str):\n        with self.edit_stylesheet() as ss:\n            ss.QHeaderView.section.backgroundColor.setValue(color)\n\n    def current_index(self) -&gt; QtCore.QModelIndex | None:\n        if (model := self.selectionModel()) is not None:\n            return model.currentIndex()\n\n    def current_data(self):\n        if (model := self.selectionModel()) is not None:\n            idx = model.currentIndex()\n            return idx.data(constants.USER_ROLE)  # type: ignore\n\n    def current_row(self) -&gt; int | None:\n        if (model := self.selectionModel()) is not None:\n            return model.currentIndex().row()\n\n    def current_column(self) -&gt; int | None:\n        if (model := self.selectionModel()) is not None:\n            return model.currentIndex().column()\n\n    def selected_indexes(self) -&gt; list[QtCore.QModelIndex]:\n\"\"\"Return list of selected indexes in first row.\"\"\"\n        indexes = (x for x in self.selectedIndexes() if x.column() == 0)  # type: ignore\n        return sorted(indexes, key=lambda x: x.row())  # type: ignore\n\n    def selected_names(self) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding item names.\"\"\"\n        return (x.data(constants.NAME_ROLE) for x in self.selected_indexes())\n\n    def selected_rows(self) -&gt; Generator[int, None, None]:\n\"\"\"Return generator yielding row nums.\"\"\"\n        return (x.row() for x in self.selected_indexes())\n\n    def selected_data(self) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding selected userData.\"\"\"\n        return (\n            x.data(constants.USER_ROLE) for x in self.selected_indexes()  # type: ignore\n        )\n\n    def setup_dragdrop_move(self):\n        self.setDragEnabled(True)\n        self.setAcceptDrops(True)\n        self.setDragDropMode(self.DragDropMode.DragDrop)\n        self.setDefaultDropAction(constants.MOVE_ACTION)\n        self.setDropIndicatorShown(True)\n\n    def set_edit_triggers(self, *triggers: EditTriggerStr | None):\n        items = [\"none\" if t is None else t for t in triggers]\n        for item in items:\n            if item not in EDIT_TRIGGERS:\n                raise InvalidParamError(item, EDIT_TRIGGERS)\n        flags = helpers.merge_flags(items, EDIT_TRIGGERS)\n        self.setEditTriggers(flags)\n\n    def get_edit_triggers(self) -&gt; list[EditTriggerStr]:\n        return [k for k, v in EDIT_TRIGGERS.items() if v &amp; self.editTriggers()]\n\n    def set_selection_behaviour(self, behaviour: SelectionBehaviourStr):\n\"\"\"Set selection behaviour for given item view.\n\n        Args:\n            behaviour: selection behaviour to use\n\n        Raises:\n            InvalidParamError: behaviour does not exist\n        \"\"\"\n        if behaviour not in SELECTION_BEHAVIOUR:\n            raise InvalidParamError(behaviour, SELECTION_BEHAVIOUR)\n        self.setSelectionBehavior(SELECTION_BEHAVIOUR[behaviour])\n\n    def get_selection_behaviour(self) -&gt; SelectionBehaviourStr:\n\"\"\"Return current selection behaviour.\n\n        Returns:\n            selection behaviour\n        \"\"\"\n        return SELECTION_BEHAVIOUR.inverse[self.selectionBehavior()]\n\n    def set_drag_drop_mode(self, mode: DragDropModeStr):\n\"\"\"Set drag-drop mode for given item view.\n\n        Args:\n            mode: drag-drop mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in DRAG_DROP_MODE:\n            raise InvalidParamError(mode, DRAG_DROP_MODE)\n        self.setDragDropMode(DRAG_DROP_MODE[mode])\n\n    def get_drag_drop_mode(self) -&gt; DragDropModeStr:\n\"\"\"Return current drag-drop mode.\n\n        Returns:\n            drag-drop mode\n        \"\"\"\n        return DRAG_DROP_MODE.inverse[self.dragDropMode()]\n\n    def set_selection_mode(self, mode: SelectionModeStr | None):\n\"\"\"Set selection mode for given item view.\n\n        Args:\n            mode: selection mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode is None:\n            mode = \"none\"\n        if mode not in SELECTION_MODE:\n            raise InvalidParamError(mode, SELECTION_MODE)\n        self.setSelectionMode(SELECTION_MODE[mode])\n\n    def get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n\n        Returns:\n            selection mode\n        \"\"\"\n        return SELECTION_MODE.inverse[self.selectionMode()]\n\n    def set_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the scroll mode for both directions.\n\n        Args:\n            mode: mode to set\n\n        Raises:\n            InvalidParamError: invalid scroll mode\n        \"\"\"\n        if mode not in SCROLL_MODE:\n            raise InvalidParamError(mode, SCROLL_MODE)\n        self.setHorizontalScrollMode(SCROLL_MODE[mode])\n        self.setVerticalScrollMode(SCROLL_MODE[mode])\n\n    def set_horizontal_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the horizontal scroll mode.\n\n        Args:\n            mode: mode to set\n\n        Raises:\n            InvalidParamError: invalid scroll mode\n        \"\"\"\n        if mode not in SCROLL_MODE:\n            raise InvalidParamError(mode, SCROLL_MODE)\n        self.setHorizontalScrollMode(SCROLL_MODE[mode])\n\n    def set_vertical_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the vertical scroll mode.\n\n        Args:\n            mode: mode to set\n\n        Raises:\n            InvalidParamError: invalid scroll mode\n        \"\"\"\n        if mode not in SCROLL_MODE:\n            raise InvalidParamError(mode, SCROLL_MODE)\n        self.setVerticalScrollMode(SCROLL_MODE[mode])\n\n    def num_selected(self) -&gt; int:\n\"\"\"Return amount of selected rows.\n\n        Returns:\n            amount of selected rows\n        \"\"\"\n        if (model := self.selectionModel()) is not None:\n            return len(model.selectedRows())\n        return 0\n\n    def jump_to_column(self, col_num: int):\n\"\"\"Make sure column at given index is visible.\n\n        scrolls to column at given index\n\n        Args:\n            col_num: column to scroll to\n        \"\"\"\n        if (model := self.model()) is not None:\n            idx = model.index(0, col_num)\n            self.scrollTo(idx)\n\n    def scroll_to_top(self):\n\"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\"\n        self.scrollToTop()\n\n    def scroll_to_bottom(self):\n\"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\"\n        self.scrollToBottom()\n\n    def select_last_row(self):\n        idx = self.model().createIndex(self.model().rowCount() - 1, 0)\n        self.setCurrentIndex(idx)\n\n    def scroll_to(self, index, mode: ScrollHintStr = \"ensure_visible\"):\n        if mode not in SCROLL_HINT:\n            raise InvalidParamError(mode, SCROLL_HINT)\n        self.scrollTo(index, SCROLL_HINT[mode])\n\n    def highlight_when_inactive(self):\n\"\"\"Highlight items when widget does not have focus.\"\"\"\n        p = gui.Palette()\n        p.highlight_inactive()\n        self.setPalette(p)\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n        if isinstance(size, tuple):\n            size = QtCore.QSize(*size)\n        elif isinstance(size, int):\n            size = QtCore.QSize(size, size)\n        self.setIconSize(size)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_drag_drop_mode","title":"<code>get_drag_drop_mode(self) -&gt; DragDropModeStr</code>","text":"<p>Return current drag-drop mode.</p> <p>Returns:</p> Type Description <code>DragDropModeStr</code> <p>drag-drop mode</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def get_drag_drop_mode(self) -&gt; DragDropModeStr:\n\"\"\"Return current drag-drop mode.\n\n    Returns:\n        drag-drop mode\n    \"\"\"\n    return DRAG_DROP_MODE.inverse[self.dragDropMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_selection_behaviour","title":"<code>get_selection_behaviour(self) -&gt; SelectionBehaviourStr</code>","text":"<p>Return current selection behaviour.</p> <p>Returns:</p> Type Description <code>SelectionBehaviourStr</code> <p>selection behaviour</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def get_selection_behaviour(self) -&gt; SelectionBehaviourStr:\n\"\"\"Return current selection behaviour.\n\n    Returns:\n        selection behaviour\n    \"\"\"\n    return SELECTION_BEHAVIOUR.inverse[self.selectionBehavior()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.get_selection_mode","title":"<code>get_selection_mode(self) -&gt; SelectionModeStr</code>","text":"<p>Return current selection mode.</p> <p>Returns:</p> Type Description <code>SelectionModeStr</code> <p>selection mode</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n\n    Returns:\n        selection mode\n    \"\"\"\n    return SELECTION_MODE.inverse[self.selectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.highlight_when_inactive","title":"<code>highlight_when_inactive(self)</code>","text":"<p>Highlight items when widget does not have focus.</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def highlight_when_inactive(self):\n\"\"\"Highlight items when widget does not have focus.\"\"\"\n    p = gui.Palette()\n    p.highlight_inactive()\n    self.setPalette(p)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.jump_to_column","title":"<code>jump_to_column(self, col_num: int)</code>","text":"<p>Make sure column at given index is visible.</p> <p>scrolls to column at given index</p> <p>Parameters:</p> Name Type Description Default <code>col_num</code> <code>int</code> <p>column to scroll to</p> required Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def jump_to_column(self, col_num: int):\n\"\"\"Make sure column at given index is visible.\n\n    scrolls to column at given index\n\n    Args:\n        col_num: column to scroll to\n    \"\"\"\n    if (model := self.model()) is not None:\n        idx = model.index(0, col_num)\n        self.scrollTo(idx)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.num_selected","title":"<code>num_selected(self) -&gt; int</code>","text":"<p>Return amount of selected rows.</p> <p>Returns:</p> Type Description <code>int</code> <p>amount of selected rows</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def num_selected(self) -&gt; int:\n\"\"\"Return amount of selected rows.\n\n    Returns:\n        amount of selected rows\n    \"\"\"\n    if (model := self.selectionModel()) is not None:\n        return len(model.selectedRows())\n    return 0\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.scroll_to_bottom","title":"<code>scroll_to_bottom(self)</code>","text":"<p>Override to use abstractitemview-way of scrolling to bottom.</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def scroll_to_bottom(self):\n\"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\"\n    self.scrollToBottom()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.scroll_to_top","title":"<code>scroll_to_top(self)</code>","text":"<p>Override to use abstractitemview-way of scrolling to top.</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def scroll_to_top(self):\n\"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\"\n    self.scrollToTop()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selectAll","title":"<code>selectAll(self)</code>","text":"<p>Override, we dont want to selectAll for too many items bc of performance.</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def selectAll(self):\n\"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\"\n    if self.model() is None:\n        return\n    if self.model().rowCount() * self.model().columnCount() &gt; 1_000_000:\n        logger.warning(\"Too many cells to select.\")\n        return\n    super().selectAll()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_data","title":"<code>selected_data(self) -&gt; Generator[Any, None, None]</code>","text":"<p>Return generator yielding selected userData.</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def selected_data(self) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding selected userData.\"\"\"\n    return (\n        x.data(constants.USER_ROLE) for x in self.selected_indexes()  # type: ignore\n    )\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_indexes","title":"<code>selected_indexes(self) -&gt; list[QtCore.QModelIndex]</code>","text":"<p>Return list of selected indexes in first row.</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def selected_indexes(self) -&gt; list[QtCore.QModelIndex]:\n\"\"\"Return list of selected indexes in first row.\"\"\"\n    indexes = (x for x in self.selectedIndexes() if x.column() == 0)  # type: ignore\n    return sorted(indexes, key=lambda x: x.row())  # type: ignore\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_names","title":"<code>selected_names(self) -&gt; Generator[Any, None, None]</code>","text":"<p>Return generator yielding item names.</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def selected_names(self) -&gt; Generator[Any, None, None]:\n\"\"\"Return generator yielding item names.\"\"\"\n    return (x.data(constants.NAME_ROLE) for x in self.selected_indexes())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.selected_rows","title":"<code>selected_rows(self) -&gt; Generator[int, None, None]</code>","text":"<p>Return generator yielding row nums.</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def selected_rows(self) -&gt; Generator[int, None, None]:\n\"\"\"Return generator yielding row nums.\"\"\"\n    return (x.row() for x in self.selected_indexes())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_drag_drop_mode","title":"<code>set_drag_drop_mode(self, mode: DragDropModeStr)</code>","text":"<p>Set drag-drop mode for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>DragDropModeStr</code> <p>drag-drop mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def set_drag_drop_mode(self, mode: DragDropModeStr):\n\"\"\"Set drag-drop mode for given item view.\n\n    Args:\n        mode: drag-drop mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in DRAG_DROP_MODE:\n        raise InvalidParamError(mode, DRAG_DROP_MODE)\n    self.setDragDropMode(DRAG_DROP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_horizontal_scroll_mode","title":"<code>set_horizontal_scroll_mode(self, mode: ScrollModeStr)</code>","text":"<p>Set the horizontal scroll mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ScrollModeStr</code> <p>mode to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid scroll mode</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def set_horizontal_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the horizontal scroll mode.\n\n    Args:\n        mode: mode to set\n\n    Raises:\n        InvalidParamError: invalid scroll mode\n    \"\"\"\n    if mode not in SCROLL_MODE:\n        raise InvalidParamError(mode, SCROLL_MODE)\n    self.setHorizontalScrollMode(SCROLL_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_model","title":"<code>set_model(self, model: QtCore.QAbstractItemModel | None)</code>","text":"<p>Delete old selection model explicitely, seems to help with memory usage.</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def set_model(self, model: QtCore.QAbstractItemModel | None):\n\"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\"\n    old_model = self.model()\n    old_sel_model = self.selectionModel()\n    if old_model is not None or model is not None:\n        self.setModel(model)  # type: ignore\n    # if old_model:\n    #     old_model.deleteLater()\n    #     del old_model\n    if old_sel_model:\n        old_sel_model.deleteLater()\n        del old_sel_model\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_scroll_mode","title":"<code>set_scroll_mode(self, mode: ScrollModeStr)</code>","text":"<p>Set the scroll mode for both directions.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ScrollModeStr</code> <p>mode to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid scroll mode</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def set_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the scroll mode for both directions.\n\n    Args:\n        mode: mode to set\n\n    Raises:\n        InvalidParamError: invalid scroll mode\n    \"\"\"\n    if mode not in SCROLL_MODE:\n        raise InvalidParamError(mode, SCROLL_MODE)\n    self.setHorizontalScrollMode(SCROLL_MODE[mode])\n    self.setVerticalScrollMode(SCROLL_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_selection_behaviour","title":"<code>set_selection_behaviour(self, behaviour: SelectionBehaviourStr)</code>","text":"<p>Set selection behaviour for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>behaviour</code> <code>SelectionBehaviourStr</code> <p>selection behaviour to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>behaviour does not exist</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def set_selection_behaviour(self, behaviour: SelectionBehaviourStr):\n\"\"\"Set selection behaviour for given item view.\n\n    Args:\n        behaviour: selection behaviour to use\n\n    Raises:\n        InvalidParamError: behaviour does not exist\n    \"\"\"\n    if behaviour not in SELECTION_BEHAVIOUR:\n        raise InvalidParamError(behaviour, SELECTION_BEHAVIOUR)\n    self.setSelectionBehavior(SELECTION_BEHAVIOUR[behaviour])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_selection_mode","title":"<code>set_selection_mode(self, mode: SelectionModeStr | None)</code>","text":"<p>Set selection mode for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SelectionModeStr | None</code> <p>selection mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def set_selection_mode(self, mode: SelectionModeStr | None):\n\"\"\"Set selection mode for given item view.\n\n    Args:\n        mode: selection mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode is None:\n        mode = \"none\"\n    if mode not in SELECTION_MODE:\n        raise InvalidParamError(mode, SELECTION_MODE)\n    self.setSelectionMode(SELECTION_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.set_vertical_scroll_mode","title":"<code>set_vertical_scroll_mode(self, mode: ScrollModeStr)</code>","text":"<p>Set the vertical scroll mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ScrollModeStr</code> <p>mode to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid scroll mode</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def set_vertical_scroll_mode(self, mode: ScrollModeStr):\n\"\"\"Set the vertical scroll mode.\n\n    Args:\n        mode: mode to set\n\n    Raises:\n        InvalidParamError: invalid scroll mode\n    \"\"\"\n    if mode not in SCROLL_MODE:\n        raise InvalidParamError(mode, SCROLL_MODE)\n    self.setVerticalScrollMode(SCROLL_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemViewMixin.toggle_select_all","title":"<code>toggle_select_all(self)</code>","text":"<p>Select all items from list (deselect when all selected).</p> Source code in <code>prettyqt/widgets/abstractitemview.py</code> <pre><code>def toggle_select_all(self):\n\"\"\"Select all items from list (deselect when all selected).\"\"\"\n    if self.selectionModel() is None:\n        return\n    if self.selectionModel().hasSelection():\n        self.clearSelection()\n    else:\n        self.selectAll()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea","title":"<code>abstractscrollarea</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin","title":"<code> AbstractScrollAreaMixin            (FrameMixin)         </code>","text":"Source code in <code>prettyqt/widgets/abstractscrollarea.py</code> <pre><code>class AbstractScrollAreaMixin(widgets.FrameMixin):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.setHorizontalScrollBar(widgets.ScrollBar(parent=self))\n        self.setVerticalScrollBar(widgets.ScrollBar(parent=self))\n\n    def serialize_fields(self):\n        return dict(\n            size_adjust_policy=self.get_size_adjust_policy(),\n            horizontal_scrollbar_policy=self.get_horizontal_scrollbar_policy(),\n            vertical_scrollbar_policy=self.get_vertical_scrollbar_policy(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_size_adjust_policy(state[\"size_adjust_policy\"])\n        self.set_horizontal_scrollbar_policy(state[\"horizontal_scrollbar_policy\"])\n        self.set_vertical_scrollbar_policy(state[\"vertical_scrollbar_policy\"])\n\n    @property\n    def h_scrollbar(self):\n        return self.horizontalScrollBar()\n\n    @h_scrollbar.setter\n    def h_scrollbar(self, scrollbar):\n        self.setHorizontalScrollBar(scrollbar)\n\n    @property\n    def v_scrollbar(self):\n        return self.verticalScrollBar()\n\n    @v_scrollbar.setter\n    def v_scrollbar(self, scrollbar):\n        self.setVerticalScrollBar(scrollbar)\n\n    def set_size_adjust_policy(self, policy: SizePolicyStr):\n\"\"\"Set size adjust policy.\n\n        Args:\n            policy: size adjust policy to use\n\n        Raises:\n            InvalidParamError: invalid size adjust policy\n        \"\"\"\n        if policy not in SIZE_POLICY:\n            raise InvalidParamError(policy, SIZE_POLICY)\n        self.setSizeAdjustPolicy(SIZE_POLICY[policy])\n\n    def get_size_adjust_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size adjust policy.\n\n        Returns:\n            size adjust policy\n        \"\"\"\n        return SIZE_POLICY.inverse[self.sizeAdjustPolicy()]\n\n    def set_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the policy for both scrollbars.\n\n        Args:\n            mode: visibilty to set\n\n        Raises:\n            InvalidParamError: invalid scrollbar policy\n        \"\"\"\n        if mode not in constants.SCROLLBAR_POLICY:\n            raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n        self.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n        self.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n\n    def set_horizontal_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the horizontal scrollbar visibility.\n\n        Args:\n            mode: visibilty to set\n\n        Raises:\n            InvalidParamError: invalid scrollbar policy\n        \"\"\"\n        if mode not in constants.SCROLLBAR_POLICY:\n            raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n        self.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n\n    def get_horizontal_scrollbar_policy(self):\n        return constants.SCROLLBAR_POLICY.inverse[self.horizontalScrollBarPolicy()]\n\n    def set_vertical_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the vertical scrollbar visibility.\n\n        Args:\n            mode: visibilty to set\n\n        Raises:\n            InvalidParamError: invalid scrollbar policy\n        \"\"\"\n        if mode not in constants.SCROLLBAR_POLICY:\n            raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n        self.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n\n    def get_vertical_scrollbar_policy(self):\n        return constants.SCROLLBAR_POLICY.inverse[self.verticalScrollBarPolicy()]\n\n    def set_scrollbar_width(self, width: int):\n\"\"\"Set the width for both scrollbars.\n\n        Args:\n            width: width in pixels\n        \"\"\"\n        self.set_horizontal_scrollbar_width(width)\n        self.set_vertical_scrollbar_width(width)\n\n    def set_horizontal_scrollbar_width(self, width: int):\n\"\"\"Set the horizontal scrollbar width.\n\n        Args:\n            width: width in pixels\n        \"\"\"\n        with self.h_scrollbar.edit_stylesheet() as ss:\n            ss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\n\n    def set_vertical_scrollbar_width(self, width: int):\n\"\"\"Set the vertical scrollbar width.\n\n        Args:\n            width: width in pixels\n        \"\"\"\n        with self.v_scrollbar.edit_stylesheet() as ss:\n            ss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\n\n    def scroll_to_top(self):\n\"\"\"Scroll to the top of the scroll area.\"\"\"\n        self.verticalScrollBar().scroll_to_min()\n\n    def scroll_to_bottom(self):\n\"\"\"Scroll to the bottom of the scroll area.\"\"\"\n        self.verticalScrollBar().scroll_to_max()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.get_size_adjust_policy","title":"<code>get_size_adjust_policy(self) -&gt; SizePolicyStr</code>","text":"<p>Return size adjust policy.</p> <p>Returns:</p> Type Description <code>SizePolicyStr</code> <p>size adjust policy</p> Source code in <code>prettyqt/widgets/abstractscrollarea.py</code> <pre><code>def get_size_adjust_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size adjust policy.\n\n    Returns:\n        size adjust policy\n    \"\"\"\n    return SIZE_POLICY.inverse[self.sizeAdjustPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.scroll_to_bottom","title":"<code>scroll_to_bottom(self)</code>","text":"<p>Scroll to the bottom of the scroll area.</p> Source code in <code>prettyqt/widgets/abstractscrollarea.py</code> <pre><code>def scroll_to_bottom(self):\n\"\"\"Scroll to the bottom of the scroll area.\"\"\"\n    self.verticalScrollBar().scroll_to_max()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.scroll_to_top","title":"<code>scroll_to_top(self)</code>","text":"<p>Scroll to the top of the scroll area.</p> Source code in <code>prettyqt/widgets/abstractscrollarea.py</code> <pre><code>def scroll_to_top(self):\n\"\"\"Scroll to the top of the scroll area.\"\"\"\n    self.verticalScrollBar().scroll_to_min()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_horizontal_scrollbar_policy","title":"<code>set_horizontal_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr)</code>","text":"<p>Set the horizontal scrollbar visibility.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ScrollBarPolicyStr</code> <p>visibilty to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid scrollbar policy</p> Source code in <code>prettyqt/widgets/abstractscrollarea.py</code> <pre><code>def set_horizontal_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the horizontal scrollbar visibility.\n\n    Args:\n        mode: visibilty to set\n\n    Raises:\n        InvalidParamError: invalid scrollbar policy\n    \"\"\"\n    if mode not in constants.SCROLLBAR_POLICY:\n        raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n    self.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_horizontal_scrollbar_width","title":"<code>set_horizontal_scrollbar_width(self, width: int)</code>","text":"<p>Set the horizontal scrollbar width.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>width in pixels</p> required Source code in <code>prettyqt/widgets/abstractscrollarea.py</code> <pre><code>def set_horizontal_scrollbar_width(self, width: int):\n\"\"\"Set the horizontal scrollbar width.\n\n    Args:\n        width: width in pixels\n    \"\"\"\n    with self.h_scrollbar.edit_stylesheet() as ss:\n        ss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_scrollbar_policy","title":"<code>set_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr)</code>","text":"<p>Set the policy for both scrollbars.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ScrollBarPolicyStr</code> <p>visibilty to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid scrollbar policy</p> Source code in <code>prettyqt/widgets/abstractscrollarea.py</code> <pre><code>def set_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the policy for both scrollbars.\n\n    Args:\n        mode: visibilty to set\n\n    Raises:\n        InvalidParamError: invalid scrollbar policy\n    \"\"\"\n    if mode not in constants.SCROLLBAR_POLICY:\n        raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n    self.setHorizontalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n    self.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_scrollbar_width","title":"<code>set_scrollbar_width(self, width: int)</code>","text":"<p>Set the width for both scrollbars.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>width in pixels</p> required Source code in <code>prettyqt/widgets/abstractscrollarea.py</code> <pre><code>def set_scrollbar_width(self, width: int):\n\"\"\"Set the width for both scrollbars.\n\n    Args:\n        width: width in pixels\n    \"\"\"\n    self.set_horizontal_scrollbar_width(width)\n    self.set_vertical_scrollbar_width(width)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_size_adjust_policy","title":"<code>set_size_adjust_policy(self, policy: SizePolicyStr)</code>","text":"<p>Set size adjust policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizePolicyStr</code> <p>size adjust policy to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid size adjust policy</p> Source code in <code>prettyqt/widgets/abstractscrollarea.py</code> <pre><code>def set_size_adjust_policy(self, policy: SizePolicyStr):\n\"\"\"Set size adjust policy.\n\n    Args:\n        policy: size adjust policy to use\n\n    Raises:\n        InvalidParamError: invalid size adjust policy\n    \"\"\"\n    if policy not in SIZE_POLICY:\n        raise InvalidParamError(policy, SIZE_POLICY)\n    self.setSizeAdjustPolicy(SIZE_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_vertical_scrollbar_policy","title":"<code>set_vertical_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr)</code>","text":"<p>Set the vertical scrollbar visibility.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ScrollBarPolicyStr</code> <p>visibilty to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid scrollbar policy</p> Source code in <code>prettyqt/widgets/abstractscrollarea.py</code> <pre><code>def set_vertical_scrollbar_policy(self, mode: constants.ScrollBarPolicyStr):\n\"\"\"Set the vertical scrollbar visibility.\n\n    Args:\n        mode: visibilty to set\n\n    Raises:\n        InvalidParamError: invalid scrollbar policy\n    \"\"\"\n    if mode not in constants.SCROLLBAR_POLICY:\n        raise InvalidParamError(mode, constants.SCROLLBAR_POLICY)\n    self.setVerticalScrollBarPolicy(constants.SCROLLBAR_POLICY[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollAreaMixin.set_vertical_scrollbar_width","title":"<code>set_vertical_scrollbar_width(self, width: int)</code>","text":"<p>Set the vertical scrollbar width.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>width in pixels</p> required Source code in <code>prettyqt/widgets/abstractscrollarea.py</code> <pre><code>def set_vertical_scrollbar_width(self, width: int):\n\"\"\"Set the vertical scrollbar width.\n\n    Args:\n        width: width in pixels\n    \"\"\"\n    with self.v_scrollbar.edit_stylesheet() as ss:\n        ss.QScrollBar.horizontal.height.setValue(f\"{width}px\")\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider","title":"<code>abstractslider</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin","title":"<code> AbstractSliderMixin            (WidgetMixin)         </code>","text":"Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>class AbstractSliderMixin(widgets.WidgetMixin):\n    value_changed = core.Signal(int)\n\n    def on_value_change(self):\n        self.value_changed.emit(self.value())\n\n    def serialize_fields(self):\n        return dict(\n            range=(self.minimum(), self.maximum()),\n            value=self.value(),\n            has_tracking=self.hasTracking(),\n            inverted_controls=self.invertedControls(),\n            inverted_appearance=self.invertedAppearance(),\n            single_step=self.singleStep(),\n            page_step=self.pageStep(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_range(*state[\"range\"])\n        self.set_value(state[\"value\"])\n        self.setSingleStep(state[\"single_step\"])\n        self.setPageStep(state[\"page_step\"])\n        self.setTracking(state[\"has_tracking\"])\n        self.setInvertedControls(state[\"inverted_controls\"])\n        self.setInvertedAppearance(state[\"inverted_appearance\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n\n        Returns:\n            True if horizontal, else False\n        \"\"\"\n        return self.orientation() == constants.HORIZONTAL\n\n    def is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n\n        Returns:\n            True if vertical, else False\n        \"\"\"\n        return self.orientation() == constants.VERTICAL\n\n    def set_horizontal(self):\n\"\"\"Set slider orientation to horizontal.\"\"\"\n        self.setOrientation(constants.HORIZONTAL)\n\n    def set_vertical(self):\n\"\"\"Set slider orientation to vertical.\"\"\"\n        self.setOrientation(constants.VERTICAL)\n\n    def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the slider.\n\n        Args:\n            orientation: orientation for the slider\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in constants.ORIENTATION:\n            raise InvalidParamError(orientation, constants.ORIENTATION)\n        self.setOrientation(constants.ORIENTATION[orientation])\n\n    def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return constants.ORIENTATION.inverse[self.orientation()]\n\n    def scroll_to_min(self):\n\"\"\"Scroll to the minimum value of the slider.\"\"\"\n        self.setValue(self.minimum())\n\n    def scroll_to_max(self):\n\"\"\"Scroll to the maximum value of the slider.\"\"\"\n        self.setValue(self.maximum())\n\n    def set_range(self, min_val: int, max_val: int):\n        self.setRange(min_val, max_val)\n\n    def set_step_size(self, step_size: int):\n        self.setSingleStep(step_size)\n\n    def set_repeat_action(\n        self, action: SliderActionStr, threshold: int = 500, repeat_time: int = 50\n    ):\n\"\"\"Set the repeat action.\n\n        Args:\n            action: repeat action\n            threshold: initial delay in ms\n            repeat_time: repeat time in ms\n\n        Raises:\n            InvalidParamError: invalid repeat action\n        \"\"\"\n        if action not in SLIDER_ACTION:\n            raise InvalidParamError(action, SLIDER_ACTION)\n        self.setRepeatAction(SLIDER_ACTION[action], threshold, repeat_time)\n\n    def get_repeat_action(self) -&gt; SliderActionStr:\n\"\"\"Get current repeat action.\n\n        Returns:\n            current repeat action\n        \"\"\"\n        return SLIDER_ACTION.inverse[self.repeatAction()]\n\n    def trigger_action(self, action: SliderActionStr):\n\"\"\"Trigger slider action.\"\"\"\n        if action not in SLIDER_ACTION:\n            raise InvalidParamError(action, SLIDER_ACTION)\n        self.triggerAction(SLIDER_ACTION[action])\n\n    def get_value(self):\n        return self.value()\n\n    def set_value(self, value: int):\n        self.setValue(value)\n\n    def on_scrollbar_range_changed(self, minval, maxval):\n        if self.value() &gt;= self.maximum() - 1:\n            self.setValue(maxval)\n\n    def set_auto_scroll_to_end(self, scroll: bool = True):\n\"\"\"Set to always scroll to the end when range changes.\"\"\"\n        if scroll:\n            self.rangeChanged.connect(self.on_scrollbar_range_changed)\n        else:\n            self.rangeChanged.disconnect(self.on_scrollbar_range_changed)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.get_orientation","title":"<code>get_orientation(self) -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.get_repeat_action","title":"<code>get_repeat_action(self) -&gt; SliderActionStr</code>","text":"<p>Get current repeat action.</p> <p>Returns:</p> Type Description <code>SliderActionStr</code> <p>current repeat action</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def get_repeat_action(self) -&gt; SliderActionStr:\n\"\"\"Get current repeat action.\n\n    Returns:\n        current repeat action\n    \"\"\"\n    return SLIDER_ACTION.inverse[self.repeatAction()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.is_horizontal","title":"<code>is_horizontal(self) -&gt; bool</code>","text":"<p>Check if silder is horizontal.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if horizontal, else False</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n\n    Returns:\n        True if horizontal, else False\n    \"\"\"\n    return self.orientation() == constants.HORIZONTAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.is_vertical","title":"<code>is_vertical(self) -&gt; bool</code>","text":"<p>Check if silder is vertical.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if vertical, else False</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n\n    Returns:\n        True if vertical, else False\n    \"\"\"\n    return self.orientation() == constants.VERTICAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.scroll_to_max","title":"<code>scroll_to_max(self)</code>","text":"<p>Scroll to the maximum value of the slider.</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def scroll_to_max(self):\n\"\"\"Scroll to the maximum value of the slider.\"\"\"\n    self.setValue(self.maximum())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.scroll_to_min","title":"<code>scroll_to_min(self)</code>","text":"<p>Scroll to the minimum value of the slider.</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def scroll_to_min(self):\n\"\"\"Scroll to the minimum value of the slider.\"\"\"\n    self.setValue(self.minimum())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_auto_scroll_to_end","title":"<code>set_auto_scroll_to_end(self, scroll: bool = True)</code>","text":"<p>Set to always scroll to the end when range changes.</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def set_auto_scroll_to_end(self, scroll: bool = True):\n\"\"\"Set to always scroll to the end when range changes.\"\"\"\n    if scroll:\n        self.rangeChanged.connect(self.on_scrollbar_range_changed)\n    else:\n        self.rangeChanged.disconnect(self.on_scrollbar_range_changed)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_horizontal","title":"<code>set_horizontal(self)</code>","text":"<p>Set slider orientation to horizontal.</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def set_horizontal(self):\n\"\"\"Set slider orientation to horizontal.\"\"\"\n    self.setOrientation(constants.HORIZONTAL)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_orientation","title":"<code>set_orientation(self, orientation: constants.OrientationStr)</code>","text":"<p>Set the orientation of the slider.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr</code> <p>orientation for the slider</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the slider.\n\n    Args:\n        orientation: orientation for the slider\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in constants.ORIENTATION:\n        raise InvalidParamError(orientation, constants.ORIENTATION)\n    self.setOrientation(constants.ORIENTATION[orientation])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_repeat_action","title":"<code>set_repeat_action(self, action: SliderActionStr, threshold: int = 500, repeat_time: int = 50)</code>","text":"<p>Set the repeat action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>SliderActionStr</code> <p>repeat action</p> required <code>threshold</code> <code>int</code> <p>initial delay in ms</p> <code>500</code> <code>repeat_time</code> <code>int</code> <p>repeat time in ms</p> <code>50</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid repeat action</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def set_repeat_action(\n    self, action: SliderActionStr, threshold: int = 500, repeat_time: int = 50\n):\n\"\"\"Set the repeat action.\n\n    Args:\n        action: repeat action\n        threshold: initial delay in ms\n        repeat_time: repeat time in ms\n\n    Raises:\n        InvalidParamError: invalid repeat action\n    \"\"\"\n    if action not in SLIDER_ACTION:\n        raise InvalidParamError(action, SLIDER_ACTION)\n    self.setRepeatAction(SLIDER_ACTION[action], threshold, repeat_time)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.set_vertical","title":"<code>set_vertical(self)</code>","text":"<p>Set slider orientation to vertical.</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def set_vertical(self):\n\"\"\"Set slider orientation to vertical.\"\"\"\n    self.setOrientation(constants.VERTICAL)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSliderMixin.trigger_action","title":"<code>trigger_action(self, action: SliderActionStr)</code>","text":"<p>Trigger slider action.</p> Source code in <code>prettyqt/widgets/abstractslider.py</code> <pre><code>def trigger_action(self, action: SliderActionStr):\n\"\"\"Trigger slider action.\"\"\"\n    if action not in SLIDER_ACTION:\n        raise InvalidParamError(action, SLIDER_ACTION)\n    self.triggerAction(SLIDER_ACTION[action])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox","title":"<code>abstractspinbox</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin","title":"<code> AbstractSpinBoxMixin            (WidgetMixin)         </code>","text":"Source code in <code>prettyqt/widgets/abstractspinbox.py</code> <pre><code>class AbstractSpinBoxMixin(widgets.WidgetMixin):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.setLineEdit(widgets.LineEdit())\n        self.setGroupSeparatorShown(True)\n\n    def serialize_fields(self):\n        return dict(\n            button_symbols=self.get_button_symbols(),\n            correction_mode=self.get_correction_mode(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_correction_mode(state[\"correction_mode\"])\n        self.set_button_symbols(state[\"button_symbols\"])\n\n    def is_valid(self) -&gt; bool:\n        return self.hasAcceptableInput()\n\n    def set_validator(self, validator: gui.Validator):\n        self.lineEdit().setValidator(validator)\n\n    def get_button_symbols(self) -&gt; SymbolStr:\n\"\"\"Return button symbol type.\n\n        Returns:\n            button symbol type\n        \"\"\"\n        return SYMBOLS.inverse[self.buttonSymbols()]\n\n    def set_button_symbols(self, mode: SymbolStr):\n\"\"\"Set button symbol type.\n\n        Args:\n            mode: button symbol type to use\n\n        Raises:\n            InvalidParamError: invalid button symbol type\n        \"\"\"\n        if mode not in SYMBOLS:\n            raise InvalidParamError(mode, SYMBOLS)\n        self.setButtonSymbols(SYMBOLS[mode])\n\n    def set_correction_mode(self, mode: CorrectionModeStr):\n\"\"\"Set correction mode.\n\n        Args:\n            mode: correction mode to use\n\n        Raises:\n            InvalidParamError: invalid correction mode\n        \"\"\"\n        if mode not in CORRECTION_MODES:\n            raise InvalidParamError(mode, CORRECTION_MODES)\n        self.setCorrectionMode(CORRECTION_MODES[mode])\n\n    def get_correction_mode(self) -&gt; CorrectionModeStr:\n\"\"\"Return correction mode.\n\n        Returns:\n            correction mode\n        \"\"\"\n        return CORRECTION_MODES.inverse[self.correctionMode()]\n\n    def set_step_type(self, mode: StepTypeStr):\n\"\"\"Set step type.\n\n        Args:\n            mode: step type to use\n\n        Raises:\n            InvalidParamError: invalid step type\n        \"\"\"\n        if mode not in STEP_TYPES:\n            raise InvalidParamError(mode, STEP_TYPES)\n        self.setStepType(STEP_TYPES[mode])\n\n    def get_step_type(self) -&gt; StepTypeStr:\n\"\"\"Return step type.\n\n        Returns:\n            step type\n        \"\"\"\n        return STEP_TYPES.inverse[self.stepType()]\n\n    def set_special_value(self, value: str):\n        self.setSpecialValueText(value)\n\n    def get_value(self) -&gt; int:\n        return self.value()\n\n    def set_value(self, value: int):\n        self.setValue(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.get_button_symbols","title":"<code>get_button_symbols(self) -&gt; SymbolStr</code>","text":"<p>Return button symbol type.</p> <p>Returns:</p> Type Description <code>SymbolStr</code> <p>button symbol type</p> Source code in <code>prettyqt/widgets/abstractspinbox.py</code> <pre><code>def get_button_symbols(self) -&gt; SymbolStr:\n\"\"\"Return button symbol type.\n\n    Returns:\n        button symbol type\n    \"\"\"\n    return SYMBOLS.inverse[self.buttonSymbols()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.get_correction_mode","title":"<code>get_correction_mode(self) -&gt; CorrectionModeStr</code>","text":"<p>Return correction mode.</p> <p>Returns:</p> Type Description <code>CorrectionModeStr</code> <p>correction mode</p> Source code in <code>prettyqt/widgets/abstractspinbox.py</code> <pre><code>def get_correction_mode(self) -&gt; CorrectionModeStr:\n\"\"\"Return correction mode.\n\n    Returns:\n        correction mode\n    \"\"\"\n    return CORRECTION_MODES.inverse[self.correctionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.get_step_type","title":"<code>get_step_type(self) -&gt; StepTypeStr</code>","text":"<p>Return step type.</p> <p>Returns:</p> Type Description <code>StepTypeStr</code> <p>step type</p> Source code in <code>prettyqt/widgets/abstractspinbox.py</code> <pre><code>def get_step_type(self) -&gt; StepTypeStr:\n\"\"\"Return step type.\n\n    Returns:\n        step type\n    \"\"\"\n    return STEP_TYPES.inverse[self.stepType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.set_button_symbols","title":"<code>set_button_symbols(self, mode: SymbolStr)</code>","text":"<p>Set button symbol type.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SymbolStr</code> <p>button symbol type to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid button symbol type</p> Source code in <code>prettyqt/widgets/abstractspinbox.py</code> <pre><code>def set_button_symbols(self, mode: SymbolStr):\n\"\"\"Set button symbol type.\n\n    Args:\n        mode: button symbol type to use\n\n    Raises:\n        InvalidParamError: invalid button symbol type\n    \"\"\"\n    if mode not in SYMBOLS:\n        raise InvalidParamError(mode, SYMBOLS)\n    self.setButtonSymbols(SYMBOLS[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.set_correction_mode","title":"<code>set_correction_mode(self, mode: CorrectionModeStr)</code>","text":"<p>Set correction mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CorrectionModeStr</code> <p>correction mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid correction mode</p> Source code in <code>prettyqt/widgets/abstractspinbox.py</code> <pre><code>def set_correction_mode(self, mode: CorrectionModeStr):\n\"\"\"Set correction mode.\n\n    Args:\n        mode: correction mode to use\n\n    Raises:\n        InvalidParamError: invalid correction mode\n    \"\"\"\n    if mode not in CORRECTION_MODES:\n        raise InvalidParamError(mode, CORRECTION_MODES)\n    self.setCorrectionMode(CORRECTION_MODES[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBoxMixin.set_step_type","title":"<code>set_step_type(self, mode: StepTypeStr)</code>","text":"<p>Set step type.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>StepTypeStr</code> <p>step type to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid step type</p> Source code in <code>prettyqt/widgets/abstractspinbox.py</code> <pre><code>def set_step_type(self, mode: StepTypeStr):\n\"\"\"Set step type.\n\n    Args:\n        mode: step type to use\n\n    Raises:\n        InvalidParamError: invalid step type\n    \"\"\"\n    if mode not in STEP_TYPES:\n        raise InvalidParamError(mode, STEP_TYPES)\n    self.setStepType(STEP_TYPES[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action","title":"<code>action</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin","title":"<code> ActionMixin            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/widgets/action.py</code> <pre><code>class ActionMixin(core.ObjectMixin):\n    def __init__(\n        self,\n        parent: QtCore.QObject | None = None,\n        text: str = \"\",\n        icon: datatypes.IconType = None,\n        shortcut: str | None = None,\n        tooltip: str = \"\",\n        checkable: bool = False,\n        checked: bool = False,\n        statustip: str = \"\",\n        enabled: bool = True,\n        callback: Callable | None = None,\n    ):\n        super().__init__(parent)\n        self._menu = None\n        self.set_text(text)\n        self.set_icon(icon)\n        self.set_shortcut(shortcut)\n        self.set_tooltip(tooltip)\n        self.set_checkable(checkable)\n        self.set_checked(checked)\n        self.set_statustip(statustip)\n        self.set_enabled(enabled)\n        if callback is not None:\n            self.triggered.connect(callback)\n\n    def __repr__(self) -&gt; str:\n        cls_name = type(self).__name__\n        return f\"{cls_name}({helpers.format_kwargs(self.serialize_fields())})\"\n\n    def serialize_fields(self):\n        dct = dict(\n            auto_repeat=self.autoRepeat(),\n            text=self.text(),\n            enabled=self.isEnabled(),\n            visible=self.isVisible(),\n            font=self.get_font(),\n            shortcut=self.get_shortcut(),\n            tool_tip=self.toolTip(),\n            checkable=self.isCheckable(),\n            checked=self.isChecked(),\n            icon=self.get_icon(),\n            icon_text=self.iconText(),\n            priority=self.get_priority(),\n            icon_visible_in_menu=self.isIconVisibleInMenu(),\n            shortcut_visible_in_context_menu=self.isShortcutVisibleInContextMenu(),\n            menu_role=self.get_menu_role(),\n            shortcut_context=self.get_shortcut_context(),\n            status_tip=self.statusTip(),\n            whats_this=self.whatsThis(),\n        )\n        return dct\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_text(state.get(\"text\", \"\"))\n        self.set_enabled(state.get(\"enabled\", True))\n        self.set_shortcut(state[\"shortcut\"])\n        self.set_tooltip(state.get(\"tool_tip\", \"\"))\n        self.set_statustip(state.get(\"status_tip\", \"\"))\n        self.set_checked(state.get(\"checked\", False))\n        self.set_priority(state[\"priority\"])\n        self.set_shortcut_context(state[\"shortcut_context\"])\n        self.set_checkable(state[\"checkable\"])\n        self.setAutoRepeat(state[\"auto_repeat\"])\n        self.setVisible(state[\"visible\"])\n        self.setFont(state[\"font\"])\n        # self.setIcon(state[\"icon\"])\n        self.setIconText(state[\"icon_text\"])\n        self.setIconVisibleInMenu(state[\"icon_visible_in_menu\"])\n        self.setShortcutVisibleInContextMenu(state[\"shortcut_visible_in_context_menu\"])\n        self.set_menu_role(state[\"menu_role\"])\n        self.setWhatsThis(state[\"whats_this\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def set_text(self, text: str):\n        self.setText(text)\n\n    def set_enabled(self, enabled: bool = True):\n        self.setEnabled(enabled)\n\n    def set_disabled(self):\n        self.setEnabled(False)\n\n    def set_tooltip(\n        self,\n        tooltip: str | datatypes.PathType,\n        size: datatypes.SizeType | None = None,\n    ):\n        if isinstance(tooltip, os.PathLike):\n            path = os.fspath(tooltip)\n            if size is None:\n                tooltip = f\"&lt;img src={path!r}&gt;\"\n            else:\n                if isinstance(size, QtCore.QSize):\n                    size = (size.width(), size.height())\n                tooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\n        self.setToolTip(tooltip)\n\n    def set_statustip(self, text: str):\n        self.setStatusTip(text)\n\n    def set_checked(self, value: bool):\n        self.setChecked(value)\n\n    def set_checkable(self, value: bool):\n        self.setCheckable(value)\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        if icon.isNull():\n            return None\n        return gui.Icon(icon)\n\n    def set_shortcut(self, shortcut: None | QtGui.QKeySequence | str):\n        if shortcut is None:\n            shortcut = \"\"\n        if isinstance(shortcut, str):\n            shortcut = gui.KeySequence(\n                shortcut, gui.KeySequence.SequenceFormat.PortableText\n            )\n        self.setShortcut(shortcut)\n\n    def get_shortcut(self) -&gt; gui.KeySequence | None:\n        shortcut = self.shortcut()\n        if not shortcut:\n            return None\n        return gui.KeySequence(\n            shortcut.toString(), gui.KeySequence.SequenceFormat.PortableText\n        )\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def set_menu(self, menu):\n        try:\n            self.setMenu(menu)\n        except AttributeError:\n            self.triggered.connect(menu.exec_)\n            self._menu = menu\n\n    def menu(self):\n        return self._menu\n\n    def set_priority(self, priority: PriorityStr):\n\"\"\"Set priority of the action.\n\n        Args:\n            priority: priority for the action\n\n        Raises:\n            InvalidParamError: priority does not exist\n        \"\"\"\n        if priority not in PRIORITIES:\n            raise InvalidParamError(priority, PRIORITIES)\n        self.setPriority(PRIORITIES[priority])\n\n    def get_priority(self) -&gt; PriorityStr:\n\"\"\"Return current priority.\n\n        Returns:\n            priority\n        \"\"\"\n        return PRIORITIES.inverse[self.priority()]\n\n    def set_shortcut_context(self, context: constants.ContextStr):\n\"\"\"Set shortcut context.\n\n        Args:\n            context: shortcut context\n\n        Raises:\n            InvalidParamError: shortcut context does not exist\n        \"\"\"\n        if context not in constants.CONTEXT:\n            raise InvalidParamError(context, constants.CONTEXT)\n        self.setShortcutContext(constants.CONTEXT[context])\n\n    def get_shortcut_context(self) -&gt; constants.ContextStr:\n\"\"\"Return shortcut context.\n\n        Returns:\n            shortcut context\n        \"\"\"\n        return constants.CONTEXT.inverse[self.shortcutContext()]\n\n    def set_menu_role(self, role: RoleStr):\n\"\"\"Set menu role.\n\n        Args:\n            role: menu role\n\n        Raises:\n            InvalidParamError: menu role does not exist\n        \"\"\"\n        if role not in ROLES:\n            raise InvalidParamError(role, ROLES)\n        self.setMenuRole(ROLES[role])\n\n    def get_menu_role(self) -&gt; RoleStr:\n\"\"\"Return menu role.\n\n        Returns:\n            menu role\n        \"\"\"\n        return ROLES.inverse[self.menuRole()]\n\n    def show_shortcut_in_contextmenu(self, state: bool = True):\n        self.setShortcutVisibleInContextMenu(state)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.get_menu_role","title":"<code>get_menu_role(self) -&gt; RoleStr</code>","text":"<p>Return menu role.</p> <p>Returns:</p> Type Description <code>RoleStr</code> <p>menu role</p> Source code in <code>prettyqt/widgets/action.py</code> <pre><code>def get_menu_role(self) -&gt; RoleStr:\n\"\"\"Return menu role.\n\n    Returns:\n        menu role\n    \"\"\"\n    return ROLES.inverse[self.menuRole()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.get_priority","title":"<code>get_priority(self) -&gt; PriorityStr</code>","text":"<p>Return current priority.</p> <p>Returns:</p> Type Description <code>PriorityStr</code> <p>priority</p> Source code in <code>prettyqt/widgets/action.py</code> <pre><code>def get_priority(self) -&gt; PriorityStr:\n\"\"\"Return current priority.\n\n    Returns:\n        priority\n    \"\"\"\n    return PRIORITIES.inverse[self.priority()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.get_shortcut_context","title":"<code>get_shortcut_context(self) -&gt; constants.ContextStr</code>","text":"<p>Return shortcut context.</p> <p>Returns:</p> Type Description <code>constants.ContextStr</code> <p>shortcut context</p> Source code in <code>prettyqt/widgets/action.py</code> <pre><code>def get_shortcut_context(self) -&gt; constants.ContextStr:\n\"\"\"Return shortcut context.\n\n    Returns:\n        shortcut context\n    \"\"\"\n    return constants.CONTEXT.inverse[self.shortcutContext()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.set_icon","title":"<code>set_icon(self, icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt/widgets/action.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.set_menu_role","title":"<code>set_menu_role(self, role: RoleStr)</code>","text":"<p>Set menu role.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>RoleStr</code> <p>menu role</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>menu role does not exist</p> Source code in <code>prettyqt/widgets/action.py</code> <pre><code>def set_menu_role(self, role: RoleStr):\n\"\"\"Set menu role.\n\n    Args:\n        role: menu role\n\n    Raises:\n        InvalidParamError: menu role does not exist\n    \"\"\"\n    if role not in ROLES:\n        raise InvalidParamError(role, ROLES)\n    self.setMenuRole(ROLES[role])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.set_priority","title":"<code>set_priority(self, priority: PriorityStr)</code>","text":"<p>Set priority of the action.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>PriorityStr</code> <p>priority for the action</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>priority does not exist</p> Source code in <code>prettyqt/widgets/action.py</code> <pre><code>def set_priority(self, priority: PriorityStr):\n\"\"\"Set priority of the action.\n\n    Args:\n        priority: priority for the action\n\n    Raises:\n        InvalidParamError: priority does not exist\n    \"\"\"\n    if priority not in PRIORITIES:\n        raise InvalidParamError(priority, PRIORITIES)\n    self.setPriority(PRIORITIES[priority])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.action.ActionMixin.set_shortcut_context","title":"<code>set_shortcut_context(self, context: constants.ContextStr)</code>","text":"<p>Set shortcut context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>constants.ContextStr</code> <p>shortcut context</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>shortcut context does not exist</p> Source code in <code>prettyqt/widgets/action.py</code> <pre><code>def set_shortcut_context(self, context: constants.ContextStr):\n\"\"\"Set shortcut context.\n\n    Args:\n        context: shortcut context\n\n    Raises:\n        InvalidParamError: shortcut context does not exist\n    \"\"\"\n    if context not in constants.CONTEXT:\n        raise InvalidParamError(context, constants.CONTEXT)\n    self.setShortcutContext(constants.CONTEXT[context])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup","title":"<code>actiongroup</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup","title":"<code> ActionGroup            (ObjectMixin, QActionGroup)         </code>","text":"Source code in <code>prettyqt/widgets/actiongroup.py</code> <pre><code>class ActionGroup(core.ObjectMixin, QtWidgets.QActionGroup):\n    def __init__(self, parent: QtCore.QObject | None = None):\n        super().__init__(parent)  # type: ignore\n\n    def __len__(self) -&gt; int:\n        return len(self.actions())\n\n    def __getitem__(self, item: int) -&gt; QtWidgets.QAction:\n        return self.actions()[item]\n\n    def serialize_fields(self):\n        return dict(\n            exclusion_policy=self.get_exclusion_policy(),\n            visible=self.isVisible(),\n            enabled=self.isEnabled(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.setEnabled(state.get(\"enabled\", \"\"))\n        self.setVisible(state.get(\"visible\", \"\"))\n        self.set_exclusion_policy(state.get(\"exclusion_policy\", \"\"))\n\n    def set_exclusion_policy(self, policy: ExclusionPolicyStr | None):\n\"\"\"Set exclusion policy to use.\n\n        Args:\n            policy: exclusion policy to use\n\n        Raises:\n            InvalidParamError: exclusion policy does not exist\n        \"\"\"\n        if policy is None:\n            policy = \"none\"\n        if policy not in POLICIES:\n            raise InvalidParamError(policy, POLICIES)\n        self.setExclusionPolicy(POLICIES[policy])\n\n    def get_exclusion_policy(self) -&gt; ExclusionPolicyStr:\n\"\"\"Return current exclusion policy.\n\n        Returns:\n            exclusion policy\n        \"\"\"\n        return POLICIES.inverse[self.exclusionPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.get_exclusion_policy","title":"<code>get_exclusion_policy(self) -&gt; ExclusionPolicyStr</code>","text":"<p>Return current exclusion policy.</p> <p>Returns:</p> Type Description <code>ExclusionPolicyStr</code> <p>exclusion policy</p> Source code in <code>prettyqt/widgets/actiongroup.py</code> <pre><code>def get_exclusion_policy(self) -&gt; ExclusionPolicyStr:\n\"\"\"Return current exclusion policy.\n\n    Returns:\n        exclusion policy\n    \"\"\"\n    return POLICIES.inverse[self.exclusionPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.set_exclusion_policy","title":"<code>set_exclusion_policy(self, policy: ExclusionPolicyStr | None)</code>","text":"<p>Set exclusion policy to use.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>ExclusionPolicyStr | None</code> <p>exclusion policy to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>exclusion policy does not exist</p> Source code in <code>prettyqt/widgets/actiongroup.py</code> <pre><code>def set_exclusion_policy(self, policy: ExclusionPolicyStr | None):\n\"\"\"Set exclusion policy to use.\n\n    Args:\n        policy: exclusion policy to use\n\n    Raises:\n        InvalidParamError: exclusion policy does not exist\n    \"\"\"\n    if policy is None:\n        policy = \"none\"\n    if policy not in POLICIES:\n        raise InvalidParamError(policy, POLICIES)\n    self.setExclusionPolicy(POLICIES[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.application","title":"<code>application</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.application.ApplicationMixin","title":"<code> ApplicationMixin            (GuiApplicationMixin)         </code>","text":"Source code in <code>prettyqt/widgets/application.py</code> <pre><code>class ApplicationMixin(gui.GuiApplicationMixin):\n    def __class_getitem__(cls, name: str) -&gt; QtWidgets.QWidget:\n        widget = cls.get_widget(name)\n        if widget is None:\n            raise ValueError(f\"Widget {name!r} does not exist.\")\n        return widget\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QWidget]:\n        return iter(self.topLevelWidgets())\n\n    def serialize_fields(self):\n        return dict(\n            auto_sip_enabled=self.autoSipEnabled(),\n            cursor_flash_time=self.cursorFlashTime(),\n            double_click_interval=self.doubleClickInterval(),\n            keyboard_input_interval=self.keyboardInputInterval(),\n            start_drag_distance=self.startDragDistance(),\n            start_drag_time=self.startDragTime(),\n            style_sheet=self.styleSheet(),\n            wheel_scroll_lines=self.wheelScrollLines(),\n        )\n\n    def store_widget_states(\n        self, settings: MutableMapping | None = None, key: str = \"states\"\n    ):\n        settings = core.Settings() if settings is None else settings\n        result = {}\n        for k, v in SAVE_STATES.items():\n            result[k] = {\n                i.objectName(): i.saveState()\n                for i in self.find_children(v)\n                if i.objectName()\n            }\n        settings[key] = result\n\n    def restore_widget_states(self, settings: Mapping | None = None, key: str = \"states\"):\n        settings = core.Settings() if settings is None else settings\n        for category, v in SAVE_STATES.items():\n            items = settings[key].get(category)\n            if items is None:\n                continue\n            for name, state in items.items():\n                w = self.find_child(v, name=name)\n                if w is not None:\n                    if isinstance(state, str):\n                        state = state.encode()\n                    w.restoreState(state)\n\n    def about_popup(self, title: str = \"About\"):\n        text = (\n            f\"{self.applicationName()}\\n\\n\"\n            f\"{self.organizationName()}\\n\"\n            f\"{self.applicationVersion()}\\n\"\n            f\"{self.organizationDomain()}\"\n        )\n        popup = widgets.MessageBox(\n            \"none\",\n            title,\n            text,\n            buttons=[\"ok\"],\n        )\n        popup.set_icon(\"mdi.information-outline\")\n        popup.exec_()\n\n    @classmethod\n    def get_mainwindow(cls) -&gt; QtWidgets.QMainWindow | None:\n        inst = cls.instance()\n        if inst is None:\n            return None\n        widget_list = inst.topLevelWidgets()\n        for widget in widget_list:\n            if isinstance(widget, QtWidgets.QMainWindow):\n                return widget\n        return None\n\n    @classmethod\n    def get_widget(cls, name: str) -&gt; QtWidgets.QWidget | None:\n        mw = cls.get_mainwindow()\n        if mw is None:\n            logger.warning(\"Trying to get widget from nonexistent mainwindow\")\n            return None\n        return mw.findChild(QtWidgets.QWidget, name)  # type: ignore\n        # widget_list = cls.instance().allWidgets()\n        # for widget in widget_list:\n        #     if isinstance(widget, QtWidgets.QWidget) and widget.objectName() == name:\n        #         return widget\n        # return None\n\n    @contextlib.contextmanager\n    def edit_stylesheet(self) -&gt; Iterator[qstylizer.style.StyleSheet]:\n        ss = self.get_stylesheet()\n        yield ss\n        self.set_stylesheet(ss)\n\n    def set_stylesheet(\n        self, ss: None | str | qstylizer.style.StyleSheet | datatypes.PathType\n    ):\n        if isinstance(ss, os.PathLike):\n            ss = pathlib.Path(ss).read_text()\n        elif ss is None:\n            ss = \"\"\n        self.setStyleSheet(str(ss))\n\n    def set_style(self, style: str):\n        self.setStyle(QtWidgets.QStyleFactory.create(style))\n        icon_color = self.get_palette().get_color(\"highlighted_text\")\n        iconprovider.set_defaults(color=icon_color)\n\n    def get_stylesheet(self) -&gt; qstylizer.style.StyleSheet:\n        return qstylizer.parser.parse(self.styleSheet())\n\n    def set_theme(self, theme: constants.ThemeStr):\n        self.set_palette(theme)\n        match theme:\n            case \"default\":\n                self.set_stylesheet(\"\")\n                color = self.get_palette().get_color(\"highlighted_text\")\n            case \"dark\":\n                ss = (paths.THEMES_PATH / \"darktheme.qss\").read_text()\n                self.set_stylesheet(ss)\n                color = gui.Color(\"lightblue\")\n        iconprovider.set_defaults(color=color)\n\n    @classmethod\n    def get_available_themes(cls) -&gt; dict[constants.ThemeStr, str]:\n        return dict(default=\"Default\", dark=\"Dark\")\n\n    def send_event(self, obj_or_str: str | QtCore.QObject, event: QtCore.QEvent):\n        obj = self.get_widget(obj_or_str) if isinstance(obj_or_str, str) else obj_or_str\n        if obj is None:\n            raise ValueError(obj)\n        return self.sendEvent(obj, event)\n\n    def post_event(\n        self,\n        obj_or_str: str | QtCore.QObject,\n        event: QtCore.QEvent,\n        priority: int | constants.EventPriorityStr = \"normal\",\n    ):\n        obj = self.get_widget(obj_or_str) if isinstance(obj_or_str, str) else obj_or_str\n        if obj is None:\n            raise ValueError(obj)\n        super().post_event(obj, event, priority)\n\n    @classmethod\n    def get_style_icon(cls, icon: widgets.style.StandardPixmapStr) -&gt; gui.Icon:\n        style = cls.style()\n        # icon_size = style.pixelMetric(QtWidgets.QStyle.PM_MessageBoxIconSize)\n        if icon not in widgets.style.STANDARD_PIXMAP:\n            raise InvalidParamError(icon, widgets.style.STANDARD_PIXMAP)\n        icon = style.standardIcon(widgets.style.STANDARD_PIXMAP[icon])\n        return gui.Icon(icon)\n\n    def set_effect_enabled(self, effect: constants.UiEffectStr, enabled: bool = True):\n\"\"\"Set the enabled state of a desktop effect.\n\n        Args:\n            effect: desktop effect to set\n            enabled: new state\n\n        Raises:\n            InvalidParamError: invalid desktop effect\n        \"\"\"\n        if effect not in constants.UI_EFFECTS:\n            raise InvalidParamError(effect, constants.UI_EFFECTS)\n        self.setEffectEnabled(constants.UI_EFFECTS[effect])\n\n    def is_effect_enabled(self, effect: constants.UiEffectStr) -&gt; bool:\n\"\"\"Return desktop effect state.\n\n        Returns:\n            desktop effect state\n        \"\"\"\n        return self.isEffectEnabled(constants.UI_EFFECTS[effect])\n\n    def set_navigation_mode(self, mode: constants.NavigationModeStr):\n\"\"\"Set the navigation mode.\n\n        Args:\n            mode: navigation mode to use\n\n        Raises:\n            InvalidParamError: invalid navigation mode\n        \"\"\"\n        if mode not in constants.NAVIGATION_MODES:\n            raise InvalidParamError(mode, constants.NAVIGATION_MODES)\n        self.setNavigationMode(constants.NAVIGATION_MODES[mode])\n\n    def get_navigation_mode(self) -&gt; constants.NavigationModeStr:\n\"\"\"Return navigation mode.\n\n        Returns:\n            navigation mode\n        \"\"\"\n        return constants.NAVIGATION_MODES.inverse[self.navigationMode()]\n\n    @classmethod\n    def sleep(cls, secs: float):\n\"\"\"Pause application (non-blocking).\n\n        Args:\n            secs: seconds to sleep\n        \"\"\"\n        start = timeit.default_timer()\n        while True:\n            cls.processEvents()\n            if timeit.default_timer() - start &gt; secs:\n                return\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.application.ApplicationMixin.get_navigation_mode","title":"<code>get_navigation_mode(self) -&gt; constants.NavigationModeStr</code>","text":"<p>Return navigation mode.</p> <p>Returns:</p> Type Description <code>constants.NavigationModeStr</code> <p>navigation mode</p> Source code in <code>prettyqt/widgets/application.py</code> <pre><code>def get_navigation_mode(self) -&gt; constants.NavigationModeStr:\n\"\"\"Return navigation mode.\n\n    Returns:\n        navigation mode\n    \"\"\"\n    return constants.NAVIGATION_MODES.inverse[self.navigationMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.application.ApplicationMixin.is_effect_enabled","title":"<code>is_effect_enabled(self, effect: constants.UiEffectStr) -&gt; bool</code>","text":"<p>Return desktop effect state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>desktop effect state</p> Source code in <code>prettyqt/widgets/application.py</code> <pre><code>def is_effect_enabled(self, effect: constants.UiEffectStr) -&gt; bool:\n\"\"\"Return desktop effect state.\n\n    Returns:\n        desktop effect state\n    \"\"\"\n    return self.isEffectEnabled(constants.UI_EFFECTS[effect])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.application.ApplicationMixin.set_effect_enabled","title":"<code>set_effect_enabled(self, effect: constants.UiEffectStr, enabled: bool = True)</code>","text":"<p>Set the enabled state of a desktop effect.</p> <p>Parameters:</p> Name Type Description Default <code>effect</code> <code>constants.UiEffectStr</code> <p>desktop effect to set</p> required <code>enabled</code> <code>bool</code> <p>new state</p> <code>True</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid desktop effect</p> Source code in <code>prettyqt/widgets/application.py</code> <pre><code>def set_effect_enabled(self, effect: constants.UiEffectStr, enabled: bool = True):\n\"\"\"Set the enabled state of a desktop effect.\n\n    Args:\n        effect: desktop effect to set\n        enabled: new state\n\n    Raises:\n        InvalidParamError: invalid desktop effect\n    \"\"\"\n    if effect not in constants.UI_EFFECTS:\n        raise InvalidParamError(effect, constants.UI_EFFECTS)\n    self.setEffectEnabled(constants.UI_EFFECTS[effect])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.application.ApplicationMixin.set_navigation_mode","title":"<code>set_navigation_mode(self, mode: constants.NavigationModeStr)</code>","text":"<p>Set the navigation mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.NavigationModeStr</code> <p>navigation mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid navigation mode</p> Source code in <code>prettyqt/widgets/application.py</code> <pre><code>def set_navigation_mode(self, mode: constants.NavigationModeStr):\n\"\"\"Set the navigation mode.\n\n    Args:\n        mode: navigation mode to use\n\n    Raises:\n        InvalidParamError: invalid navigation mode\n    \"\"\"\n    if mode not in constants.NAVIGATION_MODES:\n        raise InvalidParamError(mode, constants.NAVIGATION_MODES)\n    self.setNavigationMode(constants.NAVIGATION_MODES[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.application.ApplicationMixin.sleep","title":"<code>sleep(secs: float)</code>  <code>classmethod</code>","text":"<p>Pause application (non-blocking).</p> <p>Parameters:</p> Name Type Description Default <code>secs</code> <code>float</code> <p>seconds to sleep</p> required Source code in <code>prettyqt/widgets/application.py</code> <pre><code>@classmethod\ndef sleep(cls, secs: float):\n\"\"\"Pause application (non-blocking).\n\n    Args:\n        secs: seconds to sleep\n    \"\"\"\n    start = timeit.default_timer()\n    while True:\n        cls.processEvents()\n        if timeit.default_timer() - start &gt; secs:\n            return\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout","title":"<code>boxlayout</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayoutMixin","title":"<code> BoxLayoutMixin            (LayoutMixin)         </code>","text":"Source code in <code>prettyqt/widgets/boxlayout.py</code> <pre><code>class BoxLayoutMixin(widgets.LayoutMixin):\n    def __init__(\n        self,\n        orientation: Literal[\"horizontal\", \"vertical\"] = \"horizontal\",\n        parent: QtWidgets.QWidget | None = None,\n        margin: int | None = None,\n    ):\n        o = (\n            self.Direction.TopToBottom\n            if orientation == \"vertical\"\n            else self.Direction.LeftToRight\n        )\n        super().__init__(o, parent)\n        if margin is not None:\n            self.set_margin(margin)\n\n    def serialize_fields(self):\n        return dict(items=self.get_children(), direction=self.get_direction())\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_direction(state[\"direction\"])\n        for item in state[\"items\"]:\n            self.add(item)\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __add__(self, other: QtWidgets.QWidget | QtWidgets.QLayout):\n        self.add(other)\n        return self\n\n    def add(self, *item):\n        for i in item:\n            if isinstance(i, QtWidgets.QWidget):\n                self.addWidget(i)\n            else:\n                self.addLayout(i)\n\n    def add_stretch(self, stretch: int = 0):\n        self.addStretch(stretch)\n\n    def add_spacing(self, size: int):\n        self.addSpacing(size)\n\n    def set_direction(self, direction: DirectionStr):\n\"\"\"Set the direction.\n\n        Args:\n            direction: direction\n\n        Raises:\n            InvalidParamError: direction does not exist\n        \"\"\"\n        if direction not in DIRECTION:\n            raise InvalidParamError(direction, DIRECTION)\n        self.setDirection(DIRECTION[direction])\n\n    def get_direction(self) -&gt; DirectionStr:\n\"\"\"Return current direction.\n\n        Returns:\n            direction\n        \"\"\"\n        return DIRECTION.inverse[self.direction()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayoutMixin.get_direction","title":"<code>get_direction(self) -&gt; DirectionStr</code>","text":"<p>Return current direction.</p> <p>Returns:</p> Type Description <code>DirectionStr</code> <p>direction</p> Source code in <code>prettyqt/widgets/boxlayout.py</code> <pre><code>def get_direction(self) -&gt; DirectionStr:\n\"\"\"Return current direction.\n\n    Returns:\n        direction\n    \"\"\"\n    return DIRECTION.inverse[self.direction()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayoutMixin.set_direction","title":"<code>set_direction(self, direction: DirectionStr)</code>","text":"<p>Set the direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>DirectionStr</code> <p>direction</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>direction does not exist</p> Source code in <code>prettyqt/widgets/boxlayout.py</code> <pre><code>def set_direction(self, direction: DirectionStr):\n\"\"\"Set the direction.\n\n    Args:\n        direction: direction\n\n    Raises:\n        InvalidParamError: direction does not exist\n    \"\"\"\n    if direction not in DIRECTION:\n        raise InvalidParamError(direction, DIRECTION)\n    self.setDirection(DIRECTION[direction])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget","title":"<code>calendarwidget</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget","title":"<code> CalendarWidget            (WidgetMixin, QCalendarWidget)         </code>","text":"Source code in <code>prettyqt/widgets/calendarwidget.py</code> <pre><code>class CalendarWidget(widgets.WidgetMixin, QtWidgets.QCalendarWidget):\n    def serialize_fields(self):\n        return dict(date=self.get_date())\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.setSelectedDate(state[\"date\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def get_date(self) -&gt; datetime.date:\n        return self.selectedDate().toPython()  # type: ignore\n\n    def get_value(self) -&gt; datetime.date:\n        return self.get_date()\n\n    def set_value(self, value: datatypes.DateType):\n        if isinstance(value, str):\n            value = QtCore.QDate.fromString(value)\n        self.setSelectedDate(value)  # type: ignore\n\n    def set_range(\n        self,\n        lower: datatypes.DateType,\n        upper: datatypes.DateType,\n    ):\n        if isinstance(lower, str):\n            lower = QtCore.QDate.fromString(lower)\n        if isinstance(upper, str):\n            upper = QtCore.QDate.fromString(upper)\n        self.setMinimumDate(lower)  # type: ignore\n        self.setMaximumDate(upper)  # type: ignore\n\n    def set_selection_mode(self, mode: SelectionModeStr | None):\n\"\"\"Set selection mode for given calendar widget.\n\n        Args:\n            mode: selection mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode is None:\n            mode = \"none\"\n        if mode not in SELECTION_MODE:\n            raise InvalidParamError(mode, SELECTION_MODE)\n        self.setSelectionMode(SELECTION_MODE[mode])\n\n    def get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n\n        Returns:\n            selection mode\n        \"\"\"\n        return SELECTION_MODE.inverse[self.selectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.get_selection_mode","title":"<code>get_selection_mode(self) -&gt; SelectionModeStr</code>","text":"<p>Return current selection mode.</p> <p>Returns:</p> Type Description <code>SelectionModeStr</code> <p>selection mode</p> Source code in <code>prettyqt/widgets/calendarwidget.py</code> <pre><code>def get_selection_mode(self) -&gt; SelectionModeStr:\n\"\"\"Return current selection mode.\n\n    Returns:\n        selection mode\n    \"\"\"\n    return SELECTION_MODE.inverse[self.selectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.set_selection_mode","title":"<code>set_selection_mode(self, mode: SelectionModeStr | None)</code>","text":"<p>Set selection mode for given calendar widget.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SelectionModeStr | None</code> <p>selection mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/widgets/calendarwidget.py</code> <pre><code>def set_selection_mode(self, mode: SelectionModeStr | None):\n\"\"\"Set selection mode for given calendar widget.\n\n    Args:\n        mode: selection mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode is None:\n        mode = \"none\"\n    if mode not in SELECTION_MODE:\n        raise InvalidParamError(mode, SELECTION_MODE)\n    self.setSelectionMode(SELECTION_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.checkbox","title":"<code>checkbox</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox","title":"<code> CheckBox            (AbstractButtonMixin, QCheckBox)         </code>","text":"Source code in <code>prettyqt/widgets/checkbox.py</code> <pre><code>class CheckBox(widgets.AbstractButtonMixin, QtWidgets.QCheckBox):\n    value_changed = core.Signal(int)\n\n    def __init__(\n        self,\n        label: str = \"\",\n        parent: QtWidgets.QWidget | None = None,\n        checked: bool = False,\n    ):\n        super().__init__(label, parent)\n        self.stateChanged.connect(self.value_changed)\n        self.setChecked(checked)\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.setTristate(state.get(\"is_tristate\", False))\n        self.set_checkstate(state[\"checkstate\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def serialize_fields(self):\n        return dict(\n            checkstate=self.get_checkstate(),\n            is_tristate=self.isTristate(),\n        )\n\n    def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n        Args:\n            state: checkstate to use\n\n        Raises:\n            InvalidParamError: invalid checkstate\n        \"\"\"\n        if state not in constants.STATE:\n            raise InvalidParamError(state, constants.STATE)\n        self.setCheckState(constants.STATE[state])\n\n    def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n        Returns:\n            checkstate\n        \"\"\"\n        return constants.STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.get_checkstate","title":"<code>get_checkstate(self) -&gt; constants.StateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.StateStr</code> <p>checkstate</p> Source code in <code>prettyqt/widgets/checkbox.py</code> <pre><code>def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n    Returns:\n        checkstate\n    \"\"\"\n    return constants.STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.set_checkstate","title":"<code>set_checkstate(self, state: constants.StateStr)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.StateStr</code> <p>checkstate to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid checkstate</p> Source code in <code>prettyqt/widgets/checkbox.py</code> <pre><code>def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n    Args:\n        state: checkstate to use\n\n    Raises:\n        InvalidParamError: invalid checkstate\n    \"\"\"\n    if state not in constants.STATE:\n        raise InvalidParamError(state, constants.STATE)\n    self.setCheckState(constants.STATE[state])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.colordialog","title":"<code>colordialog</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.colordialog.CPAlphaShowLabel","title":"<code> CPAlphaShowLabel            (Label)         </code>","text":"Source code in <code>prettyqt/widgets/colordialog.py</code> <pre><code>class CPAlphaShowLabel(widgets.Label):\n\"\"\"Label which displays the currently-active color using checkerboard alpha.\n\n    A replacement for QColorDialog's QColorShowLabel.\n    \"\"\"\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(parent)\n        # Length in pixels of a side of the checkerboard squares\n        # (Pattern is made up of 2\u00d72 squares, total size 2n \u00d7 2n)\n        self.checkerboard_size = 8\n        # Start out transparent by default\n        self.color = self.parent().currentColor()\n        self.parent().currentColorChanged.connect(self.update_color)\n        self.pattern = gui.Pixmap.create_checkerboard_pattern(\n            self.checkerboard_size, \"#aaa\", \"#ccc\"\n        )\n\n    def update_color(self, color: QtGui.QColor):\n        self.color = color\n        self.repaint()\n\n    def paintEvent(self, event):\n\"\"\"Show the current color using checkerboard alpha.\"\"\"\n        event.accept()\n        with gui.Painter(self) as p:\n            p.set_pen(None)\n            if self.color.alphaF() &lt; 1.0:\n                p.drawTiledPixmap(event.rect(), self.pattern, QtCore.QPoint(4, 4))\n            p.fillRect(event.rect(), self.color)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.colordialog.CPAlphaShowLabel.paintEvent","title":"<code>paintEvent(self, event)</code>","text":"<p>Show the current color using checkerboard alpha.</p> Source code in <code>prettyqt/widgets/colordialog.py</code> <pre><code>def paintEvent(self, event):\n\"\"\"Show the current color using checkerboard alpha.\"\"\"\n    event.accept()\n    with gui.Painter(self) as p:\n        p.set_pen(None)\n        if self.color.alphaF() &lt; 1.0:\n            p.drawTiledPixmap(event.rect(), self.pattern, QtCore.QPoint(4, 4))\n        p.fillRect(event.rect(), self.color)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox","title":"<code>combobox</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin","title":"<code> ComboBoxMixin            (WidgetMixin)         </code>","text":"Source code in <code>prettyqt/widgets/combobox.py</code> <pre><code>class ComboBoxMixin(widgets.WidgetMixin):\n    value_changed = core.Signal(object)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.currentIndexChanged.connect(self.index_changed)\n\n    def serialize_fields(self):\n        items = [\n            (self.itemText(i), self.itemData(i), self.item_icon(i))\n            for i in range(self.count())\n        ]\n        dct = dict(\n            index=self.currentIndex(),\n            editable=self.isEditable(),\n            max_count=self.maxCount(),\n            has_frame=self.hasFrame(),\n            icon_size=self.iconSize(),\n            insert_policy=self.insertPolicy(),\n            model_column=self.modelColumn(),\n            max_visible_items=self.maxVisibleItems(),\n            size_adjust_policy=self.get_size_adjust_policy(),\n            duplicates_enabled=self.duplicatesEnabled(),\n            min_contents_length=self.minimumContentsLength(),\n            placeholder_text=self.placeholderText(),\n            items=items,\n        )\n        return dct\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        for label, data, icon in state[\"items\"]:\n            self.add(label, data, icon=icon)\n        self.setCurrentIndex(state[\"index\"])\n        self.setEditable(state[\"editable\"])\n        self.setMaxCount(state[\"max_count\"])\n        self.setMaxVisibleItems(state[\"max_visible_items\"])\n        self.setMinimumContentsLength(state[\"min_contents_length\"])\n        self.setDuplicatesEnabled(state[\"duplicates_enabled\"])\n        self.setFrame(state[\"has_frame\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __len__(self) -&gt; int:\n        return self.count()\n\n    def index_changed(self, index: int):\n        data = self.itemData(index)\n        self.value_changed.emit(data)\n\n    def add_items(self, items: Iterable | Mapping, default=NoData):\n        if isinstance(items, Mapping):\n            for k, v in items.items():\n                self.addItem(v, userData=k)\n        else:\n            for i in items:\n                if isinstance(i, (tuple, list)):\n                    self.add(*i)\n                else:\n                    self.addItem(i, i)\n        if default is not NoData:\n            self.set_value(default)\n\n    def add(self, label: str, data=NoData, icon: datatypes.IconType = None):\n        if data is NoData:\n            data = label\n        if icon is not None:\n            icon = iconprovider.get_icon(icon)\n            self.addItem(gui.Icon(icon), label, userData=data)\n        else:\n            self.addItem(label, userData=data)\n\n    def item_icon(self, index: int) -&gt; gui.Icon | None:\n        icon = self.itemIcon(index)\n        if icon.isNull():\n            return None\n        return gui.Icon(icon)\n\n    def set_editable(self, editable: bool):\n        self.setEditable(editable)\n        if self.completer() is None and editable:\n            self.setCompleter(widgets.Completer(self))\n\n    def set_insert_policy(self, policy: InsertPolicyStr):\n\"\"\"Set insert policy.\n\n        Args:\n            policy: insert policy to use\n\n        Raises:\n            InvalidParamError: invalid insert policy\n        \"\"\"\n        if policy not in INSERT_POLICY:\n            raise InvalidParamError(policy, INSERT_POLICY)\n        self.setInsertPolicy(INSERT_POLICY[policy])\n\n    def get_insert_policy(self) -&gt; InsertPolicyStr:\n\"\"\"Return insert policy.\n\n        Returns:\n            insert policy\n        \"\"\"\n        return INSERT_POLICY.inverse[self.insertPolicy()]\n\n    def set_size_adjust_policy(self, policy: SizeAdjustPolicyStr):\n\"\"\"Set size adjust policy.\n\n        Args:\n            policy: size adjust policy to use\n\n        Raises:\n            InvalidParamError: invalid size adjust policy\n        \"\"\"\n        if policy not in SIZE_ADJUST_POLICY:\n            raise InvalidParamError(policy, SIZE_ADJUST_POLICY)\n        self.setSizeAdjustPolicy(SIZE_ADJUST_POLICY[policy])\n\n    def get_size_adjust_policy(self) -&gt; SizeAdjustPolicyStr:\n\"\"\"Return size adjust policy.\n\n        Returns:\n            size adjust policy\n        \"\"\"\n        return SIZE_ADJUST_POLICY.inverse[self.sizeAdjustPolicy()]\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n        if isinstance(size, int):\n            size = core.Size(size, size)\n        elif isinstance(size, tuple):\n            size = core.Size(*size)\n        self.setIconSize(size)\n\n    def get_icon_size(self) -&gt; core.Size:\n        return core.Size(self.iconSize())\n\n    def set_min_char_length(self, chars: int):\n        self.setMinimumContentsLength(chars)\n\n    def get_value(self) -&gt; Any:\n        # if all(self.itemData(i) is None for i in range(self.count())):\n        #     return self.currentText()\n        # else:\n        #     return self.currentData()\n        return self.currentData()\n\n    def set_value(self, value: Any):\n        self.set_data(value)\n\n    def set_text(self, text: str):\n        self.setCurrentText(text)\n\n    def set_data(self, data: Any):\n        idx = self.findData(data)\n        if idx == -1:\n            raise ValueError(\"invalid data\")\n        self.setCurrentIndex(idx)\n\n    def text(self) -&gt; str:\n        return self.currentText()\n\n    def hide_completer(self):\n\"\"\"Hides the completion widget.\"\"\"\n        completer = widgets.Completer(self)\n        self.setCompleter(completer)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.get_insert_policy","title":"<code>get_insert_policy(self) -&gt; InsertPolicyStr</code>","text":"<p>Return insert policy.</p> <p>Returns:</p> Type Description <code>InsertPolicyStr</code> <p>insert policy</p> Source code in <code>prettyqt/widgets/combobox.py</code> <pre><code>def get_insert_policy(self) -&gt; InsertPolicyStr:\n\"\"\"Return insert policy.\n\n    Returns:\n        insert policy\n    \"\"\"\n    return INSERT_POLICY.inverse[self.insertPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.get_size_adjust_policy","title":"<code>get_size_adjust_policy(self) -&gt; SizeAdjustPolicyStr</code>","text":"<p>Return size adjust policy.</p> <p>Returns:</p> Type Description <code>SizeAdjustPolicyStr</code> <p>size adjust policy</p> Source code in <code>prettyqt/widgets/combobox.py</code> <pre><code>def get_size_adjust_policy(self) -&gt; SizeAdjustPolicyStr:\n\"\"\"Return size adjust policy.\n\n    Returns:\n        size adjust policy\n    \"\"\"\n    return SIZE_ADJUST_POLICY.inverse[self.sizeAdjustPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.hide_completer","title":"<code>hide_completer(self)</code>","text":"<p>Hides the completion widget.</p> Source code in <code>prettyqt/widgets/combobox.py</code> <pre><code>def hide_completer(self):\n\"\"\"Hides the completion widget.\"\"\"\n    completer = widgets.Completer(self)\n    self.setCompleter(completer)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.set_icon_size","title":"<code>set_icon_size(self, size: int | datatypes.SizeType)</code>","text":"<p>Set size of the icons.</p> Source code in <code>prettyqt/widgets/combobox.py</code> <pre><code>def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n    if isinstance(size, int):\n        size = core.Size(size, size)\n    elif isinstance(size, tuple):\n        size = core.Size(*size)\n    self.setIconSize(size)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.set_insert_policy","title":"<code>set_insert_policy(self, policy: InsertPolicyStr)</code>","text":"<p>Set insert policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>InsertPolicyStr</code> <p>insert policy to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid insert policy</p> Source code in <code>prettyqt/widgets/combobox.py</code> <pre><code>def set_insert_policy(self, policy: InsertPolicyStr):\n\"\"\"Set insert policy.\n\n    Args:\n        policy: insert policy to use\n\n    Raises:\n        InvalidParamError: invalid insert policy\n    \"\"\"\n    if policy not in INSERT_POLICY:\n        raise InvalidParamError(policy, INSERT_POLICY)\n    self.setInsertPolicy(INSERT_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBoxMixin.set_size_adjust_policy","title":"<code>set_size_adjust_policy(self, policy: SizeAdjustPolicyStr)</code>","text":"<p>Set size adjust policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizeAdjustPolicyStr</code> <p>size adjust policy to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid size adjust policy</p> Source code in <code>prettyqt/widgets/combobox.py</code> <pre><code>def set_size_adjust_policy(self, policy: SizeAdjustPolicyStr):\n\"\"\"Set size adjust policy.\n\n    Args:\n        policy: size adjust policy to use\n\n    Raises:\n        InvalidParamError: invalid size adjust policy\n    \"\"\"\n    if policy not in SIZE_ADJUST_POLICY:\n        raise InvalidParamError(policy, SIZE_ADJUST_POLICY)\n    self.setSizeAdjustPolicy(SIZE_ADJUST_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer","title":"<code>completer</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer","title":"<code> Completer            (ObjectMixin, QCompleter)         </code>","text":"Source code in <code>prettyqt/widgets/completer.py</code> <pre><code>class Completer(core.ObjectMixin, QtWidgets.QCompleter):\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        super().__init__(parent)\n\n    def set_sort_mode(self, mode: SortModeStr | None):\n\"\"\"Set sort mode to use.\n\n        Args:\n            mode: sort mode to use\n\n        Raises:\n            InvalidParamError: sort mode does not exist\n        \"\"\"\n        if mode is None:\n            mode = \"unsorted\"\n        if mode not in SORT_MODE:\n            raise InvalidParamError(mode, SORT_MODE)\n        self.setModelSorting(SORT_MODE[mode])\n\n    def get_sort_mode(self) -&gt; SortModeStr:\n\"\"\"Return current sort mode.\n\n        Returns:\n            sort mode\n        \"\"\"\n        return SORT_MODE.inverse[self.modelSorting()]\n\n    def set_completion_mode(self, mode: CompletionModeStr):\n\"\"\"Set completion mode to use.\n\n        Args:\n            mode: completion mode to use\n\n        Raises:\n            InvalidParamError: completion mode does not exist\n        \"\"\"\n        if mode not in COMPLETION_MODE:\n            raise InvalidParamError(mode, COMPLETION_MODE)\n        self.setCompletionMode(COMPLETION_MODE[mode])\n\n    def get_completion_mode(self) -&gt; CompletionModeStr:\n\"\"\"Return current completion mode.\n\n        Returns:\n            completion mode\n        \"\"\"\n        return COMPLETION_MODE.inverse[self.completionMode()]\n\n    def set_filter_mode(self, mode: constants.FilterModeStr):\n\"\"\"Set filter mode to use.\n\n        Args:\n            mode: filter mode to use\n\n        Raises:\n            InvalidParamError: filter mode does not exist\n        \"\"\"\n        if mode not in constants.FILTER_MODES:\n            raise InvalidParamError(mode, constants.FILTER_MODES)\n        self.setFilterMode(constants.FILTER_MODES[mode])\n\n    def get_filter_mode(self) -&gt; constants.FilterModeStr:\n\"\"\"Return current filter mode.\n\n        Returns:\n            filter mode\n        \"\"\"\n        return constants.FILTER_MODES.inverse[self.filterMode()]\n\n    def set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n\n        Args:\n            state: case sensitive\n\n        \"\"\"\n        sensitivity = (\n            QtCore.Qt.CaseSensitivity.CaseSensitive\n            if state\n            else QtCore.Qt.CaseSensitivity.CaseInsensitive\n        )\n        self.setCaseSensitivity(sensitivity)\n\n    def is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n\n        Returns:\n            case sensitivity\n        \"\"\"\n        return bool(self.caseSensitivity())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_completion_mode","title":"<code>get_completion_mode(self) -&gt; CompletionModeStr</code>","text":"<p>Return current completion mode.</p> <p>Returns:</p> Type Description <code>CompletionModeStr</code> <p>completion mode</p> Source code in <code>prettyqt/widgets/completer.py</code> <pre><code>def get_completion_mode(self) -&gt; CompletionModeStr:\n\"\"\"Return current completion mode.\n\n    Returns:\n        completion mode\n    \"\"\"\n    return COMPLETION_MODE.inverse[self.completionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_filter_mode","title":"<code>get_filter_mode(self) -&gt; constants.FilterModeStr</code>","text":"<p>Return current filter mode.</p> <p>Returns:</p> Type Description <code>constants.FilterModeStr</code> <p>filter mode</p> Source code in <code>prettyqt/widgets/completer.py</code> <pre><code>def get_filter_mode(self) -&gt; constants.FilterModeStr:\n\"\"\"Return current filter mode.\n\n    Returns:\n        filter mode\n    \"\"\"\n    return constants.FILTER_MODES.inverse[self.filterMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_sort_mode","title":"<code>get_sort_mode(self) -&gt; SortModeStr</code>","text":"<p>Return current sort mode.</p> <p>Returns:</p> Type Description <code>SortModeStr</code> <p>sort mode</p> Source code in <code>prettyqt/widgets/completer.py</code> <pre><code>def get_sort_mode(self) -&gt; SortModeStr:\n\"\"\"Return current sort mode.\n\n    Returns:\n        sort mode\n    \"\"\"\n    return SORT_MODE.inverse[self.modelSorting()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.is_case_sensitive","title":"<code>is_case_sensitive(self) -&gt; bool</code>","text":"<p>Return case sensitivity.</p> <p>Returns:</p> Type Description <code>bool</code> <p>case sensitivity</p> Source code in <code>prettyqt/widgets/completer.py</code> <pre><code>def is_case_sensitive(self) -&gt; bool:\n\"\"\"Return case sensitivity.\n\n    Returns:\n        case sensitivity\n    \"\"\"\n    return bool(self.caseSensitivity())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_case_sensitive","title":"<code>set_case_sensitive(self, state: bool)</code>","text":"<p>Set case sensitivity.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>case sensitive</p> required Source code in <code>prettyqt/widgets/completer.py</code> <pre><code>def set_case_sensitive(self, state: bool):\n\"\"\"Set case sensitivity.\n\n    Args:\n        state: case sensitive\n\n    \"\"\"\n    sensitivity = (\n        QtCore.Qt.CaseSensitivity.CaseSensitive\n        if state\n        else QtCore.Qt.CaseSensitivity.CaseInsensitive\n    )\n    self.setCaseSensitivity(sensitivity)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_completion_mode","title":"<code>set_completion_mode(self, mode: CompletionModeStr)</code>","text":"<p>Set completion mode to use.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CompletionModeStr</code> <p>completion mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>completion mode does not exist</p> Source code in <code>prettyqt/widgets/completer.py</code> <pre><code>def set_completion_mode(self, mode: CompletionModeStr):\n\"\"\"Set completion mode to use.\n\n    Args:\n        mode: completion mode to use\n\n    Raises:\n        InvalidParamError: completion mode does not exist\n    \"\"\"\n    if mode not in COMPLETION_MODE:\n        raise InvalidParamError(mode, COMPLETION_MODE)\n    self.setCompletionMode(COMPLETION_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_filter_mode","title":"<code>set_filter_mode(self, mode: constants.FilterModeStr)</code>","text":"<p>Set filter mode to use.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.FilterModeStr</code> <p>filter mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>filter mode does not exist</p> Source code in <code>prettyqt/widgets/completer.py</code> <pre><code>def set_filter_mode(self, mode: constants.FilterModeStr):\n\"\"\"Set filter mode to use.\n\n    Args:\n        mode: filter mode to use\n\n    Raises:\n        InvalidParamError: filter mode does not exist\n    \"\"\"\n    if mode not in constants.FILTER_MODES:\n        raise InvalidParamError(mode, constants.FILTER_MODES)\n    self.setFilterMode(constants.FILTER_MODES[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_sort_mode","title":"<code>set_sort_mode(self, mode: SortModeStr | None)</code>","text":"<p>Set sort mode to use.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SortModeStr | None</code> <p>sort mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>sort mode does not exist</p> Source code in <code>prettyqt/widgets/completer.py</code> <pre><code>def set_sort_mode(self, mode: SortModeStr | None):\n\"\"\"Set sort mode to use.\n\n    Args:\n        mode: sort mode to use\n\n    Raises:\n        InvalidParamError: sort mode does not exist\n    \"\"\"\n    if mode is None:\n        mode = \"unsorted\"\n    if mode not in SORT_MODE:\n        raise InvalidParamError(mode, SORT_MODE)\n    self.setModelSorting(SORT_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper","title":"<code>datawidgetmapper</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper","title":"<code> DataWidgetMapper            (ObjectMixin, QDataWidgetMapper)         </code>","text":"Source code in <code>prettyqt/widgets/datawidgetmapper.py</code> <pre><code>class DataWidgetMapper(core.ObjectMixin, QtWidgets.QDataWidgetMapper):\n    def serialize_fields(self):\n        return dict(\n            current_index=self.currentIndex(),\n            orientation=self.get_orientation(),\n            submit_policy=self.get_submit_policy(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_orientation(state[\"orientation\"])\n        self.set_submit_policy(state[\"submit_policy\"])\n        self.setCurrentIndex(state[\"current_index\"])\n\n    def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the data widget mapper.\n\n        Args:\n            orientation: orientation for the data widget mapper\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in constants.ORIENTATION:\n            raise InvalidParamError(orientation, constants.ORIENTATION)\n        self.setOrientation(constants.ORIENTATION[orientation])\n\n    def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return constants.ORIENTATION.inverse[self.orientation()]\n\n    def set_submit_policy(self, policy: SubmitPolicyStr):\n\"\"\"Set the submit policy of the mapper.\n\n        Args:\n            policy: submit_policy for the data widget mapper\n\n        Raises:\n            InvalidParamError: submit_policy does not exist\n        \"\"\"\n        if policy not in SUBMIT_POLICY:\n            raise InvalidParamError(policy, SUBMIT_POLICY)\n        self.setSubmitPolicy(SUBMIT_POLICY[policy])\n\n    def get_submit_policy(self) -&gt; SubmitPolicyStr:\n\"\"\"Return current submit policy.\n\n        Returns:\n            submit policy\n        \"\"\"\n        return SUBMIT_POLICY.inverse[self.submitPolicy()]\n\n    def add_mapping(\n        self, widget: QtWidgets.QWidget, section: int, property_name: str | None = None\n    ):\n        if property_name is None:\n            self.addMapping(widget, section)\n        else:\n            ba = QtCore.QByteArray(property_name.encode())\n            self.addMapping(widget, section, ba)\n\n    def get_mapped_property_name(self, widget: QtWidgets.QWidget) -&gt; str:\n        return bytes(self.mappedPropertyName(widget)).decode()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_orientation","title":"<code>get_orientation(self) -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt/widgets/datawidgetmapper.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_submit_policy","title":"<code>get_submit_policy(self) -&gt; SubmitPolicyStr</code>","text":"<p>Return current submit policy.</p> <p>Returns:</p> Type Description <code>SubmitPolicyStr</code> <p>submit policy</p> Source code in <code>prettyqt/widgets/datawidgetmapper.py</code> <pre><code>def get_submit_policy(self) -&gt; SubmitPolicyStr:\n\"\"\"Return current submit policy.\n\n    Returns:\n        submit policy\n    \"\"\"\n    return SUBMIT_POLICY.inverse[self.submitPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_orientation","title":"<code>set_orientation(self, orientation: constants.OrientationStr)</code>","text":"<p>Set the orientation of the data widget mapper.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr</code> <p>orientation for the data widget mapper</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt/widgets/datawidgetmapper.py</code> <pre><code>def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the data widget mapper.\n\n    Args:\n        orientation: orientation for the data widget mapper\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in constants.ORIENTATION:\n        raise InvalidParamError(orientation, constants.ORIENTATION)\n    self.setOrientation(constants.ORIENTATION[orientation])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_submit_policy","title":"<code>set_submit_policy(self, policy: SubmitPolicyStr)</code>","text":"<p>Set the submit policy of the mapper.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SubmitPolicyStr</code> <p>submit_policy for the data widget mapper</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>submit_policy does not exist</p> Source code in <code>prettyqt/widgets/datawidgetmapper.py</code> <pre><code>def set_submit_policy(self, policy: SubmitPolicyStr):\n\"\"\"Set the submit policy of the mapper.\n\n    Args:\n        policy: submit_policy for the data widget mapper\n\n    Raises:\n        InvalidParamError: submit_policy does not exist\n    \"\"\"\n    if policy not in SUBMIT_POLICY:\n        raise InvalidParamError(policy, SUBMIT_POLICY)\n    self.setSubmitPolicy(SUBMIT_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox","title":"<code>dialogbuttonbox</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox","title":"<code> DialogButtonBox            (WidgetMixin, QDialogButtonBox)         </code>","text":"Source code in <code>prettyqt/widgets/dialogbuttonbox.py</code> <pre><code>class DialogButtonBox(widgets.WidgetMixin, QtWidgets.QDialogButtonBox):\n    button_clicked = core.Signal(str)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.clicked.connect(self.on_click)\n\n    def __len__(self) -&gt; int:\n        return len(self.buttons())\n\n    def __getitem__(self, index: ButtonStr) -&gt; QtWidgets.QPushButton:\n        return self.button(BUTTONS[index])\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QAbstractButton]:\n        return iter(self.buttons())\n\n    def __contains__(self, index: ButtonStr):\n        return self.button(BUTTONS[index]) is not None\n\n    @classmethod\n    def create(cls, **kwargs):\n        box = cls()\n        for k, v in kwargs.items():\n            box.add_default_button(k, callback=v)  # type: ignore\n        return box\n\n    def on_click(self, button: QtCore.QObject):\n        self.button_clicked.emit(button.objectName())\n\n    def set_horizontal(self):\n        self.setOrientation(constants.HORIZONTAL)\n\n    def set_vertical(self):\n        self.setOrientation(constants.VERTICAL)\n\n    def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the button box.\n\n        Args:\n            orientation: orientation for the button box\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in constants.ORIENTATION:\n            raise InvalidParamError(orientation, constants.ORIENTATION)\n        self.setOrientation(constants.ORIENTATION[orientation])\n\n    def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return constants.ORIENTATION.inverse[self.orientation()]\n\n    def add_default_buttons(self, buttons: Sequence[ButtonStr]):\n        return [self.add_default_button(btn) for btn in buttons]\n\n    def add_default_button(\n        self, button: ButtonStr, callback: Callable | None = None\n    ) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n\n        Args:\n            button: button to add\n            callback: function to call when button gets clicked\n\n        Returns:\n            created button\n\n        Raises:\n            InvalidParamError: Button type not available\n        \"\"\"\n        if button not in BUTTONS:\n            raise InvalidParamError(button, BUTTONS)\n        btn = self.addButton(BUTTONS[button])\n        btn.setObjectName(button)\n        if callback:\n            btn.clicked.connect(callback)\n        return btn\n\n    def add_button(\n        self,\n        button: QtWidgets.QPushButton | ButtonStr,\n        role: RoleStr = \"accept\",\n        callback: Callable | None = None,\n    ) -&gt; widgets.PushButton:\n\"\"\"Add a button.\n\n        Args:\n            button: button to add\n            role: role of the button\n            callback: function to call when button gets clicked\n\n        Returns:\n            created button\n\n        Raises:\n            InvalidParamError: Button type not available\n        \"\"\"\n        if isinstance(button, str):\n            button = widgets.PushButton(button)\n        self.addButton(button, ROLES[role])\n        if callback:\n            button.clicked.connect(callback)\n        return button\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_button","title":"<code>add_button(self, button: QtWidgets.QPushButton | ButtonStr, role: RoleStr = 'accept', callback: Callable | None = None) -&gt; widgets.PushButton</code>","text":"<p>Add a button.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>QtWidgets.QPushButton | ButtonStr</code> <p>button to add</p> required <code>role</code> <code>RoleStr</code> <p>role of the button</p> <code>'accept'</code> <code>callback</code> <code>Callable | None</code> <p>function to call when button gets clicked</p> <code>None</code> <p>Returns:</p> Type Description <code>widgets.PushButton</code> <p>created button</p> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>Button type not available</p> Source code in <code>prettyqt/widgets/dialogbuttonbox.py</code> <pre><code>def add_button(\n    self,\n    button: QtWidgets.QPushButton | ButtonStr,\n    role: RoleStr = \"accept\",\n    callback: Callable | None = None,\n) -&gt; widgets.PushButton:\n\"\"\"Add a button.\n\n    Args:\n        button: button to add\n        role: role of the button\n        callback: function to call when button gets clicked\n\n    Returns:\n        created button\n\n    Raises:\n        InvalidParamError: Button type not available\n    \"\"\"\n    if isinstance(button, str):\n        button = widgets.PushButton(button)\n    self.addButton(button, ROLES[role])\n    if callback:\n        button.clicked.connect(callback)\n    return button\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_default_button","title":"<code>add_default_button(self, button: ButtonStr, callback: Callable | None = None) -&gt; QtWidgets.QPushButton</code>","text":"<p>Add a default button.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>ButtonStr</code> <p>button to add</p> required <code>callback</code> <code>Callable | None</code> <p>function to call when button gets clicked</p> <code>None</code> <p>Returns:</p> Type Description <code>QtWidgets.QPushButton</code> <p>created button</p> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>Button type not available</p> Source code in <code>prettyqt/widgets/dialogbuttonbox.py</code> <pre><code>def add_default_button(\n    self, button: ButtonStr, callback: Callable | None = None\n) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n\n    Args:\n        button: button to add\n        callback: function to call when button gets clicked\n\n    Returns:\n        created button\n\n    Raises:\n        InvalidParamError: Button type not available\n    \"\"\"\n    if button not in BUTTONS:\n        raise InvalidParamError(button, BUTTONS)\n    btn = self.addButton(BUTTONS[button])\n    btn.setObjectName(button)\n    if callback:\n        btn.clicked.connect(callback)\n    return btn\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.create","title":"<code>create(**kwargs)</code>  <code>classmethod</code>","text":"<p>create(self, arg__1: int = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) -&gt; None</p> Source code in <code>prettyqt/widgets/dialogbuttonbox.py</code> <pre><code>@classmethod\ndef create(cls, **kwargs):\n    box = cls()\n    for k, v in kwargs.items():\n        box.add_default_button(k, callback=v)  # type: ignore\n    return box\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.get_orientation","title":"<code>get_orientation(self) -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt/widgets/dialogbuttonbox.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.set_orientation","title":"<code>set_orientation(self, orientation: constants.OrientationStr)</code>","text":"<p>Set the orientation of the button box.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr</code> <p>orientation for the button box</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt/widgets/dialogbuttonbox.py</code> <pre><code>def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the button box.\n\n    Args:\n        orientation: orientation for the button box\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in constants.ORIENTATION:\n        raise InvalidParamError(orientation, constants.ORIENTATION)\n    self.setOrientation(constants.ORIENTATION[orientation])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog","title":"<code>filedialog</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog","title":"<code> FileDialog            (DialogMixin, QFileDialog)         </code>","text":"Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>class FileDialog(widgets.DialogMixin, QtWidgets.QFileDialog):\n\"\"\"Simple dialog used to display some widget.\"\"\"\n\n    def __init__(\n        self,\n        path: None | datatypes.PathType = None,\n        mode: AcceptModeStr = \"open\",\n        caption: str | None = None,\n        path_id: str | None = None,\n        extension_filter: dict | None = None,\n        file_mode: FileModeStr = \"existing_files\",\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        super().__init__(parent=parent)\n        self.set_title(caption)\n        self.path_id = path_id\n        if extension_filter:\n            self.set_extension_filter(extension_filter)\n        if path_id is not None and path is None:\n            settings = core.Settings()\n            path = settings.get(path_id, \"\")\n        if path is not None:\n            self.set_directory(path)\n        self.set_file_mode(file_mode)\n        self.set_accept_mode(mode)\n\n    def serialize_fields(self):\n        return dict(\n            file_mode=self.get_file_mode(),\n            accept_mode=self.get_accept_mode(),\n            filter=self.get_filter(),\n            view_mode=self.get_view_mode(),\n            name_filter=self.selectedNameFilter(),\n            default_suffix=self.defaultSuffix(),\n            name_filters=self.nameFilters(),\n            supported_schemes=self.supportedSchemes(),\n        )\n\n    def __setstate__(self, state):\n        self.set_file_mode(state[\"file_mode\"])\n        self.set_accept_mode(state[\"accept_mode\"])\n        self.set_view_mode(state[\"view_mode\"])\n        self.set_filter(*state[\"filter\"])\n        self.setNameFilters(state[\"name_filters\"])\n        self.setNameFilter(state[\"name_filter\"])\n        self.setDefaultSuffix(state[\"default_suffix\"])\n        self.setSupportedSchemes(state[\"supported_schemes\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def set_accept_mode(self, mode: AcceptModeStr):\n\"\"\"Set accept mode.\n\n        Args:\n            mode: accept mode to use\n\n        Raises:\n            InvalidParamError: invalid accept mode\n        \"\"\"\n        if mode not in ACCEPT_MODE:\n            raise InvalidParamError(mode, ACCEPT_MODE)\n        self.setAcceptMode(ACCEPT_MODE[mode])\n\n    def get_accept_mode(self) -&gt; AcceptModeStr:\n\"\"\"Return accept mode.\n\n        Returns:\n            accept mode\n        \"\"\"\n        return ACCEPT_MODE.inverse[self.acceptMode()]\n\n    def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode.\n\n        Args:\n            mode: view mode to use\n\n        Raises:\n            InvalidParamError: invalid view mode\n        \"\"\"\n        if mode not in VIEW_MODE:\n            raise InvalidParamError(mode, VIEW_MODE)\n        self.setViewMode(VIEW_MODE[mode])\n\n    def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n\n        Returns:\n            view mode\n        \"\"\"\n        return VIEW_MODE.inverse[self.viewMode()]\n\n    def set_label_text(self, label: LabelStr, text: str):\n\"\"\"Set the label text for button label.\n\n        Args:\n            label: button to set text for\n            text: text to use\n        \"\"\"\n        if label not in LABEL:\n            raise InvalidParamError(label, LABEL)\n        self.setLabelText(LABEL[label], text)\n\n    def get_label_text(self, label: LabelStr) -&gt; str:\n\"\"\"Return label text.\n\n        Returns:\n            label text\n        \"\"\"\n        return self.labelText(LABEL[label])\n\n    def get_file_mode(self) -&gt; FileModeStr:\n\"\"\"Return file mode.\n\n        Returns:\n            file mode\n        \"\"\"\n        return FILE_MODE.inverse[self.fileMode()]\n\n    def set_file_mode(self, mode: FileModeStr):\n\"\"\"Set the file mode of the dialog.\n\n        Args:\n            mode: mode to use\n        \"\"\"\n        self.setFileMode(FILE_MODE[mode])\n\n    def selected_files(self) -&gt; list[pathlib.Path]:\n        return [pathlib.Path(p) for p in self.selectedFiles()]\n\n    def selected_file(self) -&gt; pathlib.Path | None:\n        selected = self.selectedFiles()\n        return pathlib.Path(selected[0]) if selected else None\n\n    def choose_folder(self) -&gt; list[pathlib.Path] | None:\n        self.set_file_mode(\"directory\")\n        return self.choose()\n\n    def open_file(self) -&gt; list[pathlib.Path] | None:\n        self.set_file_mode(\"existing_file\")\n        return self.choose()\n\n    def choose(self) -&gt; list[pathlib.Path] | None:\n        result = self.main_loop()\n        if result != self.DialogCode.Accepted:\n            return None\n        paths = self.selected_files()\n        folder_path = paths[0].parent\n        if self.path_id:\n            settings = core.Settings()\n            settings.setValue(self.path_id, str(folder_path))\n        return paths\n\n    def set_extension_filter(self, extension_dict: dict[str, list[str]]):\n\"\"\"Set filter based on given dictionary.\n\n        dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs\n\n        Args:\n            extension_dict: filter dictionary\n        \"\"\"\n        items = [\n            f\"{k} ({' '.join(f'*{ext}' for ext in v)})\" for k, v in extension_dict.items()\n        ]\n        filter_str = \";;\".join(items)\n        self.setNameFilter(filter_str)\n\n    def get_directory(self) -&gt; pathlib.Path:\n\"\"\"Return current directory.\n\n        returns current directory level as a Pathlib object\n\n        Returns:\n            Pathlib object\n        \"\"\"\n        return pathlib.Path(self.directory().absolutePath())\n\n    def set_directory(self, path: datatypes.PathType):\n\"\"\"Set start directory.\"\"\"\n        path = os.fspath(path)\n        self.setDirectory(path)\n\n    def set_filter(self, *filters: core.dir.FilterStr):\n        for item in filters:\n            if item not in core.dir.FILTERS:\n                raise InvalidParamError(item, core.dir.FILTERS)\n        flags = helpers.merge_flags(filters, core.dir.FILTERS)\n        self.setFilter(flags)\n\n    def get_filter(self) -&gt; list[core.dir.FilterStr]:\n        return [k for k, v in core.dir.FILTERS.items() if v &amp; self.filter()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_accept_mode","title":"<code>get_accept_mode(self) -&gt; AcceptModeStr</code>","text":"<p>Return accept mode.</p> <p>Returns:</p> Type Description <code>AcceptModeStr</code> <p>accept mode</p> Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>def get_accept_mode(self) -&gt; AcceptModeStr:\n\"\"\"Return accept mode.\n\n    Returns:\n        accept mode\n    \"\"\"\n    return ACCEPT_MODE.inverse[self.acceptMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_directory","title":"<code>get_directory(self) -&gt; pathlib.Path</code>","text":"<p>Return current directory.</p> <p>returns current directory level as a Pathlib object</p> <p>Returns:</p> Type Description <code>pathlib.Path</code> <p>Pathlib object</p> Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>def get_directory(self) -&gt; pathlib.Path:\n\"\"\"Return current directory.\n\n    returns current directory level as a Pathlib object\n\n    Returns:\n        Pathlib object\n    \"\"\"\n    return pathlib.Path(self.directory().absolutePath())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_file_mode","title":"<code>get_file_mode(self) -&gt; FileModeStr</code>","text":"<p>Return file mode.</p> <p>Returns:</p> Type Description <code>FileModeStr</code> <p>file mode</p> Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>def get_file_mode(self) -&gt; FileModeStr:\n\"\"\"Return file mode.\n\n    Returns:\n        file mode\n    \"\"\"\n    return FILE_MODE.inverse[self.fileMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_label_text","title":"<code>get_label_text(self, label: LabelStr) -&gt; str</code>","text":"<p>Return label text.</p> <p>Returns:</p> Type Description <code>str</code> <p>label text</p> Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>def get_label_text(self, label: LabelStr) -&gt; str:\n\"\"\"Return label text.\n\n    Returns:\n        label text\n    \"\"\"\n    return self.labelText(LABEL[label])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_view_mode","title":"<code>get_view_mode(self) -&gt; ViewModeStr</code>","text":"<p>Return view mode.</p> <p>Returns:</p> Type Description <code>ViewModeStr</code> <p>view mode</p> Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n\n    Returns:\n        view mode\n    \"\"\"\n    return VIEW_MODE.inverse[self.viewMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_accept_mode","title":"<code>set_accept_mode(self, mode: AcceptModeStr)</code>","text":"<p>Set accept mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>AcceptModeStr</code> <p>accept mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid accept mode</p> Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>def set_accept_mode(self, mode: AcceptModeStr):\n\"\"\"Set accept mode.\n\n    Args:\n        mode: accept mode to use\n\n    Raises:\n        InvalidParamError: invalid accept mode\n    \"\"\"\n    if mode not in ACCEPT_MODE:\n        raise InvalidParamError(mode, ACCEPT_MODE)\n    self.setAcceptMode(ACCEPT_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_directory","title":"<code>set_directory(self, path: datatypes.PathType)</code>","text":"<p>Set start directory.</p> Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>def set_directory(self, path: datatypes.PathType):\n\"\"\"Set start directory.\"\"\"\n    path = os.fspath(path)\n    self.setDirectory(path)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_extension_filter","title":"<code>set_extension_filter(self, extension_dict: dict[str, list[str]])</code>","text":"<p>Set filter based on given dictionary.</p> <p>dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs</p> <p>Parameters:</p> Name Type Description Default <code>extension_dict</code> <code>dict[str, list[str]]</code> <p>filter dictionary</p> required Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>def set_extension_filter(self, extension_dict: dict[str, list[str]]):\n\"\"\"Set filter based on given dictionary.\n\n    dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs\n\n    Args:\n        extension_dict: filter dictionary\n    \"\"\"\n    items = [\n        f\"{k} ({' '.join(f'*{ext}' for ext in v)})\" for k, v in extension_dict.items()\n    ]\n    filter_str = \";;\".join(items)\n    self.setNameFilter(filter_str)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_file_mode","title":"<code>set_file_mode(self, mode: FileModeStr)</code>","text":"<p>Set the file mode of the dialog.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>FileModeStr</code> <p>mode to use</p> required Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>def set_file_mode(self, mode: FileModeStr):\n\"\"\"Set the file mode of the dialog.\n\n    Args:\n        mode: mode to use\n    \"\"\"\n    self.setFileMode(FILE_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_label_text","title":"<code>set_label_text(self, label: LabelStr, text: str)</code>","text":"<p>Set the label text for button label.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>LabelStr</code> <p>button to set text for</p> required <code>text</code> <code>str</code> <p>text to use</p> required Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>def set_label_text(self, label: LabelStr, text: str):\n\"\"\"Set the label text for button label.\n\n    Args:\n        label: button to set text for\n        text: text to use\n    \"\"\"\n    if label not in LABEL:\n        raise InvalidParamError(label, LABEL)\n    self.setLabelText(LABEL[label], text)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_view_mode","title":"<code>set_view_mode(self, mode: ViewModeStr)</code>","text":"<p>Set view mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewModeStr</code> <p>view mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid view mode</p> Source code in <code>prettyqt/widgets/filedialog.py</code> <pre><code>def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode.\n\n    Args:\n        mode: view mode to use\n\n    Raises:\n        InvalidParamError: invalid view mode\n    \"\"\"\n    if mode not in VIEW_MODE:\n        raise InvalidParamError(mode, VIEW_MODE)\n    self.setViewMode(VIEW_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel","title":"<code>filesystemmodel</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel","title":"<code> FileSystemModel            (AbstractItemModelMixin, QFileSystemModel)         </code>","text":"Source code in <code>prettyqt/widgets/filesystemmodel.py</code> <pre><code>class FileSystemModel(core.AbstractItemModelMixin, QtWidgets.QFileSystemModel):\n\"\"\"Class to populate a filesystem treeview.\"\"\"\n\n    DATA_ROLE = constants.USER_ROLE + 33  # type: ignore\n    content_type = \"files\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.setReadOnly(False)\n\n    def data(self, index, role=QtCore.Qt.ItemDataRole.DisplayRole):\n        if role == self.DATA_ROLE:\n            path = index.data(self.Roles.FilePathRole)\n            return pathlib.Path(path)\n        return super().data(index, role)\n\n    def get_file_info(self, index: QtCore.QModelIndex) -&gt; core.FileInfo:\n        return core.FileInfo(self.fileInfo(index))\n\n    def get_file_path(self, index: QtCore.QModelIndex) -&gt; pathlib.Path:\n        return pathlib.Path(self.filePath(index))\n\n    def yield_child_indexes(\n        self, index: QtCore.QModelIndex\n    ) -&gt; Iterator[QtCore.QModelIndex]:\n        if not self.hasChildren(index):\n            return\n        path = self.get_file_path(index)\n        for it in path.iterdir():\n            yield self.index(str(path / it))\n\n    def resolve_sym_links(self, resolve: bool):\n        self.setResolveSymlinks(resolve)\n\n    def watch_for_changes(self, watch: bool):\n        self.setOption(OPTIONS[\"dont_watch_changes\"], not watch)\n\n    def use_custom_icons(self, use: bool):\n        self.setOption(OPTIONS[\"no_custom_icons\"], not use)\n\n    def set_root_path(self, path: datatypes.PathType) -&gt; QtCore.QModelIndex:\n        match path:\n            case \"/\" | \"root\":\n                path = core.Dir.rootPath()\n            case \"home\":\n                path = core.Dir.homePath()\n            case \"temp\":\n                path = core.Dir.tempPath()\n            case \"current\":\n                path = core.Dir.currentPath()\n            case _:\n                path = os.fspath(path)\n        return self.setRootPath(path)\n\n    def set_name_filters(self, filters, hide: bool = False):\n        self.setNameFilters(filters)\n        self.setNameFilterDisables(not hide)\n\n    def set_filter(self, filter_mode: core.dir.FilterStr):\n        if filter_mode not in core.dir.FILTERS:\n            raise InvalidParamError(filter_mode, core.dir.FILTERS)\n        self.setFilter(core.dir.FILTERS[filter_mode])\n\n    def get_paths(self, indexes: Sequence[QtCore.QModelIndex]) -&gt; list[pathlib.Path]:\n        paths = [i.data(self.DATA_ROLE) for i in indexes]\n        if not paths:\n            return []\n        if paths[0] == \"\":\n            paths = [\n                folder / filename\n                for folder in paths\n                for filename in folder.iterdir()\n                if (folder / filename).is_file()\n            ]\n        return paths\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel.data","title":"<code>data(self, index, role = &lt;ItemDataRole.DisplayRole: 0&gt;)</code>","text":"<p>data(self, index: Union[PySide6.QtCore.QModelIndex, PySide6.QtCore.QPersistentModelIndex], role: int = Instance(Qt.DisplayRole)) -&gt; Any</p> Source code in <code>prettyqt/widgets/filesystemmodel.py</code> <pre><code>def data(self, index, role=QtCore.Qt.ItemDataRole.DisplayRole):\n    if role == self.DATA_ROLE:\n        path = index.data(self.Roles.FilePathRole)\n        return pathlib.Path(path)\n    return super().data(index, role)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox","title":"<code>fontcombobox</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox","title":"<code> FontComboBox            (ComboBoxMixin, QFontComboBox)         </code>","text":"Source code in <code>prettyqt/widgets/fontcombobox.py</code> <pre><code>class FontComboBox(widgets.ComboBoxMixin, QtWidgets.QFontComboBox):\n    value_changed = core.Signal(object)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.currentIndexChanged.connect(self.index_changed)\n\n    def serialize_fields(self):\n        return dict(\n            current_font=self.get_current_font(),\n            font_filters=self.get_font_filters(),\n        )\n\n    def __setstate__(self, state):\n        self.set_font_filters(*state.get(\"font_filters\", []))\n        self.setCurrentFont(state[\"current_font\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def set_font_filters(self, *filters: FontFilterStr):\n\"\"\"Set font filters.\n\n        Args:\n            filters: font filters to use\n\n        Raises:\n            InvalidParamError: invalid font filters\n        \"\"\"\n        if not filters:\n            filters = (\"all\",)\n        for item in filters:\n            if item not in FONT_FILTERS:\n                raise InvalidParamError(item, FONT_FILTERS)\n        flags = helpers.merge_flags(filters, FONT_FILTERS)\n        self.setFontFilters(flags)\n\n    def get_font_filters(self) -&gt; list[FontFilterStr]:\n\"\"\"Return list of font filters.\n\n        Returns:\n            font filter list\n        \"\"\"\n        return [k for k, v in FONT_FILTERS.items() if v &amp; self.fontFilters()]\n\n    def set_value(self, value: QtGui.QFont):\n        self.setCurrentFont(value)\n\n    def get_value(self) -&gt; gui.Font:\n        return self.get_current_font()\n\n    def get_current_font(self) -&gt; gui.Font:\n        return gui.Font(self.currentFont())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.get_font_filters","title":"<code>get_font_filters(self) -&gt; list[FontFilterStr]</code>","text":"<p>Return list of font filters.</p> <p>Returns:</p> Type Description <code>list[FontFilterStr]</code> <p>font filter list</p> Source code in <code>prettyqt/widgets/fontcombobox.py</code> <pre><code>def get_font_filters(self) -&gt; list[FontFilterStr]:\n\"\"\"Return list of font filters.\n\n    Returns:\n        font filter list\n    \"\"\"\n    return [k for k, v in FONT_FILTERS.items() if v &amp; self.fontFilters()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.set_font_filters","title":"<code>set_font_filters(self, *filters: FontFilterStr)</code>","text":"<p>Set font filters.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>FontFilterStr</code> <p>font filters to use</p> <code>()</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid font filters</p> Source code in <code>prettyqt/widgets/fontcombobox.py</code> <pre><code>def set_font_filters(self, *filters: FontFilterStr):\n\"\"\"Set font filters.\n\n    Args:\n        filters: font filters to use\n\n    Raises:\n        InvalidParamError: invalid font filters\n    \"\"\"\n    if not filters:\n        filters = (\"all\",)\n    for item in filters:\n        if item not in FONT_FILTERS:\n            raise InvalidParamError(item, FONT_FILTERS)\n    flags = helpers.merge_flags(filters, FONT_FILTERS)\n    self.setFontFilters(flags)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout","title":"<code>formlayout</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout","title":"<code> FormLayout            (LayoutMixin, QFormLayout)         </code>","text":"Source code in <code>prettyqt/widgets/formlayout.py</code> <pre><code>class FormLayout(widgets.LayoutMixin, QtWidgets.QFormLayout):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.set_size_mode(\"maximum\")\n        self.setVerticalSpacing(8)\n\n    def __setitem__(\n        self, index: int | tuple[int, RoleStr], value: str | QtWidgets.QWidget\n    ):\n        if isinstance(index, tuple):\n            row = index[0]\n            role = index[1]\n        else:\n            row = index\n            role = \"both\"\n        self.set_widget(value, row, role)\n\n    def __delitem__(self, index: int):\n        self.removeRow(index)\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QWidget | QtWidgets.QLayout]:\n        return iter(self[i] for i in range(self.count()) if self[i] is not None)\n\n    def __len__(self) -&gt; int:\n\"\"\"Needed for PySide2.\"\"\"\n        return self.rowCount()\n\n    def __add__(self, other: QtWidgets.QWidget | QtWidgets.QLayout | tuple):\n        self.add(other)\n        return self\n\n    def serialize_fields(self):\n        widget_list = []\n        positions = []\n        for i, item in enumerate(list(self)):\n            widget_list.append(item)\n            positions.append(self.get_item_position(i))\n        return dict(widgets=widget_list, positions=positions)\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __setstate__(self, state):\n        for i, (item, pos) in enumerate(zip(state[\"widgets\"], state[\"positions\"])):\n            self.set_widget(item, pos[0], pos[1])\n\n    def set_widget(\n        self, widget: str | QtWidgets.QWidget, row: int, role: RoleStr = \"both\"\n    ):\n        if isinstance(widget, str):\n            widget = widgets.Label(widget)\n        self.setWidget(row, ROLE[role], widget)\n\n    def get_widget(\n        self, row: int, role: RoleStr = \"both\"\n    ) -&gt; QtWidgets.QLayout | QtWidgets.QWidget:\n        item = self.itemAt(row, ROLE[role])\n        widget = item.widget()\n        if widget is None:\n            widget = item.layout()\n        return widget\n\n    def get_item_position(self, index: int) -&gt; tuple[int, RoleStr] | None:\n        pos = self.getItemPosition(index)  # type: ignore\n        if pos[0] == -1:  # type: ignore\n            return None\n        return pos[0], ROLE.inverse[pos[1]]  # type: ignore\n\n    def add(self, *items):\n        for i in items:\n            if isinstance(i, (QtWidgets.QWidget, QtWidgets.QLayout)):\n                self.addRow(i)\n            elif isinstance(i, tuple):\n                self.addRow(*i)\n\n    def set_row_wrap_policy(self, policy: RowWrapPolicyStr):\n\"\"\"Set row wrap policy to use.\n\n        Args:\n            policy: row wrap policy to use\n\n        Raises:\n            InvalidParamError: row wrap policy does not exist\n        \"\"\"\n        if policy not in ROW_WRAP_POLICY:\n            raise InvalidParamError(policy, ROW_WRAP_POLICY)\n        self.setRowWrapPolicy(ROW_WRAP_POLICY[policy])\n\n    def get_row_wrap_policy(self) -&gt; RowWrapPolicyStr:\n\"\"\"Return current row wrap policy.\n\n        Returns:\n            row wrap policy\n        \"\"\"\n        return ROW_WRAP_POLICY.inverse[self.rowWrapPolicy()]\n\n    def set_field_growth_policy(self, policy: FieldGrowthPolicyStr):\n\"\"\"Set field growth policy to use.\n\n        Args:\n            policy: field growth policy to use\n\n        Raises:\n            InvalidParamError: field growth policy does not exist\n        \"\"\"\n        if policy not in FIELD_GROWTH_POLICY:\n            raise InvalidParamError(policy, FIELD_GROWTH_POLICY)\n        self.setFieldGrowthPolicy(FIELD_GROWTH_POLICY[policy])\n\n    def get_field_growth_policy(self) -&gt; FieldGrowthPolicyStr:\n\"\"\"Return current field growth policy.\n\n        Returns:\n            field growth policy\n        \"\"\"\n        return FIELD_GROWTH_POLICY.inverse[self.fieldGrowthPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.__len__","title":"<code>__len__(self) -&gt; int</code>  <code>special</code>","text":"<p>Needed for PySide2.</p> Source code in <code>prettyqt/widgets/formlayout.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Needed for PySide2.\"\"\"\n    return self.rowCount()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_field_growth_policy","title":"<code>get_field_growth_policy(self) -&gt; FieldGrowthPolicyStr</code>","text":"<p>Return current field growth policy.</p> <p>Returns:</p> Type Description <code>FieldGrowthPolicyStr</code> <p>field growth policy</p> Source code in <code>prettyqt/widgets/formlayout.py</code> <pre><code>def get_field_growth_policy(self) -&gt; FieldGrowthPolicyStr:\n\"\"\"Return current field growth policy.\n\n    Returns:\n        field growth policy\n    \"\"\"\n    return FIELD_GROWTH_POLICY.inverse[self.fieldGrowthPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_row_wrap_policy","title":"<code>get_row_wrap_policy(self) -&gt; RowWrapPolicyStr</code>","text":"<p>Return current row wrap policy.</p> <p>Returns:</p> Type Description <code>RowWrapPolicyStr</code> <p>row wrap policy</p> Source code in <code>prettyqt/widgets/formlayout.py</code> <pre><code>def get_row_wrap_policy(self) -&gt; RowWrapPolicyStr:\n\"\"\"Return current row wrap policy.\n\n    Returns:\n        row wrap policy\n    \"\"\"\n    return ROW_WRAP_POLICY.inverse[self.rowWrapPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_field_growth_policy","title":"<code>set_field_growth_policy(self, policy: FieldGrowthPolicyStr)</code>","text":"<p>Set field growth policy to use.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>FieldGrowthPolicyStr</code> <p>field growth policy to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>field growth policy does not exist</p> Source code in <code>prettyqt/widgets/formlayout.py</code> <pre><code>def set_field_growth_policy(self, policy: FieldGrowthPolicyStr):\n\"\"\"Set field growth policy to use.\n\n    Args:\n        policy: field growth policy to use\n\n    Raises:\n        InvalidParamError: field growth policy does not exist\n    \"\"\"\n    if policy not in FIELD_GROWTH_POLICY:\n        raise InvalidParamError(policy, FIELD_GROWTH_POLICY)\n    self.setFieldGrowthPolicy(FIELD_GROWTH_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_row_wrap_policy","title":"<code>set_row_wrap_policy(self, policy: RowWrapPolicyStr)</code>","text":"<p>Set row wrap policy to use.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>RowWrapPolicyStr</code> <p>row wrap policy to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>row wrap policy does not exist</p> Source code in <code>prettyqt/widgets/formlayout.py</code> <pre><code>def set_row_wrap_policy(self, policy: RowWrapPolicyStr):\n\"\"\"Set row wrap policy to use.\n\n    Args:\n        policy: row wrap policy to use\n\n    Raises:\n        InvalidParamError: row wrap policy does not exist\n    \"\"\"\n    if policy not in ROW_WRAP_POLICY:\n        raise InvalidParamError(policy, ROW_WRAP_POLICY)\n    self.setRowWrapPolicy(ROW_WRAP_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame","title":"<code>frame</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin","title":"<code> FrameMixin            (WidgetMixin)         </code>","text":"Source code in <code>prettyqt/widgets/frame.py</code> <pre><code>class FrameMixin(widgets.WidgetMixin):\n    def serialize_fields(self):\n        return dict(\n            frame_shadow=self.get_frame_shadow(),\n            frame_shape=self.get_frame_shape(),\n            frame_rect=self.frameRect(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_frame_shadow(state[\"frame_shadow\"])\n        self.set_frame_shape(state[\"frame_shape\"])\n        self.setFrameRect(state[\"frame_rect\"])\n\n    def set_frame_shadow(self, style: ShadowStr):\n\"\"\"Set frame shadow.\n\n        Args:\n            style: frame style to use\n\n        Raises:\n            InvalidParamError: style does not exist\n        \"\"\"\n        if style is None:\n            return\n        if style not in SHADOW:\n            raise InvalidParamError(style, SHADOW)\n        self.setFrameShadow(SHADOW[style])\n\n    def get_frame_shadow(self) -&gt; ShadowStr | None:\n\"\"\"Return current frame shadow.\n\n        Returns:\n            frame style\n        \"\"\"\n        if (frame_shadow := self.frameShadow()) == 0:\n            return None\n        return SHADOW.inverse[frame_shadow]\n\n    def set_frame_shape(self, shape: FrameShapeStr):\n\"\"\"Set frame shape.\n\n        Args:\n            shape: frame shape to use\n\n        Raises:\n            InvalidParamError: shape does not exist\n        \"\"\"\n        if shape not in FRAME_SHAPE:\n            raise InvalidParamError(shape, FRAME_SHAPE)\n        self.setFrameShape(FRAME_SHAPE[shape])\n\n    def get_frame_shape(self) -&gt; FrameShapeStr:\n\"\"\"Return current frame shape.\n\n        Returns:\n            frame shape\n        \"\"\"\n        return FRAME_SHAPE.inverse[self.frameShape()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.get_frame_shadow","title":"<code>get_frame_shadow(self) -&gt; ShadowStr | None</code>","text":"<p>Return current frame shadow.</p> <p>Returns:</p> Type Description <code>ShadowStr | None</code> <p>frame style</p> Source code in <code>prettyqt/widgets/frame.py</code> <pre><code>def get_frame_shadow(self) -&gt; ShadowStr | None:\n\"\"\"Return current frame shadow.\n\n    Returns:\n        frame style\n    \"\"\"\n    if (frame_shadow := self.frameShadow()) == 0:\n        return None\n    return SHADOW.inverse[frame_shadow]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.get_frame_shape","title":"<code>get_frame_shape(self) -&gt; FrameShapeStr</code>","text":"<p>Return current frame shape.</p> <p>Returns:</p> Type Description <code>FrameShapeStr</code> <p>frame shape</p> Source code in <code>prettyqt/widgets/frame.py</code> <pre><code>def get_frame_shape(self) -&gt; FrameShapeStr:\n\"\"\"Return current frame shape.\n\n    Returns:\n        frame shape\n    \"\"\"\n    return FRAME_SHAPE.inverse[self.frameShape()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.set_frame_shadow","title":"<code>set_frame_shadow(self, style: ShadowStr)</code>","text":"<p>Set frame shadow.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>ShadowStr</code> <p>frame style to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>style does not exist</p> Source code in <code>prettyqt/widgets/frame.py</code> <pre><code>def set_frame_shadow(self, style: ShadowStr):\n\"\"\"Set frame shadow.\n\n    Args:\n        style: frame style to use\n\n    Raises:\n        InvalidParamError: style does not exist\n    \"\"\"\n    if style is None:\n        return\n    if style not in SHADOW:\n        raise InvalidParamError(style, SHADOW)\n    self.setFrameShadow(SHADOW[style])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.frame.FrameMixin.set_frame_shape","title":"<code>set_frame_shape(self, shape: FrameShapeStr)</code>","text":"<p>Set frame shape.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>FrameShapeStr</code> <p>frame shape to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>shape does not exist</p> Source code in <code>prettyqt/widgets/frame.py</code> <pre><code>def set_frame_shape(self, shape: FrameShapeStr):\n\"\"\"Set frame shape.\n\n    Args:\n        shape: frame shape to use\n\n    Raises:\n        InvalidParamError: shape does not exist\n    \"\"\"\n    if shape not in FRAME_SHAPE:\n        raise InvalidParamError(shape, FRAME_SHAPE)\n    self.setFrameShape(FRAME_SHAPE[shape])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture","title":"<code>gesture</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin","title":"<code> GestureMixin            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/widgets/gesture.py</code> <pre><code>class GestureMixin(core.ObjectMixin):\n    def get_state(self) -&gt; constants.GestureStateStr:\n\"\"\"Return current state.\n\n        Returns:\n            state\n        \"\"\"\n        return constants.GESTURE_STATE.inverse[self.state()]\n\n    def get_gesture_type(self) -&gt; constants.GestureTypeStr:\n\"\"\"Return current gesture type.\n\n        Returns:\n            gesture type\n        \"\"\"\n        return constants.GESTURE_TYPE.inverse[self.gestureType()]\n\n    def get_hot_spot(self) -&gt; core.PointF:\n        return core.PointF(self.hotSpot())\n\n    def set_gesture_cancel_policy(self, policy: GestureCancelPolicyStr):\n\"\"\"Set gesture cancel policy.\n\n        Args:\n            policy: gesture cancel policy to use\n\n        Raises:\n            InvalidParamError: gesture cancel policy does not exist\n        \"\"\"\n        if policy not in GESTURE_CANCEL_POLICY:\n            raise InvalidParamError(policy, GESTURE_CANCEL_POLICY)\n        self.setGestureCancelPolicy(GESTURE_CANCEL_POLICY[policy])\n\n    def get_gesture_cancel_policy(self) -&gt; GestureCancelPolicyStr:\n\"\"\"Return current gesture cancel policy.\n\n        Returns:\n            gesture cancel policy\n        \"\"\"\n        return GESTURE_CANCEL_POLICY.inverse[self.gestureCancelPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.get_gesture_cancel_policy","title":"<code>get_gesture_cancel_policy(self) -&gt; GestureCancelPolicyStr</code>","text":"<p>Return current gesture cancel policy.</p> <p>Returns:</p> Type Description <code>GestureCancelPolicyStr</code> <p>gesture cancel policy</p> Source code in <code>prettyqt/widgets/gesture.py</code> <pre><code>def get_gesture_cancel_policy(self) -&gt; GestureCancelPolicyStr:\n\"\"\"Return current gesture cancel policy.\n\n    Returns:\n        gesture cancel policy\n    \"\"\"\n    return GESTURE_CANCEL_POLICY.inverse[self.gestureCancelPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.get_gesture_type","title":"<code>get_gesture_type(self) -&gt; constants.GestureTypeStr</code>","text":"<p>Return current gesture type.</p> <p>Returns:</p> Type Description <code>constants.GestureTypeStr</code> <p>gesture type</p> Source code in <code>prettyqt/widgets/gesture.py</code> <pre><code>def get_gesture_type(self) -&gt; constants.GestureTypeStr:\n\"\"\"Return current gesture type.\n\n    Returns:\n        gesture type\n    \"\"\"\n    return constants.GESTURE_TYPE.inverse[self.gestureType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.get_state","title":"<code>get_state(self) -&gt; constants.GestureStateStr</code>","text":"<p>Return current state.</p> <p>Returns:</p> Type Description <code>constants.GestureStateStr</code> <p>state</p> Source code in <code>prettyqt/widgets/gesture.py</code> <pre><code>def get_state(self) -&gt; constants.GestureStateStr:\n\"\"\"Return current state.\n\n    Returns:\n        state\n    \"\"\"\n    return constants.GESTURE_STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gesture.GestureMixin.set_gesture_cancel_policy","title":"<code>set_gesture_cancel_policy(self, policy: GestureCancelPolicyStr)</code>","text":"<p>Set gesture cancel policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>GestureCancelPolicyStr</code> <p>gesture cancel policy to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>gesture cancel policy does not exist</p> Source code in <code>prettyqt/widgets/gesture.py</code> <pre><code>def set_gesture_cancel_policy(self, policy: GestureCancelPolicyStr):\n\"\"\"Set gesture cancel policy.\n\n    Args:\n        policy: gesture cancel policy to use\n\n    Raises:\n        InvalidParamError: gesture cancel policy does not exist\n    \"\"\"\n    if policy not in GESTURE_CANCEL_POLICY:\n        raise InvalidParamError(policy, GESTURE_CANCEL_POLICY)\n    self.setGestureCancelPolicy(GESTURE_CANCEL_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem","title":"<code>graphicsitem</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin","title":"<code> GraphicsItemMixin        </code>","text":"Source code in <code>prettyqt/widgets/graphicsitem.py</code> <pre><code>class GraphicsItemMixin:\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    def __contains__(self, value: QtCore.QPointF) -&gt; bool:\n        return self.contains(value)\n\n    def __getitem__(self, key: int):\n        return self.data(key)\n\n    def __setitem__(self, key: int, value):\n        self.setData(key, value)\n\n    def serialize_fields(self):\n        return dict(\n            cache_mode=self.get_cache_mode(),\n            accept_drops=self.acceptDrops(),\n            accept_hover_events=self.acceptHoverEvents(),\n            accept_touch_events=self.acceptTouchEvents(),\n            bounding_region_granularity=self.boundingRegionGranularity(),\n            enabled=self.isEnabled(),\n            filters_child_events=self.filtersChildEvents(),\n            opacity=self.opacity(),\n            panel_modality=self.get_panel_modality(),\n            pos=self.pos(),\n            rotation=self.rotation(),\n            scale=self.scale(),\n            selected=self.isSelected(),\n            tool_tip=self.toolTip(),\n            transform_origin_point=self.transformOriginPoint(),\n            visible=self.isVisible(),\n            z_value=self.zValue(),\n        )\n\n    def set_focus(self, reason: constants.FocusReasonStr = \"other\"):\n        if reason not in constants.FOCUS_REASONS:\n            raise InvalidParamError(reason, constants.FOCUS_REASONS)\n        self.setFocus(constants.FOCUS_REASONS[reason])\n\n    def colliding_items(\n        self, mode: constants.ItemSelectionModeStr = \"intersects_shape\"\n    ) -&gt; list[QtWidgets.QGraphicsItem]:\n        if mode not in constants.ITEM_SELECTION_MODE:\n            raise InvalidParamError(mode, constants.ITEM_SELECTION_MODE)\n        return self.collidingItems(constants.ITEM_SELECTION_MODE[mode])\n\n    def collides_with(\n        self,\n        item: QtGui.QPainterPath | QtWidgets.QGraphicsItem,\n        mode: constants.ItemSelectionModeStr = \"intersects_shape\",\n    ) -&gt; bool:\n        if mode not in constants.ITEM_SELECTION_MODE:\n            raise InvalidParamError(mode, constants.ITEM_SELECTION_MODE)\n        if isinstance(item, QtGui.QPainterPath):\n            return self.collidesWithPath(item, constants.ITEM_SELECTION_MODE[mode])\n        else:\n            return self.collidesWithItem(item, constants.ITEM_SELECTION_MODE[mode])\n\n    def set_panel_modality(self, modality: PanelModalityStr) -&gt; None:\n\"\"\"Set panel modality.\n\n        Args:\n            modality: panel modality\n\n        Raises:\n            InvalidParamError: panel modality does not exist\n        \"\"\"\n        if modality not in PANEL_MODALITY:\n            raise InvalidParamError(modality, PANEL_MODALITY)\n        self.setPanelModality(PANEL_MODALITY[modality])\n\n    def get_panel_modality(self) -&gt; PanelModalityStr:\n\"\"\"Get the current modality modes as a string.\n\n        Returns:\n            panel modality\n        \"\"\"\n        return PANEL_MODALITY.inverse[self.panelModality()]\n\n    def set_cache_mode(self, mode: CacheModeStr) -&gt; None:\n\"\"\"Set cache mode.\n\n        Args:\n            mode: cache mode\n\n        Raises:\n            InvalidParamError: cache mode does not exist\n        \"\"\"\n        if mode not in CACHE_MODE:\n            raise InvalidParamError(mode, CACHE_MODE)\n        self.setCacheMode(CACHE_MODE[mode])\n\n    def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current mode modes as a string.\n\n        Returns:\n            cache mode\n        \"\"\"\n        return CACHE_MODE.inverse[self.cacheMode()]\n\n    def get_shape(self) -&gt; gui.PainterPath:\n        return gui.PainterPath(self.shape())\n\n    def set_scale(self, scale: tuple[float, float] | float):\n        if isinstance(scale, float):\n            self.setScale(scale)\n        else:\n            self.setTransform(gui.Transform.fromScale(scale[0], scale[1]), True)\n\n    def set_transform(self, transform: datatypes.TransformType, combine: bool = False):\n        if isinstance(transform, tuple):\n            transform = gui.Transform(*transform)\n        self.setTransform(transform, combine)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.get_cache_mode","title":"<code>get_cache_mode(self) -&gt; CacheModeStr</code>","text":"<p>Get the current mode modes as a string.</p> <p>Returns:</p> Type Description <code>CacheModeStr</code> <p>cache mode</p> Source code in <code>prettyqt/widgets/graphicsitem.py</code> <pre><code>def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Get the current mode modes as a string.\n\n    Returns:\n        cache mode\n    \"\"\"\n    return CACHE_MODE.inverse[self.cacheMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.get_panel_modality","title":"<code>get_panel_modality(self) -&gt; PanelModalityStr</code>","text":"<p>Get the current modality modes as a string.</p> <p>Returns:</p> Type Description <code>PanelModalityStr</code> <p>panel modality</p> Source code in <code>prettyqt/widgets/graphicsitem.py</code> <pre><code>def get_panel_modality(self) -&gt; PanelModalityStr:\n\"\"\"Get the current modality modes as a string.\n\n    Returns:\n        panel modality\n    \"\"\"\n    return PANEL_MODALITY.inverse[self.panelModality()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.set_cache_mode","title":"<code>set_cache_mode(self, mode: CacheModeStr) -&gt; None</code>","text":"<p>Set cache mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CacheModeStr</code> <p>cache mode</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>cache mode does not exist</p> Source code in <code>prettyqt/widgets/graphicsitem.py</code> <pre><code>def set_cache_mode(self, mode: CacheModeStr) -&gt; None:\n\"\"\"Set cache mode.\n\n    Args:\n        mode: cache mode\n\n    Raises:\n        InvalidParamError: cache mode does not exist\n    \"\"\"\n    if mode not in CACHE_MODE:\n        raise InvalidParamError(mode, CACHE_MODE)\n    self.setCacheMode(CACHE_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItemMixin.set_panel_modality","title":"<code>set_panel_modality(self, modality: PanelModalityStr) -&gt; None</code>","text":"<p>Set panel modality.</p> <p>Parameters:</p> Name Type Description Default <code>modality</code> <code>PanelModalityStr</code> <p>panel modality</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>panel modality does not exist</p> Source code in <code>prettyqt/widgets/graphicsitem.py</code> <pre><code>def set_panel_modality(self, modality: PanelModalityStr) -&gt; None:\n\"\"\"Set panel modality.\n\n    Args:\n        modality: panel modality\n\n    Raises:\n        InvalidParamError: panel modality does not exist\n    \"\"\"\n    if modality not in PANEL_MODALITY:\n        raise InvalidParamError(modality, PANEL_MODALITY)\n    self.setPanelModality(PANEL_MODALITY[modality])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem","title":"<code>graphicspixmapitem</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem","title":"<code> GraphicsPixmapItem            (GraphicsItemMixin, QGraphicsPixmapItem)         </code>","text":"Source code in <code>prettyqt/widgets/graphicspixmapitem.py</code> <pre><code>class GraphicsPixmapItem(widgets.GraphicsItemMixin, QtWidgets.QGraphicsPixmapItem):\n    def serialize_fields(self):\n        return dict(\n            offset=self.offset(),\n            pixmap=self.get_pixmap(),\n            shape_mode=self.get_shape_mode(),\n            transformation_mode=self.get_transformation_mode(),\n        )\n\n    def set_transformation_mode(self, mode: constants.TransformationModeStr):\n\"\"\"Set transformation mode.\n\n        Args:\n            mode: transformation mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in constants.TRANSFORMATION_MODE:\n            raise InvalidParamError(mode, constants.TRANSFORMATION_MODE)\n        self.setTransformationMode(constants.TRANSFORMATION_MODE[mode])\n\n    def get_transformation_mode(self) -&gt; constants.TransformationModeStr:\n\"\"\"Return current transformation mode.\n\n        Returns:\n            transformation mode\n        \"\"\"\n        return constants.TRANSFORMATION_MODE.inverse[self.transformationMode()]\n\n    def set_shape_mode(self, mode: ShapeModeStr):\n\"\"\"Set shape mode.\n\n        Args:\n            mode: shape mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in SHAPE_MODE:\n            raise InvalidParamError(mode, SHAPE_MODE)\n        self.setShapeMode(SHAPE_MODE[mode])\n\n    def get_shape_mode(self) -&gt; ShapeModeStr:\n\"\"\"Return current shape mode.\n\n        Returns:\n            shape mode\n        \"\"\"\n        return SHAPE_MODE.inverse[self.shapeMode()]\n\n    def get_pixmap(self) -&gt; gui.Pixmap | None:\n        pix = self.pixmap()\n        if pix.isNull():\n            return None\n        return gui.Pixmap(pix)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.get_shape_mode","title":"<code>get_shape_mode(self) -&gt; ShapeModeStr</code>","text":"<p>Return current shape mode.</p> <p>Returns:</p> Type Description <code>ShapeModeStr</code> <p>shape mode</p> Source code in <code>prettyqt/widgets/graphicspixmapitem.py</code> <pre><code>def get_shape_mode(self) -&gt; ShapeModeStr:\n\"\"\"Return current shape mode.\n\n    Returns:\n        shape mode\n    \"\"\"\n    return SHAPE_MODE.inverse[self.shapeMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.get_transformation_mode","title":"<code>get_transformation_mode(self) -&gt; constants.TransformationModeStr</code>","text":"<p>Return current transformation mode.</p> <p>Returns:</p> Type Description <code>constants.TransformationModeStr</code> <p>transformation mode</p> Source code in <code>prettyqt/widgets/graphicspixmapitem.py</code> <pre><code>def get_transformation_mode(self) -&gt; constants.TransformationModeStr:\n\"\"\"Return current transformation mode.\n\n    Returns:\n        transformation mode\n    \"\"\"\n    return constants.TRANSFORMATION_MODE.inverse[self.transformationMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.set_shape_mode","title":"<code>set_shape_mode(self, mode: ShapeModeStr)</code>","text":"<p>Set shape mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ShapeModeStr</code> <p>shape mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/widgets/graphicspixmapitem.py</code> <pre><code>def set_shape_mode(self, mode: ShapeModeStr):\n\"\"\"Set shape mode.\n\n    Args:\n        mode: shape mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in SHAPE_MODE:\n        raise InvalidParamError(mode, SHAPE_MODE)\n    self.setShapeMode(SHAPE_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicspixmapitem.GraphicsPixmapItem.set_transformation_mode","title":"<code>set_transformation_mode(self, mode: constants.TransformationModeStr)</code>","text":"<p>Set transformation mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.TransformationModeStr</code> <p>transformation mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/widgets/graphicspixmapitem.py</code> <pre><code>def set_transformation_mode(self, mode: constants.TransformationModeStr):\n\"\"\"Set transformation mode.\n\n    Args:\n        mode: transformation mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in constants.TRANSFORMATION_MODE:\n        raise InvalidParamError(mode, constants.TRANSFORMATION_MODE)\n    self.setTransformationMode(constants.TRANSFORMATION_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene","title":"<code>graphicsscene</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene","title":"<code> GraphicsScene            (ObjectMixin, QGraphicsScene)         </code>","text":"Source code in <code>prettyqt/widgets/graphicsscene.py</code> <pre><code>class GraphicsScene(core.ObjectMixin, QtWidgets.QGraphicsScene):\n    def serialize_fields(self):\n        return dict(\n            items=self.items(),\n            background_brush=self.get_background_brush(),\n            foreground_brush=self.get_foreground_brush(),\n            item_index_method=self.get_item_index_method(),\n            minimum_render_size=self.minimumRenderSize(),\n            palette=self.get_palette(),\n            bsp_tree_depth=self.bspTreeDepth(),\n            focus_on_touch=self.focusOnTouch(),\n            sticky_focus=self.stickyFocus(),\n            scene_rect=core.RectF(self.sceneRect()),\n            font=self.get_font(),\n        )\n\n    def __setitem__(self, state):\n        # self.setItem\n        self.setBackgroundBrush(state[\"background_brush\"])\n        self.setForegroundBrush(state[\"foreground_brush\"])\n        self.set_item_index_method(state[\"item_index_method\"])\n        self.setMinimumRenderSize(state[\"minimum_render_size\"])\n        self.setPalette(state[\"palette\"])\n        self.setBspTreeDepth(state[\"bsp_tree_depth\"])\n        self.setFocusOnTouchRelease(state[\"focus_on_touch\"])\n        self.setStickyFocus(state[\"focus_on_touch\"])\n        self.setSceneRect(state[\"scene_rect\"])\n        self.setFont(state[\"font\"])\n\n    def __getitem__(self, index: int) -&gt; QtWidgets.QGraphicsItem:\n        return self.items()[index]\n\n    def get_palette(self) -&gt; gui.Palette:\n        return gui.Palette(self.palette())\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_background_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.backgroundBrush())\n\n    def get_foreground_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.foregroundBrush())\n\n    def add(self, item) -&gt; QtWidgets.QGraphicsItem:\n        match item:\n            case QtWidgets.QGraphicsItem():\n                self.addItem(item)\n                return item\n            case QtGui.QPixmap():\n                return self.add_pixmap(item)\n            case QtGui.QPainterPath():\n                return self.add_path(item)\n            case QtGui.QPolygonF():\n                return self.add_polygon(item)\n            case QtCore.QRectF():\n                return self.add_rect(item)\n            case QtCore.QLine():\n                return self.add_line(item)\n            case str():\n                return self.add_text(item)\n            case QtWidgets.QWidget():\n                return self.add_widget(item)\n            case _:\n                raise TypeError(item)\n\n    def add_pixmap(self, pixmap: QtGui.QPixmap) -&gt; widgets.GraphicsPixmapItem:\n        g_item = widgets.GraphicsPixmapItem()\n        g_item.setPixmap(pixmap)\n        self.addItem(g_item)\n        return g_item\n\n    def add_polygon(\n        self,\n        polygon: QtGui.QPolygonF | QtGui.QPolygon,\n        pen: QtGui.QPen | None = None,\n        brush: QtGui.QBrush | None = None,\n    ) -&gt; widgets.GraphicsPolygonItem:\n        if isinstance(polygon, QtGui.QPolygon):\n            polygon = gui.PolygonF(polygon)\n        g_item = widgets.GraphicsPolygonItem()\n        g_item.setPolygon(polygon)\n        if brush is not None:\n            g_item.setBrush(brush)\n        if pen is not None:\n            g_item.setPen(pen)\n        self.addItem(g_item)\n        return g_item\n\n    def add_path(\n        self,\n        path: QtGui.QPainterPath,\n        pen: QtGui.QPen | None = None,\n        brush: QtGui.QBrush | None = None,\n    ) -&gt; widgets.GraphicsPathItem:\n        g_item = widgets.GraphicsPathItem()\n        g_item.setPath(path)\n        if brush is not None:\n            g_item.setBrush(brush)\n        if pen is not None:\n            g_item.setPen(pen)\n        self.addItem(g_item)\n        return g_item\n\n    def add_rect(\n        self,\n        rect: datatypes.RectType | datatypes.RectFType,\n        pen: QtGui.QPen | None = None,\n        brush: QtGui.QBrush | None = None,\n    ) -&gt; widgets.GraphicsRectItem:\n        if isinstance(rect, QtCore.QRect):\n            rect = core.RectF(rect)\n        elif isinstance(rect, tuple):\n            rect = core.RectF(*rect)\n        g_item = widgets.GraphicsRectItem()\n        g_item.setRect(rect)\n        if brush is not None:\n            g_item.setBrush(brush)\n        if pen is not None:\n            g_item.setPen(pen)\n        self.addItem(g_item)\n        return g_item\n\n    def add_line(\n        self,\n        line: QtCore.QLineF | QtCore.QLine | tuple[float, float, float, float],\n        pen: QtGui.QPen | None = None,\n    ) -&gt; widgets.GraphicsLineItem:\n        if isinstance(line, QtCore.QLine):\n            line = core.LineF(line)\n        elif isinstance(line, tuple):\n            line = core.LineF(*line)\n        g_item = widgets.GraphicsLineItem()\n        g_item.setLine(line)\n        if pen is not None:\n            g_item.setPen(pen)\n        self.addItem(g_item)\n        return g_item\n\n    def add_ellipse(\n        self,\n        ellipse: datatypes.RectType | datatypes.RectFType,\n        pen: QtGui.QPen | None = None,\n        brush: QtGui.QBrush | None = None,\n    ) -&gt; widgets.GraphicsEllipseItem:\n        if isinstance(ellipse, QtCore.QRect):\n            ellipse = core.RectF(ellipse)\n        elif isinstance(ellipse, tuple):\n            ellipse = core.RectF(*ellipse)\n        g_item = widgets.GraphicsEllipseItem()\n        g_item.setRect(ellipse)\n        if brush is not None:\n            g_item.setBrush(brush)\n        if pen is not None:\n            g_item.setPen(pen)\n        self.addItem(g_item)\n        return g_item\n\n    def add_text(\n        self, text: str, font: QtGui.QFont | None = None\n    ) -&gt; widgets.GraphicsTextItem:\n        g_item = widgets.GraphicsTextItem()\n        g_item.setPlainText(text)\n        if font is not None:\n            g_item.setFont(font)\n        self.addItem(g_item)\n        return g_item\n\n    def add_simple_text(\n        self, text: str, font: QtGui.QFont | None = None\n    ) -&gt; widgets.GraphicsSimpleTextItem:\n        g_item = widgets.GraphicsSimpleTextItem()\n        g_item.setText(text)\n        if font is not None:\n            g_item.setFont(font)\n        self.addItem(g_item)\n        return g_item\n\n    def add_widget(self, widget: QtWidgets.QWidget) -&gt; widgets.GraphicsProxyWidget:\n        g_item = widgets.GraphicsProxyWidget()\n        g_item.setWidget(widget)\n        self.addItem(g_item)\n        return g_item\n\n    def colliding_items(\n        self,\n        item: QtWidgets.QGraphicsItem,\n        mode: constants.ItemSelectionModeStr = \"intersects_shape\",\n    ) -&gt; list[QtWidgets.QGraphicsItem]:\n        if mode not in constants.ITEM_SELECTION_MODE:\n            raise InvalidParamError(mode, constants.ITEM_SELECTION_MODE)\n        return self.collidingItems(item, constants.ITEM_SELECTION_MODE[mode])\n\n    def add_item_group(\n        self, *items: QtWidgets.QGraphicsItem\n    ) -&gt; widgets.GraphicsItemGroup:\n        group = widgets.GraphicsItemGroup()\n        for item in items:\n            group.addToGroup(item)\n        return group\n\n    def set_item_index_method(self, method: ItemIndexMethodStr):\n\"\"\"Set item index method.\n\n        Args:\n            method: item index method to use\n\n        Raises:\n            InvalidParamError: invalid item index method\n        \"\"\"\n        if method not in ITEM_INDEX_METHOD:\n            raise InvalidParamError(method, ITEM_INDEX_METHOD)\n        self.setItemIndexMethod(ITEM_INDEX_METHOD[method])\n\n    def get_item_index_method(self) -&gt; ItemIndexMethodStr:\n\"\"\"Return item index method.\n\n        Returns:\n            item index method\n        \"\"\"\n        return ITEM_INDEX_METHOD.inverse[self.itemIndexMethod()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.get_item_index_method","title":"<code>get_item_index_method(self) -&gt; ItemIndexMethodStr</code>","text":"<p>Return item index method.</p> <p>Returns:</p> Type Description <code>ItemIndexMethodStr</code> <p>item index method</p> Source code in <code>prettyqt/widgets/graphicsscene.py</code> <pre><code>def get_item_index_method(self) -&gt; ItemIndexMethodStr:\n\"\"\"Return item index method.\n\n    Returns:\n        item index method\n    \"\"\"\n    return ITEM_INDEX_METHOD.inverse[self.itemIndexMethod()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.set_item_index_method","title":"<code>set_item_index_method(self, method: ItemIndexMethodStr)</code>","text":"<p>Set item index method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>ItemIndexMethodStr</code> <p>item index method to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid item index method</p> Source code in <code>prettyqt/widgets/graphicsscene.py</code> <pre><code>def set_item_index_method(self, method: ItemIndexMethodStr):\n\"\"\"Set item index method.\n\n    Args:\n        method: item index method to use\n\n    Raises:\n        InvalidParamError: invalid item index method\n    \"\"\"\n    if method not in ITEM_INDEX_METHOD:\n        raise InvalidParamError(method, ITEM_INDEX_METHOD)\n    self.setItemIndexMethod(ITEM_INDEX_METHOD[method])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview","title":"<code>graphicsview</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin","title":"<code> GraphicsViewMixin            (AbstractScrollAreaMixin)         </code>","text":"Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>class GraphicsViewMixin(widgets.AbstractScrollAreaMixin):\n    def serialize_fields(self):\n        return dict(\n            scene=self.scene(),\n            background_brush=self.get_background_brush(),\n            foreground_brush=self.get_foreground_brush(),\n            transformation_anchor=self.get_transformation_anchor(),\n            resize_anchor=self.get_resize_anchor(),\n            viewport_update_mode=self.get_viewport_update_mode(),\n            drag_mode=self.get_drag_mode(),\n            rubberband_selection_mode=self.get_rubberband_selection_mode(),\n            scene_rect=core.RectF(self.sceneRect()),\n            cache_mode=self.get_cache_mode(),\n            is_interactive=self.isInteractive(),\n        )\n\n    def __setitem__(self, state):\n        super().__setstate__(state)\n        self.setScene(state[\"scene\"])\n        self.setBackgroundBrush(state[\"background_brush\"])\n        self.setForegroundBrush(state[\"foreground_brush\"])\n        self.set_transformation_anchor(state[\"transformation_anchor\"])\n        self.set_resize_anchor(state[\"resicze_anchor\"])\n        self.set_viewport_update_mode(state[\"viewport_update_mode\"])\n        self.set_drag_mode(state[\"drag_mode\"])\n        self.set_rubberband_selection_mode(state[\"rubberband_selection_mode\"])\n        self.setSceneRect(state[\"scene_rect\"])\n        self.set_cache_mode(state[\"cache_mode\"])\n        self.setInteractive(state[\"is_interactive\"])\n\n    def __getitem__(self, index: int) -&gt; QtWidgets.QGraphicsItem:\n        return self.items()[index]\n\n    def get_background_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.backgroundBrush())\n\n    def get_foreground_brush(self) -&gt; gui.Brush:\n        return gui.Brush(self.foregroundBrush())\n\n    def invalidate_scene(\n        self, rect: QtCore.QRectF, layer: widgets.graphicsscene.SceneLayerStr = \"all\"\n    ):\n        if layer not in widgets.graphicsscene.SCENE_LAYER:\n            raise InvalidParamError(layer, widgets.graphicsscene.SCENE_LAYER)\n        self.invalidateScene(rect, widgets.graphicsscene.SCENE_LAYER[layer])\n\n    def set_transformation_anchor(self, mode: ViewportAnchorStr):\n\"\"\"Set how the view should position the scene during transformations.\n\n        Args:\n            mode: transformation anchor to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in VIEWPORT_ANCHOR:\n            raise InvalidParamError(mode, VIEWPORT_ANCHOR)\n        self.setTransformationAnchor(VIEWPORT_ANCHOR[mode])\n\n    def get_transformation_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current transformation anchor.\n\n        Returns:\n            viewport anchor\n        \"\"\"\n        return VIEWPORT_ANCHOR.inverse[self.transformationAnchor()]\n\n    def set_transform(self, transform: datatypes.TransformType, combine: bool = False):\n        if isinstance(transform, tuple):\n            transform = gui.Transform(*transform)\n        self.setTransform(transform, combine)\n\n    def set_resize_anchor(self, mode: ViewportAnchorStr):\n\"\"\"Set how the view should position the scene during resizes.\n\n        Args:\n            mode: resize anchor to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in VIEWPORT_ANCHOR:\n            raise InvalidParamError(mode, VIEWPORT_ANCHOR)\n        self.setResizeAnchor(VIEWPORT_ANCHOR[mode])\n\n    def get_resize_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current resize anchor.\n\n        Returns:\n            resize anchor\n        \"\"\"\n        return VIEWPORT_ANCHOR.inverse[self.resizeAnchor()]\n\n    def set_viewport_update_mode(self, mode: ViewportUpdateModeStr):\n\"\"\"Set how the viewport should update its contents.\n\n        Args:\n            mode: viewport update mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in VIEWPORT_UPDATE_MODE:\n            raise InvalidParamError(mode, VIEWPORT_UPDATE_MODE)\n        self.setViewportUpdateMode(VIEWPORT_UPDATE_MODE[mode])\n\n    def get_viewport_update_mode(self) -&gt; ViewportUpdateModeStr:\n\"\"\"Return current viewport update mode.\n\n        Returns:\n            viewport update mode\n        \"\"\"\n        return VIEWPORT_UPDATE_MODE.inverse[self.viewportUpdateMode()]\n\n    def set_drag_mode(self, mode: DragModeStr):\n\"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed.\n\n        Args:\n            mode: drag mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in DRAG_MODE:\n            raise InvalidParamError(mode, DRAG_MODE)\n        self.setDragMode(DRAG_MODE[mode])\n\n    def get_drag_mode(self) -&gt; DragModeStr:\n\"\"\"Return current drag mode.\n\n        Returns:\n            drag mode\n        \"\"\"\n        return DRAG_MODE.inverse[self.dragMode()]\n\n    def set_rubberband_selection_mode(self, mode: constants.ItemSelectionModeStr):\n\"\"\"Set the behavior for selecting items with a rubber band selection rectangle.\n\n        Args:\n            mode: rubberband selection mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in constants.ITEM_SELECTION_MODE:\n            raise InvalidParamError(mode, constants.ITEM_SELECTION_MODE)\n        self.setRubberBandSelectionMode(constants.ITEM_SELECTION_MODE[mode])\n\n    def get_rubberband_selection_mode(self) -&gt; constants.ItemSelectionModeStr:\n\"\"\"Return current rubberband selection mode.\n\n        Returns:\n            rubberband selection mode\n        \"\"\"\n        return constants.ITEM_SELECTION_MODE.inverse[self.rubberBandSelectionMode()]\n\n    def set_cache_mode(self, mode: CacheModeStr):\n\"\"\"Set the cache mode.\n\n        Args:\n            mode: cache mode to use\n\n        Raises:\n            InvalidParamError: mode does not exist\n        \"\"\"\n        if mode not in CACHE_MODES:\n            raise InvalidParamError(mode, CACHE_MODES)\n        self.setCacheMode(CACHE_MODES[mode])\n\n    def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Return current cache mode.\n\n        Returns:\n            cache mode\n        \"\"\"\n        return CACHE_MODES.inverse[self.cacheMode()]\n\n    def set_optimization_flags(self, *items: OptimizationFlagStr):\n        for item in items:\n            if item not in OPTIMIZATION_FLAGS:\n                raise InvalidParamError(item, OPTIMIZATION_FLAGS)\n        flags = helpers.merge_flags(items, OPTIMIZATION_FLAGS)\n        self.setOptimizationFlags(flags)\n\n    def get_optimization_flags(self) -&gt; list[OptimizationFlagStr]:\n        return [k for k, v in OPTIMIZATION_FLAGS.items() if v &amp; self.optimizationFlags()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_cache_mode","title":"<code>get_cache_mode(self) -&gt; CacheModeStr</code>","text":"<p>Return current cache mode.</p> <p>Returns:</p> Type Description <code>CacheModeStr</code> <p>cache mode</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def get_cache_mode(self) -&gt; CacheModeStr:\n\"\"\"Return current cache mode.\n\n    Returns:\n        cache mode\n    \"\"\"\n    return CACHE_MODES.inverse[self.cacheMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_drag_mode","title":"<code>get_drag_mode(self) -&gt; DragModeStr</code>","text":"<p>Return current drag mode.</p> <p>Returns:</p> Type Description <code>DragModeStr</code> <p>drag mode</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def get_drag_mode(self) -&gt; DragModeStr:\n\"\"\"Return current drag mode.\n\n    Returns:\n        drag mode\n    \"\"\"\n    return DRAG_MODE.inverse[self.dragMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_resize_anchor","title":"<code>get_resize_anchor(self) -&gt; ViewportAnchorStr</code>","text":"<p>Return current resize anchor.</p> <p>Returns:</p> Type Description <code>ViewportAnchorStr</code> <p>resize anchor</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def get_resize_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current resize anchor.\n\n    Returns:\n        resize anchor\n    \"\"\"\n    return VIEWPORT_ANCHOR.inverse[self.resizeAnchor()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_rubberband_selection_mode","title":"<code>get_rubberband_selection_mode(self) -&gt; constants.ItemSelectionModeStr</code>","text":"<p>Return current rubberband selection mode.</p> <p>Returns:</p> Type Description <code>constants.ItemSelectionModeStr</code> <p>rubberband selection mode</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def get_rubberband_selection_mode(self) -&gt; constants.ItemSelectionModeStr:\n\"\"\"Return current rubberband selection mode.\n\n    Returns:\n        rubberband selection mode\n    \"\"\"\n    return constants.ITEM_SELECTION_MODE.inverse[self.rubberBandSelectionMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_transformation_anchor","title":"<code>get_transformation_anchor(self) -&gt; ViewportAnchorStr</code>","text":"<p>Return current transformation anchor.</p> <p>Returns:</p> Type Description <code>ViewportAnchorStr</code> <p>viewport anchor</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def get_transformation_anchor(self) -&gt; ViewportAnchorStr:\n\"\"\"Return current transformation anchor.\n\n    Returns:\n        viewport anchor\n    \"\"\"\n    return VIEWPORT_ANCHOR.inverse[self.transformationAnchor()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.get_viewport_update_mode","title":"<code>get_viewport_update_mode(self) -&gt; ViewportUpdateModeStr</code>","text":"<p>Return current viewport update mode.</p> <p>Returns:</p> Type Description <code>ViewportUpdateModeStr</code> <p>viewport update mode</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def get_viewport_update_mode(self) -&gt; ViewportUpdateModeStr:\n\"\"\"Return current viewport update mode.\n\n    Returns:\n        viewport update mode\n    \"\"\"\n    return VIEWPORT_UPDATE_MODE.inverse[self.viewportUpdateMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_cache_mode","title":"<code>set_cache_mode(self, mode: CacheModeStr)</code>","text":"<p>Set the cache mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CacheModeStr</code> <p>cache mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def set_cache_mode(self, mode: CacheModeStr):\n\"\"\"Set the cache mode.\n\n    Args:\n        mode: cache mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in CACHE_MODES:\n        raise InvalidParamError(mode, CACHE_MODES)\n    self.setCacheMode(CACHE_MODES[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_drag_mode","title":"<code>set_drag_mode(self, mode: DragModeStr)</code>","text":"<p>Set the behavior for dragging the mouse while the left mouse button is pressed.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>DragModeStr</code> <p>drag mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def set_drag_mode(self, mode: DragModeStr):\n\"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed.\n\n    Args:\n        mode: drag mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in DRAG_MODE:\n        raise InvalidParamError(mode, DRAG_MODE)\n    self.setDragMode(DRAG_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_resize_anchor","title":"<code>set_resize_anchor(self, mode: ViewportAnchorStr)</code>","text":"<p>Set how the view should position the scene during resizes.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewportAnchorStr</code> <p>resize anchor to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def set_resize_anchor(self, mode: ViewportAnchorStr):\n\"\"\"Set how the view should position the scene during resizes.\n\n    Args:\n        mode: resize anchor to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in VIEWPORT_ANCHOR:\n        raise InvalidParamError(mode, VIEWPORT_ANCHOR)\n    self.setResizeAnchor(VIEWPORT_ANCHOR[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_rubberband_selection_mode","title":"<code>set_rubberband_selection_mode(self, mode: constants.ItemSelectionModeStr)</code>","text":"<p>Set the behavior for selecting items with a rubber band selection rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ItemSelectionModeStr</code> <p>rubberband selection mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def set_rubberband_selection_mode(self, mode: constants.ItemSelectionModeStr):\n\"\"\"Set the behavior for selecting items with a rubber band selection rectangle.\n\n    Args:\n        mode: rubberband selection mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in constants.ITEM_SELECTION_MODE:\n        raise InvalidParamError(mode, constants.ITEM_SELECTION_MODE)\n    self.setRubberBandSelectionMode(constants.ITEM_SELECTION_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_transformation_anchor","title":"<code>set_transformation_anchor(self, mode: ViewportAnchorStr)</code>","text":"<p>Set how the view should position the scene during transformations.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewportAnchorStr</code> <p>transformation anchor to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def set_transformation_anchor(self, mode: ViewportAnchorStr):\n\"\"\"Set how the view should position the scene during transformations.\n\n    Args:\n        mode: transformation anchor to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in VIEWPORT_ANCHOR:\n        raise InvalidParamError(mode, VIEWPORT_ANCHOR)\n    self.setTransformationAnchor(VIEWPORT_ANCHOR[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsViewMixin.set_viewport_update_mode","title":"<code>set_viewport_update_mode(self, mode: ViewportUpdateModeStr)</code>","text":"<p>Set how the viewport should update its contents.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewportUpdateModeStr</code> <p>viewport update mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>mode does not exist</p> Source code in <code>prettyqt/widgets/graphicsview.py</code> <pre><code>def set_viewport_update_mode(self, mode: ViewportUpdateModeStr):\n\"\"\"Set how the viewport should update its contents.\n\n    Args:\n        mode: viewport update mode to use\n\n    Raises:\n        InvalidParamError: mode does not exist\n    \"\"\"\n    if mode not in VIEWPORT_UPDATE_MODE:\n        raise InvalidParamError(mode, VIEWPORT_UPDATE_MODE)\n    self.setViewportUpdateMode(VIEWPORT_UPDATE_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget","title":"<code>graphicswidget</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidgetMixin","title":"<code> GraphicsWidgetMixin            (GraphicsObjectMixin, GraphicsLayoutItemMixin)         </code>","text":"Source code in <code>prettyqt/widgets/graphicswidget.py</code> <pre><code>class GraphicsWidgetMixin(widgets.GraphicsObjectMixin, widgets.GraphicsLayoutItemMixin):\n    def serialize_fields(self):\n        return dict(\n            autofill_background=self.autoFillBackground(),\n            font=self.get_font(),\n            window_title=self.windowTitle(),\n            preferred_size=self.preferredSize(),\n            maximum_size=self.maximumSize(),\n            palette=self.get_palette(),\n            focus_policy=self.get_focus_policy(),\n        )\n\n    def set_layout(self, layout: LayoutStr | QtWidgets.QGraphicsLayout | None):\n        match layout:\n            case None:\n                return\n            case QtWidgets.QGraphicsLayout():\n                self.box = layout\n            case \"grid\":\n                self.box = widgets.GraphicsGridLayout()\n            case \"anchor\":\n                self.box = widgets.GraphicsAnchorLayout()\n            case \"horizontal\" | \"vertical\":\n                self.box = widgets.GraphicsLinearLayout(layout)\n            case _:\n                raise ValueError(\"Invalid Layout\")\n        self.setLayout(self.box)\n\n    def set_focus_policy(self, policy: constants.FocusPolicyStr) -&gt; None:\n\"\"\"Set the way the widget accepts keyboard focus.\n\n        Args:\n            policy: Focus policy\n\n        Raises:\n            InvalidParamError: Description\n        \"\"\"\n        if policy not in constants.FOCUS_POLICY:\n            raise InvalidParamError(policy, constants.FOCUS_POLICY)\n        self.setFocusPolicy(constants.FOCUS_POLICY[policy])\n\n    def get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return way the widget accepts keyboard focus.\n\n        Returns:\n            str: Focus policy\n        \"\"\"\n        return constants.FOCUS_POLICY.inverse[self.focusPolicy()]\n\n    def window_frame_section_at(\n        self, point: datatypes.PointType\n    ) -&gt; constants.WindowFrameSectionStr:\n\"\"\"Return the window frame section at given position.\n\n        Returns:\n            str: Window frame section\n        \"\"\"\n        if isinstance(point, tuple):\n            point = QtCore.QPoint(*point)\n        return constants.WINDOW_FRAME_SECTION.inverse[self.windowFrameSectionAt(point)]\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_palette(self) -&gt; gui.Palette:\n        return gui.Palette(self.palette())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidgetMixin.get_focus_policy","title":"<code>get_focus_policy(self) -&gt; constants.FocusPolicyStr</code>","text":"<p>Return way the widget accepts keyboard focus.</p> <p>Returns:</p> Type Description <code>str</code> <p>Focus policy</p> Source code in <code>prettyqt/widgets/graphicswidget.py</code> <pre><code>def get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return way the widget accepts keyboard focus.\n\n    Returns:\n        str: Focus policy\n    \"\"\"\n    return constants.FOCUS_POLICY.inverse[self.focusPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidgetMixin.set_focus_policy","title":"<code>set_focus_policy(self, policy: constants.FocusPolicyStr) -&gt; None</code>","text":"<p>Set the way the widget accepts keyboard focus.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>constants.FocusPolicyStr</code> <p>Focus policy</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>Description</p> Source code in <code>prettyqt/widgets/graphicswidget.py</code> <pre><code>def set_focus_policy(self, policy: constants.FocusPolicyStr) -&gt; None:\n\"\"\"Set the way the widget accepts keyboard focus.\n\n    Args:\n        policy: Focus policy\n\n    Raises:\n        InvalidParamError: Description\n    \"\"\"\n    if policy not in constants.FOCUS_POLICY:\n        raise InvalidParamError(policy, constants.FOCUS_POLICY)\n    self.setFocusPolicy(constants.FOCUS_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidgetMixin.window_frame_section_at","title":"<code>window_frame_section_at(self, point: datatypes.PointType) -&gt; constants.WindowFrameSectionStr</code>","text":"<p>Return the window frame section at given position.</p> <p>Returns:</p> Type Description <code>str</code> <p>Window frame section</p> Source code in <code>prettyqt/widgets/graphicswidget.py</code> <pre><code>def window_frame_section_at(\n    self, point: datatypes.PointType\n) -&gt; constants.WindowFrameSectionStr:\n\"\"\"Return the window frame section at given position.\n\n    Returns:\n        str: Window frame section\n    \"\"\"\n    if isinstance(point, tuple):\n        point = QtCore.QPoint(*point)\n    return constants.WINDOW_FRAME_SECTION.inverse[self.windowFrameSectionAt(point)]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout","title":"<code>gridlayout</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout","title":"<code> GridLayout            (LayoutMixin, QGridLayout)         </code>","text":"Source code in <code>prettyqt/widgets/gridlayout.py</code> <pre><code>class GridLayout(widgets.LayoutMixin, QtWidgets.QGridLayout):\n    def __getitem__(\n        self, idx: tuple[int, int] | int | str\n    ) -&gt; QtWidgets.QWidget | QtWidgets.QLayout | None:\n        if isinstance(idx, tuple):\n            item = self.itemAtPosition(*idx)\n        elif isinstance(idx, int):\n            item = self.itemAt(idx)\n        else:\n            return self.find_child(QtCore.QObject, idx)\n        widget = item.widget()\n        if widget is None:\n            return item.layout()\n        return widget\n\n    def __setitem__(\n        self,\n        idx: tuple[int | slice, int | slice],\n        value: QtWidgets.QWidget | QtWidgets.QLayout | QtWidgets.QLayoutItem,\n    ):\n        row, col = idx\n        rowspan = row.stop - row.start + 1 if isinstance(row, slice) else 1\n        colspan = col.stop - col.start + 1 if isinstance(col, slice) else 1\n        rowstart = row.start if isinstance(row, slice) else row\n        colstart = col.start if isinstance(col, slice) else col\n        self.add(value, rowstart, colstart, rowspan, colspan)\n\n    def serialize_fields(self):\n        widgets = []\n        positions = []\n        for i, item in enumerate(list(self)):\n            widgets.append(item)\n            positions.append(self.getItemPosition(i))\n        return dict(widgets=widgets, positions=positions)\n\n    def __setstate__(self, state):\n        for i, (item, pos) in enumerate(zip(state[\"widgets\"], state[\"positions\"])):\n            x, y, w, h = pos\n            self[x : x + w - 1, y : y + h - 1] = item\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QWidget | QtWidgets.QLayout]:\n        return iter(item for i in range(self.count()) if (item := self[i]) is not None)\n\n    def __add__(\n        self,\n        other: (\n            tuple | list | QtWidgets.QWidget | QtWidgets.QLayout | QtWidgets.QLayoutItem\n        ),\n    ):\n        if isinstance(other, (tuple, list)):\n            for i, control in enumerate(other):\n                self[self.rowCount(), i] = other  # type: ignore\n        else:\n            self[self.rowCount(), 0 : self.columnCount() - 1] = other\n        return self\n\n    def add(\n        self,\n        item: QtWidgets.QWidget | QtWidgets.QLayout | QtWidgets.QLayoutItem,\n        rowstart: int,\n        colstart: int,\n        rowspan: int = 1,\n        colspan: int = 1,\n    ):\n        match item:\n            case QtWidgets.QWidget():\n                self.addWidget(item, rowstart, colstart, rowspan, colspan)\n            case QtWidgets.QLayout():\n                self.addLayout(item, rowstart, colstart, rowspan, colspan)\n            case QtWidgets.QLayoutItem():\n                self.addItem(item, rowstart, colstart, rowspan, colspan)\n\n    def append(self, item: QtWidgets.QWidget | QtWidgets.QLayout | QtWidgets.QLayoutItem):\n        self[self.rowCount(), 0 : self.columnCount() - 1] = item\n\n    def set_origin_corner(self, corner: constants.CornerStr):\n\"\"\"Set the origin corner.\n\n        Args:\n            corner: origin corner\n\n        Raises:\n            InvalidParamError: corner does not exist\n        \"\"\"\n        if corner not in constants.CORNER:\n            raise InvalidParamError(corner, constants.CORNER)\n        self.setOriginCorner(constants.CORNER[corner])\n\n    def get_origin_corner(self) -&gt; constants.CornerStr:\n\"\"\"Return current origin corner.\n\n        Returns:\n            origin corner\n        \"\"\"\n        return constants.CORNER.inverse[self.originCorner()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.get_origin_corner","title":"<code>get_origin_corner(self) -&gt; constants.CornerStr</code>","text":"<p>Return current origin corner.</p> <p>Returns:</p> Type Description <code>constants.CornerStr</code> <p>origin corner</p> Source code in <code>prettyqt/widgets/gridlayout.py</code> <pre><code>def get_origin_corner(self) -&gt; constants.CornerStr:\n\"\"\"Return current origin corner.\n\n    Returns:\n        origin corner\n    \"\"\"\n    return constants.CORNER.inverse[self.originCorner()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.set_origin_corner","title":"<code>set_origin_corner(self, corner: constants.CornerStr)</code>","text":"<p>Set the origin corner.</p> <p>Parameters:</p> Name Type Description Default <code>corner</code> <code>constants.CornerStr</code> <p>origin corner</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>corner does not exist</p> Source code in <code>prettyqt/widgets/gridlayout.py</code> <pre><code>def set_origin_corner(self, corner: constants.CornerStr):\n\"\"\"Set the origin corner.\n\n    Args:\n        corner: origin corner\n\n    Raises:\n        InvalidParamError: corner does not exist\n    \"\"\"\n    if corner not in constants.CORNER:\n        raise InvalidParamError(corner, constants.CORNER)\n    self.setOriginCorner(constants.CORNER[corner])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.headerview","title":"<code>headerview</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderViewMixin","title":"<code> HeaderViewMixin            (AbstractItemViewMixin)         </code>","text":"Source code in <code>prettyqt/widgets/headerview.py</code> <pre><code>class HeaderViewMixin(widgets.AbstractItemViewMixin):\n    section_vis_changed = core.Signal(int, bool)\n    section_resized_by_user = core.Signal(int, int, int)\n\n    def __init__(\n        self,\n        orientation: constants.OrientationStr | QtCore.Qt.Orientation,\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        if isinstance(orientation, QtCore.Qt.Orientation):\n            ori = orientation\n        else:\n            ori = constants.ORIENTATION[orientation]\n        super().__init__(ori, parent=parent)\n        self.setSectionsMovable(True)\n        self.setSectionsClickable(True)\n        self.sectionResized.connect(self.sectionResizeEvent)\n        self._handle_section_is_pressed = False\n        self._widget_name = parent.get_id() if parent is not None else \"\"\n\n    def mousePressEvent(self, e):\n        super().mousePressEvent(e)\n        self._handle_section_is_pressed = self.cursor().shape() == QtCore.Qt.SplitHCursor\n\n    def mouseReleaseEvent(self, e):\n        super().mouseReleaseEvent(e)\n        self._handle_section_is_pressed = False\n\n    def sectionResizeEvent(self, logical_index, old_size, new_size):\n        if self._handle_section_is_pressed:\n            self.section_resized_by_user.emit(logical_index, old_size, new_size)\n\n    def generate_header_id(self):\n        # return f\"{self._widget_name}.state\"\n        column_names = \",\".join(self.get_section_labels())\n        columns_hash = hashlib.md5(column_names.encode()).hexdigest()\n        return f\"{type(self).__name__}_{columns_hash}.state\"\n\n    def save_state(self, settings: core.Settings | None = None, key: str | None = None):\n        settings = core.Settings() if settings is None else settings\n        key = self.generate_header_id() if key is None else key\n        settings.set_value(key, self.saveState())\n\n    def load_state(\n        self, settings: core.Settings | None = None, key: str | None = None\n    ) -&gt; bool:\n        settings = core.Settings() if settings is None else settings\n        key = self.generate_header_id() if key is None else key\n        state = settings.get(key, None)\n        if state is not None:\n            if isinstance(state, str):\n                state = state.encode()\n            self.restoreState(state)\n            return True\n        return False\n\n    def resize_sections(self, mode: ModeStr):\n        self.resizeSections(MODES[mode])\n\n    @deprecated(reason=\"This method is deprecated, use set_resize_mode instead.\")\n    def resize_mode(self, mode: ModeStr, col: int | None = None):\n        self.set_resize_mode(mode, col)\n\n    def set_resize_mode(self, mode: ModeStr, col: int | None = None):\n        if mode not in MODES:\n            raise InvalidParamError(mode, MODES)\n        if col is None:\n            self.setSectionResizeMode(MODES[mode])\n        else:\n            self.setSectionResizeMode(col, MODES[mode])\n\n    def get_section_labels(self) -&gt; list[str]:\n        model = self.model()\n        return [\n            model.headerData(\n                i, constants.HORIZONTAL, constants.DISPLAY_ROLE  # type: ignore\n            )\n            for i in range(self.count())\n        ]\n\n    def contextMenuEvent(self, event):\n\"\"\"Context menu for our files tree.\"\"\"\n        menu = widgets.Menu(parent=self)\n        actions = self.get_header_actions()\n        menu.add_actions(actions)\n        menu.exec_(self.mapToGlobal(event.position()))\n\n    def get_header_actions(self) -&gt; list[widgets.Action]:\n        actions = []\n        labels = self.get_section_labels()[1:]\n        for i, header_label in enumerate(labels, start=1):\n            val = not self.isSectionHidden(i)\n            action = widgets.Action(text=header_label, checkable=True, checked=val)\n            fn = functools.partial(self.set_section_hidden, i=i, hide=val)\n            action.triggered.connect(fn)\n            actions.append(action)\n        return actions\n\n    def set_section_hidden(self, i: int, hide: bool):\n        self.section_vis_changed.emit(i, hide)\n        self.setSectionHidden(i, hide)\n\n    def set_sizes(self, sizes: Iterable[int | None]):\n        for i, size in enumerate(sizes):\n            if size is not None:\n                self.resizeSection(i, size)\n\n    def set_default_section_size(self, size: int | None):\n        if size is None:\n            self.resetDefaultSectionSize()\n        else:\n            self.setDefaultSectionSize(size)\n\n    def stretch_last_section(self, stretch: bool = True):\n        self.setStretchLastSection(stretch)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderViewMixin.contextMenuEvent","title":"<code>contextMenuEvent(self, event)</code>","text":"<p>Context menu for our files tree.</p> Source code in <code>prettyqt/widgets/headerview.py</code> <pre><code>def contextMenuEvent(self, event):\n\"\"\"Context menu for our files tree.\"\"\"\n    menu = widgets.Menu(parent=self)\n    actions = self.get_header_actions()\n    menu.add_actions(actions)\n    menu.exec_(self.mapToGlobal(event.position()))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog","title":"<code>inputdialog</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog","title":"<code> InputDialog            (DialogMixin, QInputDialog)         </code>","text":"Source code in <code>prettyqt/widgets/inputdialog.py</code> <pre><code>class InputDialog(widgets.DialogMixin, QtWidgets.QInputDialog):\n    @classmethod\n    def get_int(\n        cls,\n        title: str = \"\",\n        label: str = \"\",\n        icon: datatypes.IconType = None,\n    ) -&gt; int | None:\n        par = widgets.Dialog()\n        par.set_icon(icon)\n        v = cls.getInt(par, title, label, value=0)\n        return v[0] if v[1] else None\n\n    @classmethod\n    def get_float(\n        cls,\n        title: str = \"\",\n        label: str = \"\",\n        icon: datatypes.IconType = None,\n    ) -&gt; float | None:\n        par = widgets.Dialog()\n        par.set_icon(icon)\n        v = cls.getDouble(par, title, label, value=0.0)\n        return v[0] if v[1] else None\n\n    @classmethod\n    def get_text(\n        cls,\n        title: str = \"\",\n        label: str = \"\",\n        icon: datatypes.IconType = None,\n        default_value: str = \"\",\n        echo_mode: widgets.lineedit.EchoModeStr = \"normal\",\n    ) -&gt; str | None:\n        par = widgets.Dialog()\n        par.set_icon(icon)\n        if echo_mode not in widgets.lineedit.ECHO_MODE:\n            raise InvalidParamError(echo_mode, widgets.lineedit.ECHO_MODE)\n        v = cls.getText(\n            par, title, label, widgets.lineedit.ECHO_MODE[echo_mode], default_value\n        )\n        return v[0] if v[1] else None\n\n    @classmethod\n    def get_item(\n        cls,\n        items: list[str],\n        title: str = \"\",\n        label: str = \"\",\n        icon: datatypes.IconType = None,\n        editable: bool = False,\n    ) -&gt; str | None:\n        par = widgets.Dialog()\n        par.set_icon(icon)\n        v = cls.getItem(par, title, label, items, editable=editable, current=0)\n        return v[0] if v[1] else None\n\n    def set_text_echo_mode(self, mode: widgets.lineedit.EchoModeStr):\n\"\"\"Set text echo mode.\n\n        Args:\n            mode: echo mode to use\n\n        Raises:\n            InvalidParamError: invalid echo mode\n        \"\"\"\n        if mode not in widgets.lineedit.ECHO_MODE:\n            raise InvalidParamError(mode, widgets.lineedit.ECHO_MODE)\n        self.setTextEchoMode(widgets.lineedit.ECHO_MODE[mode])\n\n    def get_text_echo_mode(self) -&gt; widgets.lineedit.EchoModeStr:\n\"\"\"Return text echo mode.\n\n        Returns:\n            echo mode\n        \"\"\"\n        return widgets.lineedit.ECHO_MODE.inverse[self.textEchoMode()]\n\n    def set_input_mode(self, mode: InputModeStr):\n\"\"\"Set input mode.\n\n        Args:\n            mode: input mode to use\n\n        Raises:\n            InvalidParamError: invalid input mode\n        \"\"\"\n        if mode not in INPUT_MODE:\n            raise InvalidParamError(mode, INPUT_MODE)\n        self.setInputMode(INPUT_MODE[mode])\n\n    def get_input_mode(self) -&gt; InputModeStr:\n\"\"\"Return input mode.\n\n        Returns:\n            input mode\n        \"\"\"\n        return INPUT_MODE.inverse[self.inputMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.get_input_mode","title":"<code>get_input_mode(self) -&gt; InputModeStr</code>","text":"<p>Return input mode.</p> <p>Returns:</p> Type Description <code>InputModeStr</code> <p>input mode</p> Source code in <code>prettyqt/widgets/inputdialog.py</code> <pre><code>def get_input_mode(self) -&gt; InputModeStr:\n\"\"\"Return input mode.\n\n    Returns:\n        input mode\n    \"\"\"\n    return INPUT_MODE.inverse[self.inputMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.get_text_echo_mode","title":"<code>get_text_echo_mode(self) -&gt; widgets.lineedit.EchoModeStr</code>","text":"<p>Return text echo mode.</p> <p>Returns:</p> Type Description <code>widgets.lineedit.EchoModeStr</code> <p>echo mode</p> Source code in <code>prettyqt/widgets/inputdialog.py</code> <pre><code>def get_text_echo_mode(self) -&gt; widgets.lineedit.EchoModeStr:\n\"\"\"Return text echo mode.\n\n    Returns:\n        echo mode\n    \"\"\"\n    return widgets.lineedit.ECHO_MODE.inverse[self.textEchoMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.set_input_mode","title":"<code>set_input_mode(self, mode: InputModeStr)</code>","text":"<p>Set input mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>InputModeStr</code> <p>input mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid input mode</p> Source code in <code>prettyqt/widgets/inputdialog.py</code> <pre><code>def set_input_mode(self, mode: InputModeStr):\n\"\"\"Set input mode.\n\n    Args:\n        mode: input mode to use\n\n    Raises:\n        InvalidParamError: invalid input mode\n    \"\"\"\n    if mode not in INPUT_MODE:\n        raise InvalidParamError(mode, INPUT_MODE)\n    self.setInputMode(INPUT_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.set_text_echo_mode","title":"<code>set_text_echo_mode(self, mode: widgets.lineedit.EchoModeStr)</code>","text":"<p>Set text echo mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>widgets.lineedit.EchoModeStr</code> <p>echo mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid echo mode</p> Source code in <code>prettyqt/widgets/inputdialog.py</code> <pre><code>def set_text_echo_mode(self, mode: widgets.lineedit.EchoModeStr):\n\"\"\"Set text echo mode.\n\n    Args:\n        mode: echo mode to use\n\n    Raises:\n        InvalidParamError: invalid echo mode\n    \"\"\"\n    if mode not in widgets.lineedit.ECHO_MODE:\n        raise InvalidParamError(mode, widgets.lineedit.ECHO_MODE)\n    self.setTextEchoMode(widgets.lineedit.ECHO_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label","title":"<code>label</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.label.Label","title":"<code> Label            (FrameMixin, QLabel)         </code>","text":"Source code in <code>prettyqt/widgets/label.py</code> <pre><code>class Label(widgets.FrameMixin, QtWidgets.QLabel):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.openExternalLinks()\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.text()!r})\"\n\n    def serialize_fields(self):\n        pixmap = gui.Pixmap(self.pixmap())\n        return dict(\n            text=self.text(),\n            scaled_contents=self.hasScaledContents(),\n            indent=self.indent(),\n            margin=self.margin(),\n            text_format=self.get_text_format(),\n            pixmap=pixmap if pixmap else None,\n            open_external_links=self.openExternalLinks(),\n            has_selected_text=self.hasSelectedText(),\n            selected_text=self.selectedText(),\n            alignment=(self.get_horizontal_alignment(), self.get_vertical_alignment()),\n            word_wrap=self.wordWrap(),\n            text_interaction_flags=self.get_text_interaction(),\n        )\n\n    def __setstate__(self, state):\n        self.setText(state.get(\"text\", \"\"))\n        self.setIndent(state.get(\"indent\", -1))\n        self.setMargin(state.get(\"margin\", 0))\n        self.setWordWrap(state.get(\"word_wrap\", 0))\n        self.set_text_format(state.get(\"text_format\", 0))\n        # self.setPixmap(state.get(\"pixmap\"))\n        self.setOpenExternalLinks(state.get(\"open_external_links\", False))\n        self.set_alignment(*state.get(\"alignment\"))\n        self.setScaledContents(state[\"scaled_contents\"])\n        self.setWordWrap(state[\"word_wrap\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def allow_links(self) -&gt; Label:\n        # self.setText(\"&lt;a href=\\\"http://example.com/\\\"&gt;Click Here!&lt;/a&gt;\")\n        self.setTextFormat(QtCore.Qt.TextFormat.RichText)\n        self.setTextInteractionFlags(\n            QtCore.Qt.TextInteractionFlag.TextBrowserInteraction  # type: ignore\n        )\n        self.setOpenExternalLinks(True)\n        return self\n\n    def set_alignment(\n        self,\n        horizontal: constants.HorizontalAlignmentStr | None = None,\n        vertical: constants.VerticalAlignmentStr | None = None,\n    ):\n\"\"\"Set the alignment of the label's contents.\"\"\"\n        match horizontal, vertical:\n            case None, None:\n                return self\n            case None, _:\n                flag = constants.V_ALIGNMENT[vertical]\n            case _, None:\n                flag = constants.H_ALIGNMENT[horizontal]\n            case _, _:\n                flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n        self.setAlignment(flag)\n        return self\n\n    def get_horizontal_alignment(self) -&gt; constants.HorizontalAlignmentStr:\n        align = self.alignment()\n        if align &amp; constants.ALIGN_RIGHT:  # type: ignore\n            return \"right\"\n        elif align &amp; constants.ALIGN_H_CENTER:  # type: ignore\n            return \"center\"\n        elif align &amp; constants.ALIGN_JUSTIFY:  # type: ignore\n            return \"justify\"\n        else:\n            return \"left\"\n\n    def get_vertical_alignment(self) -&gt; constants.VerticalAlignmentStr:\n        align = self.alignment()\n        if align &amp; constants.ALIGN_TOP:  # type: ignore\n            return \"top\"\n        elif align &amp; constants.ALIGN_BOTTOM:  # type: ignore\n            return \"bottom\"\n        elif align &amp; constants.ALIGN_BASELINE:  # type: ignore\n            return \"baseline\"\n        else:\n            return \"center\"\n\n    def set_indent(self, indent: int) -&gt; Label:\n\"\"\"Set the label's text indent in pixels.\"\"\"\n        self.setIndent(indent)\n        return self\n\n    def set_text_format(self, text_format: TextFormatStr) -&gt; Label:\n\"\"\"Set the text format.\n\n        Args:\n            text_format: text format to use\n\n        Raises:\n            InvalidParamError: text format does not exist\n        \"\"\"\n        if text_format not in TEXT_FORMAT:\n            raise InvalidParamError(text_format, TEXT_FORMAT)\n        self.setTextFormat(TEXT_FORMAT[text_format])\n        return self\n\n    def get_text_format(self) -&gt; TextFormatStr:\n\"\"\"Return current text format.\n\n        Returns:\n            text format\n        \"\"\"\n        return TEXT_FORMAT.inverse[self.textFormat()]\n\n    def set_text_interaction(self, *types: TextInteractionStr) -&gt; Label:\n\"\"\"Set the text interaction mode.\n\n        Args:\n            types: text interaction mode to use\n\n        Raises:\n            InvalidParamError: text interaction mode does not exist\n        \"\"\"\n        for item in types:\n            if item not in TEXT_INTERACTION:\n                raise InvalidParamError(item, TEXT_INTERACTION)\n        flags = helpers.merge_flags(types, TEXT_INTERACTION)\n        self.setTextInteractionFlags(flags)\n        return self\n\n    def get_text_interaction(self) -&gt; list[TextInteractionStr]:\n\"\"\"Return current text interaction mode.\n\n        Returns:\n            list of text interaction modes\n        \"\"\"\n        return [k for k, v in TEXT_INTERACTION.items() if v &amp; self.textInteractionFlags()]\n\n    def set_text(self, text: str) -&gt; Label:\n\"\"\"Set the label's text.\"\"\"\n        self.setText(text)\n        return self\n\n    def set_bold(self, bold: bool = True) -&gt; Label:\n        font = self.font()\n        font.setBold(bold)\n        self.setFont(font)\n        return self\n\n    def set_italic(self, italic: bool = True) -&gt; Label:\n        font = self.font()\n        font.setItalic(italic)\n        self.setFont(font)\n        return self\n\n    def set_point_size(self, size: int) -&gt; Label:\n        font = self.font()\n        font.setPointSize(size)\n        self.setFont(font)\n        return self\n\n    def set_weight(self, weight: gui.font.WeightStr) -&gt; Label:\n\"\"\"Set the font weight.\n\n        Args:\n            weight: font weight\n\n        Raises:\n            InvalidParamError: invalid font weight\n        \"\"\"\n        if weight not in gui.font.WEIGHT:\n            raise InvalidParamError(weight, gui.font.WEIGHT)\n        font = self.font()\n        font.setWeight(gui.font.WEIGHT[weight])\n        self.setFont(font)\n        return self\n\n    def set_color(self, color: datatypes.ColorType) -&gt; Label:\n        with self.edit_stylesheet() as ss:\n            if color is None:\n                ss.color.setValue(\"\")\n            else:\n                color = colors.get_color(color)\n                ss.color.setValue(color.name())\n        return self\n\n    def set_image(self, path: datatypes.PathType, width: int = 300) -&gt; Label:\n        self.setScaledContents(True)\n        self.set_alignment(horizontal=\"center\")\n        self.setText(\n            \"&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;\"\n            f\"&lt;img src={os.fspath(path)!r} width={str(width)!r}/&gt;\"\n            \"&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\n        )\n        return self\n\n    @classmethod\n    def image_from_path(\n        cls, path: datatypes.PathType, parent: QtWidgets.QWidget | None = None\n    ) -&gt; Label:\n        pixmap = gui.Pixmap.from_file(path)\n        label = cls(parent=parent)\n        label.setPixmap(pixmap)\n        label.resize(pixmap.width(), pixmap.height())\n        return label\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_format","title":"<code>get_text_format(self) -&gt; TextFormatStr</code>","text":"<p>Return current text format.</p> <p>Returns:</p> Type Description <code>TextFormatStr</code> <p>text format</p> Source code in <code>prettyqt/widgets/label.py</code> <pre><code>def get_text_format(self) -&gt; TextFormatStr:\n\"\"\"Return current text format.\n\n    Returns:\n        text format\n    \"\"\"\n    return TEXT_FORMAT.inverse[self.textFormat()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_interaction","title":"<code>get_text_interaction(self) -&gt; list[TextInteractionStr]</code>","text":"<p>Return current text interaction mode.</p> <p>Returns:</p> Type Description <code>list[TextInteractionStr]</code> <p>list of text interaction modes</p> Source code in <code>prettyqt/widgets/label.py</code> <pre><code>def get_text_interaction(self) -&gt; list[TextInteractionStr]:\n\"\"\"Return current text interaction mode.\n\n    Returns:\n        list of text interaction modes\n    \"\"\"\n    return [k for k, v in TEXT_INTERACTION.items() if v &amp; self.textInteractionFlags()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_alignment","title":"<code>set_alignment(self, horizontal: constants.HorizontalAlignmentStr | None = None, vertical: constants.VerticalAlignmentStr | None = None)</code>","text":"<p>Set the alignment of the label's contents.</p> Source code in <code>prettyqt/widgets/label.py</code> <pre><code>def set_alignment(\n    self,\n    horizontal: constants.HorizontalAlignmentStr | None = None,\n    vertical: constants.VerticalAlignmentStr | None = None,\n):\n\"\"\"Set the alignment of the label's contents.\"\"\"\n    match horizontal, vertical:\n        case None, None:\n            return self\n        case None, _:\n            flag = constants.V_ALIGNMENT[vertical]\n        case _, None:\n            flag = constants.H_ALIGNMENT[horizontal]\n        case _, _:\n            flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n    self.setAlignment(flag)\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_indent","title":"<code>set_indent(self, indent: int) -&gt; Label</code>","text":"<p>Set the label's text indent in pixels.</p> Source code in <code>prettyqt/widgets/label.py</code> <pre><code>def set_indent(self, indent: int) -&gt; Label:\n\"\"\"Set the label's text indent in pixels.\"\"\"\n    self.setIndent(indent)\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text","title":"<code>set_text(self, text: str) -&gt; Label</code>","text":"<p>Set the label's text.</p> Source code in <code>prettyqt/widgets/label.py</code> <pre><code>def set_text(self, text: str) -&gt; Label:\n\"\"\"Set the label's text.\"\"\"\n    self.setText(text)\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_format","title":"<code>set_text_format(self, text_format: TextFormatStr) -&gt; Label</code>","text":"<p>Set the text format.</p> <p>Parameters:</p> Name Type Description Default <code>text_format</code> <code>TextFormatStr</code> <p>text format to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>text format does not exist</p> Source code in <code>prettyqt/widgets/label.py</code> <pre><code>def set_text_format(self, text_format: TextFormatStr) -&gt; Label:\n\"\"\"Set the text format.\n\n    Args:\n        text_format: text format to use\n\n    Raises:\n        InvalidParamError: text format does not exist\n    \"\"\"\n    if text_format not in TEXT_FORMAT:\n        raise InvalidParamError(text_format, TEXT_FORMAT)\n    self.setTextFormat(TEXT_FORMAT[text_format])\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_interaction","title":"<code>set_text_interaction(self, *types: TextInteractionStr) -&gt; Label</code>","text":"<p>Set the text interaction mode.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>TextInteractionStr</code> <p>text interaction mode to use</p> <code>()</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>text interaction mode does not exist</p> Source code in <code>prettyqt/widgets/label.py</code> <pre><code>def set_text_interaction(self, *types: TextInteractionStr) -&gt; Label:\n\"\"\"Set the text interaction mode.\n\n    Args:\n        types: text interaction mode to use\n\n    Raises:\n        InvalidParamError: text interaction mode does not exist\n    \"\"\"\n    for item in types:\n        if item not in TEXT_INTERACTION:\n            raise InvalidParamError(item, TEXT_INTERACTION)\n    flags = helpers.merge_flags(types, TEXT_INTERACTION)\n    self.setTextInteractionFlags(flags)\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_weight","title":"<code>set_weight(self, weight: gui.font.WeightStr) -&gt; Label</code>","text":"<p>Set the font weight.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>gui.font.WeightStr</code> <p>font weight</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid font weight</p> Source code in <code>prettyqt/widgets/label.py</code> <pre><code>def set_weight(self, weight: gui.font.WeightStr) -&gt; Label:\n\"\"\"Set the font weight.\n\n    Args:\n        weight: font weight\n\n    Raises:\n        InvalidParamError: invalid font weight\n    \"\"\"\n    if weight not in gui.font.WEIGHT:\n        raise InvalidParamError(weight, gui.font.WEIGHT)\n    font = self.font()\n    font.setWeight(gui.font.WEIGHT[weight])\n    self.setFont(font)\n    return self\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layout","title":"<code>layout</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.layout.LayoutMixin","title":"<code> LayoutMixin            (ObjectMixin, LayoutItemMixin)         </code>","text":"Source code in <code>prettyqt/widgets/layout.py</code> <pre><code>class LayoutMixin(core.ObjectMixin, widgets.LayoutItemMixin):\n    def __getitem__(\n        self, index: str | int\n    ) -&gt; QtWidgets.QWidget | QtWidgets.QLayout | None:\n        if isinstance(index, int):\n            item = self.itemAt(index)\n            widget = item.widget()\n            if widget is None:\n                widget = item.layout()\n        elif isinstance(index, str):\n            return self.find_child(typ=QtCore.QObject, name=index)\n        return widget\n\n    def __delitem__(self, index: int):\n        item = self.itemAt(index)\n        self.removeItem(item)\n\n    def __len__(self) -&gt; int:\n        return self.count()\n\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QWidget | QtWidgets.QLayout | None]:\n        return iter(self[i] for i in range(self.count()))\n\n    def __contains__(self, item: QtWidgets.QWidget | QtWidgets.QLayoutItem):\n        return self.indexOf(item) &gt;= 0\n\n    def serialize_fields(self):\n        return dict(\n            size_mode=self.get_size_mode(),\n            spacing=self.spacing(),\n            enabled=self.isEnabled(),\n        )\n\n    def get_children(self) -&gt; list[QtWidgets.QWidget | QtWidgets.QLayout]:\n        return list(self)\n\n    def set_margin(self, margin: int):\n        self.setContentsMargins(margin, margin, margin, margin)\n\n    def set_spacing(self, pixels: int):\n        self.setSpacing(pixels)\n\n    def set_size_mode(self, mode: SizeConstraintStr):\n\"\"\"Set the size mode of the layout.\n\n        Args:\n            mode: size mode for the layout\n\n        Raises:\n            InvalidParamError: size mode does not exist\n        \"\"\"\n        if mode not in SIZE_CONSTRAINT:\n            raise InvalidParamError(mode, SIZE_CONSTRAINT)\n        self.setSizeConstraint(SIZE_CONSTRAINT[mode])\n\n    def get_size_mode(self) -&gt; SizeConstraintStr:\n\"\"\"Return current size mode.\n\n        Returns:\n            size mode\n        \"\"\"\n        return SIZE_CONSTRAINT.inverse[self.sizeConstraint()]\n\n    def set_alignment(\n        self,\n        alignment: constants.AlignmentStr,\n        item: QtWidgets.QWidget | QtWidgets.QLayout | None = None,\n    ) -&gt; bool:\n\"\"\"Set the alignment for widget / layout to alignment.\n\n        Returns true if w is found in this layout (not including child layouts).\n\n        Args:\n            alignment: alignment for the layout\n            item: set alignment for specific child only\n\n        Raises:\n            InvalidParamError: alignment does not exist\n        \"\"\"\n        if alignment not in constants.ALIGNMENTS:\n            raise InvalidParamError(alignment, constants.ALIGNMENTS)\n        if item is not None:\n            return self.setAlignment(item, constants.ALIGNMENTS[alignment])\n        else:\n            return self.setAlignment(constants.ALIGNMENTS[alignment])\n\n    def add(self, *item: QtWidgets.QWidget | QtWidgets.QLayout):\n        for i in item:\n            if isinstance(i, QtWidgets.QWidget):\n                self.addWidget(i)\n            elif isinstance(i, QtWidgets.QLayout):\n                w = widgets.Widget()\n                w.set_layout(i)\n                self.addWidget(w)\n            else:\n                raise TypeError(\"add_item only supports widgets and layouts\")\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layout.LayoutMixin.get_size_mode","title":"<code>get_size_mode(self) -&gt; SizeConstraintStr</code>","text":"<p>Return current size mode.</p> <p>Returns:</p> Type Description <code>SizeConstraintStr</code> <p>size mode</p> Source code in <code>prettyqt/widgets/layout.py</code> <pre><code>def get_size_mode(self) -&gt; SizeConstraintStr:\n\"\"\"Return current size mode.\n\n    Returns:\n        size mode\n    \"\"\"\n    return SIZE_CONSTRAINT.inverse[self.sizeConstraint()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layout.LayoutMixin.set_alignment","title":"<code>set_alignment(self, alignment: constants.AlignmentStr, item: QtWidgets.QWidget | QtWidgets.QLayout | None = None) -&gt; bool</code>","text":"<p>Set the alignment for widget / layout to alignment.</p> <p>Returns true if w is found in this layout (not including child layouts).</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr</code> <p>alignment for the layout</p> required <code>item</code> <code>QtWidgets.QWidget | QtWidgets.QLayout | None</code> <p>set alignment for specific child only</p> <code>None</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>alignment does not exist</p> Source code in <code>prettyqt/widgets/layout.py</code> <pre><code>def set_alignment(\n    self,\n    alignment: constants.AlignmentStr,\n    item: QtWidgets.QWidget | QtWidgets.QLayout | None = None,\n) -&gt; bool:\n\"\"\"Set the alignment for widget / layout to alignment.\n\n    Returns true if w is found in this layout (not including child layouts).\n\n    Args:\n        alignment: alignment for the layout\n        item: set alignment for specific child only\n\n    Raises:\n        InvalidParamError: alignment does not exist\n    \"\"\"\n    if alignment not in constants.ALIGNMENTS:\n        raise InvalidParamError(alignment, constants.ALIGNMENTS)\n    if item is not None:\n        return self.setAlignment(item, constants.ALIGNMENTS[alignment])\n    else:\n        return self.setAlignment(constants.ALIGNMENTS[alignment])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layout.LayoutMixin.set_size_mode","title":"<code>set_size_mode(self, mode: SizeConstraintStr)</code>","text":"<p>Set the size mode of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SizeConstraintStr</code> <p>size mode for the layout</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>size mode does not exist</p> Source code in <code>prettyqt/widgets/layout.py</code> <pre><code>def set_size_mode(self, mode: SizeConstraintStr):\n\"\"\"Set the size mode of the layout.\n\n    Args:\n        mode: size mode for the layout\n\n    Raises:\n        InvalidParamError: size mode does not exist\n    \"\"\"\n    if mode not in SIZE_CONSTRAINT:\n        raise InvalidParamError(mode, SIZE_CONSTRAINT)\n    self.setSizeConstraint(SIZE_CONSTRAINT[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layoutitem","title":"<code>layoutitem</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.layoutitem.LayoutItemMixin","title":"<code> LayoutItemMixin        </code>","text":"Source code in <code>prettyqt/widgets/layoutitem.py</code> <pre><code>class LayoutItemMixin:\n    # def __bool__(self):\n    #     return not self.isEmpty()\n\n    def set_alignment(self, alignment: constants.AlignmentStr):\n\"\"\"Set the alignment of the layout.\n\n        Args:\n            alignment: alignment for the layout\n\n        Raises:\n            InvalidParamError: alignment does not exist\n        \"\"\"\n        if alignment not in constants.ALIGNMENTS:\n            raise InvalidParamError(alignment, constants.ALIGNMENTS)\n        self.setAlignment(constants.ALIGNMENTS[alignment])\n\n    def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n\n        Returns:\n            alignment\n        \"\"\"\n        return constants.ALIGNMENTS.inverse[self.alignment()]\n\n    def get_item(\n        self,\n    ) -&gt; QtWidgets.QWidget | QtWidgets.QLayout | QtWidgets.QSpacerItem | None:\n        if content := self.widget():\n            return content\n        if content := self.layout():\n            return content\n        if content := self.spacerItem():\n            return content\n        return None\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layoutitem.LayoutItemMixin.get_alignment","title":"<code>get_alignment(self) -&gt; constants.AlignmentStr</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.AlignmentStr</code> <p>alignment</p> Source code in <code>prettyqt/widgets/layoutitem.py</code> <pre><code>def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n\n    Returns:\n        alignment\n    \"\"\"\n    return constants.ALIGNMENTS.inverse[self.alignment()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.layoutitem.LayoutItemMixin.set_alignment","title":"<code>set_alignment(self, alignment: constants.AlignmentStr)</code>","text":"<p>Set the alignment of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr</code> <p>alignment for the layout</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>alignment does not exist</p> Source code in <code>prettyqt/widgets/layoutitem.py</code> <pre><code>def set_alignment(self, alignment: constants.AlignmentStr):\n\"\"\"Set the alignment of the layout.\n\n    Args:\n        alignment: alignment for the layout\n\n    Raises:\n        InvalidParamError: alignment does not exist\n    \"\"\"\n    if alignment not in constants.ALIGNMENTS:\n        raise InvalidParamError(alignment, constants.ALIGNMENTS)\n    self.setAlignment(constants.ALIGNMENTS[alignment])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber","title":"<code>lcdnumber</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber","title":"<code> LCDNumber            (FrameMixin, QLCDNumber)         </code>","text":"Source code in <code>prettyqt/widgets/lcdnumber.py</code> <pre><code>class LCDNumber(widgets.FrameMixin, QtWidgets.QLCDNumber):\n    def serialize_fields(self):\n        return dict(\n            mode=self.get_mode(),\n            segment_style=self.get_segment_style(),\n            value=self.get_value(),\n        )\n\n    def __setstate__(self, state):\n        self.set_mode(state[\"mode\"])\n        self.set_segment_style(state[\"segment_style\"])\n        self.set_value(state[\"value\"])\n\n    def set_mode(self, mode: ModeStr):\n\"\"\"Set the lcd mode.\n\n        Args:\n            mode: lcd mode to use\n\n        Raises:\n            InvalidParamError: lcd mode does not exist\n        \"\"\"\n        if mode not in MODE:\n            raise InvalidParamError(mode, MODE)\n        self.setMode(MODE[mode])\n\n    def get_mode(self) -&gt; ModeStr:\n\"\"\"Return current lcd mode.\n\n        Returns:\n            lcd mode\n        \"\"\"\n        return MODE.inverse[self.mode()]\n\n    def set_segment_style(self, mode: SegmentStyleStr):\n\"\"\"Set the segment style.\n\n        Args:\n            mode: segment style to use\n\n        Raises:\n            InvalidParamError: segment style does not exist\n        \"\"\"\n        if mode not in SEGMENT_STYLE:\n            raise InvalidParamError(mode, SEGMENT_STYLE)\n        self.setSegmentStyle(SEGMENT_STYLE[mode])\n\n    def get_segment_style(self) -&gt; SegmentStyleStr:\n\"\"\"Return current segment style.\n\n        Returns:\n            segment style\n        \"\"\"\n        return SEGMENT_STYLE.inverse[self.segmentStyle()]\n\n    def set_value(self, value: float | str):\n        self.display(value)\n\n    def get_value(self) -&gt; float:\n        return self.value()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_mode","title":"<code>get_mode(self) -&gt; ModeStr</code>","text":"<p>Return current lcd mode.</p> <p>Returns:</p> Type Description <code>ModeStr</code> <p>lcd mode</p> Source code in <code>prettyqt/widgets/lcdnumber.py</code> <pre><code>def get_mode(self) -&gt; ModeStr:\n\"\"\"Return current lcd mode.\n\n    Returns:\n        lcd mode\n    \"\"\"\n    return MODE.inverse[self.mode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_segment_style","title":"<code>get_segment_style(self) -&gt; SegmentStyleStr</code>","text":"<p>Return current segment style.</p> <p>Returns:</p> Type Description <code>SegmentStyleStr</code> <p>segment style</p> Source code in <code>prettyqt/widgets/lcdnumber.py</code> <pre><code>def get_segment_style(self) -&gt; SegmentStyleStr:\n\"\"\"Return current segment style.\n\n    Returns:\n        segment style\n    \"\"\"\n    return SEGMENT_STYLE.inverse[self.segmentStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_mode","title":"<code>set_mode(self, mode: ModeStr)</code>","text":"<p>Set the lcd mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ModeStr</code> <p>lcd mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>lcd mode does not exist</p> Source code in <code>prettyqt/widgets/lcdnumber.py</code> <pre><code>def set_mode(self, mode: ModeStr):\n\"\"\"Set the lcd mode.\n\n    Args:\n        mode: lcd mode to use\n\n    Raises:\n        InvalidParamError: lcd mode does not exist\n    \"\"\"\n    if mode not in MODE:\n        raise InvalidParamError(mode, MODE)\n    self.setMode(MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_segment_style","title":"<code>set_segment_style(self, mode: SegmentStyleStr)</code>","text":"<p>Set the segment style.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>SegmentStyleStr</code> <p>segment style to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>segment style does not exist</p> Source code in <code>prettyqt/widgets/lcdnumber.py</code> <pre><code>def set_segment_style(self, mode: SegmentStyleStr):\n\"\"\"Set the segment style.\n\n    Args:\n        mode: segment style to use\n\n    Raises:\n        InvalidParamError: segment style does not exist\n    \"\"\"\n    if mode not in SEGMENT_STYLE:\n        raise InvalidParamError(mode, SEGMENT_STYLE)\n    self.setSegmentStyle(SEGMENT_STYLE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit","title":"<code>lineedit</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit","title":"<code> LineEdit            (WidgetMixin, QLineEdit)         </code>","text":"Source code in <code>prettyqt/widgets/lineedit.py</code> <pre><code>class LineEdit(widgets.WidgetMixin, QtWidgets.QLineEdit):\n    focusLost = core.Signal()\n    enterPressed = core.Signal()\n    editComplete = core.Signal(str)\n\n    value_changed = core.Signal(str)\n\n    def __init__(\n        self,\n        default_value: str = \"\",\n        read_only: bool = False,\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        super().__init__(default_value, parent)\n        self.textChanged.connect(self._set_validation_color)\n        self.textChanged.connect(self.value_changed)\n        self.set_read_only(read_only)\n\n    def __repr__(self):\n        return f\"{type(self).__name__}: {self.serialize_fields()}\"\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_text(state[\"text\"])\n        self.setValidator(state[\"validator\"])\n        self.setInputMask(state[\"input_mask\"])\n        self.setMaxLength(state[\"max_length\"])\n        self.setPlaceholderText(state[\"placeholder_text\"])\n        self.setReadOnly(state[\"read_only\"])\n        self.setFrame(state[\"has_frame\"])\n        self.setClearButtonEnabled(state[\"clear_button_enabled\"])\n        # self.setAlignment(state[\"alignment\"])\n        self.set_cursor_move_style(state[\"cursor_move_style\"])\n        self.set_echo_mode(state[\"echo_mode\"])\n        self.setCursorPosition(state[\"cursor_position\"])\n        self.setDragEnabled(state[\"drag_enabled\"])\n        self.setModified(state[\"is_modified\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __add__(self, other: str):\n        self.append_text(other)\n        return self\n\n    def serialize_fields(self):\n        return dict(\n            text=self.text(),\n            # alignment=self.alignment(),\n            validator=self.validator(),\n            max_length=self.maxLength(),\n            read_only=self.isReadOnly(),\n            input_mask=self.inputMask(),\n            has_frame=self.hasFrame(),\n            placeholder_text=self.placeholderText(),\n            clear_button_enabled=self.isClearButtonEnabled(),\n            cursor_move_style=self.get_cursor_move_style(),\n            echo_mode=self.get_echo_mode(),\n            cursor_position=self.cursorPosition(),\n            drag_enabled=self.dragEnabled(),\n            is_modified=self.isModified(),\n        )\n\n    def focusOutEvent(self, event):\n        self.focusLost.emit()\n        return super().focusOutEvent(event)\n\n    def keyPressEvent(self, event):\n        match event.key():\n            case QtCore.Qt.Key.Key_Enter | QtCore.Qt.Key.Key_Return:\n                self.enterPressed.emit()\n        return super().keyPressEvent(event)\n\n    def _on_edit_complete(self):\n        self.editComplete.emit(self.text())\n\n    def font(self) -&gt; gui.Font:\n        return gui.Font(super().font())\n\n    def append_text(self, text: str):\n        self.set_text(self.text() + text)\n\n    def set_text(self, text: str):\n        self.setText(text)\n\n    def set_read_only(self, value: bool = True):\n\"\"\"Set text to read-only.\n\n        Args:\n            value: True, for read-only, otherwise False\n        \"\"\"\n        self.setReadOnly(value)\n\n    def set_regex_validator(self, regex: str, flags=0) -&gt; gui.RegularExpressionValidator:\n        validator = gui.RegularExpressionValidator(self)\n        validator.set_regex(regex, flags)\n        self.set_validator(validator)\n        return validator\n\n    def set_range(self, lower: int | None, upper: int | None):\n        val = gui.IntValidator()\n        val.set_range(lower, upper)\n        self.set_validator(val)\n\n    def set_validator(self, validator: gui.Validator):\n        self.setValidator(validator)\n        self._set_validation_color()\n\n    def set_input_mask(self, mask: str):\n        self.setInputMask(mask)\n\n    def _set_validation_color(self, state: bool = True):\n        color = \"orange\" if not self.is_valid() else None\n        self.set_background_color(color)\n\n    def set_echo_mode(self, mode: EchoModeStr):\n\"\"\"Set echo mode.\n\n        Args:\n            mode: echo mode to use\n\n        Raises:\n            InvalidParamError: invalid echo mode\n        \"\"\"\n        if mode not in ECHO_MODE:\n            raise InvalidParamError(mode, ECHO_MODE)\n        self.setEchoMode(ECHO_MODE[mode])\n\n    def get_echo_mode(self) -&gt; EchoModeStr:\n\"\"\"Return echo mode.\n\n        Returns:\n            echo mode\n        \"\"\"\n        return ECHO_MODE.inverse[self.echoMode()]\n\n    def set_cursor_move_style(self, style: constants.CursorMoveStyleStr):\n\"\"\"Set cursor move style.\n\n        Args:\n            style: cursor move style to use\n\n        Raises:\n            InvalidParamError: invalid cursor move style\n        \"\"\"\n        if style not in constants.CURSOR_MOVE_STYLE:\n            raise InvalidParamError(style, constants.CURSOR_MOVE_STYLE)\n        self.setCursorMoveStyle(constants.CURSOR_MOVE_STYLE[style])\n\n    def get_cursor_move_style(self) -&gt; constants.CursorMoveStyleStr:\n\"\"\"Return cursor move style.\n\n        Returns:\n            cursor move style\n        \"\"\"\n        return constants.CURSOR_MOVE_STYLE.inverse[self.cursorMoveStyle()]\n\n    def add_action(\n        self, action: QtWidgets.QAction, position: ActionPositionStr = \"trailing\"\n    ):\n        self.addAction(action, ACTION_POSITION[position])\n\n    def set_value(self, value: str):\n        self.setText(value)\n\n    def get_value(self) -&gt; str:\n        return self.text()\n\n    def is_valid(self) -&gt; bool:\n        return self.hasAcceptableInput()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.focusOutEvent","title":"<code>focusOutEvent(self, event)</code>","text":"<p>focusOutEvent(self, arg__1: PySide6.QtGui.QFocusEvent) -&gt; None</p> Source code in <code>prettyqt/widgets/lineedit.py</code> <pre><code>def focusOutEvent(self, event):\n    self.focusLost.emit()\n    return super().focusOutEvent(event)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.font","title":"<code>font(self) -&gt; gui.Font</code>","text":"<p>font(self) -&gt; PySide6.QtGui.QFont</p> Source code in <code>prettyqt/widgets/lineedit.py</code> <pre><code>def font(self) -&gt; gui.Font:\n    return gui.Font(super().font())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_cursor_move_style","title":"<code>get_cursor_move_style(self) -&gt; constants.CursorMoveStyleStr</code>","text":"<p>Return cursor move style.</p> <p>Returns:</p> Type Description <code>constants.CursorMoveStyleStr</code> <p>cursor move style</p> Source code in <code>prettyqt/widgets/lineedit.py</code> <pre><code>def get_cursor_move_style(self) -&gt; constants.CursorMoveStyleStr:\n\"\"\"Return cursor move style.\n\n    Returns:\n        cursor move style\n    \"\"\"\n    return constants.CURSOR_MOVE_STYLE.inverse[self.cursorMoveStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_echo_mode","title":"<code>get_echo_mode(self) -&gt; EchoModeStr</code>","text":"<p>Return echo mode.</p> <p>Returns:</p> Type Description <code>EchoModeStr</code> <p>echo mode</p> Source code in <code>prettyqt/widgets/lineedit.py</code> <pre><code>def get_echo_mode(self) -&gt; EchoModeStr:\n\"\"\"Return echo mode.\n\n    Returns:\n        echo mode\n    \"\"\"\n    return ECHO_MODE.inverse[self.echoMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.keyPressEvent","title":"<code>keyPressEvent(self, event)</code>","text":"<p>keyPressEvent(self, arg__1: PySide6.QtGui.QKeyEvent) -&gt; None</p> Source code in <code>prettyqt/widgets/lineedit.py</code> <pre><code>def keyPressEvent(self, event):\n    match event.key():\n        case QtCore.Qt.Key.Key_Enter | QtCore.Qt.Key.Key_Return:\n            self.enterPressed.emit()\n    return super().keyPressEvent(event)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_cursor_move_style","title":"<code>set_cursor_move_style(self, style: constants.CursorMoveStyleStr)</code>","text":"<p>Set cursor move style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.CursorMoveStyleStr</code> <p>cursor move style to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid cursor move style</p> Source code in <code>prettyqt/widgets/lineedit.py</code> <pre><code>def set_cursor_move_style(self, style: constants.CursorMoveStyleStr):\n\"\"\"Set cursor move style.\n\n    Args:\n        style: cursor move style to use\n\n    Raises:\n        InvalidParamError: invalid cursor move style\n    \"\"\"\n    if style not in constants.CURSOR_MOVE_STYLE:\n        raise InvalidParamError(style, constants.CURSOR_MOVE_STYLE)\n    self.setCursorMoveStyle(constants.CURSOR_MOVE_STYLE[style])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_echo_mode","title":"<code>set_echo_mode(self, mode: EchoModeStr)</code>","text":"<p>Set echo mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>EchoModeStr</code> <p>echo mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid echo mode</p> Source code in <code>prettyqt/widgets/lineedit.py</code> <pre><code>def set_echo_mode(self, mode: EchoModeStr):\n\"\"\"Set echo mode.\n\n    Args:\n        mode: echo mode to use\n\n    Raises:\n        InvalidParamError: invalid echo mode\n    \"\"\"\n    if mode not in ECHO_MODE:\n        raise InvalidParamError(mode, ECHO_MODE)\n    self.setEchoMode(ECHO_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_read_only","title":"<code>set_read_only(self, value: bool = True)</code>","text":"<p>Set text to read-only.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True, for read-only, otherwise False</p> <code>True</code> Source code in <code>prettyqt/widgets/lineedit.py</code> <pre><code>def set_read_only(self, value: bool = True):\n\"\"\"Set text to read-only.\n\n    Args:\n        value: True, for read-only, otherwise False\n    \"\"\"\n    self.setReadOnly(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview","title":"<code>listview</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin","title":"<code> ListViewMixin            (AbstractItemViewMixin)         </code>","text":"Source code in <code>prettyqt/widgets/listview.py</code> <pre><code>class ListViewMixin(widgets.AbstractItemViewMixin):\n    def serialize_fields(self):\n        return dict(\n            view_mode=self.get_view_mode(),\n            resize_mode=self.get_resize_mode(),\n            layout_mode=self.get_layout_mode(),\n            movement=self.get_movement(),\n            batch_size=self.batchSize(),\n            flow=self.get_flow(),\n            grid_size=self.get_grid_size(),\n            is_wrapping=self.isWrapping(),\n            # item_alignment=self.itemAlignment(),\n            model_column=self.modelColumn(),\n            selection_rect_visible=self.isSelectionRectVisible(),\n            spacing=self.spacing(),\n            uniform_item_sizes=self.uniformItemSizes(),\n            word_wrap=self.wordWrap(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_view_mode(state[\"view_mode\"])\n        self.set_resize_mode(state[\"resize_mode\"])\n        self.set_layout_mode(state[\"layout_mode\"])\n        self.set_movement(state[\"movement\"])\n        self.setBatchSize(state[\"batch_size\"])\n        self.set_flow(state[\"flow\"])\n        self.set_grid_size(state[\"grid_size\"])\n        self.setWrapping(state[\"is_wrapping\"])\n        # self.setItemAlignment(state[\"flow\"])\n        self.setModelColumn(state[\"model_column\"])\n        self.setSelectionRectVisible(state[\"selection_rect_visible\"])\n        self.setSpacing(state[\"spacing\"])\n        self.setUniformItemSizes(state[\"uniform_item_sizes\"])\n        self.setWordWrap(state[\"word_wrap\"])\n\n    def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode.\n\n        Args:\n            mode: view mode to use\n\n        Raises:\n            InvalidParamError: invalid view mode\n        \"\"\"\n        if mode not in VIEW_MODE:\n            raise InvalidParamError(mode, VIEW_MODE)\n        self.setViewMode(VIEW_MODE[mode])\n\n    def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n\n        Returns:\n            view mode\n        \"\"\"\n        return VIEW_MODE.inverse[self.viewMode()]\n\n    def set_resize_mode(self, mode: ResizeModeStr):\n\"\"\"Set resize mode.\n\n        Args:\n            mode: resize mode to use\n\n        Raises:\n            InvalidParamError: invalid resize mode\n        \"\"\"\n        if mode not in RESIZE_MODE:\n            raise InvalidParamError(mode, RESIZE_MODE)\n        self.setResizeMode(RESIZE_MODE[mode])\n\n    def get_resize_mode(self) -&gt; ResizeModeStr:\n\"\"\"Return resize mode.\n\n        Returns:\n            resize mode\n        \"\"\"\n        return RESIZE_MODE.inverse[self.resizeMode()]\n\n    def set_layout_mode(self, mode: LayoutModeStr):\n\"\"\"Set layout mode.\n\n        Args:\n            mode: layout mode to use\n\n        Raises:\n            InvalidParamError: invalid layout mode\n        \"\"\"\n        if mode not in LAYOUT_MODE:\n            raise InvalidParamError(mode, LAYOUT_MODE)\n        self.setLayoutMode(LAYOUT_MODE[mode])\n\n    def get_layout_mode(self) -&gt; LayoutModeStr:\n\"\"\"Return layout mode.\n\n        Returns:\n            layout mode\n        \"\"\"\n        return LAYOUT_MODE.inverse[self.layoutMode()]\n\n    def set_movement(self, mode: MovementStr):\n\"\"\"Set movement mode.\n\n        Args:\n            mode: movement mode to use\n\n        Raises:\n            InvalidParamError: invalid movement mode\n        \"\"\"\n        if mode not in MOVEMENT:\n            raise InvalidParamError(mode, MOVEMENT)\n        self.setMovement(MOVEMENT[mode])\n\n    def get_movement(self) -&gt; MovementStr:\n\"\"\"Return movement mode.\n\n        Returns:\n            movement mode\n        \"\"\"\n        return MOVEMENT.inverse[self.movement()]\n\n    def set_flow(self, mode: FlowStr):\n\"\"\"Set flow mode.\n\n        Args:\n            mode: flow mode to use\n\n        Raises:\n            InvalidParamError: invalid flow mode\n        \"\"\"\n        if mode not in FLOW:\n            raise InvalidParamError(mode, FLOW)\n        self.setFlow(FLOW[mode])\n\n    def get_flow(self) -&gt; FlowStr:\n\"\"\"Return flow mode.\n\n        Returns:\n            flow mode\n        \"\"\"\n        return FLOW.inverse[self.flow()]\n\n    def set_grid_size(self, size: QtCore.QSize | tuple[int, int]):\n        if isinstance(size, tuple):\n            size = QtCore.QSize(*size)\n        self.setGridSize(size)\n\n    def get_grid_size(self) -&gt; core.Size:\n        return core.Size(self.gridSize())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_flow","title":"<code>get_flow(self) -&gt; FlowStr</code>","text":"<p>Return flow mode.</p> <p>Returns:</p> Type Description <code>FlowStr</code> <p>flow mode</p> Source code in <code>prettyqt/widgets/listview.py</code> <pre><code>def get_flow(self) -&gt; FlowStr:\n\"\"\"Return flow mode.\n\n    Returns:\n        flow mode\n    \"\"\"\n    return FLOW.inverse[self.flow()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_layout_mode","title":"<code>get_layout_mode(self) -&gt; LayoutModeStr</code>","text":"<p>Return layout mode.</p> <p>Returns:</p> Type Description <code>LayoutModeStr</code> <p>layout mode</p> Source code in <code>prettyqt/widgets/listview.py</code> <pre><code>def get_layout_mode(self) -&gt; LayoutModeStr:\n\"\"\"Return layout mode.\n\n    Returns:\n        layout mode\n    \"\"\"\n    return LAYOUT_MODE.inverse[self.layoutMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_movement","title":"<code>get_movement(self) -&gt; MovementStr</code>","text":"<p>Return movement mode.</p> <p>Returns:</p> Type Description <code>MovementStr</code> <p>movement mode</p> Source code in <code>prettyqt/widgets/listview.py</code> <pre><code>def get_movement(self) -&gt; MovementStr:\n\"\"\"Return movement mode.\n\n    Returns:\n        movement mode\n    \"\"\"\n    return MOVEMENT.inverse[self.movement()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_resize_mode","title":"<code>get_resize_mode(self) -&gt; ResizeModeStr</code>","text":"<p>Return resize mode.</p> <p>Returns:</p> Type Description <code>ResizeModeStr</code> <p>resize mode</p> Source code in <code>prettyqt/widgets/listview.py</code> <pre><code>def get_resize_mode(self) -&gt; ResizeModeStr:\n\"\"\"Return resize mode.\n\n    Returns:\n        resize mode\n    \"\"\"\n    return RESIZE_MODE.inverse[self.resizeMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.get_view_mode","title":"<code>get_view_mode(self) -&gt; ViewModeStr</code>","text":"<p>Return view mode.</p> <p>Returns:</p> Type Description <code>ViewModeStr</code> <p>view mode</p> Source code in <code>prettyqt/widgets/listview.py</code> <pre><code>def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return view mode.\n\n    Returns:\n        view mode\n    \"\"\"\n    return VIEW_MODE.inverse[self.viewMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_flow","title":"<code>set_flow(self, mode: FlowStr)</code>","text":"<p>Set flow mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>FlowStr</code> <p>flow mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid flow mode</p> Source code in <code>prettyqt/widgets/listview.py</code> <pre><code>def set_flow(self, mode: FlowStr):\n\"\"\"Set flow mode.\n\n    Args:\n        mode: flow mode to use\n\n    Raises:\n        InvalidParamError: invalid flow mode\n    \"\"\"\n    if mode not in FLOW:\n        raise InvalidParamError(mode, FLOW)\n    self.setFlow(FLOW[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_layout_mode","title":"<code>set_layout_mode(self, mode: LayoutModeStr)</code>","text":"<p>Set layout mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>LayoutModeStr</code> <p>layout mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid layout mode</p> Source code in <code>prettyqt/widgets/listview.py</code> <pre><code>def set_layout_mode(self, mode: LayoutModeStr):\n\"\"\"Set layout mode.\n\n    Args:\n        mode: layout mode to use\n\n    Raises:\n        InvalidParamError: invalid layout mode\n    \"\"\"\n    if mode not in LAYOUT_MODE:\n        raise InvalidParamError(mode, LAYOUT_MODE)\n    self.setLayoutMode(LAYOUT_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_movement","title":"<code>set_movement(self, mode: MovementStr)</code>","text":"<p>Set movement mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>MovementStr</code> <p>movement mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid movement mode</p> Source code in <code>prettyqt/widgets/listview.py</code> <pre><code>def set_movement(self, mode: MovementStr):\n\"\"\"Set movement mode.\n\n    Args:\n        mode: movement mode to use\n\n    Raises:\n        InvalidParamError: invalid movement mode\n    \"\"\"\n    if mode not in MOVEMENT:\n        raise InvalidParamError(mode, MOVEMENT)\n    self.setMovement(MOVEMENT[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_resize_mode","title":"<code>set_resize_mode(self, mode: ResizeModeStr)</code>","text":"<p>Set resize mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ResizeModeStr</code> <p>resize mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid resize mode</p> Source code in <code>prettyqt/widgets/listview.py</code> <pre><code>def set_resize_mode(self, mode: ResizeModeStr):\n\"\"\"Set resize mode.\n\n    Args:\n        mode: resize mode to use\n\n    Raises:\n        InvalidParamError: invalid resize mode\n    \"\"\"\n    if mode not in RESIZE_MODE:\n        raise InvalidParamError(mode, RESIZE_MODE)\n    self.setResizeMode(RESIZE_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListViewMixin.set_view_mode","title":"<code>set_view_mode(self, mode: ViewModeStr)</code>","text":"<p>Set view mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewModeStr</code> <p>view mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid view mode</p> Source code in <code>prettyqt/widgets/listview.py</code> <pre><code>def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode.\n\n    Args:\n        mode: view mode to use\n\n    Raises:\n        InvalidParamError: invalid view mode\n    \"\"\"\n    if mode not in VIEW_MODE:\n        raise InvalidParamError(mode, VIEW_MODE)\n    self.setViewMode(VIEW_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem","title":"<code>listwidgetitem</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem","title":"<code> ListWidgetItem            (QListWidgetItem)         </code>","text":"Source code in <code>prettyqt/widgets/listwidgetitem.py</code> <pre><code>class ListWidgetItem(QtWidgets.QListWidgetItem):\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.icon()}, {self.text()!r})\"\n\n    def __setitem__(self, index: int, value):\n        self.setData(index, value)\n\n    def __getitem__(self, index: int):\n        return self.data(index)\n\n    def serialize_fields(self):\n        return dict(\n            text=self.text(),\n            tool_tip=self.toolTip(),\n            status_tip=self.statusTip(),\n            checkstate=self.get_checkstate(),\n            icon=self.get_icon(),\n            data=self.data(constants.USER_ROLE),  # type: ignore\n        )\n\n    def __getstate__(self):\n        return bytes(self)\n\n    def __setstate__(self, ba):\n        core.DataStream.write_bytearray(ba, self)\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __bytes__(self):\n        ba = core.DataStream.create_bytearray(self)\n        return bytes(ba)\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n        Args:\n            state: checkstate to use\n\n        Raises:\n            InvalidParamError: invalid checkstate\n        \"\"\"\n        if state not in constants.STATE:\n            raise InvalidParamError(state, constants.STATE)\n        self.setCheckState(constants.STATE[state])\n\n    def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n        Returns:\n            checkstate\n        \"\"\"\n        return constants.STATE.inverse[self.checkState()]\n\n    def get_background(self) -&gt; gui.Brush:\n        return gui.Brush(self.background())\n\n    def get_foreground(self) -&gt; gui.Brush:\n        return gui.Brush(self.foreground())\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        if icon.isNull():\n            return None\n        return gui.Icon(icon)\n\n    def set_data(self, role: str, data):\n        role_id = constants.ITEM_DATA_ROLE[role]\n        self.setData(role_id, data)\n\n    def set_size_hint(self, hint: datatypes.SizeType):\n        if isinstance(hint, tuple):\n            hint = QtCore.QSize(*hint)\n        self.setSizeHint(hint)\n\n    def set_text_alignment(\n        self,\n        horizontal: constants.HorizontalAlignmentStr | None = None,\n        vertical: constants.VerticalAlignmentStr | None = None,\n    ):\n\"\"\"Set text alignment of the checkbox.\n\n        Args:\n            horizontal: horizontal text alignment to use\n            vertical: vertical text alignment to use\n\n        Raises:\n            InvalidParamError: invalid text alignment\n        \"\"\"\n        match horizontal, vertical:\n            case None, None:\n                return\n            case None, _:\n                flag = constants.V_ALIGNMENT[vertical]\n            case _, None:\n                flag = constants.H_ALIGNMENT[horizontal]\n            case _, _:\n                flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n        self.setTextAlignment(flag)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.get_checkstate","title":"<code>get_checkstate(self) -&gt; constants.StateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.StateStr</code> <p>checkstate</p> Source code in <code>prettyqt/widgets/listwidgetitem.py</code> <pre><code>def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n    Returns:\n        checkstate\n    \"\"\"\n    return constants.STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_checkstate","title":"<code>set_checkstate(self, state: constants.StateStr)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.StateStr</code> <p>checkstate to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid checkstate</p> Source code in <code>prettyqt/widgets/listwidgetitem.py</code> <pre><code>def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n    Args:\n        state: checkstate to use\n\n    Raises:\n        InvalidParamError: invalid checkstate\n    \"\"\"\n    if state not in constants.STATE:\n        raise InvalidParamError(state, constants.STATE)\n    self.setCheckState(constants.STATE[state])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_icon","title":"<code>set_icon(self, icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt/widgets/listwidgetitem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_text_alignment","title":"<code>set_text_alignment(self, horizontal: constants.HorizontalAlignmentStr | None = None, vertical: constants.VerticalAlignmentStr | None = None)</code>","text":"<p>Set text alignment of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>horizontal</code> <code>constants.HorizontalAlignmentStr | None</code> <p>horizontal text alignment to use</p> <code>None</code> <code>vertical</code> <code>constants.VerticalAlignmentStr | None</code> <p>vertical text alignment to use</p> <code>None</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid text alignment</p> Source code in <code>prettyqt/widgets/listwidgetitem.py</code> <pre><code>def set_text_alignment(\n    self,\n    horizontal: constants.HorizontalAlignmentStr | None = None,\n    vertical: constants.VerticalAlignmentStr | None = None,\n):\n\"\"\"Set text alignment of the checkbox.\n\n    Args:\n        horizontal: horizontal text alignment to use\n        vertical: vertical text alignment to use\n\n    Raises:\n        InvalidParamError: invalid text alignment\n    \"\"\"\n    match horizontal, vertical:\n        case None, None:\n            return\n        case None, _:\n            flag = constants.V_ALIGNMENT[vertical]\n        case _, None:\n            flag = constants.H_ALIGNMENT[horizontal]\n        case _, _:\n            flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n    self.setTextAlignment(flag)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow","title":"<code>mainwindow</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow","title":"<code> MainWindow            (WidgetMixin, QMainWindow)         </code>","text":"Source code in <code>prettyqt/widgets/mainwindow.py</code> <pre><code>class MainWindow(widgets.WidgetMixin, QtWidgets.QMainWindow):\n\"\"\"Class for our mainWindow.\n\n    Includes all docks, a centralwidget and a toolbar\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.setMenuBar(widgets.MenuBar())\n        self.setDockOptions(\n            self.DockOption.AllowTabbedDocks  # type: ignore\n            | self.DockOption.AllowNestedDocks\n            | self.DockOption.GroupedDragging\n            | self.DockOption.AnimatedDocks\n        )\n\n    def __getitem__(self, index: str) -&gt; QtWidgets.QWidget:\n        result = self.find_child(QtWidgets.QWidget, index)\n        if result is None:\n            raise KeyError(\"Widget not found\")\n        return result\n\n    def serialize_fields(self):\n        return dict(\n            central_widget=self.centralWidget(),\n            is_maximized=self.isMaximized(),\n        )\n\n    def __setstate__(self, state):\n        if state[\"central_widget\"]:\n            self.setCentralWidget(state[\"central_widget\"])\n        if state[\"is_maximized\"]:\n            self.showMaximized()\n        self.box = self.layout()\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def set_widget(self, widget: QtWidgets.QWidget | None):\n        if widget is None:\n            self.takeCentralWidget()\n        else:\n            self.setCentralWidget(widget)\n\n    def createPopupMenu(self) -&gt; widgets.Menu:\n        # qactions = self.createPopupMenu()\n        menu = widgets.Menu(parent=self)\n        for i, item in enumerate(self.get_docks()):\n            action = widgets.Action(text=item.windowTitle(), parent=self)\n            action.set_checkable(True)\n            action.set_checked(item.isVisible())\n            action.set_shortcut(f\"Ctrl+Shift+{i}\")\n            action.set_shortcut_context(\"application\")\n            action.toggled.connect(item.setVisible)\n            menu.add(action)\n        menu.add_separator()\n        for tb in self.get_toolbars():\n            action = widgets.Action(text=tb.windowTitle(), parent=self)\n            action.set_checkable(True)\n            action.toggled.connect(tb.setVisible)\n            action.set_checked(tb.isVisible())\n            menu.add(action)\n        return menu\n\n    def add_toolbar(\n        self, toolbar: QtWidgets.QToolBar, position: constants.ToolbarAreaStr = \"top\"\n    ):\n\"\"\"Adds a toolbar to the mainmenu at specified area.\n\n        Args:\n            toolbar: toolbar to use\n            position: position of the toolbar\n\n        Raises:\n            InvalidParamError: position does not exist\n        \"\"\"\n        if position not in constants.TOOLBAR_AREA:\n            raise InvalidParamError(position, constants.TOOLBAR_AREA)\n        self.addToolBar(constants.TOOLBAR_AREA[position], toolbar)\n\n    def add_toolbar_break(self, position: constants.ToolbarAreaStr = \"top\"):\n\"\"\"Adds a toolbar break to the given area behind the last item.\n\n        Args:\n            position: position of the toolbar\n\n        Raises:\n            InvalidParamError: position does not exist\n        \"\"\"\n        if position not in constants.TOOLBAR_AREA:\n            raise InvalidParamError(position, constants.TOOLBAR_AREA)\n        self.addToolBarBreak(constants.TOOLBAR_AREA[position])\n\n    def load_window_state(self, recursive: bool = False) -&gt; bool:\n        settings = core.Settings()\n        name = self.get_id()\n        geom = settings.get(f\"{name}.geometry\")\n        state = settings.get(f\"{name}.state\")\n        restored = False\n        if geom is not None and state is not None:\n            try:\n                logger.debug(f\"Loading window state for {self.windowTitle()!r}...\")\n                self.restoreGeometry(geom)\n                if isinstance(state, str):\n                    state = state.encode()\n                self.restoreState(state)\n                restored = True\n            except TypeError:\n                logger.error(\"Wrong type for window state. Probably Qt binding switch?\")\n        if recursive:\n            for window in self.find_children(MainWindow, recursive=True):\n                if window.get_id():\n                    window.load_window_state()\n        return restored\n\n    def save_window_state(self, recursive: bool = False):\n\"\"\"Save current window state as QSetting.\n\n        Args:\n            recursive (bool, optional): Description\n        \"\"\"\n        settings = core.Settings()\n        name = self.get_id()\n        logger.debug(f\"Saving window state for {self.windowTitle()!r}...\")\n        settings[f\"{name}.geometry\"] = self.saveGeometry()\n        settings[f\"{name}.state\"] = self.saveState()\n        if recursive:\n            for window in self.find_children(MainWindow, recursive=True):\n                if window.get_id():\n                    window.save_window_state()\n\n    def add_widget_as_dock(\n        self,\n        name: str,\n        title: str,\n        vertical: bool = True,\n        position: constants.DockPositionStr = \"left\",\n    ) -&gt; widgets.DockWidget:\n        dock_widget = widgets.DockWidget(self, name=name, title=title)\n        widget = widgets.Widget()\n        widget.set_id(f\"{name}.widget\")\n        layout = widgets.BoxLayout(\n            \"vertical\" if vertical else \"horizontal\", widget, margin=0\n        )\n        dock_widget.setWidget(widget)\n        self.add_dockwidget(dock_widget, position)\n        dock_widget.box = layout\n        return dock_widget\n\n    def add_dockwidget(\n        self,\n        dockwidget: QtWidgets.QDockWidget,\n        position: constants.DockPositionStr = \"left\",\n    ):\n        self.addDockWidget(constants.DOCK_POSITION[position], dockwidget)\n\n    def remove_dockwidgets(self, dockwidgets: Sequence[QtWidgets.QDockWidget]):\n        for i in dockwidgets:\n            self.removeDockWidget(i)\n\n    def show_blocking(self):\n        self.set_modality(\"application\")\n        self.show()\n\n    def get_docks(self) -&gt; list[QtWidgets.QDockWidget]:\n        return self.find_children(QtWidgets.QDockWidget, recursive=False)\n\n    def get_toolbars(self) -&gt; list[QtWidgets.QToolBar]:\n        return self.find_children(QtWidgets.QToolBar, recursive=False)\n\n    def toggle_fullscreen(self):\n\"\"\"Toggle between fullscreen and regular size.\"\"\"\n        if self.isFullScreen():\n            self.showNormal()\n        else:\n            self.showFullScreen()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar","title":"<code>add_toolbar(self, toolbar: QtWidgets.QToolBar, position: constants.ToolbarAreaStr = 'top')</code>","text":"<p>Adds a toolbar to the mainmenu at specified area.</p> <p>Parameters:</p> Name Type Description Default <code>toolbar</code> <code>QtWidgets.QToolBar</code> <p>toolbar to use</p> required <code>position</code> <code>constants.ToolbarAreaStr</code> <p>position of the toolbar</p> <code>'top'</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>position does not exist</p> Source code in <code>prettyqt/widgets/mainwindow.py</code> <pre><code>def add_toolbar(\n    self, toolbar: QtWidgets.QToolBar, position: constants.ToolbarAreaStr = \"top\"\n):\n\"\"\"Adds a toolbar to the mainmenu at specified area.\n\n    Args:\n        toolbar: toolbar to use\n        position: position of the toolbar\n\n    Raises:\n        InvalidParamError: position does not exist\n    \"\"\"\n    if position not in constants.TOOLBAR_AREA:\n        raise InvalidParamError(position, constants.TOOLBAR_AREA)\n    self.addToolBar(constants.TOOLBAR_AREA[position], toolbar)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar_break","title":"<code>add_toolbar_break(self, position: constants.ToolbarAreaStr = 'top')</code>","text":"<p>Adds a toolbar break to the given area behind the last item.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>constants.ToolbarAreaStr</code> <p>position of the toolbar</p> <code>'top'</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>position does not exist</p> Source code in <code>prettyqt/widgets/mainwindow.py</code> <pre><code>def add_toolbar_break(self, position: constants.ToolbarAreaStr = \"top\"):\n\"\"\"Adds a toolbar break to the given area behind the last item.\n\n    Args:\n        position: position of the toolbar\n\n    Raises:\n        InvalidParamError: position does not exist\n    \"\"\"\n    if position not in constants.TOOLBAR_AREA:\n        raise InvalidParamError(position, constants.TOOLBAR_AREA)\n    self.addToolBarBreak(constants.TOOLBAR_AREA[position])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.createPopupMenu","title":"<code>createPopupMenu(self) -&gt; widgets.Menu</code>","text":"<p>createPopupMenu(self) -&gt; PySide6.QtWidgets.QMenu</p> Source code in <code>prettyqt/widgets/mainwindow.py</code> <pre><code>def createPopupMenu(self) -&gt; widgets.Menu:\n    # qactions = self.createPopupMenu()\n    menu = widgets.Menu(parent=self)\n    for i, item in enumerate(self.get_docks()):\n        action = widgets.Action(text=item.windowTitle(), parent=self)\n        action.set_checkable(True)\n        action.set_checked(item.isVisible())\n        action.set_shortcut(f\"Ctrl+Shift+{i}\")\n        action.set_shortcut_context(\"application\")\n        action.toggled.connect(item.setVisible)\n        menu.add(action)\n    menu.add_separator()\n    for tb in self.get_toolbars():\n        action = widgets.Action(text=tb.windowTitle(), parent=self)\n        action.set_checkable(True)\n        action.toggled.connect(tb.setVisible)\n        action.set_checked(tb.isVisible())\n        menu.add(action)\n    return menu\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.save_window_state","title":"<code>save_window_state(self, recursive: bool = False)</code>","text":"<p>Save current window state as QSetting.</p> <p>Parameters:</p> Name Type Description Default <code>recursive</code> <code>bool</code> <p>Description</p> <code>False</code> Source code in <code>prettyqt/widgets/mainwindow.py</code> <pre><code>def save_window_state(self, recursive: bool = False):\n\"\"\"Save current window state as QSetting.\n\n    Args:\n        recursive (bool, optional): Description\n    \"\"\"\n    settings = core.Settings()\n    name = self.get_id()\n    logger.debug(f\"Saving window state for {self.windowTitle()!r}...\")\n    settings[f\"{name}.geometry\"] = self.saveGeometry()\n    settings[f\"{name}.state\"] = self.saveState()\n    if recursive:\n        for window in self.find_children(MainWindow, recursive=True):\n            if window.get_id():\n                window.save_window_state()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.toggle_fullscreen","title":"<code>toggle_fullscreen(self)</code>","text":"<p>Toggle between fullscreen and regular size.</p> Source code in <code>prettyqt/widgets/mainwindow.py</code> <pre><code>def toggle_fullscreen(self):\n\"\"\"Toggle between fullscreen and regular size.\"\"\"\n    if self.isFullScreen():\n        self.showNormal()\n    else:\n        self.showFullScreen()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea","title":"<code>mdiarea</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea","title":"<code> MdiArea            (AbstractScrollAreaMixin, QMdiArea)         </code>","text":"Source code in <code>prettyqt/widgets/mdiarea.py</code> <pre><code>class MdiArea(widgets.AbstractScrollAreaMixin, QtWidgets.QMdiArea):\n    def __add__(self, other: QtWidgets.QWidget):\n        self.add(other)\n        return self\n\n    def serialize_fields(self):\n        return dict(\n            view_mode=self.get_view_mode(),\n            window_order=self.get_window_order(),\n            tab_position=self.get_tab_position(),\n            background=self.get_background(),\n            document_mode=self.documentMode(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_view_mode(state[\"view_mode\"])\n        self.set_window_order(state[\"window_order\"])\n        self.set_tab_position(state[\"tab_position\"])\n        self.set_background(state[\"background\"])\n        self.setDocumentMode(state[\"document_mode\"])\n\n    def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode for the MDI area.\n\n        Args:\n            mode: view mode to use\n\n        Raises:\n            InvalidParamError: view mode does not exist\n        \"\"\"\n        if mode not in VIEW_MODE:\n            raise InvalidParamError(mode, VIEW_MODE)\n        self.setViewMode(VIEW_MODE[mode])\n\n    def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return current view mode.\n\n        Returns:\n            view mode\n        \"\"\"\n        return VIEW_MODE.inverse[self.viewMode()]\n\n    def set_window_order(self, mode: WindowOrderStr):\n\"\"\"Set the window order behaviour for the MDI area.\n\n        Args:\n            mode: window order behaviour to use\n\n        Raises:\n            InvalidParamError: window order mode not existing.\n        \"\"\"\n        if mode not in WINDOW_ORDER:\n            raise InvalidParamError(mode, WINDOW_ORDER)\n        self.setActivationOrder(WINDOW_ORDER[mode])\n\n    def get_window_order(self) -&gt; WindowOrderStr:\n\"\"\"Return current window order.\n\n        Returns:\n            view mode\n        \"\"\"\n        return WINDOW_ORDER.inverse[self.activationOrder()]\n\n    def set_tab_position(self, position: TabPositionStr):\n\"\"\"Set tab position for the MDI area.\n\n        Args:\n            position: tabs position to use\n\n        Raises:\n            InvalidParamError: tab position does not exist\n        \"\"\"\n        if position not in TAB_POSITION:\n            raise InvalidParamError(position, TAB_POSITION)\n        self.setTabPosition(TAB_POSITION[position])\n\n    def get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return current tab position.\n\n        Returns:\n            tab position\n        \"\"\"\n        return TAB_POSITION.inverse[self.tabPosition()]\n\n    def set_background(\n        self,\n        brush_or_color: datatypes.ColorAndBrushType,\n        pattern: constants.BrushStyleStr = \"solid\",\n    ):\n        if isinstance(brush_or_color, QtGui.QBrush):\n            brush = brush_or_color\n        else:\n            color = colors.get_color(brush_or_color)\n            brush = gui.Brush(color, constants.BRUSH_STYLE[pattern])\n        self.setBackground(brush)\n\n    def get_background(self) -&gt; gui.Brush:\n        return gui.Brush(self.background())\n\n    def add(self, *item: QtWidgets.QWidget):\n        for i in item:\n            if not isinstance(i, QtWidgets.QMdiSubWindow):\n                widget = widgets.MdiSubWindow()\n                widget.setWidget(i)\n                self.addSubWindow(widget)\n            else:\n                self.addSubWindow(i)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_tab_position","title":"<code>get_tab_position(self) -&gt; TabPositionStr</code>","text":"<p>Return current tab position.</p> <p>Returns:</p> Type Description <code>TabPositionStr</code> <p>tab position</p> Source code in <code>prettyqt/widgets/mdiarea.py</code> <pre><code>def get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return current tab position.\n\n    Returns:\n        tab position\n    \"\"\"\n    return TAB_POSITION.inverse[self.tabPosition()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_view_mode","title":"<code>get_view_mode(self) -&gt; ViewModeStr</code>","text":"<p>Return current view mode.</p> <p>Returns:</p> Type Description <code>ViewModeStr</code> <p>view mode</p> Source code in <code>prettyqt/widgets/mdiarea.py</code> <pre><code>def get_view_mode(self) -&gt; ViewModeStr:\n\"\"\"Return current view mode.\n\n    Returns:\n        view mode\n    \"\"\"\n    return VIEW_MODE.inverse[self.viewMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_window_order","title":"<code>get_window_order(self) -&gt; WindowOrderStr</code>","text":"<p>Return current window order.</p> <p>Returns:</p> Type Description <code>WindowOrderStr</code> <p>view mode</p> Source code in <code>prettyqt/widgets/mdiarea.py</code> <pre><code>def get_window_order(self) -&gt; WindowOrderStr:\n\"\"\"Return current window order.\n\n    Returns:\n        view mode\n    \"\"\"\n    return WINDOW_ORDER.inverse[self.activationOrder()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_tab_position","title":"<code>set_tab_position(self, position: TabPositionStr)</code>","text":"<p>Set tab position for the MDI area.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>TabPositionStr</code> <p>tabs position to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>tab position does not exist</p> Source code in <code>prettyqt/widgets/mdiarea.py</code> <pre><code>def set_tab_position(self, position: TabPositionStr):\n\"\"\"Set tab position for the MDI area.\n\n    Args:\n        position: tabs position to use\n\n    Raises:\n        InvalidParamError: tab position does not exist\n    \"\"\"\n    if position not in TAB_POSITION:\n        raise InvalidParamError(position, TAB_POSITION)\n    self.setTabPosition(TAB_POSITION[position])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_view_mode","title":"<code>set_view_mode(self, mode: ViewModeStr)</code>","text":"<p>Set view mode for the MDI area.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ViewModeStr</code> <p>view mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>view mode does not exist</p> Source code in <code>prettyqt/widgets/mdiarea.py</code> <pre><code>def set_view_mode(self, mode: ViewModeStr):\n\"\"\"Set view mode for the MDI area.\n\n    Args:\n        mode: view mode to use\n\n    Raises:\n        InvalidParamError: view mode does not exist\n    \"\"\"\n    if mode not in VIEW_MODE:\n        raise InvalidParamError(mode, VIEW_MODE)\n    self.setViewMode(VIEW_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_window_order","title":"<code>set_window_order(self, mode: WindowOrderStr)</code>","text":"<p>Set the window order behaviour for the MDI area.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>WindowOrderStr</code> <p>window order behaviour to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>window order mode not existing.</p> Source code in <code>prettyqt/widgets/mdiarea.py</code> <pre><code>def set_window_order(self, mode: WindowOrderStr):\n\"\"\"Set the window order behaviour for the MDI area.\n\n    Args:\n        mode: window order behaviour to use\n\n    Raises:\n        InvalidParamError: window order mode not existing.\n    \"\"\"\n    if mode not in WINDOW_ORDER:\n        raise InvalidParamError(mode, WINDOW_ORDER)\n    self.setActivationOrder(WINDOW_ORDER[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.menu","title":"<code>menu</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.menu.MenuMixin","title":"<code> MenuMixin            (WidgetMixin)         </code>","text":"Source code in <code>prettyqt/widgets/menu.py</code> <pre><code>class MenuMixin(widgets.WidgetMixin):\n    def __init__(\n        self,\n        title: str = \"\",\n        icon: datatypes.IconType = None,\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        super().__init__(title, parent=parent)\n        self.set_icon(icon)\n        self.setToolTipsVisible(True)\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QAction]:\n        return iter(self.actions())\n\n    def __len__(self) -&gt; int:\n        return len(self.actions())\n\n    def __add__(self, other: QtWidgets.QAction):\n        self.add(other)\n        return self\n\n    def __getitem__(self, item: str) -&gt; QtWidgets.QAction:\n        for action in self.actions():\n            if action.objectName() == item:\n                return action\n        raise KeyError(f\"Action {item} not in menu\")\n\n    def serialize_fields(self):\n        return dict(\n            separators_collapsible=self.separatorsCollapsible(),\n            tearoff_enabled=self.isTearOffEnabled(),\n            title=self.title(),\n            tool_tips_visible=self.toolTipsVisible(),\n            icon=self.get_icon(),\n        )\n\n    def add(self, *item: QtWidgets.QAction):\n        for i in item:\n            i.setParent(self)\n            self.addAction(i)\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the menu.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        if icon.isNull():\n            return None\n        return gui.Icon(icon)\n\n    def add_separator(self, text: str | None = None) -&gt; widgets.WidgetAction:\n\"\"\"Adds a separator showing an optional label.\n\n        Args:\n            text: Text to show on separator\n\n        Returns:\n            Separator action\n        \"\"\"\n        separator = widgets.WidgetAction(parent=self)\n        if text is None:\n            separator.setSeparator(True)\n        else:\n            label = widgets.Label(text)\n            label.setMinimumWidth(self.minimumWidth())\n            with label.edit_stylesheet() as ss:\n                ss.background.setValue(\"lightgrey\")\n            label.set_alignment(horizontal=\"center\")\n            separator.setDefaultWidget(label)\n            separator.setEnabled(False)\n        self.add(separator)\n        return separator\n\n    def add_action(\n        self,\n        label: str | widgets.Action,\n        callback: Callable = None,\n        icon: Any | None = None,\n        checkable: bool = False,\n        checked: bool = False,\n        shortcut: str | None = None,\n        status_tip: str | None = None,\n    ) -&gt; widgets.Action:\n\"\"\"Add an action to the menu.\n\n        Args:\n            label: Label for button\n            callback: gets called when action is triggered\n            icon: icon for button\n            checkable: as checkbox button\n            checked: if checkable, turn on by default\n            shortcut: Shortcut for action\n            status_tip: Status tip to be shown in status bar\n\n        Returns:\n            Action added to menu\n        \"\"\"\n        if isinstance(label, str):\n            action = widgets.Action(text=label, parent=self)\n            if callback:\n                action.triggered.connect(callback)\n            action.set_icon(icon)\n            action.set_shortcut(shortcut)\n            if checkable:\n                action.setCheckable(True)\n                action.setChecked(checked)\n            if status_tip is not None:\n                action.setStatusTip(status_tip)\n        else:\n            action = label\n            action.setParent(self)\n        self.addAction(action)\n        return action\n\n    def add_actions(self, actions: list[QtWidgets.QAction]):\n        self.addActions(actions)\n\n    def add_menu(self, menu: QtWidgets.QMenu) -&gt; QtWidgets.QAction:\n        action = menu.menuAction()\n        self.addAction(action)\n        return action\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.menu.MenuMixin.add_action","title":"<code>add_action(self, label: str | widgets.Action, callback: Callable = None, icon: Any | None = None, checkable: bool = False, checked: bool = False, shortcut: str | None = None, status_tip: str | None = None) -&gt; widgets.Action</code>","text":"<p>Add an action to the menu.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str | widgets.Action</code> <p>Label for button</p> required <code>callback</code> <code>Callable</code> <p>gets called when action is triggered</p> <code>None</code> <code>icon</code> <code>Any | None</code> <p>icon for button</p> <code>None</code> <code>checkable</code> <code>bool</code> <p>as checkbox button</p> <code>False</code> <code>checked</code> <code>bool</code> <p>if checkable, turn on by default</p> <code>False</code> <code>shortcut</code> <code>str | None</code> <p>Shortcut for action</p> <code>None</code> <code>status_tip</code> <code>str | None</code> <p>Status tip to be shown in status bar</p> <code>None</code> <p>Returns:</p> Type Description <code>widgets.Action</code> <p>Action added to menu</p> Source code in <code>prettyqt/widgets/menu.py</code> <pre><code>def add_action(\n    self,\n    label: str | widgets.Action,\n    callback: Callable = None,\n    icon: Any | None = None,\n    checkable: bool = False,\n    checked: bool = False,\n    shortcut: str | None = None,\n    status_tip: str | None = None,\n) -&gt; widgets.Action:\n\"\"\"Add an action to the menu.\n\n    Args:\n        label: Label for button\n        callback: gets called when action is triggered\n        icon: icon for button\n        checkable: as checkbox button\n        checked: if checkable, turn on by default\n        shortcut: Shortcut for action\n        status_tip: Status tip to be shown in status bar\n\n    Returns:\n        Action added to menu\n    \"\"\"\n    if isinstance(label, str):\n        action = widgets.Action(text=label, parent=self)\n        if callback:\n            action.triggered.connect(callback)\n        action.set_icon(icon)\n        action.set_shortcut(shortcut)\n        if checkable:\n            action.setCheckable(True)\n            action.setChecked(checked)\n        if status_tip is not None:\n            action.setStatusTip(status_tip)\n    else:\n        action = label\n        action.setParent(self)\n    self.addAction(action)\n    return action\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.menu.MenuMixin.add_separator","title":"<code>add_separator(self, text: str | None = None) -&gt; widgets.WidgetAction</code>","text":"<p>Adds a separator showing an optional label.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Text to show on separator</p> <code>None</code> <p>Returns:</p> Type Description <code>widgets.WidgetAction</code> <p>Separator action</p> Source code in <code>prettyqt/widgets/menu.py</code> <pre><code>def add_separator(self, text: str | None = None) -&gt; widgets.WidgetAction:\n\"\"\"Adds a separator showing an optional label.\n\n    Args:\n        text: Text to show on separator\n\n    Returns:\n        Separator action\n    \"\"\"\n    separator = widgets.WidgetAction(parent=self)\n    if text is None:\n        separator.setSeparator(True)\n    else:\n        label = widgets.Label(text)\n        label.setMinimumWidth(self.minimumWidth())\n        with label.edit_stylesheet() as ss:\n            ss.background.setValue(\"lightgrey\")\n        label.set_alignment(horizontal=\"center\")\n        separator.setDefaultWidget(label)\n        separator.setEnabled(False)\n    self.add(separator)\n    return separator\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.menu.MenuMixin.set_icon","title":"<code>set_icon(self, icon: datatypes.IconType)</code>","text":"<p>Set the icon for the menu.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt/widgets/menu.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the menu.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.messagebox","title":"<code>messagebox</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox","title":"<code> MessageBox            (DialogMixin, QMessageBox)         </code>","text":"Source code in <code>prettyqt/widgets/messagebox.py</code> <pre><code>class MessageBox(widgets.DialogMixin, QtWidgets.QMessageBox):\n    def __init__(\n        self,\n        icon: datatypes.IconType | IconStr = None,\n        title: str = \"\",\n        text: str = \"\",\n        informative_text: str = \"\",\n        details: str = \"\",\n        buttons: list[ButtonStr] | None = None,\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        super().__init__(parent)\n        self.set_icon(icon)\n        self.setText(text)\n        self.setInformativeText(informative_text)\n        self.setWindowTitle(title)\n        self.setWindowFlags(\n            QtCore.Qt.WindowType.Dialog  # type: ignore\n            | QtCore.Qt.WindowType.WindowTitleHint\n            | QtCore.Qt.WindowType.CustomizeWindowHint\n        )\n        self.setDetailedText(details)\n        if isinstance(buttons, list):\n            for b in buttons:\n                self.add_button(b)\n\n    def serialize_fields(self):\n        return dict(\n            icon=self.get_icon(),\n            detailed_text=self.detailedText(),\n            icon_pixmap=self.get_icon_pixmap(),\n            informative_text=self.informativeText(),\n            text=self.text(),\n            text_format=self.get_text_format(),\n        )\n\n    @classmethod\n    def message(\n        cls,\n        text: str,\n        title: str = \"\",\n        icon: datatypes.IconType = None,\n        detail_text: str | None = None,\n    ) -&gt; str:\n        m = cls(\"none\", title, text)\n        m.set_icon(icon)\n        if detail_text is not None:\n            m.setDetailedText(detail_text)\n        return m.show_blocking()\n\n    @classmethod\n    def show_exception(cls, exception: Exception):\n        exctype, value = sys.exc_info()[:2]\n        tb = traceback.format_exc()\n        dlg = cls(text=str(value), title=str(exctype), icon=\"critical\", details=tb)\n        dlg.show_blocking()\n\n    def set_icon(self, icon: datatypes.IconType | IconStr):\n        if icon in ICONS:\n            self.setIcon(ICONS[icon])\n        else:\n            ico = iconprovider.get_icon(icon)\n            self.setIconPixmap(ico.get_pixmap(size=64))\n\n    def show_blocking(self) -&gt; ButtonStr:\n        return BUTTONS.inverse[self.main_loop()]\n\n    def get_icon_pixmap(self) -&gt; gui.Pixmap | None:\n        pix = self.iconPixmap()\n        if pix.isNull():\n            return None\n        return gui.Pixmap(pix)\n\n    def get_standard_buttons(self) -&gt; list[ButtonStr]:\n        return [k for k, v in BUTTONS.items() if v &amp; self.standardButtons()]\n\n    def add_button(self, button: ButtonStr) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n\n        Args:\n            button: button to add\n\n        Returns:\n            created button\n\n        Raises:\n            InvalidParamError: Button type not available\n        \"\"\"\n        if button not in BUTTONS:\n            raise InvalidParamError(button, BUTTONS)\n        return self.addButton(BUTTONS[button])\n\n    # @classmethod\n    # def show_exception(cls, exception):\n    #     header = str(exception[0])\n    #     error_text = str(exception[1])\n    #     widgets.MessageBox.message(error_text, header, \"mdi.exclamation\")\n\n    def set_text_format(self, text_format: TextFormatStr):\n\"\"\"Set the text format.\n\n        Args:\n            text_format: text format to use\n\n        Raises:\n            InvalidParamError: text format does not exist\n        \"\"\"\n        if text_format not in TEXT_FORMAT:\n            raise InvalidParamError(text_format, TEXT_FORMAT)\n        self.setTextFormat(TEXT_FORMAT[text_format])\n\n    def get_text_format(self) -&gt; TextFormatStr:\n\"\"\"Return current text format.\n\n        Returns:\n            text format\n        \"\"\"\n        return TEXT_FORMAT.inverse[self.textFormat()]\n\n    def set_escape_button(self, button: ButtonStr | QtWidgets.QAbstractButton):\n        if isinstance(button, QtWidgets.QAbstractButton):\n            self.setEscapeButton(button)\n        else:\n            self.setEscapeButton(BUTTONS[button])\n\n    def set_default_button(self, button: ButtonStr | QtWidgets.QPushButton):\n        if isinstance(button, QtWidgets.QPushButton):\n            self.setDefaultButton(button)\n        else:\n            self.setDefaultButton(BUTTONS[button])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.add_button","title":"<code>add_button(self, button: ButtonStr) -&gt; QtWidgets.QPushButton</code>","text":"<p>Add a default button.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>ButtonStr</code> <p>button to add</p> required <p>Returns:</p> Type Description <code>QtWidgets.QPushButton</code> <p>created button</p> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>Button type not available</p> Source code in <code>prettyqt/widgets/messagebox.py</code> <pre><code>def add_button(self, button: ButtonStr) -&gt; QtWidgets.QPushButton:\n\"\"\"Add a default button.\n\n    Args:\n        button: button to add\n\n    Returns:\n        created button\n\n    Raises:\n        InvalidParamError: Button type not available\n    \"\"\"\n    if button not in BUTTONS:\n        raise InvalidParamError(button, BUTTONS)\n    return self.addButton(BUTTONS[button])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.get_text_format","title":"<code>get_text_format(self) -&gt; TextFormatStr</code>","text":"<p>Return current text format.</p> <p>Returns:</p> Type Description <code>TextFormatStr</code> <p>text format</p> Source code in <code>prettyqt/widgets/messagebox.py</code> <pre><code>def get_text_format(self) -&gt; TextFormatStr:\n\"\"\"Return current text format.\n\n    Returns:\n        text format\n    \"\"\"\n    return TEXT_FORMAT.inverse[self.textFormat()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_icon","title":"<code>set_icon(self, icon: datatypes.IconType | IconStr)</code>","text":"<p>Set the window icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType | IconStr</code> <p>icon to use</p> required Source code in <code>prettyqt/widgets/messagebox.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType | IconStr):\n    if icon in ICONS:\n        self.setIcon(ICONS[icon])\n    else:\n        ico = iconprovider.get_icon(icon)\n        self.setIconPixmap(ico.get_pixmap(size=64))\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_text_format","title":"<code>set_text_format(self, text_format: TextFormatStr)</code>","text":"<p>Set the text format.</p> <p>Parameters:</p> Name Type Description Default <code>text_format</code> <code>TextFormatStr</code> <p>text format to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>text format does not exist</p> Source code in <code>prettyqt/widgets/messagebox.py</code> <pre><code>def set_text_format(self, text_format: TextFormatStr):\n\"\"\"Set the text format.\n\n    Args:\n        text_format: text format to use\n\n    Raises:\n        InvalidParamError: text format does not exist\n    \"\"\"\n    if text_format not in TEXT_FORMAT:\n        raise InvalidParamError(text_format, TEXT_FORMAT)\n    self.setTextFormat(TEXT_FORMAT[text_format])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit","title":"<code>plaintextedit</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin","title":"<code> PlainTextEditMixin            (AbstractScrollAreaMixin)         </code>","text":"Source code in <code>prettyqt/widgets/plaintextedit.py</code> <pre><code>class PlainTextEditMixin(widgets.AbstractScrollAreaMixin):\n    value_changed = core.Signal()\n\n    def __init__(\n        self,\n        text: str = \"\",\n        parent: QtWidgets.QWidget | None = None,\n        read_only: bool = False,\n    ):\n        super().__init__(parent)\n        self._allow_wheel_zoom = False\n        self.validator: QtGui.QValidator | None = None\n        self.textChanged.connect(self._on_value_change)\n        self.set_read_only(read_only)\n        doc = gui.TextDocument(self)\n        layout = widgets.PlainTextDocumentLayout(doc)\n        doc.setDocumentLayout(layout)\n        self.setDocument(doc)\n        self.set_text(text)\n\n    def serialize_fields(self):\n        return dict(\n            text=self.text(),\n            read_only=self.isReadOnly(),\n            line_wrap_mode=self.get_line_wrap_mode(),\n            word_wrap_mode=self.get_word_wrap_mode(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_text(state[\"text\"])\n        self.setReadOnly(state[\"read_only\"])\n        self.set_line_wrap_mode(state[\"line_wrap_mode\"])\n        self.set_word_wrap_mode(state[\"word_wrap_mode\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __add__(self, other: str):\n        self.append_text(other)\n        return self\n\n    def wheelEvent(self, event):\n\"\"\"Handle wheel event for zooming.\"\"\"\n        if not self._allow_wheel_zoom:\n            return None\n        if event.modifiers() &amp; constants.CTRL_MOD:\n            self.zoomIn() if event.angleDelta().y() &gt; 0 else self.zoomOut()\n        else:\n            super().wheelEvent(event)\n\n    def allow_wheel_zoom(self, do_zoom: bool = True):\n        self._allow_wheel_zoom = do_zoom\n\n    def goto_line(self, line_no: int):\n        doc = self.document()\n        lines = doc.blockCount()\n        assert 1 &lt;= line_no &lt;= lines\n        pos = doc.findBlockByLineNumber(line_no - 1).position()\n        with self.current_cursor() as text_cursor:\n            text_cursor.setPosition(pos)\n\n    def get_selected_text(self) -&gt; str:\n        if self.textCursor().hasSelection():\n            return self.textCursor().selectedText()\n        else:\n            return \"\"\n\n    def get_current_line(self) -&gt; int:\n        return self.textCursor().blockNumber()\n\n    def get_selected_rows(self) -&gt; tuple[int, int]:\n        start = self.textCursor().selectionStart()\n        end = self.textCursor().selectionEnd()\n        start_block_id = self.document().findBlock(start).blockNumber()\n        end_block_id = self.document().findBlock(end).blockNumber()\n\n        return (start_block_id, end_block_id)\n\n    @contextlib.contextmanager\n    def create_cursor(self) -&gt; Iterator[gui.TextCursor]:\n        cursor = gui.TextCursor(self.document())\n        yield cursor\n        self.setTextCursor(cursor)\n\n    @contextlib.contextmanager\n    def current_cursor(self) -&gt; Iterator[gui.TextCursor]:\n        cursor = gui.TextCursor(self.textCursor())\n        yield cursor\n        self.setTextCursor(cursor)\n\n    def get_text_cursor(self) -&gt; gui.TextCursor:\n        return gui.TextCursor(self.textCursor())\n\n    def move_cursor(\n        self,\n        operation: gui.textcursor.MoveOperationStr,\n        mode: gui.textcursor.MoveModeStr = \"move\",\n    ):\n        self.moveCursor(\n            gui.textcursor.MOVE_OPERATION[operation], gui.textcursor.MOVE_MODE[mode]\n        )\n\n    def append_text(self, text: str, newline: bool = True):\n        if newline:\n            self.appendPlainText(text)\n        else:\n            self.move_cursor(\"end\")\n            self.insertPlainText(text)\n            self.move_cursor(\"end\")\n\n    def set_text(self, text: str):\n        self.setPlainText(text)\n\n    def set_syntaxhighlighter(self, syntax: str, style: str | None = None):\n        self._hl = syntaxhighlighters.PygmentsHighlighter(self.document(), syntax)\n        if style is not None:\n            self._hl.set_style(style)\n\n    def text(self) -&gt; str:\n        return self.toPlainText()\n\n    def select_text(self, start: int, end: int):\n        with self.create_cursor() as c:\n            c.select_text(start, end)\n\n    def set_read_only(self, value: bool = True):\n\"\"\"Make the PlainTextEdit read-only.\n\n        Args:\n            value: True, for read-only, otherwise False\n        \"\"\"\n        self.setReadOnly(value)\n\n    def show_whitespace_and_tabs(self, show: bool):\n\"\"\"Set show white spaces flag.\"\"\"\n        doc = self.document()\n        options = doc.defaultTextOption()\n        flag = QtGui.QTextOption.Flag.ShowTabsAndSpaces\n        if show:\n            options.setFlags(options.flags() | flag)  # type: ignore\n        else:\n            options.setFlags(options.flags() &amp; ~flag)  # type: ignore\n        doc.setDefaultTextOption(options)\n\n    def highlight_current_line(self, color: datatypes.ColorType = None):\n        if color is None:\n            color = self.get_palette().get_color(\"highlight\")\n        else:\n            color = colors.get_color(color)\n        extra_selections = []\n\n        if not self.isReadOnly():\n            selection = widgets.TextEdit.ExtraSelection()\n            selection.format.setBackground(color)\n            prop = QtGui.QTextFormat.Property.FullWidthSelection\n            selection.format.setProperty(prop, True)\n            selection.cursor = self.textCursor()\n            selection.cursor.clearSelection()\n            extra_selections.append(selection)\n\n        self.setExtraSelections(extra_selections)\n\n    @deprecated(reason=\"This method is deprecated, use set_word_wrap_mode instead.\")\n    def set_wrap_mode(self, mode: gui.textoption.WordWrapModeStr):\n        self.set_word_wrap_mode(mode)\n\n    def set_word_wrap_mode(self, mode: gui.textoption.WordWrapModeStr):\n\"\"\"Set word wrap mode.\n\n        Args:\n            mode: word wrap mode to use\n\n        Raises:\n            InvalidParamError: wrap mode does not exist\n        \"\"\"\n        if mode not in gui.textoption.WORD_WRAP_MODE:\n            raise InvalidParamError(mode, gui.textoption.WORD_WRAP_MODE)\n        self.setWordWrapMode(gui.textoption.WORD_WRAP_MODE[mode])\n\n    @deprecated(reason=\"This method is deprecated, use get_word_wrap_mode instead.\")\n    def get_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n        return self.get_word_wrap_mode()\n\n    def get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n\n        Returns:\n            Word wrap mode\n        \"\"\"\n        return gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\n\n    def set_line_wrap_mode(self, mode: LineWrapModeStr):\n\"\"\"Set line wrap mode.\n\n        Args:\n            mode: line wrap mode to use\n\n        Raises:\n            InvalidParamError: line wrap mode does not exist\n        \"\"\"\n        if mode not in LINE_WRAP_MODE:\n            raise InvalidParamError(mode, LINE_WRAP_MODE)\n        self.setLineWrapMode(LINE_WRAP_MODE[mode])\n\n    def get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n\n        Returns:\n            Wrap mode\n        \"\"\"\n        return LINE_WRAP_MODE.inverse[self.lineWrapMode()]\n\n    def _on_value_change(self):\n        self.value_changed.emit()\n        if self.validator is not None:\n            self._set_validation_color()\n\n    def _set_validation_color(self, state: bool = True):\n        color = \"orange\" if not self.is_valid() else None\n        self.set_background_color(color)\n\n    def set_validator(self, validator: QtGui.QValidator | None):\n        self.validator = validator\n        self._set_validation_color()\n\n    def set_regex_validator(self, regex: str, flags=0) -&gt; gui.RegularExpressionValidator:\n        validator = gui.RegularExpressionValidator(self)\n        validator.set_regex(regex, flags)\n        self.set_validator(validator)\n        return validator\n\n    def is_valid(self) -&gt; bool:\n        if self.validator is None:\n            return True\n        return self.validator.is_valid_value(self.text())\n\n    def set_value(self, value: str):\n        self.setPlainText(value)\n\n    def get_value(self) -&gt; str:\n        return self.text()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.get_line_wrap_mode","title":"<code>get_line_wrap_mode(self) -&gt; LineWrapModeStr</code>","text":"<p>Get the current wrap mode.</p> <p>Returns:</p> Type Description <code>LineWrapModeStr</code> <p>Wrap mode</p> Source code in <code>prettyqt/widgets/plaintextedit.py</code> <pre><code>def get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n\n    Returns:\n        Wrap mode\n    \"\"\"\n    return LINE_WRAP_MODE.inverse[self.lineWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.get_word_wrap_mode","title":"<code>get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr</code>","text":"<p>Get the current word wrap mode.</p> <p>Returns:</p> Type Description <code>gui.textoption.WordWrapModeStr</code> <p>Word wrap mode</p> Source code in <code>prettyqt/widgets/plaintextedit.py</code> <pre><code>def get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n\n    Returns:\n        Word wrap mode\n    \"\"\"\n    return gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.set_line_wrap_mode","title":"<code>set_line_wrap_mode(self, mode: LineWrapModeStr)</code>","text":"<p>Set line wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>LineWrapModeStr</code> <p>line wrap mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>line wrap mode does not exist</p> Source code in <code>prettyqt/widgets/plaintextedit.py</code> <pre><code>def set_line_wrap_mode(self, mode: LineWrapModeStr):\n\"\"\"Set line wrap mode.\n\n    Args:\n        mode: line wrap mode to use\n\n    Raises:\n        InvalidParamError: line wrap mode does not exist\n    \"\"\"\n    if mode not in LINE_WRAP_MODE:\n        raise InvalidParamError(mode, LINE_WRAP_MODE)\n    self.setLineWrapMode(LINE_WRAP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.set_read_only","title":"<code>set_read_only(self, value: bool = True)</code>","text":"<p>Make the PlainTextEdit read-only.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>True, for read-only, otherwise False</p> <code>True</code> Source code in <code>prettyqt/widgets/plaintextedit.py</code> <pre><code>def set_read_only(self, value: bool = True):\n\"\"\"Make the PlainTextEdit read-only.\n\n    Args:\n        value: True, for read-only, otherwise False\n    \"\"\"\n    self.setReadOnly(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.set_word_wrap_mode","title":"<code>set_word_wrap_mode(self, mode: gui.textoption.WordWrapModeStr)</code>","text":"<p>Set word wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>gui.textoption.WordWrapModeStr</code> <p>word wrap mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>wrap mode does not exist</p> Source code in <code>prettyqt/widgets/plaintextedit.py</code> <pre><code>def set_word_wrap_mode(self, mode: gui.textoption.WordWrapModeStr):\n\"\"\"Set word wrap mode.\n\n    Args:\n        mode: word wrap mode to use\n\n    Raises:\n        InvalidParamError: wrap mode does not exist\n    \"\"\"\n    if mode not in gui.textoption.WORD_WRAP_MODE:\n        raise InvalidParamError(mode, gui.textoption.WORD_WRAP_MODE)\n    self.setWordWrapMode(gui.textoption.WORD_WRAP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.show_whitespace_and_tabs","title":"<code>show_whitespace_and_tabs(self, show: bool)</code>","text":"<p>Set show white spaces flag.</p> Source code in <code>prettyqt/widgets/plaintextedit.py</code> <pre><code>def show_whitespace_and_tabs(self, show: bool):\n\"\"\"Set show white spaces flag.\"\"\"\n    doc = self.document()\n    options = doc.defaultTextOption()\n    flag = QtGui.QTextOption.Flag.ShowTabsAndSpaces\n    if show:\n        options.setFlags(options.flags() | flag)  # type: ignore\n    else:\n        options.setFlags(options.flags() &amp; ~flag)  # type: ignore\n    doc.setDefaultTextOption(options)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEditMixin.wheelEvent","title":"<code>wheelEvent(self, event)</code>","text":"<p>Handle wheel event for zooming.</p> Source code in <code>prettyqt/widgets/plaintextedit.py</code> <pre><code>def wheelEvent(self, event):\n\"\"\"Handle wheel event for zooming.\"\"\"\n    if not self._allow_wheel_zoom:\n        return None\n    if event.modifiers() &amp; constants.CTRL_MOD:\n        self.zoomIn() if event.angleDelta().y() &gt; 0 else self.zoomOut()\n    else:\n        super().wheelEvent(event)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar","title":"<code>progressbar</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar","title":"<code> ProgressBar            (WidgetMixin, QProgressBar)         </code>","text":"Source code in <code>prettyqt/widgets/progressbar.py</code> <pre><code>class ProgressBar(widgets.WidgetMixin, QtWidgets.QProgressBar):\n\"\"\"Progress dialog.\n\n    wrapper for QtWidgets.QProgressBar\n    \"\"\"\n\n    def __init__(\n        self, text_visible: bool = True, parent: QtWidgets.QWidget | None = None\n    ):\n        super().__init__(parent=parent)\n        self.setTextVisible(text_visible)\n\n    def serialize_fields(self):\n        return dict(\n            alignment=self.get_alignment(),\n            format=self.format(),\n            # inverted_appearance=self.invertedAppearance(),\n            minimum=self.minimum(),\n            maximum=self.maximum(),\n            orientation=self.get_orientation(),\n            text=self.text(),\n            # text_direction=self.get_text_direction(),\n            text_visible=self.isTextVisible(),\n            value=self.value(),\n        )\n\n    def set_alignment(self, alignment: constants.AlignmentStr):\n\"\"\"Set the alignment of the layout.\n\n        Args:\n            alignment: alignment for the layout\n\n        Raises:\n            InvalidParamError: alignment does not exist\n        \"\"\"\n        if alignment not in constants.ALIGNMENTS:\n            raise InvalidParamError(alignment, constants.ALIGNMENTS)\n        self.setAlignment(constants.ALIGNMENTS[alignment])\n\n    def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n\n        Returns:\n            alignment\n        \"\"\"\n        return constants.ALIGNMENTS.inverse[self.alignment()]\n\n    def set_text_direction(self, text_direction: TextDirectionStr):\n\"\"\"Set the text direction of the layout.\n\n        Args:\n            text_direction: text direction for the layout\n\n        Raises:\n            InvalidParamError: text direction does not exist\n        \"\"\"\n        if text_direction not in TEXT_DIRECTIONS:\n            raise InvalidParamError(text_direction, TEXT_DIRECTIONS)\n        self.setTextDirection(TEXT_DIRECTIONS[text_direction])\n\n    def get_text_direction(self) -&gt; TextDirectionStr:\n\"\"\"Return current text direction.\n\n        Returns:\n            Text direction\n        \"\"\"\n        return TEXT_DIRECTIONS.inverse[self.textDirection()]\n\n    def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the progress bar.\n\n        Args:\n            orientation: orientation for the progress bar\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in constants.ORIENTATION:\n            raise InvalidParamError(orientation, constants.ORIENTATION)\n        self.setOrientation(constants.ORIENTATION[orientation])\n\n    def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return constants.ORIENTATION.inverse[self.orientation()]\n\n    def set_range(self, start: int, end: int):\n        self.setRange(start, end)\n\n    def set_value(self, value: int):\n        self.setValue(value)\n\n    def get_value(self) -&gt; int:\n        return self.value()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_alignment","title":"<code>get_alignment(self) -&gt; constants.AlignmentStr</code>","text":"<p>Return current alignment.</p> <p>Returns:</p> Type Description <code>constants.AlignmentStr</code> <p>alignment</p> Source code in <code>prettyqt/widgets/progressbar.py</code> <pre><code>def get_alignment(self) -&gt; constants.AlignmentStr:\n\"\"\"Return current alignment.\n\n    Returns:\n        alignment\n    \"\"\"\n    return constants.ALIGNMENTS.inverse[self.alignment()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_orientation","title":"<code>get_orientation(self) -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt/widgets/progressbar.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_text_direction","title":"<code>get_text_direction(self) -&gt; TextDirectionStr</code>","text":"<p>Return current text direction.</p> <p>Returns:</p> Type Description <code>TextDirectionStr</code> <p>Text direction</p> Source code in <code>prettyqt/widgets/progressbar.py</code> <pre><code>def get_text_direction(self) -&gt; TextDirectionStr:\n\"\"\"Return current text direction.\n\n    Returns:\n        Text direction\n    \"\"\"\n    return TEXT_DIRECTIONS.inverse[self.textDirection()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_alignment","title":"<code>set_alignment(self, alignment: constants.AlignmentStr)</code>","text":"<p>Set the alignment of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>alignment</code> <code>constants.AlignmentStr</code> <p>alignment for the layout</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>alignment does not exist</p> Source code in <code>prettyqt/widgets/progressbar.py</code> <pre><code>def set_alignment(self, alignment: constants.AlignmentStr):\n\"\"\"Set the alignment of the layout.\n\n    Args:\n        alignment: alignment for the layout\n\n    Raises:\n        InvalidParamError: alignment does not exist\n    \"\"\"\n    if alignment not in constants.ALIGNMENTS:\n        raise InvalidParamError(alignment, constants.ALIGNMENTS)\n    self.setAlignment(constants.ALIGNMENTS[alignment])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_orientation","title":"<code>set_orientation(self, orientation: constants.OrientationStr)</code>","text":"<p>Set the orientation of the progress bar.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr</code> <p>orientation for the progress bar</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt/widgets/progressbar.py</code> <pre><code>def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the progress bar.\n\n    Args:\n        orientation: orientation for the progress bar\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in constants.ORIENTATION:\n        raise InvalidParamError(orientation, constants.ORIENTATION)\n    self.setOrientation(constants.ORIENTATION[orientation])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_text_direction","title":"<code>set_text_direction(self, text_direction: TextDirectionStr)</code>","text":"<p>Set the text direction of the layout.</p> <p>Parameters:</p> Name Type Description Default <code>text_direction</code> <code>TextDirectionStr</code> <p>text direction for the layout</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>text direction does not exist</p> Source code in <code>prettyqt/widgets/progressbar.py</code> <pre><code>def set_text_direction(self, text_direction: TextDirectionStr):\n\"\"\"Set the text direction of the layout.\n\n    Args:\n        text_direction: text direction for the layout\n\n    Raises:\n        InvalidParamError: text direction does not exist\n    \"\"\"\n    if text_direction not in TEXT_DIRECTIONS:\n        raise InvalidParamError(text_direction, TEXT_DIRECTIONS)\n    self.setTextDirection(TEXT_DIRECTIONS[text_direction])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollbar","title":"<code>scrollbar</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.scrollbar.ScrollBarMixin","title":"<code> ScrollBarMixin            (AbstractSliderMixin)         </code>","text":"Source code in <code>prettyqt/widgets/scrollbar.py</code> <pre><code>class ScrollBarMixin(widgets.AbstractSliderMixin):\n    value_changed = core.Signal(int)\n\n    def __init__(\n        self,\n        orientation: (QtCore.Qt.Orientation | constants.OrientationStr) = \"horizontal\",\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        if isinstance(orientation, QtCore.Qt.Orientation):\n            ori = orientation\n        else:\n            ori = constants.ORIENTATION[orientation]\n        super().__init__(ori, parent)\n        self.valueChanged.connect(self.on_value_change)\n\n    def scroll_to_next_row(self):\n\"\"\"Scroll to the next row.\"\"\"\n        self.setValue(self.value() + self.singleStep())\n\n    def scroll_to_previous_row(self):\n\"\"\"Scroll to the previous row.\"\"\"\n        self.setValue(self.value() - self.singleStep())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollbar.ScrollBarMixin.scroll_to_next_row","title":"<code>scroll_to_next_row(self)</code>","text":"<p>Scroll to the next row.</p> Source code in <code>prettyqt/widgets/scrollbar.py</code> <pre><code>def scroll_to_next_row(self):\n\"\"\"Scroll to the next row.\"\"\"\n    self.setValue(self.value() + self.singleStep())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollbar.ScrollBarMixin.scroll_to_previous_row","title":"<code>scroll_to_previous_row(self)</code>","text":"<p>Scroll to the previous row.</p> Source code in <code>prettyqt/widgets/scrollbar.py</code> <pre><code>def scroll_to_previous_row(self):\n\"\"\"Scroll to the previous row.\"\"\"\n    self.setValue(self.value() - self.singleStep())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scroller","title":"<code>scroller</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.scroller.Scroller","title":"<code> Scroller            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/widgets/scroller.py</code> <pre><code>class Scroller(core.ObjectMixin):\n    def __init__(self, item: QtWidgets.QScroller):\n        self.item = item\n\n    def __getattr__(self, val):\n        return getattr(self.item, val)\n\n    def get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n\n        Returns:\n            state\n        \"\"\"\n        return STATE.inverse[self.state()]\n\n    def get_velocity(self) -&gt; core.PointF:\n        return core.PointF(self.velocity())\n\n    def get_pixel_per_meter(self) -&gt; core.PointF:\n        return core.PointF(self.pixelPerMeter())\n\n    def get_final_position(self) -&gt; core.PointF:\n        return core.PointF(self.finalPosition())\n\n    def handle_input(\n        self, input_type: InputStr, position: datatypes.PointFType, timestamp: int = 0\n    ) -&gt; bool:\n        if isinstance(position, tuple):\n            position = core.PointF(*position)\n        if input_type not in INPUT:\n            raise InvalidParamError(input_type, INPUT)\n        return self.handleInput(INPUT[input_type], position, timestamp)\n\n    def get_scroller_properties(self) -&gt; widgets.ScrollerProperties:\n        return widgets.ScrollerProperties(self.scrollerProperties())\n\n    @classmethod\n    def get_scroller(cls, obj: QtCore.QObject):\n        return cls(QtWidgets.QScroller.scroller(obj))\n\n    @staticmethod\n    def grab_gesture(\n        target: QtCore.QObject, gesture_type: ScrollGestureTypeStr = \"touch\"\n    ) -&gt; str:\n        if gesture_type not in SCROLLER_GESTURE_TYPE:\n            raise InvalidParamError(gesture_type, SCROLLER_GESTURE_TYPE)\n        gesture = QtWidgets.QScroller.grabGesture(\n            target, SCROLLER_GESTURE_TYPE[gesture_type]\n        )\n        if gesture &gt;= 256:\n            gesture -= 256\n        return constants.GESTURE_TYPE.inverse[gesture]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scroller.Scroller.get_state","title":"<code>get_state(self) -&gt; StateStr</code>","text":"<p>Return current state.</p> <p>Returns:</p> Type Description <code>StateStr</code> <p>state</p> Source code in <code>prettyqt/widgets/scroller.py</code> <pre><code>def get_state(self) -&gt; StateStr:\n\"\"\"Return current state.\n\n    Returns:\n        state\n    \"\"\"\n    return STATE.inverse[self.state()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties","title":"<code>scrollerproperties</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties","title":"<code> ScrollerProperties            (QScrollerProperties)         </code>","text":"Source code in <code>prettyqt/widgets/scrollerproperties.py</code> <pre><code>class ScrollerProperties(QtWidgets.QScrollerProperties):\n    def __getitem__(self, metric: ScrollmetricStr):\n        return self.get_scroll_metric(metric)\n\n    def __setitem__(self, metric: ScrollmetricStr, value: Any):\n        self.set_scroll_metric(metric, value)\n\n    def set_scroll_metric(self, metric: ScrollmetricStr, value: Any):\n\"\"\"Set scroll metric.\n\n        Args:\n            metric: Scroll metric to set\n            value: Value to set\n\n        Raises:\n            InvalidParamError: metric does not exist\n\n        \"\"\"\n        if metric not in SCROLL_METRIC:\n            raise InvalidParamError(metric, SCROLL_METRIC)\n        self.setScrollMetric(SCROLL_METRIC[metric], value)\n\n    def get_scroll_metric(self, metric: ScrollmetricStr) -&gt; Any:\n\"\"\"Return scroll metric.\n\n        Args:\n            metric: Scroll metric to get\n\n        Raises:\n            InvalidParamError: metric does not exist\n\n        Returns:\n            state\n        \"\"\"\n        if metric not in SCROLL_METRIC:\n            raise InvalidParamError(metric, SCROLL_METRIC)\n        return self.scrollMetric(SCROLL_METRIC[metric])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.get_scroll_metric","title":"<code>get_scroll_metric(self, metric: ScrollmetricStr) -&gt; Any</code>","text":"<p>Return scroll metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>ScrollmetricStr</code> <p>Scroll metric to get</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>metric does not exist</p> <p>Returns:</p> Type Description <code>Any</code> <p>state</p> Source code in <code>prettyqt/widgets/scrollerproperties.py</code> <pre><code>def get_scroll_metric(self, metric: ScrollmetricStr) -&gt; Any:\n\"\"\"Return scroll metric.\n\n    Args:\n        metric: Scroll metric to get\n\n    Raises:\n        InvalidParamError: metric does not exist\n\n    Returns:\n        state\n    \"\"\"\n    if metric not in SCROLL_METRIC:\n        raise InvalidParamError(metric, SCROLL_METRIC)\n    return self.scrollMetric(SCROLL_METRIC[metric])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.set_scroll_metric","title":"<code>set_scroll_metric(self, metric: ScrollmetricStr, value: Any)</code>","text":"<p>Set scroll metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>ScrollmetricStr</code> <p>Scroll metric to set</p> required <code>value</code> <code>Any</code> <p>Value to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>metric does not exist</p> Source code in <code>prettyqt/widgets/scrollerproperties.py</code> <pre><code>def set_scroll_metric(self, metric: ScrollmetricStr, value: Any):\n\"\"\"Set scroll metric.\n\n    Args:\n        metric: Scroll metric to set\n        value: Value to set\n\n    Raises:\n        InvalidParamError: metric does not exist\n\n    \"\"\"\n    if metric not in SCROLL_METRIC:\n        raise InvalidParamError(metric, SCROLL_METRIC)\n    self.setScrollMetric(SCROLL_METRIC[metric], value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.shortcut","title":"<code>shortcut</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut","title":"<code> Shortcut            (ObjectMixin, QShortcut)         </code>","text":"Source code in <code>prettyqt/widgets/shortcut.py</code> <pre><code>class Shortcut(core.ObjectMixin, QtWidgets.QShortcut):\n    def __str__(self):\n        return self.key().toString()\n\n    def serialize_field(self):\n        return dict(\n            auto_repeat=self.autoRepeat(),\n            context=self.get_context(),\n            enabled=self.isEnabled(),\n            key=self.get_key(),\n            whats_this=self.whatsThis(),\n        )\n\n    def set_context(self, context: constants.ContextStr):\n\"\"\"Set shortcut context.\n\n        Args:\n            context: shortcut context\n\n        Raises:\n            InvalidParamError: shortcut context does not exist\n        \"\"\"\n        if context not in constants.CONTEXT:\n            raise InvalidParamError(context, constants.CONTEXT)\n        self.setContext(constants.CONTEXT[context])\n\n    def get_context(self) -&gt; constants.ContextStr:\n\"\"\"Return shortcut context.\n\n        Returns:\n            shortcut context\n        \"\"\"\n        return constants.CONTEXT.inverse[self.context()]\n\n    def get_key(self) -&gt; gui.KeySequence:\n\"\"\"Return the shortcut's key sequence.\n\n        Returns:\n            Key sequence\n        \"\"\"\n        return gui.KeySequence(\n            self.key().toString(), gui.KeySequence.SequenceFormat.PortableText\n        )\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.get_context","title":"<code>get_context(self) -&gt; constants.ContextStr</code>","text":"<p>Return shortcut context.</p> <p>Returns:</p> Type Description <code>constants.ContextStr</code> <p>shortcut context</p> Source code in <code>prettyqt/widgets/shortcut.py</code> <pre><code>def get_context(self) -&gt; constants.ContextStr:\n\"\"\"Return shortcut context.\n\n    Returns:\n        shortcut context\n    \"\"\"\n    return constants.CONTEXT.inverse[self.context()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.get_key","title":"<code>get_key(self) -&gt; gui.KeySequence</code>","text":"<p>Return the shortcut's key sequence.</p> <p>Returns:</p> Type Description <code>gui.KeySequence</code> <p>Key sequence</p> Source code in <code>prettyqt/widgets/shortcut.py</code> <pre><code>def get_key(self) -&gt; gui.KeySequence:\n\"\"\"Return the shortcut's key sequence.\n\n    Returns:\n        Key sequence\n    \"\"\"\n    return gui.KeySequence(\n        self.key().toString(), gui.KeySequence.SequenceFormat.PortableText\n    )\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.set_context","title":"<code>set_context(self, context: constants.ContextStr)</code>","text":"<p>Set shortcut context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>constants.ContextStr</code> <p>shortcut context</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>shortcut context does not exist</p> Source code in <code>prettyqt/widgets/shortcut.py</code> <pre><code>def set_context(self, context: constants.ContextStr):\n\"\"\"Set shortcut context.\n\n    Args:\n        context: shortcut context\n\n    Raises:\n        InvalidParamError: shortcut context does not exist\n    \"\"\"\n    if context not in constants.CONTEXT:\n        raise InvalidParamError(context, constants.CONTEXT)\n    self.setContext(constants.CONTEXT[context])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy","title":"<code>sizepolicy</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy","title":"<code> SizePolicy            (PrettyPrinter, QSizePolicy)         </code>","text":"Source code in <code>prettyqt/widgets/sizepolicy.py</code> <pre><code>class SizePolicy(prettyprinter.PrettyPrinter, QtWidgets.QSizePolicy):\n    def __repr__(self) -&gt; str:\n        cls_name = type(self).__name__\n        params = helpers.format_kwargs(self.__getstate__())\n        return f\"{cls_name}({params})\"\n\n    def __getstate__(self):\n        return dict(\n            has_height_for_width=self.hasHeightForWidth(),\n            has_width_for_height=self.hasWidthForHeight(),\n            horizontal_stretch=self.horizontalStretch(),\n            vertical_stretch=self.verticalStretch(),\n            horizontal_policy=self.get_horizontal_policy(),\n            vertical_policy=self.get_vertical_policy(),\n            retain_size_when_hidden=self.retainSizeWhenHidden(),\n            control_type=self.get_control_type(),\n        )\n\n    def __setstate__(self, state: dict[str, Any]) -&gt; None:\n        self.setHeightForWidth(state[\"has_height_for_width\"])\n        self.setWidthForHeight(state[\"has_width_for_height\"])\n        self.setHorizontalStretch(state[\"horizontal_stretch\"])\n        self.setVerticalStretch(state[\"vertical_stretch\"])\n        self.set_horizontal_policy(state[\"horizontal_policy\"])\n        self.set_vertical_policy(state[\"vertical_policy\"])\n        self.setRetainSizeWhenHidden(state[\"retain_size_when_hidden\"])\n        self.set_control_type(state[\"control_type\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def serialize(self) -&gt; dict[str, Any]:\n        return self.__getstate__()\n\n    @classmethod\n    def clone(cls, qpol: QtWidgets.QSizePolicy) -&gt; SizePolicy:\n        pol = cls(qpol.horizontalPolicy(), qpol.verticalPolicy(), qpol.controlType())\n        pol.setHeightForWidth(qpol.hasHeightForWidth())\n        pol.setWidthForHeight(qpol.hasWidthForHeight())\n        pol.setHorizontalStretch(qpol.horizontalStretch())\n        pol.setVerticalStretch(qpol.verticalStretch())\n        pol.setRetainSizeWhenHidden(qpol.retainSizeWhenHidden())\n        return pol\n\n    def get_horizontal_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n\n        Returns:\n            horizontal size policy\n        \"\"\"\n        return SIZE_POLICY.inverse[self.horizontalPolicy()]\n\n    def set_horizontal_policy(self, policy: SizePolicyStr) -&gt; None:\n\"\"\"Set the horizontal policy.\n\n        Args:\n            policy: policy to set\n\n        Raises:\n            InvalidParamError: policy does not exist\n        \"\"\"\n        self.setHorizontalPolicy(SIZE_POLICY[policy])\n\n    def get_vertical_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n\n        Returns:\n            vertical size policy\n\n        \"\"\"\n        return SIZE_POLICY.inverse[self.verticalPolicy()]\n\n    def set_vertical_policy(self, policy: SizePolicyStr) -&gt; None:\n\"\"\"Set the horizontal policy.\n\n        Args:\n            policy: policy to set\n\n        Raises:\n            InvalidParamError: policy does not exist\n        \"\"\"\n        self.setVerticalPolicy(SIZE_POLICY[policy])\n\n    def get_control_type(self) -&gt; ControlTypeStr:\n\"\"\"Return control type.\n\n        Returns:\n            control type\n        \"\"\"\n        return CONTROL_TYPE.inverse[self.controlType()]\n\n    def set_control_type(self, typ: ControlTypeStr) -&gt; None:\n\"\"\"Set the control type.\n\n        Args:\n            typ: control type to set\n\n        Raises:\n            InvalidParamError: control type does not exist\n        \"\"\"\n        if typ not in CONTROL_TYPE:\n            raise InvalidParamError(typ, CONTROL_TYPE)\n        self.setControlType(CONTROL_TYPE[typ])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_control_type","title":"<code>get_control_type(self) -&gt; ControlTypeStr</code>","text":"<p>Return control type.</p> <p>Returns:</p> Type Description <code>ControlTypeStr</code> <p>control type</p> Source code in <code>prettyqt/widgets/sizepolicy.py</code> <pre><code>def get_control_type(self) -&gt; ControlTypeStr:\n\"\"\"Return control type.\n\n    Returns:\n        control type\n    \"\"\"\n    return CONTROL_TYPE.inverse[self.controlType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_horizontal_policy","title":"<code>get_horizontal_policy(self) -&gt; SizePolicyStr</code>","text":"<p>Return size policy.</p> <p>Returns:</p> Type Description <code>SizePolicyStr</code> <p>horizontal size policy</p> Source code in <code>prettyqt/widgets/sizepolicy.py</code> <pre><code>def get_horizontal_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n\n    Returns:\n        horizontal size policy\n    \"\"\"\n    return SIZE_POLICY.inverse[self.horizontalPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_vertical_policy","title":"<code>get_vertical_policy(self) -&gt; SizePolicyStr</code>","text":"<p>Return size policy.</p> <p>Returns:</p> Type Description <code>SizePolicyStr</code> <p>vertical size policy</p> Source code in <code>prettyqt/widgets/sizepolicy.py</code> <pre><code>def get_vertical_policy(self) -&gt; SizePolicyStr:\n\"\"\"Return size policy.\n\n    Returns:\n        vertical size policy\n\n    \"\"\"\n    return SIZE_POLICY.inverse[self.verticalPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_control_type","title":"<code>set_control_type(self, typ: ControlTypeStr) -&gt; None</code>","text":"<p>Set the control type.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>ControlTypeStr</code> <p>control type to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>control type does not exist</p> Source code in <code>prettyqt/widgets/sizepolicy.py</code> <pre><code>def set_control_type(self, typ: ControlTypeStr) -&gt; None:\n\"\"\"Set the control type.\n\n    Args:\n        typ: control type to set\n\n    Raises:\n        InvalidParamError: control type does not exist\n    \"\"\"\n    if typ not in CONTROL_TYPE:\n        raise InvalidParamError(typ, CONTROL_TYPE)\n    self.setControlType(CONTROL_TYPE[typ])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_horizontal_policy","title":"<code>set_horizontal_policy(self, policy: SizePolicyStr) -&gt; None</code>","text":"<p>Set the horizontal policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizePolicyStr</code> <p>policy to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>policy does not exist</p> Source code in <code>prettyqt/widgets/sizepolicy.py</code> <pre><code>def set_horizontal_policy(self, policy: SizePolicyStr) -&gt; None:\n\"\"\"Set the horizontal policy.\n\n    Args:\n        policy: policy to set\n\n    Raises:\n        InvalidParamError: policy does not exist\n    \"\"\"\n    self.setHorizontalPolicy(SIZE_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_vertical_policy","title":"<code>set_vertical_policy(self, policy: SizePolicyStr) -&gt; None</code>","text":"<p>Set the horizontal policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SizePolicyStr</code> <p>policy to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>policy does not exist</p> Source code in <code>prettyqt/widgets/sizepolicy.py</code> <pre><code>def set_vertical_policy(self, policy: SizePolicyStr) -&gt; None:\n\"\"\"Set the horizontal policy.\n\n    Args:\n        policy: policy to set\n\n    Raises:\n        InvalidParamError: policy does not exist\n    \"\"\"\n    self.setVerticalPolicy(SIZE_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.slider","title":"<code>slider</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider","title":"<code> Slider            (AbstractSliderMixin, QSlider)         </code>","text":"Source code in <code>prettyqt/widgets/slider.py</code> <pre><code>class Slider(widgets.AbstractSliderMixin, QtWidgets.QSlider):\n    value_changed = core.Signal(int)\n\n    def __init__(\n        self,\n        orientation: (constants.OrientationStr | QtCore.Qt.Orientation) = \"horizontal\",\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        if isinstance(orientation, QtCore.Qt.Orientation):\n            ori = orientation\n        else:\n            ori = constants.ORIENTATION[orientation]\n        super().__init__(ori, parent)\n        self.valueChanged.connect(self.on_value_change)\n\n    def serialize_fields(self):\n        return dict(\n            tick_position=self.get_tick_position(),\n            tick_interval=self.tickInterval(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_tick_position(state[\"tick_position\"])\n        self.setTickInterval(state[\"tick_interval\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def set_tick_position(self, position: TickPositionAllStr):\n\"\"\"Set the tick position for the slider.\n\n        For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\".\n\n        Args:\n            position: position for the ticks\n        \"\"\"\n        if position == \"left\":\n            position = \"above\"\n        elif position == \"right\":\n            position = \"below\"\n        elif position not in TICK_POSITION:\n            raise InvalidParamError(position, TICK_POSITION)\n        self.setTickPosition(TICK_POSITION[position])\n\n    def get_tick_position(self) -&gt; TickPositionStr:\n\"\"\"Return tick position.\n\n        Returns:\n            tick position\n        \"\"\"\n        return TICK_POSITION.inverse[self.tickPosition()]\n        # if self.is_vertical():\n        #     if val == \"above\":\n        #         return \"left\"\n        #     elif val == \"below\":\n        #         return \"right\"\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.get_tick_position","title":"<code>get_tick_position(self) -&gt; TickPositionStr</code>","text":"<p>Return tick position.</p> <p>Returns:</p> Type Description <code>TickPositionStr</code> <p>tick position</p> Source code in <code>prettyqt/widgets/slider.py</code> <pre><code>def get_tick_position(self) -&gt; TickPositionStr:\n\"\"\"Return tick position.\n\n    Returns:\n        tick position\n    \"\"\"\n    return TICK_POSITION.inverse[self.tickPosition()]\n    # if self.is_vertical():\n    #     if val == \"above\":\n    #         return \"left\"\n    #     elif val == \"below\":\n    #         return \"right\"\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.set_tick_position","title":"<code>set_tick_position(self, position: TickPositionAllStr)</code>","text":"<p>Set the tick position for the slider.</p> <p>For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\".</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>TickPositionAllStr</code> <p>position for the ticks</p> required Source code in <code>prettyqt/widgets/slider.py</code> <pre><code>def set_tick_position(self, position: TickPositionAllStr):\n\"\"\"Set the tick position for the slider.\n\n    For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\".\n\n    Args:\n        position: position for the ticks\n    \"\"\"\n    if position == \"left\":\n        position = \"above\"\n    elif position == \"right\":\n        position = \"below\"\n    elif position not in TICK_POSITION:\n        raise InvalidParamError(position, TICK_POSITION)\n    self.setTickPosition(TICK_POSITION[position])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.splitter","title":"<code>splitter</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.splitter.SplitterMixin","title":"<code> SplitterMixin            (FrameMixin)         </code>","text":"Source code in <code>prettyqt/widgets/splitter.py</code> <pre><code>class SplitterMixin(widgets.FrameMixin):\n    def __init__(\n        self,\n        orientation: (constants.OrientationStr | QtCore.Qt.Orientation) = \"horizontal\",\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        if isinstance(orientation, QtCore.Qt.Orientation):\n            ori = orientation\n        else:\n            ori = constants.ORIENTATION[orientation]\n        super().__init__(ori, parent)\n\n    def __getitem__(self, index: int | str) -&gt; QtWidgets.QWidget:\n        if isinstance(index, int):\n            return self.widget(index)\n        else:\n            result = self.find_child(QtWidgets.QWidget, index)\n            if result is None:\n                raise KeyError(\"Widget not found\")\n            return result\n\n    def __setitem__(self, index: int, value: QtWidgets.QWidget):\n        self.replaceWidget(index, value)\n\n    def serialize_fields(self):\n        return dict(\n            items=self.get_children(),\n            orientation=self.get_orientation(),\n            handle_width=self.handleWidth(),\n            children_collapsible=self.childrenCollapsible(),\n            opaque_resize=self.opaqueResize(),\n        )\n\n    def __setstate__(self, state):\n        for item in state[\"items\"]:\n            self.addWidget(item)\n        self.setHandleWidth(state[\"handle_width\"])\n        self.setChildrenCollapsible(state[\"children_collapsible\"])\n        self.setOpaqueResize(state[\"opaque_resize\"])\n\n    def __reduce__(self):\n        return type(self), (self.orientation(),), self.__getstate__()\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QWidget]:\n        return iter(self.get_children())\n\n    def __len__(self) -&gt; int:\n        return self.count()\n\n    def __contains__(self, item: QtWidgets.QWidget):\n        return self.indexOf(item) &gt;= 0\n\n    def __add__(self, other: QtWidgets.QWidget | QtWidgets.QLayout):\n        self.add(other)\n        return self\n\n    def get_children(self) -&gt; list[QtWidgets.QWidget]:\n        return [self[i] for i in range(self.count())]\n\n    def add_widget(self, widget: QtWidgets.QWidget):\n        self.addWidget(widget)\n\n    def add_layout(self, layout: QtWidgets.QLayout) -&gt; widgets.Widget:\n        widget = widgets.Widget()\n        widget.set_layout(layout)\n        self.addWidget(widget)\n        return widget\n\n    def add(self, *item: QtWidgets.QWidget | QtWidgets.QLayout):\n        for i in item:\n            if isinstance(i, QtWidgets.QWidget):\n                self.add_widget(i)\n            else:\n                self.add_layout(i)\n\n    @classmethod\n    def from_widgets(\n        cls,\n        *widgets: QtWidgets.QWidget,\n        horizontal: bool = False,\n        parent: QtWidgets.QWidget | None = None,\n    ) -&gt; Splitter:\n        splitter = cls(\"horizontal\" if horizontal else \"vertical\", parent=parent)\n        for widget in widgets:\n            splitter += widget\n        return splitter\n\n    def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the splitter.\n\n        Args:\n            orientation: orientation for the splitter\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in constants.ORIENTATION:\n            raise InvalidParamError(orientation, constants.ORIENTATION)\n        self.setOrientation(constants.ORIENTATION[orientation])\n\n    def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.splitter.SplitterMixin.get_orientation","title":"<code>get_orientation(self) -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt/widgets/splitter.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.splitter.SplitterMixin.set_orientation","title":"<code>set_orientation(self, orientation: constants.OrientationStr)</code>","text":"<p>Set the orientation of the splitter.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr</code> <p>orientation for the splitter</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt/widgets/splitter.py</code> <pre><code>def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the splitter.\n\n    Args:\n        orientation: orientation for the splitter\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in constants.ORIENTATION:\n        raise InvalidParamError(orientation, constants.ORIENTATION)\n    self.setOrientation(constants.ORIENTATION[orientation])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle","title":"<code>splitterhandle</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle.SplitterHandle","title":"<code> SplitterHandle            (WidgetMixin, QSplitterHandle)         </code>","text":"Source code in <code>prettyqt/widgets/splitterhandle.py</code> <pre><code>class SplitterHandle(widgets.WidgetMixin, QtWidgets.QSplitterHandle):\n    def __init__(\n        self,\n        orientation: constants.OrientationStr | QtCore.Qt.Orientation,\n        parent: QtWidgets.QSplitter,\n    ):\n        if isinstance(orientation, QtCore.Qt.Orientation):\n            ori = orientation\n        else:\n            ori = constants.ORIENTATION[orientation]\n        super().__init__(ori, parent)\n\n    def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the slider.\n\n        Args:\n            orientation: orientation for the slider\n\n        Raises:\n            InvalidParamError: orientation does not exist\n        \"\"\"\n        if orientation not in constants.ORIENTATION:\n            raise InvalidParamError(orientation, constants.ORIENTATION)\n        self.setOrientation(constants.ORIENTATION[orientation])\n\n    def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n        Returns:\n            orientation\n        \"\"\"\n        return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle.SplitterHandle.get_orientation","title":"<code>get_orientation(self) -&gt; constants.OrientationStr</code>","text":"<p>Return current orientation.</p> <p>Returns:</p> Type Description <code>constants.OrientationStr</code> <p>orientation</p> Source code in <code>prettyqt/widgets/splitterhandle.py</code> <pre><code>def get_orientation(self) -&gt; constants.OrientationStr:\n\"\"\"Return current orientation.\n\n    Returns:\n        orientation\n    \"\"\"\n    return constants.ORIENTATION.inverse[self.orientation()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.splitterhandle.SplitterHandle.set_orientation","title":"<code>set_orientation(self, orientation: constants.OrientationStr)</code>","text":"<p>Set the orientation of the slider.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>constants.OrientationStr</code> <p>orientation for the slider</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>orientation does not exist</p> Source code in <code>prettyqt/widgets/splitterhandle.py</code> <pre><code>def set_orientation(self, orientation: constants.OrientationStr):\n\"\"\"Set the orientation of the slider.\n\n    Args:\n        orientation: orientation for the slider\n\n    Raises:\n        InvalidParamError: orientation does not exist\n    \"\"\"\n    if orientation not in constants.ORIENTATION:\n        raise InvalidParamError(orientation, constants.ORIENTATION)\n    self.setOrientation(constants.ORIENTATION[orientation])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider","title":"<code>styleoptionslider</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider","title":"<code> StyleOptionSlider            (StyleOptionComplexMixin, QStyleOptionSlider)         </code>","text":"Source code in <code>prettyqt/widgets/styleoptionslider.py</code> <pre><code>class StyleOptionSlider(widgets.StyleOptionComplexMixin, QtWidgets.QStyleOptionSlider):\n    def is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n\n        Returns:\n            True if horizontal, else False\n        \"\"\"\n        return self.orientation == constants.HORIZONTAL\n\n    def is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n\n        Returns:\n            True if vertical, else False\n        \"\"\"\n        return self.orientation == constants.VERTICAL\n\n    def set_horizontal(self) -&gt; None:\n\"\"\"Set slider orientation to horizontal.\"\"\"\n        self.orientation = constants.HORIZONTAL\n\n    def set_vertical(self) -&gt; None:\n\"\"\"Set slider orientation to vertical.\"\"\"\n        self.orientation = constants.VERTICAL\n\n    def get_orientation(self) -&gt; Literal[\"horizontal\", \"vertical\"]:\n        return \"horizontal\" if self.is_horizontal() else \"vertical\"\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_horizontal","title":"<code>is_horizontal(self) -&gt; bool</code>","text":"<p>Check if silder is horizontal.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if horizontal, else False</p> Source code in <code>prettyqt/widgets/styleoptionslider.py</code> <pre><code>def is_horizontal(self) -&gt; bool:\n\"\"\"Check if silder is horizontal.\n\n    Returns:\n        True if horizontal, else False\n    \"\"\"\n    return self.orientation == constants.HORIZONTAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_vertical","title":"<code>is_vertical(self) -&gt; bool</code>","text":"<p>Check if silder is vertical.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if vertical, else False</p> Source code in <code>prettyqt/widgets/styleoptionslider.py</code> <pre><code>def is_vertical(self) -&gt; bool:\n\"\"\"Check if silder is vertical.\n\n    Returns:\n        True if vertical, else False\n    \"\"\"\n    return self.orientation == constants.VERTICAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_horizontal","title":"<code>set_horizontal(self) -&gt; None</code>","text":"<p>Set slider orientation to horizontal.</p> Source code in <code>prettyqt/widgets/styleoptionslider.py</code> <pre><code>def set_horizontal(self) -&gt; None:\n\"\"\"Set slider orientation to horizontal.\"\"\"\n    self.orientation = constants.HORIZONTAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_vertical","title":"<code>set_vertical(self) -&gt; None</code>","text":"<p>Set slider orientation to vertical.</p> Source code in <code>prettyqt/widgets/styleoptionslider.py</code> <pre><code>def set_vertical(self) -&gt; None:\n\"\"\"Set slider orientation to vertical.\"\"\"\n    self.orientation = constants.VERTICAL\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture","title":"<code>swipegesture</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGestureMixin","title":"<code> SwipeGestureMixin            (GestureMixin)         </code>","text":"Source code in <code>prettyqt/widgets/swipegesture.py</code> <pre><code>class SwipeGestureMixin(widgets.GestureMixin):\n    def get_horizontal_direction(self) -&gt; HorizontalDirectionStr:\n\"\"\"Return horizontal direction of the gesture.\n\n        Returns:\n            horizontal direction\n        \"\"\"\n        return SWIPE_DIRECTION.inverse[self.horizontalDirection()]\n\n    def get_vertical_direction(self) -&gt; VerticalDirectionStr:\n\"\"\"Return vertical direction of the gesture.\n\n        Returns:\n            vertical direction\n        \"\"\"\n        return SWIPE_DIRECTION.inverse[self.verticalDirection()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGestureMixin.get_horizontal_direction","title":"<code>get_horizontal_direction(self) -&gt; HorizontalDirectionStr</code>","text":"<p>Return horizontal direction of the gesture.</p> <p>Returns:</p> Type Description <code>HorizontalDirectionStr</code> <p>horizontal direction</p> Source code in <code>prettyqt/widgets/swipegesture.py</code> <pre><code>def get_horizontal_direction(self) -&gt; HorizontalDirectionStr:\n\"\"\"Return horizontal direction of the gesture.\n\n    Returns:\n        horizontal direction\n    \"\"\"\n    return SWIPE_DIRECTION.inverse[self.horizontalDirection()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGestureMixin.get_vertical_direction","title":"<code>get_vertical_direction(self) -&gt; VerticalDirectionStr</code>","text":"<p>Return vertical direction of the gesture.</p> <p>Returns:</p> Type Description <code>VerticalDirectionStr</code> <p>vertical direction</p> Source code in <code>prettyqt/widgets/swipegesture.py</code> <pre><code>def get_vertical_direction(self) -&gt; VerticalDirectionStr:\n\"\"\"Return vertical direction of the gesture.\n\n    Returns:\n        vertical direction\n    \"\"\"\n    return SWIPE_DIRECTION.inverse[self.verticalDirection()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon","title":"<code>systemtrayicon</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon","title":"<code> SystemTrayIcon            (ObjectMixin, QSystemTrayIcon)         </code>","text":"Source code in <code>prettyqt/widgets/systemtrayicon.py</code> <pre><code>class SystemTrayIcon(core.ObjectMixin, QtWidgets.QSystemTrayIcon):\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the system tray icon.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def show_message(\n        self,\n        title: str,\n        message: str = \"\",\n        icon: datatypes.IconType = None,\n        timeout: int = 10,\n    ):\n        if icon is None:\n            ico = gui.Icon()\n        if icon in MESSAGE_ICONS:\n            ico = MESSAGE_ICONS[icon]\n        else:\n            ico = iconprovider.get_icon(icon)\n        self.showMessage(title, message, ico, timeout * 1000)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon.set_icon","title":"<code>set_icon(self, icon: datatypes.IconType)</code>","text":"<p>Set the system tray icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt/widgets/systemtrayicon.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the system tray icon.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabbar","title":"<code>tabbar</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBarMixin","title":"<code> TabBarMixin            (WidgetMixin)         </code>","text":"Source code in <code>prettyqt/widgets/tabbar.py</code> <pre><code>class TabBarMixin(widgets.WidgetMixin):\n    on_detach = QtCore.Signal(int, QtCore.QPoint)\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None) -&gt; None:\n        super().__init__(parent)\n\n        self.setAcceptDrops(True)\n        self.set_elide_mode(\"right\")\n        self.set_selection_behavior_on_remove(\"left_tab\")\n\n    def __getitem__(self, index: tuple[int, str]):\n        return self.tabButton(index[0], POSITIONS[index[1]])\n\n    def __setitem__(\n        self, index: tuple[int, PositionStr], value: QtWidgets.QWidget | None\n    ):\n        self.set_tab(index[0], index[1], value)\n\n    def serialize_fields(self):\n        return dict(\n            movable=self.isMovable(),\n            document_mode=self.documentMode(),\n            current_index=self.currentIndex(),\n            # shape=self.shape(),\n            draw_base=self.drawBase(),\n            elide_mode=self.get_elide_mode(),\n            icon_size=core.Size(self.iconSize()),\n        )\n\n    def __setstate__(self, state):\n        self.setDocumentMode(state.get(\"document_mode\", False))\n        self.setMovable(state.get(\"movable\", False))\n        # self.setShape(state.get(\"shape\", \"rounded\"))\n        self.setIconSize(state[\"icon_size\"])\n        self.setDrawBase(state.get(\"draw_base\"))\n        self.set_elide_mode(state.get(\"elide_mode\"))\n        self.setCurrentIndex(state.get(\"index\", 0))\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    #  Send the on_detach when a tab is double clicked\n    def mouseDoubleClickEvent(self, event):\n        event.accept()\n        tab = self.tabAt(event.position())\n        pos = QtGui.QCursor.pos()\n        self.on_detach.emit(tab, pos)\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n        if isinstance(size, int):\n            size = core.Size(size, size)\n        elif isinstance(size, tuple):\n            size = core.Size(*size)\n        self.setIconSize(size)\n\n    def get_icon_size(self) -&gt; core.Size:\n        return core.Size(self.iconSize())\n\n    def set_tab(\n        self, index: int, position: PositionStr, widget: QtWidgets.QWidget | None\n    ) -&gt; None:\n        self.setTabButton(index, POSITIONS[position], widget)  # type: ignore\n\n    @deprecated(\n        reason=\"This method is deprecated, use set_selection_behavior_on_remove instead.\"\n    )\n    def set_remove_behaviour(self, mode: RemoveBehaviourStr) -&gt; None:\n        self.set_selection_behavior_on_remove(mode)\n\n    def set_selection_behavior_on_remove(self, mode: RemoveBehaviourStr) -&gt; None:\n\"\"\"Set the remove hehaviour.\n\n        What tab should be set as current when removeTab is called\n        if the removed tab is also the current tab.\n\n        Args:\n            mode: new remove behaviour\n        \"\"\"\n        if mode not in REMOVE_BEHAVIOUR:\n            raise InvalidParamError(mode, REMOVE_BEHAVIOUR)\n        self.setSelectionBehaviorOnRemove(REMOVE_BEHAVIOUR[mode])\n\n    def get_remove_behaviour(self) -&gt; RemoveBehaviourStr:\n\"\"\"Return remove behaviour.\n\n        Returns:\n            remove behaviour\n        \"\"\"\n        return REMOVE_BEHAVIOUR.inverse[self.selectionBehaviorOnRemove()]\n\n    def set_elide_mode(self, mode: constants.ElideModeStr) -&gt; None:\n\"\"\"Set elide mode.\n\n        Args:\n            mode: elide mode to use\n\n        Raises:\n            InvalidParamError: invalid elide mode\n        \"\"\"\n        if mode not in constants.ELIDE_MODE:\n            raise InvalidParamError(mode, constants.ELIDE_MODE)\n        self.setElideMode(constants.ELIDE_MODE[mode])\n\n    def get_elide_mode(self) -&gt; constants.ElideModeStr:\n\"\"\"Return elide mode.\n\n        Returns:\n            elide mode\n        \"\"\"\n        return constants.ELIDE_MODE.inverse[self.elideMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBarMixin.get_elide_mode","title":"<code>get_elide_mode(self) -&gt; constants.ElideModeStr</code>","text":"<p>Return elide mode.</p> <p>Returns:</p> Type Description <code>constants.ElideModeStr</code> <p>elide mode</p> Source code in <code>prettyqt/widgets/tabbar.py</code> <pre><code>def get_elide_mode(self) -&gt; constants.ElideModeStr:\n\"\"\"Return elide mode.\n\n    Returns:\n        elide mode\n    \"\"\"\n    return constants.ELIDE_MODE.inverse[self.elideMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBarMixin.get_remove_behaviour","title":"<code>get_remove_behaviour(self) -&gt; RemoveBehaviourStr</code>","text":"<p>Return remove behaviour.</p> <p>Returns:</p> Type Description <code>RemoveBehaviourStr</code> <p>remove behaviour</p> Source code in <code>prettyqt/widgets/tabbar.py</code> <pre><code>def get_remove_behaviour(self) -&gt; RemoveBehaviourStr:\n\"\"\"Return remove behaviour.\n\n    Returns:\n        remove behaviour\n    \"\"\"\n    return REMOVE_BEHAVIOUR.inverse[self.selectionBehaviorOnRemove()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBarMixin.set_elide_mode","title":"<code>set_elide_mode(self, mode: constants.ElideModeStr) -&gt; None</code>","text":"<p>Set elide mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ElideModeStr</code> <p>elide mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid elide mode</p> Source code in <code>prettyqt/widgets/tabbar.py</code> <pre><code>def set_elide_mode(self, mode: constants.ElideModeStr) -&gt; None:\n\"\"\"Set elide mode.\n\n    Args:\n        mode: elide mode to use\n\n    Raises:\n        InvalidParamError: invalid elide mode\n    \"\"\"\n    if mode not in constants.ELIDE_MODE:\n        raise InvalidParamError(mode, constants.ELIDE_MODE)\n    self.setElideMode(constants.ELIDE_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBarMixin.set_icon_size","title":"<code>set_icon_size(self, size: int | datatypes.SizeType)</code>","text":"<p>Set size of the icons.</p> Source code in <code>prettyqt/widgets/tabbar.py</code> <pre><code>def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n    if isinstance(size, int):\n        size = core.Size(size, size)\n    elif isinstance(size, tuple):\n        size = core.Size(*size)\n    self.setIconSize(size)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBarMixin.set_selection_behavior_on_remove","title":"<code>set_selection_behavior_on_remove(self, mode: RemoveBehaviourStr) -&gt; None</code>","text":"<p>Set the remove hehaviour.</p> <p>What tab should be set as current when removeTab is called if the removed tab is also the current tab.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>RemoveBehaviourStr</code> <p>new remove behaviour</p> required Source code in <code>prettyqt/widgets/tabbar.py</code> <pre><code>def set_selection_behavior_on_remove(self, mode: RemoveBehaviourStr) -&gt; None:\n\"\"\"Set the remove hehaviour.\n\n    What tab should be set as current when removeTab is called\n    if the removed tab is also the current tab.\n\n    Args:\n        mode: new remove behaviour\n    \"\"\"\n    if mode not in REMOVE_BEHAVIOUR:\n        raise InvalidParamError(mode, REMOVE_BEHAVIOUR)\n    self.setSelectionBehaviorOnRemove(REMOVE_BEHAVIOUR[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tableview","title":"<code>tableview</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableViewMixin","title":"<code> TableViewMixin            (AbstractItemViewMixin)         </code>","text":"Source code in <code>prettyqt/widgets/tableview.py</code> <pre><code>class TableViewMixin(widgets.AbstractItemViewMixin):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        class_name = type(self).__name__\n        self.set_id(class_name)\n        self.setHorizontalHeader(widgets.HeaderView(\"horizontal\", parent=self))\n        self.setVerticalHeader(widgets.HeaderView(\"vertical\", parent=self))\n        self.setAlternatingRowColors(True)\n        self.setWordWrap(False)\n\n    def serialize_fields(self):\n        return dict(\n            corner_button_enabled=self.isCornerButtonEnabled(),\n            grid_style=self.get_grid_style(),\n            show_grid=self.showGrid(),\n            sorting_enabled=self.isSortingEnabled(),\n            word_wrap=self.wordWrap(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.setCornerButtonEnabled(state[\"corner_button_enabled\"])\n        self.set_grid_style(state[\"grid_style\"])\n        self.setShowGrid(state[\"show_grid\"])\n        self.setSortingEnabled(state[\"sorting_enabled\"])\n        self.setWordWrap(state[\"word_wrap\"])\n\n    @property\n    def h_header(self):\n        return self.horizontalHeader()\n\n    @h_header.setter\n    def h_header(self, header):\n        self.setHorizontalHeader(header)\n\n    @property\n    def v_header(self):\n        return self.verticalHeader()\n\n    @v_header.setter\n    def v_header(self, header):\n        self.setVerticalHeader(header)\n\n    def setup_list_style(self):\n        self.set_selection_behaviour(\"rows\")\n        self.h_header.setStretchLastSection(True)\n        self.v_header.set_resize_mode(\"fixed\")\n        self.v_header.set_default_section_size(28)\n\n    def adapt_sizes(self):\n        model = self.model()\n        if model is not None and (model.rowCount() * model.columnCount()) &lt; 1000:\n            self.resizeColumnsToContents()\n        else:\n            self.h_header.resize_sections(\"interactive\")\n\n    def sort_by_column(self, column: int | None, ascending: bool = True):\n        column = -1 if column is None else column\n        order = constants.ASCENDING if ascending else constants.DESCENDING\n        self.sortByColumn(column, order)\n\n    def set_grid_style(self, style: constants.PenStyleStr):\n\"\"\"Set grid style.\n\n        Args:\n            style: grid style to use\n\n        Raises:\n            InvalidParamError: invalid grid style\n        \"\"\"\n        if style not in constants.PEN_STYLE:\n            raise InvalidParamError(style, constants.PEN_STYLE)\n        self.setGridStyle(constants.PEN_STYLE[style])\n\n    def get_grid_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return grid style.\n\n        Returns:\n            grid style\n        \"\"\"\n        return constants.PEN_STYLE.inverse[self.gridStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableViewMixin.get_grid_style","title":"<code>get_grid_style(self) -&gt; constants.PenStyleStr</code>","text":"<p>Return grid style.</p> <p>Returns:</p> Type Description <code>constants.PenStyleStr</code> <p>grid style</p> Source code in <code>prettyqt/widgets/tableview.py</code> <pre><code>def get_grid_style(self) -&gt; constants.PenStyleStr:\n\"\"\"Return grid style.\n\n    Returns:\n        grid style\n    \"\"\"\n    return constants.PEN_STYLE.inverse[self.gridStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableViewMixin.set_grid_style","title":"<code>set_grid_style(self, style: constants.PenStyleStr)</code>","text":"<p>Set grid style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.PenStyleStr</code> <p>grid style to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid grid style</p> Source code in <code>prettyqt/widgets/tableview.py</code> <pre><code>def set_grid_style(self, style: constants.PenStyleStr):\n\"\"\"Set grid style.\n\n    Args:\n        style: grid style to use\n\n    Raises:\n        InvalidParamError: invalid grid style\n    \"\"\"\n    if style not in constants.PEN_STYLE:\n        raise InvalidParamError(style, constants.PEN_STYLE)\n    self.setGridStyle(constants.PEN_STYLE[style])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem","title":"<code>tablewidgetitem</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem","title":"<code> TableWidgetItem            (QTableWidgetItem)         </code>","text":"Source code in <code>prettyqt/widgets/tablewidgetitem.py</code> <pre><code>class TableWidgetItem(QtWidgets.QTableWidgetItem):\n    def __setitem__(self, index: int, value):\n        self.setData(index, value)\n\n    def __getitem__(self, index: int):\n        return self.data(index)\n\n    def serialize_fields(self):\n        return dict(\n            text=self.text(),\n            tool_tip=self.toolTip(),\n            status_tip=self.statusTip(),\n            checkstate=self.get_checkstate(),\n            icon=self.get_icon(),\n            data=self.data(constants.USER_ROLE),  # type: ignore\n        )\n\n    def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(icon)\n\n    def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n        Args:\n            state: checkstate to use\n\n        Raises:\n            InvalidParamError: invalid checkstate\n        \"\"\"\n        if state not in constants.STATE:\n            raise InvalidParamError(state, constants.STATE)\n        self.setCheckState(constants.STATE[state])\n\n    def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n        Returns:\n            checkstate\n        \"\"\"\n        return constants.STATE.inverse[self.checkState()]\n\n    def set_text_alignment(\n        self,\n        horizontal: constants.HorizontalAlignmentStr | None = None,\n        vertical: constants.VerticalAlignmentStr | None = None,\n    ):\n\"\"\"Set text alignment of the checkbox.\n\n        Args:\n            horizontal: horizontal text alignment to use\n            vertical: vertical text alignment to use\n\n        Raises:\n            InvalidParamError: invalid text alignment\n        \"\"\"\n        match horizontal, vertical:\n            case None, None:\n                return\n            case None, _:\n                flag = constants.V_ALIGNMENT[vertical]\n            case _, None:\n                flag = constants.H_ALIGNMENT[horizontal]\n            case _, _:\n                flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n        self.setTextAlignment(flag)\n\n    def get_background(self) -&gt; gui.Brush:\n        return gui.Brush(self.background())\n\n    def get_foreground(self) -&gt; gui.Brush:\n        return gui.Brush(self.foreground())\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.icon()\n        if icon.isNull():\n            return None\n        return gui.Icon(icon)\n\n    def set_tooltip(\n        self,\n        tooltip: str | datatypes.PathType,\n        size: datatypes.SizeType | None = None,\n    ):\n        if isinstance(tooltip, os.PathLike):\n            path = os.fspath(tooltip)\n            if size is None:\n                tooltip = f\"&lt;img src={path!r}&gt;\"\n            else:\n                if isinstance(size, QtCore.QSize):\n                    size = (size.width(), size.height())\n                tooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\n        self.setToolTip(tooltip)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.get_checkstate","title":"<code>get_checkstate(self) -&gt; constants.StateStr</code>","text":"<p>Return checkstate.</p> <p>Returns:</p> Type Description <code>constants.StateStr</code> <p>checkstate</p> Source code in <code>prettyqt/widgets/tablewidgetitem.py</code> <pre><code>def get_checkstate(self) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n    Returns:\n        checkstate\n    \"\"\"\n    return constants.STATE.inverse[self.checkState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_checkstate","title":"<code>set_checkstate(self, state: constants.StateStr)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.StateStr</code> <p>checkstate to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid checkstate</p> Source code in <code>prettyqt/widgets/tablewidgetitem.py</code> <pre><code>def set_checkstate(self, state: constants.StateStr):\n\"\"\"Set checkstate of the checkbox.\n\n    Args:\n        state: checkstate to use\n\n    Raises:\n        InvalidParamError: invalid checkstate\n    \"\"\"\n    if state not in constants.STATE:\n        raise InvalidParamError(state, constants.STATE)\n    self.setCheckState(constants.STATE[state])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_icon","title":"<code>set_icon(self, icon: datatypes.IconType)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt/widgets/tablewidgetitem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the action.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_text_alignment","title":"<code>set_text_alignment(self, horizontal: constants.HorizontalAlignmentStr | None = None, vertical: constants.VerticalAlignmentStr | None = None)</code>","text":"<p>Set text alignment of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>horizontal</code> <code>constants.HorizontalAlignmentStr | None</code> <p>horizontal text alignment to use</p> <code>None</code> <code>vertical</code> <code>constants.VerticalAlignmentStr | None</code> <p>vertical text alignment to use</p> <code>None</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid text alignment</p> Source code in <code>prettyqt/widgets/tablewidgetitem.py</code> <pre><code>def set_text_alignment(\n    self,\n    horizontal: constants.HorizontalAlignmentStr | None = None,\n    vertical: constants.VerticalAlignmentStr | None = None,\n):\n\"\"\"Set text alignment of the checkbox.\n\n    Args:\n        horizontal: horizontal text alignment to use\n        vertical: vertical text alignment to use\n\n    Raises:\n        InvalidParamError: invalid text alignment\n    \"\"\"\n    match horizontal, vertical:\n        case None, None:\n            return\n        case None, _:\n            flag = constants.V_ALIGNMENT[vertical]\n        case _, None:\n            flag = constants.H_ALIGNMENT[horizontal]\n        case _, _:\n            flag = constants.V_ALIGNMENT[vertical] | constants.H_ALIGNMENT[horizontal]\n    self.setTextAlignment(flag)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget","title":"<code>tabwidget</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab","title":"<code> DetachedTab            (MainWindow)         </code>","text":"Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>class DetachedTab(widgets.MainWindow):\n\"\"\"Window containing a detached tab.\n\n    When a tab is detached, the contents are placed into this QMainWindow.\n    The tab can be re-attached by closing the dialog\n\n    Attributes:\n        on_close: signal, emitted when window is closed (widget, title, icon)\n    \"\"\"\n\n    on_close = core.Signal(QtWidgets.QWidget, str, QtGui.QIcon)\n\n    def __init__(self, name: str, widget: QtWidgets.QWidget):\n        super().__init__(None)\n\n        self.set_id(name)\n        self.set_title(name)\n\n        self.widget = widget\n        self.setCentralWidget(self.widget)\n        self.widget.show()\n\n    #  If the window is closed, emit the on_close and give the\n    #  content widget back to the DetachableTabWidget\n    def closeEvent(self, event):\n        self.on_close.emit(self.widget, self.get_id(), self.windowIcon())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab.closeEvent","title":"<code>closeEvent(self, event)</code>","text":"<p>closeEvent(self, event: PySide6.QtGui.QCloseEvent) -&gt; None</p> Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>def closeEvent(self, event):\n    self.on_close.emit(self.widget, self.get_id(), self.windowIcon())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget","title":"<code> TabWidget            (WidgetMixin, QTabWidget)         </code>","text":"Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>class TabWidget(widgets.WidgetMixin, QtWidgets.QTabWidget):\n\"\"\"Widget for managing the tabs section.\"\"\"\n\n    def __init__(\n        self,\n        parent: QtWidgets.QWidget | None = None,\n        closable: bool = False,\n        detachable: bool = False,\n    ) -&gt; None:\n        # Basic initalization\n        super().__init__(parent)\n        self.tabCloseRequested.connect(self.remove_tab)\n        self.tab_bar = widgets.TabBar(self)\n\n        self.setTabBar(self.tab_bar)\n\n        # Used to keep a reference to detached tabs since their QMainWindow\n        # does not have a parent\n        self.detached_tabs: dict[str, DetachedTab] = {}\n        if detachable:\n            self.set_detachable()\n        self.set_closable(closable)\n\n    def __len__(self) -&gt; int:\n        return self.count()\n\n    def __getitem__(self, index: int) -&gt; QtWidgets.QWidget:\n        if isinstance(index, int):\n            return self.widget(index)\n        else:\n            result = self.findChild(QtWidgets.QWidget, index)\n            if result is None:\n                raise KeyError(\"Widget not found\")\n            return result\n\n    def __contains__(self, item: QtWidgets.QWidget):\n        return self.indexOf(item) &gt;= 0\n\n    def serialize_fields(self):\n        return dict(\n            tabbar=self.tabBar(),\n            widgets=self.get_children(),\n            movable=self.isMovable(),\n            document_mode=self.documentMode(),\n            current_index=self.currentIndex(),\n            tab_shape=self.get_tab_shape(),\n            # elide_mode=self.get_elide_mode(),\n            icon_size=self.iconSize(),\n            tab_position=self.get_tab_position(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.setTabBar(state[\"tabbar\"])\n        self.setDocumentMode(state.get(\"document_mode\", False))\n        self.setMovable(state.get(\"movable\", False))\n        self.set_tab_shape(state.get(\"tab_shape\", \"rounded\"))\n        self.setIconSize(state[\"icon_size\"])\n        for widget, name, icon, tooltip, whatsthis in state[\"widgets\"]:\n            i = self.add_tab(widget, name, icon)\n            self.setTabToolTip(i, tooltip)\n            self.setTabWhatsThis(i, whatsthis)\n        self.setCurrentIndex(state.get(\"index\", 0))\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def update_tab_bar_visibility(self):\n\"\"\"Update visibility of the tabBar depending of the number of tabs.\n\n        0 or 1 tab -&gt; tabBar hidden, 2+ tabs - &gt;tabBar visible\n        need to be called explicitly, or be connected to tabInserted/tabRemoved\n        \"\"\"\n        self.tabBar().setVisible(self.count() &gt; 1)\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n        if isinstance(size, int):\n            size = core.Size(size, size)\n        elif isinstance(size, tuple):\n            size = core.Size(*size)\n        self.setIconSize(size)\n\n    def set_document_mode(self, state: bool = True) -&gt; None:\n        self.setDocumentMode(state)\n\n    def set_tab_shape(self, shape: TabShapeStr):\n\"\"\"Set tab shape for the tabwidget.\n\n        Args:\n            shape: tab shape to use\n\n        Raises:\n            InvalidParamError: tab shape does not exist\n        \"\"\"\n        if shape not in TAB_SHAPES:\n            raise InvalidParamError(shape, TAB_SHAPES)\n        self.setTabShape(TAB_SHAPES[shape])\n\n    def get_tab_shape(self) -&gt; TabShapeStr:\n\"\"\"Return tab shape.\n\n        Returns:\n            tab shape\n        \"\"\"\n        return TAB_SHAPES.inverse[self.tabShape()]\n\n    def set_tab_position(self, position: TabPositionStr):\n\"\"\"Set tab position for the tabwidget.\n\n        Args:\n            position: tab position to use\n\n        Raises:\n            InvalidParamError: tab position does not exist\n        \"\"\"\n        if position not in TAB_POSITION:\n            raise InvalidParamError(position, TAB_POSITION)\n        self.setTabPosition(TAB_POSITION[position])\n\n    def get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return tab position.\n\n        Returns:\n            tab position\n        \"\"\"\n        return TAB_POSITION.inverse[self.tabPosition()]\n\n    def get_children(self) -&gt; list[tuple]:\n        return [\n            (\n                self.widget(i),\n                self.tabText(i),\n                self.tab_icon(i),\n                self.tabToolTip(i),\n                self.tabWhatsThis(i),\n            )\n            for i in range(self.count())\n        ]\n\n    def tab_icon(self, i: int) -&gt; gui.Icon | None:\n        icon = self.tabIcon(i)\n        if icon.isNull():\n            return None\n        return gui.Icon(icon)\n\n    def set_detachable(self):\n        self.tab_bar.on_detach.connect(self.detach_tab)\n        core.CoreApplication.call_on_exit(self.close_detached_tabs)\n        self.setMovable(True)\n\n    def set_closable(self, closable: bool = True):\n        self.setTabsClosable(closable)\n\n    @core.Slot(int, QtCore.QPoint)\n    def detach_tab(self, index: int, point: datatypes.PointType):\n\"\"\"Detach tab by removing its contents and placing them in a DetachedTab window.\n\n        Args:\n            index (int): index location of the tab to be detached\n            point (QtCore.QPoint): screen pos for creating the new DetachedTab window\n\n        Returns:\n            None: Description\n        \"\"\"\n        # Get the tab content\n        if isinstance(point, tuple):\n            point = QtCore.QPoint(*point)\n        name = self.tabText(index)\n        icon = self.tab_icon(index)\n        if icon is None:\n            icon = self.window().windowIcon()\n        widget = self.widget(index)\n\n        try:\n            widget_rect = widget.frameGeometry()\n        except AttributeError:\n            return\n\n        # Create a new detached tab window\n        detached_tab = DetachedTab(name, widget)\n        detached_tab.set_modality(\"none\")\n        detached_tab.set_icon(icon)\n        detached_tab.setGeometry(widget_rect)\n        detached_tab.on_close.connect(self.attach_tab)\n        detached_tab.move(point)\n        detached_tab.show()\n\n        # Create a reference to maintain access to the detached tab\n        self.detached_tabs[name] = detached_tab\n\n    def add_tab(\n        self,\n        item: QtWidgets.QWidget | QtWidgets.QLayout,\n        label: str,\n        icon: datatypes.IconType = None,\n        position: int | None = None,\n        show: bool = False,\n    ) -&gt; int:\n        if isinstance(item, QtWidgets.QLayout):\n            widget = widgets.Widget()\n            widget.set_layout(item)\n        else:\n            widget = item\n        if position is None:\n            position = len(self)\n        if not icon:\n            index = self.insertTab(position, widget, label)\n        else:\n            icon = iconprovider.get_icon(icon)\n            index = self.insertTab(position, widget, icon, label)\n        if show:\n            self.setCurrentIndex(index)\n        return index\n\n    def attach_tab(\n        self,\n        widget: QtWidgets.QWidget | QtWidgets.QLayout,\n        name: str,\n        icon: datatypes.IconType = None,\n        insert_at: int | None = None,\n    ):\n\"\"\"Re-attach tab.\n\n        Re-attach the tab by removing the content from the DetachedTab window,\n        closing it, and placing the content back into the DetachableTabWidget.\n\n        Args:\n            widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget\n                from the DetachedTab window\n            name (str): the name of the detached tab\n            icon (datatypes.IconType, optional): the window icon for the detached tab\n            insert_at (Optional[int], optional): insert the re-attached tab at the\n                given index\n        \"\"\"\n        widget.setParent(self)\n\n        # Remove the reference\n        del self.detached_tabs[name]\n\n        # Determine if the given image and the main window icon are the same.\n        # If they are, then do not add the icon to the tab\n        self.add_tab(widget, name, icon=icon, position=insert_at, show=True)\n\n    def close_detached_tabs(self):\n\"\"\"Close all tabs that are currently detached.\"\"\"\n        tabs = list(self.detached_tabs.values())\n        for tab in tabs:\n            tab.close()\n\n    @core.Slot(int)\n    def remove_tab(self, index: int):\n        widget = self.widget(index)\n        self.removeTab(index)\n        if widget is not None:\n            widget.deleteLater()\n\n    @core.Slot(QtWidgets.QWidget, str)\n    def open_widget(self, widget: QtWidgets.QWidget, title: str = \"Unnamed\"):\n\"\"\"Create a tab containing delivered widget.\"\"\"\n        self.add_tab(widget, title, icon=\"mdi.widgets\", show=True)\n\n    def set_tab(self, index: int, position: str, widget: QtWidgets.QWidget | None = None):\n        self.tabBar().set_tab(index, position, widget)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.attach_tab","title":"<code>attach_tab(self, widget: QtWidgets.QWidget | QtWidgets.QLayout, name: str, icon: datatypes.IconType = None, insert_at: int | None = None)</code>","text":"<p>Re-attach tab.</p> <p>Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>Union[QtWidgets.QWidget, QtWidgets.QLayout]</code> <p>the content widget from the DetachedTab window</p> required <code>name</code> <code>str</code> <p>the name of the detached tab</p> required <code>icon</code> <code>datatypes.IconType</code> <p>the window icon for the detached tab</p> <code>None</code> <code>insert_at</code> <code>Optional[int]</code> <p>insert the re-attached tab at the given index</p> <code>None</code> Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>def attach_tab(\n    self,\n    widget: QtWidgets.QWidget | QtWidgets.QLayout,\n    name: str,\n    icon: datatypes.IconType = None,\n    insert_at: int | None = None,\n):\n\"\"\"Re-attach tab.\n\n    Re-attach the tab by removing the content from the DetachedTab window,\n    closing it, and placing the content back into the DetachableTabWidget.\n\n    Args:\n        widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget\n            from the DetachedTab window\n        name (str): the name of the detached tab\n        icon (datatypes.IconType, optional): the window icon for the detached tab\n        insert_at (Optional[int], optional): insert the re-attached tab at the\n            given index\n    \"\"\"\n    widget.setParent(self)\n\n    # Remove the reference\n    del self.detached_tabs[name]\n\n    # Determine if the given image and the main window icon are the same.\n    # If they are, then do not add the icon to the tab\n    self.add_tab(widget, name, icon=icon, position=insert_at, show=True)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.close_detached_tabs","title":"<code>close_detached_tabs(self)</code>","text":"<p>Close all tabs that are currently detached.</p> Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>def close_detached_tabs(self):\n\"\"\"Close all tabs that are currently detached.\"\"\"\n    tabs = list(self.detached_tabs.values())\n    for tab in tabs:\n        tab.close()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.detach_tab","title":"<code>detach_tab(self, index: int, point: datatypes.PointType)</code>","text":"<p>Detach tab by removing its contents and placing them in a DetachedTab window.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index location of the tab to be detached</p> required <code>point</code> <code>QtCore.QPoint</code> <p>screen pos for creating the new DetachedTab window</p> required <p>Returns:</p> Type Description <code>None</code> <p>Description</p> Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>@core.Slot(int, QtCore.QPoint)\ndef detach_tab(self, index: int, point: datatypes.PointType):\n\"\"\"Detach tab by removing its contents and placing them in a DetachedTab window.\n\n    Args:\n        index (int): index location of the tab to be detached\n        point (QtCore.QPoint): screen pos for creating the new DetachedTab window\n\n    Returns:\n        None: Description\n    \"\"\"\n    # Get the tab content\n    if isinstance(point, tuple):\n        point = QtCore.QPoint(*point)\n    name = self.tabText(index)\n    icon = self.tab_icon(index)\n    if icon is None:\n        icon = self.window().windowIcon()\n    widget = self.widget(index)\n\n    try:\n        widget_rect = widget.frameGeometry()\n    except AttributeError:\n        return\n\n    # Create a new detached tab window\n    detached_tab = DetachedTab(name, widget)\n    detached_tab.set_modality(\"none\")\n    detached_tab.set_icon(icon)\n    detached_tab.setGeometry(widget_rect)\n    detached_tab.on_close.connect(self.attach_tab)\n    detached_tab.move(point)\n    detached_tab.show()\n\n    # Create a reference to maintain access to the detached tab\n    self.detached_tabs[name] = detached_tab\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_position","title":"<code>get_tab_position(self) -&gt; TabPositionStr</code>","text":"<p>Return tab position.</p> <p>Returns:</p> Type Description <code>TabPositionStr</code> <p>tab position</p> Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>def get_tab_position(self) -&gt; TabPositionStr:\n\"\"\"Return tab position.\n\n    Returns:\n        tab position\n    \"\"\"\n    return TAB_POSITION.inverse[self.tabPosition()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_shape","title":"<code>get_tab_shape(self) -&gt; TabShapeStr</code>","text":"<p>Return tab shape.</p> <p>Returns:</p> Type Description <code>TabShapeStr</code> <p>tab shape</p> Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>def get_tab_shape(self) -&gt; TabShapeStr:\n\"\"\"Return tab shape.\n\n    Returns:\n        tab shape\n    \"\"\"\n    return TAB_SHAPES.inverse[self.tabShape()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.open_widget","title":"<code>open_widget(self, widget: QtWidgets.QWidget, title: str = 'Unnamed')</code>","text":"<p>Create a tab containing delivered widget.</p> Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>@core.Slot(QtWidgets.QWidget, str)\ndef open_widget(self, widget: QtWidgets.QWidget, title: str = \"Unnamed\"):\n\"\"\"Create a tab containing delivered widget.\"\"\"\n    self.add_tab(widget, title, icon=\"mdi.widgets\", show=True)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_icon_size","title":"<code>set_icon_size(self, size: int | datatypes.SizeType)</code>","text":"<p>Set size of the icons.</p> Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n    if isinstance(size, int):\n        size = core.Size(size, size)\n    elif isinstance(size, tuple):\n        size = core.Size(*size)\n    self.setIconSize(size)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_position","title":"<code>set_tab_position(self, position: TabPositionStr)</code>","text":"<p>Set tab position for the tabwidget.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>TabPositionStr</code> <p>tab position to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>tab position does not exist</p> Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>def set_tab_position(self, position: TabPositionStr):\n\"\"\"Set tab position for the tabwidget.\n\n    Args:\n        position: tab position to use\n\n    Raises:\n        InvalidParamError: tab position does not exist\n    \"\"\"\n    if position not in TAB_POSITION:\n        raise InvalidParamError(position, TAB_POSITION)\n    self.setTabPosition(TAB_POSITION[position])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_shape","title":"<code>set_tab_shape(self, shape: TabShapeStr)</code>","text":"<p>Set tab shape for the tabwidget.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>TabShapeStr</code> <p>tab shape to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>tab shape does not exist</p> Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>def set_tab_shape(self, shape: TabShapeStr):\n\"\"\"Set tab shape for the tabwidget.\n\n    Args:\n        shape: tab shape to use\n\n    Raises:\n        InvalidParamError: tab shape does not exist\n    \"\"\"\n    if shape not in TAB_SHAPES:\n        raise InvalidParamError(shape, TAB_SHAPES)\n    self.setTabShape(TAB_SHAPES[shape])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.update_tab_bar_visibility","title":"<code>update_tab_bar_visibility(self)</code>","text":"<p>Update visibility of the tabBar depending of the number of tabs.</p> <p>0 or 1 tab -&gt; tabBar hidden, 2+ tabs - &gt;tabBar visible need to be called explicitly, or be connected to tabInserted/tabRemoved</p> Source code in <code>prettyqt/widgets/tabwidget.py</code> <pre><code>def update_tab_bar_visibility(self):\n\"\"\"Update visibility of the tabBar depending of the number of tabs.\n\n    0 or 1 tab -&gt; tabBar hidden, 2+ tabs - &gt;tabBar visible\n    need to be called explicitly, or be connected to tabInserted/tabRemoved\n    \"\"\"\n    self.tabBar().setVisible(self.count() &gt; 1)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit","title":"<code>textedit</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin","title":"<code> TextEditMixin            (AbstractScrollAreaMixin)         </code>","text":"Source code in <code>prettyqt/widgets/textedit.py</code> <pre><code>class TextEditMixin(widgets.AbstractScrollAreaMixin):\n    value_changed = core.Signal(str)\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.textChanged.connect(self.on_value_change)\n\n    def serialize_fields(self):\n        return dict(\n            text=self.text(),\n            accept_rich_text=self.acceptRichText(),\n            auto_formatting=self.get_auto_formatting(),\n            cursor_width=self.cursorWidth(),\n            document_title=self.documentTitle(),\n            line_wrap_column_or_width=self.lineWrapColumnOrWidth(),\n            line_wrap_mode=self.get_line_wrap_mode(),\n            word_wrap_mode=self.get_word_wrap_mode(),\n            overwrite_mode=self.overwriteMode(),\n            placeholder_text=self.placeholderText(),\n            read_only=self.isReadOnly(),\n            tab_changes_focus=self.tabChangesFocus(),\n            tab_stop_distance=self.tabStopDistance(),\n            undo_redo_enabled=self.isUndoRedoEnabled(),\n        )\n\n    def __setstate__(self, state):\n        super().__setstate__(state)\n        self.set_text(state[\"text\"])\n        self.setAcceptRichText(state[\"accept_rich_text\"])\n        self.set_auto_formatting(state[\"auto_formatting\"])\n        self.setCursorWidth(state[\"cursor_width\"])\n        self.setDocumentTitle(state[\"document_title\"])\n        self.setLineWrapColumnOrWidth(state[\"line_wrap_column_or_width\"])\n        self.set_line_wrap_mode(state[\"line_wrap_mode\"])\n        self.set_word_wrap_mode(state[\"word_wrap_mode\"])\n        self.setOverwriteMode(state[\"overwrite_mode\"])\n        self.setPlaceholderText(state[\"placeholder_text\"])\n        self.setReadOnly(state[\"read_only\"])\n        self.setTabChangesFocus(state[\"tab_changes_focus\"])\n        self.setTabStopDistance(state[\"tab_stop_distance\"])\n        self.setUndoRedoEnabled(state[\"undo_redo_enabled\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __add__(self, other: str) -&gt; TextEdit:\n        self.append_text(other)\n        return self\n\n    def on_value_change(self) -&gt; None:\n        self.value_changed.emit(self.text())\n\n    @contextlib.contextmanager\n    def create_cursor(self) -&gt; Iterator[gui.TextCursor]:\n        cursor = gui.TextCursor(self.document())\n        yield cursor\n        self.setTextCursor(cursor)\n\n    def get_text_cursor(self) -&gt; gui.TextCursor:\n        return gui.TextCursor(self.textCursor())\n\n    def set_text(self, text: str) -&gt; None:\n        self.setPlainText(text)\n\n    def append_text(self, text: str) -&gt; None:\n        self.append(text)\n\n    def text(self) -&gt; str:\n        return self.toPlainText()\n\n    def select_text(self, start: int, end: int) -&gt; None:\n        with self.create_cursor() as c:\n            c.select_text(start, end)\n\n    def set_read_only(self, value: bool = True) -&gt; None:\n        self.setReadOnly(value)\n\n    def set_text_color(self, color: datatypes.ColorType) -&gt; None:\n        color = colors.get_color(color)\n        self.setTextColor(color)\n\n    def set_line_wrap_mode(self, mode: LineWrapModeStr):\n\"\"\"Set line wrap mode.\n\n        Args:\n            mode: line wrap mode to use\n\n        Raises:\n            InvalidParamError: line wrap mode does not exist\n        \"\"\"\n        if mode not in LINE_WRAP_MODE:\n            raise InvalidParamError(mode, LINE_WRAP_MODE)\n        self.setLineWrapMode(LINE_WRAP_MODE[mode])\n\n    def get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n\n        Returns:\n            Wrap mode\n        \"\"\"\n        return LINE_WRAP_MODE.inverse[self.lineWrapMode()]\n\n    def set_auto_formatting(self, mode: AutoFormattingStr):\n\"\"\"Set auto formatting mode.\n\n        Args:\n            mode: auto formatting mode to use\n\n        Raises:\n            InvalidParamError: auto formatting mode does not exist\n        \"\"\"\n        if mode not in AUTO_FORMATTING:\n            raise InvalidParamError(mode, AUTO_FORMATTING)\n        self.setAutoFormatting(AUTO_FORMATTING[mode])\n\n    def get_auto_formatting(self) -&gt; AutoFormattingStr:\n\"\"\"Get the current auto formatting mode.\n\n        Returns:\n            Auto formatting mode\n        \"\"\"\n        return AUTO_FORMATTING.inverse[self.autoFormatting()]\n\n    def set_word_wrap_mode(self, mode: gui.textoption.WordWrapModeStr):\n\"\"\"Set word wrap mode.\n\n        Args:\n            mode: word wrap mode to use\n\n        Raises:\n            InvalidParamError: wrap mode does not exist\n        \"\"\"\n        if mode not in gui.textoption.WORD_WRAP_MODE:\n            raise InvalidParamError(mode, gui.textoption.WORD_WRAP_MODE)\n        self.setWordWrapMode(gui.textoption.WORD_WRAP_MODE[mode])\n\n    def get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n\n        Returns:\n            Word wrap mode\n        \"\"\"\n        return gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.get_auto_formatting","title":"<code>get_auto_formatting(self) -&gt; AutoFormattingStr</code>","text":"<p>Get the current auto formatting mode.</p> <p>Returns:</p> Type Description <code>AutoFormattingStr</code> <p>Auto formatting mode</p> Source code in <code>prettyqt/widgets/textedit.py</code> <pre><code>def get_auto_formatting(self) -&gt; AutoFormattingStr:\n\"\"\"Get the current auto formatting mode.\n\n    Returns:\n        Auto formatting mode\n    \"\"\"\n    return AUTO_FORMATTING.inverse[self.autoFormatting()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.get_line_wrap_mode","title":"<code>get_line_wrap_mode(self) -&gt; LineWrapModeStr</code>","text":"<p>Get the current wrap mode.</p> <p>Returns:</p> Type Description <code>LineWrapModeStr</code> <p>Wrap mode</p> Source code in <code>prettyqt/widgets/textedit.py</code> <pre><code>def get_line_wrap_mode(self) -&gt; LineWrapModeStr:\n\"\"\"Get the current wrap mode.\n\n    Returns:\n        Wrap mode\n    \"\"\"\n    return LINE_WRAP_MODE.inverse[self.lineWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.get_word_wrap_mode","title":"<code>get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr</code>","text":"<p>Get the current word wrap mode.</p> <p>Returns:</p> Type Description <code>gui.textoption.WordWrapModeStr</code> <p>Word wrap mode</p> Source code in <code>prettyqt/widgets/textedit.py</code> <pre><code>def get_word_wrap_mode(self) -&gt; gui.textoption.WordWrapModeStr:\n\"\"\"Get the current word wrap mode.\n\n    Returns:\n        Word wrap mode\n    \"\"\"\n    return gui.textoption.WORD_WRAP_MODE.inverse[self.wordWrapMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.set_auto_formatting","title":"<code>set_auto_formatting(self, mode: AutoFormattingStr)</code>","text":"<p>Set auto formatting mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>AutoFormattingStr</code> <p>auto formatting mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>auto formatting mode does not exist</p> Source code in <code>prettyqt/widgets/textedit.py</code> <pre><code>def set_auto_formatting(self, mode: AutoFormattingStr):\n\"\"\"Set auto formatting mode.\n\n    Args:\n        mode: auto formatting mode to use\n\n    Raises:\n        InvalidParamError: auto formatting mode does not exist\n    \"\"\"\n    if mode not in AUTO_FORMATTING:\n        raise InvalidParamError(mode, AUTO_FORMATTING)\n    self.setAutoFormatting(AUTO_FORMATTING[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.set_line_wrap_mode","title":"<code>set_line_wrap_mode(self, mode: LineWrapModeStr)</code>","text":"<p>Set line wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>LineWrapModeStr</code> <p>line wrap mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>line wrap mode does not exist</p> Source code in <code>prettyqt/widgets/textedit.py</code> <pre><code>def set_line_wrap_mode(self, mode: LineWrapModeStr):\n\"\"\"Set line wrap mode.\n\n    Args:\n        mode: line wrap mode to use\n\n    Raises:\n        InvalidParamError: line wrap mode does not exist\n    \"\"\"\n    if mode not in LINE_WRAP_MODE:\n        raise InvalidParamError(mode, LINE_WRAP_MODE)\n    self.setLineWrapMode(LINE_WRAP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEditMixin.set_word_wrap_mode","title":"<code>set_word_wrap_mode(self, mode: gui.textoption.WordWrapModeStr)</code>","text":"<p>Set word wrap mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>gui.textoption.WordWrapModeStr</code> <p>word wrap mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>wrap mode does not exist</p> Source code in <code>prettyqt/widgets/textedit.py</code> <pre><code>def set_word_wrap_mode(self, mode: gui.textoption.WordWrapModeStr):\n\"\"\"Set word wrap mode.\n\n    Args:\n        mode: word wrap mode to use\n\n    Raises:\n        InvalidParamError: wrap mode does not exist\n    \"\"\"\n    if mode not in gui.textoption.WORD_WRAP_MODE:\n        raise InvalidParamError(mode, gui.textoption.WORD_WRAP_MODE)\n    self.setWordWrapMode(gui.textoption.WORD_WRAP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbar","title":"<code>toolbar</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBarMixin","title":"<code> ToolBarMixin            (WidgetMixin)         </code>","text":"Source code in <code>prettyqt/widgets/toolbar.py</code> <pre><code>class ToolBarMixin(widgets.WidgetMixin):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.set_icon_size(24)\n        self.menu_buttons = []\n\n    def __setstate__(self, state: dict[str, Any]) -&gt; None:\n        super().__setstate__(state)\n        self.addActions(state[\"actions\"])\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def serialize_fields(self):\n        return dict(actions=self.actions(), allowed_areas=self.get_allowed_areas())\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({self.windowTitle()!r})\"\n\n    def add(self, item: QtWidgets.QAction | QtWidgets.QWidget):\n        if isinstance(item, QtWidgets.QAction):\n            self.addAction(item)\n        else:\n            self.addWidget(item)\n\n    def add_menu_button(\n        self, label: str, icon: datatypes.IconType, menu: QtWidgets.QMenu\n    ) -&gt; widgets.ToolButton:\n        btn = widgets.ToolButton.for_menu(menu)\n        btn.setText(label)\n        btn.setToolButtonStyle(self.toolButtonStyle())\n        btn.set_icon(icon)\n        self.menu_buttons.append(btn)\n        self.addWidget(btn)\n        return btn\n\n    def add_separator(\n        self, text: str | None = None, before: QtWidgets.QAction | None = None\n    ) -&gt; QtWidgets.QAction:\n\"\"\"Adds a separator showing an optional label.\n\n        Args:\n            text: Text to show on separator\n            before: insert separator before specific action\n\n        Returns:\n            Separator action\n        \"\"\"\n        if text is None:\n            if before:\n                return self.insertSeparator(before)\n            else:\n                return self.addSeparator()\n        else:\n            label = widgets.Label(text)\n            label.setMinimumWidth(self.minimumWidth())\n            with label.edit_stylesheet() as ss:\n                ss.background.setValue(\"lightgrey\")\n            label.set_alignment(horizontal=\"center\")\n            if before:\n                return self.insertWidget(before, label)\n            else:\n                return self.addWidget(label)\n\n    def set_style(self, style: constants.ToolButtonStyleStr):\n        self.setToolButtonStyle(constants.TOOLBUTTON_STYLE[style])\n        for btn in self.menu_buttons:\n            btn.set_style(style)\n\n    def get_style(self) -&gt; constants.ToolButtonStyleStr:\n\"\"\"Return current style.\n\n        Returns:\n            style\n        \"\"\"\n        return constants.TOOLBUTTON_STYLE.inverse[self.toolButtonStyle()]\n\n    def add_action(\n        self,\n        label: str,\n        icon: datatypes.IconType = None,\n        callback: Callable | None = None,\n        checkable: bool = False,\n    ) -&gt; QtWidgets.QAction:\n        icon = iconprovider.get_icon(icon)\n        action = self.addAction(icon, label)\n        if callback is not None:\n            action.triggered.connect(callback)\n        if checkable:\n            action.setCheckable(True)\n        return action\n\n    def add_spacer(self) -&gt; QtWidgets.QAction:\n        spacer = widgets.Widget()\n        spacer.set_size_policy(\"expanding\", \"expanding\")\n        return self.addWidget(spacer)\n\n    def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n        if isinstance(size, int):\n            size = core.Size(size, size)\n        elif isinstance(size, tuple):\n            size = core.Size(*size)\n        self.setIconSize(size)\n\n    def get_icon_size(self) -&gt; core.Size:\n        return core.Size(self.iconSize())\n\n    def set_font_size(self, size: int):\n        with self.edit_font() as font:\n            font.set_size(size)\n\n    def is_area_allowed(self, area: constants.ToolbarAreaStr) -&gt; bool:\n\"\"\"Check if toolbar is allowed at specified area.\n\n        Args:\n            area: area of the toolbar\n\n        Raises:\n            InvalidParamError: area does not exist\n        \"\"\"\n        if area not in constants.TOOLBAR_AREA:\n            raise InvalidParamError(area, constants.TOOLBAR_AREA)\n        return self.isAreaAllowed(constants.TOOLBAR_AREA[area])\n\n    def set_allowed_areas(self, *areas: constants.ToolbarAreaStr):\n        for area in areas:\n            if area not in constants.TOOLBAR_AREA:\n                raise InvalidParamError(area, constants.TOOLBAR_AREA)\n        flag = helpers.merge_flags(areas, constants.TOOLBAR_AREA)\n        self.setAllowedAreas(flag)\n\n    def get_allowed_areas(self) -&gt; list[constants.ToolbarAreaStr]:\n        return [\n            k\n            for k, v in constants.TOOLBAR_AREA.items()\n            if v &amp; self.allowedAreas()  # type: ignore\n        ]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBarMixin.add_separator","title":"<code>add_separator(self, text: str | None = None, before: QtWidgets.QAction | None = None) -&gt; QtWidgets.QAction</code>","text":"<p>Adds a separator showing an optional label.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Text to show on separator</p> <code>None</code> <code>before</code> <code>QtWidgets.QAction | None</code> <p>insert separator before specific action</p> <code>None</code> <p>Returns:</p> Type Description <code>QtWidgets.QAction</code> <p>Separator action</p> Source code in <code>prettyqt/widgets/toolbar.py</code> <pre><code>def add_separator(\n    self, text: str | None = None, before: QtWidgets.QAction | None = None\n) -&gt; QtWidgets.QAction:\n\"\"\"Adds a separator showing an optional label.\n\n    Args:\n        text: Text to show on separator\n        before: insert separator before specific action\n\n    Returns:\n        Separator action\n    \"\"\"\n    if text is None:\n        if before:\n            return self.insertSeparator(before)\n        else:\n            return self.addSeparator()\n    else:\n        label = widgets.Label(text)\n        label.setMinimumWidth(self.minimumWidth())\n        with label.edit_stylesheet() as ss:\n            ss.background.setValue(\"lightgrey\")\n        label.set_alignment(horizontal=\"center\")\n        if before:\n            return self.insertWidget(before, label)\n        else:\n            return self.addWidget(label)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBarMixin.get_style","title":"<code>get_style(self) -&gt; constants.ToolButtonStyleStr</code>","text":"<p>Return current style.</p> <p>Returns:</p> Type Description <code>constants.ToolButtonStyleStr</code> <p>style</p> Source code in <code>prettyqt/widgets/toolbar.py</code> <pre><code>def get_style(self) -&gt; constants.ToolButtonStyleStr:\n\"\"\"Return current style.\n\n    Returns:\n        style\n    \"\"\"\n    return constants.TOOLBUTTON_STYLE.inverse[self.toolButtonStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBarMixin.is_area_allowed","title":"<code>is_area_allowed(self, area: constants.ToolbarAreaStr) -&gt; bool</code>","text":"<p>Check if toolbar is allowed at specified area.</p> <p>Parameters:</p> Name Type Description Default <code>area</code> <code>constants.ToolbarAreaStr</code> <p>area of the toolbar</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>area does not exist</p> Source code in <code>prettyqt/widgets/toolbar.py</code> <pre><code>def is_area_allowed(self, area: constants.ToolbarAreaStr) -&gt; bool:\n\"\"\"Check if toolbar is allowed at specified area.\n\n    Args:\n        area: area of the toolbar\n\n    Raises:\n        InvalidParamError: area does not exist\n    \"\"\"\n    if area not in constants.TOOLBAR_AREA:\n        raise InvalidParamError(area, constants.TOOLBAR_AREA)\n    return self.isAreaAllowed(constants.TOOLBAR_AREA[area])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBarMixin.set_icon_size","title":"<code>set_icon_size(self, size: int | datatypes.SizeType)</code>","text":"<p>Set size of the icons.</p> Source code in <code>prettyqt/widgets/toolbar.py</code> <pre><code>def set_icon_size(self, size: int | datatypes.SizeType):\n\"\"\"Set size of the icons.\"\"\"\n    if isinstance(size, int):\n        size = core.Size(size, size)\n    elif isinstance(size, tuple):\n        size = core.Size(*size)\n    self.setIconSize(size)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton","title":"<code>toolbutton</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton","title":"<code> ToolButton            (AbstractButtonMixin, QToolButton)         </code>","text":"Source code in <code>prettyqt/widgets/toolbutton.py</code> <pre><code>class ToolButton(widgets.AbstractButtonMixin, QtWidgets.QToolButton):\n    def __getitem__(self, item: str) -&gt; QtWidgets.QAction:\n        menu = self.menu()\n        return menu[item]\n\n    # def set_menu(self, menu: QtWidgets.QMenu):\n    #     menu.setParent(self)\n    #     self.setMenu(menu)\n\n    @classmethod\n    def for_menu(cls, menu: QtWidgets.QMenu, icon: datatypes.IconType = None):\n        btn = cls()\n        btn.setMenu(menu)\n        # btn.set_title(menu.title())\n        btn.set_popup_mode(\"instant\")\n        btn.set_icon(icon)\n        return btn\n\n    def set_default_action(self, action):\n        self.setDefaultAction(action)\n\n    def set_popup_mode(self, mode: PopupModeStr):\n\"\"\"Set the popup mode of the toolbutton.\n\n        Args:\n            mode: popup mode to use\n\n        Raises:\n            InvalidParamError: invalid popup mode\n        \"\"\"\n        if mode not in POPUP_MODE:\n            raise InvalidParamError(mode, POPUP_MODE)\n        self.setPopupMode(POPUP_MODE[mode])\n\n    def get_popup_mode(self) -&gt; PopupModeStr:\n\"\"\"Return popup mode.\n\n        Returns:\n            popup mode\n        \"\"\"\n        return POPUP_MODE.inverse[self.popupMode()]\n\n    def set_arrow_type(self, mode: constants.ArrowTypeStr):\n\"\"\"Set the arrow type of the toolbutton.\n\n        Args:\n            mode: arrow type to use\n\n        Raises:\n            InvalidParamError: invalid arrow type\n        \"\"\"\n        if mode not in constants.ARROW_TYPE:\n            raise InvalidParamError(mode, constants.ARROW_TYPE)\n        self.setArrowType(constants.ARROW_TYPE[mode])\n\n    def get_arrow_type(self) -&gt; constants.ArrowTypeStr:\n\"\"\"Return arrow type.\n\n        Returns:\n            arrow type\n        \"\"\"\n        return constants.ARROW_TYPE.inverse[self.arrowType()]\n\n    def set_style(self, style: constants.ToolButtonStyleStr):\n\"\"\"Set the toolbutton style.\n\n        Args:\n            style: style to use\n\n        Raises:\n            InvalidParamError: invalid style\n        \"\"\"\n        if style not in constants.TOOLBUTTON_STYLE:\n            raise InvalidParamError(style, constants.TOOLBUTTON_STYLE)\n        self.setToolButtonStyle(constants.TOOLBUTTON_STYLE[style])\n\n    def get_style(self) -&gt; constants.ToolButtonStyleStr:\n\"\"\"Return toolbutton style.\n\n        Returns:\n            toolbutton style\n        \"\"\"\n        return constants.TOOLBUTTON_STYLE.inverse[self.toolButtonStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_arrow_type","title":"<code>get_arrow_type(self) -&gt; constants.ArrowTypeStr</code>","text":"<p>Return arrow type.</p> <p>Returns:</p> Type Description <code>constants.ArrowTypeStr</code> <p>arrow type</p> Source code in <code>prettyqt/widgets/toolbutton.py</code> <pre><code>def get_arrow_type(self) -&gt; constants.ArrowTypeStr:\n\"\"\"Return arrow type.\n\n    Returns:\n        arrow type\n    \"\"\"\n    return constants.ARROW_TYPE.inverse[self.arrowType()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_popup_mode","title":"<code>get_popup_mode(self) -&gt; PopupModeStr</code>","text":"<p>Return popup mode.</p> <p>Returns:</p> Type Description <code>PopupModeStr</code> <p>popup mode</p> Source code in <code>prettyqt/widgets/toolbutton.py</code> <pre><code>def get_popup_mode(self) -&gt; PopupModeStr:\n\"\"\"Return popup mode.\n\n    Returns:\n        popup mode\n    \"\"\"\n    return POPUP_MODE.inverse[self.popupMode()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_style","title":"<code>get_style(self) -&gt; constants.ToolButtonStyleStr</code>","text":"<p>Return toolbutton style.</p> <p>Returns:</p> Type Description <code>constants.ToolButtonStyleStr</code> <p>toolbutton style</p> Source code in <code>prettyqt/widgets/toolbutton.py</code> <pre><code>def get_style(self) -&gt; constants.ToolButtonStyleStr:\n\"\"\"Return toolbutton style.\n\n    Returns:\n        toolbutton style\n    \"\"\"\n    return constants.TOOLBUTTON_STYLE.inverse[self.toolButtonStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_arrow_type","title":"<code>set_arrow_type(self, mode: constants.ArrowTypeStr)</code>","text":"<p>Set the arrow type of the toolbutton.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>constants.ArrowTypeStr</code> <p>arrow type to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid arrow type</p> Source code in <code>prettyqt/widgets/toolbutton.py</code> <pre><code>def set_arrow_type(self, mode: constants.ArrowTypeStr):\n\"\"\"Set the arrow type of the toolbutton.\n\n    Args:\n        mode: arrow type to use\n\n    Raises:\n        InvalidParamError: invalid arrow type\n    \"\"\"\n    if mode not in constants.ARROW_TYPE:\n        raise InvalidParamError(mode, constants.ARROW_TYPE)\n    self.setArrowType(constants.ARROW_TYPE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_popup_mode","title":"<code>set_popup_mode(self, mode: PopupModeStr)</code>","text":"<p>Set the popup mode of the toolbutton.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>PopupModeStr</code> <p>popup mode to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid popup mode</p> Source code in <code>prettyqt/widgets/toolbutton.py</code> <pre><code>def set_popup_mode(self, mode: PopupModeStr):\n\"\"\"Set the popup mode of the toolbutton.\n\n    Args:\n        mode: popup mode to use\n\n    Raises:\n        InvalidParamError: invalid popup mode\n    \"\"\"\n    if mode not in POPUP_MODE:\n        raise InvalidParamError(mode, POPUP_MODE)\n    self.setPopupMode(POPUP_MODE[mode])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_style","title":"<code>set_style(self, style: constants.ToolButtonStyleStr)</code>","text":"<p>Set the toolbutton style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>constants.ToolButtonStyleStr</code> <p>style to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid style</p> Source code in <code>prettyqt/widgets/toolbutton.py</code> <pre><code>def set_style(self, style: constants.ToolButtonStyleStr):\n\"\"\"Set the toolbutton style.\n\n    Args:\n        style: style to use\n\n    Raises:\n        InvalidParamError: invalid style\n    \"\"\"\n    if style not in constants.TOOLBUTTON_STYLE:\n        raise InvalidParamError(style, constants.TOOLBUTTON_STYLE)\n    self.setToolButtonStyle(constants.TOOLBUTTON_STYLE[style])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem","title":"<code>treewidgetitem</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem","title":"<code> TreeWidgetItem            (QTreeWidgetItem)         </code>","text":"Source code in <code>prettyqt/widgets/treewidgetitem.py</code> <pre><code>class TreeWidgetItem(QtWidgets.QTreeWidgetItem):\n    def __repr__(self):\n        return f\"{type(self).__name__}()\"\n\n    def serialize_fields(self):\n        data = [\n            self.data(i, constants.USER_ROLE)  # type: ignore\n            for i in range(self.columnCount())\n        ]\n        return dict(\n            text=[self.text(i) for i in range(self.columnCount())],\n            tool_tip=[self.toolTip(i) for i in range(self.columnCount())],\n            status_tip=[self.statusTip(i) for i in range(self.columnCount())],\n            checkstate=[self.get_checkstate(i) for i in range(self.columnCount())],\n            icon=[self.get_icon(i) for i in range(self.columnCount())],\n            data=data,\n        )\n\n    def __getstate__(self):\n        return bytes(self)\n\n    def __setstate__(self, ba):\n        core.DataStream.write_bytearray(ba, self)\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def __bytes__(self):\n        ba = core.DataStream.create_bytearray(self)\n        return bytes(ba)\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QTreeWidgetItem]:\n        return iter(self.child(i) for i in range(self.childCount()))\n\n    def __len__(self):\n        return self.childCount()\n\n    def __getitem__(self, index: int) -&gt; QtWidgets.QTreeWidgetItem:\n        item = self.child(index)\n        if item is None:\n            raise KeyError(index)\n        return item\n\n    def __delitem__(self, index: int):\n        self.takeChild(index)\n\n    def __add__(self, other: QtWidgets.QTreeWidgetItem) -&gt; TreeWidgetItem:\n        self.addChild(other)\n        return self\n\n    def set_size_hint(self, hint: datatypes.SizeType, column: int = 0):\n        if isinstance(hint, tuple):\n            hint = QtCore.QSize(*hint)\n        self.setSizeHint(column, hint)\n\n    def sort_children(self, column: int, descending: bool = False):\n        order = constants.DESCENDING if descending else constants.ASCENDING\n        self.sortChildren(column, order)\n\n    def set_icon(self, icon: datatypes.IconType, column: int = 0):\n\"\"\"Set the icon for the action.\n\n        Args:\n            icon: icon to use\n            column: column\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setIcon(column, icon)\n\n    def get_background(self, column: int = 0) -&gt; gui.Brush:\n        return gui.Brush(self.background(column))\n\n    def get_foreground(self, column: int = 0) -&gt; gui.Brush:\n        return gui.Brush(self.foreground(column))\n\n    def get_font(self, column: int = 0) -&gt; gui.Font:\n        return gui.Font(self.font(column))\n\n    def get_icon(self, column: int = 0) -&gt; gui.Icon | None:\n        icon = self.icon(column)\n        if icon.isNull():\n            return None\n        return gui.Icon(icon)\n\n    def set_checkstate(self, state: constants.StateStr, column: int = 0):\n\"\"\"Set checkstate of the checkbox.\n\n        Args:\n            state: checkstate to use\n            column: column\n\n        Raises:\n            InvalidParamError: invalid checkstate\n        \"\"\"\n        if state not in constants.STATE:\n            raise InvalidParamError(state, constants.STATE)\n        self.setCheckState(column, constants.STATE[state])\n\n    def get_checkstate(self, column: int = 0) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n        Args:\n            column: column\n\n        Returns:\n            checkstate\n        \"\"\"\n        return constants.STATE.inverse[self.checkState(column)]\n\n    def set_child_indicator_policy(self, policy: ChildIndicatorPolicyStr):\n\"\"\"Set the child indicator policy.\n\n        Args:\n            policy: child indicator policy\n\n        Raises:\n            InvalidParamError: policy does not exist\n        \"\"\"\n        if policy not in CHILD_INDICATOR_POLICY:\n            raise InvalidParamError(policy, CHILD_INDICATOR_POLICY)\n        self.setChildIndicatorPolicy(CHILD_INDICATOR_POLICY[policy])\n\n    def get_child_indicator_policy(self) -&gt; ChildIndicatorPolicyStr:\n\"\"\"Return current child indicator policy.\n\n        Returns:\n            child indicator policy\n        \"\"\"\n        return CHILD_INDICATOR_POLICY.inverse[self.childIndicatorPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_checkstate","title":"<code>get_checkstate(self, column: int = 0) -&gt; constants.StateStr</code>","text":"<p>Return checkstate.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>int</code> <p>column</p> <code>0</code> <p>Returns:</p> Type Description <code>constants.StateStr</code> <p>checkstate</p> Source code in <code>prettyqt/widgets/treewidgetitem.py</code> <pre><code>def get_checkstate(self, column: int = 0) -&gt; constants.StateStr:\n\"\"\"Return checkstate.\n\n    Args:\n        column: column\n\n    Returns:\n        checkstate\n    \"\"\"\n    return constants.STATE.inverse[self.checkState(column)]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_child_indicator_policy","title":"<code>get_child_indicator_policy(self) -&gt; ChildIndicatorPolicyStr</code>","text":"<p>Return current child indicator policy.</p> <p>Returns:</p> Type Description <code>ChildIndicatorPolicyStr</code> <p>child indicator policy</p> Source code in <code>prettyqt/widgets/treewidgetitem.py</code> <pre><code>def get_child_indicator_policy(self) -&gt; ChildIndicatorPolicyStr:\n\"\"\"Return current child indicator policy.\n\n    Returns:\n        child indicator policy\n    \"\"\"\n    return CHILD_INDICATOR_POLICY.inverse[self.childIndicatorPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_checkstate","title":"<code>set_checkstate(self, state: constants.StateStr, column: int = 0)</code>","text":"<p>Set checkstate of the checkbox.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>constants.StateStr</code> <p>checkstate to use</p> required <code>column</code> <code>int</code> <p>column</p> <code>0</code> <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>invalid checkstate</p> Source code in <code>prettyqt/widgets/treewidgetitem.py</code> <pre><code>def set_checkstate(self, state: constants.StateStr, column: int = 0):\n\"\"\"Set checkstate of the checkbox.\n\n    Args:\n        state: checkstate to use\n        column: column\n\n    Raises:\n        InvalidParamError: invalid checkstate\n    \"\"\"\n    if state not in constants.STATE:\n        raise InvalidParamError(state, constants.STATE)\n    self.setCheckState(column, constants.STATE[state])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_child_indicator_policy","title":"<code>set_child_indicator_policy(self, policy: ChildIndicatorPolicyStr)</code>","text":"<p>Set the child indicator policy.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>ChildIndicatorPolicyStr</code> <p>child indicator policy</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>policy does not exist</p> Source code in <code>prettyqt/widgets/treewidgetitem.py</code> <pre><code>def set_child_indicator_policy(self, policy: ChildIndicatorPolicyStr):\n\"\"\"Set the child indicator policy.\n\n    Args:\n        policy: child indicator policy\n\n    Raises:\n        InvalidParamError: policy does not exist\n    \"\"\"\n    if policy not in CHILD_INDICATOR_POLICY:\n        raise InvalidParamError(policy, CHILD_INDICATOR_POLICY)\n    self.setChildIndicatorPolicy(CHILD_INDICATOR_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_icon","title":"<code>set_icon(self, icon: datatypes.IconType, column: int = 0)</code>","text":"<p>Set the icon for the action.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required <code>column</code> <code>int</code> <p>column</p> <code>0</code> Source code in <code>prettyqt/widgets/treewidgetitem.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType, column: int = 0):\n\"\"\"Set the icon for the action.\n\n    Args:\n        icon: icon to use\n        column: column\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setIcon(column, icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.undoview","title":"<code>undoview</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView","title":"<code> UndoView            (ListViewMixin, QUndoView)         </code>","text":"Source code in <code>prettyqt/widgets/undoview.py</code> <pre><code>class UndoView(widgets.ListViewMixin, QtWidgets.QUndoView):\n    def __getitem__(self, index: int) -&gt; QtGui.QUndoCommand:\n        return self.stack().command(index)\n\n    def set_clean_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the clean button.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon)\n        self.setCleanIcon(icon)\n\n    def set_value(self, value: QtGui.QUndoGroup | QtGui.QUndoStack):\n        if isinstance(value, QtGui.QUndoGroup):\n            self.setGroup(value)\n        else:\n            self.setStack(value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView.set_clean_icon","title":"<code>set_clean_icon(self, icon: datatypes.IconType)</code>","text":"<p>Set the icon for the clean button.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt/widgets/undoview.py</code> <pre><code>def set_clean_icon(self, icon: datatypes.IconType):\n\"\"\"Set the icon for the clean button.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon)\n    self.setCleanIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget","title":"<code>widget</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin","title":"<code> WidgetMixin            (ObjectMixin)         </code>","text":"Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>class WidgetMixin(core.ObjectMixin):\n    box: QtWidgets.QLayout\n\n    def __repr__(self) -&gt; str:\n        cls_name = type(self).__name__\n        params = helpers.format_kwargs(self.serialize_fields())\n        return f\"{cls_name}({params})\"\n\n    def __setstate__(self, state: dict[str, Any]) -&gt; None:\n        if self.layout() is None:\n            self.set_layout(state[\"layout\"])\n        self.setSizePolicy(state[\"size_policy\"])\n        self.setAccessibleName(state[\"accessible_name\"])\n        self.setToolTip(state.get(\"tool_tip\", \"\"))\n        self.setToolTipDuration(state.get(\"tooltip_duration\", \"\"))\n        self.setWindowTitle(state.get(\"window_title\", \"\"))\n        self.setWindowFilePath(state.get(\"window_file_path\", \"\"))\n        self.setEnabled(state.get(\"enabled\", True))\n        self.setVisible(state.get(\"visible\", True))\n        self.setTabletTracking(state.get(\"tablet_tracking\", True))\n        self.setWindowModified(state.get(\"window_modified\", False))\n        self.setWindowOpacity(state.get(\"window_opacity\", 1.0))\n        self.set_icon(state.get(\"icon\"))\n        self.set_modality(state.get(\"modality\", \"\"))\n        self.setWhatsThis(state.get(\"whats_this\", \"\"))\n        self.set_context_menu_policy(state.get(\"contextmenu_policy\", \"\"))\n        self.set_focus_policy(state.get(\"focus_policy\", \"\"))\n        self.setStatusTip(state.get(\"status_tip\", \"\"))\n        self.setStyleSheet(state.get(\"stylesheet\", \"\"))\n        self.setFont(state.get(\"font\", \"\"))\n        if state[\"is_maximized\"]:\n            self.showMaximized()\n\n    def __reduce__(self):\n        return type(self), (), self.__getstate__()\n\n    def serialize_fields(self) -&gt; dict[str, Any]:\n        return dict(\n            layout=self.layout() if isinstance(self.layout(), widgets.Layout) else None,\n            size_policy=self.get_size_policy(),\n            is_maximized=self.isMaximized(),\n            actions=self.actions(),\n            accessible_name=self.accessibleName(),\n            tool_tip=self.toolTip(),\n            tooltip_duration=self.toolTipDuration(),\n            window_title=self.windowTitle(),\n            window_file_path=self.windowFilePath(),\n            enabled=self.isEnabled(),\n            tablet_tracking=self.hasTabletTracking(),\n            window_modified=self.isWindowModified(),\n            window_opacity=self.windowOpacity(),\n            visible=self.isVisible(),\n            stylesheet=self.styleSheet(),\n            icon=self.get_icon(),\n            modality=self.get_modality(),\n            whats_this=self.whatsThis(),\n            contextmenu_policy=self.get_context_menu_policy(),\n            focus_policy=self.get_focus_policy(),\n            status_tip=self.statusTip(),\n            font=self.get_font(),\n        )\n\n    def resize(self, *size) -&gt; None:\n        if isinstance(size[0], tuple):\n            super().resize(*size[0])\n        else:\n            super().resize(*size)\n\n    def raise_to_top(self):\n        if sys.platform.startswith(\"win\"):\n            import win32con\n            from win32gui import SetWindowPos\n\n            # set to always-on-top and disable it again. that way windows stays in front\n            flag = win32con.SWP_NOMOVE | win32con.SWP_NOSIZE | win32con.SWP_SHOWWINDOW\n            win_id = self.winId()\n            SetWindowPos(win_id, win32con.HWND_TOPMOST, 0, 0, 0, 0, flag)\n            SetWindowPos(win_id, win32con.HWND_NOTOPMOST, 0, 0, 0, 0, flag)\n        # state = (self.windowState() &amp; ~Qt.WindowMinimized) | Qt.WindowActive\n        # self.setWindowState(state)\n        self.raise_()\n        self.show()\n        self.activateWindow()\n\n    def set_icon(self, icon: datatypes.IconType) -&gt; None:\n\"\"\"Set the window icon.\n\n        Args:\n            icon: icon to use\n        \"\"\"\n        icon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\n        self.setWindowIcon(icon)\n\n    def get_icon(self) -&gt; gui.Icon | None:\n        icon = self.windowIcon()\n        if icon.isNull():\n            return None\n        return gui.Icon(icon)\n\n    def set_min_size(self, *size) -&gt; None:\n        self.setMinimumSize(*size)\n\n    def set_max_size(self, *size) -&gt; None:\n        self.setMaximumSize(*size)\n\n    def set_min_width(self, width: int | None) -&gt; None:\n        if width is None:\n            width = 0\n        self.setMinimumWidth(width)\n\n    def set_max_width(self, width: int | None) -&gt; None:\n        if width is None:\n            width = 16777215  # QtWidgets.QWIDGETSIZE_MAX\n        self.setMaximumWidth(width)\n\n    def set_min_height(self, height: int | None) -&gt; None:\n        if height is None:\n            height = 0\n        self.setMinimumHeight(height)\n\n    def set_max_height(self, height: int | None) -&gt; None:\n        if height is None:\n            height = 16777215  # QtWidgets.QWIDGETSIZE_MAX\n        self.setMaximumHeight(height)\n\n    def set_enabled(self, enabled: bool = True) -&gt; None:\n        self.setEnabled(enabled)\n\n    def set_disabled(self) -&gt; None:\n        self.setEnabled(False)\n\n    def set_title(self, title: str) -&gt; None:\n        self.setWindowTitle(title)\n\n    def get_title(self) -&gt; str:\n        return self.windowTitle()\n\n    def set_tooltip(\n        self,\n        tooltip: str | datatypes.PathType,\n        size: datatypes.SizeType | None = None,\n    ):\n        if isinstance(tooltip, os.PathLike):\n            path = os.fspath(tooltip)\n            if size is None:\n                tooltip = f\"&lt;img src={path!r}&gt;\"\n            else:\n                if isinstance(size, QtCore.QSize):\n                    size = (size.width(), size.height())\n                tooltip = f'&lt;img src={path!r} width=\"{size[0]}\" height=\"{size[1]}\"&gt;'\n        self.setToolTip(tooltip)\n\n    def set_font(\n        self,\n        font_name: str | None = None,\n        font_size: int | None = None,\n        weight: int | None = None,\n        italic: bool = False,\n    ) -&gt; gui.Font:\n        if font_size is None:\n            font_size = -1\n        if weight is None:\n            weight = -1\n        if font_name is None:\n            font_name = self.font().family()\n        font = gui.Font(font_name, font_size, weight, italic)\n        self.setFont(font)\n        return font\n\n    def get_font(self) -&gt; gui.Font:\n        return gui.Font(self.font())\n\n    def get_foreground_role(self) -&gt; gui.palette.RoleStr:\n        return gui.palette.ROLE.inverse[self.foregroundRole()]\n\n    def set_foreground_role(self, role: gui.palette.RoleStr):\n        if role not in gui.palette.ROLE:\n            raise InvalidParamError(role, gui.palette.ROLE)\n        self.setForegroundRole(gui.palette.ROLE[role])\n\n    def get_background_role(self) -&gt; gui.palette.RoleStr:\n        return gui.palette.ROLE.inverse[self.backgroundRole()]\n\n    def set_background_role(self, role: gui.palette.RoleStr):\n        if role not in gui.palette.ROLE:\n            raise InvalidParamError(role, gui.palette.ROLE)\n        self.setBackgroundRole(gui.palette.ROLE[role])\n\n    def set_window_flags(self, *flags: constants.WindowFlagStr, append: bool = False):\n        for flag in flags:\n            if flag not in constants.WINDOW_FLAGS:\n                raise InvalidParamError(flag, constants.WINDOW_FLAGS)\n        result = helpers.merge_flags(flags, constants.WINDOW_FLAGS)\n        if append:\n            result = result | self.windowFlags()\n        self.setWindowFlags(result)\n\n    def set_flags(\n        self,\n        minimize: bool | None = None,\n        maximize: bool | None = None,\n        close: bool | None = None,\n        stay_on_top: bool | None = None,\n        frameless: bool | None = None,\n        window: bool | None = None,\n        dialog: bool | None = None,\n        tooltip: bool | None = None,\n        tool: bool | None = None,\n        customize: bool | None = None,\n        window_title: bool | None = None,\n    ) -&gt; None:\n        flags = {\n            minimize: QtCore.Qt.WindowType.WindowMinimizeButtonHint,\n            maximize: QtCore.Qt.WindowType.WindowMaximizeButtonHint,\n            close: QtCore.Qt.WindowType.WindowCloseButtonHint,\n            stay_on_top: QtCore.Qt.WindowType.WindowStaysOnTopHint,\n            frameless: QtCore.Qt.WindowType.FramelessWindowHint,\n            window: QtCore.Qt.WindowType.Window,\n            dialog: QtCore.Qt.WindowType.Dialog,\n            tooltip: QtCore.Qt.WindowType.ToolTip,\n            tool: QtCore.Qt.WindowType.Tool,\n            customize: QtCore.Qt.WindowType.CustomizeWindowHint,\n            window_title: QtCore.Qt.WindowType.WindowTitleHint,\n        }\n        for k, v in flags.items():\n            if k is not None:\n                self.setWindowFlag(v, k)\n\n    def set_attribute(\n        self, attribute: constants.WidgetAttributeStr, state: bool = True\n    ) -&gt; None:\n        if attribute not in constants.WIDGET_ATTRIBUTE:\n            raise InvalidParamError(attribute, constants.WIDGET_ATTRIBUTE)\n        self.setAttribute(constants.WIDGET_ATTRIBUTE[attribute], state)\n\n    def set_attributes(self, **kwargs: bool) -&gt; None:\n        for attr, state in kwargs.items():\n            if attr not in constants.WIDGET_ATTRIBUTE:\n                raise InvalidParamError(attr, constants.WIDGET_ATTRIBUTE)\n            self.setAttribute(constants.WIDGET_ATTRIBUTE[attr], state)  # type: ignore\n\n    def set_modality(self, modality: constants.ModalityStr) -&gt; None:\n\"\"\"Set modality for the dialog.\n\n        Args:\n            modality: modality for the main window\n\n        Raises:\n            InvalidParamError: modality type does not exist\n        \"\"\"\n        if modality not in constants.MODALITY:\n            raise InvalidParamError(modality, constants.MODALITY)\n        self.setWindowModality(constants.MODALITY[modality])\n\n    def get_modality(self) -&gt; constants.ModalityStr:\n\"\"\"Get the current modality modes as a string.\n\n        Returns:\n            modality mode\n        \"\"\"\n        return constants.MODALITY.inverse[self.windowModality()]\n\n    def set_size_policy(\n        self,\n        horizontal: widgets.sizepolicy.SizePolicyStr | None = None,\n        vertical: widgets.sizepolicy.SizePolicyStr | None = None,\n    ) -&gt; None:\n\"\"\"Set the sizes policy.\n\n        Args:\n            horizontal: horizontal size policy\n            vertical: vertical size policy\n        \"\"\"\n        sp = self.get_size_policy()\n        if horizontal is not None:\n            sp.set_horizontal_policy(horizontal)\n        if vertical is not None:\n            sp.set_vertical_policy(vertical)\n        self.setSizePolicy(sp)\n\n    def get_size_policy(self) -&gt; widgets.SizePolicy:\n        qpol = self.sizePolicy()\n        if isinstance(qpol, widgets.SizePolicy):\n            return qpol\n        return widgets.SizePolicy.clone(qpol)\n\n    def get_palette(self) -&gt; gui.Palette:\n        return gui.Palette(self.palette())\n\n    def set_background_color(self, color: datatypes.ColorType) -&gt; None:\n        col_str = \"\" if color is None else colors.get_color(color).name()\n        with self.edit_stylesheet() as ss:\n            ss.backgroundColor.setValue(col_str)\n\n    @contextlib.contextmanager\n    def grab_mouse_events(\n        self, cursor_shape: constants.CursorShapeStr | None = None\n    ) -&gt; Iterator[None]:\n        if cursor_shape is not None:\n            self.grabMouse(constants.CURSOR_SHAPE[cursor_shape])\n        else:\n            self.grabMouse()\n        yield None\n        self.releaseMouse()\n\n    @contextlib.contextmanager\n    def grab_keyboard_events(self) -&gt; Iterator[None]:\n        self.grabKeyboard()\n        yield None\n        self.releaseKeyboard()\n\n    @contextlib.contextmanager\n    def updates_off(self) -&gt; Iterator[None]:\n        updates = self.updatesEnabled()\n        self.setUpdatesEnabled(False)\n        yield None\n        self.setUpdatesEnabled(updates)\n\n    @contextlib.contextmanager\n    def edit_stylesheet(self) -&gt; Iterator[qstylizer.style.StyleSheet]:\n        ss = self.get_stylesheet()\n        yield ss\n        self.set_stylesheet(ss)\n\n    def set_stylesheet(\n        self, ss: None | str | qstylizer.style.StyleSheet | datatypes.PathType\n    ):\n        match ss:\n            case None:\n                ss = \"\"\n            case os.PathLike():\n                ss = pathlib.Path(ss).read_text()\n            case qstylizer.style.StyleSheet():\n                ss = str(ss)\n        self.setStyleSheet(ss)\n\n    def get_stylesheet(self) -&gt; qstylizer.style.StyleSheet:\n        try:\n            return qstylizer.parser.parse(self.styleSheet())\n        except ValueError:\n            return qstylizer.style.StyleSheet()\n\n    @contextlib.contextmanager\n    def edit_palette(self) -&gt; Iterator[gui.Palette]:\n        palette = gui.Palette(self.palette())\n        yield palette\n        self.setPalette(palette)\n\n    @contextlib.contextmanager\n    def edit_font(self) -&gt; Iterator[gui.Font]:\n        font = gui.Font(self.font())\n        yield font\n        self.setFont(font)\n\n    @deprecated(reason=\"This context manager is deprecated, use edit_font instead.\")\n    @contextlib.contextmanager\n    def current_font(self) -&gt; Iterator[gui.Font]:\n        with self.edit_font() as font:\n            yield font\n\n    @deprecated(reason=\"This method is deprecated, use set_context_menu_policy instead.\")\n    def set_contextmenu_policy(self, policy: constants.ContextPolicyStr) -&gt; None:\n        return self.set_context_menu_policy(policy)\n\n    def set_context_menu_policy(self, policy: constants.ContextPolicyStr) -&gt; None:\n\"\"\"Set contextmenu policy for given item view.\n\n        Args:\n            policy: contextmenu policy to use\n\n        Raises:\n            InvalidParamError: policy does not exist\n        \"\"\"\n        if policy not in constants.CONTEXT_POLICY:\n            raise InvalidParamError(policy, constants.CONTEXT_POLICY)\n        self.setContextMenuPolicy(constants.CONTEXT_POLICY[policy])\n\n    @deprecated(reason=\"This method is deprecated, use get_context_menu_policy instead.\")\n    def get_contextmenu_policy(self) -&gt; constants.ContextPolicyStr:\n\"\"\"Return current contextmenu policy.\n\n        Returns:\n            contextmenu policy\n        \"\"\"\n        return self.get_context_menu_policy()\n\n    def get_context_menu_policy(self) -&gt; constants.ContextPolicyStr:\n\"\"\"Return current contextmenu policy.\n\n        Returns:\n            contextmenu policy\n        \"\"\"\n        return constants.CONTEXT_POLICY.inverse[self.contextMenuPolicy()]\n\n    def set_window_state(self, policy: constants.WindowStateStr) -&gt; None:\n\"\"\"Set window state for given item view.\n\n        Args:\n            policy: window state to use\n\n        Raises:\n            InvalidParamError: policy does not exist\n        \"\"\"\n        if policy not in constants.WINDOW_STATES:\n            raise InvalidParamError(policy, constants.WINDOW_STATES)\n        self.setWindowState(constants.WINDOW_STATES[policy])\n\n    def get_window_state(self) -&gt; constants.WindowStateStr:\n\"\"\"Return current window state.\n\n        Returns:\n            window state\n        \"\"\"\n        return constants.WINDOW_STATES.inverse[self.windowState()]\n\n    def set_custom_menu(self, method: Callable) -&gt; None:\n        self.set_context_menu_policy(\"custom\")\n        self.customContextMenuRequested.connect(method)\n\n    def set_layout(\n        self,\n        layout: LayoutStr | QtWidgets.QLayout | None,\n        margin: int | None = None,\n        spacing: int | None = None,\n    ):\n        if layout is None:\n            return\n        match layout:\n            case \"horizontal\" | \"vertical\":\n                self.box = widgets.BoxLayout(layout)\n            case \"grid\":\n                self.box = widgets.GridLayout()\n            case \"form\":\n                self.box = widgets.FormLayout()\n            case \"stacked\":\n                self.box = widgets.StackedLayout()\n            case \"flow\":\n                from prettyqt import custom_widgets\n\n                self.box = custom_widgets.FlowLayout()\n            case QtWidgets.QLayout():\n                self.box = layout\n            case _:\n                raise ValueError(\"Invalid Layout\")\n        self.setLayout(self.box)\n        if margin is not None:\n            self.box.set_margin(margin)\n        if spacing is not None:\n            self.box.setSpacing(spacing)\n\n    def center(self, screen: int = 0) -&gt; None:\n        qr = self.frameGeometry()\n        cp = gui.GuiApplication.screens()[screen].geometry().center()\n        qr.moveCenter(cp)\n        self.move(qr.topLeft())\n\n    def set_cursor(self, cursor: constants.CursorShapeStr | QtGui.QCursor) -&gt; None:\n        if isinstance(cursor, QtGui.QCursor):\n            curs = cursor\n        else:\n            if cursor not in constants.CURSOR_SHAPE:\n                raise InvalidParamError(cursor, constants.CURSOR_SHAPE)\n            curs = gui.Cursor(constants.CURSOR_SHAPE[cursor])\n        self.setCursor(curs)\n\n    def set_focus_policy(self, policy: constants.FocusPolicyStr) -&gt; None:\n\"\"\"Set the way the widget accepts keyboard focus.\n\n        Args:\n            policy (str): Focus policy\n\n        Raises:\n            InvalidParamError: Description\n        \"\"\"\n        if policy not in constants.FOCUS_POLICY:\n            raise InvalidParamError(policy, constants.FOCUS_POLICY)\n        self.setFocusPolicy(constants.FOCUS_POLICY[policy])\n\n    def get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return waay the widget accepts keyboard focus.\n\n        Returns:\n            str: Focus policy\n        \"\"\"\n        return constants.FOCUS_POLICY.inverse[self.focusPolicy()]\n\n    def set_font_size(self, size: int) -&gt; None:\n        font = self.font()\n        font.setPointSize(size)\n        self.setFont(font)\n\n    @deprecated(reason=\"This method is deprecated, use get_font_metrics instead.\")\n    def font_metrics(self) -&gt; gui.FontMetrics:\n        return self.get_font_metrics()\n\n    def get_font_metrics(self) -&gt; gui.FontMetrics:\n        return gui.FontMetrics(self.fontMetrics())\n\n    def get_font_info(self) -&gt; gui.FontInfo:\n        return gui.FontInfo(self.fontInfo())\n\n    def set_margin(self, margin: int) -&gt; None:\n        self.setContentsMargins(margin, margin, margin, margin)\n\n    def raise_dock(self) -&gt; bool:\n        w = self.find_parent(QtWidgets.QDockWidget)\n        if w is None:\n            return False\n        w.setVisible(True)\n        w.raise_()\n        return True\n\n    def set_mask(\n        self,\n        area: datatypes.RectType | QtGui.QRegion | None,\n        typ: gui.region.RegionTypeStr = \"rectangle\",\n    ):\n        match area:\n            case None:\n                self.clearMask()\n                return\n            case tuple():\n                area = gui.Region(*area, gui.region.REGION_TYPE[typ])\n            case QtCore.QRect():\n                area = gui.Region(area, gui.region.REGION_TYPE[typ])\n        self.setMask(area)\n\n    def set_window_file_path(self, path: datatypes.PathType):\n        self.setWindowFilePath(os.fspath(path))\n\n    def get_window_file_path(self) -&gt; pathlib.Path | None:\n        path = self.windowFilePath()\n        if not path:\n            return None\n        return pathlib.Path(path)\n\n    def get_image(self) -&gt; QtGui.QPixmap:\n        image = self.grab()\n        if gl_widget := self.find_child(QtWidgets.QOpenGLWidget):\n            d = gl_widget.mapToGlobal(core.Point()) - self.mapToGlobal(core.Point())\n            with gui.Painter(image) as painter:\n                painter.set_composition_mode(\"source_atop\")\n                painter.drawImage(d, gl_widget.grabFramebuffer())\n        return image\n\n    def get_screen(self) -&gt; gui.Screen | None:\n        window = self.window().windowHandle()\n        if window is None:\n            return None\n        return gui.Screen(window.screen())\n\n    def delete_children(self):\n\"\"\"Delete all children of the specified QObject.\"\"\"\n        if hasattr(self, \"clear\"):\n            return self.clear()\n        layout = self.layout()\n        while layout.count():\n            item = layout.takeAt(0)\n            widget = item.widget()\n            if widget:\n                widget.deleteLater()\n            else:\n                self.delete_children(item.layout())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.delete_children","title":"<code>delete_children(self)</code>","text":"<p>Delete all children of the specified QObject.</p> Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>def delete_children(self):\n\"\"\"Delete all children of the specified QObject.\"\"\"\n    if hasattr(self, \"clear\"):\n        return self.clear()\n    layout = self.layout()\n    while layout.count():\n        item = layout.takeAt(0)\n        widget = item.widget()\n        if widget:\n            widget.deleteLater()\n        else:\n            self.delete_children(item.layout())\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_context_menu_policy","title":"<code>get_context_menu_policy(self) -&gt; constants.ContextPolicyStr</code>","text":"<p>Return current contextmenu policy.</p> <p>Returns:</p> Type Description <code>constants.ContextPolicyStr</code> <p>contextmenu policy</p> Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>def get_context_menu_policy(self) -&gt; constants.ContextPolicyStr:\n\"\"\"Return current contextmenu policy.\n\n    Returns:\n        contextmenu policy\n    \"\"\"\n    return constants.CONTEXT_POLICY.inverse[self.contextMenuPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_contextmenu_policy","title":"<code>get_contextmenu_policy(self) -&gt; constants.ContextPolicyStr</code>","text":"<p>Return current contextmenu policy.</p> <p>Returns:</p> Type Description <code>constants.ContextPolicyStr</code> <p>contextmenu policy</p> Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>@deprecated(reason=\"This method is deprecated, use get_context_menu_policy instead.\")\ndef get_contextmenu_policy(self) -&gt; constants.ContextPolicyStr:\n\"\"\"Return current contextmenu policy.\n\n    Returns:\n        contextmenu policy\n    \"\"\"\n    return self.get_context_menu_policy()\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_focus_policy","title":"<code>get_focus_policy(self) -&gt; constants.FocusPolicyStr</code>","text":"<p>Return waay the widget accepts keyboard focus.</p> <p>Returns:</p> Type Description <code>str</code> <p>Focus policy</p> Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>def get_focus_policy(self) -&gt; constants.FocusPolicyStr:\n\"\"\"Return waay the widget accepts keyboard focus.\n\n    Returns:\n        str: Focus policy\n    \"\"\"\n    return constants.FOCUS_POLICY.inverse[self.focusPolicy()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_modality","title":"<code>get_modality(self) -&gt; constants.ModalityStr</code>","text":"<p>Get the current modality modes as a string.</p> <p>Returns:</p> Type Description <code>constants.ModalityStr</code> <p>modality mode</p> Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>def get_modality(self) -&gt; constants.ModalityStr:\n\"\"\"Get the current modality modes as a string.\n\n    Returns:\n        modality mode\n    \"\"\"\n    return constants.MODALITY.inverse[self.windowModality()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.get_window_state","title":"<code>get_window_state(self) -&gt; constants.WindowStateStr</code>","text":"<p>Return current window state.</p> <p>Returns:</p> Type Description <code>constants.WindowStateStr</code> <p>window state</p> Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>def get_window_state(self) -&gt; constants.WindowStateStr:\n\"\"\"Return current window state.\n\n    Returns:\n        window state\n    \"\"\"\n    return constants.WINDOW_STATES.inverse[self.windowState()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_context_menu_policy","title":"<code>set_context_menu_policy(self, policy: constants.ContextPolicyStr) -&gt; None</code>","text":"<p>Set contextmenu policy for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>constants.ContextPolicyStr</code> <p>contextmenu policy to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>policy does not exist</p> Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>def set_context_menu_policy(self, policy: constants.ContextPolicyStr) -&gt; None:\n\"\"\"Set contextmenu policy for given item view.\n\n    Args:\n        policy: contextmenu policy to use\n\n    Raises:\n        InvalidParamError: policy does not exist\n    \"\"\"\n    if policy not in constants.CONTEXT_POLICY:\n        raise InvalidParamError(policy, constants.CONTEXT_POLICY)\n    self.setContextMenuPolicy(constants.CONTEXT_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_focus_policy","title":"<code>set_focus_policy(self, policy: constants.FocusPolicyStr) -&gt; None</code>","text":"<p>Set the way the widget accepts keyboard focus.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>str</code> <p>Focus policy</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>Description</p> Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>def set_focus_policy(self, policy: constants.FocusPolicyStr) -&gt; None:\n\"\"\"Set the way the widget accepts keyboard focus.\n\n    Args:\n        policy (str): Focus policy\n\n    Raises:\n        InvalidParamError: Description\n    \"\"\"\n    if policy not in constants.FOCUS_POLICY:\n        raise InvalidParamError(policy, constants.FOCUS_POLICY)\n    self.setFocusPolicy(constants.FOCUS_POLICY[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_icon","title":"<code>set_icon(self, icon: datatypes.IconType) -&gt; None</code>","text":"<p>Set the window icon.</p> <p>Parameters:</p> Name Type Description Default <code>icon</code> <code>datatypes.IconType</code> <p>icon to use</p> required Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>def set_icon(self, icon: datatypes.IconType) -&gt; None:\n\"\"\"Set the window icon.\n\n    Args:\n        icon: icon to use\n    \"\"\"\n    icon = iconprovider.get_icon(icon, color=colors.WINDOW_ICON_COLOR)\n    self.setWindowIcon(icon)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_modality","title":"<code>set_modality(self, modality: constants.ModalityStr) -&gt; None</code>","text":"<p>Set modality for the dialog.</p> <p>Parameters:</p> Name Type Description Default <code>modality</code> <code>constants.ModalityStr</code> <p>modality for the main window</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>modality type does not exist</p> Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>def set_modality(self, modality: constants.ModalityStr) -&gt; None:\n\"\"\"Set modality for the dialog.\n\n    Args:\n        modality: modality for the main window\n\n    Raises:\n        InvalidParamError: modality type does not exist\n    \"\"\"\n    if modality not in constants.MODALITY:\n        raise InvalidParamError(modality, constants.MODALITY)\n    self.setWindowModality(constants.MODALITY[modality])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_size_policy","title":"<code>set_size_policy(self, horizontal: widgets.sizepolicy.SizePolicyStr | None = None, vertical: widgets.sizepolicy.SizePolicyStr | None = None) -&gt; None</code>","text":"<p>Set the sizes policy.</p> <p>Parameters:</p> Name Type Description Default <code>horizontal</code> <code>widgets.sizepolicy.SizePolicyStr | None</code> <p>horizontal size policy</p> <code>None</code> <code>vertical</code> <code>widgets.sizepolicy.SizePolicyStr | None</code> <p>vertical size policy</p> <code>None</code> Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>def set_size_policy(\n    self,\n    horizontal: widgets.sizepolicy.SizePolicyStr | None = None,\n    vertical: widgets.sizepolicy.SizePolicyStr | None = None,\n) -&gt; None:\n\"\"\"Set the sizes policy.\n\n    Args:\n        horizontal: horizontal size policy\n        vertical: vertical size policy\n    \"\"\"\n    sp = self.get_size_policy()\n    if horizontal is not None:\n        sp.set_horizontal_policy(horizontal)\n    if vertical is not None:\n        sp.set_vertical_policy(vertical)\n    self.setSizePolicy(sp)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.widget.WidgetMixin.set_window_state","title":"<code>set_window_state(self, policy: constants.WindowStateStr) -&gt; None</code>","text":"<p>Set window state for given item view.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>constants.WindowStateStr</code> <p>window state to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>policy does not exist</p> Source code in <code>prettyqt/widgets/widget.py</code> <pre><code>def set_window_state(self, policy: constants.WindowStateStr) -&gt; None:\n\"\"\"Set window state for given item view.\n\n    Args:\n        policy: window state to use\n\n    Raises:\n        InvalidParamError: policy does not exist\n    \"\"\"\n    if policy not in constants.WINDOW_STATES:\n        raise InvalidParamError(policy, constants.WINDOW_STATES)\n    self.setWindowState(constants.WINDOW_STATES[policy])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizard","title":"<code>wizard</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.wizard.WizardMixin","title":"<code> WizardMixin            (DialogMixin)         </code>","text":"Source code in <code>prettyqt/widgets/wizard.py</code> <pre><code>class WizardMixin(widgets.DialogMixin):\n    def __getitem__(self, key: int) -&gt; QtWidgets.QWizardPage:\n        p = self.page(key)\n        if p is None:\n            raise KeyError(key)\n        return p\n\n    def __setitem__(self, key: int, value: QtWidgets.QWizardPage):\n        return self.setPage(key, value)\n\n    def __delitem__(self, key: int):\n        if key not in self.pageIds():\n            raise KeyError(key)\n        return self.removePage(key)\n\n    def __iter__(self) -&gt; Iterator[QtWidgets.QWizardPage]:\n        return iter(self.page(i) for i in self.pageIds())\n\n    def __add__(self, other: QtWidgets.QWizardPage) -&gt; Wizard:\n        self.addPage(other)\n        return self\n\n    def serialize_fields(self):\n        return dict(\n            current_id=self.currentId(),\n            start_id=self.startId(),\n            sub_title_format=self.get_subtitle_format(),\n            title_format=self.get_title_format(),\n            wizard_style=self.get_wizard_style(),\n        )\n\n    def add_widget_as_page(self, widget: QtWidgets.QWidget) -&gt; None:\n        page = widgets.WizardPage(self)\n        layout = widgets.BoxLayout(\"vertical\", self)\n        layout += widget\n        page.set_layout(layout)\n\n    def set_title_format(self, fmt: TextFormatStr):\n\"\"\"Set the title format.\n\n        Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"\n\n        Args:\n            fmt: title format to use\n\n        Raises:\n            InvalidParamError: title format does not exist\n        \"\"\"\n        if fmt not in TEXT_FORMATS:\n            raise InvalidParamError(fmt, TEXT_FORMATS)\n        self.setTitleFormat(TEXT_FORMATS[fmt])\n\n    def get_title_format(self) -&gt; TextFormatStr:\n\"\"\"Return current title format.\n\n        Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"\n\n        Returns:\n            title format\n        \"\"\"\n        return TEXT_FORMATS.inverse[self.titleFormat()]\n\n    def set_subtitle_format(self, fmt: TextFormatStr):\n\"\"\"Set the subtitle format.\n\n        Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"\n\n        Args:\n            fmt: subtitle format to use\n\n        Raises:\n            InvalidParamError: subtitle format does not exist\n        \"\"\"\n        if fmt not in TEXT_FORMATS:\n            raise InvalidParamError(fmt, TEXT_FORMATS)\n        self.setSubTitleFormat(TEXT_FORMATS[fmt])\n\n    def get_subtitle_format(self) -&gt; TextFormatStr:\n\"\"\"Return current subtitle format.\n\n        Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"\n\n        Returns:\n            subtitle format\n        \"\"\"\n        return TEXT_FORMATS.inverse[self.subTitleFormat()]\n\n    def get_button(self, button_type: WizardButtonStr) -&gt; QtWidgets.QAbstractButton:\n        if button_type not in WIZARD_BUTTON:\n            raise InvalidParamError(button_type, WIZARD_BUTTON)\n        return self.button(WIZARD_BUTTON[button_type])\n\n    def set_button_text(self, button_type: WizardButtonStr, value: str):\n\"\"\"Set text for given button type.\n\n        Args:\n            button_type: button to get text from\n            value: text to set\n\n        \"\"\"\n        if button_type not in WIZARD_BUTTON:\n            raise InvalidParamError(button_type, WIZARD_BUTTON)\n        self.setButtonText(WIZARD_BUTTON[button_type], value)\n\n    def get_button_text(self, button_type: WizardButtonStr) -&gt; str:\n\"\"\"Return text for given button type.\n\n        Args:\n            button_type: button to get text from\n\n        Returns:\n            Button text\n        \"\"\"\n        if button_type not in WIZARD_BUTTON:\n            raise InvalidParamError(button_type, WIZARD_BUTTON)\n        return self.buttonText(WIZARD_BUTTON[button_type])\n\n    def set_pixmap(self, typ: WizardPixmapStr, pixmap: QtGui.QPixmap | None):\n        if typ not in WIZARD_PIXMAP:\n            raise InvalidParamError(typ, WIZARD_PIXMAP)\n        if pixmap is None:\n            pixmap = QtGui.QPixmap()\n        self.setPixmap(WIZARD_PIXMAP[typ], pixmap)\n\n    def get_pixmap(self, typ: WizardPixmapStr) -&gt; gui.Pixmap | None:\n        if typ not in WIZARD_PIXMAP:\n            raise InvalidParamError(typ, WIZARD_PIXMAP)\n        pix = gui.Pixmap(self.pixmap(WIZARD_PIXMAP[typ]))\n        if pix.isNull():\n            return None\n        return pix\n\n    def set_wizard_style(self, style: WizardStyleStr):\n\"\"\"Set the wizard style.\n\n        Args:\n            style: wizard style\n\n        Raises:\n            InvalidParamError: wizard style does not exist\n        \"\"\"\n        if style not in WIZARD_STYLE:\n            raise InvalidParamError(style, WIZARD_STYLE)\n        self.setWizardStyle(WIZARD_STYLE[style])\n\n    def get_wizard_style(self) -&gt; WizardStyleStr:\n\"\"\"Return current wizard style.\n\n        Returns:\n            Wizard style\n        \"\"\"\n        return WIZARD_STYLE.inverse[self.wizardStyle()]\n\n    def set_option(self, option: WizardOptionStr, value: bool):\n\"\"\"Set option to given value.\n\n        Args:\n            option: option to use\n            value: value to set\n\n        Raises:\n            InvalidParamError: option does not exist\n        \"\"\"\n        if option not in WIZARD_OPTIONS:\n            raise InvalidParamError(option, WIZARD_OPTIONS)\n        self.setOption(WIZARD_OPTIONS[option], value)\n\n    def get_option(self, option: WizardOptionStr) -&gt; bool:\n\"\"\"Return the value assigned to option.\n\n        Args:\n            option: option to get\n\n        Returns:\n            option\n        \"\"\"\n        if option not in WIZARD_OPTIONS:\n            raise InvalidParamError(option, WIZARD_OPTIONS)\n        return self.testOption(WIZARD_OPTIONS[option])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizard.WizardMixin.get_button_text","title":"<code>get_button_text(self, button_type: WizardButtonStr) -&gt; str</code>","text":"<p>Return text for given button type.</p> <p>Parameters:</p> Name Type Description Default <code>button_type</code> <code>WizardButtonStr</code> <p>button to get text from</p> required <p>Returns:</p> Type Description <code>str</code> <p>Button text</p> Source code in <code>prettyqt/widgets/wizard.py</code> <pre><code>def get_button_text(self, button_type: WizardButtonStr) -&gt; str:\n\"\"\"Return text for given button type.\n\n    Args:\n        button_type: button to get text from\n\n    Returns:\n        Button text\n    \"\"\"\n    if button_type not in WIZARD_BUTTON:\n        raise InvalidParamError(button_type, WIZARD_BUTTON)\n    return self.buttonText(WIZARD_BUTTON[button_type])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizard.WizardMixin.get_option","title":"<code>get_option(self, option: WizardOptionStr) -&gt; bool</code>","text":"<p>Return the value assigned to option.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>WizardOptionStr</code> <p>option to get</p> required <p>Returns:</p> Type Description <code>bool</code> <p>option</p> Source code in <code>prettyqt/widgets/wizard.py</code> <pre><code>def get_option(self, option: WizardOptionStr) -&gt; bool:\n\"\"\"Return the value assigned to option.\n\n    Args:\n        option: option to get\n\n    Returns:\n        option\n    \"\"\"\n    if option not in WIZARD_OPTIONS:\n        raise InvalidParamError(option, WIZARD_OPTIONS)\n    return self.testOption(WIZARD_OPTIONS[option])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizard.WizardMixin.get_subtitle_format","title":"<code>get_subtitle_format(self) -&gt; TextFormatStr</code>","text":"<p>Return current subtitle format.</p> <p>Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"</p> <p>Returns:</p> Type Description <code>TextFormatStr</code> <p>subtitle format</p> Source code in <code>prettyqt/widgets/wizard.py</code> <pre><code>def get_subtitle_format(self) -&gt; TextFormatStr:\n\"\"\"Return current subtitle format.\n\n    Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"\n\n    Returns:\n        subtitle format\n    \"\"\"\n    return TEXT_FORMATS.inverse[self.subTitleFormat()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizard.WizardMixin.get_title_format","title":"<code>get_title_format(self) -&gt; TextFormatStr</code>","text":"<p>Return current title format.</p> <p>Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"</p> <p>Returns:</p> Type Description <code>TextFormatStr</code> <p>title format</p> Source code in <code>prettyqt/widgets/wizard.py</code> <pre><code>def get_title_format(self) -&gt; TextFormatStr:\n\"\"\"Return current title format.\n\n    Possible values: \"rich\", \"plain\", \"auto\", \"markdown\"\n\n    Returns:\n        title format\n    \"\"\"\n    return TEXT_FORMATS.inverse[self.titleFormat()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizard.WizardMixin.get_wizard_style","title":"<code>get_wizard_style(self) -&gt; WizardStyleStr</code>","text":"<p>Return current wizard style.</p> <p>Returns:</p> Type Description <code>WizardStyleStr</code> <p>Wizard style</p> Source code in <code>prettyqt/widgets/wizard.py</code> <pre><code>def get_wizard_style(self) -&gt; WizardStyleStr:\n\"\"\"Return current wizard style.\n\n    Returns:\n        Wizard style\n    \"\"\"\n    return WIZARD_STYLE.inverse[self.wizardStyle()]\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizard.WizardMixin.set_button_text","title":"<code>set_button_text(self, button_type: WizardButtonStr, value: str)</code>","text":"<p>Set text for given button type.</p> <p>Parameters:</p> Name Type Description Default <code>button_type</code> <code>WizardButtonStr</code> <p>button to get text from</p> required <code>value</code> <code>str</code> <p>text to set</p> required Source code in <code>prettyqt/widgets/wizard.py</code> <pre><code>def set_button_text(self, button_type: WizardButtonStr, value: str):\n\"\"\"Set text for given button type.\n\n    Args:\n        button_type: button to get text from\n        value: text to set\n\n    \"\"\"\n    if button_type not in WIZARD_BUTTON:\n        raise InvalidParamError(button_type, WIZARD_BUTTON)\n    self.setButtonText(WIZARD_BUTTON[button_type], value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizard.WizardMixin.set_option","title":"<code>set_option(self, option: WizardOptionStr, value: bool)</code>","text":"<p>Set option to given value.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>WizardOptionStr</code> <p>option to use</p> required <code>value</code> <code>bool</code> <p>value to set</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>option does not exist</p> Source code in <code>prettyqt/widgets/wizard.py</code> <pre><code>def set_option(self, option: WizardOptionStr, value: bool):\n\"\"\"Set option to given value.\n\n    Args:\n        option: option to use\n        value: value to set\n\n    Raises:\n        InvalidParamError: option does not exist\n    \"\"\"\n    if option not in WIZARD_OPTIONS:\n        raise InvalidParamError(option, WIZARD_OPTIONS)\n    self.setOption(WIZARD_OPTIONS[option], value)\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizard.WizardMixin.set_subtitle_format","title":"<code>set_subtitle_format(self, fmt: TextFormatStr)</code>","text":"<p>Set the subtitle format.</p> <p>Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>TextFormatStr</code> <p>subtitle format to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>subtitle format does not exist</p> Source code in <code>prettyqt/widgets/wizard.py</code> <pre><code>def set_subtitle_format(self, fmt: TextFormatStr):\n\"\"\"Set the subtitle format.\n\n    Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"\n\n    Args:\n        fmt: subtitle format to use\n\n    Raises:\n        InvalidParamError: subtitle format does not exist\n    \"\"\"\n    if fmt not in TEXT_FORMATS:\n        raise InvalidParamError(fmt, TEXT_FORMATS)\n    self.setSubTitleFormat(TEXT_FORMATS[fmt])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizard.WizardMixin.set_title_format","title":"<code>set_title_format(self, fmt: TextFormatStr)</code>","text":"<p>Set the title format.</p> <p>Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>TextFormatStr</code> <p>title format to use</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>title format does not exist</p> Source code in <code>prettyqt/widgets/wizard.py</code> <pre><code>def set_title_format(self, fmt: TextFormatStr):\n\"\"\"Set the title format.\n\n    Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\"\n\n    Args:\n        fmt: title format to use\n\n    Raises:\n        InvalidParamError: title format does not exist\n    \"\"\"\n    if fmt not in TEXT_FORMATS:\n        raise InvalidParamError(fmt, TEXT_FORMATS)\n    self.setTitleFormat(TEXT_FORMATS[fmt])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizard.WizardMixin.set_wizard_style","title":"<code>set_wizard_style(self, style: WizardStyleStr)</code>","text":"<p>Set the wizard style.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>WizardStyleStr</code> <p>wizard style</p> required <p>Exceptions:</p> Type Description <code>InvalidParamError</code> <p>wizard style does not exist</p> Source code in <code>prettyqt/widgets/wizard.py</code> <pre><code>def set_wizard_style(self, style: WizardStyleStr):\n\"\"\"Set the wizard style.\n\n    Args:\n        style: wizard style\n\n    Raises:\n        InvalidParamError: wizard style does not exist\n    \"\"\"\n    if style not in WIZARD_STYLE:\n        raise InvalidParamError(style, WIZARD_STYLE)\n    self.setWizardStyle(WIZARD_STYLE[style])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage","title":"<code>wizardpage</code>","text":""},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPageMixin","title":"<code> WizardPageMixin            (WidgetMixin)         </code>","text":"Source code in <code>prettyqt/widgets/wizardpage.py</code> <pre><code>class WizardPageMixin(widgets.WidgetMixin):\n    def serialize_fields(self):\n        return dict(title=self.title(), sub_title=self.subTitle())\n\n    def set_pixmap(\n        self, typ: widgets.wizard.WizardPixmapStr, pixmap: QtGui.QPixmap | None\n    ):\n        if typ not in widgets.wizard.WIZARD_PIXMAP:\n            raise InvalidParamError(typ, widgets.wizard.WIZARD_PIXMAP)\n        if pixmap is None:\n            pixmap = QtGui.QPixmap()\n        self.setPixmap(widgets.wizard.WIZARD_PIXMAP[typ], pixmap)\n\n    def get_pixmap(self, typ: widgets.wizard.WizardPixmapStr) -&gt; gui.Pixmap | None:\n        if typ not in widgets.wizard.WIZARD_PIXMAP:\n            raise InvalidParamError(typ, widgets.wizard.WIZARD_PIXMAP)\n        pix = gui.Pixmap(self.pixmap(widgets.wizard.WIZARD_PIXMAP[typ]))\n        if pix.isNull():\n            return None\n        return pix\n\n    def set_button_text(self, button_type: widgets.wizard.WizardButtonStr, value: str):\n\"\"\"Set text for given button type.\n\n        Args:\n            button_type: button to get text from\n            value: text to set\n\n        \"\"\"\n        if button_type not in widgets.wizard.WIZARD_BUTTON:\n            raise InvalidParamError(button_type, widgets.wizard.WIZARD_BUTTON)\n        self.setButtonText(widgets.wizard.WIZARD_BUTTON[button_type], value)\n\n    def get_button_text(self, button_type: widgets.wizard.WizardButtonStr) -&gt; str:\n\"\"\"Return text for given button type.\n\n        Args:\n            button_type: button to get text from\n\n        Returns:\n            Button text\n        \"\"\"\n        if button_type not in widgets.wizard.WIZARD_BUTTON:\n            raise InvalidParamError(button_type, widgets.wizard.WIZARD_BUTTON)\n        return self.buttonText(widgets.wizard.WIZARD_BUTTON[button_type])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPageMixin.get_button_text","title":"<code>get_button_text(self, button_type: widgets.wizard.WizardButtonStr) -&gt; str</code>","text":"<p>Return text for given button type.</p> <p>Parameters:</p> Name Type Description Default <code>button_type</code> <code>widgets.wizard.WizardButtonStr</code> <p>button to get text from</p> required <p>Returns:</p> Type Description <code>str</code> <p>Button text</p> Source code in <code>prettyqt/widgets/wizardpage.py</code> <pre><code>def get_button_text(self, button_type: widgets.wizard.WizardButtonStr) -&gt; str:\n\"\"\"Return text for given button type.\n\n    Args:\n        button_type: button to get text from\n\n    Returns:\n        Button text\n    \"\"\"\n    if button_type not in widgets.wizard.WIZARD_BUTTON:\n        raise InvalidParamError(button_type, widgets.wizard.WIZARD_BUTTON)\n    return self.buttonText(widgets.wizard.WIZARD_BUTTON[button_type])\n</code></pre>"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPageMixin.set_button_text","title":"<code>set_button_text(self, button_type: widgets.wizard.WizardButtonStr, value: str)</code>","text":"<p>Set text for given button type.</p> <p>Parameters:</p> Name Type Description Default <code>button_type</code> <code>widgets.wizard.WizardButtonStr</code> <p>button to get text from</p> required <code>value</code> <code>str</code> <p>text to set</p> required Source code in <code>prettyqt/widgets/wizardpage.py</code> <pre><code>def set_button_text(self, button_type: widgets.wizard.WizardButtonStr, value: str):\n\"\"\"Set text for given button type.\n\n    Args:\n        button_type: button to get text from\n        value: text to set\n\n    \"\"\"\n    if button_type not in widgets.wizard.WIZARD_BUTTON:\n        raise InvalidParamError(button_type, widgets.wizard.WIZARD_BUTTON)\n    self.setButtonText(widgets.wizard.WIZARD_BUTTON[button_type], value)\n</code></pre>"}]}