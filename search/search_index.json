{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"prettyqt: Pythonic layer on top of PyQt5 / PySide2 What is it? PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PySide2. Main Features Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module. Where to get it The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt Dependencies qtpy qtawesome bidict orjson regex docutils Installation from sources In the prettyqt directory (same one where you found this file after cloning the git repo), execute: python setup.py install or for installing in development mode : python -m pip install -e . License MIT Documentation The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/ Contributing to pandas All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Home"},{"location":"index.html#prettyqt-pythonic-layer-on-top-of-pyqt5-pyside2","text":"","title":"prettyqt: Pythonic layer on top of PyQt5 / PySide2"},{"location":"index.html#what-is-it","text":"PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PySide2.","title":"What is it?"},{"location":"index.html#main-features","text":"Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module.","title":"Main Features"},{"location":"index.html#where-to-get-it","text":"The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt","title":"Where to get it"},{"location":"index.html#dependencies","text":"qtpy qtawesome bidict orjson regex docutils","title":"Dependencies"},{"location":"index.html#installation-from-sources","text":"In the prettyqt directory (same one where you found this file after cloning the git repo), execute: python setup.py install or for installing in development mode : python -m pip install -e .","title":"Installation from sources"},{"location":"index.html#license","text":"MIT","title":"License"},{"location":"index.html#documentation","text":"The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/","title":"Documentation"},{"location":"index.html#contributing-to-pandas","text":"All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Contributing to pandas"},{"location":"changelog.html","text":"v0.89.0 (2020-07-13) Feat SidebarWidget : make button width configurable v0.88.1 (2020-07-13) Refactor ComboBox : use set_data for set_value Fix ComboBox : fix add_items method v0.88.0 (2020-07-13) Feat ComboBox : set_data method v0.87.0 (2020-07-13) Feat ComboBox : allow dict for add_items v0.86.3 (2020-07-12) Refactor RegexEditor : code cleanup v0.86.2 (2020-07-12) Fix another deployment fix v0.86.1 (2020-07-12) Fix deployment fix v0.86.0 (2020-07-12) Feat add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line v0.85.1 (2020-07-10) Fix add missing pygments requirement v0.85.0 (2020-07-10) Feat dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method Refactor CodeEditor : use pygments for syntax highlighting v0.84.0 (2020-07-10) Feat sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child v0.83.1 (2020-07-09) Refactor move set_icon from window classes to widget class v0.83.0 (2020-07-09) Feat add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager v0.82.0 (2020-07-09) Feat add Label.set_bold / set_italic / set_weight added Font.set_weight v0.81.0 (2020-07-08) Feat allow setting window icon color os dark mode detection v0.80.1 (2020-07-08) Fix Settings.value() returned wrong type v0.80.0 (2020-07-08) Feat add Widget.set_attribute add margin keyword argument to Widget.set_layout v0.79.1 (2020-07-08) Fix remove Qt logger on Application exit v0.79.0 (2020-07-08) Feat add widgets.Application.get_widget v0.78.0 (2020-07-08) Feat allow to save/load window state recursively. Saving needs to be done explicitely now. Fix some fixes for core.Settings dict interface properly preserve types in core.Settings v0.77.1 (2020-07-07) Refactor also allow qt flag for Splitter ctor Fix return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview 0.77.0 (2020-07-06) Feat allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages Fix fix Messagebox.message call Refactor dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars","title":"Changelog"},{"location":"changelog.html#v0890-2020-07-13","text":"","title":"v0.89.0 (2020-07-13)"},{"location":"changelog.html#feat","text":"SidebarWidget : make button width configurable","title":"Feat"},{"location":"changelog.html#v0881-2020-07-13","text":"","title":"v0.88.1 (2020-07-13)"},{"location":"changelog.html#refactor","text":"ComboBox : use set_data for set_value","title":"Refactor"},{"location":"changelog.html#fix","text":"ComboBox : fix add_items method","title":"Fix"},{"location":"changelog.html#v0880-2020-07-13","text":"","title":"v0.88.0 (2020-07-13)"},{"location":"changelog.html#feat_1","text":"ComboBox : set_data method","title":"Feat"},{"location":"changelog.html#v0870-2020-07-13","text":"","title":"v0.87.0 (2020-07-13)"},{"location":"changelog.html#feat_2","text":"ComboBox : allow dict for add_items","title":"Feat"},{"location":"changelog.html#v0863-2020-07-12","text":"","title":"v0.86.3 (2020-07-12)"},{"location":"changelog.html#refactor_1","text":"RegexEditor : code cleanup","title":"Refactor"},{"location":"changelog.html#v0862-2020-07-12","text":"","title":"v0.86.2 (2020-07-12)"},{"location":"changelog.html#fix_1","text":"another deployment fix","title":"Fix"},{"location":"changelog.html#v0861-2020-07-12","text":"","title":"v0.86.1 (2020-07-12)"},{"location":"changelog.html#fix_2","text":"deployment fix","title":"Fix"},{"location":"changelog.html#v0860-2020-07-12","text":"","title":"v0.86.0 (2020-07-12)"},{"location":"changelog.html#feat_3","text":"add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line","title":"Feat"},{"location":"changelog.html#v0851-2020-07-10","text":"","title":"v0.85.1 (2020-07-10)"},{"location":"changelog.html#fix_3","text":"add missing pygments requirement","title":"Fix"},{"location":"changelog.html#v0850-2020-07-10","text":"","title":"v0.85.0 (2020-07-10)"},{"location":"changelog.html#feat_4","text":"dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method","title":"Feat"},{"location":"changelog.html#refactor_2","text":"CodeEditor : use pygments for syntax highlighting","title":"Refactor"},{"location":"changelog.html#v0840-2020-07-10","text":"","title":"v0.84.0 (2020-07-10)"},{"location":"changelog.html#feat_5","text":"sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child","title":"Feat"},{"location":"changelog.html#v0831-2020-07-09","text":"","title":"v0.83.1 (2020-07-09)"},{"location":"changelog.html#refactor_3","text":"move set_icon from window classes to widget class","title":"Refactor"},{"location":"changelog.html#v0830-2020-07-09","text":"","title":"v0.83.0 (2020-07-09)"},{"location":"changelog.html#feat_6","text":"add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager","title":"Feat"},{"location":"changelog.html#v0820-2020-07-09","text":"","title":"v0.82.0 (2020-07-09)"},{"location":"changelog.html#feat_7","text":"add Label.set_bold / set_italic / set_weight added Font.set_weight","title":"Feat"},{"location":"changelog.html#v0810-2020-07-08","text":"","title":"v0.81.0 (2020-07-08)"},{"location":"changelog.html#feat_8","text":"allow setting window icon color os dark mode detection","title":"Feat"},{"location":"changelog.html#v0801-2020-07-08","text":"","title":"v0.80.1 (2020-07-08)"},{"location":"changelog.html#fix_4","text":"Settings.value() returned wrong type","title":"Fix"},{"location":"changelog.html#v0800-2020-07-08","text":"","title":"v0.80.0 (2020-07-08)"},{"location":"changelog.html#feat_9","text":"add Widget.set_attribute add margin keyword argument to Widget.set_layout","title":"Feat"},{"location":"changelog.html#v0791-2020-07-08","text":"","title":"v0.79.1 (2020-07-08)"},{"location":"changelog.html#fix_5","text":"remove Qt logger on Application exit","title":"Fix"},{"location":"changelog.html#v0790-2020-07-08","text":"","title":"v0.79.0 (2020-07-08)"},{"location":"changelog.html#feat_10","text":"add widgets.Application.get_widget","title":"Feat"},{"location":"changelog.html#v0780-2020-07-08","text":"","title":"v0.78.0 (2020-07-08)"},{"location":"changelog.html#feat_11","text":"allow to save/load window state recursively. Saving needs to be done explicitely now.","title":"Feat"},{"location":"changelog.html#fix_6","text":"some fixes for core.Settings dict interface properly preserve types in core.Settings","title":"Fix"},{"location":"changelog.html#v0771-2020-07-07","text":"","title":"v0.77.1 (2020-07-07)"},{"location":"changelog.html#refactor_4","text":"also allow qt flag for Splitter ctor","title":"Refactor"},{"location":"changelog.html#fix_7","text":"return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview","title":"Fix"},{"location":"changelog.html#0770-2020-07-06","text":"","title":"0.77.0 (2020-07-06)"},{"location":"changelog.html#feat_12","text":"allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages","title":"Feat"},{"location":"changelog.html#fix_8","text":"fix Messagebox.message call","title":"Fix"},{"location":"changelog.html#refactor_5","text":"dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars","title":"Refactor"},{"location":"contributing.html","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs ~~~~~~~~~~~ Report bugs at https://github.com/phil65/prettyqt/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs ~~~~~~~~ Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features ~~~~~~~~~~~~~~~~~~ Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ~~~~~~~~~~~~~~~~~~~ PrettyQt could always use more documentation, whether as part of the official PrettyQt docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback ~~~~~~~~~~~~~~~ The best way to send feedback is to file an issue at https://github.com/phil65/prettyqt/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! Ready to contribute? Here's how to set up prettyqt for local development. Fork the prettyqt repo on GitHub. Clone your fork locally:: $ git clone git@github.com:your_name_here/prettyqt.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:: $ mkvirtualenv prettyqt $ cd prettyqt/ $ python setup.py develop Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests: $ flake8 prettyqt tests $ py.test To install required development libraries, run \"pip install -r requirements_dev.txt\". Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6 - 3.8. Check https://travis-ci.org/phil65/prettyqt/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Contributing"},{"location":"contributing.html#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing.html#types-of-contributions","text":"Report Bugs ~~~~~~~~~~~ Report bugs at https://github.com/phil65/prettyqt/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs ~~~~~~~~ Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features ~~~~~~~~~~~~~~~~~~ Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ~~~~~~~~~~~~~~~~~~~ PrettyQt could always use more documentation, whether as part of the official PrettyQt docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback ~~~~~~~~~~~~~~~ The best way to send feedback is to file an issue at https://github.com/phil65/prettyqt/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Types of Contributions"},{"location":"contributing.html#get-started","text":"Ready to contribute? Here's how to set up prettyqt for local development. Fork the prettyqt repo on GitHub. Clone your fork locally:: $ git clone git@github.com:your_name_here/prettyqt.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:: $ mkvirtualenv prettyqt $ cd prettyqt/ $ python setup.py develop Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests: $ flake8 prettyqt tests $ py.test To install required development libraries, run \"pip install -r requirements_dev.txt\". Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing.html#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6 - 3.8. Check https://travis-ci.org/phil65/prettyqt/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"api/charts.html","text":"charts module charts module abstractseries AbstractSeries QAbstractSeries with some custom properties chart Chart apply_nice_numbers ( self ) adjust both axis to display nice round numbers Source code in prettyqt/charts/chart.py 64 65 66 67 68 69 def apply_nice_numbers ( self ): \"\"\" adjust both axis to display nice round numbers \"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers () update_boundaries ( self ) set new min/max values based on axis Source code in prettyqt/charts/chart.py 38 39 40 41 42 43 44 45 def update_boundaries ( self ): \"\"\" set new min/max values based on axis \"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min () zoom_by_factor ( self , factor ) zoom in/out by factor (1.0 = no change) make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def zoom_by_factor ( self , factor : float ): \"\"\" zoom in/out by factor (1.0 = no change) make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y )) chartview ChartView keyPressEvent ( self , event ) handle keypress events to allow navigation via keyboard Source code in prettyqt/charts/chartview.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def keyPressEvent ( self , event ): \"\"\" handle keypress events to allow navigation via keyboard \"\"\" key = event . key () if key == QtCore . Qt . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_0 : self . chart () . apply_nice_numbers () else : return super () . keyPressEvent ( event ) event . accept () mouseMoveEvent ( self , event ) override to allow dragging the chart Source code in prettyqt/charts/chartview.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def mouseMoveEvent ( self , event ): \"\"\" override to allow dragging the chart \"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . RightButton : if not self . last_mouse_pos : return None pos_diff = event . pos () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . pos () event . accept () QtWidgets . QApplication . restoreOverrideCursor () super () . mouseMoveEvent ( event ) mousePressEvent ( self , event ) override to allow dragging the chart Source code in prettyqt/charts/chartview.py 74 75 76 77 78 79 80 81 82 83 84 def mousePressEvent ( self , event ): \"\"\" override to allow dragging the chart \"\"\" if event . button () == QtCore . Qt . RightButton : cursor = gui . Cursor ( QtCore . Qt . SizeAllCursor ) QtWidgets . QApplication . setOverrideCursor ( cursor ) self . last_mouse_pos = event . pos () event . accept () super () . mousePressEvent ( event ) mouseReleaseEvent ( self , event ) override to allow dragging the chart Source code in prettyqt/charts/chartview.py 64 65 66 67 68 69 70 71 72 def mouseReleaseEvent ( self , event ): \"\"\" override to allow dragging the chart \"\"\" if event . button () == QtCore . Qt . RightButton : QtWidgets . QApplication . restoreOverrideCursor () event . accept () return None super () . mouseReleaseEvent ( event ) save ( self ) let user choose folder and save chart as an image file Source code in prettyqt/charts/chartview.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @core . Slot () def save ( self ): \"\"\" let user choose folder and save chart as an image file \"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return None self . chart () . show_legend () image = self . get_image () image . save ( filename [ 0 ]) self . chart () . hide_legend () wheelEvent ( self , event ) handle wheel event for zooming Source code in prettyqt/charts/chartview.py 57 58 59 60 61 62 def wheelEvent ( self , event ): \"\"\" handle wheel event for zooming \"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct ) lineseries LineSeries QLineSeries with some custom properties xyseries XYSeries QXYSeries with some custom properties","title":"charts"},{"location":"api/charts.html#charts-module","text":"","title":"charts module"},{"location":"api/charts.html#prettyqt.charts","text":"charts module","title":"prettyqt.charts"},{"location":"api/charts.html#prettyqt.charts.abstractseries","text":"","title":"abstractseries"},{"location":"api/charts.html#prettyqt.charts.abstractseries.AbstractSeries","text":"QAbstractSeries with some custom properties","title":"AbstractSeries"},{"location":"api/charts.html#prettyqt.charts.chart","text":"","title":"chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart","text":"","title":"Chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.apply_nice_numbers","text":"adjust both axis to display nice round numbers Source code in prettyqt/charts/chart.py 64 65 66 67 68 69 def apply_nice_numbers ( self ): \"\"\" adjust both axis to display nice round numbers \"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers ()","title":"apply_nice_numbers()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.update_boundaries","text":"set new min/max values based on axis Source code in prettyqt/charts/chart.py 38 39 40 41 42 43 44 45 def update_boundaries ( self ): \"\"\" set new min/max values based on axis \"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min ()","title":"update_boundaries()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.zoom_by_factor","text":"zoom in/out by factor (1.0 = no change) make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def zoom_by_factor ( self , factor : float ): \"\"\" zoom in/out by factor (1.0 = no change) make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y ))","title":"zoom_by_factor()"},{"location":"api/charts.html#prettyqt.charts.chartview","text":"","title":"chartview"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView","text":"","title":"ChartView"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.keyPressEvent","text":"handle keypress events to allow navigation via keyboard Source code in prettyqt/charts/chartview.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def keyPressEvent ( self , event ): \"\"\" handle keypress events to allow navigation via keyboard \"\"\" key = event . key () if key == QtCore . Qt . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_0 : self . chart () . apply_nice_numbers () else : return super () . keyPressEvent ( event ) event . accept ()","title":"keyPressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseMoveEvent","text":"override to allow dragging the chart Source code in prettyqt/charts/chartview.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def mouseMoveEvent ( self , event ): \"\"\" override to allow dragging the chart \"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . RightButton : if not self . last_mouse_pos : return None pos_diff = event . pos () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . pos () event . accept () QtWidgets . QApplication . restoreOverrideCursor () super () . mouseMoveEvent ( event )","title":"mouseMoveEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mousePressEvent","text":"override to allow dragging the chart Source code in prettyqt/charts/chartview.py 74 75 76 77 78 79 80 81 82 83 84 def mousePressEvent ( self , event ): \"\"\" override to allow dragging the chart \"\"\" if event . button () == QtCore . Qt . RightButton : cursor = gui . Cursor ( QtCore . Qt . SizeAllCursor ) QtWidgets . QApplication . setOverrideCursor ( cursor ) self . last_mouse_pos = event . pos () event . accept () super () . mousePressEvent ( event )","title":"mousePressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseReleaseEvent","text":"override to allow dragging the chart Source code in prettyqt/charts/chartview.py 64 65 66 67 68 69 70 71 72 def mouseReleaseEvent ( self , event ): \"\"\" override to allow dragging the chart \"\"\" if event . button () == QtCore . Qt . RightButton : QtWidgets . QApplication . restoreOverrideCursor () event . accept () return None super () . mouseReleaseEvent ( event )","title":"mouseReleaseEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.save","text":"let user choose folder and save chart as an image file Source code in prettyqt/charts/chartview.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 @core . Slot () def save ( self ): \"\"\" let user choose folder and save chart as an image file \"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return None self . chart () . show_legend () image = self . get_image () image . save ( filename [ 0 ]) self . chart () . hide_legend ()","title":"save()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.wheelEvent","text":"handle wheel event for zooming Source code in prettyqt/charts/chartview.py 57 58 59 60 61 62 def wheelEvent ( self , event ): \"\"\" handle wheel event for zooming \"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct )","title":"wheelEvent()"},{"location":"api/charts.html#prettyqt.charts.lineseries","text":"","title":"lineseries"},{"location":"api/charts.html#prettyqt.charts.lineseries.LineSeries","text":"QLineSeries with some custom properties","title":"LineSeries"},{"location":"api/charts.html#prettyqt.charts.xyseries","text":"","title":"xyseries"},{"location":"api/charts.html#prettyqt.charts.xyseries.XYSeries","text":"QXYSeries with some custom properties","title":"XYSeries"},{"location":"api/core.html","text":"core module core module contains QtCore-based classes abstractitemmodel AbstractItemModel __len__ ( self ) special return amount of rows Source code in prettyqt/core/abstractitemmodel.py 20 21 22 23 def __len__ ( self ) -> int : \"\"\"return amount of rows \"\"\" return self . rowCount () change_layout ( self ) content manager to change the layout wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py 31 32 33 34 35 36 37 38 39 40 41 42 @contextlib . contextmanager def change_layout ( self ): \"\"\"content manager to change the layout wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit () reset_model ( self ) content manager to reset the model wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py 44 45 46 47 48 49 50 51 52 53 54 55 @contextlib . contextmanager def reset_model ( self ): \"\"\"content manager to reset the model wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel () date Date __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/date.py 9 10 def __reduce__ ( self ): return ( self . __class__ , ( self . year (), self . month (), self . day ())) datetime DateTime __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/datetime.py 14 15 def __reduce__ ( self ): return ( self . __class__ , ( self . date (), self . time ())) regularexpression RegularExpression globalMatch ( self , * args , ** kwargs ) globalMatch(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py 52 53 54 def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it ) match ( self , text , offset = 0 , match_type = 'normal' , anchored = False ) match(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def match ( self , text : str , offset : int = 0 , match_type : str = \"normal\" , anchored : bool = False , ): if isinstance ( match_type , str ): match_type = MATCH_TYPES [ match_type ] if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , match_type , options ) return core . RegularExpressionMatch ( match ) settings Settings get_default_format () classmethod returns default settings format possible values are \"native\", \"ini\" Returns: Type Description str default settings format Source code in prettyqt/core/settings.py 101 102 103 104 105 106 107 108 109 110 @classmethod def get_default_format ( cls ) -> str : \"\"\"returns default settings format possible values are \"native\", \"ini\" Returns: default settings format \"\"\" return FORMATS . inv [ cls . defaultFormat ()] get_scope ( self ) returns scope possible values are \"user\", \"system\" Returns: Type Description str scope Source code in prettyqt/core/settings.py 112 113 114 115 116 117 118 119 120 def get_scope ( self ) -> str : \"\"\"returns scope possible values are \"user\", \"system\" Returns: scope \"\"\" return SCOPES . inv [ self . scope ()] group ( self , prefix ) context manager for setting groups Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py 139 140 141 142 143 144 145 146 147 148 @contextlib . contextmanager def group ( self , prefix : str ): \"\"\"context manager for setting groups Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup () read_array ( self , prefix ) context manager for reading arrays Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py 162 163 164 165 166 167 168 169 170 171 @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"context manager for reading arrays Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray () set_default_format ( fmt ) classmethod sets the default format possible values are \"native\", \"ini\" Parameters: Name Type Description Default fmt str the default format to use required Exceptions: Type Description ValueError invalid format Source code in prettyqt/core/settings.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @classmethod def set_default_format ( cls , fmt : str ): \"\"\"sets the default format possible values are \"native\", \"ini\" Args: fmt: the default format to use Raises: ValueError: invalid format \"\"\" if fmt not in FORMATS : raise ValueError ( f \"Invalid value. Valid values: { FORMATS . keys () } \" ) cls . setDefaultFormat ( FORMATS [ fmt ]) set_path ( fmt , scope , path ) classmethod sets the path to the settings file Parameters: Name Type Description Default fmt str the default format to use required scope str the scope to use required Exceptions: Type Description ValueError invalid format or scope Source code in prettyqt/core/settings.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @classmethod def set_path ( cls , fmt : str , scope : str , path : Union [ str , pathlib . Path ]): \"\"\"sets the path to the settings file Args: fmt: the default format to use scope: the scope to use Raises: ValueError: invalid format or scope \"\"\" if fmt not in FORMATS : raise ValueError ( f \"Invalid format. Valid values: { FORMATS . keys () } \" ) if scope not in SCOPES : raise ValueError ( f \"Invalid scope. Valid values: { SCOPES . keys () } \" ) cls . setPath ( FORMATS [ fmt ], SCOPES [ scope ], str ( path )) value ( self , key , default = None ) value(self, str, defaultValue: Any = None, type: type = None) -> object Source code in prettyqt/core/settings.py 75 76 77 78 79 80 81 82 83 def value ( self , key : str , default = None ): if not self . contains ( key ): return default val = super () . value ( key ) # this is for migration if not isinstance ( val , dict ) or \"value\" not in val : self . set_value ( key , val ) return val return val [ \"value\" ] write_array ( self , prefix , size =- 1 ) context manager for writing arrays Parameters: Name Type Description Default prefix str prefix for settings array required size int size of settings array -1 Source code in prettyqt/core/settings.py 150 151 152 153 154 155 156 157 158 159 160 @contextlib . contextmanager def write_array ( self , prefix : str , size : int = - 1 ): \"\"\"context manager for writing arrays Args: prefix: prefix for settings array size: size of settings array \"\"\" self . beginWriteArray ( prefix , size ) yield None self . endArray () url Url to_path ( self ) get pathlib object from the URL Returns: Type Description Path Path Source code in prettyqt/core/url.py 15 16 17 18 19 20 21 def to_path ( self ) -> pathlib . Path : \"\"\"get pathlib object from the URL Returns: Path \"\"\" return pathlib . Path ( self . path ())","title":"core"},{"location":"api/core.html#core-module","text":"","title":"core module"},{"location":"api/core.html#prettyqt.core","text":"core module contains QtCore-based classes","title":"prettyqt.core"},{"location":"api/core.html#prettyqt.core.abstractitemmodel","text":"","title":"abstractitemmodel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel","text":"","title":"AbstractItemModel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.__len__","text":"return amount of rows Source code in prettyqt/core/abstractitemmodel.py 20 21 22 23 def __len__ ( self ) -> int : \"\"\"return amount of rows \"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.change_layout","text":"content manager to change the layout wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py 31 32 33 34 35 36 37 38 39 40 41 42 @contextlib . contextmanager def change_layout ( self ): \"\"\"content manager to change the layout wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit ()","title":"change_layout()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.reset_model","text":"content manager to reset the model wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py 44 45 46 47 48 49 50 51 52 53 54 55 @contextlib . contextmanager def reset_model ( self ): \"\"\"content manager to reset the model wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel ()","title":"reset_model()"},{"location":"api/core.html#prettyqt.core.date","text":"","title":"date"},{"location":"api/core.html#prettyqt.core.date.Date","text":"","title":"Date"},{"location":"api/core.html#prettyqt.core.date.Date.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/date.py 9 10 def __reduce__ ( self ): return ( self . __class__ , ( self . year (), self . month (), self . day ()))","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.datetime","text":"","title":"datetime"},{"location":"api/core.html#prettyqt.core.datetime.DateTime","text":"","title":"DateTime"},{"location":"api/core.html#prettyqt.core.datetime.DateTime.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/datetime.py 14 15 def __reduce__ ( self ): return ( self . __class__ , ( self . date (), self . time ()))","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.regularexpression","text":"","title":"regularexpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression","text":"","title":"RegularExpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.globalMatch","text":"globalMatch(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py 52 53 54 def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it )","title":"globalMatch()"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.match","text":"match(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def match ( self , text : str , offset : int = 0 , match_type : str = \"normal\" , anchored : bool = False , ): if isinstance ( match_type , str ): match_type = MATCH_TYPES [ match_type ] if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , match_type , options ) return core . RegularExpressionMatch ( match )","title":"match()"},{"location":"api/core.html#prettyqt.core.settings","text":"","title":"settings"},{"location":"api/core.html#prettyqt.core.settings.Settings","text":"","title":"Settings"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_default_format","text":"returns default settings format possible values are \"native\", \"ini\" Returns: Type Description str default settings format Source code in prettyqt/core/settings.py 101 102 103 104 105 106 107 108 109 110 @classmethod def get_default_format ( cls ) -> str : \"\"\"returns default settings format possible values are \"native\", \"ini\" Returns: default settings format \"\"\" return FORMATS . inv [ cls . defaultFormat ()]","title":"get_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_scope","text":"returns scope possible values are \"user\", \"system\" Returns: Type Description str scope Source code in prettyqt/core/settings.py 112 113 114 115 116 117 118 119 120 def get_scope ( self ) -> str : \"\"\"returns scope possible values are \"user\", \"system\" Returns: scope \"\"\" return SCOPES . inv [ self . scope ()]","title":"get_scope()"},{"location":"api/core.html#prettyqt.core.settings.Settings.group","text":"context manager for setting groups Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py 139 140 141 142 143 144 145 146 147 148 @contextlib . contextmanager def group ( self , prefix : str ): \"\"\"context manager for setting groups Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup ()","title":"group()"},{"location":"api/core.html#prettyqt.core.settings.Settings.read_array","text":"context manager for reading arrays Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py 162 163 164 165 166 167 168 169 170 171 @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"context manager for reading arrays Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray ()","title":"read_array()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_default_format","text":"sets the default format possible values are \"native\", \"ini\" Parameters: Name Type Description Default fmt str the default format to use required Exceptions: Type Description ValueError invalid format Source code in prettyqt/core/settings.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @classmethod def set_default_format ( cls , fmt : str ): \"\"\"sets the default format possible values are \"native\", \"ini\" Args: fmt: the default format to use Raises: ValueError: invalid format \"\"\" if fmt not in FORMATS : raise ValueError ( f \"Invalid value. Valid values: { FORMATS . keys () } \" ) cls . setDefaultFormat ( FORMATS [ fmt ])","title":"set_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_path","text":"sets the path to the settings file Parameters: Name Type Description Default fmt str the default format to use required scope str the scope to use required Exceptions: Type Description ValueError invalid format or scope Source code in prettyqt/core/settings.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @classmethod def set_path ( cls , fmt : str , scope : str , path : Union [ str , pathlib . Path ]): \"\"\"sets the path to the settings file Args: fmt: the default format to use scope: the scope to use Raises: ValueError: invalid format or scope \"\"\" if fmt not in FORMATS : raise ValueError ( f \"Invalid format. Valid values: { FORMATS . keys () } \" ) if scope not in SCOPES : raise ValueError ( f \"Invalid scope. Valid values: { SCOPES . keys () } \" ) cls . setPath ( FORMATS [ fmt ], SCOPES [ scope ], str ( path ))","title":"set_path()"},{"location":"api/core.html#prettyqt.core.settings.Settings.value","text":"value(self, str, defaultValue: Any = None, type: type = None) -> object Source code in prettyqt/core/settings.py 75 76 77 78 79 80 81 82 83 def value ( self , key : str , default = None ): if not self . contains ( key ): return default val = super () . value ( key ) # this is for migration if not isinstance ( val , dict ) or \"value\" not in val : self . set_value ( key , val ) return val return val [ \"value\" ]","title":"value()"},{"location":"api/core.html#prettyqt.core.settings.Settings.write_array","text":"context manager for writing arrays Parameters: Name Type Description Default prefix str prefix for settings array required size int size of settings array -1 Source code in prettyqt/core/settings.py 150 151 152 153 154 155 156 157 158 159 160 @contextlib . contextmanager def write_array ( self , prefix : str , size : int = - 1 ): \"\"\"context manager for writing arrays Args: prefix: prefix for settings array size: size of settings array \"\"\" self . beginWriteArray ( prefix , size ) yield None self . endArray ()","title":"write_array()"},{"location":"api/core.html#prettyqt.core.url","text":"","title":"url"},{"location":"api/core.html#prettyqt.core.url.Url","text":"","title":"Url"},{"location":"api/core.html#prettyqt.core.url.Url.to_path","text":"get pathlib object from the URL Returns: Type Description Path Path Source code in prettyqt/core/url.py 15 16 17 18 19 20 21 def to_path ( self ) -> pathlib . Path : \"\"\"get pathlib object from the URL Returns: Path \"\"\" return pathlib . Path ( self . path ())","title":"to_path()"},{"location":"api/custom_models.html","text":"custom_models module custom_models module contains custom models regexmatchesmodel RegexMatchesModel columnCount ( self , parent = None ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py 18 19 def columnCount ( self , parent = None ): return len ( self . HEADER ) data ( self , index , role ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span () headerData ( self , offset , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py 21 22 23 24 def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] rowCount ( self , parent = None ) required override for AbstractitemModels Source code in prettyqt/custom_models/regexmatchesmodel.py 42 43 44 45 46 def rowCount ( self , parent = None ): \"\"\" required override for AbstractitemModels \"\"\" return len ( self . matches ) transposeproxymodel TransposeProxyModel columnCount ( self , parent =< prettyqt . core . modelindex . ModelIndex object at 0x7f15a20e9650 > ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py 33 34 def columnCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . rowCount ( parent ) data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py 36 37 38 39 def data ( self , index , role = QtCore . Qt . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role ) headerData ( self , section , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py 41 42 def headerData ( self , section : int , orientation , role ): return self . _source_model . headerData ( section , orientation , role ) index ( self , row , column , parent = None ) index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 24 25 def index ( self , row : int , column : int , parent = None ) -> QtCore . QModelIndex : return self . createIndex ( row , column ) mapFromSource ( self , source_index ) mapFromSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 18 19 def mapFromSource ( self , source_index ): return self . index ( source_index . column (), source_index . row ()) mapToSource ( self , proxy_index ) mapToSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 21 22 def mapToSource ( self , proxy_index ): return self . _source_model . index ( proxy_index . column (), proxy_index . row ()) parent ( self , index ) parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/custom_models/transposeproxymodel.py 27 28 def parent ( self , index ): return None rowCount ( self , parent =< prettyqt . core . modelindex . ModelIndex object at 0x7f15a20e9a50 > ) rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py 30 31 def rowCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . columnCount ( parent ) setSourceModel ( self , source_model ) setSourceModel(self, QAbstractItemModel) Source code in prettyqt/custom_models/transposeproxymodel.py 14 15 16 def setSourceModel ( self , source_model ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"custom_models"},{"location":"api/custom_models.html#custom_models-module","text":"","title":"custom_models module"},{"location":"api/custom_models.html#prettyqt.custom_models","text":"custom_models module contains custom models","title":"prettyqt.custom_models"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel","text":"","title":"regexmatchesmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel","text":"","title":"RegexMatchesModel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py 18 19 def columnCount ( self , parent = None ): return len ( self . HEADER )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span ()","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py 21 22 23 24 def headerData ( self , offset : int , orientation , role ): if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ]","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.rowCount","text":"required override for AbstractitemModels Source code in prettyqt/custom_models/regexmatchesmodel.py 42 43 44 45 46 def rowCount ( self , parent = None ): \"\"\" required override for AbstractitemModels \"\"\" return len ( self . matches )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel","text":"","title":"transposeproxymodel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel","text":"","title":"TransposeProxyModel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py 33 34 def columnCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . rowCount ( parent )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.data","text":"data(self, QModelIndex, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py 36 37 38 39 def data ( self , index , role = QtCore . Qt . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role )","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py 41 42 def headerData ( self , section : int , orientation , role ): return self . _source_model . headerData ( section , orientation , role )","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.index","text":"index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 24 25 def index ( self , row : int , column : int , parent = None ) -> QtCore . QModelIndex : return self . createIndex ( row , column )","title":"index()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapFromSource","text":"mapFromSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 18 19 def mapFromSource ( self , source_index ): return self . index ( source_index . column (), source_index . row ())","title":"mapFromSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapToSource","text":"mapToSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py 21 22 def mapToSource ( self , proxy_index ): return self . _source_model . index ( proxy_index . column (), proxy_index . row ())","title":"mapToSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.parent","text":"parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/custom_models/transposeproxymodel.py 27 28 def parent ( self , index ): return None","title":"parent()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.rowCount","text":"rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py 30 31 def rowCount ( self , parent = core . ModelIndex ()) -> int : return self . _source_model . columnCount ( parent )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.setSourceModel","text":"setSourceModel(self, QAbstractItemModel) Source code in prettyqt/custom_models/transposeproxymodel.py 14 15 16 def setSourceModel ( self , source_model ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"setSourceModel()"},{"location":"api/custom_validators.html","text":"custom_validators module custom_models module contains custom models compositevalidator CompositeValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/compositevalidator.py 23 24 25 def validate ( self , text : str , pos : int = 0 ) -> tuple : vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] return ( min ( vals ), text , pos ) notemptyvalidator NotEmptyValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notemptyvalidator.py 15 16 17 18 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos ) notzerovalidator NotZeroValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notzerovalidator.py 15 16 17 18 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"0\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos ) pathvalidator PathValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/pathvalidator.py 17 18 19 20 def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return ( self . Acceptable , text , pos ) return ( self . Intermediate , text , pos ) regexpatternvalidator RegexPatternValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexpatternvalidator.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def validate ( self , text : str , pos : int = 0 ) -> tuple : # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : self . compiled = re . compile ( text ) except sre_constants . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) except re . _regex_core . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) else : self . error_message = \"\" return ( self . Acceptable , text , pos ) regexvalidators BaseRegexValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexvalidators.py 33 34 35 36 37 38 39 40 41 42 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , partial = True ) if match is None : return ( self . Invalid , text , pos ) if match . partial : return ( self . Intermediate , text , pos ) else : return ( self . Acceptable , text , pos )","title":"custom_validators"},{"location":"api/custom_validators.html#custom_validators-module","text":"","title":"custom_validators module"},{"location":"api/custom_validators.html#prettyqt.custom_validators","text":"custom_models module contains custom models","title":"prettyqt.custom_validators"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator","text":"","title":"compositevalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator","text":"","title":"CompositeValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/compositevalidator.py 23 24 25 def validate ( self , text : str , pos : int = 0 ) -> tuple : vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] return ( min ( vals ), text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator","text":"","title":"notemptyvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator","text":"","title":"NotEmptyValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notemptyvalidator.py 15 16 17 18 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator","text":"","title":"notzerovalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator","text":"","title":"NotZeroValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notzerovalidator.py 15 16 17 18 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"0\" : return ( self . Intermediate , text , pos ) return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator","text":"","title":"pathvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator","text":"","title":"PathValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/pathvalidator.py 17 18 19 20 def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return ( self . Acceptable , text , pos ) return ( self . Intermediate , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator","text":"","title":"regexpatternvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator","text":"","title":"RegexPatternValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexpatternvalidator.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def validate ( self , text : str , pos : int = 0 ) -> tuple : # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : self . compiled = re . compile ( text ) except sre_constants . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) except re . _regex_core . error as e : self . error_message = str ( e ) self . compiled = None return ( self . Intermediate , text , pos ) else : self . error_message = \"\" return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators","text":"","title":"regexvalidators"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator","text":"","title":"BaseRegexValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexvalidators.py 33 34 35 36 37 38 39 40 41 42 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , partial = True ) if match is None : return ( self . Invalid , text , pos ) if match . partial : return ( self . Intermediate , text , pos ) else : return ( self . Acceptable , text , pos )","title":"validate()"},{"location":"api/custom_widgets.html","text":"custom_widgets module custom_widgets module buttondelegate ButtonDelegate createEditor ( self , parent , option , index ) createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_widgets/buttondelegate.py 15 16 17 18 19 20 21 22 23 24 def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) # btn.setStyleSheet(\"border:1px;\") return btn setEditorData ( self , editor , index ) setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_widgets/buttondelegate.py 26 27 28 def setEditorData ( self , editor , index ): editor . blockSignals ( True ) editor . blockSignals ( False ) setModelData ( self , editor , model , index ) setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_widgets/buttondelegate.py 30 31 def setModelData ( self , editor , model , index ): pass checkboxdelegate CheckBoxDelegate A delegate that places a fully functioning CheckBox in every cell of the column to which it's applied createEditor ( self , parent , option , index ) override instanciate the editor widget and initialize it also connect currentIndexChanged signal Source code in prettyqt/custom_widgets/checkboxdelegate.py 24 25 26 27 28 29 30 31 32 def createEditor ( self , parent , option , index ): \"\"\" override instanciate the editor widget and initialize it also connect currentIndexChanged signal \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb setEditorData ( self , cb , index ) override set correct initial value for editor widget Source code in prettyqt/custom_widgets/checkboxdelegate.py 34 35 36 37 38 39 40 41 def setEditorData ( self , cb , index ): \"\"\" override set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection ) setModelData ( self , combo , model , index ) override, gets called on self.commitData (?) apply the newly selected dtype to the column if possible Source code in prettyqt/custom_widgets/checkboxdelegate.py 43 44 45 46 47 48 49 50 51 52 53 def setModelData ( self , combo , model , index ): \"\"\" override, gets called on self.commitData (?) apply the newly selected dtype to the column if possible \"\"\" dtype = self . dtypes [ combo . currentText ()] # s = model.data(index, model.DATA_ROLE) try : model . setData ( index , dtype , model . DTYPE_ROLE ) except ValueError as e : logger . error ( e ) codeeditor CodeEditor resizeEvent ( self , event ) resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/codeeditor.py 34 35 36 37 38 39 def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect ) LineNumberArea paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/codeeditor.py 18 19 def paintEvent ( self , event ): self . editor . line_area_paintevent ( event ) sizeHint ( self ) sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/codeeditor.py 15 16 def sizeHint ( self ): return core . Size ( self . editor . line_area_width (), 0 ) dataset Bool Construct a boolean data item * text [string]: form's field name (optional) * label [string]: name * value [string]: default value (optional) * check [bool]: if False, value is not checked (optional, value=True) Button Construct a simple button that calls a method when hit * label [string]: text shown on the button * callback [function]: function with four params (dataset, item, value, parent) - dataset [DataSet]: instance of the parent dataset - item [DataItem]: instance of Button (i.e. self) - value [unspecified]: value of Button (default Button value or last value returned by the callback) - parent [QObject]: button's parent widget * icon [QIcon or string]: icon show on the button (optional) * check [bool]: if False, value is not checked (optional, value=True) Code Construct a code data item * label [string]: name * value [string]: default value (optional) * language [string]: language for syntax highlighting Color Construct a color data item * label [string]: name * value [string]: default value (optional) * check [bool]: if False, value is not checked (optional, value=True) Color values are encoded as hexadecimal strings or Qt color names DataItem set_pos ( self , col = 0 , colspan = None ) Set data item's position on a GUI layout Source code in prettyqt/custom_widgets/dataset.py 36 37 38 39 40 41 42 def set_pos ( self , col = 0 , colspan = None ): \"\"\" Set data item's position on a GUI layout \"\"\" self . label_col = col self . colspan = colspan return self DataSetMeta DataSet metaclass Create class attribute _items : list of the DataSet class attributes, created in the same order as these attributes were written __new__ ( mcs , name , bases , dct ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py 496 497 498 499 500 501 502 503 504 505 def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct ) Enum Construct a data item for a list of choices. * label [string]: name * choices [list, tuple or function]: string list or (key, label) list function of two arguments (item, value) returning a list of tuples (key, label, image) where image is an icon path, a QIcon instance or a function of one argument (key) returning a QIcon instance * value [-]: default label or default key (optional) * check [bool]: if False, value is not checked (optional, value=True) * radio [bool]: if True, shows radio buttons instead of a combo box (default is False) Float Construct a float data item * label [string]: name * value [float]: default value (optional) * min [float]: minimum value (optional) * max [float]: maximum value (optional) * slider [bool]: if True, shows a slider widget right after the line edit widget (default is False) * step [float]: step between tick values with a slider widget (optional) * unit [string]: physical unit (optional) * check [bool]: if False, value is not checked (optional, value=True) FloatList Construct an FloatList data item * label [string]: name * value [string]: default value (optional) * notempty [bool]: if True, empty string is not a valid value (opt.) Int Construct an integer data item * label [string]: name * value [int]: default value (optional) * min [int]: minimum value (optional) * max [int]: maximum value (optional) * unit [string]: physical unit (optional) * slider [bool]: if True, shows a slider widget right after the line edit widget (default is False) * check [bool]: if False, value is not checked (optional, value=True) IntList Construct an IntList data item * label [string]: name * value [string]: default value (optional) * notempty [bool]: if True, empty string is not a valid value (opt.) Range Construct a Range data item * label [string]: name * value [int]: default value (optional) * min [int]: minimum value (optional) * max [int]: maximum value (optional) * unit [string]: physical unit (optional) * slider [bool]: if True, shows a slider widget right after the line edit widget (default is False) * check [bool]: if False, value is not checked (optional, value=True) Regex Construct a code data item * label [string]: name * value [string]: default value (optional) * language [string]: language for syntax highlighting RegexPattern Construct a string data item * label [string]: name * value [string]: default value (optional) * notempty [bool]: if True, empty string is not a valid value (opt.) String Construct a string data item * label [string]: name * value [string]: default value (optional) * notempty [bool]: if True, empty string is not a valid value (opt.) filechooserbutton FileChooserButton __init__ ( self , extensions = None , mode = 'save' , file_mode = 'existing_files' , root = None , parent = None ) special initialize FileChooserButton Parameters: Name Type Description Default extensions dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode Accept mode (\"save\" or \"load\") 'save' file_mode File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' parent parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , extensions = None , mode = \"save\" , file_mode = \"existing_files\" , root = None , parent = None , ): \"\"\"initialize FileChooserButton Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") parent: parent widget \"\"\" super () . __init__ ( parent ) self . path = None self . extensions = extensions self . mode = mode self . file_mode = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout += self . lineedit action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout += self . button flowlayout FlowLayout addItem ( self , item ) addItem(self, QLayoutItem) Source code in prettyqt/custom_widgets/flowlayout.py 36 37 def addItem ( self , item ): self . items . append ( item ) count ( self ) count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py 39 40 def count ( self ) -> int : return len ( self . items ) expandingDirections ( self ) expandingDirections(self) -> Qt.Orientations Source code in prettyqt/custom_widgets/flowlayout.py 54 55 def expandingDirections ( self ): return QtCore . Qt . Orientations ( QtCore . Qt . Orientation ( 0 )) hasHeightForWidth ( self ) hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py 57 58 def hasHeightForWidth ( self ): return True heightForWidth ( self , width ) heightForWidth(self, int) -> int Source code in prettyqt/custom_widgets/flowlayout.py 60 61 def heightForWidth ( self , width ): return self . do_layout ( core . Rect ( 0 , 0 , width , 0 ), True ) itemAt ( self , index ) itemAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py 42 43 44 45 46 def itemAt ( self , index ): if 0 <= index < len ( self . items ): return self . items [ index ] return None minimumSize ( self ) minimumSize(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py 70 71 72 73 74 75 76 77 78 def minimumSize ( self ): size = core . Size () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += core . Size ( margin_width , margin_width ) return size setGeometry ( self , rect ) setGeometry(self, QRect) Source code in prettyqt/custom_widgets/flowlayout.py 63 64 65 def setGeometry ( self , rect ): super () . setGeometry ( rect ) self . do_layout ( rect , False ) sizeHint ( self ) sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py 67 68 def sizeHint ( self ): return self . minimumSize () takeAt ( self , index ) takeAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py 48 49 50 51 52 def takeAt ( self , index ): if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None labeledslider LabeledSlider paintEvent ( self , e ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/labeledslider.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () painter = gui . Painter ( self ) st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PM_SliderSpaceAvailable , st_slider , self . sl ) for v , v_str in self . levels : # get the size of the label rect = painter . drawText ( core . Rect (), QtCore . Qt . TextDontPrint , v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc if self . bottom_margin <= rect . height (): self . bottom_margin = rect . height () self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) painter . drawText ( left , bottom , v_str ) return logtextedit LogTextEdit wheelEvent ( self , event ) handle wheel event for zooming Source code in prettyqt/custom_widgets/logtextedit.py 211 212 213 214 215 216 217 218 def wheelEvent ( self , event ): \"\"\" handle wheel event for zooming \"\"\" if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event ) popupinfo PopupInfo dialog overlay to show some info to user show ( self , * args , ** kwargs ) show(self) Source code in prettyqt/custom_widgets/popupinfo.py 34 35 36 37 38 39 40 41 42 def show ( self , * args , ** kwargs ): self . hide () screen_geo = gui . GuiApplication . screens ()[ 0 ] . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) / 2 y = ( screen_geo . height () - size . height ()) / 2 self . move ( x , y - 200 ) super () . show ( * args , ** kwargs ) self . timer . start ( 2500 ) promptlineedit credits to PyQode Authors PromptLineEdit Extends QLineEdit to show a prompt text and a clear icon prompt_text: str property writable Gets/Sets the prompt text. paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/promptlineedit.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def paintEvent ( self , event ): super () . paintEvent ( event ) if self . _prompt_text and not self . text () and self . isEnabled (): option = widgets . StyleOptionFrame () self . initStyleOption ( option ) left , top , right , bottom = self . getTextMargins () va = self . style () . visualAlignment ( self . layoutDirection (), self . alignment ()) rect = ( self . style () . subElementRect ( widgets . Style . SE_LineEditContents , option , self ) . adjusted ( 2 , 0 , 0 , 0 ) . adjusted ( left , top , - right , - bottom ) ) fm = gui . FontMetrics ( self . font ()) text = fm . elided_text ( self . _prompt_text , mode = \"right\" , width = rect . width ()) painter = gui . Painter ( self ) painter . setPen ( self . palette () . color ( gui . Palette . Disabled , gui . Palette . Text )) painter . drawText ( rect , va , text ) resizeEvent ( self , event ) resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/promptlineedit.py 69 70 71 72 73 def resizeEvent ( self , event ): # Adjusts Clear button position super () . resizeEvent ( event ) self . button . resize ( core . Size ( self . _margin , self . height () - 2 )) self . button . move ( self . width () - self . _margin - 3 , 1 ) set_button_visible ( self , visible ) Sets the clear button as visible :param visible: Visible state (True = visible, False = hidden). Source code in prettyqt/custom_widgets/promptlineedit.py 75 76 77 78 79 80 81 82 83 84 85 86 def set_button_visible ( self , visible : bool ): \"\"\" Sets the clear button as ``visible`` :param visible: Visible state (True = visible, False = hidden). \"\"\" self . button . setVisible ( visible ) left , top , right , bottom = self . getTextMargins () if visible : right = self . _margin + self . _spacing else : right = 0 self . setTextMargins ( left , top , right , bottom ) radiodelegate RadioDelegate createEditor ( self , parent , option , index ) createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_widgets/radiodelegate.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def createEditor ( self , parent , option , index ): editor = widgets . Widget ( parent ) editor . setContentsMargins ( 0 , 0 , 0 , 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . buttonGroup = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . setFocusPolicy ( QtCore . Qt . NoFocus ) rb . installEventFilter ( self ) editor . buttonGroup . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) editor . installEventFilter ( self ) return editor eventFilter ( self , source , event ) eventFilter(self, QObject, QEvent) -> bool Source code in prettyqt/custom_widgets/radiodelegate.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def eventFilter ( self , source , event ): if event . type () == core . Event . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event ) setEditorData ( self , editor , index ) setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_widgets/radiodelegate.py 78 79 80 81 def setEditorData ( self , editor , index ): value = index . data ( QtCore . Qt . DisplayRole ) if value in self . items : editor . buttonGroup . button ( self . items . index ( value )) . setChecked ( True ) setModelData ( self , editor , model , index ) setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_widgets/radiodelegate.py 83 84 85 86 87 def setModelData ( self , editor , model , index ): button = editor . buttonGroup . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], QtCore . Qt . DisplayRole ) self . choices [ button ] = index . row () updateEditorGeometry ( self , editor , option , index ) updateEditorGeometry(self, QWidget, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_widgets/radiodelegate.py 67 68 69 70 71 72 73 74 75 76 def updateEditorGeometry ( self , editor , option , index ): rect = core . Rect ( option . rect ) minWidth = editor . minimumSizeHint () . width () if rect . width () < minWidth : rect . setWidth ( minWidth ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) editor . setMask ( mask ) regexeditor special This package contains the API. You may use it to embed the regex editor inside your own PyQt application. editor This module contains the editor widget implementation. quick_ref Contains the quick reference widget spanslider SpanSlider mouseMoveEvent ( self , event ) mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PM_MaximumDragDistance , opt , self ) new_pos = self . pixel_pos_to_value ( self . pick ( event . pos ()) - self . offset ) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . pos ()): new_pos = self . position # pick the preferred handle on the first movement if self . first_movement : if self . lower == self . upper : if new_pos < self . lower_value : self . swap_controls () self . first_movement = False else : self . first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper - 1 ) if self . movement == \"free\" and new_pos > self . upper : self . swap_controls () self . set_upper_pos ( new_pos ) else : self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower : self . swap_controls () self . set_lower_pos ( new_pos ) else : self . set_upper_pos ( new_pos ) event . accept () mousePressEvent ( self , event ) mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . handle_mouse_press ( event . pos (), self . upper_pressed , self . upper , self . UPPER_HANDLE ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . handle_mouse_press ( event . pos (), self . lower_pressed , self . lower , self . LOWER_HANDLE ) self . first_movement = True event . accept () mouseReleaseEvent ( self , event ) mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 431 432 433 434 435 def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SC_None self . update () paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/spanslider.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SC_SliderTickmarks painter . drawComplexControl ( SLIDER_STYLE , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . drawComplexControl ( SLIDER_STYLE , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () spanRect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) if self . is_horizontal (): spanRect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) self . draw_span ( painter , spanRect ) # handles if self . last_pressed == self . LOWER_HANDLE : self . draw_handle ( painter , self . UPPER_HANDLE ) self . draw_handle ( painter , self . LOWER_HANDLE ) else : self . draw_handle ( painter , self . LOWER_HANDLE ) self . draw_handle ( painter , self . UPPER_HANDLE ) waitingspinner The MIT License (MIT) Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. BaseWaitingSpinner paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( \"none\" ) for i in range ( 0 , self . _line_num ): painter . save () painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length , ) rotate_angle = float ( 360 * i ) / float ( self . _line_num ) painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) rect = core . Rect ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . RelativeSize ) painter . restore () WaitingSpinner paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py 231 232 233 def paintEvent ( self , event ): self . update_position () super () . paintEvent ( event )","title":"custom_widgets"},{"location":"api/custom_widgets.html#custom_widgets-module","text":"","title":"custom_widgets module"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets","text":"custom_widgets module","title":"prettyqt.custom_widgets"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.buttondelegate","text":"","title":"buttondelegate"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.buttondelegate.ButtonDelegate","text":"","title":"ButtonDelegate"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.buttondelegate.ButtonDelegate.createEditor","text":"createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_widgets/buttondelegate.py 15 16 17 18 19 20 21 22 23 24 def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) # btn.setStyleSheet(\"border:1px;\") return btn","title":"createEditor()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.buttondelegate.ButtonDelegate.setEditorData","text":"setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_widgets/buttondelegate.py 26 27 28 def setEditorData ( self , editor , index ): editor . blockSignals ( True ) editor . blockSignals ( False )","title":"setEditorData()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.buttondelegate.ButtonDelegate.setModelData","text":"setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_widgets/buttondelegate.py 30 31 def setModelData ( self , editor , model , index ): pass","title":"setModelData()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.checkboxdelegate","text":"","title":"checkboxdelegate"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.checkboxdelegate.CheckBoxDelegate","text":"A delegate that places a fully functioning CheckBox in every cell of the column to which it's applied","title":"CheckBoxDelegate"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.checkboxdelegate.CheckBoxDelegate.createEditor","text":"override instanciate the editor widget and initialize it also connect currentIndexChanged signal Source code in prettyqt/custom_widgets/checkboxdelegate.py 24 25 26 27 28 29 30 31 32 def createEditor ( self , parent , option , index ): \"\"\" override instanciate the editor widget and initialize it also connect currentIndexChanged signal \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb","title":"createEditor()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.checkboxdelegate.CheckBoxDelegate.setEditorData","text":"override set correct initial value for editor widget Source code in prettyqt/custom_widgets/checkboxdelegate.py 34 35 36 37 38 39 40 41 def setEditorData ( self , cb , index ): \"\"\" override set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection )","title":"setEditorData()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.checkboxdelegate.CheckBoxDelegate.setModelData","text":"override, gets called on self.commitData (?) apply the newly selected dtype to the column if possible Source code in prettyqt/custom_widgets/checkboxdelegate.py 43 44 45 46 47 48 49 50 51 52 53 def setModelData ( self , combo , model , index ): \"\"\" override, gets called on self.commitData (?) apply the newly selected dtype to the column if possible \"\"\" dtype = self . dtypes [ combo . currentText ()] # s = model.data(index, model.DATA_ROLE) try : model . setData ( index , dtype , model . DTYPE_ROLE ) except ValueError as e : logger . error ( e )","title":"setModelData()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor","text":"","title":"codeeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor","text":"","title":"CodeEditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor.resizeEvent","text":"resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/codeeditor.py 34 35 36 37 38 39 def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea","text":"","title":"LineNumberArea"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/codeeditor.py 18 19 def paintEvent ( self , event ): self . editor . line_area_paintevent ( event )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.sizeHint","text":"sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/codeeditor.py 15 16 def sizeHint ( self ): return core . Size ( self . editor . line_area_width (), 0 )","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset","text":"","title":"dataset"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.Bool","text":"Construct a boolean data item * text [string]: form's field name (optional) * label [string]: name * value [string]: default value (optional) * check [bool]: if False, value is not checked (optional, value=True)","title":"Bool"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.Button","text":"Construct a simple button that calls a method when hit * label [string]: text shown on the button * callback [function]: function with four params (dataset, item, value, parent) - dataset [DataSet]: instance of the parent dataset - item [DataItem]: instance of Button (i.e. self) - value [unspecified]: value of Button (default Button value or last value returned by the callback) - parent [QObject]: button's parent widget * icon [QIcon or string]: icon show on the button (optional) * check [bool]: if False, value is not checked (optional, value=True)","title":"Button"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.Code","text":"Construct a code data item * label [string]: name * value [string]: default value (optional) * language [string]: language for syntax highlighting","title":"Code"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.Color","text":"Construct a color data item * label [string]: name * value [string]: default value (optional) * check [bool]: if False, value is not checked (optional, value=True) Color values are encoded as hexadecimal strings or Qt color names","title":"Color"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem","text":"","title":"DataItem"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem.set_pos","text":"Set data item's position on a GUI layout Source code in prettyqt/custom_widgets/dataset.py 36 37 38 39 40 41 42 def set_pos ( self , col = 0 , colspan = None ): \"\"\" Set data item's position on a GUI layout \"\"\" self . label_col = col self . colspan = colspan return self","title":"set_pos()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta","text":"DataSet metaclass Create class attribute _items : list of the DataSet class attributes, created in the same order as these attributes were written","title":"DataSetMeta"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py 496 497 498 499 500 501 502 503 504 505 def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct )","title":"__new__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.Enum","text":"Construct a data item for a list of choices. * label [string]: name * choices [list, tuple or function]: string list or (key, label) list function of two arguments (item, value) returning a list of tuples (key, label, image) where image is an icon path, a QIcon instance or a function of one argument (key) returning a QIcon instance * value [-]: default label or default key (optional) * check [bool]: if False, value is not checked (optional, value=True) * radio [bool]: if True, shows radio buttons instead of a combo box (default is False)","title":"Enum"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.Float","text":"Construct a float data item * label [string]: name * value [float]: default value (optional) * min [float]: minimum value (optional) * max [float]: maximum value (optional) * slider [bool]: if True, shows a slider widget right after the line edit widget (default is False) * step [float]: step between tick values with a slider widget (optional) * unit [string]: physical unit (optional) * check [bool]: if False, value is not checked (optional, value=True)","title":"Float"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.FloatList","text":"Construct an FloatList data item * label [string]: name * value [string]: default value (optional) * notempty [bool]: if True, empty string is not a valid value (opt.)","title":"FloatList"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.Int","text":"Construct an integer data item * label [string]: name * value [int]: default value (optional) * min [int]: minimum value (optional) * max [int]: maximum value (optional) * unit [string]: physical unit (optional) * slider [bool]: if True, shows a slider widget right after the line edit widget (default is False) * check [bool]: if False, value is not checked (optional, value=True)","title":"Int"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.IntList","text":"Construct an IntList data item * label [string]: name * value [string]: default value (optional) * notempty [bool]: if True, empty string is not a valid value (opt.)","title":"IntList"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.Range","text":"Construct a Range data item * label [string]: name * value [int]: default value (optional) * min [int]: minimum value (optional) * max [int]: maximum value (optional) * unit [string]: physical unit (optional) * slider [bool]: if True, shows a slider widget right after the line edit widget (default is False) * check [bool]: if False, value is not checked (optional, value=True)","title":"Range"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.Regex","text":"Construct a code data item * label [string]: name * value [string]: default value (optional) * language [string]: language for syntax highlighting","title":"Regex"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.RegexPattern","text":"Construct a string data item * label [string]: name * value [string]: default value (optional) * notempty [bool]: if True, empty string is not a valid value (opt.)","title":"RegexPattern"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.String","text":"Construct a string data item * label [string]: name * value [string]: default value (optional) * notempty [bool]: if True, empty string is not a valid value (opt.)","title":"String"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton","text":"","title":"filechooserbutton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton","text":"","title":"FileChooserButton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton.__init__","text":"initialize FileChooserButton Parameters: Name Type Description Default extensions dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode Accept mode (\"save\" or \"load\") 'save' file_mode File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' parent parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , extensions = None , mode = \"save\" , file_mode = \"existing_files\" , root = None , parent = None , ): \"\"\"initialize FileChooserButton Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") parent: parent widget \"\"\" super () . __init__ ( parent ) self . path = None self . extensions = extensions self . mode = mode self . file_mode = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout += self . lineedit action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout += self . button","title":"__init__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout","text":"","title":"flowlayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout","text":"","title":"FlowLayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.addItem","text":"addItem(self, QLayoutItem) Source code in prettyqt/custom_widgets/flowlayout.py 36 37 def addItem ( self , item ): self . items . append ( item )","title":"addItem()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.count","text":"count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py 39 40 def count ( self ) -> int : return len ( self . items )","title":"count()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.expandingDirections","text":"expandingDirections(self) -> Qt.Orientations Source code in prettyqt/custom_widgets/flowlayout.py 54 55 def expandingDirections ( self ): return QtCore . Qt . Orientations ( QtCore . Qt . Orientation ( 0 ))","title":"expandingDirections()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.hasHeightForWidth","text":"hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py 57 58 def hasHeightForWidth ( self ): return True","title":"hasHeightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.heightForWidth","text":"heightForWidth(self, int) -> int Source code in prettyqt/custom_widgets/flowlayout.py 60 61 def heightForWidth ( self , width ): return self . do_layout ( core . Rect ( 0 , 0 , width , 0 ), True )","title":"heightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.itemAt","text":"itemAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py 42 43 44 45 46 def itemAt ( self , index ): if 0 <= index < len ( self . items ): return self . items [ index ] return None","title":"itemAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.minimumSize","text":"minimumSize(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py 70 71 72 73 74 75 76 77 78 def minimumSize ( self ): size = core . Size () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += core . Size ( margin_width , margin_width ) return size","title":"minimumSize()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.setGeometry","text":"setGeometry(self, QRect) Source code in prettyqt/custom_widgets/flowlayout.py 63 64 65 def setGeometry ( self , rect ): super () . setGeometry ( rect ) self . do_layout ( rect , False )","title":"setGeometry()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.sizeHint","text":"sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py 67 68 def sizeHint ( self ): return self . minimumSize ()","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.takeAt","text":"takeAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py 48 49 50 51 52 def takeAt ( self , index ): if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None","title":"takeAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider","text":"","title":"labeledslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider","text":"","title":"LabeledSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/labeledslider.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () painter = gui . Painter ( self ) st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PM_SliderSpaceAvailable , st_slider , self . sl ) for v , v_str in self . levels : # get the size of the label rect = painter . drawText ( core . Rect (), QtCore . Qt . TextDontPrint , v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc if self . bottom_margin <= rect . height (): self . bottom_margin = rect . height () self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . layout . setContentsMargins ( self . left_margin , self . top_margin , self . right_margin , self . bottom_margin , ) painter . drawText ( left , bottom , v_str ) return","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.logtextedit","text":"","title":"logtextedit"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.logtextedit.LogTextEdit","text":"","title":"LogTextEdit"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.logtextedit.LogTextEdit.wheelEvent","text":"handle wheel event for zooming Source code in prettyqt/custom_widgets/logtextedit.py 211 212 213 214 215 216 217 218 def wheelEvent ( self , event ): \"\"\" handle wheel event for zooming \"\"\" if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event )","title":"wheelEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo","text":"","title":"popupinfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo","text":"dialog overlay to show some info to user","title":"PopupInfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo.show","text":"show(self) Source code in prettyqt/custom_widgets/popupinfo.py 34 35 36 37 38 39 40 41 42 def show ( self , * args , ** kwargs ): self . hide () screen_geo = gui . GuiApplication . screens ()[ 0 ] . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) / 2 y = ( screen_geo . height () - size . height ()) / 2 self . move ( x , y - 200 ) super () . show ( * args , ** kwargs ) self . timer . start ( 2500 )","title":"show()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit","text":"credits to PyQode Authors","title":"promptlineedit"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit","text":"Extends QLineEdit to show a prompt text and a clear icon","title":"PromptLineEdit"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.prompt_text","text":"Gets/Sets the prompt text.","title":"prompt_text"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/promptlineedit.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def paintEvent ( self , event ): super () . paintEvent ( event ) if self . _prompt_text and not self . text () and self . isEnabled (): option = widgets . StyleOptionFrame () self . initStyleOption ( option ) left , top , right , bottom = self . getTextMargins () va = self . style () . visualAlignment ( self . layoutDirection (), self . alignment ()) rect = ( self . style () . subElementRect ( widgets . Style . SE_LineEditContents , option , self ) . adjusted ( 2 , 0 , 0 , 0 ) . adjusted ( left , top , - right , - bottom ) ) fm = gui . FontMetrics ( self . font ()) text = fm . elided_text ( self . _prompt_text , mode = \"right\" , width = rect . width ()) painter = gui . Painter ( self ) painter . setPen ( self . palette () . color ( gui . Palette . Disabled , gui . Palette . Text )) painter . drawText ( rect , va , text )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.resizeEvent","text":"resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/promptlineedit.py 69 70 71 72 73 def resizeEvent ( self , event ): # Adjusts Clear button position super () . resizeEvent ( event ) self . button . resize ( core . Size ( self . _margin , self . height () - 2 )) self . button . move ( self . width () - self . _margin - 3 , 1 )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.promptlineedit.PromptLineEdit.set_button_visible","text":"Sets the clear button as visible :param visible: Visible state (True = visible, False = hidden). Source code in prettyqt/custom_widgets/promptlineedit.py 75 76 77 78 79 80 81 82 83 84 85 86 def set_button_visible ( self , visible : bool ): \"\"\" Sets the clear button as ``visible`` :param visible: Visible state (True = visible, False = hidden). \"\"\" self . button . setVisible ( visible ) left , top , right , bottom = self . getTextMargins () if visible : right = self . _margin + self . _spacing else : right = 0 self . setTextMargins ( left , top , right , bottom )","title":"set_button_visible()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.radiodelegate","text":"","title":"radiodelegate"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.radiodelegate.RadioDelegate","text":"","title":"RadioDelegate"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.radiodelegate.RadioDelegate.createEditor","text":"createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_widgets/radiodelegate.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def createEditor ( self , parent , option , index ): editor = widgets . Widget ( parent ) editor . setContentsMargins ( 0 , 0 , 0 , 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . buttonGroup = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . setFocusPolicy ( QtCore . Qt . NoFocus ) rb . installEventFilter ( self ) editor . buttonGroup . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) editor . installEventFilter ( self ) return editor","title":"createEditor()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.radiodelegate.RadioDelegate.eventFilter","text":"eventFilter(self, QObject, QEvent) -> bool Source code in prettyqt/custom_widgets/radiodelegate.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def eventFilter ( self , source , event ): if event . type () == core . Event . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event )","title":"eventFilter()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.radiodelegate.RadioDelegate.setEditorData","text":"setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_widgets/radiodelegate.py 78 79 80 81 def setEditorData ( self , editor , index ): value = index . data ( QtCore . Qt . DisplayRole ) if value in self . items : editor . buttonGroup . button ( self . items . index ( value )) . setChecked ( True )","title":"setEditorData()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.radiodelegate.RadioDelegate.setModelData","text":"setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_widgets/radiodelegate.py 83 84 85 86 87 def setModelData ( self , editor , model , index ): button = editor . buttonGroup . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], QtCore . Qt . DisplayRole ) self . choices [ button ] = index . row ()","title":"setModelData()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.radiodelegate.RadioDelegate.updateEditorGeometry","text":"updateEditorGeometry(self, QWidget, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_widgets/radiodelegate.py 67 68 69 70 71 72 73 74 75 76 def updateEditorGeometry ( self , editor , option , index ): rect = core . Rect ( option . rect ) minWidth = editor . minimumSizeHint () . width () if rect . width () < minWidth : rect . setWidth ( minWidth ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) editor . setMask ( mask )","title":"updateEditorGeometry()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor","text":"This package contains the API. You may use it to embed the regex editor inside your own PyQt application.","title":"regexeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.editor","text":"This module contains the editor widget implementation.","title":"editor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.quick_ref","text":"Contains the quick reference widget","title":"quick_ref"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider","text":"","title":"spanslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider","text":"","title":"SpanSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseMoveEvent","text":"mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PM_MaximumDragDistance , opt , self ) new_pos = self . pixel_pos_to_value ( self . pick ( event . pos ()) - self . offset ) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . pos ()): new_pos = self . position # pick the preferred handle on the first movement if self . first_movement : if self . lower == self . upper : if new_pos < self . lower_value : self . swap_controls () self . first_movement = False else : self . first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper - 1 ) if self . movement == \"free\" and new_pos > self . upper : self . swap_controls () self . set_upper_pos ( new_pos ) else : self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower : self . swap_controls () self . set_lower_pos ( new_pos ) else : self . set_upper_pos ( new_pos ) event . accept ()","title":"mouseMoveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mousePressEvent","text":"mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . handle_mouse_press ( event . pos (), self . upper_pressed , self . upper , self . UPPER_HANDLE ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . handle_mouse_press ( event . pos (), self . lower_pressed , self . lower , self . LOWER_HANDLE ) self . first_movement = True event . accept ()","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseReleaseEvent","text":"mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py 431 432 433 434 435 def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SC_None self . update ()","title":"mouseReleaseEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/spanslider.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SC_SliderTickmarks painter . drawComplexControl ( SLIDER_STYLE , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . drawComplexControl ( SLIDER_STYLE , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () spanRect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) if self . is_horizontal (): spanRect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) self . draw_span ( painter , spanRect ) # handles if self . last_pressed == self . LOWER_HANDLE : self . draw_handle ( painter , self . UPPER_HANDLE ) self . draw_handle ( painter , self . LOWER_HANDLE ) else : self . draw_handle ( painter , self . LOWER_HANDLE ) self . draw_handle ( painter , self . UPPER_HANDLE )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner","text":"The MIT License (MIT) Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"waitingspinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner","text":"","title":"BaseWaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( \"none\" ) for i in range ( 0 , self . _line_num ): painter . save () painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length , ) rotate_angle = float ( 360 * i ) / float ( self . _line_num ) painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) rect = core . Rect ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . RelativeSize ) painter . restore ()","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner","text":"","title":"WaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py 231 232 233 def paintEvent ( self , event ): self . update_position () super () . paintEvent ( event )","title":"paintEvent()"},{"location":"api/gui.html","text":"gui module gui module contains QtGui-based classes color Color __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/color.py 15 16 def __reduce__ ( self ): return ( self . __class__ , ( self . red (), self . green (), self . blue (), self . alpha ())) from_text ( text ) classmethod Create a QColor from specified string Source code in prettyqt/gui/color.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @classmethod def from_text ( cls , text ): \"\"\"Create a QColor from specified string\"\"\" color = cls () text = str ( text ) if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color cursor Cursor get_shape ( self ) returns current cursor shape Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: Type Description str cursor shape Source code in prettyqt/gui/cursor.py 35 36 37 38 39 40 41 42 43 def get_shape ( self ) -> str : \"\"\"returns current cursor shape Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: cursor shape \"\"\" return SHAPES . inv [ self . shape ()] set_shape ( self , shape ) sets cursor shape Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Parameters: Name Type Description Default shape str shape to use required Exceptions: Type Description ValueError shape does not exist Source code in prettyqt/gui/cursor.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def set_shape ( self , shape : str ): \"\"\"sets cursor shape Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Args: shape: shape to use Raises: ValueError: shape does not exist \"\"\" if shape not in SHAPES : raise ValueError ( f \"Invalid shape type ' { shape } .\" ) self . setShape ( SHAPES [ shape ]) font Font set_style_hint ( self , hint ) sets the style hint Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str style hint required Exceptions: Type Description ValueError invalid style hint Source code in prettyqt/gui/font.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def set_style_hint ( self , hint : str ): \"\"\"sets the style hint Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: style hint Raises: ValueError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise ValueError ( \"Invalid style hint\" ) self . setStyleHint ( STYLE_HINTS [ hint ]) set_weight ( self , weight ) sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description ValueError invalid font weight Source code in prettyqt/gui/font.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def set_weight ( self , weight : str ): \"\"\"sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: ValueError: invalid font weight \"\"\" if weight not in WEIGHTS : raise ValueError ( f \"Invalid weight ' { weight } '\" ) self . setWeight ( WEIGHTS [ weight ]) painter Painter get_composition_mode ( self ) get the current composition mode Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: Type Description str composition mode Source code in prettyqt/gui/painter.py 108 109 110 111 112 113 114 115 116 117 118 def get_composition_mode ( self ) -> str : \"\"\"get the current composition mode Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: composition mode \"\"\" return COMP_MODES . inv [ self . compositionMode ()] get_pen ( self ) returns current pen type Possible values: \"none\", Returns: Type Description str pen type Source code in prettyqt/gui/painter.py 78 79 80 81 82 83 84 85 86 def get_pen ( self ) -> str : \"\"\"returns current pen type Possible values: \"none\", Returns: pen type \"\"\" return PEN_TYPES . inv [ self . pen ()] set_composition_mode ( self , mode ) set the current composition mode Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Exceptions: Type Description ValueError composition mode does not exist Source code in prettyqt/gui/painter.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def set_composition_mode ( self , mode : str ): \"\"\"set the current composition mode Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Raises: ValueError: composition mode does not exist \"\"\" if mode not in COMP_MODES : raise ValueError ( \"Invalid composition mode.\" f \" Valid values: { COMP_MODES . keys () } \" ) self . setCompositionMode ( COMP_MODES [ mode ]) set_pen ( self , pen_type ) set pen type to use Allowed values are \"none\", Parameters: Name Type Description Default pen_type str pen type to use required Exceptions: Type Description ValueError pen type does not exist Source code in prettyqt/gui/painter.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def set_pen ( self , pen_type : str ): \"\"\"set pen type to use Allowed values are \"none\", Args: pen_type: pen type to use Raises: ValueError: pen type does not exist \"\"\" if pen_type not in PEN_TYPES : raise ValueError ( f \"Invalid pen type. Valid values: { PEN_TYPES . keys () } \" ) self . setPen ( PEN_TYPES [ pen_type ]) regularexpressionvalidator_pyside RegularExpressionValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/gui/regularexpressionvalidator_pyside.py 36 37 38 39 40 41 42 43 44 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , match_type = \"prefer_first\" ) if match . hasPartialMatch (): return ( self . Intermediate , text , pos ) if match . hasMatch (): return ( self . Acceptable , text , pos ) return ( self . Invalid , text , pos ) standarditem StandardItem clone ( self ) clone(self) -> QStandardItem Source code in prettyqt/gui/standarditem.py 32 33 34 35 36 37 38 39 40 def clone ( self ): item = self . __class__ () ba = QtCore . QByteArray () ds = QtCore . QDataStream ( ba , core . IODevice . WriteOnly ) ds << self ds = QtCore . QDataStream ( ba ) ds >> item assert type ( item ) == StandardItem return item set_icon ( self , icon ) set the icon for the action Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/gui/standarditem.py 42 43 44 45 46 47 48 49 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the action Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( icon ) syntaxhighlighter SyntaxHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py 29 30 31 32 33 34 35 36 def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text. \"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt ) textblockuserdata TextBlockUserData Storage for the user data associated with each line. textcharformat TextCharFormat get_font_weight ( self ) get current font weight Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: Type Description str current font weight Source code in prettyqt/gui/textcharformat.py 69 70 71 72 73 74 75 76 77 def get_font_weight ( self ) -> str : \"\"\"get current font weight Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: current font weight \"\"\" return WEIGHTS . inv [ self . fontWeight ()] get_underline_style ( self ) get current underline style Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: Type Description str current underline style Source code in prettyqt/gui/textcharformat.py 95 96 97 98 99 100 101 102 103 104 def get_underline_style ( self ) -> str : \"\"\"get current underline style Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: current underline style \"\"\" return UNDERLINE_STYLES . inv [ self . underlineStyle ()] set_font_style_hint ( self , hint ) sets the font style hint Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str font style hint required Exceptions: Type Description ValueError invalid font style hint Source code in prettyqt/gui/textcharformat.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def set_font_style_hint ( self , hint : str ): \"\"\"sets the font style hint Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: font style hint Raises: ValueError: invalid font style hint \"\"\" if hint not in STYLE_HINTS : raise ValueError ( \"Invalid font style hint\" ) self . setFontStyleHint ( STYLE_HINTS [ hint ]) set_font_weight ( self , weight ) sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description ValueError invalid font weight Source code in prettyqt/gui/textcharformat.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def set_font_weight ( self , weight : str ): \"\"\"sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: ValueError: invalid font weight \"\"\" if weight not in WEIGHTS : raise ValueError ( \"Invalid font weight\" ) self . setFontWeight ( WEIGHTS [ weight ]) set_underline_style ( self , style ) sets the underline style Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Parameters: Name Type Description Default style str underline style required Exceptions: Type Description ValueError invalid underline style Source code in prettyqt/gui/textcharformat.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def set_underline_style ( self , style : str ): \"\"\"sets the underline style Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Args: style: underline style Raises: ValueError: invalid underline style \"\"\" if style not in UNDERLINE_STYLES : raise ValueError ( \"Invalid underline style\" ) self . setUnderlineStyle ( UNDERLINE_STYLES [ style ]) textcursor TextCursor edit_block ( self ) Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py 105 106 107 108 109 110 111 @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions. \"\"\" self . beginEditBlock () yield self . endEditBlock () select ( self , selection ) select(self, QTextCursor.SelectionType) Source code in prettyqt/gui/textcursor.py 66 67 68 69 def select ( self , selection ): if selection in SELECTION_TYPES : selection = SELECTION_TYPES [ selection ] super () . select ( selection ) select_text ( self , start_pos , end_pos ) select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos Union[int, str] Start position required end_pos Union[int, str] End position required Source code in prettyqt/gui/textcursor.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def select_text ( self , start_pos : Union [ int , str ], end_pos : Union [ int , str ]) -> str : \"\"\"select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText () set_position ( self , pos , mode = 'move' ) set cursor to given position Parameters: Name Type Description Default pos int Cursor position required mode str Move mode 'move' Source code in prettyqt/gui/textcursor.py 57 58 59 60 61 62 63 64 def set_position ( self , pos : int , mode : str = \"move\" ): \"\"\"set cursor to given position Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODES [ mode ]) validator Validator __radd__ ( self , other ) special needed for sum() Source code in prettyqt/gui/validator.py 23 24 25 26 27 def __radd__ ( self , other : QtGui . QValidator ): \"\"\" needed for sum() \"\"\" return self . __add__ ( other )","title":"gui"},{"location":"api/gui.html#gui-module","text":"","title":"gui module"},{"location":"api/gui.html#prettyqt.gui","text":"gui module contains QtGui-based classes","title":"prettyqt.gui"},{"location":"api/gui.html#prettyqt.gui.color","text":"","title":"color"},{"location":"api/gui.html#prettyqt.gui.color.Color","text":"","title":"Color"},{"location":"api/gui.html#prettyqt.gui.color.Color.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/color.py 15 16 def __reduce__ ( self ): return ( self . __class__ , ( self . red (), self . green (), self . blue (), self . alpha ()))","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.color.Color.from_text","text":"Create a QColor from specified string Source code in prettyqt/gui/color.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @classmethod def from_text ( cls , text ): \"\"\"Create a QColor from specified string\"\"\" color = cls () text = str ( text ) if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color","title":"from_text()"},{"location":"api/gui.html#prettyqt.gui.cursor","text":"","title":"cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor","text":"","title":"Cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.get_shape","text":"returns current cursor shape Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: Type Description str cursor shape Source code in prettyqt/gui/cursor.py 35 36 37 38 39 40 41 42 43 def get_shape ( self ) -> str : \"\"\"returns current cursor shape Possible values: \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Returns: cursor shape \"\"\" return SHAPES . inv [ self . shape ()]","title":"get_shape()"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.set_shape","text":"sets cursor shape Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Parameters: Name Type Description Default shape str shape to use required Exceptions: Type Description ValueError shape does not exist Source code in prettyqt/gui/cursor.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def set_shape ( self , shape : str ): \"\"\"sets cursor shape Allowed values are \"arrow\", \"uparrow\", \"cross\", \"wait\", \"caret\" Args: shape: shape to use Raises: ValueError: shape does not exist \"\"\" if shape not in SHAPES : raise ValueError ( f \"Invalid shape type ' { shape } .\" ) self . setShape ( SHAPES [ shape ])","title":"set_shape()"},{"location":"api/gui.html#prettyqt.gui.font","text":"","title":"font"},{"location":"api/gui.html#prettyqt.gui.font.Font","text":"","title":"Font"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style_hint","text":"sets the style hint Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str style hint required Exceptions: Type Description ValueError invalid style hint Source code in prettyqt/gui/font.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def set_style_hint ( self , hint : str ): \"\"\"sets the style hint Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: style hint Raises: ValueError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise ValueError ( \"Invalid style hint\" ) self . setStyleHint ( STYLE_HINTS [ hint ])","title":"set_style_hint()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_weight","text":"sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description ValueError invalid font weight Source code in prettyqt/gui/font.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def set_weight ( self , weight : str ): \"\"\"sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: ValueError: invalid font weight \"\"\" if weight not in WEIGHTS : raise ValueError ( f \"Invalid weight ' { weight } '\" ) self . setWeight ( WEIGHTS [ weight ])","title":"set_weight()"},{"location":"api/gui.html#prettyqt.gui.painter","text":"","title":"painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter","text":"","title":"Painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_composition_mode","text":"get the current composition mode Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: Type Description str composition mode Source code in prettyqt/gui/painter.py 108 109 110 111 112 113 114 115 116 117 118 def get_composition_mode ( self ) -> str : \"\"\"get the current composition mode Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Returns: composition mode \"\"\" return COMP_MODES . inv [ self . compositionMode ()]","title":"get_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_pen","text":"returns current pen type Possible values: \"none\", Returns: Type Description str pen type Source code in prettyqt/gui/painter.py 78 79 80 81 82 83 84 85 86 def get_pen ( self ) -> str : \"\"\"returns current pen type Possible values: \"none\", Returns: pen type \"\"\" return PEN_TYPES . inv [ self . pen ()]","title":"get_pen()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_composition_mode","text":"set the current composition mode Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Exceptions: Type Description ValueError composition mode does not exist Source code in prettyqt/gui/painter.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def set_composition_mode ( self , mode : str ): \"\"\"set the current composition mode Possible values: \"source_over\", \"destination_over\", \"clear\", \"source\", \"destination\", \"source_in\", \"destination_in\", \"source_out\", \"destination_out\", \"source_atop\", \"destination_atop\", Raises: ValueError: composition mode does not exist \"\"\" if mode not in COMP_MODES : raise ValueError ( \"Invalid composition mode.\" f \" Valid values: { COMP_MODES . keys () } \" ) self . setCompositionMode ( COMP_MODES [ mode ])","title":"set_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_pen","text":"set pen type to use Allowed values are \"none\", Parameters: Name Type Description Default pen_type str pen type to use required Exceptions: Type Description ValueError pen type does not exist Source code in prettyqt/gui/painter.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def set_pen ( self , pen_type : str ): \"\"\"set pen type to use Allowed values are \"none\", Args: pen_type: pen type to use Raises: ValueError: pen type does not exist \"\"\" if pen_type not in PEN_TYPES : raise ValueError ( f \"Invalid pen type. Valid values: { PEN_TYPES . keys () } \" ) self . setPen ( PEN_TYPES [ pen_type ])","title":"set_pen()"},{"location":"api/gui.html#prettyqt.gui.regularexpressionvalidator_pyside","text":"","title":"regularexpressionvalidator_pyside"},{"location":"api/gui.html#prettyqt.gui.regularexpressionvalidator_pyside.RegularExpressionValidator","text":"","title":"RegularExpressionValidator"},{"location":"api/gui.html#prettyqt.gui.regularexpressionvalidator_pyside.RegularExpressionValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/gui/regularexpressionvalidator_pyside.py 36 37 38 39 40 41 42 43 44 def validate ( self , text : str , pos : int = 0 ) -> tuple : if text == \"\" : return ( self . Intermediate , text , pos ) match = self . regex . match ( text , match_type = \"prefer_first\" ) if match . hasPartialMatch (): return ( self . Intermediate , text , pos ) if match . hasMatch (): return ( self . Acceptable , text , pos ) return ( self . Invalid , text , pos )","title":"validate()"},{"location":"api/gui.html#prettyqt.gui.standarditem","text":"","title":"standarditem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem","text":"","title":"StandardItem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.clone","text":"clone(self) -> QStandardItem Source code in prettyqt/gui/standarditem.py 32 33 34 35 36 37 38 39 40 def clone ( self ): item = self . __class__ () ba = QtCore . QByteArray () ds = QtCore . QDataStream ( ba , core . IODevice . WriteOnly ) ds << self ds = QtCore . QDataStream ( ba ) ds >> item assert type ( item ) == StandardItem return item","title":"clone()"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_icon","text":"set the icon for the action Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/gui/standarditem.py 42 43 44 45 46 47 48 49 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the action Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter","text":"","title":"syntaxhighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter","text":"","title":"SyntaxHighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py 29 30 31 32 33 34 35 36 def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text. \"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt )","title":"highlightBlock()"},{"location":"api/gui.html#prettyqt.gui.textblockuserdata","text":"","title":"textblockuserdata"},{"location":"api/gui.html#prettyqt.gui.textblockuserdata.TextBlockUserData","text":"Storage for the user data associated with each line.","title":"TextBlockUserData"},{"location":"api/gui.html#prettyqt.gui.textcharformat","text":"","title":"textcharformat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat","text":"","title":"TextCharFormat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_font_weight","text":"get current font weight Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: Type Description str current font weight Source code in prettyqt/gui/textcharformat.py 69 70 71 72 73 74 75 76 77 def get_font_weight ( self ) -> str : \"\"\"get current font weight Possible values are \"thin\", \"light\", \"medium\" or \"bold\" Returns: current font weight \"\"\" return WEIGHTS . inv [ self . fontWeight ()]","title":"get_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_underline_style","text":"get current underline style Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: Type Description str current underline style Source code in prettyqt/gui/textcharformat.py 95 96 97 98 99 100 101 102 103 104 def get_underline_style ( self ) -> str : \"\"\"get current underline style Possible values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Returns: current underline style \"\"\" return UNDERLINE_STYLES . inv [ self . underlineStyle ()]","title":"get_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_style_hint","text":"sets the font style hint Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Parameters: Name Type Description Default hint str font style hint required Exceptions: Type Description ValueError invalid font style hint Source code in prettyqt/gui/textcharformat.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def set_font_style_hint ( self , hint : str ): \"\"\"sets the font style hint Valid values are \"any\", \"sans_serif\", \"serif\", \"typewriter\", \"decorative\", \"monospace\", \"fantasy\", \"cursive\", \"system\" Args: hint: font style hint Raises: ValueError: invalid font style hint \"\"\" if hint not in STYLE_HINTS : raise ValueError ( \"Invalid font style hint\" ) self . setFontStyleHint ( STYLE_HINTS [ hint ])","title":"set_font_style_hint()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_weight","text":"sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description ValueError invalid font weight Source code in prettyqt/gui/textcharformat.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def set_font_weight ( self , weight : str ): \"\"\"sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: ValueError: invalid font weight \"\"\" if weight not in WEIGHTS : raise ValueError ( \"Invalid font weight\" ) self . setFontWeight ( WEIGHTS [ weight ])","title":"set_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_underline_style","text":"sets the underline style Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Parameters: Name Type Description Default style str underline style required Exceptions: Type Description ValueError invalid underline style Source code in prettyqt/gui/textcharformat.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def set_underline_style ( self , style : str ): \"\"\"sets the underline style Valid values are \"none\", \"single\", \"dash\", \"dot\", \"dashdot\", \"dashdotline\", \"wave\", \"spellcheck\" Args: style: underline style Raises: ValueError: invalid underline style \"\"\" if style not in UNDERLINE_STYLES : raise ValueError ( \"Invalid underline style\" ) self . setUnderlineStyle ( UNDERLINE_STYLES [ style ])","title":"set_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcursor","text":"","title":"textcursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor","text":"","title":"TextCursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.edit_block","text":"Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py 105 106 107 108 109 110 111 @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions. \"\"\" self . beginEditBlock () yield self . endEditBlock ()","title":"edit_block()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select","text":"select(self, QTextCursor.SelectionType) Source code in prettyqt/gui/textcursor.py 66 67 68 69 def select ( self , selection ): if selection in SELECTION_TYPES : selection = SELECTION_TYPES [ selection ] super () . select ( selection )","title":"select()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select_text","text":"select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos Union[int, str] Start position required end_pos Union[int, str] End position required Source code in prettyqt/gui/textcursor.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def select_text ( self , start_pos : Union [ int , str ], end_pos : Union [ int , str ]) -> str : \"\"\"select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText ()","title":"select_text()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.set_position","text":"set cursor to given position Parameters: Name Type Description Default pos int Cursor position required mode str Move mode 'move' Source code in prettyqt/gui/textcursor.py 57 58 59 60 61 62 63 64 def set_position ( self , pos : int , mode : str = \"move\" ): \"\"\"set cursor to given position Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODES [ mode ])","title":"set_position()"},{"location":"api/gui.html#prettyqt.gui.validator","text":"","title":"validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator","text":"","title":"Validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator.__radd__","text":"needed for sum() Source code in prettyqt/gui/validator.py 23 24 25 26 27 def __radd__ ( self , other : QtGui . QValidator ): \"\"\" needed for sum() \"\"\" return self . __add__ ( other )","title":"__radd__()"},{"location":"api/syntaxhighlighters.html","text":"syntaxhighlighters module syntaxhighlighters module contains some custom syntax highlighers highlightrule HighlightRule dataclass HighlightRule(regex: Union[str, List[str]] = '', color: str = 'black', italic: bool = False, bold: bool = False, minimal: bool = False, font_size: Union[float, NoneType] = None, nth: int = 0) __init_subclass__ ( ** kwargs ) classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py 25 26 27 28 29 30 31 32 def __init_subclass__ ( cls , ** kwargs ): super () . __init_subclass__ ( ** kwargs ) if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . format = cls . get_format () jsonhighlighter JsonHighlighter highlightBlock ( self , text ) Highlight a block of code using the rules outlined in the Constructor Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py 26 27 28 29 30 31 32 33 34 35 36 def highlightBlock ( self , text : str ): \"\"\" Highlight a block of code using the rules outlined in the Constructor \"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT ) markdownhighlighter Syntax highlighter for Markdown markup language MarkdownHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py 92 93 94 95 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE ) pygmentshighlighter PygmentsHighlighter Syntax highlighter that uses Pygments for parsing. highlightBlock ( self , string ) Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def highlightBlock ( self , string ): \"\"\" Highlight a block of text. \"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack set_style ( self , style ) Sets the style to the specified Pygments style. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 139 140 141 142 143 144 145 def set_style ( self , style ): \"\"\" Sets the style to the specified Pygments style. \"\"\" if isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches () set_style_sheet ( self , stylesheet ) Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 147 148 149 150 151 152 153 154 155 156 157 158 def set_style_sheet ( self , stylesheet ): \"\"\" Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches () get_tokens_unprocessed ( self , text , stack = ( 'root' ,)) Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def get_tokens_unprocessed ( self , text , stack = ( \"root\" ,)): \"\"\" Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while 1 : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if type ( action ) is _TokenType : yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , \"wrong state def: %r \" % new_state statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" pos += 1 statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos , Text , \" \\n \" continue yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack ) qstring_length ( text ) Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 13 14 15 16 17 18 19 20 21 22 23 def qstring_length ( text ): \"\"\" Tries to compute what the length of an utf16-encoded QString would be. \"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length pythonhighlighter Syntax highlighter for the programming language Python PythonHighlighter Syntax highlighter for the Python language. highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py 146 147 148 149 150 151 152 153 154 def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text. \"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE ) match_multiline ( self , text , delimiter , in_state , style ) Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def match_multiline ( self , text , delimiter , in_state , style ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : start = delimiter . indexIn ( text ) # Move past this match add = delimiter . matchedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter end = delimiter . indexIn ( text , start + add ) # Ending delimiter on this line? if end >= add : length = end - start + add + delimiter . matchedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . indexIn ( text , start + length ) # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state regexmatchhighlighter RegexMatchHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i ) xmlhighlighter based on http://www.yasinuludag.com/blog/?p=49 XmlHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . indexIn ( text ) while start_index >= 0 : end_index = VALUE_END_EXPRESSION . indexIn ( text , start_index ) if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : matched_len = VALUE_END_EXPRESSION . matchedLength () comment_len = end_index - start_index + matched_len self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . indexIn ( text , start_index + comment_len ) yamlhighlighter YamlHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py 84 85 86 87 88 89 90 91 92 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . indexIn ( text ) if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"syntaxhighlighters"},{"location":"api/syntaxhighlighters.html#syntaxhighlighters-module","text":"","title":"syntaxhighlighters module"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters","text":"syntaxhighlighters module contains some custom syntax highlighers","title":"prettyqt.syntaxhighlighters"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule","text":"","title":"highlightrule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule","text":"HighlightRule(regex: Union[str, List[str]] = '', color: str = 'black', italic: bool = False, bold: bool = False, minimal: bool = False, font_size: Union[float, NoneType] = None, nth: int = 0)","title":"HighlightRule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py 25 26 27 28 29 30 31 32 def __init_subclass__ ( cls , ** kwargs ): super () . __init_subclass__ ( ** kwargs ) if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . format = cls . get_format ()","title":"__init_subclass__()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter","text":"","title":"jsonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter","text":"","title":"JsonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter.highlightBlock","text":"Highlight a block of code using the rules outlined in the Constructor Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py 26 27 28 29 30 31 32 33 34 35 36 def highlightBlock ( self , text : str ): \"\"\" Highlight a block of code using the rules outlined in the Constructor \"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter","text":"Syntax highlighter for Markdown markup language","title":"markdownhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter","text":"","title":"MarkdownHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py 92 93 94 95 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter","text":"","title":"pygmentshighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter","text":"Syntax highlighter that uses Pygments for parsing.","title":"PygmentsHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.highlightBlock","text":"Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def highlightBlock ( self , string ): \"\"\" Highlight a block of text. \"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style","text":"Sets the style to the specified Pygments style. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 139 140 141 142 143 144 145 def set_style ( self , style ): \"\"\" Sets the style to the specified Pygments style. \"\"\" if isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches ()","title":"set_style()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style_sheet","text":"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 147 148 149 150 151 152 153 154 155 156 157 158 def set_style_sheet ( self , stylesheet ): \"\"\" Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches ()","title":"set_style_sheet()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.get_tokens_unprocessed","text":"Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def get_tokens_unprocessed ( self , text , stack = ( \"root\" ,)): \"\"\" Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while 1 : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if type ( action ) is _TokenType : yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , \"wrong state def: %r \" % new_state statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" pos += 1 statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos , Text , \" \\n \" continue yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack )","title":"get_tokens_unprocessed()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.qstring_length","text":"Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py 13 14 15 16 17 18 19 20 21 22 23 def qstring_length ( text ): \"\"\" Tries to compute what the length of an utf16-encoded QString would be. \"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length","title":"qstring_length()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter","text":"Syntax highlighter for the programming language Python","title":"pythonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter","text":"Syntax highlighter for the Python language.","title":"PythonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py 146 147 148 149 150 151 152 153 154 def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text. \"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.match_multiline","text":"Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def match_multiline ( self , text , delimiter , in_state , style ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : start = delimiter . indexIn ( text ) # Move past this match add = delimiter . matchedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter end = delimiter . indexIn ( text , start + add ) # Ending delimiter on this line? if end >= add : length = end - start + add + delimiter . matchedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . indexIn ( text , start + length ) # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state","title":"match_multiline()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter","text":"","title":"regexmatchhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter","text":"","title":"RegexMatchHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter","text":"based on http://www.yasinuludag.com/blog/?p=49","title":"xmlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter","text":"","title":"XmlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . indexIn ( text ) while start_index >= 0 : end_index = VALUE_END_EXPRESSION . indexIn ( text , start_index ) if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : matched_len = VALUE_END_EXPRESSION . matchedLength () comment_len = end_index - start_index + matched_len self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . indexIn ( text , start_index + comment_len )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter","text":"","title":"yamlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter","text":"","title":"YamlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py 84 85 86 87 88 89 90 91 92 def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . indexIn ( text ) if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"highlightBlock()"},{"location":"api/webenginewidgets.html","text":"webenginewidgets module gui module contains QWebEngineView-based classes webenginepage WebEnginePage A web engine page holds the contents of an HTML document, the history of navigated links, and actions. find_text ( self , string , backward = False , case_sensitive = False , callback = None ) Find text in the current page Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webenginepage.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = self . FindFlag () if case_sensitive : flag |= self . FindCaseSensitively if backward : flag |= self . FindBackward self . findText ( string , flag , callback ) load_url ( self , url ) load the URL Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webenginepage.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"load the URL Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) set_url ( self , url ) set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webenginepage.py 21 22 23 24 25 26 27 28 29 30 31 32 33 def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom ) Set the zoom factor for the Page Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webenginepage.py 52 53 54 55 56 57 58 59 60 def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom ) webengineview WebEngineView find_text ( self , string , backward = False , case_sensitive = False , callback = None ) Find text in the current page Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webengineview.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlag () if case_sensitive : flag |= QtWebEngineWidgets . QWebEnginePage . FindCaseSensitively if backward : flag |= QtWebEngineWidgets . QWebEnginePage . FindBackward self . findText ( string , flag , callback ) load_url ( self , url ) load the URL Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webengineview.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"load the URL Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) set_url ( self , url ) set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webengineview.py 17 18 19 20 21 22 23 24 25 26 27 28 29 def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom ) Set the zoom factor for the view Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py 48 49 50 51 52 53 54 55 56 def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"webenginewidgets"},{"location":"api/webenginewidgets.html#webenginewidgets-module","text":"","title":"webenginewidgets module"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets","text":"gui module contains QWebEngineView-based classes","title":"prettyqt.webenginewidgets"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage","text":"","title":"webenginepage"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage","text":"A web engine page holds the contents of an HTML document, the history of navigated links, and actions.","title":"WebEnginePage"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.find_text","text":"Find text in the current page Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webenginepage.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = self . FindFlag () if case_sensitive : flag |= self . FindCaseSensitively if backward : flag |= self . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.load_url","text":"load the URL Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webenginepage.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"load the URL Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_url","text":"set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webenginepage.py 21 22 23 24 25 26 27 28 29 30 31 32 33 def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_zoom","text":"Set the zoom factor for the Page Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webenginepage.py 52 53 54 55 56 57 58 59 60 def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview","text":"","title":"webengineview"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView","text":"","title":"WebEngineView"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.find_text","text":"Find text in the current page Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable result callback None Source code in prettyqt/webenginewidgets/webengineview.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable = None , ): \"\"\"Find text in the current page Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlag () if case_sensitive : flag |= QtWebEngineWidgets . QWebEnginePage . FindCaseSensitively if backward : flag |= QtWebEngineWidgets . QWebEnginePage . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.load_url","text":"load the URL Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webengineview.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"load the URL Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_url","text":"set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webengineview.py 17 18 19 20 21 22 23 24 25 26 27 28 29 def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_zoom","text":"Set the zoom factor for the view Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py 48 49 50 51 52 53 54 55 56 def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/widgets.html","text":"widgets module widgets module contains QtWidgets-based classes abstractbutton AbstractButton set_icon ( self , icon ) set the icon for the button Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/abstractbutton.py 44 45 46 47 48 49 50 51 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the button Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( icon ) abstractitemview AbstractItemView get_selection_behaviour ( self ) returns current selection behaviour Possible values: \"rows\", \"columns\", \"items\" Returns: Type Description str selection behaviour Source code in prettyqt/widgets/abstractitemview.py 185 186 187 188 189 190 191 192 193 def get_selection_behaviour ( self ) -> str : \"\"\"returns current selection behaviour Possible values: \"rows\", \"columns\", \"items\" Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOURS . inv [ self . selectionBehavior ()] get_selection_mode ( self ) returns current selection mode Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/abstractitemview.py 214 215 216 217 218 219 220 221 222 def get_selection_mode ( self ) -> str : \"\"\"returns current selection mode Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()] highlight_when_inactive ( self ) also highlight items when widget does not have focus Source code in prettyqt/widgets/abstractitemview.py 307 308 309 310 311 312 def highlight_when_inactive ( self ): \"\"\"also highlight items when widget does not have focus \"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p ) jump_to_column ( self , col_num ) make sure column at given index is visible scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py 280 281 282 283 284 285 286 287 288 289 290 291 def jump_to_column ( self , col_num : int ): \"\"\"make sure column at given index is visible scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return None idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx ) num_selected ( self ) returns amount of selected rows Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py 270 271 272 273 274 275 276 277 278 def num_selected ( self ) -> int : \"\"\"returns amount of selected rows Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ()) scroll_to_bottom ( self ) override to use abstractitemview-way of scrolling to bottom Source code in prettyqt/widgets/abstractitemview.py 298 299 300 301 def scroll_to_bottom ( self ): \"\"\"override to use abstractitemview-way of scrolling to bottom \"\"\" self . scrollToBottom () scroll_to_top ( self ) override to use abstractitemview-way of scrolling to top Source code in prettyqt/widgets/abstractitemview.py 293 294 295 296 def scroll_to_top ( self ): \"\"\"override to use abstractitemview-way of scrolling to top \"\"\" self . scrollToTop () selectAll ( self ) Override, we dont want to selectAll for too many items for performance reasons Source code in prettyqt/widgets/abstractitemview.py 49 50 51 52 53 54 55 56 57 58 def selectAll ( self ): \"\"\" Override, we dont want to selectAll for too many items for performance reasons \"\"\" if self . model () is None : return None if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logging . warning ( \"Too many cells to select.\" ) return None super () . selectAll () selected_data ( self ) returns generator yielding selected userData Source code in prettyqt/widgets/abstractitemview.py 146 147 148 149 150 def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\" returns generator yielding selected userData \"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes ()) selected_indexes ( self ) returns list of selected indexes in first row Source code in prettyqt/widgets/abstractitemview.py 127 128 129 130 131 132 def selected_indexes ( self ) -> List [ QtCore . QModelIndex ]: \"\"\" returns list of selected indexes in first row \"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) return sorted ( indexes , key = lambda x : x . row ()) selected_names ( self ) returns generator yielding item names Source code in prettyqt/widgets/abstractitemview.py 134 135 136 137 138 def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\" returns generator yielding item names \"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ()) selected_rows ( self ) returns generator yielding row nums Source code in prettyqt/widgets/abstractitemview.py 140 141 142 143 144 def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\" returns generator yielding row nums \"\"\" return ( x . row () for x in self . selected_indexes ()) set_horizontal_scroll_mode ( self , mode ) sets the horizontal scroll mode possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description ValueError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def set_horizontal_scroll_mode ( self , mode : str ): \"\"\"sets the horizontal scroll mode possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: ValueError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise ValueError ( \"Invalid scroll mode\" ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ]) set_model ( self , model ) delete old selection model explicitely, seems to help with memory usage Source code in prettyqt/widgets/abstractitemview.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def set_model ( self , model : Optional [ QtCore . QAbstractItemModel ]): \"\"\" delete old selection model explicitely, seems to help with memory usage \"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model set_scroll_mode ( self , mode ) sets the scroll mode for both directions possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description ValueError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def set_scroll_mode ( self , mode : str ): \"\"\"sets the scroll mode for both directions possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: ValueError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise ValueError ( \"Invalid scroll mode\" ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ]) self . setVerticalScrollMode ( SCROLL_MODES [ mode ]) set_selection_behaviour ( self , behaviour ) set selection behaviour for given item view Allowed values are \"rows\", \"columns\", \"items\" Parameters: Name Type Description Default behaviour str selection behaviour to use required Exceptions: Type Description ValueError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def set_selection_behaviour ( self , behaviour : str ): \"\"\"set selection behaviour for given item view Allowed values are \"rows\", \"columns\", \"items\" Args: behaviour: selection behaviour to use Raises: ValueError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOURS : raise ValueError ( \"invalid selection behaviour\" ) self . setSelectionBehavior ( SELECTION_BEHAVIOURS [ behaviour ]) set_selection_mode ( self , mode ) set selection mode for given item view Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description ValueError mode does not exist Source code in prettyqt/widgets/abstractitemview.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"set selection mode for given item view Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Args: mode: selection mode to use Raises: ValueError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise ValueError ( \"Format must be either 'single', 'extended',\" \"'multi' or 'None'\" ) self . setSelectionMode ( SELECTION_MODES [ mode ]) set_vertical_scroll_mode ( self , mode ) sets the vertical scroll mode possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description ValueError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 def set_vertical_scroll_mode ( self , mode : str ): \"\"\"sets the vertical scroll mode possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: ValueError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise ValueError ( \"Invalid scroll mode\" ) self . setVerticalScrollMode ( SCROLL_MODES [ mode ]) toggle_select_all ( self ) select all items from list (deselect when all selected) Source code in prettyqt/widgets/abstractitemview.py 97 98 99 100 101 102 103 104 105 106 def toggle_select_all ( self ): \"\"\" select all items from list (deselect when all selected) \"\"\" if self . selectionModel () is None : return None if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll () abstractscrollarea AbstractScrollArea get_size_adjust_policy ( self ) returns size adjust policy possible values are \"content\", \"first_show\", \"ignored\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py 70 71 72 73 74 75 76 77 78 def get_size_adjust_policy ( self ) -> str : \"\"\"returns size adjust policy possible values are \"content\", \"first_show\", \"ignored\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()] scroll_to_bottom ( self ) scroll to the bottom of the scroll area Source code in prettyqt/widgets/abstractscrollarea.py 158 159 160 161 def scroll_to_bottom ( self ): \"\"\"scroll to the bottom of the scroll area \"\"\" self . verticalScrollBar () . scroll_to_max () scroll_to_top ( self ) scroll to the top of the scroll area Source code in prettyqt/widgets/abstractscrollarea.py 153 154 155 156 def scroll_to_top ( self ): \"\"\"scroll to the top of the scroll area \"\"\" self . verticalScrollBar () . scroll_to_min () set_horizontal_scrollbar_policy ( self , mode ) sets the horizontal scrollbar visibility possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description ValueError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def set_horizontal_scrollbar_policy ( self , mode : str ): \"\"\"sets the horizontal scrollbar visibility possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: ValueError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise ValueError ( \"Invalid scrollbar policy\" ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_horizontal_scrollbar_width ( self , width ) sets the horizontal scrollbar width Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 135 136 137 138 139 140 141 142 def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"sets the horizontal scrollbar width Args: width: width in pixels \"\"\" stylesheet = f \"QScrollBar:horizontal {{ height: { width } px; }} \" self . horizontalScrollBar () . setStyleSheet ( stylesheet ) set_scrollbar_policy ( self , mode ) sets the policy for both scrollbars possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description ValueError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def set_scrollbar_policy ( self , mode : str ): \"\"\"sets the policy for both scrollbars possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: ValueError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise ValueError ( \"Invalid scrollbar policy\" ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_scrollbar_width ( self , width ) sets the width for both scrollbars Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 126 127 128 129 130 131 132 133 def set_scrollbar_width ( self , width : int ): \"\"\"sets the width for both scrollbars Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width ) set_size_adjust_policy ( self , policy ) set size adjust policy Valid values are \"content\", \"first_show\", \"ignored\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description ValueError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def set_size_adjust_policy ( self , policy : str ): \"\"\"set size adjust policy Valid values are \"content\", \"first_show\", \"ignored\" Args: policy: size adjust policy to use Raises: ValueError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise ValueError ( \"Policy not available\" ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy ) set_vertical_scrollbar_policy ( self , mode ) sets the vertical scrollbar visibility possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description ValueError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def set_vertical_scrollbar_policy ( self , mode : str ): \"\"\"sets the vertical scrollbar visibility possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: ValueError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise ValueError ( \"Invalid scrollbar policy\" ) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) set_vertical_scrollbar_width ( self , width ) sets the vertical scrollbar width Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 144 145 146 147 148 149 150 151 def set_vertical_scrollbar_width ( self , width : int ): \"\"\"sets the vertical scrollbar width Args: width: width in pixels \"\"\" stylesheet = f \"QScrollBar:vertical {{ width: { width } px; }} \" self . verticalScrollBar () . setStyleSheet ( stylesheet ) abstractslider AbstractSlider is_horizontal ( self ) check if silder is horizontal Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py 41 42 43 44 45 46 47 def is_horizontal ( self ) -> bool : \"\"\"check if silder is horizontal Returns: True if horizontal, else False \"\"\" return self . orientation () == QtCore . Qt . Horizontal is_vertical ( self ) check if silder is vertical Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py 49 50 51 52 53 54 55 def is_vertical ( self ) -> bool : \"\"\"check if silder is vertical Returns: True if vertical, else False \"\"\" return self . orientation () == QtCore . Qt . Vertical scroll_to_max ( self ) scroll to the maximum value of the slider Source code in prettyqt/widgets/abstractslider.py 72 73 74 75 def scroll_to_max ( self ): \"\"\"scroll to the maximum value of the slider \"\"\" self . setValue ( self . maximum ()) scroll_to_min ( self ) scroll to the minimum value of the slider Source code in prettyqt/widgets/abstractslider.py 67 68 69 70 def scroll_to_min ( self ): \"\"\"scroll to the minimum value of the slider \"\"\" self . setValue ( self . minimum ()) set_horizontal ( self ) set slider orientation to horizontal Source code in prettyqt/widgets/abstractslider.py 57 58 59 60 def set_horizontal ( self ): \"\"\"set slider orientation to horizontal \"\"\" self . setOrientation ( QtCore . Qt . Horizontal ) set_vertical ( self ) set slider orientation to vertical Source code in prettyqt/widgets/abstractslider.py 62 63 64 65 def set_vertical ( self ): \"\"\"set slider orientation to vertical \"\"\" self . setOrientation ( QtCore . Qt . Vertical ) abstractspinbox AbstractSpinBox get_button_symbols ( self ) returns button symbol type possible values are \"none\", \"up_down\", \"plus_minus\" Returns: Type Description str button symbol type Source code in prettyqt/widgets/abstractspinbox.py 43 44 45 46 47 48 49 50 51 def get_button_symbols ( self ) -> str : \"\"\"returns button symbol type possible values are \"none\", \"up_down\", \"plus_minus\" Returns: button symbol type \"\"\" return SYMBOLS . inv [ self . buttonSymbols ()] get_correction_mode ( self ) returns correction mode possible values are \"to_previous\", \"to_nearest\" Returns: Type Description str correction mode Source code in prettyqt/widgets/abstractspinbox.py 83 84 85 86 87 88 89 90 91 def get_correction_mode ( self ) -> str : \"\"\"returns correction mode possible values are \"to_previous\", \"to_nearest\" Returns: correction mode \"\"\" return CORRECTION_MODES . inv [ self . correctionMode ()] get_step_type ( self ) returns step type possible values are \"default\", \"adaptive\" Returns: Type Description str step type Source code in prettyqt/widgets/abstractspinbox.py 108 109 110 111 112 113 114 115 116 def get_step_type ( self ) -> str : \"\"\"returns step type possible values are \"default\", \"adaptive\" Returns: step type \"\"\" return STEP_TYPES . inv [ self . stepType ()] set_button_symbols ( self , mode ) sets button symbol type possible values are \"none\", \"up_down\", \"plus_minus\" Parameters: Name Type Description Default mode str button symbol type to use required Exceptions: Type Description ValueError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def set_button_symbols ( self , mode : str ): \"\"\"sets button symbol type possible values are \"none\", \"up_down\", \"plus_minus\" Args: mode: button symbol type to use Raises: ValueError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise ValueError ( \"Invalid button symbol type.\" ) self . setButtonSymbols ( SYMBOLS [ mode ]) set_correction_mode ( self , mode ) sets correction mode possible values are \"to_previous\", \"to_nearest\" Parameters: Name Type Description Default mode str correction mode to use required Exceptions: Type Description ValueError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def set_correction_mode ( self , mode : str ): \"\"\"sets correction mode possible values are \"to_previous\", \"to_nearest\" Args: mode: correction mode to use Raises: ValueError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise ValueError ( \"Invalid correction mode.\" ) self . setCorrectionMode ( CORRECTION_MODES [ mode ]) set_step_type ( self , mode ) sets step type possible values are \"default\", \"adaptive\" Parameters: Name Type Description Default mode str step type to use required Exceptions: Type Description ValueError invalid step type Source code in prettyqt/widgets/abstractspinbox.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def set_step_type ( self , mode : str ): \"\"\"sets step type possible values are \"default\", \"adaptive\" Args: mode: step type to use Raises: ValueError: invalid step type \"\"\" if mode not in STEP_TYPES : raise ValueError ( \"Invalid step type.\" ) self . setStepType ( STEP_TYPES [ mode ]) action Action get_priority ( self ) returns current priority Possible values: \"low\", \"normal\", \"high\" Returns: Type Description str priority Source code in prettyqt/widgets/action.py 122 123 124 125 126 127 128 129 130 def get_priority ( self ) -> str : \"\"\"returns current priority Possible values: \"low\", \"normal\", \"high\" Returns: priority \"\"\" return PRIORITIES . inv [ self . priority ()] get_shortcut_context ( self ) returns shortcut context Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: Type Description str shortcut context Source code in prettyqt/widgets/action.py 147 148 149 150 151 152 153 154 155 def get_shortcut_context ( self ) -> str : \"\"\"returns shortcut context Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: shortcut context \"\"\" return CONTEXTS . inv [ self . shortcutContext ()] set_icon ( self , icon ) set the icon for the action Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/action.py 91 92 93 94 95 96 97 98 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the action Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( icon ) set_priority ( self , priority ) set priority of the action Allowed values are \"low\", \"normal\", \"high\" Parameters: Name Type Description Default priority str priority for the action required Exceptions: Type Description ValueError priority does not exist Source code in prettyqt/widgets/action.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def set_priority ( self , priority : str ): \"\"\"set priority of the action Allowed values are \"low\", \"normal\", \"high\" Args: priority: priority for the action Raises: ValueError: priority does not exist \"\"\" if priority not in PRIORITIES : raise ValueError ( f \" { priority } not a valid priority.\" ) self . setPriority ( PRIORITIES [ priority ]) set_shortcut_context ( self , context ) set shortcut context Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Parameters: Name Type Description Default context str shortcut context required Exceptions: Type Description ValueError shortcut context does not exist Source code in prettyqt/widgets/action.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def set_shortcut_context ( self , context : str ): \"\"\"set shortcut context Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Args: context: shortcut context Raises: ValueError: shortcut context does not exist \"\"\" if context not in CONTEXTS : raise ValueError ( f \" { context } not a valid shortcut context.\" ) self . setShortcutContext ( CONTEXTS [ context ]) application Application copy_to_clipboard ( text ) classmethod Sets clipboard to supplied text Source code in prettyqt/widgets/application.py 73 74 75 76 77 78 79 80 @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\" Sets clipboard to supplied text \"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Clipboard ) cb . setText ( text , mode = cb . Clipboard ) set_icon ( self , icon ) set the default window icon Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/application.py 19 20 21 22 23 24 25 26 def set_icon ( self , icon : icons . IconType ): \"\"\"set the default window icon Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) calendarwidget CalendarWidget get_selection_mode ( self ) returns current selection mode Possible values: \"single\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/calendarwidget.py 65 66 67 68 69 70 71 72 73 def get_selection_mode ( self ) -> str : \"\"\"returns current selection mode Possible values: \"single\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()] set_selection_mode ( self , mode ) set selection mode for given calendar widget Allowed values are \"single\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description ValueError mode does not exist Source code in prettyqt/widgets/calendarwidget.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"set selection mode for given calendar widget Allowed values are \"single\" or \"none\" Args: mode: selection mode to use Raises: ValueError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise ValueError ( \"Format must be either 'single' or 'None'\" ) self . setSelectionMode ( SELECTION_MODES [ mode ]) checkbox CheckBox get_checkstate ( self ) returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description bool checkstate Source code in prettyqt/widgets/checkbox.py 79 80 81 82 83 84 85 86 87 def get_checkstate ( self ) -> bool : \"\"\"returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()] set_checkstate ( self , state ) set checkstate of the checkbox valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description ValueError invalid checkstate Source code in prettyqt/widgets/checkbox.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def set_checkstate ( self , state : str ): \"\"\"set checkstate of the checkbox valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: ValueError: invalid checkstate \"\"\" if state not in STATES : raise ValueError ( \"Invalid checkstate.\" ) self . setCheckState ( STATES [ state ]) combobox ComboBox get_insert_policy ( self ) returns insert policy possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: Type Description str insert policy Source code in prettyqt/widgets/combobox.py 130 131 132 133 134 135 136 137 138 139 def get_insert_policy ( self ) -> str : \"\"\"returns insert policy possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: insert policy \"\"\" return INSERT_POLICIES . inv [ self . insertPolicy ()] get_size_adjust_policy ( self ) returns size adjust policy possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/combobox.py 157 158 159 160 161 162 163 164 165 def get_size_adjust_policy ( self ) -> str : \"\"\"returns size adjust policy possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()] set_insert_policy ( self , policy ) set insert policy valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Parameters: Name Type Description Default policy str insert policy to use required Exceptions: Type Description ValueError invalid insert policy Source code in prettyqt/widgets/combobox.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def set_insert_policy ( self , policy : str ): \"\"\"set insert policy valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Args: policy: insert policy to use Raises: ValueError: invalid insert policy \"\"\" if policy not in INSERT_POLICIES : raise ValueError ( \"Policy not available\" ) policy = INSERT_POLICIES . get ( policy ) self . setInsertPolicy ( policy ) set_size_adjust_policy ( self , policy ) set size adjust policy possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description ValueError invalid size adjust policy Source code in prettyqt/widgets/combobox.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def set_size_adjust_policy ( self , policy : str ): \"\"\"set size adjust policy possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Args: policy: size adjust policy to use Raises: ValueError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise ValueError ( \"Policy not available\" ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy ) dialog BaseDialog keyPressEvent ( self , e ) keyPressEvent(self, QKeyEvent) Source code in prettyqt/widgets/dialog.py 43 44 45 46 47 48 49 def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e ) dialogbuttonbox DialogButtonBox add_button ( self , button , role = 'accept' , callback = None ) add a button Parameters: Name Type Description Default button Union[PyQt5.QtWidgets.QPushButton, str] button to add required role str role of the button 'accept' callback Optional[Callable] function to call when button gets clicked None Returns: Type Description PushButton created button Exceptions: Type Description ValueError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def add_button ( self , button : Union [ QtWidgets . QPushButton , str ], role : str = \"accept\" , callback : Optional [ Callable ] = None , ) -> widgets . PushButton : \"\"\"add a button Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: ValueError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button add_default_button ( self , button , callback = None ) add a default button Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required callback Optional[Callable] function to call when button gets clicked None Returns: Type Description QPushButton created button Exceptions: Type Description ValueError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def add_default_button ( self , button : str , callback : Optional [ Callable ] = None ) -> QtWidgets . QPushButton : \"\"\"add a default button Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: ValueError: Button type not available \"\"\" if button not in BUTTONS : raise ValueError ( \"button type not available\" ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn create ( ** kwargs ) classmethod create(self, window: sip.voidptr = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) Source code in prettyqt/widgets/dialogbuttonbox.py 73 74 75 76 77 78 @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) return box get_orientation ( self ) returns current orientation Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/dialogbuttonbox.py 104 105 106 107 108 109 110 111 112 def get_orientation ( self ) -> str : \"\"\"returns current orientation Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()] set_orientation ( self , orientation ) set the orientation of the button box Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the button box required Exceptions: Type Description ValueError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def set_orientation ( self , orientation : str ): \"\"\"set the orientation of the button box Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the button box Raises: ValueError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise ValueError ( f \" { orientation } not a valid orientation.\" ) self . setOrientation ( ORIENTATIONS [ orientation ]) dockwidget DockWidget Customized DockWidget class contains a custom TitleBar with maximise button filedialog FileDialog simple dialog used to display some widget directory ( self ) return current directory returns current directory level as a Pathlib object Returns: Type Description Path Pathlib object Source code in prettyqt/widgets/filedialog.py 230 231 232 233 234 235 236 237 238 def directory ( self ) -> pathlib . Path : \"\"\"return current directory returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( super () . directory ()) get_accept_mode ( self ) returns accept mode possible values are \"save\", \"open\" Returns: Type Description str accept mode Source code in prettyqt/widgets/filedialog.py 106 107 108 109 110 111 112 113 114 def get_accept_mode ( self ) -> str : \"\"\"returns accept mode possible values are \"save\", \"open\" Returns: accept mode \"\"\" return ACCEPT_MODES . inv [ self . acceptMode ()] get_file_mode ( self ) returns file mode possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: Type Description str file mode Source code in prettyqt/widgets/filedialog.py 165 166 167 168 169 170 171 172 173 def get_file_mode ( self ) -> str : \"\"\"returns file mode possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: file mode \"\"\" return MODES . inv [ self . fileMode ()] get_label_text ( self , label ) returns label text possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py 155 156 157 158 159 160 161 162 163 def get_label_text ( self , label ) -> str : \"\"\"returns label text possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: label text \"\"\" return self . labelText ( LABELS . inv [ label ]) get_view_mode ( self ) returns view mode possible values are \"detail\", \"list\" Returns: Type Description str view mode Source code in prettyqt/widgets/filedialog.py 131 132 133 134 135 136 137 138 139 def get_view_mode ( self ) -> str : \"\"\"returns view mode possible values are \"detail\", \"list\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()] set_accept_mode ( self , mode ) set accept mode possible values are \"save\", \"open\" Parameters: Name Type Description Default mode str accept mode to use required Exceptions: Type Description ValueError invalid accept mode Source code in prettyqt/widgets/filedialog.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def set_accept_mode ( self , mode : str ): \"\"\"set accept mode possible values are \"save\", \"open\" Args: mode: accept mode to use Raises: ValueError: invalid accept mode \"\"\" if mode not in ACCEPT_MODES : raise ValueError ( f \"Invalid value. Valid values: { ACCEPT_MODES . keys () } \" ) self . setAcceptMode ( ACCEPT_MODES [ mode ]) set_directory ( self , path ) set start directory Source code in prettyqt/widgets/filedialog.py 240 241 242 243 244 245 def set_directory ( self , path : Union [ None , str , pathlib . Path ]): \"\"\"set start directory \"\"\" if isinstance ( path , pathlib . Path ): path = str ( path ) self . setDirectory ( path ) set_extension_filter ( self , extension_dict ) set filter based on given dictionary dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict dict filter dictionary required Source code in prettyqt/widgets/filedialog.py 216 217 218 219 220 221 222 223 224 225 226 227 228 def set_extension_filter ( self , extension_dict : dict ): \"\"\"set filter based on given dictionary dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str ) set_file_mode ( self , mode ) sets the file mode of the dialog allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Parameters: Name Type Description Default mode str mode to use required Source code in prettyqt/widgets/filedialog.py 175 176 177 178 179 180 181 182 183 def set_file_mode ( self , mode : str ): \"\"\"sets the file mode of the dialog allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Args: mode: mode to use \"\"\" self . setFileMode ( MODES [ mode ]) set_label_text ( self , label , text ) sets the label text for button label possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Parameters: Name Type Description Default label str button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py 141 142 143 144 145 146 147 148 149 150 151 152 153 def set_label_text ( self , label : str , text : str ): \"\"\"sets the label text for button label possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Args: label: button to set text for text: text to use \"\"\" if label not in LABELS : raise ValueError ( f \"Invalid value. Valid values: { LABELS . keys () } \" ) self . setLabelText ( LABELS [ label ], text ) set_view_mode ( self , mode ) set view mode possible values are \"detail\", \"list\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description ValueError invalid view mode Source code in prettyqt/widgets/filedialog.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def set_view_mode ( self , mode : str ): \"\"\"set view mode possible values are \"detail\", \"list\" Args: mode: view mode to use Raises: ValueError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise ValueError ( f \"Invalid value. Valid values: { VIEW_MODES . keys () } \" ) self . setViewMode ( VIEW_MODES [ mode ]) filesystemmodel FileSystemModel Class to populate a filesystem treeview data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/widgets/filesystemmodel.py 53 54 55 56 57 def data ( self , index , role = QtCore . Qt . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role ) formlayout FormLayout __len__ ( self ) special needed for PySide2 Source code in prettyqt/widgets/formlayout.py 39 40 41 42 def __len__ ( self ): \"\"\"needed for PySide2 \"\"\" return self . rowCount () frame Frame get_frame_style ( self ) returns current frame style Possible values: \"plain\", \"raised\", \"sunken\" Returns: Type Description str frame style Source code in prettyqt/widgets/frame.py 46 47 48 49 50 51 52 53 54 def get_frame_style ( self ) -> str : \"\"\"returns current frame style Possible values: \"plain\", \"raised\", \"sunken\" Returns: frame style \"\"\" return SHADOWS . inv [ self . frameStyle ()] set_frame_style ( self , style ) set frame style Allowed values are \"plain\", \"raised\", \"sunken\" Parameters: Name Type Description Default style str frame style to use required Exceptions: Type Description ValueError style does not exist Source code in prettyqt/widgets/frame.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def set_frame_style ( self , style : str ): \"\"\"set frame style Allowed values are \"plain\", \"raised\", \"sunken\" Args: style: frame style to use Raises: ValueError: style does not exist \"\"\" if style not in SHADOWS : raise ValueError ( \"invalid frame style\" ) self . setFrameStyle ( SHADOWS [ style ]) groupbox GroupBox GroupBox widget A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets. headerview HeaderView contextMenuEvent ( self , event ) context menu for our files tree Source code in prettyqt/widgets/headerview.py 71 72 73 74 75 76 77 78 79 80 81 82 83 def contextMenuEvent ( self , event ): \"\"\" context menu for our files tree \"\"\" menu = widgets . Menu ( parent = self ) for i , header_label in enumerate ( self . section_labels ()[ 1 :], start = 1 ): act = menu . addAction ( header_label ) act . setCheckable ( True ) val = not self . isSectionHidden ( i ) act . setChecked ( val ) fn = functools . partial ( self . set_section_hidden , i = i , hide = val ) act . triggered . connect ( fn ) menu . exec_ ( self . mapToGlobal ( event . pos ())) label Label get_text_format ( self ) returns current text format Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/label.py 124 125 126 127 128 129 130 131 132 def get_text_format ( self ) -> str : \"\"\"returns current text format Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()] get_text_interaction ( self ) returns current text interaction mode Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: Type Description List[str] list of text interaction modes Source code in prettyqt/widgets/label.py 152 153 154 155 156 157 158 159 160 def get_text_interaction ( self ) -> List [ str ]: \"\"\"returns current text interaction mode Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()] set_text_format ( self , text_format ) set the text format Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description ValueError text format does not exist Source code in prettyqt/widgets/label.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def set_text_format ( self , text_format : str ): \"\"\"set the text format Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: ValueError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise ValueError ( \"Invalid text format\" ) self . setTextFormat ( TEXT_FORMATS [ text_format ]) return self set_text_interaction ( self , * types ) set the text interaction mode Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Parameters: Name Type Description Default types str text interaction mode to use () Exceptions: Type Description ValueError text interaction mode does not exist Source code in prettyqt/widgets/label.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def set_text_interaction ( self , * types : str ): \"\"\"set the text interaction mode Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Args: types: text interaction mode to use Raises: ValueError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise ValueError ( \"Invalid text interaction mode\" ) flags = functools . reduce ( operator . ior , [ TEXT_INTERACTION [ t ] for t in types ]) self . setTextInteractionFlags ( flags ) return self set_weight ( self , weight ) sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description ValueError invalid font weight Source code in prettyqt/widgets/label.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def set_weight ( self , weight : str ): \"\"\"sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: ValueError: invalid font weight \"\"\" if weight not in WEIGHTS : raise ValueError ( f \"Invalid weight ' { weight } '\" ) font = self . font () font . setWeight ( WEIGHTS [ weight ]) self . setFont ( font ) return self layout Layout get_size_mode ( self ) returns current size mode Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: Type Description str size mode Source code in prettyqt/widgets/layout.py 75 76 77 78 79 80 81 82 83 def get_size_mode ( self ) -> str : \"\"\"returns current size mode Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: size mode \"\"\" return MODES . inv [ self . sizeConstraint ()] set_alignment ( self , alignment , item = None ) Sets the alignment for widget / layout to alignment and returns true if w is found in this layout (not including child layouts) Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required item set alignment for specific child only None Exceptions: Type Description ValueError alignment does not exist Source code in prettyqt/widgets/layout.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def set_alignment ( self , alignment : str , item = None ): \"\"\"Sets the alignment for widget / layout to alignment and returns true if w is found in this layout (not including child layouts) Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout item: set alignment for specific child only Raises: ValueError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise ValueError ( f \" { alignment !r} not a valid alignment.\" ) if item is not None : return self . setAlignment ( item , ALIGNMENTS [ alignment ]) else : return self . setAlignment ( ALIGNMENTS [ alignment ]) set_size_mode ( self , mode ) set the size mode of the layout Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Parameters: Name Type Description Default mode str size mode for the layout required Exceptions: Type Description ValueError size mode does not exist Source code in prettyqt/widgets/layout.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def set_size_mode ( self , mode : str ): \"\"\"set the size mode of the layout Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Args: mode: size mode for the layout Raises: ValueError: size mode does not exist \"\"\" if mode not in MODES : raise ValueError ( f \" { mode } not a valid size mode.\" ) self . setSizeConstraint ( MODES [ mode ]) lineedit LineEdit font ( self ) font(self) -> QFont Source code in prettyqt/widgets/lineedit.py 69 70 def font ( self ) -> gui . Font : return gui . Font ( super () . font ()) get_echo_mode ( self ) returns echo mode possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: Type Description str echo mode Source code in prettyqt/widgets/lineedit.py 123 124 125 126 127 128 129 130 131 def get_echo_mode ( self ) -> str : \"\"\"returns echo mode possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: echo mode \"\"\" return ECHO_MODES . inv [ self . echoMode ()] set_echo_mode ( self , mode ) set echo mode Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Parameters: Name Type Description Default mode str echo mode to use required Exceptions: Type Description ValueError invalid echo mode Source code in prettyqt/widgets/lineedit.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def set_echo_mode ( self , mode : str ): \"\"\"set echo mode Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Args: mode: echo mode to use Raises: ValueError: invalid echo mode \"\"\" if mode not in ECHO_MODES : raise ValueError ( \"Invalid echo mode\" ) self . setEchoMode ( ECHO_MODES [ mode ]) set_read_only ( self , value = True ) set test to read only Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py 78 79 80 81 82 83 84 def set_read_only ( self , value : bool = True ): \"\"\"set test to read only Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) listview ListView get_view_mode ( self ) returns view mode possible values are \"list\", \"icon\" Returns: Type Description str view mode Source code in prettyqt/widgets/listview.py 33 34 35 36 37 38 39 40 41 def get_view_mode ( self ) -> str : \"\"\"returns view mode possible values are \"list\", \"icon\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()] set_view_mode ( self , mode ) set view mode possible values are \"list\", \"icon\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description ValueError invalid view mode Source code in prettyqt/widgets/listview.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def set_view_mode ( self , mode : str ): \"\"\"set view mode possible values are \"list\", \"icon\" Args: mode: view mode to use Raises: ValueError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise ValueError ( f \"Invalid value. Valid values: { VIEW_MODES . keys () } \" ) self . setViewMode ( VIEW_MODES [ mode ]) listwidgetitem ListWidgetItem get_checkstate ( self ) returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/listwidgetitem.py 65 66 67 68 69 70 71 72 73 def get_checkstate ( self ) -> str : \"\"\"returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()] set_checkstate ( self , state ) set checkstate of the checkbox valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description ValueError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def set_checkstate ( self , state : str ): \"\"\"set checkstate of the checkbox valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: ValueError: invalid checkstate \"\"\" if state not in STATES : raise ValueError ( \"Invalid checkstate.\" ) self . setCheckState ( STATES [ state ]) set_icon ( self , icon ) set the icon for the action Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/listwidgetitem.py 41 42 43 44 45 46 47 48 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the action Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( icon ) mainwindow MainWindow Class for our mainWindow includes all docks, a centralwidget and a toolbar add_toolbar ( self , toolbar , position = 'top' ) adds a toolbar to the mainmenu at specified area Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default toolbar toolbar to use required position str position of the toolbar 'top' Exceptions: Type Description ValueError position does not exist Source code in prettyqt/widgets/mainwindow.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def add_toolbar ( self , toolbar , position : str = \"top\" ): \"\"\"adds a toolbar to the mainmenu at specified area Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: toolbar: toolbar to use position: position of the toolbar Raises: ValueError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise ValueError ( \"Position not existing\" ) self . addToolBar ( TOOLBAR_AREAS [ position ], toolbar ) add_toolbar_break ( self , position = 'top' ) Adds a toolbar break to the given area after all the other objects that are present. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default position str position of the toolbar 'top' Exceptions: Type Description ValueError position does not exist Source code in prettyqt/widgets/mainwindow.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def add_toolbar_break ( self , position : str = \"top\" ): \"\"\"Adds a toolbar break to the given area after all the other objects that are present. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: position: position of the toolbar Raises: ValueError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise ValueError ( \"Position not existing\" ) self . addToolBarBreak ( TOOLBAR_AREAS [ position ]) createPopupMenu ( self ) createPopupMenu(self) -> QMenu Source code in prettyqt/widgets/mainwindow.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def createPopupMenu ( self ): # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add_action ( action ) menu . add_separator () for i in self . get_toolbars (): action = widgets . Action ( text = i . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( i . setVisible ) action . set_checked ( i . isVisible ()) menu . add_action ( action ) return menu save_window_state ( self , recursive = False ) override, gets executed when app gets closed. saves GUI settings Source code in prettyqt/widgets/mainwindow.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def save_window_state ( self , recursive = False ): \"\"\" override, gets executed when app gets closed. saves GUI settings \"\"\" settings = core . Settings () name = self . get_id () logging . debug ( f \"Saving window state for { name } ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state () toggle_fullscreen ( self ) toggle between fullscreen and regular size Source code in prettyqt/widgets/mainwindow.py 187 188 189 190 191 192 193 def toggle_fullscreen ( self ): \"\"\"toggle between fullscreen and regular size \"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen () mdiarea MdiArea get_tab_position ( self ) returns current tab position Possible values: \"north\", \"south\", \"west\", \"east\" Returns: Type Description str tab position Source code in prettyqt/widgets/mdiarea.py 107 108 109 110 111 112 113 114 115 def get_tab_position ( self ) -> str : \"\"\"returns current tab position Possible values: \"north\", \"south\", \"west\", \"east\" Returns: tab position \"\"\" return TAB_POSITIONS . inv [ self . tabPosition ()] get_view_mode ( self ) returns current view mode Possible values: \"default\", \"tabbed\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py 57 58 59 60 61 62 63 64 65 def get_view_mode ( self ) -> str : \"\"\"returns current view mode Possible values: \"default\", \"tabbed\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()] get_window_order ( self ) returns current window order Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py 82 83 84 85 86 87 88 89 90 def get_window_order ( self ) -> str : \"\"\"returns current window order Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: view mode \"\"\" return WINDOW_ORDERS . inv [ self . activationOrder ()] set_tab_position ( self , position ) set tab position for the MDI area Valid values are \"north\", \"south\", \"west\", \"east\" Parameters: Name Type Description Default position str tabs position to use required Exceptions: Type Description ValueError tab position does not exist Source code in prettyqt/widgets/mdiarea.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def set_tab_position ( self , position : str ): \"\"\"set tab position for the MDI area Valid values are \"north\", \"south\", \"west\", \"east\" Args: position: tabs position to use Raises: ValueError: tab position does not exist \"\"\" if position not in TAB_POSITIONS : raise ValueError ( \"Invalid value for tab position.\" ) self . setTabPosition ( TAB_POSITIONS [ position ]) set_view_mode ( self , mode ) set view mode for the MDI area Valid values are \"default\", \"tabbed\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description ValueError view mode does not exist Source code in prettyqt/widgets/mdiarea.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def set_view_mode ( self , mode : str ): \"\"\"set view mode for the MDI area Valid values are \"default\", \"tabbed\" Args: mode: view mode to use Raises: ValueError: view mode does not exist \"\"\" if mode not in VIEW_MODES : raise ValueError ( \"Invalid value for mode.\" ) self . setViewMode ( VIEW_MODES [ mode ]) set_window_order ( self , mode ) set the window order behaviour for the MDI area Valid values are \"creation\", \"stacking\", \"activation_history\" Parameters: Name Type Description Default mode str window order behaviour to use required Exceptions: Type Description ValueError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def set_window_order ( self , mode : str ): \"\"\"set the window order behaviour for the MDI area Valid values are \"creation\", \"stacking\", \"activation_history\" Args: mode: window order behaviour to use Raises: ValueError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDERS : raise ValueError ( \"Invalid value for mode.\" ) self . setActivationOrder ( WINDOW_ORDERS [ mode ]) menu Menu add_action ( self , label , callback = None , icon = None , checkable = False , checked = False , shortcut = None , status_tip = None ) Add an action to the menu Parameters: Name Type Description Default label Union[str, prettyqt.widgets.action.Action] Label for button required callback Callable gets called when action is triggered None icon Optional[Any] icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut Optional[str] Shortcut for action None status_tip Optional[str] Status tip to be shown in status bar None Returns: Type Description Action Action added to menu Source code in prettyqt/widgets/menu.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def add_action ( self , label : Union [ str , widgets . Action ], callback : Callable = None , icon : Optional [ Any ] = None , checkable : bool = False , checked : bool = False , shortcut : Optional [ str ] = None , status_tip : Optional [ str ] = None , ) -> widgets . Action : \"\"\"Add an action to the menu Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action add_separator ( self , text = None ) adds a separator showing an optional label Parameters: Name Type Description Default text Optional[str] Text to show on separator None Returns: Type Description WidgetAction Separator action Source code in prettyqt/widgets/menu.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def add_separator ( self , text : Optional [ str ] = None ) -> widgets . WidgetAction : \"\"\"adds a separator showing an optional label Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) label . setStyleSheet ( \"background:lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator = widgets . WidgetAction ( parent = self ) separator . setDefaultWidget ( label ) self . add ( separator ) return separator set_icon ( self , icon ) set the icon for the menu Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/menu.py 44 45 46 47 48 49 50 51 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the menu Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( icon ) messagebox MessageBox add_button ( self , button ) add a default button Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required Returns: Type Description QPushButton created button Exceptions: Type Description ValueError Button type not available Source code in prettyqt/widgets/messagebox.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def add_button ( self , button : str ) -> QtWidgets . QPushButton : \"\"\"add a default button Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add Returns: created button Raises: ValueError: Button type not available \"\"\" if button not in BUTTONS : raise ValueError ( \"button type not available\" ) return self . addButton ( BUTTONS [ button ]) get_text_format ( self ) returns current text format Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/messagebox.py 134 135 136 137 138 139 140 141 142 def get_text_format ( self ) -> str : \"\"\"returns current text format Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()] set_icon ( self , icon ) set the window icon Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/messagebox.py 79 80 81 82 83 84 def set_icon ( self , icon : icons . IconType ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) return None icon = icons . get_icon ( icon ) self . setIconPixmap ( icon . get_pixmap ( size = 64 )) set_text_format ( self , text_format ) set the text format Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description ValueError text format does not exist Source code in prettyqt/widgets/messagebox.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def set_text_format ( self , text_format : str ): \"\"\"set the text format Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: ValueError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise ValueError ( \"Invalid text format\" ) self . setTextFormat ( TEXT_FORMATS [ text_format ]) plaintextedit PlainTextEdit set_line_wrap_mode ( self , mode ) set line wrap mode Allowed values are \"none\" and \"widget width\" Parameters: Name Type Description Default mode str line wrap mode to use required Exceptions: Type Description ValueError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def set_line_wrap_mode ( self , mode : str ): \"\"\"set line wrap mode Allowed values are \"none\" and \"widget width\" Args: mode: line wrap mode to use Raises: ValueError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODES : raise ValueError ( f \"invalid wrap mode. \" f \"Allowed values: { LINE_WRAP_MODES . keys () } \" ) self . setLineWrapMode ( LINE_WRAP_MODES [ mode ]) set_read_only ( self , value = True ) make the PlainTextEdit read-only Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py 101 102 103 104 105 106 107 def set_read_only ( self , value : bool = True ): \"\"\"make the PlainTextEdit read-only Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) set_wrap_mode ( self , mode ) set word wrap mode Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Parameters: Name Type Description Default mode str word wrap mode to use required Exceptions: Type Description ValueError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def set_wrap_mode ( self , mode : str ): \"\"\"set word wrap mode Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Args: mode: word wrap mode to use Raises: ValueError: wrap mode does not exist \"\"\" if mode not in WRAP_MODES : raise ValueError ( f \"invalid wrap mode. Allowed values: { WRAP_MODES . keys () } \" ) self . setWordWrapMode ( WRAP_MODES [ mode ]) progressbar ProgressBar Progress dialog wrapper for QtWidgets.QProgressBar get_alignment ( self ) returns current alignment Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description str alignment Source code in prettyqt/widgets/progressbar.py 52 53 54 55 56 57 58 59 60 def get_alignment ( self ) -> str : \"\"\"returns current alignment Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" return ALIGNMENTS . inv [ self . alignment ()] get_text_direction ( self ) returns current text direction Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Type Description str Text direction Source code in prettyqt/widgets/progressbar.py 77 78 79 80 81 82 83 84 85 def get_text_direction ( self ) -> str : \"\"\"returns current text direction Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inv [ self . textDirection ()] set_alignment ( self , alignment ) set the alignment of the layout Allowed values are \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required Exceptions: Type Description ValueError alignment does not exist Source code in prettyqt/widgets/progressbar.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def set_alignment ( self , alignment : str ): \"\"\"set the alignment of the layout Allowed values are \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout Raises: ValueError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise ValueError ( f \" { alignment !r} not a valid alignment.\" ) self . setAlignment ( ALIGNMENTS [ alignment ]) set_text_direction ( self , text_direction ) set the text direction of the layout Allowed values are \"top_to_bottom\", \"bottom_to_top\" Parameters: Name Type Description Default text_direction str text direction for the layout required Exceptions: Type Description ValueError text direction does not exist Source code in prettyqt/widgets/progressbar.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def set_text_direction ( self , text_direction : str ): \"\"\"set the text direction of the layout Allowed values are \"top_to_bottom\", \"bottom_to_top\" Args: text_direction: text direction for the layout Raises: ValueError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise ValueError ( f \" { text_direction !r} not a valid text direction.\" ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ]) progressdialog ProgressDialog Progress dialog wrapper for QtWidgets.QProgressDialog sizepolicy SizePolicy get_control_type ( self ) returns control type possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: Type Description str control type Source code in prettyqt/widgets/sizepolicy.py 108 109 110 111 112 113 114 115 116 117 118 def get_control_type ( self ) -> str : \"\"\"returns control type possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: control type \"\"\" return CONTROL_TYPES . inv [ self . controlType ()] get_horizontal_policy ( self ) returns size policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str horizontal size policy Source code in prettyqt/widgets/sizepolicy.py 64 65 66 67 68 69 70 71 72 73 def get_horizontal_policy ( self ) -> str : \"\"\"returns size policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: horizontal size policy \"\"\" return SIZE_POLICIES . inv [ self . horizontalPolicy ()] get_vertical_policy ( self ) returns size policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str vertical size policy Source code in prettyqt/widgets/sizepolicy.py 86 87 88 89 90 91 92 93 94 95 def get_vertical_policy ( self ) -> str : \"\"\"returns size policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: vertical size policy \"\"\" return SIZE_POLICIES . inv [ self . verticalPolicy ()] set_control_type ( self , mode ) sets the control type possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Parameters: Name Type Description Default mode str control type to set required Source code in prettyqt/widgets/sizepolicy.py 120 121 122 123 124 125 126 127 128 129 130 def set_control_type ( self , mode : str ): \"\"\"sets the control type possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Args: mode: control type to set \"\"\" self . setControlType ( CONTROL_TYPES [ mode ]) set_horizontal_policy ( self , mode ) sets the horizontal policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py 75 76 77 78 79 80 81 82 83 84 def set_horizontal_policy ( self , mode : str ): \"\"\"sets the horizontal policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setHorizontalPolicy ( SIZE_POLICIES [ mode ]) set_vertical_policy ( self , mode ) sets the horizontal policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py 97 98 99 100 101 102 103 104 105 106 def set_vertical_policy ( self , mode : str ): \"\"\"sets the horizontal policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setVerticalPolicy ( SIZE_POLICIES [ mode ]) slider Slider get_tick_position ( self ) returns tick position possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: Type Description str tick position Source code in prettyqt/widgets/slider.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_tick_position ( self ) -> str : \"\"\"returns tick position possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: tick position \"\"\" val = TICK_POSITIONS . inv [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\" return val set_tick_position ( self , position ) sets the tick position for the slider allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Parameters: Name Type Description Default position str position for the ticks required Source code in prettyqt/widgets/slider.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def set_tick_position ( self , position : str ): \"\"\"sets the tick position for the slider allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITIONS : raise ValueError ( f \" { position } not a valid tick position.\" ) self . setTickPosition ( TICK_POSITIONS [ position ]) splitter Splitter get_orientation ( self ) returns current orientation Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/splitter.py 99 100 101 102 103 104 105 106 107 def get_orientation ( self ) -> str : \"\"\"returns current orientation Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()] set_orientation ( self , orientation ) set the orientation of the splitter Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description ValueError orientation does not exist Source code in prettyqt/widgets/splitter.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def set_orientation ( self , orientation : str ): \"\"\"set the orientation of the splitter Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: ValueError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise ValueError ( f \" { orientation } not a valid orientation.\" ) self . setOrientation ( ORIENTATIONS [ orientation ]) styleoptionslider StyleOptionSlider is_horizontal ( self ) check if silder is horizontal Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py 29 30 31 32 33 34 35 def is_horizontal ( self ) -> bool : \"\"\"check if silder is horizontal Returns: True if horizontal, else False \"\"\" return self . orientation == QtCore . Qt . Horizontal is_vertical ( self ) check if silder is vertical Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py 37 38 39 40 41 42 43 def is_vertical ( self ) -> bool : \"\"\"check if silder is vertical Returns: True if vertical, else False \"\"\" return self . orientation == QtCore . Qt . Vertical set_horizontal ( self ) set slider orientation to horizontal Source code in prettyqt/widgets/styleoptionslider.py 45 46 47 48 def set_horizontal ( self ): \"\"\"set slider orientation to horizontal \"\"\" self . orientation = QtCore . Qt . Horizontal set_vertical ( self ) set slider orientation to vertical Source code in prettyqt/widgets/styleoptionslider.py 50 51 52 53 def set_vertical ( self ): \"\"\"set slider orientation to vertical \"\"\" self . orientation = QtCore . Qt . Vertical tabbar TabBar get_elide_mode ( self ) returns elide mode possible values are \"left\", \"right\", \"middle\", \"none\" Returns: Type Description str elide mode Source code in prettyqt/widgets/tabbar.py 133 134 135 136 137 138 139 140 141 def get_elide_mode ( self ) -> str : \"\"\"returns elide mode possible values are \"left\", \"right\", \"middle\", \"none\" Returns: elide mode \"\"\" return ELIDE_MODES . inv [ self . elideMode ()] get_remove_behaviour ( self ) returns remove behaviour possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: Type Description str remove behaviour Source code in prettyqt/widgets/tabbar.py 108 109 110 111 112 113 114 115 116 def get_remove_behaviour ( self ) -> str : \"\"\"returns remove behaviour possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOURS . inv [ self . selectionBehaviorOnRemove ()] mouseDoubleClickEvent ( self , event ) mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/widgets/tabbar.py 80 81 82 def mouseDoubleClickEvent ( self , event ): event . accept () self . on_detach . emit ( self . tabAt ( event . pos ()), self . mouse_cursor . pos ()) set_elide_mode ( self , mode ) set elide mode Valid values are \"left\", \"right\", \"middle\", \"none\" Parameters: Name Type Description Default mode str elide mode to use required Exceptions: Type Description ValueError invalid elide mode Source code in prettyqt/widgets/tabbar.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def set_elide_mode ( self , mode : str ): \"\"\"set elide mode Valid values are \"left\", \"right\", \"middle\", \"none\" Args: mode: elide mode to use Raises: ValueError: invalid elide mode \"\"\" if mode not in ELIDE_MODES : raise ValueError ( \"Mode not available\" ) self . setElideMode ( ELIDE_MODES [ mode ]) set_icon_size ( self , size ) Set the icon size for the tabs Parameters: Name Type Description Default size int height/width of the icons required Source code in prettyqt/widgets/tabbar.py 84 85 86 87 88 89 90 def set_icon_size ( self , size : int ): \"\"\"Set the icon size for the tabs Args: size: height/width of the icons \"\"\" self . setIconSize ( QtCore . QSize ( size , size )) set_remove_behaviour ( self , mode ) sets the remove hehaviour What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Parameters: Name Type Description Default mode str new remove behaviour required Source code in prettyqt/widgets/tabbar.py 95 96 97 98 99 100 101 102 103 104 105 106 def set_remove_behaviour ( self , mode : str ): \"\"\"sets the remove hehaviour What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOURS : raise ValueError ( \"Mode not available\" ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOURS [ mode ]) tabwidget DetachedTab window containing a detached tab When a tab is detached , the contents are placed into this QMainWindow . The tab can be re - attached by closing the dialog !!! attributes on_close : signal , emitted when window is closed ( widget , title , icon ) closeEvent ( self , event ) closeEvent(self, QCloseEvent) Source code in prettyqt/widgets/tabwidget.py 258 259 def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . id , self . windowIcon ()) TabWidget Widget for managing the tabs section attach_tab ( self , widget , name , icon = None , insert_at = None ) Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget @param widget the content widget from the DetachedTab window @param name the name of the detached tab @param icon the window icon for the detached tab @param insert_at insert the re-attached tab at the given index Source code in prettyqt/widgets/tabwidget.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def attach_tab ( self , widget , name : str , icon : icons . IconType = None , insert_at : Optional [ int ] = None , ): \"\"\" Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget @param widget the content widget from the DetachedTab window @param name the name of the detached tab @param icon the window icon for the detached tab @param insert_at insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True ) close_detached_tabs ( self ) Close all tabs that are currently detached Source code in prettyqt/widgets/tabwidget.py 210 211 212 213 214 def close_detached_tabs ( self ): \"\"\"Close all tabs that are currently detached \"\"\" for detached_tab in self . detached_tabs . values (): detached_tab . close () detach_tab ( self , index , point ) Detach the tab by removing it's contents and placing them in a DetachedTab window @param index index location of the tab to be detached @param point screen pos for creating the new DetachedTab window Source code in prettyqt/widgets/tabwidget.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 @core . Slot ( int , QtCore . QPoint ) def detach_tab ( self , index : int , point : QtCore . QPoint ): \"\"\" Detach the tab by removing it's contents and placing them in a DetachedTab window @param index index location of the tab to be detached @param point screen pos for creating the new DetachedTab window \"\"\" # Get the tab content name = self . tabText ( index ) icon = self . tabIcon ( index ) if icon . isNull (): icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab get_tab_shape ( self ) returns tab shape possible values are \"roundes\", \"triangular\" Returns: Type Description str tab shape Source code in prettyqt/widgets/tabwidget.py 94 95 96 97 98 99 100 101 102 def get_tab_shape ( self ) -> str : \"\"\"returns tab shape possible values are \"roundes\", \"triangular\" Returns: tab shape \"\"\" return TAB_SHAPES . inv [ self . tabShape ()] open_widget ( self , widget , title = 'Unnamed' ) create a tab containing delivered widget Source code in prettyqt/widgets/tabwidget.py 223 224 225 226 227 228 @core . Slot ( object , str ) def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\" create a tab containing delivered widget \"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True ) set_tab_shape ( self , shape ) set tab shape for the tabwidget Valid values are \"rounded\" and \"triangular\" Parameters: Name Type Description Default shape str tab shape to use required Exceptions: Type Description ValueError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def set_tab_shape ( self , shape : str ): \"\"\"set tab shape for the tabwidget Valid values are \"rounded\" and \"triangular\" Args: shape: tab shape to use Raises: ValueError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise ValueError ( \"Invalid value for shape.\" ) self . setTabShape ( TAB_SHAPES [ shape ]) toolbar ToolBar add_separator ( self , text = None , before = None ) adds a separator showing an optional label Parameters: Name Type Description Default text Optional[str] Text to show on separator None before QAction insert separator before specific action None Returns: Type Description QAction Separator action Source code in prettyqt/widgets/toolbar.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def add_separator ( self , text : Optional [ str ] = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"adds a separator showing an optional label Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) label . setStyleSheet ( \"background:lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label ) get_style ( self ) returns current style Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: Type Description str style Source code in prettyqt/widgets/toolbar.py 84 85 86 87 88 89 90 91 92 def get_style ( self ) -> str : \"\"\"returns current style Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: style \"\"\" return STYLES . inv [ self . toolButtonStyle ()] is_area_allowed ( self , area ) check if toolbar is allowed at specified area Valid values for area: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default area str area of the toolbar required Exceptions: Type Description ValueError area does not exist Source code in prettyqt/widgets/toolbar.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def is_area_allowed ( self , area : str ): \"\"\"check if toolbar is allowed at specified area Valid values for area: \"left\", \"right\", \"top\", \"bottom\" Args: area: area of the toolbar Raises: ValueError: area does not exist \"\"\" if area not in TOOLBAR_AREAS : raise ValueError ( \"Area not existing\" ) return self . isAreaAllowed ( TOOLBAR_AREAS [ area ]) toolbutton ToolButton get_arrow_type ( self ) returns arrow type possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: Type Description str arrow type Source code in prettyqt/widgets/toolbutton.py 91 92 93 94 95 96 97 98 99 def get_arrow_type ( self ) -> str : \"\"\"returns arrow type possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: arrow type \"\"\" return ARROW_TYPES . inv [ self . arrowType ()] get_popup_mode ( self ) returns popup mode possible values are \"delayed\", \"menu_button\", \"instant\" Returns: Type Description str popup mode Source code in prettyqt/widgets/toolbutton.py 66 67 68 69 70 71 72 73 74 def get_popup_mode ( self ) -> str : \"\"\"returns popup mode possible values are \"delayed\", \"menu_button\", \"instant\" Returns: popup mode \"\"\" return POPUP_MODES . inv [ self . popupMode ()] set_arrow_type ( self , mode ) sets the arrow type of the toolbutton valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Parameters: Name Type Description Default mode str arrow type to use required Exceptions: Type Description ValueError invalid arrow type Source code in prettyqt/widgets/toolbutton.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def set_arrow_type ( self , mode : str ): \"\"\"sets the arrow type of the toolbutton valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Args: mode: arrow type to use Raises: ValueError: invalid arrow type \"\"\" if mode not in ARROW_TYPES : raise ValueError ( \"Invalid arrow type.\" ) self . setArrowType ( ARROW_TYPES [ mode ]) set_popup_mode ( self , mode ) sets the popup mode of the toolbutton valid values are: \"delayed\", \"menu_button\", \"instant\" Parameters: Name Type Description Default mode str popup mode to use required Exceptions: Type Description ValueError invalid popup mode Source code in prettyqt/widgets/toolbutton.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def set_popup_mode ( self , mode : str ): \"\"\"sets the popup mode of the toolbutton valid values are: \"delayed\", \"menu_button\", \"instant\" Args: mode: popup mode to use Raises: ValueError: invalid popup mode \"\"\" if mode not in POPUP_MODES : raise ValueError ( \"Invalid mode.\" ) self . setPopupMode ( POPUP_MODES [ mode ]) treewidgetitem TreeWidgetItem get_checkstate ( self ) returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/treewidgetitem.py 66 67 68 69 70 71 72 73 74 def get_checkstate ( self ) -> str : \"\"\"returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ( 0 )] set_checkstate ( self , state ) set checkstate of the checkbox valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description ValueError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def set_checkstate ( self , state : str ): \"\"\"set checkstate of the checkbox valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: ValueError: invalid checkstate \"\"\" if state not in STATES : raise ValueError ( \"Invalid checkstate.\" ) self . setCheckState ( 0 , STATES [ state ]) set_icon ( self , icon ) set the icon for the action Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/treewidgetitem.py 42 43 44 45 46 47 48 49 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the action Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( 0 , icon ) widget Widget get_contextmenu_policy ( self ) returns current contextmenu policy Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\", \"showhide_menu\" Returns: Type Description str contextmenu policy Source code in prettyqt/widgets/widget.py 310 311 312 313 314 315 316 317 318 319 def get_contextmenu_policy ( self ) -> str : \"\"\"returns current contextmenu policy Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\", \"showhide_menu\" Returns: contextmenu policy \"\"\" return POLICIES . inv [ self . contextMenuPolicy ()] get_modality ( self ) get the current modality modes as a string Possible values: \"modeless\", \"window\", \"application\" Returns: Type Description str modality mode str Source code in prettyqt/widgets/widget.py 236 237 238 239 240 241 242 243 244 245 def get_modality ( self ) -> str : \"\"\"get the current modality modes as a string Possible values: \"modeless\", \"window\", \"application\" Returns: modality mode str \"\"\" return MODALITIES . inv [ self . windowModality ()] resize ( self , * size ) resize(self, QSize) resize(self, int, int) Source code in prettyqt/widgets/widget.py 103 104 105 106 107 def resize ( self , * size ): if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size ) set_contextmenu_policy ( self , policy ) set contextmenu policy for given item view Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\", \"showhide_menu\" Parameters: Name Type Description Default policy str contextmenu policy to use required Exceptions: Type Description ValueError policy does not exist Source code in prettyqt/widgets/widget.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def set_contextmenu_policy ( self , policy : str ): \"\"\"set contextmenu policy for given item view Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\", \"showhide_menu\" Args: policy: contextmenu policy to use Raises: ValueError: policy does not exist \"\"\" if policy not in POLICIES : raise ValueError ( \"invalid selection behaviour\" ) self . setContextMenuPolicy ( POLICIES [ policy ]) set_icon ( self , icon ) set the window icon Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/widget.py 109 110 111 112 113 114 115 116 def set_icon ( self , icon : icons . IconType ): \"\"\"set the window icon Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) set_modality ( self , modality = 'window' ) set modality for the dialog Valid values for modality: \"modeless\", \"window\", \"application\" Parameters: Name Type Description Default modality str modality for the main window 'window' Exceptions: Type Description ValueError modality type does not exist Source code in prettyqt/widgets/widget.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def set_modality ( self , modality : str = \"window\" ): \"\"\"set modality for the dialog Valid values for modality: \"modeless\", \"window\", \"application\" Args: modality: modality for the main window Raises: ValueError: modality type does not exist \"\"\" if modality not in MODALITIES : raise ValueError ( \"Invalid value for modality.\" ) self . setWindowModality ( MODALITIES [ modality ]) set_size_policy ( self , horizontal = None , vertical = None ) sets the sizes policy possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default horizontal Optional[str] horizontal size policy None vertical Optional[str] vertical size policy None Source code in prettyqt/widgets/widget.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def set_size_policy ( self , horizontal : Optional [ str ] = None , vertical : Optional [ str ] = None ): \"\"\"sets the sizes policy possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp )","title":"widgets"},{"location":"api/widgets.html#widgets-module","text":"","title":"widgets module"},{"location":"api/widgets.html#prettyqt.widgets","text":"widgets module contains QtWidgets-based classes","title":"prettyqt.widgets"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton","text":"","title":"abstractbutton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton","text":"","title":"AbstractButton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton.set_icon","text":"set the icon for the button Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/abstractbutton.py 44 45 46 47 48 49 50 51 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the button Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview","text":"","title":"abstractitemview"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView","text":"","title":"AbstractItemView"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_behaviour","text":"returns current selection behaviour Possible values: \"rows\", \"columns\", \"items\" Returns: Type Description str selection behaviour Source code in prettyqt/widgets/abstractitemview.py 185 186 187 188 189 190 191 192 193 def get_selection_behaviour ( self ) -> str : \"\"\"returns current selection behaviour Possible values: \"rows\", \"columns\", \"items\" Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOURS . inv [ self . selectionBehavior ()]","title":"get_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_mode","text":"returns current selection mode Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/abstractitemview.py 214 215 216 217 218 219 220 221 222 def get_selection_mode ( self ) -> str : \"\"\"returns current selection mode Possible values: \"single\", \"extended\", \"multi\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.highlight_when_inactive","text":"also highlight items when widget does not have focus Source code in prettyqt/widgets/abstractitemview.py 307 308 309 310 311 312 def highlight_when_inactive ( self ): \"\"\"also highlight items when widget does not have focus \"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p )","title":"highlight_when_inactive()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.jump_to_column","text":"make sure column at given index is visible scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py 280 281 282 283 284 285 286 287 288 289 290 291 def jump_to_column ( self , col_num : int ): \"\"\"make sure column at given index is visible scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return None idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx )","title":"jump_to_column()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.num_selected","text":"returns amount of selected rows Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py 270 271 272 273 274 275 276 277 278 def num_selected ( self ) -> int : \"\"\"returns amount of selected rows Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ())","title":"num_selected()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_bottom","text":"override to use abstractitemview-way of scrolling to bottom Source code in prettyqt/widgets/abstractitemview.py 298 299 300 301 def scroll_to_bottom ( self ): \"\"\"override to use abstractitemview-way of scrolling to bottom \"\"\" self . scrollToBottom ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_top","text":"override to use abstractitemview-way of scrolling to top Source code in prettyqt/widgets/abstractitemview.py 293 294 295 296 def scroll_to_top ( self ): \"\"\"override to use abstractitemview-way of scrolling to top \"\"\" self . scrollToTop ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selectAll","text":"Override, we dont want to selectAll for too many items for performance reasons Source code in prettyqt/widgets/abstractitemview.py 49 50 51 52 53 54 55 56 57 58 def selectAll ( self ): \"\"\" Override, we dont want to selectAll for too many items for performance reasons \"\"\" if self . model () is None : return None if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logging . warning ( \"Too many cells to select.\" ) return None super () . selectAll ()","title":"selectAll()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_data","text":"returns generator yielding selected userData Source code in prettyqt/widgets/abstractitemview.py 146 147 148 149 150 def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\" returns generator yielding selected userData \"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes ())","title":"selected_data()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_indexes","text":"returns list of selected indexes in first row Source code in prettyqt/widgets/abstractitemview.py 127 128 129 130 131 132 def selected_indexes ( self ) -> List [ QtCore . QModelIndex ]: \"\"\" returns list of selected indexes in first row \"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) return sorted ( indexes , key = lambda x : x . row ())","title":"selected_indexes()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_names","text":"returns generator yielding item names Source code in prettyqt/widgets/abstractitemview.py 134 135 136 137 138 def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\" returns generator yielding item names \"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ())","title":"selected_names()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_rows","text":"returns generator yielding row nums Source code in prettyqt/widgets/abstractitemview.py 140 141 142 143 144 def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\" returns generator yielding row nums \"\"\" return ( x . row () for x in self . selected_indexes ())","title":"selected_rows()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_horizontal_scroll_mode","text":"sets the horizontal scroll mode possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description ValueError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def set_horizontal_scroll_mode ( self , mode : str ): \"\"\"sets the horizontal scroll mode possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: ValueError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise ValueError ( \"Invalid scroll mode\" ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ])","title":"set_horizontal_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_model","text":"delete old selection model explicitely, seems to help with memory usage Source code in prettyqt/widgets/abstractitemview.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def set_model ( self , model : Optional [ QtCore . QAbstractItemModel ]): \"\"\" delete old selection model explicitely, seems to help with memory usage \"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model","title":"set_model()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_scroll_mode","text":"sets the scroll mode for both directions possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description ValueError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def set_scroll_mode ( self , mode : str ): \"\"\"sets the scroll mode for both directions possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: ValueError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise ValueError ( \"Invalid scroll mode\" ) self . setHorizontalScrollMode ( SCROLL_MODES [ mode ]) self . setVerticalScrollMode ( SCROLL_MODES [ mode ])","title":"set_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_behaviour","text":"set selection behaviour for given item view Allowed values are \"rows\", \"columns\", \"items\" Parameters: Name Type Description Default behaviour str selection behaviour to use required Exceptions: Type Description ValueError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 def set_selection_behaviour ( self , behaviour : str ): \"\"\"set selection behaviour for given item view Allowed values are \"rows\", \"columns\", \"items\" Args: behaviour: selection behaviour to use Raises: ValueError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOURS : raise ValueError ( \"invalid selection behaviour\" ) self . setSelectionBehavior ( SELECTION_BEHAVIOURS [ behaviour ])","title":"set_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_mode","text":"set selection mode for given item view Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description ValueError mode does not exist Source code in prettyqt/widgets/abstractitemview.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"set selection mode for given item view Allowed values are \"single\", \"extended\", \"multi\" or \"none\" Args: mode: selection mode to use Raises: ValueError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise ValueError ( \"Format must be either 'single', 'extended',\" \"'multi' or 'None'\" ) self . setSelectionMode ( SELECTION_MODES [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_vertical_scroll_mode","text":"sets the vertical scroll mode possible values are \"item\", \"pixel\" Parameters: Name Type Description Default mode str mode to set required Exceptions: Type Description ValueError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 def set_vertical_scroll_mode ( self , mode : str ): \"\"\"sets the vertical scroll mode possible values are \"item\", \"pixel\" Args: mode: mode to set Raises: ValueError: invalid scroll mode \"\"\" if mode not in SCROLL_MODES : raise ValueError ( \"Invalid scroll mode\" ) self . setVerticalScrollMode ( SCROLL_MODES [ mode ])","title":"set_vertical_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.toggle_select_all","text":"select all items from list (deselect when all selected) Source code in prettyqt/widgets/abstractitemview.py 97 98 99 100 101 102 103 104 105 106 def toggle_select_all ( self ): \"\"\" select all items from list (deselect when all selected) \"\"\" if self . selectionModel () is None : return None if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll ()","title":"toggle_select_all()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea","text":"","title":"abstractscrollarea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea","text":"","title":"AbstractScrollArea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.get_size_adjust_policy","text":"returns size adjust policy possible values are \"content\", \"first_show\", \"ignored\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py 70 71 72 73 74 75 76 77 78 def get_size_adjust_policy ( self ) -> str : \"\"\"returns size adjust policy possible values are \"content\", \"first_show\", \"ignored\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_bottom","text":"scroll to the bottom of the scroll area Source code in prettyqt/widgets/abstractscrollarea.py 158 159 160 161 def scroll_to_bottom ( self ): \"\"\"scroll to the bottom of the scroll area \"\"\" self . verticalScrollBar () . scroll_to_max ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_top","text":"scroll to the top of the scroll area Source code in prettyqt/widgets/abstractscrollarea.py 153 154 155 156 def scroll_to_top ( self ): \"\"\"scroll to the top of the scroll area \"\"\" self . verticalScrollBar () . scroll_to_min ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_policy","text":"sets the horizontal scrollbar visibility possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description ValueError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def set_horizontal_scrollbar_policy ( self , mode : str ): \"\"\"sets the horizontal scrollbar visibility possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: ValueError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise ValueError ( \"Invalid scrollbar policy\" ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_horizontal_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_width","text":"sets the horizontal scrollbar width Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 135 136 137 138 139 140 141 142 def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"sets the horizontal scrollbar width Args: width: width in pixels \"\"\" stylesheet = f \"QScrollBar:horizontal {{ height: { width } px; }} \" self . horizontalScrollBar () . setStyleSheet ( stylesheet )","title":"set_horizontal_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_policy","text":"sets the policy for both scrollbars possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description ValueError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def set_scrollbar_policy ( self , mode : str ): \"\"\"sets the policy for both scrollbars possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: ValueError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise ValueError ( \"Invalid scrollbar policy\" ) self . setHorizontalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_width","text":"sets the width for both scrollbars Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 126 127 128 129 130 131 132 133 def set_scrollbar_width ( self , width : int ): \"\"\"sets the width for both scrollbars Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width )","title":"set_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_size_adjust_policy","text":"set size adjust policy Valid values are \"content\", \"first_show\", \"ignored\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description ValueError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def set_size_adjust_policy ( self , policy : str ): \"\"\"set size adjust policy Valid values are \"content\", \"first_show\", \"ignored\" Args: policy: size adjust policy to use Raises: ValueError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise ValueError ( \"Policy not available\" ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy )","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_policy","text":"sets the vertical scrollbar visibility possible values are \"always_on\", \"always_off\", \"as_needed\" Parameters: Name Type Description Default mode str visibilty to set required Exceptions: Type Description ValueError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def set_vertical_scrollbar_policy ( self , mode : str ): \"\"\"sets the vertical scrollbar visibility possible values are \"always_on\", \"always_off\", \"as_needed\" Args: mode: visibilty to set Raises: ValueError: invalid scrollbar policy \"\"\" if mode not in SCROLLBAR_POLICY : raise ValueError ( \"Invalid scrollbar policy\" ) self . setVerticalScrollBarPolicy ( SCROLLBAR_POLICY [ mode ])","title":"set_vertical_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_width","text":"sets the vertical scrollbar width Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py 144 145 146 147 148 149 150 151 def set_vertical_scrollbar_width ( self , width : int ): \"\"\"sets the vertical scrollbar width Args: width: width in pixels \"\"\" stylesheet = f \"QScrollBar:vertical {{ width: { width } px; }} \" self . verticalScrollBar () . setStyleSheet ( stylesheet )","title":"set_vertical_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider","text":"","title":"abstractslider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider","text":"","title":"AbstractSlider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_horizontal","text":"check if silder is horizontal Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py 41 42 43 44 45 46 47 def is_horizontal ( self ) -> bool : \"\"\"check if silder is horizontal Returns: True if horizontal, else False \"\"\" return self . orientation () == QtCore . Qt . Horizontal","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_vertical","text":"check if silder is vertical Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py 49 50 51 52 53 54 55 def is_vertical ( self ) -> bool : \"\"\"check if silder is vertical Returns: True if vertical, else False \"\"\" return self . orientation () == QtCore . Qt . Vertical","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_max","text":"scroll to the maximum value of the slider Source code in prettyqt/widgets/abstractslider.py 72 73 74 75 def scroll_to_max ( self ): \"\"\"scroll to the maximum value of the slider \"\"\" self . setValue ( self . maximum ())","title":"scroll_to_max()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_min","text":"scroll to the minimum value of the slider Source code in prettyqt/widgets/abstractslider.py 67 68 69 70 def scroll_to_min ( self ): \"\"\"scroll to the minimum value of the slider \"\"\" self . setValue ( self . minimum ())","title":"scroll_to_min()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_horizontal","text":"set slider orientation to horizontal Source code in prettyqt/widgets/abstractslider.py 57 58 59 60 def set_horizontal ( self ): \"\"\"set slider orientation to horizontal \"\"\" self . setOrientation ( QtCore . Qt . Horizontal )","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_vertical","text":"set slider orientation to vertical Source code in prettyqt/widgets/abstractslider.py 62 63 64 65 def set_vertical ( self ): \"\"\"set slider orientation to vertical \"\"\" self . setOrientation ( QtCore . Qt . Vertical )","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox","text":"","title":"abstractspinbox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox","text":"","title":"AbstractSpinBox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_button_symbols","text":"returns button symbol type possible values are \"none\", \"up_down\", \"plus_minus\" Returns: Type Description str button symbol type Source code in prettyqt/widgets/abstractspinbox.py 43 44 45 46 47 48 49 50 51 def get_button_symbols ( self ) -> str : \"\"\"returns button symbol type possible values are \"none\", \"up_down\", \"plus_minus\" Returns: button symbol type \"\"\" return SYMBOLS . inv [ self . buttonSymbols ()]","title":"get_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_correction_mode","text":"returns correction mode possible values are \"to_previous\", \"to_nearest\" Returns: Type Description str correction mode Source code in prettyqt/widgets/abstractspinbox.py 83 84 85 86 87 88 89 90 91 def get_correction_mode ( self ) -> str : \"\"\"returns correction mode possible values are \"to_previous\", \"to_nearest\" Returns: correction mode \"\"\" return CORRECTION_MODES . inv [ self . correctionMode ()]","title":"get_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_step_type","text":"returns step type possible values are \"default\", \"adaptive\" Returns: Type Description str step type Source code in prettyqt/widgets/abstractspinbox.py 108 109 110 111 112 113 114 115 116 def get_step_type ( self ) -> str : \"\"\"returns step type possible values are \"default\", \"adaptive\" Returns: step type \"\"\" return STEP_TYPES . inv [ self . stepType ()]","title":"get_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_button_symbols","text":"sets button symbol type possible values are \"none\", \"up_down\", \"plus_minus\" Parameters: Name Type Description Default mode str button symbol type to use required Exceptions: Type Description ValueError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def set_button_symbols ( self , mode : str ): \"\"\"sets button symbol type possible values are \"none\", \"up_down\", \"plus_minus\" Args: mode: button symbol type to use Raises: ValueError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise ValueError ( \"Invalid button symbol type.\" ) self . setButtonSymbols ( SYMBOLS [ mode ])","title":"set_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_correction_mode","text":"sets correction mode possible values are \"to_previous\", \"to_nearest\" Parameters: Name Type Description Default mode str correction mode to use required Exceptions: Type Description ValueError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def set_correction_mode ( self , mode : str ): \"\"\"sets correction mode possible values are \"to_previous\", \"to_nearest\" Args: mode: correction mode to use Raises: ValueError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise ValueError ( \"Invalid correction mode.\" ) self . setCorrectionMode ( CORRECTION_MODES [ mode ])","title":"set_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_step_type","text":"sets step type possible values are \"default\", \"adaptive\" Parameters: Name Type Description Default mode str step type to use required Exceptions: Type Description ValueError invalid step type Source code in prettyqt/widgets/abstractspinbox.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def set_step_type ( self , mode : str ): \"\"\"sets step type possible values are \"default\", \"adaptive\" Args: mode: step type to use Raises: ValueError: invalid step type \"\"\" if mode not in STEP_TYPES : raise ValueError ( \"Invalid step type.\" ) self . setStepType ( STEP_TYPES [ mode ])","title":"set_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.action","text":"","title":"action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action","text":"","title":"Action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_priority","text":"returns current priority Possible values: \"low\", \"normal\", \"high\" Returns: Type Description str priority Source code in prettyqt/widgets/action.py 122 123 124 125 126 127 128 129 130 def get_priority ( self ) -> str : \"\"\"returns current priority Possible values: \"low\", \"normal\", \"high\" Returns: priority \"\"\" return PRIORITIES . inv [ self . priority ()]","title":"get_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_shortcut_context","text":"returns shortcut context Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: Type Description str shortcut context Source code in prettyqt/widgets/action.py 147 148 149 150 151 152 153 154 155 def get_shortcut_context ( self ) -> str : \"\"\"returns shortcut context Possible values: \"widget\", \"widget_with_children\", \"window\", \"application\" Returns: shortcut context \"\"\" return CONTEXTS . inv [ self . shortcutContext ()]","title":"get_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_icon","text":"set the icon for the action Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/action.py 91 92 93 94 95 96 97 98 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the action Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_priority","text":"set priority of the action Allowed values are \"low\", \"normal\", \"high\" Parameters: Name Type Description Default priority str priority for the action required Exceptions: Type Description ValueError priority does not exist Source code in prettyqt/widgets/action.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def set_priority ( self , priority : str ): \"\"\"set priority of the action Allowed values are \"low\", \"normal\", \"high\" Args: priority: priority for the action Raises: ValueError: priority does not exist \"\"\" if priority not in PRIORITIES : raise ValueError ( f \" { priority } not a valid priority.\" ) self . setPriority ( PRIORITIES [ priority ])","title":"set_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_shortcut_context","text":"set shortcut context Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Parameters: Name Type Description Default context str shortcut context required Exceptions: Type Description ValueError shortcut context does not exist Source code in prettyqt/widgets/action.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def set_shortcut_context ( self , context : str ): \"\"\"set shortcut context Allowed values are \"widget\", \"widget_with_children\", \"window\", \"application\" Args: context: shortcut context Raises: ValueError: shortcut context does not exist \"\"\" if context not in CONTEXTS : raise ValueError ( f \" { context } not a valid shortcut context.\" ) self . setShortcutContext ( CONTEXTS [ context ])","title":"set_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.application","text":"","title":"application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application","text":"","title":"Application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.copy_to_clipboard","text":"Sets clipboard to supplied text Source code in prettyqt/widgets/application.py 73 74 75 76 77 78 79 80 @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\" Sets clipboard to supplied text \"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Clipboard ) cb . setText ( text , mode = cb . Clipboard )","title":"copy_to_clipboard()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.set_icon","text":"set the default window icon Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/application.py 19 20 21 22 23 24 25 26 def set_icon ( self , icon : icons . IconType ): \"\"\"set the default window icon Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget","text":"","title":"calendarwidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget","text":"","title":"CalendarWidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.get_selection_mode","text":"returns current selection mode Possible values: \"single\" or \"none\" Returns: Type Description str selection mode Source code in prettyqt/widgets/calendarwidget.py 65 66 67 68 69 70 71 72 73 def get_selection_mode ( self ) -> str : \"\"\"returns current selection mode Possible values: \"single\" or \"none\" Returns: selection mode \"\"\" return SELECTION_MODES . inv [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.set_selection_mode","text":"set selection mode for given calendar widget Allowed values are \"single\" or \"none\" Parameters: Name Type Description Default mode Optional[str] selection mode to use required Exceptions: Type Description ValueError mode does not exist Source code in prettyqt/widgets/calendarwidget.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def set_selection_mode ( self , mode : Optional [ str ]): \"\"\"set selection mode for given calendar widget Allowed values are \"single\" or \"none\" Args: mode: selection mode to use Raises: ValueError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODES : raise ValueError ( \"Format must be either 'single' or 'None'\" ) self . setSelectionMode ( SELECTION_MODES [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox","text":"","title":"checkbox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox","text":"","title":"CheckBox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.get_checkstate","text":"returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description bool checkstate Source code in prettyqt/widgets/checkbox.py 79 80 81 82 83 84 85 86 87 def get_checkstate ( self ) -> bool : \"\"\"returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.set_checkstate","text":"set checkstate of the checkbox valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description ValueError invalid checkstate Source code in prettyqt/widgets/checkbox.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def set_checkstate ( self , state : str ): \"\"\"set checkstate of the checkbox valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: ValueError: invalid checkstate \"\"\" if state not in STATES : raise ValueError ( \"Invalid checkstate.\" ) self . setCheckState ( STATES [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.combobox","text":"","title":"combobox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox","text":"","title":"ComboBox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_insert_policy","text":"returns insert policy possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: Type Description str insert policy Source code in prettyqt/widgets/combobox.py 130 131 132 133 134 135 136 137 138 139 def get_insert_policy ( self ) -> str : \"\"\"returns insert policy possible values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Returns: insert policy \"\"\" return INSERT_POLICIES . inv [ self . insertPolicy ()]","title":"get_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_size_adjust_policy","text":"returns size adjust policy possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: Type Description str size adjust policy Source code in prettyqt/widgets/combobox.py 157 158 159 160 161 162 163 164 165 def get_size_adjust_policy ( self ) -> str : \"\"\"returns size adjust policy possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Returns: size adjust policy \"\"\" return SIZE_POLICIES . inv [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_insert_policy","text":"set insert policy valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Parameters: Name Type Description Default policy str insert policy to use required Exceptions: Type Description ValueError invalid insert policy Source code in prettyqt/widgets/combobox.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def set_insert_policy ( self , policy : str ): \"\"\"set insert policy valid values are \"no_insert\", \"top\", \"current\", \"bottom\", \"after_current\", \"before_current\", \"alphabetically\" Args: policy: insert policy to use Raises: ValueError: invalid insert policy \"\"\" if policy not in INSERT_POLICIES : raise ValueError ( \"Policy not available\" ) policy = INSERT_POLICIES . get ( policy ) self . setInsertPolicy ( policy )","title":"set_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_size_adjust_policy","text":"set size adjust policy possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Parameters: Name Type Description Default policy str size adjust policy to use required Exceptions: Type Description ValueError invalid size adjust policy Source code in prettyqt/widgets/combobox.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def set_size_adjust_policy ( self , policy : str ): \"\"\"set size adjust policy possible values are \"content\", \"first_show\", \"min_length\", \"min_length_with_icon\" Args: policy: size adjust policy to use Raises: ValueError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICIES : raise ValueError ( \"Policy not available\" ) policy = SIZE_POLICIES . get ( policy ) self . setSizeAdjustPolicy ( policy )","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.dialog","text":"","title":"dialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.BaseDialog","text":"","title":"BaseDialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.BaseDialog.keyPressEvent","text":"keyPressEvent(self, QKeyEvent) Source code in prettyqt/widgets/dialog.py 43 44 45 46 47 48 49 def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e )","title":"keyPressEvent()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox","text":"","title":"dialogbuttonbox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox","text":"","title":"DialogButtonBox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_button","text":"add a button Parameters: Name Type Description Default button Union[PyQt5.QtWidgets.QPushButton, str] button to add required role str role of the button 'accept' callback Optional[Callable] function to call when button gets clicked None Returns: Type Description PushButton created button Exceptions: Type Description ValueError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def add_button ( self , button : Union [ QtWidgets . QPushButton , str ], role : str = \"accept\" , callback : Optional [ Callable ] = None , ) -> widgets . PushButton : \"\"\"add a button Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: ValueError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_default_button","text":"add a default button Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required callback Optional[Callable] function to call when button gets clicked None Returns: Type Description QPushButton created button Exceptions: Type Description ValueError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def add_default_button ( self , button : str , callback : Optional [ Callable ] = None ) -> QtWidgets . QPushButton : \"\"\"add a default button Valid arguments: \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: ValueError: Button type not available \"\"\" if button not in BUTTONS : raise ValueError ( \"button type not available\" ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn","title":"add_default_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.create","text":"create(self, window: sip.voidptr = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) Source code in prettyqt/widgets/dialogbuttonbox.py 73 74 75 76 77 78 @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) return box","title":"create()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.get_orientation","text":"returns current orientation Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/dialogbuttonbox.py 104 105 106 107 108 109 110 111 112 def get_orientation ( self ) -> str : \"\"\"returns current orientation Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.set_orientation","text":"set the orientation of the button box Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the button box required Exceptions: Type Description ValueError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def set_orientation ( self , orientation : str ): \"\"\"set the orientation of the button box Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the button box Raises: ValueError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise ValueError ( f \" { orientation } not a valid orientation.\" ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.dockwidget","text":"","title":"dockwidget"},{"location":"api/widgets.html#prettyqt.widgets.dockwidget.DockWidget","text":"Customized DockWidget class contains a custom TitleBar with maximise button","title":"DockWidget"},{"location":"api/widgets.html#prettyqt.widgets.filedialog","text":"","title":"filedialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog","text":"simple dialog used to display some widget","title":"FileDialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.directory","text":"return current directory returns current directory level as a Pathlib object Returns: Type Description Path Pathlib object Source code in prettyqt/widgets/filedialog.py 230 231 232 233 234 235 236 237 238 def directory ( self ) -> pathlib . Path : \"\"\"return current directory returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( super () . directory ())","title":"directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_accept_mode","text":"returns accept mode possible values are \"save\", \"open\" Returns: Type Description str accept mode Source code in prettyqt/widgets/filedialog.py 106 107 108 109 110 111 112 113 114 def get_accept_mode ( self ) -> str : \"\"\"returns accept mode possible values are \"save\", \"open\" Returns: accept mode \"\"\" return ACCEPT_MODES . inv [ self . acceptMode ()]","title":"get_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_file_mode","text":"returns file mode possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: Type Description str file mode Source code in prettyqt/widgets/filedialog.py 165 166 167 168 169 170 171 172 173 def get_file_mode ( self ) -> str : \"\"\"returns file mode possible values are \"existing_file\", \"existing_files\", \"any_file\", \"directory\" Returns: file mode \"\"\" return MODES . inv [ self . fileMode ()]","title":"get_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_label_text","text":"returns label text possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py 155 156 157 158 159 160 161 162 163 def get_label_text ( self , label ) -> str : \"\"\"returns label text possible values are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Returns: label text \"\"\" return self . labelText ( LABELS . inv [ label ])","title":"get_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_view_mode","text":"returns view mode possible values are \"detail\", \"list\" Returns: Type Description str view mode Source code in prettyqt/widgets/filedialog.py 131 132 133 134 135 136 137 138 139 def get_view_mode ( self ) -> str : \"\"\"returns view mode possible values are \"detail\", \"list\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_accept_mode","text":"set accept mode possible values are \"save\", \"open\" Parameters: Name Type Description Default mode str accept mode to use required Exceptions: Type Description ValueError invalid accept mode Source code in prettyqt/widgets/filedialog.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def set_accept_mode ( self , mode : str ): \"\"\"set accept mode possible values are \"save\", \"open\" Args: mode: accept mode to use Raises: ValueError: invalid accept mode \"\"\" if mode not in ACCEPT_MODES : raise ValueError ( f \"Invalid value. Valid values: { ACCEPT_MODES . keys () } \" ) self . setAcceptMode ( ACCEPT_MODES [ mode ])","title":"set_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_directory","text":"set start directory Source code in prettyqt/widgets/filedialog.py 240 241 242 243 244 245 def set_directory ( self , path : Union [ None , str , pathlib . Path ]): \"\"\"set start directory \"\"\" if isinstance ( path , pathlib . Path ): path = str ( path ) self . setDirectory ( path )","title":"set_directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_extension_filter","text":"set filter based on given dictionary dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict dict filter dictionary required Source code in prettyqt/widgets/filedialog.py 216 217 218 219 220 221 222 223 224 225 226 227 228 def set_extension_filter ( self , extension_dict : dict ): \"\"\"set filter based on given dictionary dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str )","title":"set_extension_filter()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_file_mode","text":"sets the file mode of the dialog allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Parameters: Name Type Description Default mode str mode to use required Source code in prettyqt/widgets/filedialog.py 175 176 177 178 179 180 181 182 183 def set_file_mode ( self , mode : str ): \"\"\"sets the file mode of the dialog allowed values are \"existing_file\", \"existing_files\", \"any_file\" \"directory\" Args: mode: mode to use \"\"\" self . setFileMode ( MODES [ mode ])","title":"set_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_label_text","text":"sets the label text for button label possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Parameters: Name Type Description Default label str button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py 141 142 143 144 145 146 147 148 149 150 151 152 153 def set_label_text ( self , label : str , text : str ): \"\"\"sets the label text for button label possible values for label are \"look_in\", \"filename\", \"filetype\", \"accept\", \"reject\" Args: label: button to set text for text: text to use \"\"\" if label not in LABELS : raise ValueError ( f \"Invalid value. Valid values: { LABELS . keys () } \" ) self . setLabelText ( LABELS [ label ], text )","title":"set_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_view_mode","text":"set view mode possible values are \"detail\", \"list\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description ValueError invalid view mode Source code in prettyqt/widgets/filedialog.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def set_view_mode ( self , mode : str ): \"\"\"set view mode possible values are \"detail\", \"list\" Args: mode: view mode to use Raises: ValueError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise ValueError ( f \"Invalid value. Valid values: { VIEW_MODES . keys () } \" ) self . setViewMode ( VIEW_MODES [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel","text":"","title":"filesystemmodel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel","text":"Class to populate a filesystem treeview","title":"FileSystemModel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/widgets/filesystemmodel.py 53 54 55 56 57 def data ( self , index , role = QtCore . Qt . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role )","title":"data()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout","text":"","title":"formlayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout","text":"","title":"FormLayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.__len__","text":"needed for PySide2 Source code in prettyqt/widgets/formlayout.py 39 40 41 42 def __len__ ( self ): \"\"\"needed for PySide2 \"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/widgets.html#prettyqt.widgets.frame","text":"","title":"frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame","text":"","title":"Frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.get_frame_style","text":"returns current frame style Possible values: \"plain\", \"raised\", \"sunken\" Returns: Type Description str frame style Source code in prettyqt/widgets/frame.py 46 47 48 49 50 51 52 53 54 def get_frame_style ( self ) -> str : \"\"\"returns current frame style Possible values: \"plain\", \"raised\", \"sunken\" Returns: frame style \"\"\" return SHADOWS . inv [ self . frameStyle ()]","title":"get_frame_style()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.set_frame_style","text":"set frame style Allowed values are \"plain\", \"raised\", \"sunken\" Parameters: Name Type Description Default style str frame style to use required Exceptions: Type Description ValueError style does not exist Source code in prettyqt/widgets/frame.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def set_frame_style ( self , style : str ): \"\"\"set frame style Allowed values are \"plain\", \"raised\", \"sunken\" Args: style: frame style to use Raises: ValueError: style does not exist \"\"\" if style not in SHADOWS : raise ValueError ( \"invalid frame style\" ) self . setFrameStyle ( SHADOWS [ style ])","title":"set_frame_style()"},{"location":"api/widgets.html#prettyqt.widgets.groupbox","text":"","title":"groupbox"},{"location":"api/widgets.html#prettyqt.widgets.groupbox.GroupBox","text":"GroupBox widget A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets.","title":"GroupBox"},{"location":"api/widgets.html#prettyqt.widgets.headerview","text":"","title":"headerview"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView","text":"","title":"HeaderView"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView.contextMenuEvent","text":"context menu for our files tree Source code in prettyqt/widgets/headerview.py 71 72 73 74 75 76 77 78 79 80 81 82 83 def contextMenuEvent ( self , event ): \"\"\" context menu for our files tree \"\"\" menu = widgets . Menu ( parent = self ) for i , header_label in enumerate ( self . section_labels ()[ 1 :], start = 1 ): act = menu . addAction ( header_label ) act . setCheckable ( True ) val = not self . isSectionHidden ( i ) act . setChecked ( val ) fn = functools . partial ( self . set_section_hidden , i = i , hide = val ) act . triggered . connect ( fn ) menu . exec_ ( self . mapToGlobal ( event . pos ()))","title":"contextMenuEvent()"},{"location":"api/widgets.html#prettyqt.widgets.label","text":"","title":"label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label","text":"","title":"Label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_format","text":"returns current text format Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/label.py 124 125 126 127 128 129 130 131 132 def get_text_format ( self ) -> str : \"\"\"returns current text format Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_interaction","text":"returns current text interaction mode Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: Type Description List[str] list of text interaction modes Source code in prettyqt/widgets/label.py 152 153 154 155 156 157 158 159 160 def get_text_interaction ( self ) -> List [ str ]: \"\"\"returns current text interaction mode Possible values: \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()]","title":"get_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_format","text":"set the text format Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description ValueError text format does not exist Source code in prettyqt/widgets/label.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def set_text_format ( self , text_format : str ): \"\"\"set the text format Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: ValueError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise ValueError ( \"Invalid text format\" ) self . setTextFormat ( TEXT_FORMATS [ text_format ]) return self","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_interaction","text":"set the text interaction mode Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Parameters: Name Type Description Default types str text interaction mode to use () Exceptions: Type Description ValueError text interaction mode does not exist Source code in prettyqt/widgets/label.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def set_text_interaction ( self , * types : str ): \"\"\"set the text interaction mode Allowed values are \"none\", \"by_mouse\", \"by_keyboard\", \"text_editable\" Args: types: text interaction mode to use Raises: ValueError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise ValueError ( \"Invalid text interaction mode\" ) flags = functools . reduce ( operator . ior , [ TEXT_INTERACTION [ t ] for t in types ]) self . setTextInteractionFlags ( flags ) return self","title":"set_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_weight","text":"sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Parameters: Name Type Description Default weight str font weight required Exceptions: Type Description ValueError invalid font weight Source code in prettyqt/widgets/label.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def set_weight ( self , weight : str ): \"\"\"sets the font weight Valid values are \"thin\", \"extra_light\", light\", \"medium\", \"demi_bold\", \"bold\", \"extra_bold\", normal\", \"black\" Args: weight: font weight Raises: ValueError: invalid font weight \"\"\" if weight not in WEIGHTS : raise ValueError ( f \"Invalid weight ' { weight } '\" ) font = self . font () font . setWeight ( WEIGHTS [ weight ]) self . setFont ( font ) return self","title":"set_weight()"},{"location":"api/widgets.html#prettyqt.widgets.layout","text":"","title":"layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout","text":"","title":"Layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.get_size_mode","text":"returns current size mode Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: Type Description str size mode Source code in prettyqt/widgets/layout.py 75 76 77 78 79 80 81 82 83 def get_size_mode ( self ) -> str : \"\"\"returns current size mode Possible values: \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Returns: size mode \"\"\" return MODES . inv [ self . sizeConstraint ()]","title":"get_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_alignment","text":"Sets the alignment for widget / layout to alignment and returns true if w is found in this layout (not including child layouts) Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required item set alignment for specific child only None Exceptions: Type Description ValueError alignment does not exist Source code in prettyqt/widgets/layout.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def set_alignment ( self , alignment : str , item = None ): \"\"\"Sets the alignment for widget / layout to alignment and returns true if w is found in this layout (not including child layouts) Allowed values for alignment: \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout item: set alignment for specific child only Raises: ValueError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise ValueError ( f \" { alignment !r} not a valid alignment.\" ) if item is not None : return self . setAlignment ( item , ALIGNMENTS [ alignment ]) else : return self . setAlignment ( ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_size_mode","text":"set the size mode of the layout Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Parameters: Name Type Description Default mode str size mode for the layout required Exceptions: Type Description ValueError size mode does not exist Source code in prettyqt/widgets/layout.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def set_size_mode ( self , mode : str ): \"\"\"set the size mode of the layout Allowed values are \"default\", \"fixed\", \"minimum\", \"maximum\", \"min_and_max\", \"none\" Args: mode: size mode for the layout Raises: ValueError: size mode does not exist \"\"\" if mode not in MODES : raise ValueError ( f \" { mode } not a valid size mode.\" ) self . setSizeConstraint ( MODES [ mode ])","title":"set_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit","text":"","title":"lineedit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit","text":"","title":"LineEdit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.font","text":"font(self) -> QFont Source code in prettyqt/widgets/lineedit.py 69 70 def font ( self ) -> gui . Font : return gui . Font ( super () . font ())","title":"font()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_echo_mode","text":"returns echo mode possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: Type Description str echo mode Source code in prettyqt/widgets/lineedit.py 123 124 125 126 127 128 129 130 131 def get_echo_mode ( self ) -> str : \"\"\"returns echo mode possible values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Returns: echo mode \"\"\" return ECHO_MODES . inv [ self . echoMode ()]","title":"get_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_echo_mode","text":"set echo mode Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Parameters: Name Type Description Default mode str echo mode to use required Exceptions: Type Description ValueError invalid echo mode Source code in prettyqt/widgets/lineedit.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def set_echo_mode ( self , mode : str ): \"\"\"set echo mode Valid values are \"normal\", \"no_echo\", \"password\", \"echo_on_edit\" Args: mode: echo mode to use Raises: ValueError: invalid echo mode \"\"\" if mode not in ECHO_MODES : raise ValueError ( \"Invalid echo mode\" ) self . setEchoMode ( ECHO_MODES [ mode ])","title":"set_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_read_only","text":"set test to read only Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py 78 79 80 81 82 83 84 def set_read_only ( self , value : bool = True ): \"\"\"set test to read only Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.listview","text":"","title":"listview"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView","text":"","title":"ListView"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_view_mode","text":"returns view mode possible values are \"list\", \"icon\" Returns: Type Description str view mode Source code in prettyqt/widgets/listview.py 33 34 35 36 37 38 39 40 41 def get_view_mode ( self ) -> str : \"\"\"returns view mode possible values are \"list\", \"icon\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_view_mode","text":"set view mode possible values are \"list\", \"icon\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description ValueError invalid view mode Source code in prettyqt/widgets/listview.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def set_view_mode ( self , mode : str ): \"\"\"set view mode possible values are \"list\", \"icon\" Args: mode: view mode to use Raises: ValueError: invalid view mode \"\"\" if mode not in VIEW_MODES : raise ValueError ( f \"Invalid value. Valid values: { VIEW_MODES . keys () } \" ) self . setViewMode ( VIEW_MODES [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem","text":"","title":"listwidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem","text":"","title":"ListWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.get_checkstate","text":"returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/listwidgetitem.py 65 66 67 68 69 70 71 72 73 def get_checkstate ( self ) -> str : \"\"\"returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_checkstate","text":"set checkstate of the checkbox valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description ValueError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def set_checkstate ( self , state : str ): \"\"\"set checkstate of the checkbox valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: ValueError: invalid checkstate \"\"\" if state not in STATES : raise ValueError ( \"Invalid checkstate.\" ) self . setCheckState ( STATES [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_icon","text":"set the icon for the action Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/listwidgetitem.py 41 42 43 44 45 46 47 48 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the action Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow","text":"","title":"mainwindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow","text":"Class for our mainWindow includes all docks, a centralwidget and a toolbar","title":"MainWindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar","text":"adds a toolbar to the mainmenu at specified area Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default toolbar toolbar to use required position str position of the toolbar 'top' Exceptions: Type Description ValueError position does not exist Source code in prettyqt/widgets/mainwindow.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def add_toolbar ( self , toolbar , position : str = \"top\" ): \"\"\"adds a toolbar to the mainmenu at specified area Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: toolbar: toolbar to use position: position of the toolbar Raises: ValueError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise ValueError ( \"Position not existing\" ) self . addToolBar ( TOOLBAR_AREAS [ position ], toolbar )","title":"add_toolbar()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar_break","text":"Adds a toolbar break to the given area after all the other objects that are present. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default position str position of the toolbar 'top' Exceptions: Type Description ValueError position does not exist Source code in prettyqt/widgets/mainwindow.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def add_toolbar_break ( self , position : str = \"top\" ): \"\"\"Adds a toolbar break to the given area after all the other objects that are present. Valid values for position: \"left\", \"right\", \"top\", \"bottom\" Args: position: position of the toolbar Raises: ValueError: position does not exist \"\"\" if position not in TOOLBAR_AREAS : raise ValueError ( \"Position not existing\" ) self . addToolBarBreak ( TOOLBAR_AREAS [ position ])","title":"add_toolbar_break()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.createPopupMenu","text":"createPopupMenu(self) -> QMenu Source code in prettyqt/widgets/mainwindow.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def createPopupMenu ( self ): # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add_action ( action ) menu . add_separator () for i in self . get_toolbars (): action = widgets . Action ( text = i . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( i . setVisible ) action . set_checked ( i . isVisible ()) menu . add_action ( action ) return menu","title":"createPopupMenu()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.save_window_state","text":"override, gets executed when app gets closed. saves GUI settings Source code in prettyqt/widgets/mainwindow.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def save_window_state ( self , recursive = False ): \"\"\" override, gets executed when app gets closed. saves GUI settings \"\"\" settings = core . Settings () name = self . get_id () logging . debug ( f \"Saving window state for { name } ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state ()","title":"save_window_state()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.toggle_fullscreen","text":"toggle between fullscreen and regular size Source code in prettyqt/widgets/mainwindow.py 187 188 189 190 191 192 193 def toggle_fullscreen ( self ): \"\"\"toggle between fullscreen and regular size \"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen ()","title":"toggle_fullscreen()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea","text":"","title":"mdiarea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea","text":"","title":"MdiArea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_tab_position","text":"returns current tab position Possible values: \"north\", \"south\", \"west\", \"east\" Returns: Type Description str tab position Source code in prettyqt/widgets/mdiarea.py 107 108 109 110 111 112 113 114 115 def get_tab_position ( self ) -> str : \"\"\"returns current tab position Possible values: \"north\", \"south\", \"west\", \"east\" Returns: tab position \"\"\" return TAB_POSITIONS . inv [ self . tabPosition ()]","title":"get_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_view_mode","text":"returns current view mode Possible values: \"default\", \"tabbed\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py 57 58 59 60 61 62 63 64 65 def get_view_mode ( self ) -> str : \"\"\"returns current view mode Possible values: \"default\", \"tabbed\" Returns: view mode \"\"\" return VIEW_MODES . inv [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_window_order","text":"returns current window order Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: Type Description str view mode Source code in prettyqt/widgets/mdiarea.py 82 83 84 85 86 87 88 89 90 def get_window_order ( self ) -> str : \"\"\"returns current window order Possible values: \"creation\", \"stacking\", \"activation_history\" Returns: view mode \"\"\" return WINDOW_ORDERS . inv [ self . activationOrder ()]","title":"get_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_tab_position","text":"set tab position for the MDI area Valid values are \"north\", \"south\", \"west\", \"east\" Parameters: Name Type Description Default position str tabs position to use required Exceptions: Type Description ValueError tab position does not exist Source code in prettyqt/widgets/mdiarea.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def set_tab_position ( self , position : str ): \"\"\"set tab position for the MDI area Valid values are \"north\", \"south\", \"west\", \"east\" Args: position: tabs position to use Raises: ValueError: tab position does not exist \"\"\" if position not in TAB_POSITIONS : raise ValueError ( \"Invalid value for tab position.\" ) self . setTabPosition ( TAB_POSITIONS [ position ])","title":"set_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_view_mode","text":"set view mode for the MDI area Valid values are \"default\", \"tabbed\" Parameters: Name Type Description Default mode str view mode to use required Exceptions: Type Description ValueError view mode does not exist Source code in prettyqt/widgets/mdiarea.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def set_view_mode ( self , mode : str ): \"\"\"set view mode for the MDI area Valid values are \"default\", \"tabbed\" Args: mode: view mode to use Raises: ValueError: view mode does not exist \"\"\" if mode not in VIEW_MODES : raise ValueError ( \"Invalid value for mode.\" ) self . setViewMode ( VIEW_MODES [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_window_order","text":"set the window order behaviour for the MDI area Valid values are \"creation\", \"stacking\", \"activation_history\" Parameters: Name Type Description Default mode str window order behaviour to use required Exceptions: Type Description ValueError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def set_window_order ( self , mode : str ): \"\"\"set the window order behaviour for the MDI area Valid values are \"creation\", \"stacking\", \"activation_history\" Args: mode: window order behaviour to use Raises: ValueError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDERS : raise ValueError ( \"Invalid value for mode.\" ) self . setActivationOrder ( WINDOW_ORDERS [ mode ])","title":"set_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.menu","text":"","title":"menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu","text":"","title":"Menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_action","text":"Add an action to the menu Parameters: Name Type Description Default label Union[str, prettyqt.widgets.action.Action] Label for button required callback Callable gets called when action is triggered None icon Optional[Any] icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut Optional[str] Shortcut for action None status_tip Optional[str] Status tip to be shown in status bar None Returns: Type Description Action Action added to menu Source code in prettyqt/widgets/menu.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 def add_action ( self , label : Union [ str , widgets . Action ], callback : Callable = None , icon : Optional [ Any ] = None , checkable : bool = False , checked : bool = False , shortcut : Optional [ str ] = None , status_tip : Optional [ str ] = None , ) -> widgets . Action : \"\"\"Add an action to the menu Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action","title":"add_action()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_separator","text":"adds a separator showing an optional label Parameters: Name Type Description Default text Optional[str] Text to show on separator None Returns: Type Description WidgetAction Separator action Source code in prettyqt/widgets/menu.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def add_separator ( self , text : Optional [ str ] = None ) -> widgets . WidgetAction : \"\"\"adds a separator showing an optional label Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) label . setStyleSheet ( \"background:lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator = widgets . WidgetAction ( parent = self ) separator . setDefaultWidget ( label ) self . add ( separator ) return separator","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.set_icon","text":"set the icon for the menu Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/menu.py 44 45 46 47 48 49 50 51 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the menu Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox","text":"","title":"messagebox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox","text":"","title":"MessageBox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.add_button","text":"add a default button Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Parameters: Name Type Description Default button str button to add required Returns: Type Description QPushButton created button Exceptions: Type Description ValueError Button type not available Source code in prettyqt/widgets/messagebox.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def add_button ( self , button : str ) -> QtWidgets . QPushButton : \"\"\"add a default button Valid arguments: \"none\", \"cancel\", \"ok\", \"save\", \"open\", \"close\", \"discard\", \"apply\", \"reset\", \"restore_defaults\", \"help\", \"save_all\", \"yes\", \"yes_to_all\", \"no\", \"no_to_all\", \"abort\", \"retry\", \"ignore\" Args: button: button to add Returns: created button Raises: ValueError: Button type not available \"\"\" if button not in BUTTONS : raise ValueError ( \"button type not available\" ) return self . addButton ( BUTTONS [ button ])","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.get_text_format","text":"returns current text format Possible values: \"rich\", \"plain\", \"auto\" Returns: Type Description str text format Source code in prettyqt/widgets/messagebox.py 134 135 136 137 138 139 140 141 142 def get_text_format ( self ) -> str : \"\"\"returns current text format Possible values: \"rich\", \"plain\", \"auto\" Returns: text format \"\"\" return TEXT_FORMATS . inv [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_icon","text":"set the window icon Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/messagebox.py 79 80 81 82 83 84 def set_icon ( self , icon : icons . IconType ): if icon in ICONS : self . setIcon ( ICONS [ icon ]) return None icon = icons . get_icon ( icon ) self . setIconPixmap ( icon . get_pixmap ( size = 64 ))","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_text_format","text":"set the text format Allowed values are \"rich\", \"plain\", \"auto\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description ValueError text format does not exist Source code in prettyqt/widgets/messagebox.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def set_text_format ( self , text_format : str ): \"\"\"set the text format Allowed values are \"rich\", \"plain\", \"auto\" Args: text_format: text format to use Raises: ValueError: text format does not exist \"\"\" if text_format not in TEXT_FORMATS : raise ValueError ( \"Invalid text format\" ) self . setTextFormat ( TEXT_FORMATS [ text_format ])","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit","text":"","title":"plaintextedit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit","text":"","title":"PlainTextEdit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_line_wrap_mode","text":"set line wrap mode Allowed values are \"none\" and \"widget width\" Parameters: Name Type Description Default mode str line wrap mode to use required Exceptions: Type Description ValueError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def set_line_wrap_mode ( self , mode : str ): \"\"\"set line wrap mode Allowed values are \"none\" and \"widget width\" Args: mode: line wrap mode to use Raises: ValueError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODES : raise ValueError ( f \"invalid wrap mode. \" f \"Allowed values: { LINE_WRAP_MODES . keys () } \" ) self . setLineWrapMode ( LINE_WRAP_MODES [ mode ])","title":"set_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_read_only","text":"make the PlainTextEdit read-only Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py 101 102 103 104 105 106 107 def set_read_only ( self , value : bool = True ): \"\"\"make the PlainTextEdit read-only Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_wrap_mode","text":"set word wrap mode Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Parameters: Name Type Description Default mode str word wrap mode to use required Exceptions: Type Description ValueError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def set_wrap_mode ( self , mode : str ): \"\"\"set word wrap mode Allowed values are \"none\", \"word\", \"anywhere\", \"boundary_or_anywhere\" Args: mode: word wrap mode to use Raises: ValueError: wrap mode does not exist \"\"\" if mode not in WRAP_MODES : raise ValueError ( f \"invalid wrap mode. Allowed values: { WRAP_MODES . keys () } \" ) self . setWordWrapMode ( WRAP_MODES [ mode ])","title":"set_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar","text":"","title":"progressbar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar","text":"Progress dialog wrapper for QtWidgets.QProgressBar","title":"ProgressBar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_alignment","text":"returns current alignment Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: Type Description str alignment Source code in prettyqt/widgets/progressbar.py 52 53 54 55 56 57 58 59 60 def get_alignment ( self ) -> str : \"\"\"returns current alignment Possible values: \"left\", \"right\", \"top\", \"bottom\" Returns: alignment \"\"\" return ALIGNMENTS . inv [ self . alignment ()]","title":"get_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_text_direction","text":"returns current text direction Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Type Description str Text direction Source code in prettyqt/widgets/progressbar.py 77 78 79 80 81 82 83 84 85 def get_text_direction ( self ) -> str : \"\"\"returns current text direction Possible values are \"top_to_bottom\", \"bottom_to_top\" Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inv [ self . textDirection ()]","title":"get_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_alignment","text":"set the alignment of the layout Allowed values are \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default alignment str alignment for the layout required Exceptions: Type Description ValueError alignment does not exist Source code in prettyqt/widgets/progressbar.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def set_alignment ( self , alignment : str ): \"\"\"set the alignment of the layout Allowed values are \"left\", \"right\", \"top\", \"bottom\" Args: alignment: alignment for the layout Raises: ValueError: alignment does not exist \"\"\" if alignment not in ALIGNMENTS : raise ValueError ( f \" { alignment !r} not a valid alignment.\" ) self . setAlignment ( ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_text_direction","text":"set the text direction of the layout Allowed values are \"top_to_bottom\", \"bottom_to_top\" Parameters: Name Type Description Default text_direction str text direction for the layout required Exceptions: Type Description ValueError text direction does not exist Source code in prettyqt/widgets/progressbar.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def set_text_direction ( self , text_direction : str ): \"\"\"set the text direction of the layout Allowed values are \"top_to_bottom\", \"bottom_to_top\" Args: text_direction: text direction for the layout Raises: ValueError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise ValueError ( f \" { text_direction !r} not a valid text direction.\" ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ])","title":"set_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.progressdialog","text":"","title":"progressdialog"},{"location":"api/widgets.html#prettyqt.widgets.progressdialog.ProgressDialog","text":"Progress dialog wrapper for QtWidgets.QProgressDialog","title":"ProgressDialog"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy","text":"","title":"sizepolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy","text":"","title":"SizePolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_control_type","text":"returns control type possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: Type Description str control type Source code in prettyqt/widgets/sizepolicy.py 108 109 110 111 112 113 114 115 116 117 118 def get_control_type ( self ) -> str : \"\"\"returns control type possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Returns: control type \"\"\" return CONTROL_TYPES . inv [ self . controlType ()]","title":"get_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_horizontal_policy","text":"returns size policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str horizontal size policy Source code in prettyqt/widgets/sizepolicy.py 64 65 66 67 68 69 70 71 72 73 def get_horizontal_policy ( self ) -> str : \"\"\"returns size policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: horizontal size policy \"\"\" return SIZE_POLICIES . inv [ self . horizontalPolicy ()]","title":"get_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_vertical_policy","text":"returns size policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: Type Description str vertical size policy Source code in prettyqt/widgets/sizepolicy.py 86 87 88 89 90 91 92 93 94 95 def get_vertical_policy ( self ) -> str : \"\"\"returns size policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Returns: vertical size policy \"\"\" return SIZE_POLICIES . inv [ self . verticalPolicy ()]","title":"get_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_control_type","text":"sets the control type possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Parameters: Name Type Description Default mode str control type to set required Source code in prettyqt/widgets/sizepolicy.py 120 121 122 123 124 125 126 127 128 129 130 def set_control_type ( self , mode : str ): \"\"\"sets the control type possible values are \"default\", \"buttonbox\", \"checkbox\", \"combobox\", \"frame\", \"groupbox\", \"label\", \"line\", \"lineedit\", \"pushbutton\", \"radiobutton\", \"slider\", \"spinbox\", \"tabwidget\", \"toolbutton\" Args: mode: control type to set \"\"\" self . setControlType ( CONTROL_TYPES [ mode ])","title":"set_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_horizontal_policy","text":"sets the horizontal policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py 75 76 77 78 79 80 81 82 83 84 def set_horizontal_policy ( self , mode : str ): \"\"\"sets the horizontal policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setHorizontalPolicy ( SIZE_POLICIES [ mode ])","title":"set_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_vertical_policy","text":"sets the horizontal policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default mode str policy to set required Source code in prettyqt/widgets/sizepolicy.py 97 98 99 100 101 102 103 104 105 106 def set_vertical_policy ( self , mode : str ): \"\"\"sets the horizontal policy possible values are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: mode: policy to set \"\"\" self . setVerticalPolicy ( SIZE_POLICIES [ mode ])","title":"set_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.slider","text":"","title":"slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider","text":"","title":"Slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.get_tick_position","text":"returns tick position possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: Type Description str tick position Source code in prettyqt/widgets/slider.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_tick_position ( self ) -> str : \"\"\"returns tick position possible values are \"none\", \"both_sides\", \"above\", \"below\" Returns: tick position \"\"\" val = TICK_POSITIONS . inv [ self . tickPosition ()] # if self.is_vertical(): # if val == \"above\": # return \"left\" # elif val == \"below\": # return \"right\" return val","title":"get_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.set_tick_position","text":"sets the tick position for the slider allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Parameters: Name Type Description Default position str position for the ticks required Source code in prettyqt/widgets/slider.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def set_tick_position ( self , position : str ): \"\"\"sets the tick position for the slider allowed values are \"none\", \"both_sides\", \"above\", \"below\", \"left\", \"right\" for vertical orientation of the slider, \"above\" equals to \"left\" and \"below\" to \"right\" Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITIONS : raise ValueError ( f \" { position } not a valid tick position.\" ) self . setTickPosition ( TICK_POSITIONS [ position ])","title":"set_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.splitter","text":"","title":"splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter","text":"","title":"Splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.get_orientation","text":"returns current orientation Possible values: \"horizontal\", \"vertical\" Returns: Type Description str orientation Source code in prettyqt/widgets/splitter.py 99 100 101 102 103 104 105 106 107 def get_orientation ( self ) -> str : \"\"\"returns current orientation Possible values: \"horizontal\", \"vertical\" Returns: orientation \"\"\" return ORIENTATIONS . inv [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.set_orientation","text":"set the orientation of the splitter Allowed values are \"horizontal\", \"vertical\" Parameters: Name Type Description Default orientation str orientation for the splitter required Exceptions: Type Description ValueError orientation does not exist Source code in prettyqt/widgets/splitter.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def set_orientation ( self , orientation : str ): \"\"\"set the orientation of the splitter Allowed values are \"horizontal\", \"vertical\" Args: orientation: orientation for the splitter Raises: ValueError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise ValueError ( f \" { orientation } not a valid orientation.\" ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider","text":"","title":"styleoptionslider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider","text":"","title":"StyleOptionSlider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_horizontal","text":"check if silder is horizontal Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py 29 30 31 32 33 34 35 def is_horizontal ( self ) -> bool : \"\"\"check if silder is horizontal Returns: True if horizontal, else False \"\"\" return self . orientation == QtCore . Qt . Horizontal","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_vertical","text":"check if silder is vertical Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py 37 38 39 40 41 42 43 def is_vertical ( self ) -> bool : \"\"\"check if silder is vertical Returns: True if vertical, else False \"\"\" return self . orientation == QtCore . Qt . Vertical","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_horizontal","text":"set slider orientation to horizontal Source code in prettyqt/widgets/styleoptionslider.py 45 46 47 48 def set_horizontal ( self ): \"\"\"set slider orientation to horizontal \"\"\" self . orientation = QtCore . Qt . Horizontal","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_vertical","text":"set slider orientation to vertical Source code in prettyqt/widgets/styleoptionslider.py 50 51 52 53 def set_vertical ( self ): \"\"\"set slider orientation to vertical \"\"\" self . orientation = QtCore . Qt . Vertical","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar","text":"","title":"tabbar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar","text":"","title":"TabBar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_elide_mode","text":"returns elide mode possible values are \"left\", \"right\", \"middle\", \"none\" Returns: Type Description str elide mode Source code in prettyqt/widgets/tabbar.py 133 134 135 136 137 138 139 140 141 def get_elide_mode ( self ) -> str : \"\"\"returns elide mode possible values are \"left\", \"right\", \"middle\", \"none\" Returns: elide mode \"\"\" return ELIDE_MODES . inv [ self . elideMode ()]","title":"get_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_remove_behaviour","text":"returns remove behaviour possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: Type Description str remove behaviour Source code in prettyqt/widgets/tabbar.py 108 109 110 111 112 113 114 115 116 def get_remove_behaviour ( self ) -> str : \"\"\"returns remove behaviour possible values are \"left_tab\", \"right_tab\", \"previous_tab\" Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOURS . inv [ self . selectionBehaviorOnRemove ()]","title":"get_remove_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.mouseDoubleClickEvent","text":"mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/widgets/tabbar.py 80 81 82 def mouseDoubleClickEvent ( self , event ): event . accept () self . on_detach . emit ( self . tabAt ( event . pos ()), self . mouse_cursor . pos ())","title":"mouseDoubleClickEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_elide_mode","text":"set elide mode Valid values are \"left\", \"right\", \"middle\", \"none\" Parameters: Name Type Description Default mode str elide mode to use required Exceptions: Type Description ValueError invalid elide mode Source code in prettyqt/widgets/tabbar.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def set_elide_mode ( self , mode : str ): \"\"\"set elide mode Valid values are \"left\", \"right\", \"middle\", \"none\" Args: mode: elide mode to use Raises: ValueError: invalid elide mode \"\"\" if mode not in ELIDE_MODES : raise ValueError ( \"Mode not available\" ) self . setElideMode ( ELIDE_MODES [ mode ])","title":"set_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_icon_size","text":"Set the icon size for the tabs Parameters: Name Type Description Default size int height/width of the icons required Source code in prettyqt/widgets/tabbar.py 84 85 86 87 88 89 90 def set_icon_size ( self , size : int ): \"\"\"Set the icon size for the tabs Args: size: height/width of the icons \"\"\" self . setIconSize ( QtCore . QSize ( size , size ))","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_remove_behaviour","text":"sets the remove hehaviour What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Parameters: Name Type Description Default mode str new remove behaviour required Source code in prettyqt/widgets/tabbar.py 95 96 97 98 99 100 101 102 103 104 105 106 def set_remove_behaviour ( self , mode : str ): \"\"\"sets the remove hehaviour What tab should be set as current when removeTab is called if the removed tab is also the current tab. Possible values: left, right, previous Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOURS : raise ValueError ( \"Mode not available\" ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOURS [ mode ])","title":"set_remove_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget","text":"","title":"tabwidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab","text":"window containing a detached tab When a tab is detached , the contents are placed into this QMainWindow . The tab can be re - attached by closing the dialog !!! attributes on_close : signal , emitted when window is closed ( widget , title , icon )","title":"DetachedTab"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab.closeEvent","text":"closeEvent(self, QCloseEvent) Source code in prettyqt/widgets/tabwidget.py 258 259 def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . id , self . windowIcon ())","title":"closeEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget","text":"Widget for managing the tabs section","title":"TabWidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.attach_tab","text":"Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget @param widget the content widget from the DetachedTab window @param name the name of the detached tab @param icon the window icon for the detached tab @param insert_at insert the re-attached tab at the given index Source code in prettyqt/widgets/tabwidget.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def attach_tab ( self , widget , name : str , icon : icons . IconType = None , insert_at : Optional [ int ] = None , ): \"\"\" Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget @param widget the content widget from the DetachedTab window @param name the name of the detached tab @param icon the window icon for the detached tab @param insert_at insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True )","title":"attach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.close_detached_tabs","text":"Close all tabs that are currently detached Source code in prettyqt/widgets/tabwidget.py 210 211 212 213 214 def close_detached_tabs ( self ): \"\"\"Close all tabs that are currently detached \"\"\" for detached_tab in self . detached_tabs . values (): detached_tab . close ()","title":"close_detached_tabs()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.detach_tab","text":"Detach the tab by removing it's contents and placing them in a DetachedTab window @param index index location of the tab to be detached @param point screen pos for creating the new DetachedTab window Source code in prettyqt/widgets/tabwidget.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 @core . Slot ( int , QtCore . QPoint ) def detach_tab ( self , index : int , point : QtCore . QPoint ): \"\"\" Detach the tab by removing it's contents and placing them in a DetachedTab window @param index index location of the tab to be detached @param point screen pos for creating the new DetachedTab window \"\"\" # Get the tab content name = self . tabText ( index ) icon = self . tabIcon ( index ) if icon . isNull (): icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab","title":"detach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_shape","text":"returns tab shape possible values are \"roundes\", \"triangular\" Returns: Type Description str tab shape Source code in prettyqt/widgets/tabwidget.py 94 95 96 97 98 99 100 101 102 def get_tab_shape ( self ) -> str : \"\"\"returns tab shape possible values are \"roundes\", \"triangular\" Returns: tab shape \"\"\" return TAB_SHAPES . inv [ self . tabShape ()]","title":"get_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.open_widget","text":"create a tab containing delivered widget Source code in prettyqt/widgets/tabwidget.py 223 224 225 226 227 228 @core . Slot ( object , str ) def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\" create a tab containing delivered widget \"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True )","title":"open_widget()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_shape","text":"set tab shape for the tabwidget Valid values are \"rounded\" and \"triangular\" Parameters: Name Type Description Default shape str tab shape to use required Exceptions: Type Description ValueError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def set_tab_shape ( self , shape : str ): \"\"\"set tab shape for the tabwidget Valid values are \"rounded\" and \"triangular\" Args: shape: tab shape to use Raises: ValueError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise ValueError ( \"Invalid value for shape.\" ) self . setTabShape ( TAB_SHAPES [ shape ])","title":"set_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar","text":"","title":"toolbar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar","text":"","title":"ToolBar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.add_separator","text":"adds a separator showing an optional label Parameters: Name Type Description Default text Optional[str] Text to show on separator None before QAction insert separator before specific action None Returns: Type Description QAction Separator action Source code in prettyqt/widgets/toolbar.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def add_separator ( self , text : Optional [ str ] = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"adds a separator showing an optional label Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) label . setStyleSheet ( \"background:lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label )","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.get_style","text":"returns current style Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: Type Description str style Source code in prettyqt/widgets/toolbar.py 84 85 86 87 88 89 90 91 92 def get_style ( self ) -> str : \"\"\"returns current style Possible values: \"icon\", \"text\", \"text_below_icon\", \"text_beside_icon\" Returns: style \"\"\" return STYLES . inv [ self . toolButtonStyle ()]","title":"get_style()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.is_area_allowed","text":"check if toolbar is allowed at specified area Valid values for area: \"left\", \"right\", \"top\", \"bottom\" Parameters: Name Type Description Default area str area of the toolbar required Exceptions: Type Description ValueError area does not exist Source code in prettyqt/widgets/toolbar.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def is_area_allowed ( self , area : str ): \"\"\"check if toolbar is allowed at specified area Valid values for area: \"left\", \"right\", \"top\", \"bottom\" Args: area: area of the toolbar Raises: ValueError: area does not exist \"\"\" if area not in TOOLBAR_AREAS : raise ValueError ( \"Area not existing\" ) return self . isAreaAllowed ( TOOLBAR_AREAS [ area ])","title":"is_area_allowed()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton","text":"","title":"toolbutton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton","text":"","title":"ToolButton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_arrow_type","text":"returns arrow type possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: Type Description str arrow type Source code in prettyqt/widgets/toolbutton.py 91 92 93 94 95 96 97 98 99 def get_arrow_type ( self ) -> str : \"\"\"returns arrow type possible values are \"none\", \"up\", \"down\", \"left\", \"right\" Returns: arrow type \"\"\" return ARROW_TYPES . inv [ self . arrowType ()]","title":"get_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_popup_mode","text":"returns popup mode possible values are \"delayed\", \"menu_button\", \"instant\" Returns: Type Description str popup mode Source code in prettyqt/widgets/toolbutton.py 66 67 68 69 70 71 72 73 74 def get_popup_mode ( self ) -> str : \"\"\"returns popup mode possible values are \"delayed\", \"menu_button\", \"instant\" Returns: popup mode \"\"\" return POPUP_MODES . inv [ self . popupMode ()]","title":"get_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_arrow_type","text":"sets the arrow type of the toolbutton valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Parameters: Name Type Description Default mode str arrow type to use required Exceptions: Type Description ValueError invalid arrow type Source code in prettyqt/widgets/toolbutton.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def set_arrow_type ( self , mode : str ): \"\"\"sets the arrow type of the toolbutton valid values are: \"none\", \"up\", \"down\", \"left\", \"right\" Args: mode: arrow type to use Raises: ValueError: invalid arrow type \"\"\" if mode not in ARROW_TYPES : raise ValueError ( \"Invalid arrow type.\" ) self . setArrowType ( ARROW_TYPES [ mode ])","title":"set_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_popup_mode","text":"sets the popup mode of the toolbutton valid values are: \"delayed\", \"menu_button\", \"instant\" Parameters: Name Type Description Default mode str popup mode to use required Exceptions: Type Description ValueError invalid popup mode Source code in prettyqt/widgets/toolbutton.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def set_popup_mode ( self , mode : str ): \"\"\"sets the popup mode of the toolbutton valid values are: \"delayed\", \"menu_button\", \"instant\" Args: mode: popup mode to use Raises: ValueError: invalid popup mode \"\"\" if mode not in POPUP_MODES : raise ValueError ( \"Invalid mode.\" ) self . setPopupMode ( POPUP_MODES [ mode ])","title":"set_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem","text":"","title":"treewidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem","text":"","title":"TreeWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_checkstate","text":"returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: Type Description str checkstate Source code in prettyqt/widgets/treewidgetitem.py 66 67 68 69 70 71 72 73 74 def get_checkstate ( self ) -> str : \"\"\"returns checkstate possible values are \"unchecked\", \"partial\", \"checked\" Returns: checkstate \"\"\" return STATES . inv [ self . checkState ( 0 )]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_checkstate","text":"set checkstate of the checkbox valid values are: unchecked, partial, checked Parameters: Name Type Description Default state str checkstate to use required Exceptions: Type Description ValueError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def set_checkstate ( self , state : str ): \"\"\"set checkstate of the checkbox valid values are: unchecked, partial, checked Args: state: checkstate to use Raises: ValueError: invalid checkstate \"\"\" if state not in STATES : raise ValueError ( \"Invalid checkstate.\" ) self . setCheckState ( 0 , STATES [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_icon","text":"set the icon for the action Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/treewidgetitem.py 42 43 44 45 46 47 48 49 def set_icon ( self , icon : icons . IconType ): \"\"\"set the icon for the action Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon ) self . setIcon ( 0 , icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget","text":"","title":"widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget","text":"","title":"Widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_contextmenu_policy","text":"returns current contextmenu policy Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\", \"showhide_menu\" Returns: Type Description str contextmenu policy Source code in prettyqt/widgets/widget.py 310 311 312 313 314 315 316 317 318 319 def get_contextmenu_policy ( self ) -> str : \"\"\"returns current contextmenu policy Possible values: \"none\", \"prevent\", \"default\", \"actions\", \"custom\", \"showhide_menu\" Returns: contextmenu policy \"\"\" return POLICIES . inv [ self . contextMenuPolicy ()]","title":"get_contextmenu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_modality","text":"get the current modality modes as a string Possible values: \"modeless\", \"window\", \"application\" Returns: Type Description str modality mode str Source code in prettyqt/widgets/widget.py 236 237 238 239 240 241 242 243 244 245 def get_modality ( self ) -> str : \"\"\"get the current modality modes as a string Possible values: \"modeless\", \"window\", \"application\" Returns: modality mode str \"\"\" return MODALITIES . inv [ self . windowModality ()]","title":"get_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.resize","text":"resize(self, QSize) resize(self, int, int) Source code in prettyqt/widgets/widget.py 103 104 105 106 107 def resize ( self , * size ): if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size )","title":"resize()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_contextmenu_policy","text":"set contextmenu policy for given item view Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\", \"showhide_menu\" Parameters: Name Type Description Default policy str contextmenu policy to use required Exceptions: Type Description ValueError policy does not exist Source code in prettyqt/widgets/widget.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def set_contextmenu_policy ( self , policy : str ): \"\"\"set contextmenu policy for given item view Allowed values are \"none\", \"prevent\", \"default\", \"actions\", \"custom\", \"showhide_menu\" Args: policy: contextmenu policy to use Raises: ValueError: policy does not exist \"\"\" if policy not in POLICIES : raise ValueError ( \"invalid selection behaviour\" ) self . setContextMenuPolicy ( POLICIES [ policy ])","title":"set_contextmenu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_icon","text":"set the window icon Parameters: Name Type Description Default icon Optional[Union[PyQt5.QtGui.QIcon, str, pathlib.Path]] icon to use required Source code in prettyqt/widgets/widget.py 109 110 111 112 113 114 115 116 def set_icon ( self , icon : icons . IconType ): \"\"\"set the window icon Args: icon: icon to use \"\"\" icon = icons . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_modality","text":"set modality for the dialog Valid values for modality: \"modeless\", \"window\", \"application\" Parameters: Name Type Description Default modality str modality for the main window 'window' Exceptions: Type Description ValueError modality type does not exist Source code in prettyqt/widgets/widget.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def set_modality ( self , modality : str = \"window\" ): \"\"\"set modality for the dialog Valid values for modality: \"modeless\", \"window\", \"application\" Args: modality: modality for the main window Raises: ValueError: modality type does not exist \"\"\" if modality not in MODALITIES : raise ValueError ( \"Invalid value for modality.\" ) self . setWindowModality ( MODALITIES [ modality ])","title":"set_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_size_policy","text":"sets the sizes policy possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Parameters: Name Type Description Default horizontal Optional[str] horizontal size policy None vertical Optional[str] vertical size policy None Source code in prettyqt/widgets/widget.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def set_size_policy ( self , horizontal : Optional [ str ] = None , vertical : Optional [ str ] = None ): \"\"\"sets the sizes policy possible values for both parameters are \"fixed\", \"minimum\", \"maximum\", \"preferred\", \"expanding\", \"minimum_expanding\" and \"ignored\" Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp )","title":"set_size_policy()"}]}