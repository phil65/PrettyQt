{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"prettyqt: Pythonic layer on top of PyQt5 / PySide2 What is it? PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PySide2. Main Features Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module. Where to get it The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt Dependencies qtpy qtawesome bidict orjson regex docutils Installation from sources This project uses poetry for dependency management and packaging. Install this first. In the prettyqt directory (same one where you found this file after cloning the git repo), execute: poetry install License MIT Documentation The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/ Contributing to prettyqt All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Home"},{"location":"index.html#prettyqt-pythonic-layer-on-top-of-pyqt5-pyside2","text":"","title":"prettyqt: Pythonic layer on top of PyQt5 / PySide2"},{"location":"index.html#what-is-it","text":"PrettyQt is a Python package that provides a pythonic layer on top of the GUI frameworks PyQt5 / PySide2.","title":"What is it?"},{"location":"index.html#main-features","text":"Here are just a few of the things that PrettyQt does well: Large parts of the Qt API are available in a PEP-8 -compliant way. Several predefined widgets, validators, models, syntax highlighters are included. A regex module based on QRegularExpression with the same API as Pythons core re module.","title":"Main Features"},{"location":"index.html#where-to-get-it","text":"The source code is currently hosted on GitHub at: https://github.com/phil65/PrettyQt The latest released version are available at the Python package index . # or PyPI pip install prettyqt","title":"Where to get it"},{"location":"index.html#dependencies","text":"qtpy qtawesome bidict orjson regex docutils","title":"Dependencies"},{"location":"index.html#installation-from-sources","text":"This project uses poetry for dependency management and packaging. Install this first. In the prettyqt directory (same one where you found this file after cloning the git repo), execute: poetry install","title":"Installation from sources"},{"location":"index.html#license","text":"MIT","title":"License"},{"location":"index.html#documentation","text":"The official documentation is hosted on Github Pages: https://phil65.github.io/PrettyQt/","title":"Documentation"},{"location":"index.html#contributing-to-prettyqt","text":"All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Or maybe through using PrettyQt you have an idea of your own or are looking for something in the documentation and thinking \u2018this can be improved\u2019...you can do something about it!","title":"Contributing to prettyqt"},{"location":"changelog.html","text":"v0.162.0 (2020-12-27) Feat FontDatabase : add additional check in add_font Painter : add offset_by and apply_transform context managers Fix IconWidget : update when setting size v0.161.0 (2020-12-26) Feat LineEdit : add add_action method ListView/TableView : add some more setters / getters Painter : add edit_pen context manager PolygonF : alternative ctors for diamond / star creation Fix LabeledSlider : call adjust_margins on correct object correct IconProvider init v0.160.0 (2020-12-25) Feat gui : add TextLine module Doublevalidator : add set_range method IntValidator : add set_range method Pixmap : add eq method v0.159.0 (2020-12-24) Feat LineEdit : add set/get_cursor_move_style methods v0.158.0 (2020-12-22) Feat iconprovider : add reset_cache method Widget : add set/get_foreground/background_role methods Application/Widget : add set/get_stylesheet methods Application : add edit_stylesheet context manager v0.157.1 (2020-12-22) Fix SpanSlider fix v0.157.0 (2020-12-22) Feat Painter : add native_mode context manager FontDatabase : add add_font method gui : add IconEngine class TabWidget : add set_icon_size method Icon : allow more types for size param v0.156.0 (2020-12-21) Feat RegularExpressionMatch : add bool method custom_widgets : add ObjectBrowser class Timer : add restart method ListView : add set_grid_size method SortFilterProxyModel : add is/set_filter_case_sensitive methods AbstractItemView : add set_icon_size method v0.155.0 (2020-12-20) Feat Label : add get_horizontal/vertical_alignment methods GraphicsWidget : add window_frame_section_at method v0.154.0 (2020-12-18) Feat add QtLocation and QtHelp to qt submodule Dir/FileDialog : add get/set_filter methods InputDialog : add get/set_input_mode and get/set_text_echo_mode methods Fix correct StarDelegate setModelData call v0.153.0 (2020-12-17) Feat MediaPlayer : add get_error method v0.152.1 (2020-12-17) Fix PySide2 workaround for non-recursive Object.findChild(ren) v0.152.0 (2020-12-16) Feat Standarditem/StandardItemModel : add enabled and editable kwarg to add_item methods AbstractItemView : add get/set_drag_drop_mode methods v0.151.0 (2020-12-16) Feat ToolBar : add add method Icon : add get_actual_size method winextras : add WinThumbnailToolButton class ToolButton : add set_menu method Uuid : add str method Fix PySide2 find_child(ren) fix v0.150.0 (2020-12-15) Feat Movie : add get_state method v0.149.0 (2020-12-15) Feat add HoverIconEventFilter class positioning : add GeoPositionInfo class Icon : add mode and state kwarg for add/get_pixmap widget : add set_mask method core : add FileSystemWatcher class Palette : add get/set_color_group methods Brush : add some addtional methods Region : add some additional methods custom_delegates : add RenderLinkDelegate class TableWidgetItem : add set_text_alignment method Gradients : add repr and some helper methods to gradient classes Fix PySide2 workaround for missing recursive param in findChild(ren) WebEngineHistory len fix for PySide2 CategoryAxis len fix for PySide2 correctly inherit LCDNumber v0.148.0 (2020-12-14) Feat Widget : add get/set_window_state methods AbstractTextDocumentLayout : add tuple support for hit_test point arg TimeZone : add get_display_name method GuiApplication : add get/set_high_dpi_scale_factor_rounding_policy methods StandardItem : add some new methods AbstractButton : add get_icon method StandardItemModel : add add_item method StandardItem : add get/set_checkstate methods Window : add start_system_resize method v0.147.2 (2020-12-14) Fix MacOs test fix v0.147.1 (2020-12-14) Fix MacOs test fix v0.147.0 (2020-12-13) Feat ToolBar : add get_allowed_areas method WebEnginePage : add some additional methods WebEngineSettings : add delitem method Application : add send/post_event methods v0.146.0 (2020-12-13) Fix correctly serialize AbstractGraphicsShapeItem Feat GuiApplication : add get_icon method PlainTextEdit : add get(_line)_wrap_mode methods GuiApplication : add get_application_state method v0.145.0 (2020-12-11) Fix GraphicsGridLayout : serialize correctly MediaRecorder : use correct module in set_video/audio_settings correct constant naming install_exceptionhook fix Feat GridLayout : add get/set_origin_corner methods BoxLayout : add get/set_direction methods NetworkCookieJar : add add and set_cookies_from_url methods NetworkCookie : add set_expiration_date method Translator : add bool method custom_widgets : add RoundProgressBar class DateTimeEdit : add some more methods related to sections get/set_icon_size work for some widgets CalendarWidget : add set_range method HeaderView : add generate_header_id method Widget : add edit_palette contextmanager and get_font method Palette : add brush methods custom_models : add ImportlibDistributionModel class v0.144.0 (2020-12-09) Fix Settings : iter through key-value pairs correct inheritance for QuickItem ColumnItemModel : correct get_width signature Feat qml : add QmlImageProviderbase class widgets : add TreeWidgetItemIterator class quick : add some more classes qml : add QmlParserStatus class Widget : add get_title method Painter : add get_text_rect method ListWidget : add add_item method v0.143.0 (2020-12-08) Fix ObjectBrowser fix Feat implement eq method for some more validator classes v0.142.1 (2020-12-07) Fix use our own SizeF class v0.142.0 (2020-12-07) Feat SizeF : add some methods to be on par with Size Size : add expanded_to method CompositeValidator : add some additional methods custom_validators : add eq method to validator classes TreeWidgetItem : add some more methods widgets : add TableWidgetSelectionRange class core : add Calendar class core : add SignalMapper class core : add StateMachine class core : add LockFile class core : add JsonDocument/JsonValue classes GeoCircle : allow tuple in ctor core : add SocketNotifier class widgets : add Shortcut class Fix Correctly inherit StyleItemDelegate v0.141.0 (2020-12-03) Feat core : add Collator(SortKey) classes Fix github actions fix v0.140.4 (2020-12-02) Fix docs build fix v0.140.3 (2020-12-02) Fix docs deployment v0.140.2 (2020-12-02) Fix deploy check for github actions v0.140.1 (2020-12-02) Fix github actions: conditional deploy step v0.140.0 (2020-12-02) Feat gui : add ColorSpace class v0.139.0 (2020-12-02) Feat FileInfo/Dir : fallback to pathlib.Path methods widgets : add Proxy/CommonStyle classes widgets : add Gesture classes core : add TemporaryDir class widgets : add WhatsThis class core : add ItemSelectionRange class FormLayout : add some more methods core : add ProcessEnvironment class gui : add StaticText class core : add PauseAnimation class v0.138.0 (2020-12-01) Feat core : add ChildEvent / TimerEvent classes core : add IdentityProxyModel class gui : add SessionManager class gui : add InputMethod class core : add AbstractEventDispatcher class widgets : add StackedWidget class widgets : add some events FileInfo : add some additional methods gui : add Vector3D class core : add MimeType / MimeDatabase classes core : add SaveFile class core : add SignalBlocker class core : add TimeLine class gui : add Bitmap class core : add RandomGenerator class FileDevice : add get_error method widgets : add Dial class widgets : add RubberBand class Wizard/WizardPage : add some more methods widgets : add GraphicsRotation / GraphicsScale classes widgets : add GraphicsTransform class widgets : add LCDNumber class widgets : add Scroller(Properties) classes core : add CommandLineParser/Option classes Pixmap : add some more methods gui : add Screen class Transform : add some more methods add Abstract/PlainTextTextDocumentLayout classes core : add BasicTimer class core : add Resource class core : add StorageInfo class core : add ElapsedTimer class core : add CryptographicHash class v0.137.1 (2020-11-27) Fix doc build fix v0.137.0 (2020-11-27) Feat core : add OperatingSystemVersion class PdfWriter : add set_page_margins method core : add MarginsF class core : Add TextStream class core : add ByteArrayMatcher AbstractItemModel : add check_index method PlaceManager : add search_place method core : add app method add bytes method to some classes utils : add Singleton metaclass icon : add add_pixmap method gui : Add PixmapCache Font : add some more methods v0.136.0 (2020-11-26) Feat location : add PlaceResult class location : add PlaceProposedSearchResult class location : add clone_from method to reply classes Object : add has_id method Fix emit inputandslider signal correctly on value change correct flag for constants.NO_CHILDREN v0.135.0 (2020-11-26) Feat WebEngineHistoryItem : add get_icon_url method location : add PlaceMatchReply / PlaceIdReply classes PlaceContentReply/PlaceSearchReply : add request methods gui : add TextListFormat class gui : add TextImageFormat class location : add some reply/result classes gui : add TextTableCellFormat class gui : add app method gui : add TextFrameFormat class Application : add get_font method add qthelp module quick : add QuickPaintedItem class gui : add TextBlockGroup class TextCharFormat : add get/set_vertical_alignment methods TextBlock : add contains method PaintDevice : add get_metric method GuiApplication : add get/set_layout_direction methods gui : add TextObject / TextLength / TextFrame / TextFormat classes core : add ItemSelection class GraphicsLayout : add set_margin method Fix correctly add items for GraphicsGridLayout v0.134.0 (2020-11-23) Feat core : add PersistentModelIndex class core : add PluginLoader class core : add Library class gui : add PainterPathStroker class gui : add ImageWriter / ImageReader / ImageIOHandler classes quick : add QuickItem / QuickWindow classes core : add install_message_handler method gui : add RasterWindow / PaintDeviceWindow / OpenGLWindow classes svg : add SvgGenerator class SplashScreen : allow pixmap for ctor icon : add get_available_sizes method widget : add set_attributes method gui : add Vector4D / Matrix4x4 classes custom_widgets : add StarDelegate class custom_delegates : add ProgressBarDelegate class widgets : add missing StyleOption classes WidgetItems : some more methods Painter : add backup_state contextmanager Fix KeySequenceEdit : correct repr correct coloring for WaitingSpinner v0.133.1 (2020-11-16) Fix test fix v0.133.0 (2020-11-16) Feat ComboBox : default param for add_items AbstractItemModel : add force_reset/force_layoutchange methods add location module gui : add FontMetricsF class GeoCoordinate : add bool method FontMetrics : add get_(tight_)bounding_rect methods Url : add to_string method network : add LocalServer / TcpServer classes multimediawidgets : add GraphicsVideoItem class mediaobject : add get_availability method add qt module v0.132.1 (2020-11-07) Fix import fix v0.132.0 (2020-11-07) Feat NetworkAccessManager : allow str for request network : add UdpSocket network : add NetworkAddressEntry / NetworkInterface classes add texttospeech module network : add NetworkDatagram class core : add DeadlineTimer class network : add HostAddress/AbstractSocket/TcpSocket classes network : add NetworkProxy class network : add HttpMultiPart class network : add HttpPart class NetworkRequest : add set/get_header methods v0.131.0 (2020-11-04) Feat webenginecore : add WebEngineHttpRequest class webenginewidgets : add WebEngineContextMenuData class webenginewidgets : add WebEngineScriptCollection class multimedia : add CameraExposure/CameraImageProcessing classes multimedia : add CameraFocus(Zone) classes webenginecore : add WebEngineUrlSchemeHandler v0.130.0 (2020-11-04) Feat WebEnginePage : add some settings methods webenginewidgets : add WebEngineSettings class add bluetooth module core : add Uuid class add quick module gui : add Surface and Window class multimedia : add ImageEncoderSettings multimedia : add MediaTimeRange and MediaTimeInterval classes v0.129.1 (2020-10-29) Fix fix tests fix multimedia tests for Travis Feat charts : add Legend class WebEnginePage : add get_history method qml : add JSValue(Iterator) class VideoWidget : option for fullscreen toggling via double click multimedia : add CameraViewFinderSettings multimedia : add VideoFrame class multimedia : add AbstractPlanarVideoBuffer class multimedia : add AbstractVideoBuffer class multimedia : add Camera class multimedia : add CameraInfo class gui : add Clipboard class multimedia : add AudioFormat class multimedia : add SoundEffect class charts : add PieSlice class charts : add BoxSet and CandlestickSet classes charts : add Axis-related classes charts : add BarSeries-related classes v0.128.1 (2020-10-25) Fix import fix v0.128.0 (2020-10-25) Feat custom_widgets : add ExpandableLine class ParallelAnimationGroup : add set_duration method charts : add Abstract/ValueAxis and PolarChart classes core : add SequentialAnimationGroup class AnimationGroup : allow slicing for indexing AnimationGroup : add add_property_animation method ChartView : add get/set_rubber_band methods Chart : add some more methods core : add Locale class core : add Margins class webenginewidgets : add some more modules Fix Chart : properly inherit from GraphicsWidget v0.127.1 (2020-10-20) Fix fix tests v0.127.0 (2020-10-20) Fix always import correct bindings for winextras module Url : allow initializing without arg Feat PainterPath : add set_fill_rule method PainterPath : add get_bounding_rect method GraphicsItem : add get_shape method MediaPlaylist : add get_media_url method start with webenginecore module core : add EventLoop class Widget : add get_font_info method custom_models : add PlaylistModel Translator : add get_file_path method add positioning module add some first QtQml classes core : add LibraryInfo class Application : add iter method Application : add get/set_navigation_mode methods Application : add get/is_effect_enabled methods custom_widgets : add Player class v0.126.0 (2020-10-08) Feat core : add Process class DateTime : add get/set_time_spec and get_date/time methods core : add Time class DateTime : add timezone methods core : add TimeZone class Pixmap : add create_dot classmethod v0.125.1 (2020-10-07) Fix import fix v0.125.0 (2020-10-07) Feat widgets : add Transition classes core : add Transition classes Fix fix Action.get_shortcut for NoneValue v0.124.0 (2020-10-05) Feat IODevice : add get_open_mode method Improve repr and add str method for Date and DateTime core : add TemporaryFile class FileDevice : add set/get_file_time methods MainWindow : allow setting central widget to None AbstractButton : add get_shortcut method Url : add from_user_input method WebEngineView : add get_url method FileInfo : support pathlib + add proper repr KeySequence : allow initializing with standard keys v0.123.1 (2020-09-29) Fix add missing State import in core module v0.123.0 (2020-09-29) Feat core : add State classes core : add TextBoundaryFinder class ProgressBar : add get/set_orientation methods + serialize work Action : allow setting callback with ctor WebEngineView : set subclassed WebEnginePage by default WebEnginePage : add some more methods and constants AbstractSlider : add get/set_orientation methods core : add FileInfo class webenginewidgets : add WebEngineProfile class v0.122.1 (2020-09-27) Fix use correct icon names v0.122.0 (2020-09-27) Feat gui : add PageLayout gui : add Movie class gui : add PageSize class gui : add FontInfo class core : add UrlQuery class add network module PropertyAnimation : add get/set_property_name methods core : add ParallelAnimationGroup widgets : add SizeGrip class widgets : add DataWidgetMapper class core : add StringListModel VersionNumber : add get_python_version gui : add Transform class Painter : add draw_polygon method add core.ByteArray v0.121.0 (2020-09-10) Feat Image : add setitem / getitem methods Line/LineF : add reversed and abs methods GraphicsScene : add get/set_item_index_method method Fix serialization fixes v0.120.0 (2020-08-27) Feat GraphicsWidget : add set_layout method GraphicsLayout : add some magic methods GraphicsScene : add add_item_group method widgets : add GraphicsAnchorLayout / GraphicsGridLayout / GraphicsLinearLayout widgets : add GraphicsItemGroup Layout : add delitem method Polygon/PolygonF : add repr and iter methods PainterPath : some additional methods GraphicsItems : add repr methods Line/LineF : add repr and iter Application : allow loading included language files via load_language_file widgets : add GraphicsView class Refactor PromptLineEdit rework v0.119.1 (2020-08-24) Fix add missing StyleOptionComplex class v0.119.0 (2020-08-24) Feat GraphicsScene : add some convenience methods widgets : add graphicsitem classes StylePainter : add draw_complex_control method gui : allow pickling some more classes core : add LineF class Widget : add get_palette() method widgets : add GraphicsPixmapItem / GraphicsScene GraphicsItem : add getitem and setitem methods widgets : add Blur/Colorize/DropShadowEffect Fix Graphicsitem collides methods fix KeySequence : pickling v0.118.2 (2020-08-17) Fix Fix tests v0.118.1 (2020-08-17) Fix MenuBar : fix add method v0.118.0 (2020-08-17) Refactor MenuBar : return subclassed types instead of qt classes Feat gui : add TextDocument / TextBlock / TextOption gui : add ConicalGradient / RadialGradient custom_widgets : add CollapsibleFrame GraphicsItem : add some more methods v0.117.0 (2020-08-16) Feat MimeData : add dict-like interface Timer : add get/set_type methods File : add repr and str methods Dir : add repr and truediv methods Frame : set/get_frame_shape, set/get_frame_shadow Splitter : add setitem method, and some more typing Polygon/PolygonF : pythonize core : add Abstract/Variant/PropertyAnimation and AnimationGroup core : add EasingCurve StyleOptionSlider : add get_orientation method Refactor SpanSlider : clean up code v0.116.0 (2020-08-13) Feat gui : add LinearGradient AbstractSlider : add get/set_repeat_action and trigger_action methods TabWidget : add get/set_tab_position methods Image/Pixmap : add bool method MenuBar : serialize stuff MdiArea : serialize stuff Brush : allow pickling + add get_texture_image method custom_widgets : add Timeline Pen : add methods for setting and getting style / join style / cap style Refactor Painter : rework set_pen / get_pen v0.115.0 (2020-08-12) Feat Polygon : add add_points method Object : add store_widget_states / restore_widget_states Painter : add paint_on, set_transparent_background, set_brush PainterPath : add add_rect method Application : add class_getitem Fix RegexEditor : correctly initialize dialog v0.114.1 (2020-08-12) Fix HeaderView : fix saving state v0.114.0 (2020-08-12) Refactor use AutoSlot decorator Feat add autoslot decorator add prettyqt.debug v0.113.0 (2020-08-10) Feat gui : add PainterPath class gui : add Polygon class gui : palette improvements core : add Line class core : add TransposeProxyModel / ConcatenateTablesProxyModel add ObjectBrowser widgets : add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect Action : \"checked\" param for ctor gui : some magic methods + get_matches for KeySequence core : allow pickling VersionNumber / Size / Dir gui : add Gradient class add ColumnItemModel / ColumnItem Settings : add set_values method Widget : spacing kwarg for set_layout Refactor add serialization stuff improve some repr methods v0.112.0 (2020-08-04) Feat utils : add install_exceptionhook method FileSystemModel : add some more shortcuts for set_root_path core : add VersionNumber class Application : add get_icon method MessageBox : add show_exception method Refactor improve compat with older Qt Versions Fix another test fix v0.111.1 (2020-08-03) Fix fix tests for Linux v0.111.0 (2020-08-03) Feat widgets : add FontComboBox StandardPaths : add class_getitem method Action : some more ctor kwargs Action : add get/set_menu_role methods, some pickle work Refactor custom Exception for wrong params Fix Menu : disable separator widgetAction v0.110.2 (2020-08-03) Fix fix broken LogTextEdit v0.110.1 (2020-08-03) Fix LogTextEdit : improve exception handling SidebarWidget : some fixes related to set_marker v0.110.0 (2020-08-02) Refactor improve serialization for listitems Validator pickle work Feat Image : allow pickling DataStream : add create_bytearray / write_bytearray / copy_data methods core : add DataStream class v0.109.0 (2020-08-02) Feat widget : add pretty method for devtools GridLayout : allow adding tuples/lists Refactor rework widget pickling move CheckboxDelegate to custom_delegates pickle stuff for undocommand v0.108.0 (2020-07-31) Feat custom_delegates : add IconDelegate and NoFocusDelegate TableWidet : add getitem and setitem methods Icon : add from_image method allow str for layout. getitem (uses objectName) SidebarWidget : add set_marker method Refactor move delegates to separate module v0.107.0 (2020-07-29) Feat GridLayout : also allow adding LayoutItems via add method v0.106.1 (2020-07-29) Fix TabWidget : correctly close detached tabs on app close pickle fixes for toolbar and dockwidget PygmentsHighlighter : catch pygments KeyError v0.106.0 (2020-07-26) Feat gui : add DesktopServices class multimedia : add AudioRecorder class core : add StandardPaths class widgets : add Undo classes v0.105.0 (2020-07-24) Feat MediaRecorder : some new methods sort_by_column for tableview and treeview multimedia : dict-setter and getter for encodersettings Refactor improve Url-Pathlib interoperability Fix PopupInfo : use PrimaryScreen geometry instead of screens[0] for positioning v0.104.0 (2020-07-23) Feat multimedia : add MediaRecorder AbstractItemModel : add getitem method multimedia : add VideoEncoderSettings / AudioEncoderSettings Refactor use subclassed core.Size v0.103.0 (2020-07-22) Feat ActionGroup : add getitem method MediaContent : add get_url method add multimediawidgets module add multimedia module PlainTextEdit : add allow_wheel_zoom method Object : name kwarg for find_parent method v0.102.0 (2020-07-21) Refactor move raise_dock to from Widget to Object SidebarWidget : some code cleanup, make settings button size configurable Widget : default state to True for set_attribute MainWindow : add return value for load_window_state Feat Object : add find_parent method PlainTextEdit : add style kwarg to set_syntaxhighlighter v0.101.1 (2020-07-20) Fix LogTextEdit : better integrate with custom qstylesheets v0.101.0 (2020-07-20) Feat MessageBox : add detail_text keyword argument to message method Fix correct return type for gui.icon.get_icon v0.100.0 (2020-07-20) Feat ToolTip : add show_text method GuiApplication : add set_override_cursor / restore_override_cursor methods GuiApplication : add override_cursor context manager v0.99.0 (2020-07-18) Refactor FileChooserButton : typing and fixes Dataset : typing and fixes SidebarWidget : use button map instead of attaching button to widget Feat AbstractItemView : add scroll_to method v0.98.5 (2020-07-17) Perf add icon cache Refactor use core.Settings for windows dark mode detection v0.98.4 (2020-07-15) Fix use qta default icon color instead of black for default v0.98.3 (2020-07-15) Refactor properly set stylesheets by using contextmanager FontDialog : do not override current_font contextmanager move current_font context manager to Widget class v0.98.2 (2020-07-15) Fix package name v0.98.1 (2020-07-15) Fix correctly reset stylesheet for widget validation background Refactor use qstylizer for stylesheet editing v0.98.0 (2020-07-15) Feat widgets : add StyleFactory Refactor FontDatabase : make add_fonts_from_folder a classmethod v0.97.0 (2020-07-15) Feat gui : add FontDatabase widgets : add Completer widgets : add ActionGroup v0.96.0 (2020-07-14) Feat SelectionWidget : default keyword argument for add_custom v0.95.0 (2020-07-14) Feat SelectionWidget : different options for custom type add PagedPaintDevice Widget : add set_margin method v0.94.0 (2020-07-14) Feat Widget : add Widget.font_metrics() SpacerItem : allow strings for size policy in ctor allow Mapping for listwidget.add_items Refactor change to {value: label} dicts for FlagSelectionWidget.add_items v0.93.1 (2020-07-14) Refactor typecheck for Mapping instead of dict for combobox / selectionwidget add_items method v0.93.0 (2020-07-14) Feat add register_extensions function to settings module Refactor Settings : do not override value method v0.92.1 (2020-07-14) Fix winextras test fix v0.92.0 (2020-07-14) Feat add widgets.SystemTrayIcon add winextras module Label : set_indent method v0.91.0 (2020-07-13) Feat SidebarWidget : allow choosing layout MainWindow : add show_blocking method v0.90.0 (2020-07-13) Feat Toolbar : allow combinations of allowed areas for set_allowed_areas SidebarWidget : add optional settings menu v0.89.1 (2020-07-13) Refactor SelectionWidget : switch to {data: label} dicts for add_items to be in line with RadioButton v0.89.0 (2020-07-13) Feat SidebarWidget : make button width configurable v0.88.1 (2020-07-13) Refactor ComboBox : use set_data for set_value Fix ComboBox : fix add_items method v0.88.0 (2020-07-13) Feat ComboBox : set_data method v0.87.0 (2020-07-13) Feat ComboBox : allow dict for add_items v0.86.3 (2020-07-12) Refactor RegexEditor : code cleanup v0.86.2 (2020-07-12) Fix another deployment fix v0.86.1 (2020-07-12) Fix deployment fix v0.86.0 (2020-07-12) Feat add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line v0.85.1 (2020-07-10) Fix add missing pygments requirement v0.85.0 (2020-07-10) Feat dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method Refactor CodeEditor : use pygments for syntax highlighting v0.84.0 (2020-07-10) Feat sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child v0.83.1 (2020-07-09) Refactor move set_icon from window classes to widget class v0.83.0 (2020-07-09) Feat add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager v0.82.0 (2020-07-09) Feat add Label.set_bold / set_italic / set_weight added Font.set_weight v0.81.0 (2020-07-08) Feat allow setting window icon color os dark mode detection v0.80.1 (2020-07-08) Fix Settings.value() returned wrong type v0.80.0 (2020-07-08) Feat add Widget.set_attribute add margin keyword argument to Widget.set_layout v0.79.1 (2020-07-08) Fix remove Qt logger on Application exit v0.79.0 (2020-07-08) Feat add widgets.Application.get_widget v0.78.0 (2020-07-08) Feat allow to save/load window state recursively. Saving needs to be done explicitely now. Fix some fixes for core.Settings dict interface properly preserve types in core.Settings v0.77.1 (2020-07-07) Refactor also allow qt flag for Splitter ctor Fix return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview 0.77.0 (2020-07-06) Feat allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages Fix fix Messagebox.message call Refactor dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars","title":"Changelog"},{"location":"changelog.html#v01620-2020-12-27","text":"","title":"v0.162.0 (2020-12-27)"},{"location":"changelog.html#feat","text":"FontDatabase : add additional check in add_font Painter : add offset_by and apply_transform context managers","title":"Feat"},{"location":"changelog.html#fix","text":"IconWidget : update when setting size","title":"Fix"},{"location":"changelog.html#v01610-2020-12-26","text":"","title":"v0.161.0 (2020-12-26)"},{"location":"changelog.html#feat_1","text":"LineEdit : add add_action method ListView/TableView : add some more setters / getters Painter : add edit_pen context manager PolygonF : alternative ctors for diamond / star creation","title":"Feat"},{"location":"changelog.html#fix_1","text":"LabeledSlider : call adjust_margins on correct object correct IconProvider init","title":"Fix"},{"location":"changelog.html#v01600-2020-12-25","text":"","title":"v0.160.0 (2020-12-25)"},{"location":"changelog.html#feat_2","text":"gui : add TextLine module Doublevalidator : add set_range method IntValidator : add set_range method Pixmap : add eq method","title":"Feat"},{"location":"changelog.html#v01590-2020-12-24","text":"","title":"v0.159.0 (2020-12-24)"},{"location":"changelog.html#feat_3","text":"LineEdit : add set/get_cursor_move_style methods","title":"Feat"},{"location":"changelog.html#v01580-2020-12-22","text":"","title":"v0.158.0 (2020-12-22)"},{"location":"changelog.html#feat_4","text":"iconprovider : add reset_cache method Widget : add set/get_foreground/background_role methods Application/Widget : add set/get_stylesheet methods Application : add edit_stylesheet context manager","title":"Feat"},{"location":"changelog.html#v01571-2020-12-22","text":"","title":"v0.157.1 (2020-12-22)"},{"location":"changelog.html#fix_2","text":"SpanSlider fix","title":"Fix"},{"location":"changelog.html#v01570-2020-12-22","text":"","title":"v0.157.0 (2020-12-22)"},{"location":"changelog.html#feat_5","text":"Painter : add native_mode context manager FontDatabase : add add_font method gui : add IconEngine class TabWidget : add set_icon_size method Icon : allow more types for size param","title":"Feat"},{"location":"changelog.html#v01560-2020-12-21","text":"","title":"v0.156.0 (2020-12-21)"},{"location":"changelog.html#feat_6","text":"RegularExpressionMatch : add bool method custom_widgets : add ObjectBrowser class Timer : add restart method ListView : add set_grid_size method SortFilterProxyModel : add is/set_filter_case_sensitive methods AbstractItemView : add set_icon_size method","title":"Feat"},{"location":"changelog.html#v01550-2020-12-20","text":"","title":"v0.155.0 (2020-12-20)"},{"location":"changelog.html#feat_7","text":"Label : add get_horizontal/vertical_alignment methods GraphicsWidget : add window_frame_section_at method","title":"Feat"},{"location":"changelog.html#v01540-2020-12-18","text":"","title":"v0.154.0 (2020-12-18)"},{"location":"changelog.html#feat_8","text":"add QtLocation and QtHelp to qt submodule Dir/FileDialog : add get/set_filter methods InputDialog : add get/set_input_mode and get/set_text_echo_mode methods","title":"Feat"},{"location":"changelog.html#fix_3","text":"correct StarDelegate setModelData call","title":"Fix"},{"location":"changelog.html#v01530-2020-12-17","text":"","title":"v0.153.0 (2020-12-17)"},{"location":"changelog.html#feat_9","text":"MediaPlayer : add get_error method","title":"Feat"},{"location":"changelog.html#v01521-2020-12-17","text":"","title":"v0.152.1 (2020-12-17)"},{"location":"changelog.html#fix_4","text":"PySide2 workaround for non-recursive Object.findChild(ren)","title":"Fix"},{"location":"changelog.html#v01520-2020-12-16","text":"","title":"v0.152.0 (2020-12-16)"},{"location":"changelog.html#feat_10","text":"Standarditem/StandardItemModel : add enabled and editable kwarg to add_item methods AbstractItemView : add get/set_drag_drop_mode methods","title":"Feat"},{"location":"changelog.html#v01510-2020-12-16","text":"","title":"v0.151.0 (2020-12-16)"},{"location":"changelog.html#feat_11","text":"ToolBar : add add method Icon : add get_actual_size method winextras : add WinThumbnailToolButton class ToolButton : add set_menu method Uuid : add str method","title":"Feat"},{"location":"changelog.html#fix_5","text":"PySide2 find_child(ren) fix","title":"Fix"},{"location":"changelog.html#v01500-2020-12-15","text":"","title":"v0.150.0 (2020-12-15)"},{"location":"changelog.html#feat_12","text":"Movie : add get_state method","title":"Feat"},{"location":"changelog.html#v01490-2020-12-15","text":"","title":"v0.149.0 (2020-12-15)"},{"location":"changelog.html#feat_13","text":"add HoverIconEventFilter class positioning : add GeoPositionInfo class Icon : add mode and state kwarg for add/get_pixmap widget : add set_mask method core : add FileSystemWatcher class Palette : add get/set_color_group methods Brush : add some addtional methods Region : add some additional methods custom_delegates : add RenderLinkDelegate class TableWidgetItem : add set_text_alignment method Gradients : add repr and some helper methods to gradient classes","title":"Feat"},{"location":"changelog.html#fix_6","text":"PySide2 workaround for missing recursive param in findChild(ren) WebEngineHistory len fix for PySide2 CategoryAxis len fix for PySide2 correctly inherit LCDNumber","title":"Fix"},{"location":"changelog.html#v01480-2020-12-14","text":"","title":"v0.148.0 (2020-12-14)"},{"location":"changelog.html#feat_14","text":"Widget : add get/set_window_state methods AbstractTextDocumentLayout : add tuple support for hit_test point arg TimeZone : add get_display_name method GuiApplication : add get/set_high_dpi_scale_factor_rounding_policy methods StandardItem : add some new methods AbstractButton : add get_icon method StandardItemModel : add add_item method StandardItem : add get/set_checkstate methods Window : add start_system_resize method","title":"Feat"},{"location":"changelog.html#v01472-2020-12-14","text":"","title":"v0.147.2 (2020-12-14)"},{"location":"changelog.html#fix_7","text":"MacOs test fix","title":"Fix"},{"location":"changelog.html#v01471-2020-12-14","text":"","title":"v0.147.1 (2020-12-14)"},{"location":"changelog.html#fix_8","text":"MacOs test fix","title":"Fix"},{"location":"changelog.html#v01470-2020-12-13","text":"","title":"v0.147.0 (2020-12-13)"},{"location":"changelog.html#feat_15","text":"ToolBar : add get_allowed_areas method WebEnginePage : add some additional methods WebEngineSettings : add delitem method Application : add send/post_event methods","title":"Feat"},{"location":"changelog.html#v01460-2020-12-13","text":"","title":"v0.146.0 (2020-12-13)"},{"location":"changelog.html#fix_9","text":"correctly serialize AbstractGraphicsShapeItem","title":"Fix"},{"location":"changelog.html#feat_16","text":"GuiApplication : add get_icon method PlainTextEdit : add get(_line)_wrap_mode methods GuiApplication : add get_application_state method","title":"Feat"},{"location":"changelog.html#v01450-2020-12-11","text":"","title":"v0.145.0 (2020-12-11)"},{"location":"changelog.html#fix_10","text":"GraphicsGridLayout : serialize correctly MediaRecorder : use correct module in set_video/audio_settings correct constant naming install_exceptionhook fix","title":"Fix"},{"location":"changelog.html#feat_17","text":"GridLayout : add get/set_origin_corner methods BoxLayout : add get/set_direction methods NetworkCookieJar : add add and set_cookies_from_url methods NetworkCookie : add set_expiration_date method Translator : add bool method custom_widgets : add RoundProgressBar class DateTimeEdit : add some more methods related to sections get/set_icon_size work for some widgets CalendarWidget : add set_range method HeaderView : add generate_header_id method Widget : add edit_palette contextmanager and get_font method Palette : add brush methods custom_models : add ImportlibDistributionModel class","title":"Feat"},{"location":"changelog.html#v01440-2020-12-09","text":"","title":"v0.144.0 (2020-12-09)"},{"location":"changelog.html#fix_11","text":"Settings : iter through key-value pairs correct inheritance for QuickItem ColumnItemModel : correct get_width signature","title":"Fix"},{"location":"changelog.html#feat_18","text":"qml : add QmlImageProviderbase class widgets : add TreeWidgetItemIterator class quick : add some more classes qml : add QmlParserStatus class Widget : add get_title method Painter : add get_text_rect method ListWidget : add add_item method","title":"Feat"},{"location":"changelog.html#v01430-2020-12-08","text":"","title":"v0.143.0 (2020-12-08)"},{"location":"changelog.html#fix_12","text":"ObjectBrowser fix","title":"Fix"},{"location":"changelog.html#feat_19","text":"implement eq method for some more validator classes","title":"Feat"},{"location":"changelog.html#v01421-2020-12-07","text":"","title":"v0.142.1 (2020-12-07)"},{"location":"changelog.html#fix_13","text":"use our own SizeF class","title":"Fix"},{"location":"changelog.html#v01420-2020-12-07","text":"","title":"v0.142.0 (2020-12-07)"},{"location":"changelog.html#feat_20","text":"SizeF : add some methods to be on par with Size Size : add expanded_to method CompositeValidator : add some additional methods custom_validators : add eq method to validator classes TreeWidgetItem : add some more methods widgets : add TableWidgetSelectionRange class core : add Calendar class core : add SignalMapper class core : add StateMachine class core : add LockFile class core : add JsonDocument/JsonValue classes GeoCircle : allow tuple in ctor core : add SocketNotifier class widgets : add Shortcut class","title":"Feat"},{"location":"changelog.html#fix_14","text":"Correctly inherit StyleItemDelegate","title":"Fix"},{"location":"changelog.html#v01410-2020-12-03","text":"","title":"v0.141.0 (2020-12-03)"},{"location":"changelog.html#feat_21","text":"core : add Collator(SortKey) classes","title":"Feat"},{"location":"changelog.html#fix_15","text":"github actions fix","title":"Fix"},{"location":"changelog.html#v01404-2020-12-02","text":"","title":"v0.140.4 (2020-12-02)"},{"location":"changelog.html#fix_16","text":"docs build fix","title":"Fix"},{"location":"changelog.html#v01403-2020-12-02","text":"","title":"v0.140.3 (2020-12-02)"},{"location":"changelog.html#fix_17","text":"docs deployment","title":"Fix"},{"location":"changelog.html#v01402-2020-12-02","text":"","title":"v0.140.2 (2020-12-02)"},{"location":"changelog.html#fix_18","text":"deploy check for github actions","title":"Fix"},{"location":"changelog.html#v01401-2020-12-02","text":"","title":"v0.140.1 (2020-12-02)"},{"location":"changelog.html#fix_19","text":"github actions: conditional deploy step","title":"Fix"},{"location":"changelog.html#v01400-2020-12-02","text":"","title":"v0.140.0 (2020-12-02)"},{"location":"changelog.html#feat_22","text":"gui : add ColorSpace class","title":"Feat"},{"location":"changelog.html#v01390-2020-12-02","text":"","title":"v0.139.0 (2020-12-02)"},{"location":"changelog.html#feat_23","text":"FileInfo/Dir : fallback to pathlib.Path methods widgets : add Proxy/CommonStyle classes widgets : add Gesture classes core : add TemporaryDir class widgets : add WhatsThis class core : add ItemSelectionRange class FormLayout : add some more methods core : add ProcessEnvironment class gui : add StaticText class core : add PauseAnimation class","title":"Feat"},{"location":"changelog.html#v01380-2020-12-01","text":"","title":"v0.138.0 (2020-12-01)"},{"location":"changelog.html#feat_24","text":"core : add ChildEvent / TimerEvent classes core : add IdentityProxyModel class gui : add SessionManager class gui : add InputMethod class core : add AbstractEventDispatcher class widgets : add StackedWidget class widgets : add some events FileInfo : add some additional methods gui : add Vector3D class core : add MimeType / MimeDatabase classes core : add SaveFile class core : add SignalBlocker class core : add TimeLine class gui : add Bitmap class core : add RandomGenerator class FileDevice : add get_error method widgets : add Dial class widgets : add RubberBand class Wizard/WizardPage : add some more methods widgets : add GraphicsRotation / GraphicsScale classes widgets : add GraphicsTransform class widgets : add LCDNumber class widgets : add Scroller(Properties) classes core : add CommandLineParser/Option classes Pixmap : add some more methods gui : add Screen class Transform : add some more methods add Abstract/PlainTextTextDocumentLayout classes core : add BasicTimer class core : add Resource class core : add StorageInfo class core : add ElapsedTimer class core : add CryptographicHash class","title":"Feat"},{"location":"changelog.html#v01371-2020-11-27","text":"","title":"v0.137.1 (2020-11-27)"},{"location":"changelog.html#fix_20","text":"doc build fix","title":"Fix"},{"location":"changelog.html#v01370-2020-11-27","text":"","title":"v0.137.0 (2020-11-27)"},{"location":"changelog.html#feat_25","text":"core : add OperatingSystemVersion class PdfWriter : add set_page_margins method core : add MarginsF class core : Add TextStream class core : add ByteArrayMatcher AbstractItemModel : add check_index method PlaceManager : add search_place method core : add app method add bytes method to some classes utils : add Singleton metaclass icon : add add_pixmap method gui : Add PixmapCache Font : add some more methods","title":"Feat"},{"location":"changelog.html#v01360-2020-11-26","text":"","title":"v0.136.0 (2020-11-26)"},{"location":"changelog.html#feat_26","text":"location : add PlaceResult class location : add PlaceProposedSearchResult class location : add clone_from method to reply classes Object : add has_id method","title":"Feat"},{"location":"changelog.html#fix_21","text":"emit inputandslider signal correctly on value change correct flag for constants.NO_CHILDREN","title":"Fix"},{"location":"changelog.html#v01350-2020-11-26","text":"","title":"v0.135.0 (2020-11-26)"},{"location":"changelog.html#feat_27","text":"WebEngineHistoryItem : add get_icon_url method location : add PlaceMatchReply / PlaceIdReply classes PlaceContentReply/PlaceSearchReply : add request methods gui : add TextListFormat class gui : add TextImageFormat class location : add some reply/result classes gui : add TextTableCellFormat class gui : add app method gui : add TextFrameFormat class Application : add get_font method add qthelp module quick : add QuickPaintedItem class gui : add TextBlockGroup class TextCharFormat : add get/set_vertical_alignment methods TextBlock : add contains method PaintDevice : add get_metric method GuiApplication : add get/set_layout_direction methods gui : add TextObject / TextLength / TextFrame / TextFormat classes core : add ItemSelection class GraphicsLayout : add set_margin method","title":"Feat"},{"location":"changelog.html#fix_22","text":"correctly add items for GraphicsGridLayout","title":"Fix"},{"location":"changelog.html#v01340-2020-11-23","text":"","title":"v0.134.0 (2020-11-23)"},{"location":"changelog.html#feat_28","text":"core : add PersistentModelIndex class core : add PluginLoader class core : add Library class gui : add PainterPathStroker class gui : add ImageWriter / ImageReader / ImageIOHandler classes quick : add QuickItem / QuickWindow classes core : add install_message_handler method gui : add RasterWindow / PaintDeviceWindow / OpenGLWindow classes svg : add SvgGenerator class SplashScreen : allow pixmap for ctor icon : add get_available_sizes method widget : add set_attributes method gui : add Vector4D / Matrix4x4 classes custom_widgets : add StarDelegate class custom_delegates : add ProgressBarDelegate class widgets : add missing StyleOption classes WidgetItems : some more methods Painter : add backup_state contextmanager","title":"Feat"},{"location":"changelog.html#fix_23","text":"KeySequenceEdit : correct repr correct coloring for WaitingSpinner","title":"Fix"},{"location":"changelog.html#v01331-2020-11-16","text":"","title":"v0.133.1 (2020-11-16)"},{"location":"changelog.html#fix_24","text":"test fix","title":"Fix"},{"location":"changelog.html#v01330-2020-11-16","text":"","title":"v0.133.0 (2020-11-16)"},{"location":"changelog.html#feat_29","text":"ComboBox : default param for add_items AbstractItemModel : add force_reset/force_layoutchange methods add location module gui : add FontMetricsF class GeoCoordinate : add bool method FontMetrics : add get_(tight_)bounding_rect methods Url : add to_string method network : add LocalServer / TcpServer classes multimediawidgets : add GraphicsVideoItem class mediaobject : add get_availability method add qt module","title":"Feat"},{"location":"changelog.html#v01321-2020-11-07","text":"","title":"v0.132.1 (2020-11-07)"},{"location":"changelog.html#fix_25","text":"import fix","title":"Fix"},{"location":"changelog.html#v01320-2020-11-07","text":"","title":"v0.132.0 (2020-11-07)"},{"location":"changelog.html#feat_30","text":"NetworkAccessManager : allow str for request network : add UdpSocket network : add NetworkAddressEntry / NetworkInterface classes add texttospeech module network : add NetworkDatagram class core : add DeadlineTimer class network : add HostAddress/AbstractSocket/TcpSocket classes network : add NetworkProxy class network : add HttpMultiPart class network : add HttpPart class NetworkRequest : add set/get_header methods","title":"Feat"},{"location":"changelog.html#v01310-2020-11-04","text":"","title":"v0.131.0 (2020-11-04)"},{"location":"changelog.html#feat_31","text":"webenginecore : add WebEngineHttpRequest class webenginewidgets : add WebEngineContextMenuData class webenginewidgets : add WebEngineScriptCollection class multimedia : add CameraExposure/CameraImageProcessing classes multimedia : add CameraFocus(Zone) classes webenginecore : add WebEngineUrlSchemeHandler","title":"Feat"},{"location":"changelog.html#v01300-2020-11-04","text":"","title":"v0.130.0 (2020-11-04)"},{"location":"changelog.html#feat_32","text":"WebEnginePage : add some settings methods webenginewidgets : add WebEngineSettings class add bluetooth module core : add Uuid class add quick module gui : add Surface and Window class multimedia : add ImageEncoderSettings multimedia : add MediaTimeRange and MediaTimeInterval classes","title":"Feat"},{"location":"changelog.html#v01291-2020-10-29","text":"","title":"v0.129.1 (2020-10-29)"},{"location":"changelog.html#fix_26","text":"fix tests fix multimedia tests for Travis","title":"Fix"},{"location":"changelog.html#feat_33","text":"charts : add Legend class WebEnginePage : add get_history method qml : add JSValue(Iterator) class VideoWidget : option for fullscreen toggling via double click multimedia : add CameraViewFinderSettings multimedia : add VideoFrame class multimedia : add AbstractPlanarVideoBuffer class multimedia : add AbstractVideoBuffer class multimedia : add Camera class multimedia : add CameraInfo class gui : add Clipboard class multimedia : add AudioFormat class multimedia : add SoundEffect class charts : add PieSlice class charts : add BoxSet and CandlestickSet classes charts : add Axis-related classes charts : add BarSeries-related classes","title":"Feat"},{"location":"changelog.html#v01281-2020-10-25","text":"","title":"v0.128.1 (2020-10-25)"},{"location":"changelog.html#fix_27","text":"import fix","title":"Fix"},{"location":"changelog.html#v01280-2020-10-25","text":"","title":"v0.128.0 (2020-10-25)"},{"location":"changelog.html#feat_34","text":"custom_widgets : add ExpandableLine class ParallelAnimationGroup : add set_duration method charts : add Abstract/ValueAxis and PolarChart classes core : add SequentialAnimationGroup class AnimationGroup : allow slicing for indexing AnimationGroup : add add_property_animation method ChartView : add get/set_rubber_band methods Chart : add some more methods core : add Locale class core : add Margins class webenginewidgets : add some more modules","title":"Feat"},{"location":"changelog.html#fix_28","text":"Chart : properly inherit from GraphicsWidget","title":"Fix"},{"location":"changelog.html#v01271-2020-10-20","text":"","title":"v0.127.1 (2020-10-20)"},{"location":"changelog.html#fix_29","text":"fix tests","title":"Fix"},{"location":"changelog.html#v01270-2020-10-20","text":"","title":"v0.127.0 (2020-10-20)"},{"location":"changelog.html#fix_30","text":"always import correct bindings for winextras module Url : allow initializing without arg","title":"Fix"},{"location":"changelog.html#feat_35","text":"PainterPath : add set_fill_rule method PainterPath : add get_bounding_rect method GraphicsItem : add get_shape method MediaPlaylist : add get_media_url method start with webenginecore module core : add EventLoop class Widget : add get_font_info method custom_models : add PlaylistModel Translator : add get_file_path method add positioning module add some first QtQml classes core : add LibraryInfo class Application : add iter method Application : add get/set_navigation_mode methods Application : add get/is_effect_enabled methods custom_widgets : add Player class","title":"Feat"},{"location":"changelog.html#v01260-2020-10-08","text":"","title":"v0.126.0 (2020-10-08)"},{"location":"changelog.html#feat_36","text":"core : add Process class DateTime : add get/set_time_spec and get_date/time methods core : add Time class DateTime : add timezone methods core : add TimeZone class Pixmap : add create_dot classmethod","title":"Feat"},{"location":"changelog.html#v01251-2020-10-07","text":"","title":"v0.125.1 (2020-10-07)"},{"location":"changelog.html#fix_31","text":"import fix","title":"Fix"},{"location":"changelog.html#v01250-2020-10-07","text":"","title":"v0.125.0 (2020-10-07)"},{"location":"changelog.html#feat_37","text":"widgets : add Transition classes core : add Transition classes","title":"Feat"},{"location":"changelog.html#fix_32","text":"fix Action.get_shortcut for NoneValue","title":"Fix"},{"location":"changelog.html#v01240-2020-10-05","text":"","title":"v0.124.0 (2020-10-05)"},{"location":"changelog.html#feat_38","text":"IODevice : add get_open_mode method Improve repr and add str method for Date and DateTime core : add TemporaryFile class FileDevice : add set/get_file_time methods MainWindow : allow setting central widget to None AbstractButton : add get_shortcut method Url : add from_user_input method WebEngineView : add get_url method FileInfo : support pathlib + add proper repr KeySequence : allow initializing with standard keys","title":"Feat"},{"location":"changelog.html#v01231-2020-09-29","text":"","title":"v0.123.1 (2020-09-29)"},{"location":"changelog.html#fix_33","text":"add missing State import in core module","title":"Fix"},{"location":"changelog.html#v01230-2020-09-29","text":"","title":"v0.123.0 (2020-09-29)"},{"location":"changelog.html#feat_39","text":"core : add State classes core : add TextBoundaryFinder class ProgressBar : add get/set_orientation methods + serialize work Action : allow setting callback with ctor WebEngineView : set subclassed WebEnginePage by default WebEnginePage : add some more methods and constants AbstractSlider : add get/set_orientation methods core : add FileInfo class webenginewidgets : add WebEngineProfile class","title":"Feat"},{"location":"changelog.html#v01221-2020-09-27","text":"","title":"v0.122.1 (2020-09-27)"},{"location":"changelog.html#fix_34","text":"use correct icon names","title":"Fix"},{"location":"changelog.html#v01220-2020-09-27","text":"","title":"v0.122.0 (2020-09-27)"},{"location":"changelog.html#feat_40","text":"gui : add PageLayout gui : add Movie class gui : add PageSize class gui : add FontInfo class core : add UrlQuery class add network module PropertyAnimation : add get/set_property_name methods core : add ParallelAnimationGroup widgets : add SizeGrip class widgets : add DataWidgetMapper class core : add StringListModel VersionNumber : add get_python_version gui : add Transform class Painter : add draw_polygon method add core.ByteArray","title":"Feat"},{"location":"changelog.html#v01210-2020-09-10","text":"","title":"v0.121.0 (2020-09-10)"},{"location":"changelog.html#feat_41","text":"Image : add setitem / getitem methods Line/LineF : add reversed and abs methods GraphicsScene : add get/set_item_index_method method","title":"Feat"},{"location":"changelog.html#fix_35","text":"serialization fixes","title":"Fix"},{"location":"changelog.html#v01200-2020-08-27","text":"","title":"v0.120.0 (2020-08-27)"},{"location":"changelog.html#feat_42","text":"GraphicsWidget : add set_layout method GraphicsLayout : add some magic methods GraphicsScene : add add_item_group method widgets : add GraphicsAnchorLayout / GraphicsGridLayout / GraphicsLinearLayout widgets : add GraphicsItemGroup Layout : add delitem method Polygon/PolygonF : add repr and iter methods PainterPath : some additional methods GraphicsItems : add repr methods Line/LineF : add repr and iter Application : allow loading included language files via load_language_file widgets : add GraphicsView class","title":"Feat"},{"location":"changelog.html#refactor","text":"PromptLineEdit rework","title":"Refactor"},{"location":"changelog.html#v01191-2020-08-24","text":"","title":"v0.119.1 (2020-08-24)"},{"location":"changelog.html#fix_36","text":"add missing StyleOptionComplex class","title":"Fix"},{"location":"changelog.html#v01190-2020-08-24","text":"","title":"v0.119.0 (2020-08-24)"},{"location":"changelog.html#feat_43","text":"GraphicsScene : add some convenience methods widgets : add graphicsitem classes StylePainter : add draw_complex_control method gui : allow pickling some more classes core : add LineF class Widget : add get_palette() method widgets : add GraphicsPixmapItem / GraphicsScene GraphicsItem : add getitem and setitem methods widgets : add Blur/Colorize/DropShadowEffect","title":"Feat"},{"location":"changelog.html#fix_37","text":"Graphicsitem collides methods fix KeySequence : pickling","title":"Fix"},{"location":"changelog.html#v01182-2020-08-17","text":"","title":"v0.118.2 (2020-08-17)"},{"location":"changelog.html#fix_38","text":"Fix tests","title":"Fix"},{"location":"changelog.html#v01181-2020-08-17","text":"","title":"v0.118.1 (2020-08-17)"},{"location":"changelog.html#fix_39","text":"MenuBar : fix add method","title":"Fix"},{"location":"changelog.html#v01180-2020-08-17","text":"","title":"v0.118.0 (2020-08-17)"},{"location":"changelog.html#refactor_1","text":"MenuBar : return subclassed types instead of qt classes","title":"Refactor"},{"location":"changelog.html#feat_44","text":"gui : add TextDocument / TextBlock / TextOption gui : add ConicalGradient / RadialGradient custom_widgets : add CollapsibleFrame GraphicsItem : add some more methods","title":"Feat"},{"location":"changelog.html#v01170-2020-08-16","text":"","title":"v0.117.0 (2020-08-16)"},{"location":"changelog.html#feat_45","text":"MimeData : add dict-like interface Timer : add get/set_type methods File : add repr and str methods Dir : add repr and truediv methods Frame : set/get_frame_shape, set/get_frame_shadow Splitter : add setitem method, and some more typing Polygon/PolygonF : pythonize core : add Abstract/Variant/PropertyAnimation and AnimationGroup core : add EasingCurve StyleOptionSlider : add get_orientation method","title":"Feat"},{"location":"changelog.html#refactor_2","text":"SpanSlider : clean up code","title":"Refactor"},{"location":"changelog.html#v01160-2020-08-13","text":"","title":"v0.116.0 (2020-08-13)"},{"location":"changelog.html#feat_46","text":"gui : add LinearGradient AbstractSlider : add get/set_repeat_action and trigger_action methods TabWidget : add get/set_tab_position methods Image/Pixmap : add bool method MenuBar : serialize stuff MdiArea : serialize stuff Brush : allow pickling + add get_texture_image method custom_widgets : add Timeline Pen : add methods for setting and getting style / join style / cap style","title":"Feat"},{"location":"changelog.html#refactor_3","text":"Painter : rework set_pen / get_pen","title":"Refactor"},{"location":"changelog.html#v01150-2020-08-12","text":"","title":"v0.115.0 (2020-08-12)"},{"location":"changelog.html#feat_47","text":"Polygon : add add_points method Object : add store_widget_states / restore_widget_states Painter : add paint_on, set_transparent_background, set_brush PainterPath : add add_rect method Application : add class_getitem","title":"Feat"},{"location":"changelog.html#fix_40","text":"RegexEditor : correctly initialize dialog","title":"Fix"},{"location":"changelog.html#v01141-2020-08-12","text":"","title":"v0.114.1 (2020-08-12)"},{"location":"changelog.html#fix_41","text":"HeaderView : fix saving state","title":"Fix"},{"location":"changelog.html#v01140-2020-08-12","text":"","title":"v0.114.0 (2020-08-12)"},{"location":"changelog.html#refactor_4","text":"use AutoSlot decorator","title":"Refactor"},{"location":"changelog.html#feat_48","text":"add autoslot decorator add prettyqt.debug","title":"Feat"},{"location":"changelog.html#v01130-2020-08-10","text":"","title":"v0.113.0 (2020-08-10)"},{"location":"changelog.html#feat_49","text":"gui : add PainterPath class gui : add Polygon class gui : palette improvements core : add Line class core : add TransposeProxyModel / ConcatenateTablesProxyModel add ObjectBrowser widgets : add GraphicsEffect / GraphicsObject / GraphicsOpacityEffect Action : \"checked\" param for ctor gui : some magic methods + get_matches for KeySequence core : allow pickling VersionNumber / Size / Dir gui : add Gradient class add ColumnItemModel / ColumnItem Settings : add set_values method Widget : spacing kwarg for set_layout","title":"Feat"},{"location":"changelog.html#refactor_5","text":"add serialization stuff improve some repr methods","title":"Refactor"},{"location":"changelog.html#v01120-2020-08-04","text":"","title":"v0.112.0 (2020-08-04)"},{"location":"changelog.html#feat_50","text":"utils : add install_exceptionhook method FileSystemModel : add some more shortcuts for set_root_path core : add VersionNumber class Application : add get_icon method MessageBox : add show_exception method","title":"Feat"},{"location":"changelog.html#refactor_6","text":"improve compat with older Qt Versions","title":"Refactor"},{"location":"changelog.html#fix_42","text":"another test fix","title":"Fix"},{"location":"changelog.html#v01111-2020-08-03","text":"","title":"v0.111.1 (2020-08-03)"},{"location":"changelog.html#fix_43","text":"fix tests for Linux","title":"Fix"},{"location":"changelog.html#v01110-2020-08-03","text":"","title":"v0.111.0 (2020-08-03)"},{"location":"changelog.html#feat_51","text":"widgets : add FontComboBox StandardPaths : add class_getitem method Action : some more ctor kwargs Action : add get/set_menu_role methods, some pickle work","title":"Feat"},{"location":"changelog.html#refactor_7","text":"custom Exception for wrong params","title":"Refactor"},{"location":"changelog.html#fix_44","text":"Menu : disable separator widgetAction","title":"Fix"},{"location":"changelog.html#v01102-2020-08-03","text":"","title":"v0.110.2 (2020-08-03)"},{"location":"changelog.html#fix_45","text":"fix broken LogTextEdit","title":"Fix"},{"location":"changelog.html#v01101-2020-08-03","text":"","title":"v0.110.1 (2020-08-03)"},{"location":"changelog.html#fix_46","text":"LogTextEdit : improve exception handling SidebarWidget : some fixes related to set_marker","title":"Fix"},{"location":"changelog.html#v01100-2020-08-02","text":"","title":"v0.110.0 (2020-08-02)"},{"location":"changelog.html#refactor_8","text":"improve serialization for listitems Validator pickle work","title":"Refactor"},{"location":"changelog.html#feat_52","text":"Image : allow pickling DataStream : add create_bytearray / write_bytearray / copy_data methods core : add DataStream class","title":"Feat"},{"location":"changelog.html#v01090-2020-08-02","text":"","title":"v0.109.0 (2020-08-02)"},{"location":"changelog.html#feat_53","text":"widget : add pretty method for devtools GridLayout : allow adding tuples/lists","title":"Feat"},{"location":"changelog.html#refactor_9","text":"rework widget pickling move CheckboxDelegate to custom_delegates pickle stuff for undocommand","title":"Refactor"},{"location":"changelog.html#v01080-2020-07-31","text":"","title":"v0.108.0 (2020-07-31)"},{"location":"changelog.html#feat_54","text":"custom_delegates : add IconDelegate and NoFocusDelegate TableWidet : add getitem and setitem methods Icon : add from_image method allow str for layout. getitem (uses objectName) SidebarWidget : add set_marker method","title":"Feat"},{"location":"changelog.html#refactor_10","text":"move delegates to separate module","title":"Refactor"},{"location":"changelog.html#v01070-2020-07-29","text":"","title":"v0.107.0 (2020-07-29)"},{"location":"changelog.html#feat_55","text":"GridLayout : also allow adding LayoutItems via add method","title":"Feat"},{"location":"changelog.html#v01061-2020-07-29","text":"","title":"v0.106.1 (2020-07-29)"},{"location":"changelog.html#fix_47","text":"TabWidget : correctly close detached tabs on app close pickle fixes for toolbar and dockwidget PygmentsHighlighter : catch pygments KeyError","title":"Fix"},{"location":"changelog.html#v01060-2020-07-26","text":"","title":"v0.106.0 (2020-07-26)"},{"location":"changelog.html#feat_56","text":"gui : add DesktopServices class multimedia : add AudioRecorder class core : add StandardPaths class widgets : add Undo classes","title":"Feat"},{"location":"changelog.html#v01050-2020-07-24","text":"","title":"v0.105.0 (2020-07-24)"},{"location":"changelog.html#feat_57","text":"MediaRecorder : some new methods sort_by_column for tableview and treeview multimedia : dict-setter and getter for encodersettings","title":"Feat"},{"location":"changelog.html#refactor_11","text":"improve Url-Pathlib interoperability","title":"Refactor"},{"location":"changelog.html#fix_48","text":"PopupInfo : use PrimaryScreen geometry instead of screens[0] for positioning","title":"Fix"},{"location":"changelog.html#v01040-2020-07-23","text":"","title":"v0.104.0 (2020-07-23)"},{"location":"changelog.html#feat_58","text":"multimedia : add MediaRecorder AbstractItemModel : add getitem method multimedia : add VideoEncoderSettings / AudioEncoderSettings","title":"Feat"},{"location":"changelog.html#refactor_12","text":"use subclassed core.Size","title":"Refactor"},{"location":"changelog.html#v01030-2020-07-22","text":"","title":"v0.103.0 (2020-07-22)"},{"location":"changelog.html#feat_59","text":"ActionGroup : add getitem method MediaContent : add get_url method add multimediawidgets module add multimedia module PlainTextEdit : add allow_wheel_zoom method Object : name kwarg for find_parent method","title":"Feat"},{"location":"changelog.html#v01020-2020-07-21","text":"","title":"v0.102.0 (2020-07-21)"},{"location":"changelog.html#refactor_13","text":"move raise_dock to from Widget to Object SidebarWidget : some code cleanup, make settings button size configurable Widget : default state to True for set_attribute MainWindow : add return value for load_window_state","title":"Refactor"},{"location":"changelog.html#feat_60","text":"Object : add find_parent method PlainTextEdit : add style kwarg to set_syntaxhighlighter","title":"Feat"},{"location":"changelog.html#v01011-2020-07-20","text":"","title":"v0.101.1 (2020-07-20)"},{"location":"changelog.html#fix_49","text":"LogTextEdit : better integrate with custom qstylesheets","title":"Fix"},{"location":"changelog.html#v01010-2020-07-20","text":"","title":"v0.101.0 (2020-07-20)"},{"location":"changelog.html#feat_61","text":"MessageBox : add detail_text keyword argument to message method","title":"Feat"},{"location":"changelog.html#fix_50","text":"correct return type for gui.icon.get_icon","title":"Fix"},{"location":"changelog.html#v01000-2020-07-20","text":"","title":"v0.100.0 (2020-07-20)"},{"location":"changelog.html#feat_62","text":"ToolTip : add show_text method GuiApplication : add set_override_cursor / restore_override_cursor methods GuiApplication : add override_cursor context manager","title":"Feat"},{"location":"changelog.html#v0990-2020-07-18","text":"","title":"v0.99.0 (2020-07-18)"},{"location":"changelog.html#refactor_14","text":"FileChooserButton : typing and fixes Dataset : typing and fixes SidebarWidget : use button map instead of attaching button to widget","title":"Refactor"},{"location":"changelog.html#feat_63","text":"AbstractItemView : add scroll_to method","title":"Feat"},{"location":"changelog.html#v0985-2020-07-17","text":"","title":"v0.98.5 (2020-07-17)"},{"location":"changelog.html#perf","text":"add icon cache","title":"Perf"},{"location":"changelog.html#refactor_15","text":"use core.Settings for windows dark mode detection","title":"Refactor"},{"location":"changelog.html#v0984-2020-07-15","text":"","title":"v0.98.4 (2020-07-15)"},{"location":"changelog.html#fix_51","text":"use qta default icon color instead of black for default","title":"Fix"},{"location":"changelog.html#v0983-2020-07-15","text":"","title":"v0.98.3 (2020-07-15)"},{"location":"changelog.html#refactor_16","text":"properly set stylesheets by using contextmanager FontDialog : do not override current_font contextmanager move current_font context manager to Widget class","title":"Refactor"},{"location":"changelog.html#v0982-2020-07-15","text":"","title":"v0.98.2 (2020-07-15)"},{"location":"changelog.html#fix_52","text":"package name","title":"Fix"},{"location":"changelog.html#v0981-2020-07-15","text":"","title":"v0.98.1 (2020-07-15)"},{"location":"changelog.html#fix_53","text":"correctly reset stylesheet for widget validation background","title":"Fix"},{"location":"changelog.html#refactor_17","text":"use qstylizer for stylesheet editing","title":"Refactor"},{"location":"changelog.html#v0980-2020-07-15","text":"","title":"v0.98.0 (2020-07-15)"},{"location":"changelog.html#feat_64","text":"widgets : add StyleFactory","title":"Feat"},{"location":"changelog.html#refactor_18","text":"FontDatabase : make add_fonts_from_folder a classmethod","title":"Refactor"},{"location":"changelog.html#v0970-2020-07-15","text":"","title":"v0.97.0 (2020-07-15)"},{"location":"changelog.html#feat_65","text":"gui : add FontDatabase widgets : add Completer widgets : add ActionGroup","title":"Feat"},{"location":"changelog.html#v0960-2020-07-14","text":"","title":"v0.96.0 (2020-07-14)"},{"location":"changelog.html#feat_66","text":"SelectionWidget : default keyword argument for add_custom","title":"Feat"},{"location":"changelog.html#v0950-2020-07-14","text":"","title":"v0.95.0 (2020-07-14)"},{"location":"changelog.html#feat_67","text":"SelectionWidget : different options for custom type add PagedPaintDevice Widget : add set_margin method","title":"Feat"},{"location":"changelog.html#v0940-2020-07-14","text":"","title":"v0.94.0 (2020-07-14)"},{"location":"changelog.html#feat_68","text":"Widget : add Widget.font_metrics() SpacerItem : allow strings for size policy in ctor allow Mapping for listwidget.add_items","title":"Feat"},{"location":"changelog.html#refactor_19","text":"change to {value: label} dicts for FlagSelectionWidget.add_items","title":"Refactor"},{"location":"changelog.html#v0931-2020-07-14","text":"","title":"v0.93.1 (2020-07-14)"},{"location":"changelog.html#refactor_20","text":"typecheck for Mapping instead of dict for combobox / selectionwidget add_items method","title":"Refactor"},{"location":"changelog.html#v0930-2020-07-14","text":"","title":"v0.93.0 (2020-07-14)"},{"location":"changelog.html#feat_69","text":"add register_extensions function to settings module","title":"Feat"},{"location":"changelog.html#refactor_21","text":"Settings : do not override value method","title":"Refactor"},{"location":"changelog.html#v0921-2020-07-14","text":"","title":"v0.92.1 (2020-07-14)"},{"location":"changelog.html#fix_54","text":"winextras test fix","title":"Fix"},{"location":"changelog.html#v0920-2020-07-14","text":"","title":"v0.92.0 (2020-07-14)"},{"location":"changelog.html#feat_70","text":"add widgets.SystemTrayIcon add winextras module Label : set_indent method","title":"Feat"},{"location":"changelog.html#v0910-2020-07-13","text":"","title":"v0.91.0 (2020-07-13)"},{"location":"changelog.html#feat_71","text":"SidebarWidget : allow choosing layout MainWindow : add show_blocking method","title":"Feat"},{"location":"changelog.html#v0900-2020-07-13","text":"","title":"v0.90.0 (2020-07-13)"},{"location":"changelog.html#feat_72","text":"Toolbar : allow combinations of allowed areas for set_allowed_areas SidebarWidget : add optional settings menu","title":"Feat"},{"location":"changelog.html#v0891-2020-07-13","text":"","title":"v0.89.1 (2020-07-13)"},{"location":"changelog.html#refactor_22","text":"SelectionWidget : switch to {data: label} dicts for add_items to be in line with RadioButton","title":"Refactor"},{"location":"changelog.html#v0890-2020-07-13","text":"","title":"v0.89.0 (2020-07-13)"},{"location":"changelog.html#feat_73","text":"SidebarWidget : make button width configurable","title":"Feat"},{"location":"changelog.html#v0881-2020-07-13","text":"","title":"v0.88.1 (2020-07-13)"},{"location":"changelog.html#refactor_23","text":"ComboBox : use set_data for set_value","title":"Refactor"},{"location":"changelog.html#fix_55","text":"ComboBox : fix add_items method","title":"Fix"},{"location":"changelog.html#v0880-2020-07-13","text":"","title":"v0.88.0 (2020-07-13)"},{"location":"changelog.html#feat_74","text":"ComboBox : set_data method","title":"Feat"},{"location":"changelog.html#v0870-2020-07-13","text":"","title":"v0.87.0 (2020-07-13)"},{"location":"changelog.html#feat_75","text":"ComboBox : allow dict for add_items","title":"Feat"},{"location":"changelog.html#v0863-2020-07-12","text":"","title":"v0.86.3 (2020-07-12)"},{"location":"changelog.html#refactor_24","text":"RegexEditor : code cleanup","title":"Refactor"},{"location":"changelog.html#v0862-2020-07-12","text":"","title":"v0.86.2 (2020-07-12)"},{"location":"changelog.html#fix_56","text":"another deployment fix","title":"Fix"},{"location":"changelog.html#v0861-2020-07-12","text":"","title":"v0.86.1 (2020-07-12)"},{"location":"changelog.html#fix_57","text":"deployment fix","title":"Fix"},{"location":"changelog.html#v0860-2020-07-12","text":"","title":"v0.86.0 (2020-07-12)"},{"location":"changelog.html#feat_76","text":"add Scintilla CodeEditor PlainTextEdit : add color argument for highlight_current_line","title":"Feat"},{"location":"changelog.html#v0851-2020-07-10","text":"","title":"v0.85.1 (2020-07-10)"},{"location":"changelog.html#fix_58","text":"add missing pygments requirement","title":"Fix"},{"location":"changelog.html#v0850-2020-07-10","text":"","title":"v0.85.0 (2020-07-10)"},{"location":"changelog.html#feat_77","text":"dataset : add RegexPattern DataItem RegexEditor : use syntaxhighlighter for pattern RegexInput : use syntaxhighlighter for pattern PlainTextEdit : add set_syntaxhighlighter method Label : add set_color method","title":"Feat"},{"location":"changelog.html#refactor_25","text":"CodeEditor : use pygments for syntax highlighting","title":"Refactor"},{"location":"changelog.html#v0840-2020-07-10","text":"","title":"v0.84.0 (2020-07-10)"},{"location":"changelog.html#feat_78","text":"sidebarwidget : allow setting tab by object id Object : name kwarg for Object.find_children, add Object.find_child","title":"Feat"},{"location":"changelog.html#v0831-2020-07-09","text":"","title":"v0.83.1 (2020-07-09)"},{"location":"changelog.html#refactor_26","text":"move set_icon from window classes to widget class","title":"Refactor"},{"location":"changelog.html#v0830-2020-07-09","text":"","title":"v0.83.0 (2020-07-09)"},{"location":"changelog.html#feat_79","text":"add Label.set_point_size add self for label methods to allow chaining Font.current_font context manager","title":"Feat"},{"location":"changelog.html#v0820-2020-07-09","text":"","title":"v0.82.0 (2020-07-09)"},{"location":"changelog.html#feat_80","text":"add Label.set_bold / set_italic / set_weight added Font.set_weight","title":"Feat"},{"location":"changelog.html#v0810-2020-07-08","text":"","title":"v0.81.0 (2020-07-08)"},{"location":"changelog.html#feat_81","text":"allow setting window icon color os dark mode detection","title":"Feat"},{"location":"changelog.html#v0801-2020-07-08","text":"","title":"v0.80.1 (2020-07-08)"},{"location":"changelog.html#fix_59","text":"Settings.value() returned wrong type","title":"Fix"},{"location":"changelog.html#v0800-2020-07-08","text":"","title":"v0.80.0 (2020-07-08)"},{"location":"changelog.html#feat_82","text":"add Widget.set_attribute add margin keyword argument to Widget.set_layout","title":"Feat"},{"location":"changelog.html#v0791-2020-07-08","text":"","title":"v0.79.1 (2020-07-08)"},{"location":"changelog.html#fix_60","text":"remove Qt logger on Application exit","title":"Fix"},{"location":"changelog.html#v0790-2020-07-08","text":"","title":"v0.79.0 (2020-07-08)"},{"location":"changelog.html#feat_83","text":"add widgets.Application.get_widget","title":"Feat"},{"location":"changelog.html#v0780-2020-07-08","text":"","title":"v0.78.0 (2020-07-08)"},{"location":"changelog.html#feat_84","text":"allow to save/load window state recursively. Saving needs to be done explicitely now.","title":"Feat"},{"location":"changelog.html#fix_61","text":"some fixes for core.Settings dict interface properly preserve types in core.Settings","title":"Fix"},{"location":"changelog.html#v0771-2020-07-07","text":"","title":"v0.77.1 (2020-07-07)"},{"location":"changelog.html#refactor_27","text":"also allow qt flag for Splitter ctor","title":"Refactor"},{"location":"changelog.html#fix_62","text":"return correct types for re.groupdict / re.groups Fixed an issue which prevented saving an image from chartview","title":"Fix"},{"location":"changelog.html#0770-2020-07-06","text":"","title":"0.77.0 (2020-07-06)"},{"location":"changelog.html#feat_85","text":"allow custom icons for Messagebox add Icon.get_pixmap add Object.set_unique_id / Object.get_id allow None for set_max_height/width widget setters add checkboxdelegate add regexinput add pre-commit-hook for commit messages","title":"Feat"},{"location":"changelog.html#fix_63","text":"fix Messagebox.message call","title":"Fix"},{"location":"changelog.html#refactor_28","text":"dont use property setter widget.id dont use property setter widget.title add child classes in re module radiodelegate stuff no props for abstractscrollarea scrollbars","title":"Refactor"},{"location":"contributing.html","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs ~~~~~~~~~~~ Report bugs at https://github.com/phil65/prettyqt/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs ~~~~~~~~ Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features ~~~~~~~~~~~~~~~~~~ Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ~~~~~~~~~~~~~~~~~~~ PrettyQt could always use more documentation, whether as part of the official PrettyQt docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback ~~~~~~~~~~~~~~~ The best way to send feedback is to file an issue at https://github.com/phil65/prettyqt/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! Ready to contribute? Here's how to set up prettyqt for local development. Fork the prettyqt repo on GitHub. Clone your fork locally:: $ git clone git@github.com:your_name_here/prettyqt.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:: $ mkvirtualenv prettyqt $ cd prettyqt/ $ python setup.py develop Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests: $ flake8 prettyqt tests $ py.test To install required development libraries, run \"pip install -r requirements_dev.txt\". Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6 - 3.8. Check https://travis-ci.org/phil65/prettyqt/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Contributing"},{"location":"contributing.html#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing.html#types-of-contributions","text":"Report Bugs ~~~~~~~~~~~ Report bugs at https://github.com/phil65/prettyqt/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs ~~~~~~~~ Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features ~~~~~~~~~~~~~~~~~~ Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ~~~~~~~~~~~~~~~~~~~ PrettyQt could always use more documentation, whether as part of the official PrettyQt docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback ~~~~~~~~~~~~~~~ The best way to send feedback is to file an issue at https://github.com/phil65/prettyqt/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Types of Contributions"},{"location":"contributing.html#get-started","text":"Ready to contribute? Here's how to set up prettyqt for local development. Fork the prettyqt repo on GitHub. Clone your fork locally:: $ git clone git@github.com:your_name_here/prettyqt.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:: $ mkvirtualenv prettyqt $ cd prettyqt/ $ python setup.py develop Create a branch for local development:: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests: $ flake8 prettyqt tests $ py.test To install required development libraries, run \"pip install -r requirements_dev.txt\". Commit your changes and push your branch to GitHub:: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing.html#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.6 - 3.8. Check https://travis-ci.org/phil65/prettyqt/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"api/bluetooth.html","text":"bluetooth module bluetooth module. contains QtBluetooth-based classes bluetoothdevicediscoveryagent BluetoothDeviceDiscoveryAgent get_inquiry_type ( self ) Get the current inquiry type. Returns: Type Description Literal['unlimited', 'limited'] inquiry type Source code in prettyqt/bluetooth/bluetoothdevicediscoveryagent.py def get_inquiry_type ( self ) -> InquiryTypeStr : \"\"\"Get the current inquiry type. Returns: inquiry type \"\"\" return INQUIRY_TYPES . inverse [ self . inquiryType ()] set_inquiry_type ( self , typ ) Set inquiry type. Parameters: Name Type Description Default typ Literal['unlimited', 'limited'] inquiry type required Exceptions: Type Description InvalidParamError inquiry type does not exist Source code in prettyqt/bluetooth/bluetoothdevicediscoveryagent.py def set_inquiry_type ( self , typ : InquiryTypeStr ): \"\"\"Set inquiry type. Args: typ: inquiry type Raises: InvalidParamError: inquiry type does not exist \"\"\" if typ not in INQUIRY_TYPES : raise InvalidParamError ( typ , INQUIRY_TYPES ) self . setInquiryType ( INQUIRY_TYPES [ typ ])","title":"bluetooth"},{"location":"api/bluetooth.html#bluetooth-module","text":"","title":"bluetooth module"},{"location":"api/bluetooth.html#prettyqt.bluetooth","text":"bluetooth module. contains QtBluetooth-based classes","title":"prettyqt.bluetooth"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothdevicediscoveryagent","text":"","title":"bluetoothdevicediscoveryagent"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothdevicediscoveryagent.BluetoothDeviceDiscoveryAgent","text":"","title":"BluetoothDeviceDiscoveryAgent"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothdevicediscoveryagent.BluetoothDeviceDiscoveryAgent.get_inquiry_type","text":"Get the current inquiry type. Returns: Type Description Literal['unlimited', 'limited'] inquiry type Source code in prettyqt/bluetooth/bluetoothdevicediscoveryagent.py def get_inquiry_type ( self ) -> InquiryTypeStr : \"\"\"Get the current inquiry type. Returns: inquiry type \"\"\" return INQUIRY_TYPES . inverse [ self . inquiryType ()]","title":"get_inquiry_type()"},{"location":"api/bluetooth.html#prettyqt.bluetooth.bluetoothdevicediscoveryagent.BluetoothDeviceDiscoveryAgent.set_inquiry_type","text":"Set inquiry type. Parameters: Name Type Description Default typ Literal['unlimited', 'limited'] inquiry type required Exceptions: Type Description InvalidParamError inquiry type does not exist Source code in prettyqt/bluetooth/bluetoothdevicediscoveryagent.py def set_inquiry_type ( self , typ : InquiryTypeStr ): \"\"\"Set inquiry type. Args: typ: inquiry type Raises: InvalidParamError: inquiry type does not exist \"\"\" if typ not in INQUIRY_TYPES : raise InvalidParamError ( typ , INQUIRY_TYPES ) self . setInquiryType ( INQUIRY_TYPES [ typ ])","title":"set_inquiry_type()"},{"location":"api/charts.html","text":"charts module Charts module. abstractaxis AbstractAxis get_alignment ( self ) Return current alignment. Returns: Type Description Optional[Literal['left', 'right', 'top', 'bottom']] alignment Source code in prettyqt/charts/abstractaxis.py def get_alignment ( self ) -> Optional [ constants . SideStr ]: \"\"\"Return current alignment. Returns: alignment \"\"\" alignment = self . alignment () if int ( alignment ) == 0 : return None return constants . SIDES . inverse [ alignment ] get_orientation ( self ) Return current orientation. Returns: Type Description Optional[Literal['horizontal', 'vertical']] orientation Source code in prettyqt/charts/abstractaxis.py def get_orientation ( self ) -> Optional [ constants . OrientationStr ]: \"\"\"Return current orientation. Returns: orientation \"\"\" orientation = self . orientation () if int ( orientation ) == 0 : return None return constants . ORIENTATION . inverse [ orientation ] abstractbarseries AbstractBarSeries get_labels_position ( self ) Return current labels position. Returns: Type Description Literal['center', 'inside_end', 'inside_base', 'outside_end'] labels position Source code in prettyqt/charts/abstractbarseries.py def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()] set_labels_position ( self , position ) Set the labels position. Parameters: Name Type Description Default position Literal['center', 'inside_end', 'inside_base', 'outside_end'] labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/abstractbarseries.py def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ]) abstractseries AbstractSeries QAbstractSeries with some custom properties. categoryaxis CategoryAxis get_labels_position ( self ) Return current labels position. Returns: Type Description LabelsPositionStr labels position Source code in prettyqt/charts/categoryaxis.py def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()] set_labels_position ( self , position ) Set the labels position. Parameters: Name Type Description Default position LabelsPositionStr labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/categoryaxis.py def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ]) chart Chart apply_nice_numbers ( self ) Adjust both axis to display nice round numbers. Source code in prettyqt/charts/chart.py def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers () update_boundaries ( self ) Set new min/max values based on axis. Source code in prettyqt/charts/chart.py def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min () zoom_by_factor ( self , factor ) Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y )) chartview ChartView get_rubber_band ( self ) Return current rubber band type. Returns: Type Description Literal['none', 'vertical', 'horizontal', 'rectangle'] Rubber band type Source code in prettyqt/charts/chartview.py def get_rubber_band ( self ) -> RubberBandStr : \"\"\"Return current rubber band type. Returns: Rubber band type \"\"\" return RUBBER_BAND . inverse [ self . rubberBand ()] keyPressEvent ( self , event ) Handle keypress events to allow navigation via keyboard. Source code in prettyqt/charts/chartview.py def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_0 : self . chart () . apply_nice_numbers () else : super () . keyPressEvent ( event ) return event . accept () mouseMoveEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . RightButton : if not self . last_mouse_pos : return pos_diff = event . pos () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . pos () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event ) mousePressEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : cursor = gui . Cursor ( QtCore . Qt . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . pos () event . accept () super () . mousePressEvent ( event ) mouseReleaseEvent ( self , event ) Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return super () . mouseReleaseEvent ( event ) save_as_image ( self ) Let user choose folder and save chart as an image file. Source code in prettyqt/charts/chartview.py @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return self . chart () . show_legend () image = self . get_image () image . save ( str ( filename [ 0 ])) self . chart () . hide_legend () set_rubber_band ( self , typ ) Set the rubber band type. Parameters: Name Type Description Default typ Literal['none', 'vertical', 'horizontal', 'rectangle'] rubber band type required Exceptions: Type Description InvalidParamError rubber band type does not exist Source code in prettyqt/charts/chartview.py def set_rubber_band ( self , typ : RubberBandStr ): \"\"\"Set the rubber band type. Args: typ: rubber band type Raises: InvalidParamError: rubber band type does not exist \"\"\" if typ not in RUBBER_BAND : raise InvalidParamError ( typ , RUBBER_BAND ) self . setRubberBand ( RUBBER_BAND [ typ ]) wheelEvent ( self , event ) Handle wheel event for zooming. Source code in prettyqt/charts/chartview.py def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct ) legend Legend get_alignment ( self ) Return current alignment. Returns: Type Description Literal['left', 'right', 'top', 'bottom'] alignment Source code in prettyqt/charts/legend.py def get_alignment ( self ) -> constants . SideStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . SIDES . inverse [ self . alignment ()] get_marker_shape ( self ) Return current marker shape. Returns: Type Description Literal['default', 'rectangle', 'circle', 'from_series'] Marker shape Source code in prettyqt/charts/legend.py def get_marker_shape ( self ) -> MarkerShapeStr : \"\"\"Return current marker shape. Returns: Marker shape \"\"\" return MARKER_SHAPES . inverse [ self . markerShape ()] set_alignment ( self , alignment ) Set the alignment of the legend. Parameters: Name Type Description Default alignment Literal['left', 'right', 'top', 'bottom'] alignment for the legend required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/charts/legend.py def set_alignment ( self , alignment : constants . SideStr ): \"\"\"Set the alignment of the legend. Args: alignment: alignment for the legend Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . SIDES : raise InvalidParamError ( alignment , constants . SIDES ) self . setAlignment ( constants . SIDES [ alignment ]) set_marker_shape ( self , shape ) Set the marker shape. Parameters: Name Type Description Default shape Literal['default', 'rectangle', 'circle', 'from_series'] marker shape required Exceptions: Type Description InvalidParamError marker shape does not exist Source code in prettyqt/charts/legend.py def set_marker_shape ( self , shape : MarkerShapeStr ): \"\"\"Set the marker shape. Args: shape: marker shape Raises: InvalidParamError: marker shape does not exist \"\"\" if shape not in MARKER_SHAPES : raise InvalidParamError ( shape , MARKER_SHAPES ) self . setMarkerShape ( MARKER_SHAPES [ shape ]) lineseries LineSeries QLineSeries with some custom properties. pieslice PieSlice get_label_position ( self ) Return current label position. Returns: Type Description Literal['outside', 'inside_horizontal', 'inside_tangential', 'inside_normal'] label position Source code in prettyqt/charts/pieslice.py def get_label_position ( self ) -> LabelPositionStr : \"\"\"Return current label position. Returns: label position \"\"\" return LABEL_POSITION . inverse [ self . labelPosition ()] set_label_position ( self , position ) Set the label position. Parameters: Name Type Description Default position Literal['outside', 'inside_horizontal', 'inside_tangential', 'inside_normal'] label position required Exceptions: Type Description InvalidParamError label position does not exist Source code in prettyqt/charts/pieslice.py def set_label_position ( self , position : LabelPositionStr ): \"\"\"Set the label position. Args: position: label position Raises: InvalidParamError: label position does not exist \"\"\" if position not in LABEL_POSITION : raise InvalidParamError ( position , LABEL_POSITION ) self . setLabelPosition ( LABEL_POSITION [ position ]) valueaxis ValueAxis get_tick_type ( self ) Return current tick type. Returns: Type Description Literal['dynamic', 'fixed'] tick_type Source code in prettyqt/charts/valueaxis.py def get_tick_type ( self ) -> TickTypeStr : \"\"\"Return current tick type. Returns: tick_type \"\"\" return TICK_TYPES . inverse [ self . tickType ()] set_tick_type ( self , tick_type ) Set the tick type of the legend. Parameters: Name Type Description Default tick_type Literal['dynamic', 'fixed'] tick type for the legend required Exceptions: Type Description InvalidParamError tick type does not exist Source code in prettyqt/charts/valueaxis.py def set_tick_type ( self , tick_type : TickTypeStr ): \"\"\"Set the tick type of the legend. Args: tick_type: tick type for the legend Raises: InvalidParamError: tick type does not exist \"\"\" if tick_type not in TICK_TYPES : raise InvalidParamError ( tick_type , TICK_TYPES ) self . setTickType ( TICK_TYPES [ tick_type ]) xyseries XYSeries QXYSeries with some custom properties.","title":"charts"},{"location":"api/charts.html#charts-module","text":"","title":"charts module"},{"location":"api/charts.html#prettyqt.charts","text":"Charts module.","title":"prettyqt.charts"},{"location":"api/charts.html#prettyqt.charts.abstractaxis","text":"","title":"abstractaxis"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxis","text":"","title":"AbstractAxis"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxis.get_alignment","text":"Return current alignment. Returns: Type Description Optional[Literal['left', 'right', 'top', 'bottom']] alignment Source code in prettyqt/charts/abstractaxis.py def get_alignment ( self ) -> Optional [ constants . SideStr ]: \"\"\"Return current alignment. Returns: alignment \"\"\" alignment = self . alignment () if int ( alignment ) == 0 : return None return constants . SIDES . inverse [ alignment ]","title":"get_alignment()"},{"location":"api/charts.html#prettyqt.charts.abstractaxis.AbstractAxis.get_orientation","text":"Return current orientation. Returns: Type Description Optional[Literal['horizontal', 'vertical']] orientation Source code in prettyqt/charts/abstractaxis.py def get_orientation ( self ) -> Optional [ constants . OrientationStr ]: \"\"\"Return current orientation. Returns: orientation \"\"\" orientation = self . orientation () if int ( orientation ) == 0 : return None return constants . ORIENTATION . inverse [ orientation ]","title":"get_orientation()"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries","text":"","title":"abstractbarseries"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeries","text":"","title":"AbstractBarSeries"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeries.get_labels_position","text":"Return current labels position. Returns: Type Description Literal['center', 'inside_end', 'inside_base', 'outside_end'] labels position Source code in prettyqt/charts/abstractbarseries.py def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()]","title":"get_labels_position()"},{"location":"api/charts.html#prettyqt.charts.abstractbarseries.AbstractBarSeries.set_labels_position","text":"Set the labels position. Parameters: Name Type Description Default position Literal['center', 'inside_end', 'inside_base', 'outside_end'] labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/abstractbarseries.py def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ])","title":"set_labels_position()"},{"location":"api/charts.html#prettyqt.charts.abstractseries","text":"","title":"abstractseries"},{"location":"api/charts.html#prettyqt.charts.abstractseries.AbstractSeries","text":"QAbstractSeries with some custom properties.","title":"AbstractSeries"},{"location":"api/charts.html#prettyqt.charts.categoryaxis","text":"","title":"categoryaxis"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis","text":"","title":"CategoryAxis"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.get_labels_position","text":"Return current labels position. Returns: Type Description LabelsPositionStr labels position Source code in prettyqt/charts/categoryaxis.py def get_labels_position ( self ) -> LabelsPositionStr : \"\"\"Return current labels position. Returns: labels position \"\"\" return LABELS_POSITIONS . inverse [ self . labelsPosition ()]","title":"get_labels_position()"},{"location":"api/charts.html#prettyqt.charts.categoryaxis.CategoryAxis.set_labels_position","text":"Set the labels position. Parameters: Name Type Description Default position LabelsPositionStr labels position required Exceptions: Type Description InvalidParamError labels position does not exist Source code in prettyqt/charts/categoryaxis.py def set_labels_position ( self , position : LabelsPositionStr ): \"\"\"Set the labels position. Args: position: labels position Raises: InvalidParamError: labels position does not exist \"\"\" if position not in LABELS_POSITIONS : raise InvalidParamError ( position , LABELS_POSITIONS ) self . setLabelsPosition ( LABELS_POSITIONS [ position ])","title":"set_labels_position()"},{"location":"api/charts.html#prettyqt.charts.chart","text":"","title":"chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart","text":"","title":"Chart"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.apply_nice_numbers","text":"Adjust both axis to display nice round numbers. Source code in prettyqt/charts/chart.py def apply_nice_numbers ( self ): \"\"\"Adjust both axis to display nice round numbers.\"\"\" self . axisX () . applyNiceNumbers () self . axisY () . applyNiceNumbers ()","title":"apply_nice_numbers()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.update_boundaries","text":"Set new min/max values based on axis. Source code in prettyqt/charts/chart.py def update_boundaries ( self ): \"\"\"Set new min/max values based on axis.\"\"\" self . max_x = self . axisX () . max () self . max_y = self . axisY () . max () self . min_x = self . axisX () . min () self . min_y = self . axisY () . min ()","title":"update_boundaries()"},{"location":"api/charts.html#prettyqt.charts.chart.Chart.zoom_by_factor","text":"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far Source code in prettyqt/charts/chart.py def zoom_by_factor ( self , factor : float ): \"\"\"Zoom in/out by factor (1.0 = no change). Make sure that we dont zoom out too far \"\"\" self . zoom ( factor ) if self . axisX () . min () < self . min_x : self . axisX () . setMin ( self . min_x ) if self . axisX () . max () > self . max_x : self . axisX () . setMax ( self . max_x ) if self . axisY () . max () > self . max_y : self . axisY () . setMax ( self . max_y ) # always bottom-align when zooming for now. should perhaps become optional. # if self.axisY().min() < self.min_y: self . axisY () . setMin ( max ( 0 , self . min_y ))","title":"zoom_by_factor()"},{"location":"api/charts.html#prettyqt.charts.chartview","text":"","title":"chartview"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView","text":"","title":"ChartView"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.get_rubber_band","text":"Return current rubber band type. Returns: Type Description Literal['none', 'vertical', 'horizontal', 'rectangle'] Rubber band type Source code in prettyqt/charts/chartview.py def get_rubber_band ( self ) -> RubberBandStr : \"\"\"Return current rubber band type. Returns: Rubber band type \"\"\" return RUBBER_BAND . inverse [ self . rubberBand ()]","title":"get_rubber_band()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.keyPressEvent","text":"Handle keypress events to allow navigation via keyboard. Source code in prettyqt/charts/chartview.py def keyPressEvent ( self , event : QtGui . QKeyEvent ): \"\"\"Handle keypress events to allow navigation via keyboard.\"\"\" key = event . key () if key == QtCore . Qt . Key_Escape : self . chart () . zoomReset () elif key == QtCore . Qt . Key_Plus : self . chart () . zoom_by_factor ( ZOOM_IN_FACTOR ) elif key == QtCore . Qt . Key_Minus : self . chart () . zoom_by_factor ( ZOOM_OUT_FACTOR ) elif key == QtCore . Qt . Key_Left : self . chart () . scroll ( - SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Right : self . chart () . scroll ( SCROLL_STEP_SIZE , 0 ) elif key == QtCore . Qt . Key_Up : self . chart () . scroll ( 0 , SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_Down : self . chart () . scroll ( 0 , - SCROLL_STEP_SIZE ) elif key == QtCore . Qt . Key_0 : self . chart () . apply_nice_numbers () else : super () . keyPressEvent ( event ) return event . accept ()","title":"keyPressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseMoveEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseMoveEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" # pan the chart with a middle mouse drag if event . buttons () & QtCore . Qt . RightButton : if not self . last_mouse_pos : return pos_diff = event . pos () - self . last_mouse_pos self . chart () . scroll ( - pos_diff . x (), pos_diff . y ()) self . last_mouse_pos = event . pos () event . accept () widgets . Application . restoreOverrideCursor () super () . mouseMoveEvent ( event )","title":"mouseMoveEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mousePressEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mousePressEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : cursor = gui . Cursor ( QtCore . Qt . SizeAllCursor ) widgets . Application . setOverrideCursor ( cursor ) self . last_mouse_pos = event . pos () event . accept () super () . mousePressEvent ( event )","title":"mousePressEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.mouseReleaseEvent","text":"Override to allow dragging the chart. Source code in prettyqt/charts/chartview.py def mouseReleaseEvent ( self , event : QtGui . QMouseEvent ): \"\"\"Override to allow dragging the chart.\"\"\" if event . button () == QtCore . Qt . RightButton : widgets . Application . restoreOverrideCursor () event . accept () return super () . mouseReleaseEvent ( event )","title":"mouseReleaseEvent()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.save_as_image","text":"Let user choose folder and save chart as an image file. Source code in prettyqt/charts/chartview.py @core . Slot () def save_as_image ( self ): \"\"\"Let user choose folder and save chart as an image file.\"\"\" dlg = widgets . FileDialog ( mode = \"save\" , caption = \"Save image\" ) filters = { \"Bmp files\" : [ \".bmp\" ], \"Jpeg files\" : [ \".jpg\" ], \"Png files\" : [ \".png\" ]} dlg . set_extension_filter ( filters ) filename = dlg . open_file () if not filename : return self . chart () . show_legend () image = self . get_image () image . save ( str ( filename [ 0 ])) self . chart () . hide_legend ()","title":"save_as_image()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.set_rubber_band","text":"Set the rubber band type. Parameters: Name Type Description Default typ Literal['none', 'vertical', 'horizontal', 'rectangle'] rubber band type required Exceptions: Type Description InvalidParamError rubber band type does not exist Source code in prettyqt/charts/chartview.py def set_rubber_band ( self , typ : RubberBandStr ): \"\"\"Set the rubber band type. Args: typ: rubber band type Raises: InvalidParamError: rubber band type does not exist \"\"\" if typ not in RUBBER_BAND : raise InvalidParamError ( typ , RUBBER_BAND ) self . setRubberBand ( RUBBER_BAND [ typ ])","title":"set_rubber_band()"},{"location":"api/charts.html#prettyqt.charts.chartview.ChartView.wheelEvent","text":"Handle wheel event for zooming. Source code in prettyqt/charts/chartview.py def wheelEvent ( self , event : QtGui . QWheelEvent ): \"\"\"Handle wheel event for zooming.\"\"\" fct = ZOOM_IN_FACTOR if event . angleDelta () . y () > 0 else ZOOM_OUT_FACTOR self . chart () . zoom_by_factor ( fct )","title":"wheelEvent()"},{"location":"api/charts.html#prettyqt.charts.legend","text":"","title":"legend"},{"location":"api/charts.html#prettyqt.charts.legend.Legend","text":"","title":"Legend"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_alignment","text":"Return current alignment. Returns: Type Description Literal['left', 'right', 'top', 'bottom'] alignment Source code in prettyqt/charts/legend.py def get_alignment ( self ) -> constants . SideStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . SIDES . inverse [ self . alignment ()]","title":"get_alignment()"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.get_marker_shape","text":"Return current marker shape. Returns: Type Description Literal['default', 'rectangle', 'circle', 'from_series'] Marker shape Source code in prettyqt/charts/legend.py def get_marker_shape ( self ) -> MarkerShapeStr : \"\"\"Return current marker shape. Returns: Marker shape \"\"\" return MARKER_SHAPES . inverse [ self . markerShape ()]","title":"get_marker_shape()"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_alignment","text":"Set the alignment of the legend. Parameters: Name Type Description Default alignment Literal['left', 'right', 'top', 'bottom'] alignment for the legend required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/charts/legend.py def set_alignment ( self , alignment : constants . SideStr ): \"\"\"Set the alignment of the legend. Args: alignment: alignment for the legend Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . SIDES : raise InvalidParamError ( alignment , constants . SIDES ) self . setAlignment ( constants . SIDES [ alignment ])","title":"set_alignment()"},{"location":"api/charts.html#prettyqt.charts.legend.Legend.set_marker_shape","text":"Set the marker shape. Parameters: Name Type Description Default shape Literal['default', 'rectangle', 'circle', 'from_series'] marker shape required Exceptions: Type Description InvalidParamError marker shape does not exist Source code in prettyqt/charts/legend.py def set_marker_shape ( self , shape : MarkerShapeStr ): \"\"\"Set the marker shape. Args: shape: marker shape Raises: InvalidParamError: marker shape does not exist \"\"\" if shape not in MARKER_SHAPES : raise InvalidParamError ( shape , MARKER_SHAPES ) self . setMarkerShape ( MARKER_SHAPES [ shape ])","title":"set_marker_shape()"},{"location":"api/charts.html#prettyqt.charts.lineseries","text":"","title":"lineseries"},{"location":"api/charts.html#prettyqt.charts.lineseries.LineSeries","text":"QLineSeries with some custom properties.","title":"LineSeries"},{"location":"api/charts.html#prettyqt.charts.pieslice","text":"","title":"pieslice"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice","text":"","title":"PieSlice"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.get_label_position","text":"Return current label position. Returns: Type Description Literal['outside', 'inside_horizontal', 'inside_tangential', 'inside_normal'] label position Source code in prettyqt/charts/pieslice.py def get_label_position ( self ) -> LabelPositionStr : \"\"\"Return current label position. Returns: label position \"\"\" return LABEL_POSITION . inverse [ self . labelPosition ()]","title":"get_label_position()"},{"location":"api/charts.html#prettyqt.charts.pieslice.PieSlice.set_label_position","text":"Set the label position. Parameters: Name Type Description Default position Literal['outside', 'inside_horizontal', 'inside_tangential', 'inside_normal'] label position required Exceptions: Type Description InvalidParamError label position does not exist Source code in prettyqt/charts/pieslice.py def set_label_position ( self , position : LabelPositionStr ): \"\"\"Set the label position. Args: position: label position Raises: InvalidParamError: label position does not exist \"\"\" if position not in LABEL_POSITION : raise InvalidParamError ( position , LABEL_POSITION ) self . setLabelPosition ( LABEL_POSITION [ position ])","title":"set_label_position()"},{"location":"api/charts.html#prettyqt.charts.valueaxis","text":"","title":"valueaxis"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxis","text":"","title":"ValueAxis"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxis.get_tick_type","text":"Return current tick type. Returns: Type Description Literal['dynamic', 'fixed'] tick_type Source code in prettyqt/charts/valueaxis.py def get_tick_type ( self ) -> TickTypeStr : \"\"\"Return current tick type. Returns: tick_type \"\"\" return TICK_TYPES . inverse [ self . tickType ()]","title":"get_tick_type()"},{"location":"api/charts.html#prettyqt.charts.valueaxis.ValueAxis.set_tick_type","text":"Set the tick type of the legend. Parameters: Name Type Description Default tick_type Literal['dynamic', 'fixed'] tick type for the legend required Exceptions: Type Description InvalidParamError tick type does not exist Source code in prettyqt/charts/valueaxis.py def set_tick_type ( self , tick_type : TickTypeStr ): \"\"\"Set the tick type of the legend. Args: tick_type: tick type for the legend Raises: InvalidParamError: tick type does not exist \"\"\" if tick_type not in TICK_TYPES : raise InvalidParamError ( tick_type , TICK_TYPES ) self . setTickType ( TICK_TYPES [ tick_type ])","title":"set_tick_type()"},{"location":"api/charts.html#prettyqt.charts.xyseries","text":"","title":"xyseries"},{"location":"api/charts.html#prettyqt.charts.xyseries.XYSeries","text":"QXYSeries with some custom properties.","title":"XYSeries"},{"location":"api/constants.html","text":"constants module Constants module.","title":"constants"},{"location":"api/constants.html#constants-module","text":"","title":"constants module"},{"location":"api/constants.html#prettyqt.constants","text":"Constants module.","title":"prettyqt.constants"},{"location":"api/core.html","text":"core module Core module. Contains QtCore-based classes abstractanimation AbstractAnimation get_direction ( self ) Get the current animation direction. Returns: Type Description Literal['forward', 'backward'] animation direction Source code in prettyqt/core/abstractanimation.py def get_direction ( self ) -> DirectionStr : \"\"\"Get the current animation direction. Returns: animation direction \"\"\" return DIRECTION . inverse [ self . direction ()] get_state ( self ) Get the current animation state. Returns: Type Description Literal['stopped', 'paused', 'running'] animation state Source code in prettyqt/core/abstractanimation.py def get_state ( self ) -> StateStr : \"\"\"Get the current animation state. Returns: animation state \"\"\" return STATE . inverse [ self . state ()] set_direction ( self , direction ) Set animation direction. Parameters: Name Type Description Default direction Literal['forward', 'backward'] animation direction required Exceptions: Type Description InvalidParamError animation direction does not exist Source code in prettyqt/core/abstractanimation.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set animation direction. Args: direction: animation direction Raises: InvalidParamError: animation direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) start_animation ( self , policy ) Start the animation. Parameters: Name Type Description Default policy Literal['keep', 'delete'] animation policy required Exceptions: Type Description InvalidParamError animation policy does not exist Source code in prettyqt/core/abstractanimation.py def start_animation ( self , policy : DeletionPolicyStr ): \"\"\"Start the animation. Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" if policy not in DELETION_POLICY : raise InvalidParamError ( policy , DELETION_POLICY ) self . start ( DELETION_POLICY [ policy ]) abstractitemmodel AbstractItemModel __len__ ( self ) special Return amount of rows. Source code in prettyqt/core/abstractitemmodel.py def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount () change_layout ( self ) Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit () reset_model ( self ) Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel () abstracttransition AbstractTransition get_transition_type ( self ) Return current transition type. Returns: Type Description Literal['exclusive', 'parallel'] transition type Source code in prettyqt/core/abstracttransition.py def get_transition_type ( self ) -> TransitionTypeStr : \"\"\"Return current transition type. Returns: transition type \"\"\" return TRANSITION_TYPE . inverse [ self . transitionType ()] set_transition_type ( self , typ ) Set transition type. Parameters: Name Type Description Default typ Literal['exclusive', 'parallel'] transition type to use required Exceptions: Type Description InvalidParamError transition type does not exist Source code in prettyqt/core/abstracttransition.py def set_transition_type ( self , typ : TransitionTypeStr ): \"\"\"Set transition type. Args: typ: transition type to use Raises: InvalidParamError: transition type does not exist \"\"\" if typ not in TRANSITION_TYPE : raise InvalidParamError ( typ , TRANSITION_TYPE ) self . setTransitionType ( TRANSITION_TYPE [ typ ]) bytearray ByteArray __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/bytearray.py def __reduce__ ( self ): return type ( self ), ( bytes ( self ),) collator Collator is_case_sensitive ( self ) Return case sensitivity. Returns: Type Description bool case sensitivity Source code in prettyqt/core/collator.py def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ()) set_case_sensitive ( self , state ) Set case sensitivity. Parameters: Name Type Description Default state bool case sensitive required Source code in prettyqt/core/collator.py def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = QtCore . Qt . CaseSensitive if state else QtCore . Qt . CaseInsensitive self . setCaseSensitivity ( sensitivity ) commandlineparser CommandLineParser set_options_after_positional_arguments_mode ( self , mode ) Set the options after positional arguments mode. Parameters: Name Type Description Default mode Literal['compacted_short', 'long'] options after positional arguments mode required Exceptions: Type Description InvalidParamError options after positional arguments mode does not exist Source code in prettyqt/core/commandlineparser.py def set_options_after_positional_arguments_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the options after positional arguments mode. Args: mode: options after positional arguments mode Raises: InvalidParamError: options after positional arguments mode does not exist \"\"\" if mode not in OPTIONS_AFTER_POS_ARG : raise InvalidParamError ( mode , OPTIONS_AFTER_POS_ARG ) self . setOptionsAfterPositionalArgumentsMode ( OPTIONS_AFTER_POS_ARG [ mode ]) set_single_dash_word_option_mode ( self , mode ) Set the single dash word option mode. Parameters: Name Type Description Default mode Literal['compacted_short', 'long'] single dash word option mode required Exceptions: Type Description InvalidParamError single dash word option mode does not exist Source code in prettyqt/core/commandlineparser.py def set_single_dash_word_option_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the single dash word option mode. Args: mode: single dash word option mode Raises: InvalidParamError: single dash word option mode does not exist \"\"\" if mode not in SINGLE_DASH_WORD : raise InvalidParamError ( mode , SINGLE_DASH_WORD ) self . setSingleDashWordOptionMode ( SINGLE_DASH_WORD [ mode ]) datastream DataStream get_byte_order ( self ) Return byte order. Returns: Type Description Literal['big_endian', 'little_endian'] byte order Source code in prettyqt/core/datastream.py def get_byte_order ( self ) -> ByteOrderStr : \"\"\"Return byte order. Returns: byte order \"\"\" return BYTE_ORDER . inverse [ self . byteOrder ()] get_float_precision ( self ) Return floating point precision. Returns: Type Description Literal['single', 'double'] floating point precision Source code in prettyqt/core/datastream.py def get_float_precision ( self ) -> FloatPrecisionStr : \"\"\"Return floating point precision. Returns: floating point precision \"\"\" return FLOAT_PRECISION . inverse [ self . floatingPointPrecision ()] set_byte_order ( self , order ) Set byte order. Parameters: Name Type Description Default order Literal['big_endian', 'little_endian'] byte order to use required Exceptions: Type Description InvalidParamError invalid order Source code in prettyqt/core/datastream.py def set_byte_order ( self , order : ByteOrderStr ): \"\"\"Set byte order. Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ]) set_float_precision ( self , precision ) Set floating point precision. Parameters: Name Type Description Default precision Literal['single', 'double'] floating point precision required Exceptions: Type Description InvalidParamError invalid precision Source code in prettyqt/core/datastream.py def set_float_precision ( self , precision : FloatPrecisionStr ): \"\"\"Set floating point precision. Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOAT_PRECISION : raise InvalidParamError ( precision , FLOAT_PRECISION ) self . setFloatingPointPrecision ( FLOAT_PRECISION [ precision ]) date Date __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/date.py def __reduce__ ( self ): return type ( self ), ( self . year (), self . month (), self . day ()) datetime DateTime __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/datetime.py def __reduce__ ( self ): return type ( self ), ( self . date (), self . time (), self . get_timezone ()) get_time_spec ( self ) Return current time specification. Returns: Type Description Literal['local_time', 'utc', 'offset_from_utc', 'timezone'] time specification Source code in prettyqt/core/datetime.py def get_time_spec ( self ) -> constants . TimeSpecStr : \"\"\"Return current time specification. Returns: time specification \"\"\" return constants . TIME_SPEC . inverse [ self . timeSpec ()] set_time_spec ( self , spec ) Set the time specification. Parameters: Name Type Description Default spec Literal['local_time', 'utc', 'offset_from_utc', 'timezone'] time specification to use required Exceptions: Type Description InvalidParamError time specification does not exist Source code in prettyqt/core/datetime.py def set_time_spec ( self , spec : constants . TimeSpecStr ): \"\"\"Set the time specification. Args: spec: time specification to use Raises: InvalidParamError: time specification does not exist \"\"\" if spec not in constants . TIME_SPEC : raise InvalidParamError ( spec , constants . TIME_SPEC ) self . setTimeSpec ( constants . TIME_SPEC [ spec ]) deadlinetimer DeadlineTimer get_type ( self ) Return current timer type. Returns: Type Description Literal['precise', 'coarse', 'very_coarse'] timer type Source code in prettyqt/core/deadlinetimer.py def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()] set_type ( self , typ ) Set the timer type. Parameters: Name Type Description Default typ Literal['precise', 'coarse', 'very_coarse'] timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/deadlinetimer.py def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ]) easingcurve EasingCurve get_type ( self ) Get the current easing curve type. Returns: Type Description Literal['linear', 'in_quad', 'out_quad', 'in_out_quad', 'out_in_quad', 'in_cubic', 'out_cubic', 'in_out_cubic', 'out_in_cubic', 'in_quart', 'out_quart', 'in_out_quart', 'out_in_quart', 'in_quint', 'out_quint', 'in_out_quint', 'out_in_quint', 'in_sine', 'out_sine', 'in_out_sine', 'out_in_sine', 'in_expo', 'out_expo', 'in_out_expo', 'out_in_expo', 'in_circ', 'out_circ', 'in_out_circ', 'out_in_circ', 'in_elastic', 'out_elastic', 'in_out_elastic', 'out_in_elastic', 'in_back', 'out_back', 'in_out_back', 'out_in_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'out_in_bounce', 'bezier_spline', 'tcb_spline', 'custom'] easing curve type Source code in prettyqt/core/easingcurve.py def get_type ( self ) -> TypeStr : \"\"\"Get the current easing curve type. Returns: easing curve type \"\"\" return TYPE . inverse [ self . type ()] set_type ( self , typ ) Set easing curve type. Parameters: Name Type Description Default typ Literal['linear', 'in_quad', 'out_quad', 'in_out_quad', 'out_in_quad', 'in_cubic', 'out_cubic', 'in_out_cubic', 'out_in_cubic', 'in_quart', 'out_quart', 'in_out_quart', 'out_in_quart', 'in_quint', 'out_quint', 'in_out_quint', 'out_in_quint', 'in_sine', 'out_sine', 'in_out_sine', 'out_in_sine', 'in_expo', 'out_expo', 'in_out_expo', 'out_in_expo', 'in_circ', 'out_circ', 'in_out_circ', 'out_in_circ', 'in_elastic', 'out_elastic', 'in_out_elastic', 'out_in_elastic', 'in_back', 'out_back', 'in_out_back', 'out_in_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'out_in_bounce', 'bezier_spline', 'tcb_spline', 'custom'] easing curve type required Exceptions: Type Description InvalidParamError easing curve type does not exist Source code in prettyqt/core/easingcurve.py def set_type ( self , typ : TypeStr ): \"\"\"Set easing curve type. Args: typ: easing curve type Raises: InvalidParamError: easing curve type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setType ( TYPE [ typ ]) elapsedtimer ElapsedTimer get_clock_type ( self ) Return current clock type. Returns: Type Description Literal['system_time', 'monotonic_clock', 'tick_counter', 'mach_absolute_time', 'performance_counter'] clock type Source code in prettyqt/core/elapsedtimer.py def get_clock_type ( self ) -> ClockTypeStr : \"\"\"Return current clock type. Returns: clock type \"\"\" return CLOCK_TYPE . inverse [ self . clockType ()] filedevice FileDevice get_error ( self ) Return file error status. Returns: Type Description Literal['none', 'read', 'write', 'fatal', 'resource', 'open', 'abort', 'time_out', 'unspecified', 'remove', 'rename', 'position', 'resize', 'permissions', 'copy'] file error status Source code in prettyqt/core/filedevice.py def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return FILE_ERROR . inverse [ self . error ()] get_file_time ( self , typ ) Return current file time. Returns: Type Description Optional[datetime.datetime] file time Source code in prettyqt/core/filedevice.py def get_file_time ( self , typ : FileTimeStr ) -> Optional [ datetime . datetime ]: \"\"\"Return current file time. Returns: file time \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) date = self . fileTime ( FILE_TIME [ typ ]) if not date : return None return to_datetime ( date ) set_file_time ( self , file_time , typ ) Set file time. Parameters: Name Type Description Default typ Literal['access', 'birth', 'metadata_change', 'modification'] file time to use required Exceptions: Type Description InvalidParamError file time does not exist Source code in prettyqt/core/filedevice.py def set_file_time ( self , file_time : Union [ QtCore . QDateTime , datetime . datetime ], typ : FileTimeStr ) -> bool : \"\"\"Set file time. Args: typ: file time to use Raises: InvalidParamError: file time does not exist \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) return self . setFileTime ( file_time , FILE_TIME [ typ ]) # type: ignore historystate HistoryState get_history_type ( self ) Return current history type. Returns: Type Description Literal['shallow', 'deep'] history type Source code in prettyqt/core/historystate.py def get_history_type ( self ) -> HistoryTypeStr : \"\"\"Return current history type. Returns: history type \"\"\" return HISTORY_TYPE . inverse [ self . historyType ()] set_history_type ( self , typ ) Set history type to use. Parameters: Name Type Description Default typ Literal['shallow', 'deep'] history type to use required Exceptions: Type Description InvalidParamError history type does not exist Source code in prettyqt/core/historystate.py def set_history_type ( self , typ : HistoryTypeStr ): \"\"\"Set history type to use. Args: typ: history type to use Raises: InvalidParamError: history type does not exist \"\"\" if typ not in HISTORY_TYPE : raise InvalidParamError ( typ , HISTORY_TYPE ) self . setHistoryType ( HISTORY_TYPE [ typ ]) line Line __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/line.py def __reduce__ ( self ): return type ( self ), ( self . get_p1 (), self . get_p1 ()) linef LineF __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/linef.py def __reduce__ ( self ): return type ( self ), ( self . get_p1 (), self . get_p1 ()) operatingsystemversion OperatingSystemVersion get_type ( self ) Get current os type. Returns: Type Description Literal['android', 'ios', 'mac_os', 'tv_os', 'watch_os', 'windows', 'unknown'] current os type Source code in prettyqt/core/operatingsystemversion.py def get_type ( self ) -> OsTypeStr : \"\"\"Get current os type. Returns: current os type \"\"\" return OS_TYPE . inverse [ self . type ()] point Point __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/point.py def __reduce__ ( self ): return type ( self ), ( self . x (), self . y ()) pointf PointF __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/pointf.py def __reduce__ ( self ): return type ( self ), ( self . x (), self . y ()) process Process set_input_channel_mode ( self , mode ) Set the input channel mode. Parameters: Name Type Description Default mode Literal['managed', 'forwarded'] mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_input_channel_mode ( self , mode : InputChannelModeStr ): \"\"\"Set the input channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in INPUT_CHANNEL_MODES : raise InvalidParamError ( mode , INPUT_CHANNEL_MODES ) self . setInputChannelMode ( INPUT_CHANNEL_MODES [ mode ]) set_process_channel_mode ( self , mode ) Set the process channel mode. Parameters: Name Type Description Default mode Literal['separate', 'merged', 'forwarded', 'forwarded_error', 'forwarded_output'] mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_process_channel_mode ( self , mode : ProcessChannelModeStr ): \"\"\"Set the process channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in PROCESS_CHANNEL_MODES : raise InvalidParamError ( mode , PROCESS_CHANNEL_MODES ) self . setProcessChannelMode ( PROCESS_CHANNEL_MODES [ mode ]) set_read_channel ( self , channel ) Set the input channel channel. Parameters: Name Type Description Default channel Literal['standard', 'error'] channel to set required Exceptions: Type Description InvalidParamError invalid channel Source code in prettyqt/core/process.py def set_read_channel ( self , channel : ProcessChannelStr ): \"\"\"Set the input channel channel. Args: channel: channel to set Raises: InvalidParamError: invalid channel \"\"\" if channel not in PROCESS_CHANNELS : raise InvalidParamError ( channel , PROCESS_CHANNELS ) self . setReadChannel ( PROCESS_CHANNELS [ channel ]) set_state ( self , state ) Set the process state. Parameters: Name Type Description Default state Literal['not_running', 'starting', 'running'] state to set required Exceptions: Type Description InvalidParamError invalid state Source code in prettyqt/core/process.py def set_state ( self , state : ProcessStateStr ): \"\"\"Set the process state. Args: state: state to set Raises: InvalidParamError: invalid state \"\"\" if state not in PROCESS_STATES : raise InvalidParamError ( state , PROCESS_STATES ) self . setProcessState ( PROCESS_STATES [ state ]) rect Rect __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/rect.py def __reduce__ ( self ): return type ( self ), ( self . x (), self . y (), self . width (), self . height ()) rectf RectF __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/rectf.py def __reduce__ ( self ): return type ( self ), ( self . x (), self . y (), self . width (), self . height ()) regularexpression RegularExpression globalMatch ( self , * args , ** kwargs ) globalMatch(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it ) match ( self , text , offset = 0 , match_type = 'normal' , anchored = False ) match(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py def match ( # type: ignore self , text : str , offset : int = 0 , match_type : Union [ MatchTypeStr , QtCore . QRegularExpression . MatchType ] = \"normal\" , anchored : bool = False , ) -> core . RegularExpressionMatch : if isinstance ( match_type , str ): typ = MATCH_TYPE [ match_type ] else : typ = match_type if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , typ , options ) return core . RegularExpressionMatch ( match ) settings Settings edit_group ( self , prefix ) Context manager for setting groups. Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py @contextlib . contextmanager def edit_group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup () get_default_format () classmethod Return default settings format. Returns: Type Description Literal['user', 'system'] default settings format Source code in prettyqt/core/settings.py @classmethod def get_default_format ( cls ) -> FormatStr : \"\"\"Return default settings format. Returns: default settings format \"\"\" return FORMAT . inverse [ cls . defaultFormat ()] get_scope ( self ) Return scope. Returns: Type Description Literal['user', 'system'] scope Source code in prettyqt/core/settings.py def get_scope ( self ) -> ScopeStr : \"\"\"Return scope. Returns: scope \"\"\" return SCOPE . inverse [ self . scope ()] read_array ( self , prefix ) Context manager for reading arrays. Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray () set_default_format ( fmt ) classmethod Set the default format. Parameters: Name Type Description Default fmt Literal['user', 'system'] the default format to use required Exceptions: Type Description InvalidParamError invalid format Source code in prettyqt/core/settings.py @classmethod def set_default_format ( cls , fmt : FormatStr ): \"\"\"Set the default format. Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) cls . setDefaultFormat ( FORMAT [ fmt ]) set_path ( fmt , scope , path ) classmethod Set the path to the settings file. Parameters: Name Type Description Default fmt Literal['user', 'system'] the default format to use required scope Literal['user', 'system'] the scope to use required Exceptions: Type Description InvalidParamError invalid format or scope Source code in prettyqt/core/settings.py @classmethod def set_path ( cls , fmt : FormatStr , scope : ScopeStr , path : Union [ str , pathlib . Path ]): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) if scope not in SCOPE : raise InvalidParamError ( scope , SCOPE ) cls . setPath ( FORMAT [ fmt ], SCOPE [ scope ], str ( path )) write_array ( self , prefix , size =- 1 ) Context manager for writing arrays. Parameters: Name Type Description Default prefix str prefix for settings array required size int size of settings array -1 Source code in prettyqt/core/settings.py @contextlib . contextmanager def write_array ( self , prefix : str , size : int = - 1 ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" self . beginWriteArray ( prefix , size ) yield None self . endArray () size Size __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/size.py def __reduce__ ( self ): return type ( self ), ( self . width (), self . height ()) sizef SizeF __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/sizef.py def __reduce__ ( self ): return type ( self ), ( self . width (), self . height ()) socketnotifier SocketNotifier get_type ( self ) Return socket event type. Returns: Type Description Literal['read', 'write', 'exception'] socket event type Source code in prettyqt/core/socketnotifier.py def get_type ( self ) -> TypeStr : \"\"\"Return socket event type. Returns: socket event type \"\"\" return TYPE . inverse [ self . type ()] state State get_child_mode ( self ) Return current child mode. Returns: Type Description Literal['exclusive', 'parallel'] child mode Source code in prettyqt/core/state.py def get_child_mode ( self ) -> ChildModeStr : \"\"\"Return current child mode. Returns: child mode \"\"\" return CHILD_MODE . inverse [ self . childMode ()] set_child_mode ( self , mode ) Set child mode to use. Parameters: Name Type Description Default mode Literal['exclusive', 'parallel'] child mode to use required Exceptions: Type Description InvalidParamError child mode does not exist Source code in prettyqt/core/state.py def set_child_mode ( self , mode : ChildModeStr ): \"\"\"Set child mode to use. Args: mode: child mode to use Raises: InvalidParamError: child mode does not exist \"\"\" if mode not in CHILD_MODE : raise InvalidParamError ( mode , CHILD_MODE ) self . setChildMode ( CHILD_MODE [ mode ]) statemachine StateMachine get_global_restore_policy ( self ) Return current restore policy. Returns: Type Description core.state.RestorePolicyStr restore policy Source code in prettyqt/core/statemachine.py def get_global_restore_policy ( self ) -> core . state . RestorePolicyStr : \"\"\"Return current restore policy. Returns: restore policy \"\"\" return core . state . RESTORE_POLICY . inverse [ self . globalRestorePolicy ()] set_global_restore_policy ( self , policy ) Set restore policy to use. Parameters: Name Type Description Default policy core.state.RestorePolicyStr restore policy to use required Exceptions: Type Description InvalidParamError restore policy does not exist Source code in prettyqt/core/statemachine.py def set_global_restore_policy ( self , policy : core . state . RestorePolicyStr ): \"\"\"Set restore policy to use. Args: policy: restore policy to use Raises: InvalidParamError: restore policy does not exist \"\"\" if policy not in core . state . RESTORE_POLICY : raise InvalidParamError ( policy , core . state . RESTORE_POLICY ) self . setGlobalRestorePolicy ( core . state . RESTORE_POLICY [ policy ]) textstream TextStream get_field_alignment ( self ) Get current field alignment. Returns: Type Description Literal['left', 'right', 'center', 'accounting_style'] current field alignment Source code in prettyqt/core/textstream.py def get_field_alignment ( self ) -> FieldAlignmentStr : \"\"\"Get current field alignment. Returns: current field alignment \"\"\" return FIELD_ALIGNMENT . inverse [ self . fieldAlignment ()] get_real_number_notation ( self ) Get current real number notation. Returns: Type Description Literal['scientific', 'fixed', 'smart'] current real number notation Source code in prettyqt/core/textstream.py def get_real_number_notation ( self ) -> RealNumberNotationStr : \"\"\"Get current real number notation. Returns: current real number notation \"\"\" return REAL_NUMBER_NOTATION . inverse [ self . realNumberNotation ()] get_status ( self ) Get current status. Returns: Type Description Literal['ok', 'read_past_end', 'read_corrupt_data', 'write_failed'] current status Source code in prettyqt/core/textstream.py def get_status ( self ) -> StatusStr : \"\"\"Get current status. Returns: current status \"\"\" return STATUS . inverse [ self . status ()] set_field_alignment ( self , alignment ) Set the field alignment. Parameters: Name Type Description Default alignment Literal['left', 'right', 'center', 'accounting_style'] field alignment required Exceptions: Type Description InvalidParamError invalid field alignment Source code in prettyqt/core/textstream.py def set_field_alignment ( self , alignment : FieldAlignmentStr ): \"\"\"Set the field alignment. Args: alignment: field alignment Raises: InvalidParamError: invalid field alignment \"\"\" if alignment not in FIELD_ALIGNMENT : raise InvalidParamError ( alignment , FIELD_ALIGNMENT ) self . setFieldAlignment ( FIELD_ALIGNMENT [ alignment ]) set_real_number_notation ( self , notation ) Set the real number notation. Parameters: Name Type Description Default notation Literal['scientific', 'fixed', 'smart'] real number notation required Exceptions: Type Description InvalidParamError invalid real number notation Source code in prettyqt/core/textstream.py def set_real_number_notation ( self , notation : RealNumberNotationStr ): \"\"\"Set the real number notation. Args: notation: real number notation Raises: InvalidParamError: invalid real number notation \"\"\" if notation not in REAL_NUMBER_NOTATION : raise InvalidParamError ( notation , REAL_NUMBER_NOTATION ) self . setRealNumberNotation ( REAL_NUMBER_NOTATION [ notation ]) set_status ( self , status ) Set the status. Parameters: Name Type Description Default status Literal['ok', 'read_past_end', 'read_corrupt_data', 'write_failed'] status required Exceptions: Type Description InvalidParamError invalid status Source code in prettyqt/core/textstream.py def set_status ( self , status : StatusStr ): \"\"\"Set the status. Args: status: status Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ]) time Time __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/core/time.py def __reduce__ ( self ): return type ( self ), ( self . hour (), self . minute (), self . second (), self . msec ()) timeline TimeLine get_direction ( self ) Return current direction. Returns: Type Description Literal['forward', 'backward'] direction Source code in prettyqt/core/timeline.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()] get_state ( self ) Return current state. Returns: Type Description Literal['not_running', 'paused', 'running'] state Source code in prettyqt/core/timeline.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()] set_direction ( self , direction ) Set the direction. Parameters: Name Type Description Default direction Literal['forward', 'backward'] direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/core/timeline.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) timer Timer get_type ( self ) Return current timer type. Returns: Type Description constants.TimerTypeStr timer type Source code in prettyqt/core/timer.py def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()] set_type ( self , typ ) Set the timer type. Parameters: Name Type Description Default typ constants.TimerTypeStr timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/timer.py def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ]) url Url to_path ( self ) Get pathlib object from the URL. Returns: Type Description pathlib.Path Path Source code in prettyqt/core/url.py def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self )) versionnumber VersionNumber major ( self ) An integer representing the major version. Source code in prettyqt/core/versionnumber.py def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion () micro ( self ) An integer representing the micro version. Source code in prettyqt/core/versionnumber.py def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion () minor ( self ) An integer representing the minor version. Source code in prettyqt/core/versionnumber.py def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion ()","title":"core"},{"location":"api/core.html#core-module","text":"","title":"core module"},{"location":"api/core.html#prettyqt.core","text":"Core module. Contains QtCore-based classes","title":"prettyqt.core"},{"location":"api/core.html#prettyqt.core.abstractanimation","text":"","title":"abstractanimation"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation","text":"","title":"AbstractAnimation"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.get_direction","text":"Get the current animation direction. Returns: Type Description Literal['forward', 'backward'] animation direction Source code in prettyqt/core/abstractanimation.py def get_direction ( self ) -> DirectionStr : \"\"\"Get the current animation direction. Returns: animation direction \"\"\" return DIRECTION . inverse [ self . direction ()]","title":"get_direction()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.get_state","text":"Get the current animation state. Returns: Type Description Literal['stopped', 'paused', 'running'] animation state Source code in prettyqt/core/abstractanimation.py def get_state ( self ) -> StateStr : \"\"\"Get the current animation state. Returns: animation state \"\"\" return STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.set_direction","text":"Set animation direction. Parameters: Name Type Description Default direction Literal['forward', 'backward'] animation direction required Exceptions: Type Description InvalidParamError animation direction does not exist Source code in prettyqt/core/abstractanimation.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set animation direction. Args: direction: animation direction Raises: InvalidParamError: animation direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ])","title":"set_direction()"},{"location":"api/core.html#prettyqt.core.abstractanimation.AbstractAnimation.start_animation","text":"Start the animation. Parameters: Name Type Description Default policy Literal['keep', 'delete'] animation policy required Exceptions: Type Description InvalidParamError animation policy does not exist Source code in prettyqt/core/abstractanimation.py def start_animation ( self , policy : DeletionPolicyStr ): \"\"\"Start the animation. Args: policy: animation policy Raises: InvalidParamError: animation policy does not exist \"\"\" if policy not in DELETION_POLICY : raise InvalidParamError ( policy , DELETION_POLICY ) self . start ( DELETION_POLICY [ policy ])","title":"start_animation()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel","text":"","title":"abstractitemmodel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel","text":"","title":"AbstractItemModel"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.__len__","text":"Return amount of rows. Source code in prettyqt/core/abstractitemmodel.py def __len__ ( self ) -> int : \"\"\"Return amount of rows.\"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.change_layout","text":"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def change_layout ( self ): \"\"\"Context manager to change the layout. wraps calls with correct signals emitted at beginning: layoutAboutToBeChanged emitted at end: layoutChanged \"\"\" self . layoutAboutToBeChanged . emit () yield None self . layoutChanged . emit ()","title":"change_layout()"},{"location":"api/core.html#prettyqt.core.abstractitemmodel.AbstractItemModel.reset_model","text":"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel Source code in prettyqt/core/abstractitemmodel.py @contextlib . contextmanager def reset_model ( self ): \"\"\"Context manager to reset the model. wraps calls with correct signals emitted at beginning: beginResetModel emitted at end: endResetModel \"\"\" self . beginResetModel () yield None self . endResetModel ()","title":"reset_model()"},{"location":"api/core.html#prettyqt.core.abstracttransition","text":"","title":"abstracttransition"},{"location":"api/core.html#prettyqt.core.abstracttransition.AbstractTransition","text":"","title":"AbstractTransition"},{"location":"api/core.html#prettyqt.core.abstracttransition.AbstractTransition.get_transition_type","text":"Return current transition type. Returns: Type Description Literal['exclusive', 'parallel'] transition type Source code in prettyqt/core/abstracttransition.py def get_transition_type ( self ) -> TransitionTypeStr : \"\"\"Return current transition type. Returns: transition type \"\"\" return TRANSITION_TYPE . inverse [ self . transitionType ()]","title":"get_transition_type()"},{"location":"api/core.html#prettyqt.core.abstracttransition.AbstractTransition.set_transition_type","text":"Set transition type. Parameters: Name Type Description Default typ Literal['exclusive', 'parallel'] transition type to use required Exceptions: Type Description InvalidParamError transition type does not exist Source code in prettyqt/core/abstracttransition.py def set_transition_type ( self , typ : TransitionTypeStr ): \"\"\"Set transition type. Args: typ: transition type to use Raises: InvalidParamError: transition type does not exist \"\"\" if typ not in TRANSITION_TYPE : raise InvalidParamError ( typ , TRANSITION_TYPE ) self . setTransitionType ( TRANSITION_TYPE [ typ ])","title":"set_transition_type()"},{"location":"api/core.html#prettyqt.core.bytearray","text":"","title":"bytearray"},{"location":"api/core.html#prettyqt.core.bytearray.ByteArray","text":"","title":"ByteArray"},{"location":"api/core.html#prettyqt.core.bytearray.ByteArray.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/bytearray.py def __reduce__ ( self ): return type ( self ), ( bytes ( self ),)","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.collator","text":"","title":"collator"},{"location":"api/core.html#prettyqt.core.collator.Collator","text":"","title":"Collator"},{"location":"api/core.html#prettyqt.core.collator.Collator.is_case_sensitive","text":"Return case sensitivity. Returns: Type Description bool case sensitivity Source code in prettyqt/core/collator.py def is_case_sensitive ( self ) -> bool : \"\"\"Return case sensitivity. Returns: case sensitivity \"\"\" return bool ( self . caseSensitivity ())","title":"is_case_sensitive()"},{"location":"api/core.html#prettyqt.core.collator.Collator.set_case_sensitive","text":"Set case sensitivity. Parameters: Name Type Description Default state bool case sensitive required Source code in prettyqt/core/collator.py def set_case_sensitive ( self , state : bool ): \"\"\"Set case sensitivity. Args: state: case sensitive \"\"\" sensitivity = QtCore . Qt . CaseSensitive if state else QtCore . Qt . CaseInsensitive self . setCaseSensitivity ( sensitivity )","title":"set_case_sensitive()"},{"location":"api/core.html#prettyqt.core.commandlineparser","text":"","title":"commandlineparser"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser","text":"","title":"CommandLineParser"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_options_after_positional_arguments_mode","text":"Set the options after positional arguments mode. Parameters: Name Type Description Default mode Literal['compacted_short', 'long'] options after positional arguments mode required Exceptions: Type Description InvalidParamError options after positional arguments mode does not exist Source code in prettyqt/core/commandlineparser.py def set_options_after_positional_arguments_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the options after positional arguments mode. Args: mode: options after positional arguments mode Raises: InvalidParamError: options after positional arguments mode does not exist \"\"\" if mode not in OPTIONS_AFTER_POS_ARG : raise InvalidParamError ( mode , OPTIONS_AFTER_POS_ARG ) self . setOptionsAfterPositionalArgumentsMode ( OPTIONS_AFTER_POS_ARG [ mode ])","title":"set_options_after_positional_arguments_mode()"},{"location":"api/core.html#prettyqt.core.commandlineparser.CommandLineParser.set_single_dash_word_option_mode","text":"Set the single dash word option mode. Parameters: Name Type Description Default mode Literal['compacted_short', 'long'] single dash word option mode required Exceptions: Type Description InvalidParamError single dash word option mode does not exist Source code in prettyqt/core/commandlineparser.py def set_single_dash_word_option_mode ( self , mode : SingleDashWordStr ): \"\"\"Set the single dash word option mode. Args: mode: single dash word option mode Raises: InvalidParamError: single dash word option mode does not exist \"\"\" if mode not in SINGLE_DASH_WORD : raise InvalidParamError ( mode , SINGLE_DASH_WORD ) self . setSingleDashWordOptionMode ( SINGLE_DASH_WORD [ mode ])","title":"set_single_dash_word_option_mode()"},{"location":"api/core.html#prettyqt.core.datastream","text":"","title":"datastream"},{"location":"api/core.html#prettyqt.core.datastream.DataStream","text":"","title":"DataStream"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_byte_order","text":"Return byte order. Returns: Type Description Literal['big_endian', 'little_endian'] byte order Source code in prettyqt/core/datastream.py def get_byte_order ( self ) -> ByteOrderStr : \"\"\"Return byte order. Returns: byte order \"\"\" return BYTE_ORDER . inverse [ self . byteOrder ()]","title":"get_byte_order()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.get_float_precision","text":"Return floating point precision. Returns: Type Description Literal['single', 'double'] floating point precision Source code in prettyqt/core/datastream.py def get_float_precision ( self ) -> FloatPrecisionStr : \"\"\"Return floating point precision. Returns: floating point precision \"\"\" return FLOAT_PRECISION . inverse [ self . floatingPointPrecision ()]","title":"get_float_precision()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_byte_order","text":"Set byte order. Parameters: Name Type Description Default order Literal['big_endian', 'little_endian'] byte order to use required Exceptions: Type Description InvalidParamError invalid order Source code in prettyqt/core/datastream.py def set_byte_order ( self , order : ByteOrderStr ): \"\"\"Set byte order. Args: order: byte order to use Raises: InvalidParamError: invalid order \"\"\" if order not in BYTE_ORDER : raise InvalidParamError ( order , BYTE_ORDER ) self . setByteOrder ( BYTE_ORDER [ order ])","title":"set_byte_order()"},{"location":"api/core.html#prettyqt.core.datastream.DataStream.set_float_precision","text":"Set floating point precision. Parameters: Name Type Description Default precision Literal['single', 'double'] floating point precision required Exceptions: Type Description InvalidParamError invalid precision Source code in prettyqt/core/datastream.py def set_float_precision ( self , precision : FloatPrecisionStr ): \"\"\"Set floating point precision. Args: precision: floating point precision Raises: InvalidParamError: invalid precision \"\"\" if precision not in FLOAT_PRECISION : raise InvalidParamError ( precision , FLOAT_PRECISION ) self . setFloatingPointPrecision ( FLOAT_PRECISION [ precision ])","title":"set_float_precision()"},{"location":"api/core.html#prettyqt.core.date","text":"","title":"date"},{"location":"api/core.html#prettyqt.core.date.Date","text":"","title":"Date"},{"location":"api/core.html#prettyqt.core.date.Date.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/date.py def __reduce__ ( self ): return type ( self ), ( self . year (), self . month (), self . day ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.datetime","text":"","title":"datetime"},{"location":"api/core.html#prettyqt.core.datetime.DateTime","text":"","title":"DateTime"},{"location":"api/core.html#prettyqt.core.datetime.DateTime.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/datetime.py def __reduce__ ( self ): return type ( self ), ( self . date (), self . time (), self . get_timezone ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.datetime.DateTime.get_time_spec","text":"Return current time specification. Returns: Type Description Literal['local_time', 'utc', 'offset_from_utc', 'timezone'] time specification Source code in prettyqt/core/datetime.py def get_time_spec ( self ) -> constants . TimeSpecStr : \"\"\"Return current time specification. Returns: time specification \"\"\" return constants . TIME_SPEC . inverse [ self . timeSpec ()]","title":"get_time_spec()"},{"location":"api/core.html#prettyqt.core.datetime.DateTime.set_time_spec","text":"Set the time specification. Parameters: Name Type Description Default spec Literal['local_time', 'utc', 'offset_from_utc', 'timezone'] time specification to use required Exceptions: Type Description InvalidParamError time specification does not exist Source code in prettyqt/core/datetime.py def set_time_spec ( self , spec : constants . TimeSpecStr ): \"\"\"Set the time specification. Args: spec: time specification to use Raises: InvalidParamError: time specification does not exist \"\"\" if spec not in constants . TIME_SPEC : raise InvalidParamError ( spec , constants . TIME_SPEC ) self . setTimeSpec ( constants . TIME_SPEC [ spec ])","title":"set_time_spec()"},{"location":"api/core.html#prettyqt.core.deadlinetimer","text":"","title":"deadlinetimer"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer","text":"","title":"DeadlineTimer"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.get_type","text":"Return current timer type. Returns: Type Description Literal['precise', 'coarse', 'very_coarse'] timer type Source code in prettyqt/core/deadlinetimer.py def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.deadlinetimer.DeadlineTimer.set_type","text":"Set the timer type. Parameters: Name Type Description Default typ Literal['precise', 'coarse', 'very_coarse'] timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/deadlinetimer.py def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ])","title":"set_type()"},{"location":"api/core.html#prettyqt.core.easingcurve","text":"","title":"easingcurve"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve","text":"","title":"EasingCurve"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.get_type","text":"Get the current easing curve type. Returns: Type Description Literal['linear', 'in_quad', 'out_quad', 'in_out_quad', 'out_in_quad', 'in_cubic', 'out_cubic', 'in_out_cubic', 'out_in_cubic', 'in_quart', 'out_quart', 'in_out_quart', 'out_in_quart', 'in_quint', 'out_quint', 'in_out_quint', 'out_in_quint', 'in_sine', 'out_sine', 'in_out_sine', 'out_in_sine', 'in_expo', 'out_expo', 'in_out_expo', 'out_in_expo', 'in_circ', 'out_circ', 'in_out_circ', 'out_in_circ', 'in_elastic', 'out_elastic', 'in_out_elastic', 'out_in_elastic', 'in_back', 'out_back', 'in_out_back', 'out_in_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'out_in_bounce', 'bezier_spline', 'tcb_spline', 'custom'] easing curve type Source code in prettyqt/core/easingcurve.py def get_type ( self ) -> TypeStr : \"\"\"Get the current easing curve type. Returns: easing curve type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.easingcurve.EasingCurve.set_type","text":"Set easing curve type. Parameters: Name Type Description Default typ Literal['linear', 'in_quad', 'out_quad', 'in_out_quad', 'out_in_quad', 'in_cubic', 'out_cubic', 'in_out_cubic', 'out_in_cubic', 'in_quart', 'out_quart', 'in_out_quart', 'out_in_quart', 'in_quint', 'out_quint', 'in_out_quint', 'out_in_quint', 'in_sine', 'out_sine', 'in_out_sine', 'out_in_sine', 'in_expo', 'out_expo', 'in_out_expo', 'out_in_expo', 'in_circ', 'out_circ', 'in_out_circ', 'out_in_circ', 'in_elastic', 'out_elastic', 'in_out_elastic', 'out_in_elastic', 'in_back', 'out_back', 'in_out_back', 'out_in_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'out_in_bounce', 'bezier_spline', 'tcb_spline', 'custom'] easing curve type required Exceptions: Type Description InvalidParamError easing curve type does not exist Source code in prettyqt/core/easingcurve.py def set_type ( self , typ : TypeStr ): \"\"\"Set easing curve type. Args: typ: easing curve type Raises: InvalidParamError: easing curve type does not exist \"\"\" if typ not in TYPE : raise InvalidParamError ( typ , TYPE ) self . setType ( TYPE [ typ ])","title":"set_type()"},{"location":"api/core.html#prettyqt.core.elapsedtimer","text":"","title":"elapsedtimer"},{"location":"api/core.html#prettyqt.core.elapsedtimer.ElapsedTimer","text":"","title":"ElapsedTimer"},{"location":"api/core.html#prettyqt.core.elapsedtimer.ElapsedTimer.get_clock_type","text":"Return current clock type. Returns: Type Description Literal['system_time', 'monotonic_clock', 'tick_counter', 'mach_absolute_time', 'performance_counter'] clock type Source code in prettyqt/core/elapsedtimer.py def get_clock_type ( self ) -> ClockTypeStr : \"\"\"Return current clock type. Returns: clock type \"\"\" return CLOCK_TYPE . inverse [ self . clockType ()]","title":"get_clock_type()"},{"location":"api/core.html#prettyqt.core.filedevice","text":"","title":"filedevice"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice","text":"","title":"FileDevice"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice.get_error","text":"Return file error status. Returns: Type Description Literal['none', 'read', 'write', 'fatal', 'resource', 'open', 'abort', 'time_out', 'unspecified', 'remove', 'rename', 'position', 'resize', 'permissions', 'copy'] file error status Source code in prettyqt/core/filedevice.py def get_error ( self ) -> FileErrorStr : \"\"\"Return file error status. Returns: file error status \"\"\" return FILE_ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice.get_file_time","text":"Return current file time. Returns: Type Description Optional[datetime.datetime] file time Source code in prettyqt/core/filedevice.py def get_file_time ( self , typ : FileTimeStr ) -> Optional [ datetime . datetime ]: \"\"\"Return current file time. Returns: file time \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) date = self . fileTime ( FILE_TIME [ typ ]) if not date : return None return to_datetime ( date )","title":"get_file_time()"},{"location":"api/core.html#prettyqt.core.filedevice.FileDevice.set_file_time","text":"Set file time. Parameters: Name Type Description Default typ Literal['access', 'birth', 'metadata_change', 'modification'] file time to use required Exceptions: Type Description InvalidParamError file time does not exist Source code in prettyqt/core/filedevice.py def set_file_time ( self , file_time : Union [ QtCore . QDateTime , datetime . datetime ], typ : FileTimeStr ) -> bool : \"\"\"Set file time. Args: typ: file time to use Raises: InvalidParamError: file time does not exist \"\"\" if typ not in FILE_TIME : raise InvalidParamError ( typ , FILE_TIME ) return self . setFileTime ( file_time , FILE_TIME [ typ ]) # type: ignore","title":"set_file_time()"},{"location":"api/core.html#prettyqt.core.historystate","text":"","title":"historystate"},{"location":"api/core.html#prettyqt.core.historystate.HistoryState","text":"","title":"HistoryState"},{"location":"api/core.html#prettyqt.core.historystate.HistoryState.get_history_type","text":"Return current history type. Returns: Type Description Literal['shallow', 'deep'] history type Source code in prettyqt/core/historystate.py def get_history_type ( self ) -> HistoryTypeStr : \"\"\"Return current history type. Returns: history type \"\"\" return HISTORY_TYPE . inverse [ self . historyType ()]","title":"get_history_type()"},{"location":"api/core.html#prettyqt.core.historystate.HistoryState.set_history_type","text":"Set history type to use. Parameters: Name Type Description Default typ Literal['shallow', 'deep'] history type to use required Exceptions: Type Description InvalidParamError history type does not exist Source code in prettyqt/core/historystate.py def set_history_type ( self , typ : HistoryTypeStr ): \"\"\"Set history type to use. Args: typ: history type to use Raises: InvalidParamError: history type does not exist \"\"\" if typ not in HISTORY_TYPE : raise InvalidParamError ( typ , HISTORY_TYPE ) self . setHistoryType ( HISTORY_TYPE [ typ ])","title":"set_history_type()"},{"location":"api/core.html#prettyqt.core.line","text":"","title":"line"},{"location":"api/core.html#prettyqt.core.line.Line","text":"","title":"Line"},{"location":"api/core.html#prettyqt.core.line.Line.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/line.py def __reduce__ ( self ): return type ( self ), ( self . get_p1 (), self . get_p1 ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.linef","text":"","title":"linef"},{"location":"api/core.html#prettyqt.core.linef.LineF","text":"","title":"LineF"},{"location":"api/core.html#prettyqt.core.linef.LineF.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/linef.py def __reduce__ ( self ): return type ( self ), ( self . get_p1 (), self . get_p1 ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.operatingsystemversion","text":"","title":"operatingsystemversion"},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion","text":"","title":"OperatingSystemVersion"},{"location":"api/core.html#prettyqt.core.operatingsystemversion.OperatingSystemVersion.get_type","text":"Get current os type. Returns: Type Description Literal['android', 'ios', 'mac_os', 'tv_os', 'watch_os', 'windows', 'unknown'] current os type Source code in prettyqt/core/operatingsystemversion.py def get_type ( self ) -> OsTypeStr : \"\"\"Get current os type. Returns: current os type \"\"\" return OS_TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.point","text":"","title":"point"},{"location":"api/core.html#prettyqt.core.point.Point","text":"","title":"Point"},{"location":"api/core.html#prettyqt.core.point.Point.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/point.py def __reduce__ ( self ): return type ( self ), ( self . x (), self . y ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.pointf","text":"","title":"pointf"},{"location":"api/core.html#prettyqt.core.pointf.PointF","text":"","title":"PointF"},{"location":"api/core.html#prettyqt.core.pointf.PointF.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/pointf.py def __reduce__ ( self ): return type ( self ), ( self . x (), self . y ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.process","text":"","title":"process"},{"location":"api/core.html#prettyqt.core.process.Process","text":"","title":"Process"},{"location":"api/core.html#prettyqt.core.process.Process.set_input_channel_mode","text":"Set the input channel mode. Parameters: Name Type Description Default mode Literal['managed', 'forwarded'] mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_input_channel_mode ( self , mode : InputChannelModeStr ): \"\"\"Set the input channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in INPUT_CHANNEL_MODES : raise InvalidParamError ( mode , INPUT_CHANNEL_MODES ) self . setInputChannelMode ( INPUT_CHANNEL_MODES [ mode ])","title":"set_input_channel_mode()"},{"location":"api/core.html#prettyqt.core.process.Process.set_process_channel_mode","text":"Set the process channel mode. Parameters: Name Type Description Default mode Literal['separate', 'merged', 'forwarded', 'forwarded_error', 'forwarded_output'] mode to set required Exceptions: Type Description InvalidParamError invalid mode Source code in prettyqt/core/process.py def set_process_channel_mode ( self , mode : ProcessChannelModeStr ): \"\"\"Set the process channel mode. Args: mode: mode to set Raises: InvalidParamError: invalid mode \"\"\" if mode not in PROCESS_CHANNEL_MODES : raise InvalidParamError ( mode , PROCESS_CHANNEL_MODES ) self . setProcessChannelMode ( PROCESS_CHANNEL_MODES [ mode ])","title":"set_process_channel_mode()"},{"location":"api/core.html#prettyqt.core.process.Process.set_read_channel","text":"Set the input channel channel. Parameters: Name Type Description Default channel Literal['standard', 'error'] channel to set required Exceptions: Type Description InvalidParamError invalid channel Source code in prettyqt/core/process.py def set_read_channel ( self , channel : ProcessChannelStr ): \"\"\"Set the input channel channel. Args: channel: channel to set Raises: InvalidParamError: invalid channel \"\"\" if channel not in PROCESS_CHANNELS : raise InvalidParamError ( channel , PROCESS_CHANNELS ) self . setReadChannel ( PROCESS_CHANNELS [ channel ])","title":"set_read_channel()"},{"location":"api/core.html#prettyqt.core.process.Process.set_state","text":"Set the process state. Parameters: Name Type Description Default state Literal['not_running', 'starting', 'running'] state to set required Exceptions: Type Description InvalidParamError invalid state Source code in prettyqt/core/process.py def set_state ( self , state : ProcessStateStr ): \"\"\"Set the process state. Args: state: state to set Raises: InvalidParamError: invalid state \"\"\" if state not in PROCESS_STATES : raise InvalidParamError ( state , PROCESS_STATES ) self . setProcessState ( PROCESS_STATES [ state ])","title":"set_state()"},{"location":"api/core.html#prettyqt.core.rect","text":"","title":"rect"},{"location":"api/core.html#prettyqt.core.rect.Rect","text":"","title":"Rect"},{"location":"api/core.html#prettyqt.core.rect.Rect.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/rect.py def __reduce__ ( self ): return type ( self ), ( self . x (), self . y (), self . width (), self . height ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.rectf","text":"","title":"rectf"},{"location":"api/core.html#prettyqt.core.rectf.RectF","text":"","title":"RectF"},{"location":"api/core.html#prettyqt.core.rectf.RectF.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/rectf.py def __reduce__ ( self ): return type ( self ), ( self . x (), self . y (), self . width (), self . height ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.regularexpression","text":"","title":"regularexpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression","text":"","title":"RegularExpression"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.globalMatch","text":"globalMatch(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatchIterator Source code in prettyqt/core/regularexpression.py def globalMatch ( self , * args , ** kwargs ) -> core . RegularExpressionMatchIterator : it = super () . globalMatch ( * args , ** kwargs ) return core . RegularExpressionMatchIterator ( it )","title":"globalMatch()"},{"location":"api/core.html#prettyqt.core.regularexpression.RegularExpression.match","text":"match(self, str, offset: int = 0, matchType: QRegularExpression.MatchType = QRegularExpression.NormalMatch, matchOptions: Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption] = QRegularExpression.NoMatchOption) -> QRegularExpressionMatch Source code in prettyqt/core/regularexpression.py def match ( # type: ignore self , text : str , offset : int = 0 , match_type : Union [ MatchTypeStr , QtCore . QRegularExpression . MatchType ] = \"normal\" , anchored : bool = False , ) -> core . RegularExpressionMatch : if isinstance ( match_type , str ): typ = MATCH_TYPE [ match_type ] else : typ = match_type if isinstance ( anchored , bool ): options = MATCH_OPTIONS [ \"anchored\" ] if anchored else MATCH_OPTIONS [ \"none\" ] else : options = anchored match = super () . match ( text , offset , typ , options ) return core . RegularExpressionMatch ( match )","title":"match()"},{"location":"api/core.html#prettyqt.core.settings","text":"","title":"settings"},{"location":"api/core.html#prettyqt.core.settings.Settings","text":"","title":"Settings"},{"location":"api/core.html#prettyqt.core.settings.Settings.edit_group","text":"Context manager for setting groups. Parameters: Name Type Description Default prefix str setting prefix for group required Source code in prettyqt/core/settings.py @contextlib . contextmanager def edit_group ( self , prefix : str ): \"\"\"Context manager for setting groups. Args: prefix: setting prefix for group \"\"\" self . beginGroup ( prefix ) yield None self . endGroup ()","title":"edit_group()"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_default_format","text":"Return default settings format. Returns: Type Description Literal['user', 'system'] default settings format Source code in prettyqt/core/settings.py @classmethod def get_default_format ( cls ) -> FormatStr : \"\"\"Return default settings format. Returns: default settings format \"\"\" return FORMAT . inverse [ cls . defaultFormat ()]","title":"get_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.get_scope","text":"Return scope. Returns: Type Description Literal['user', 'system'] scope Source code in prettyqt/core/settings.py def get_scope ( self ) -> ScopeStr : \"\"\"Return scope. Returns: scope \"\"\" return SCOPE . inverse [ self . scope ()]","title":"get_scope()"},{"location":"api/core.html#prettyqt.core.settings.Settings.read_array","text":"Context manager for reading arrays. Parameters: Name Type Description Default prefix str prefix for settings array required Source code in prettyqt/core/settings.py @contextlib . contextmanager def read_array ( self , prefix : str ): \"\"\"Context manager for reading arrays. Args: prefix: prefix for settings array \"\"\" self . beginReadArray ( prefix ) yield None self . endArray ()","title":"read_array()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_default_format","text":"Set the default format. Parameters: Name Type Description Default fmt Literal['user', 'system'] the default format to use required Exceptions: Type Description InvalidParamError invalid format Source code in prettyqt/core/settings.py @classmethod def set_default_format ( cls , fmt : FormatStr ): \"\"\"Set the default format. Args: fmt: the default format to use Raises: InvalidParamError: invalid format \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) cls . setDefaultFormat ( FORMAT [ fmt ])","title":"set_default_format()"},{"location":"api/core.html#prettyqt.core.settings.Settings.set_path","text":"Set the path to the settings file. Parameters: Name Type Description Default fmt Literal['user', 'system'] the default format to use required scope Literal['user', 'system'] the scope to use required Exceptions: Type Description InvalidParamError invalid format or scope Source code in prettyqt/core/settings.py @classmethod def set_path ( cls , fmt : FormatStr , scope : ScopeStr , path : Union [ str , pathlib . Path ]): \"\"\"Set the path to the settings file. Args: fmt: the default format to use scope: the scope to use Raises: InvalidParamError: invalid format or scope \"\"\" if fmt not in FORMAT : raise InvalidParamError ( fmt , FORMAT ) if scope not in SCOPE : raise InvalidParamError ( scope , SCOPE ) cls . setPath ( FORMAT [ fmt ], SCOPE [ scope ], str ( path ))","title":"set_path()"},{"location":"api/core.html#prettyqt.core.settings.Settings.write_array","text":"Context manager for writing arrays. Parameters: Name Type Description Default prefix str prefix for settings array required size int size of settings array -1 Source code in prettyqt/core/settings.py @contextlib . contextmanager def write_array ( self , prefix : str , size : int = - 1 ): \"\"\"Context manager for writing arrays. Args: prefix: prefix for settings array size: size of settings array \"\"\" self . beginWriteArray ( prefix , size ) yield None self . endArray ()","title":"write_array()"},{"location":"api/core.html#prettyqt.core.size","text":"","title":"size"},{"location":"api/core.html#prettyqt.core.size.Size","text":"","title":"Size"},{"location":"api/core.html#prettyqt.core.size.Size.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/size.py def __reduce__ ( self ): return type ( self ), ( self . width (), self . height ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.sizef","text":"","title":"sizef"},{"location":"api/core.html#prettyqt.core.sizef.SizeF","text":"","title":"SizeF"},{"location":"api/core.html#prettyqt.core.sizef.SizeF.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/sizef.py def __reduce__ ( self ): return type ( self ), ( self . width (), self . height ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.socketnotifier","text":"","title":"socketnotifier"},{"location":"api/core.html#prettyqt.core.socketnotifier.SocketNotifier","text":"","title":"SocketNotifier"},{"location":"api/core.html#prettyqt.core.socketnotifier.SocketNotifier.get_type","text":"Return socket event type. Returns: Type Description Literal['read', 'write', 'exception'] socket event type Source code in prettyqt/core/socketnotifier.py def get_type ( self ) -> TypeStr : \"\"\"Return socket event type. Returns: socket event type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.state","text":"","title":"state"},{"location":"api/core.html#prettyqt.core.state.State","text":"","title":"State"},{"location":"api/core.html#prettyqt.core.state.State.get_child_mode","text":"Return current child mode. Returns: Type Description Literal['exclusive', 'parallel'] child mode Source code in prettyqt/core/state.py def get_child_mode ( self ) -> ChildModeStr : \"\"\"Return current child mode. Returns: child mode \"\"\" return CHILD_MODE . inverse [ self . childMode ()]","title":"get_child_mode()"},{"location":"api/core.html#prettyqt.core.state.State.set_child_mode","text":"Set child mode to use. Parameters: Name Type Description Default mode Literal['exclusive', 'parallel'] child mode to use required Exceptions: Type Description InvalidParamError child mode does not exist Source code in prettyqt/core/state.py def set_child_mode ( self , mode : ChildModeStr ): \"\"\"Set child mode to use. Args: mode: child mode to use Raises: InvalidParamError: child mode does not exist \"\"\" if mode not in CHILD_MODE : raise InvalidParamError ( mode , CHILD_MODE ) self . setChildMode ( CHILD_MODE [ mode ])","title":"set_child_mode()"},{"location":"api/core.html#prettyqt.core.statemachine","text":"","title":"statemachine"},{"location":"api/core.html#prettyqt.core.statemachine.StateMachine","text":"","title":"StateMachine"},{"location":"api/core.html#prettyqt.core.statemachine.StateMachine.get_global_restore_policy","text":"Return current restore policy. Returns: Type Description core.state.RestorePolicyStr restore policy Source code in prettyqt/core/statemachine.py def get_global_restore_policy ( self ) -> core . state . RestorePolicyStr : \"\"\"Return current restore policy. Returns: restore policy \"\"\" return core . state . RESTORE_POLICY . inverse [ self . globalRestorePolicy ()]","title":"get_global_restore_policy()"},{"location":"api/core.html#prettyqt.core.statemachine.StateMachine.set_global_restore_policy","text":"Set restore policy to use. Parameters: Name Type Description Default policy core.state.RestorePolicyStr restore policy to use required Exceptions: Type Description InvalidParamError restore policy does not exist Source code in prettyqt/core/statemachine.py def set_global_restore_policy ( self , policy : core . state . RestorePolicyStr ): \"\"\"Set restore policy to use. Args: policy: restore policy to use Raises: InvalidParamError: restore policy does not exist \"\"\" if policy not in core . state . RESTORE_POLICY : raise InvalidParamError ( policy , core . state . RESTORE_POLICY ) self . setGlobalRestorePolicy ( core . state . RESTORE_POLICY [ policy ])","title":"set_global_restore_policy()"},{"location":"api/core.html#prettyqt.core.textstream","text":"","title":"textstream"},{"location":"api/core.html#prettyqt.core.textstream.TextStream","text":"","title":"TextStream"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_field_alignment","text":"Get current field alignment. Returns: Type Description Literal['left', 'right', 'center', 'accounting_style'] current field alignment Source code in prettyqt/core/textstream.py def get_field_alignment ( self ) -> FieldAlignmentStr : \"\"\"Get current field alignment. Returns: current field alignment \"\"\" return FIELD_ALIGNMENT . inverse [ self . fieldAlignment ()]","title":"get_field_alignment()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_real_number_notation","text":"Get current real number notation. Returns: Type Description Literal['scientific', 'fixed', 'smart'] current real number notation Source code in prettyqt/core/textstream.py def get_real_number_notation ( self ) -> RealNumberNotationStr : \"\"\"Get current real number notation. Returns: current real number notation \"\"\" return REAL_NUMBER_NOTATION . inverse [ self . realNumberNotation ()]","title":"get_real_number_notation()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.get_status","text":"Get current status. Returns: Type Description Literal['ok', 'read_past_end', 'read_corrupt_data', 'write_failed'] current status Source code in prettyqt/core/textstream.py def get_status ( self ) -> StatusStr : \"\"\"Get current status. Returns: current status \"\"\" return STATUS . inverse [ self . status ()]","title":"get_status()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_field_alignment","text":"Set the field alignment. Parameters: Name Type Description Default alignment Literal['left', 'right', 'center', 'accounting_style'] field alignment required Exceptions: Type Description InvalidParamError invalid field alignment Source code in prettyqt/core/textstream.py def set_field_alignment ( self , alignment : FieldAlignmentStr ): \"\"\"Set the field alignment. Args: alignment: field alignment Raises: InvalidParamError: invalid field alignment \"\"\" if alignment not in FIELD_ALIGNMENT : raise InvalidParamError ( alignment , FIELD_ALIGNMENT ) self . setFieldAlignment ( FIELD_ALIGNMENT [ alignment ])","title":"set_field_alignment()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_real_number_notation","text":"Set the real number notation. Parameters: Name Type Description Default notation Literal['scientific', 'fixed', 'smart'] real number notation required Exceptions: Type Description InvalidParamError invalid real number notation Source code in prettyqt/core/textstream.py def set_real_number_notation ( self , notation : RealNumberNotationStr ): \"\"\"Set the real number notation. Args: notation: real number notation Raises: InvalidParamError: invalid real number notation \"\"\" if notation not in REAL_NUMBER_NOTATION : raise InvalidParamError ( notation , REAL_NUMBER_NOTATION ) self . setRealNumberNotation ( REAL_NUMBER_NOTATION [ notation ])","title":"set_real_number_notation()"},{"location":"api/core.html#prettyqt.core.textstream.TextStream.set_status","text":"Set the status. Parameters: Name Type Description Default status Literal['ok', 'read_past_end', 'read_corrupt_data', 'write_failed'] status required Exceptions: Type Description InvalidParamError invalid status Source code in prettyqt/core/textstream.py def set_status ( self , status : StatusStr ): \"\"\"Set the status. Args: status: status Raises: InvalidParamError: invalid status \"\"\" if status not in STATUS : raise InvalidParamError ( status , STATUS ) self . setStatus ( STATUS [ status ])","title":"set_status()"},{"location":"api/core.html#prettyqt.core.time","text":"","title":"time"},{"location":"api/core.html#prettyqt.core.time.Time","text":"","title":"Time"},{"location":"api/core.html#prettyqt.core.time.Time.__reduce__","text":"Helper for pickle. Source code in prettyqt/core/time.py def __reduce__ ( self ): return type ( self ), ( self . hour (), self . minute (), self . second (), self . msec ())","title":"__reduce__()"},{"location":"api/core.html#prettyqt.core.timeline","text":"","title":"timeline"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine","text":"","title":"TimeLine"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_direction","text":"Return current direction. Returns: Type Description Literal['forward', 'backward'] direction Source code in prettyqt/core/timeline.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()]","title":"get_direction()"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.get_state","text":"Return current state. Returns: Type Description Literal['not_running', 'paused', 'running'] state Source code in prettyqt/core/timeline.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/core.html#prettyqt.core.timeline.TimeLine.set_direction","text":"Set the direction. Parameters: Name Type Description Default direction Literal['forward', 'backward'] direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/core/timeline.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ])","title":"set_direction()"},{"location":"api/core.html#prettyqt.core.timer","text":"","title":"timer"},{"location":"api/core.html#prettyqt.core.timer.Timer","text":"","title":"Timer"},{"location":"api/core.html#prettyqt.core.timer.Timer.get_type","text":"Return current timer type. Returns: Type Description constants.TimerTypeStr timer type Source code in prettyqt/core/timer.py def get_type ( self ) -> constants . TimerTypeStr : \"\"\"Return current timer type. Returns: timer type \"\"\" return constants . TIMER_TYPE . inverse [ self . timerType ()]","title":"get_type()"},{"location":"api/core.html#prettyqt.core.timer.Timer.set_type","text":"Set the timer type. Parameters: Name Type Description Default typ constants.TimerTypeStr timer type required Exceptions: Type Description InvalidParamError timer type does not exist Source code in prettyqt/core/timer.py def set_type ( self , typ : constants . TimerTypeStr ): \"\"\"Set the timer type. Args: typ: timer type Raises: InvalidParamError: timer type does not exist \"\"\" if typ not in constants . TIMER_TYPE : raise InvalidParamError ( typ , constants . TIMER_TYPE ) self . setTimerType ( constants . TIMER_TYPE [ typ ])","title":"set_type()"},{"location":"api/core.html#prettyqt.core.url","text":"","title":"url"},{"location":"api/core.html#prettyqt.core.url.Url","text":"","title":"Url"},{"location":"api/core.html#prettyqt.core.url.Url.to_path","text":"Get pathlib object from the URL. Returns: Type Description pathlib.Path Path Source code in prettyqt/core/url.py def to_path ( self ) -> pathlib . Path : \"\"\"Get pathlib object from the URL. Returns: Path \"\"\" return pathlib . Path ( str ( self ))","title":"to_path()"},{"location":"api/core.html#prettyqt.core.versionnumber","text":"","title":"versionnumber"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber","text":"","title":"VersionNumber"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.major","text":"An integer representing the major version. Source code in prettyqt/core/versionnumber.py def major ( self ) -> int : \"\"\"An integer representing the major version.\"\"\" return self . majorVersion ()","title":"major()"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.micro","text":"An integer representing the micro version. Source code in prettyqt/core/versionnumber.py def micro ( self ) -> int : \"\"\"An integer representing the micro version.\"\"\" return self . microVersion ()","title":"micro()"},{"location":"api/core.html#prettyqt.core.versionnumber.VersionNumber.minor","text":"An integer representing the minor version. Source code in prettyqt/core/versionnumber.py def minor ( self ) -> int : \"\"\"An integer representing the minor version.\"\"\" return self . minorVersion ()","title":"minor()"},{"location":"api/custom_delegates.html","text":"custom_delegates module Module containing custom delegate classes. buttondelegate ButtonDelegate createEditor ( self , parent , option , index ) createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/buttondelegate.py def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn setEditorData ( self , editor , index ) setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setEditorData ( self , editor , index ): pass setModelData ( self , editor , model , index ) setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setModelData ( self , editor , model , index ): pass checkboxdelegate CheckBoxDelegate Delegate that places a CheckBox in every cell. createEditor ( self , parent , option , index ) Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. Source code in prettyqt/custom_delegates/checkboxdelegate.py def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb setEditorData ( self , cb , index ) Override. set correct initial value for editor widget Source code in prettyqt/custom_delegates/checkboxdelegate.py def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection ) setModelData ( self , combo , model , index ) Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. Source code in prettyqt/custom_delegates/checkboxdelegate.py def setModelData ( self , combo , model , index ): \"\"\"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. \"\"\" dtype = self . dtypes [ combo . currentText ()] # s = model.data(index, model.DATA_ROLE) try : model . setData ( index , dtype , model . DTYPE_ROLE ) except ValueError as e : logger . error ( e ) icondelegate IconDelegate paint ( self , painter , option , index ) Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Parameters: Name Type Description Default painter QPainter painter to paint the icon required option QStyleOptionViewItem state of the item to be displayed required index QModelIndex index which gets decorated required Source code in prettyqt/custom_delegates/icondelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if not value : return margin = 10 mode = gui . Icon . Normal if not ( option . state & widgets . Style . State_Enabled ): mode = gui . Icon . Disabled elif option . state & widgets . Style . State_Selected : mode = gui . Icon . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QIcon ): is_on = option . state & widgets . Style . State_Open state = gui . Icon . On if is_on else gui . Icon . Off actual_size = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = option . decorationSize & actual_size r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off alignment = constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER icon . paint ( painter , r , alignment , mode , state ) nofocusdelegate NoFocusDelegate paint ( self , painter , option , index ) paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/nofocusdelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . State_HasFocus : option . state = option . state ^ widgets . Style . State_HasFocus super () . paint ( painter , option , index ) progressbardelegate ProgressBarDelegate paint ( self , painter , option , index ) paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/progressbardelegate.py def paint ( self , painter , option , index ): progress = index . data () progressBar_option = widgets . StyleOptionProgressBar () progressBar_option . rect = option . rect progressBar_option . minimum = 0 progressBar_option . maximum = 100 progressBar_option . progress = progress progressBar_option . text = f \" { progress } %\" progressBar_option . textVisible = True widgets . Application . style () . drawControl ( widgets . Style . CE_ProgressBar , progressBar_option , painter ) radiodelegate RadioDelegate createEditor ( self , parent , option , index ) createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/radiodelegate.py def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ) -> widgets . Widget : editor = widgets . Widget ( parent ) editor . set_margin ( 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . button_group = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . set_margin ( 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . set_focus_policy ( \"none\" ) rb . installEventFilter ( self ) editor . button_group . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) # type: ignore editor . installEventFilter ( self ) return editor eventFilter ( self , source , event ) eventFilter(self, QObject, QEvent) -> bool Source code in prettyqt/custom_delegates/radiodelegate.py def eventFilter ( self , source : QtWidgets . QWidget , event : QtCore . QEvent ) -> bool : if event . type () == core . Event . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( b \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event ) setEditorData ( self , editor , index ) setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setEditorData ( self , editor : QtWidgets . QWidget , index : QtCore . QModelIndex ): value = index . data ( QtCore . Qt . DisplayRole ) if value in self . items : editor . button_group . button ( self . items . index ( value )) . setChecked ( True ) setModelData ( self , editor , model , index ) setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setModelData ( self , editor : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , index : QtCore . QModelIndex , ): button = editor . button_group . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], QtCore . Qt . DisplayRole ) self . choices [ button ] = index . row () updateEditorGeometry ( self , editor , option , index ) updateEditorGeometry(self, QWidget, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def updateEditorGeometry ( self , editor : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): rect = core . Rect ( option . rect ) min_width = editor . minimumSizeHint () . width () if rect . width () < min_width : rect . setWidth ( min_width ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) # type: ignore editor . setMask ( mask ) renderlinkdelegate RenderLinkDelegate editorEvent ( self , event , model , option , index ) editorEvent(self, QEvent, QAbstractItemModel, QStyleOptionViewItem, QModelIndex) -> bool Source code in prettyqt/custom_delegates/renderlinkdelegate.py def editorEvent ( self , event , model , option , index ): text = index . data () font = index . data ( constants . FONT_ROLE ) # alignment = index.data(constants.ALIGNMENT_ROLE) if font is None : font = widgets . Application . get_font () fm = gui . FontMetricsF ( font ) rect = fm . get_bounding_rect ( core . RectF ( option . rect ), QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter , text , ) if ( event . type () == QtCore . QEvent . MouseButtonPress and event . button () == QtCore . Qt . LeftButton and event . localPos () in rect ): text = index . data () gui . DesktopServices . open_url ( text ) return True return False paint ( self , painter , option , index ) paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/renderlinkdelegate.py def paint ( self , painter , option , index ): text = index . data () if not text : return painter . save () # I only wanted it for mouse over, but you'll probably want to remove # this condition if option . state and widgets . Style . State_MouseOver : font = option . font font . setUnderline ( True ) painter . setFont ( font ) painter . setPen ( option . palette . link () . color ()) painter . drawText ( option . rect , QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter , text ) painter . restore () stardelegate StarDelegate A delegate class that allows us to render our star ratings. createEditor ( self , parent , option , index ) Create and return the StarEditor object we'll use to edit the StarRating. Source code in prettyqt/custom_delegates/stardelegate.py def createEditor ( self , parent , option , index ): \"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\" editor = StarEditor ( parent ) editor . editing_finished . connect ( self . commitAndCloseEditor ) return editor paint ( self , painter , option , index ) paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter , option , index ): star_rating = StarRating ( index . data ()) # If the row is currently selected, we need to make sure we # paint the background accordingly. if option . state & widgets . Style . State_Selected : # The original C++ example used option.palette.foreground() to # get the brush for painting, but there are a couple of # problems with that: # - foreground() is obsolete now, use windowText() instead # - more importantly, windowText() just returns a brush # containing a flat color, where sometimes the style # would have a nice subtle gradient or something. # Here we just use the brush of the painter object that's # passed in to us, which keeps the row highlighting nice # and consistent. painter . fillRect ( option . rect , painter . brush ()) # Now that we've painted the background, call star_rating.paint() # to paint the stars. star_rating . paint ( painter , option . rect , option . palette ) setEditorData ( self , editor , index ) Set the data to be displayed and edited by our custom editor. Source code in prettyqt/custom_delegates/stardelegate.py def setEditorData ( self , editor , index ): \"\"\"Set the data to be displayed and edited by our custom editor.\"\"\" editor . set_star_rating ( index . data ()) setModelData ( self , editor , model , index ) Get the data from our custom editor and stuffs it into the model. Source code in prettyqt/custom_delegates/stardelegate.py def setModelData ( self , editor , model , index ): \"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\" model . setData ( index , editor . star_rating . star_count ) sizeHint ( self , option , index ) Return the size needed to display the item in a QSize object. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self , option , index ): \"\"\"Return the size needed to display the item in a QSize object.\"\"\" star_rating = StarRating ( index . data ()) return star_rating . sizeHint () StarEditor The custom editor for editing StarRatings. __init__ ( self , parent = None ) special Initialize the editor object, making sure we can watch mouse events. Source code in prettyqt/custom_delegates/stardelegate.py def __init__ ( self , parent : Optional [ QtWidgets . QWidget ] = None ): \"\"\"Initialize the editor object, making sure we can watch mouse events.\"\"\" super () . __init__ ( parent ) self . setMouseTracking ( True ) self . setAutoFillBackground ( True ) self . star_rating = StarRating () mouseMoveEvent ( self , event ) Update stars on mouse move. Source code in prettyqt/custom_delegates/stardelegate.py def mouseMoveEvent ( self , event ): \"\"\"Update stars on mouse move.\"\"\" star = self . star_at_position ( event . x ()) if star != - 1 : self . star_rating . star_count = star self . update () mouseReleaseEvent ( self , event ) Once star rating was clicked, tell the delegate we're done editing. Source code in prettyqt/custom_delegates/stardelegate.py def mouseReleaseEvent ( self , event ): \"\"\"Once star rating was clicked, tell the delegate we're done editing.\"\"\" self . editing_finished . emit () paintEvent ( self , event ) Paint the editor, offloading the work to the StarRating class. Source code in prettyqt/custom_delegates/stardelegate.py def paintEvent ( self , event ): \"\"\"Paint the editor, offloading the work to the StarRating class.\"\"\" painter = gui . Painter ( self ) self . star_rating . paint ( painter , self . rect (), self . palette (), is_editable = True ) sizeHint ( self ) Tell the caller how big we are. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self ): \"\"\"Tell the caller how big we are.\"\"\" return self . star_rating . sizeHint () star_at_position ( self , x ) Calculate which star the user's mouse cursor is currently hovering over. Source code in prettyqt/custom_delegates/stardelegate.py def star_at_position ( self , x : int ) -> int : \"\"\"Calculate which star the user's mouse cursor is currently hovering over.\"\"\" val = x // ( self . star_rating . sizeHint () . width () // self . star_rating . max_stars ) + 1 if not 0 < val <= self . star_rating . max_stars : return - 1 return val StarRating Handle the actual painting of the stars themselves. paint ( self , painter , rect , palette , is_editable = False ) Paint the stars (and/or diamonds if we're in editing mode). Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter : QtGui . QPainter , rect : QtCore . QRect , palette : QtGui . QPalette , is_editable : bool = False , ): \"\"\"Paint the stars (and/or diamonds if we're in editing mode).\"\"\" painter . save () painter . setRenderHint ( painter . Antialiasing , True ) painter . setPen ( QtCore . Qt . NoPen ) painter . setBrush ( palette . highlight () if is_editable else palette . windowText ()) y_offset = ( rect . height () - PAINTING_SCALE_FACTOR ) / 2 painter . translate ( rect . x (), rect . y () + y_offset ) painter . scale ( PAINTING_SCALE_FACTOR , PAINTING_SCALE_FACTOR ) for i in range ( self . max_stars ): if i < self . star_count : painter . drawPolygon ( STAR_POLYGON , QtCore . Qt . WindingFill ) elif is_editable : painter . drawPolygon ( DIAMOND_POLYGON , QtCore . Qt . WindingFill ) else : break painter . translate ( 1.0 , 0.0 ) painter . restore ()","title":"custom_delegates"},{"location":"api/custom_delegates.html#custom_delegates-module","text":"","title":"custom_delegates module"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates","text":"Module containing custom delegate classes.","title":"prettyqt.custom_delegates"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate","text":"","title":"buttondelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate","text":"","title":"ButtonDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.createEditor","text":"createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/buttondelegate.py def createEditor ( self , parent , option , index ) -> widgets . PushButton : label = index . data () btn_callback = index . data ( self . fn_role ) btn = widgets . PushButton ( label , parent ) if not btn_callback : btn . set_disabled () else : btn . clicked . connect ( btn_callback ) return btn","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setEditorData","text":"setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setEditorData ( self , editor , index ): pass","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.buttondelegate.ButtonDelegate.setModelData","text":"setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/buttondelegate.py def setModelData ( self , editor , model , index ): pass","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate","text":"","title":"checkboxdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate","text":"Delegate that places a CheckBox in every cell.","title":"CheckBoxDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.createEditor","text":"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. Source code in prettyqt/custom_delegates/checkboxdelegate.py def createEditor ( self , parent , option , index ): \"\"\"Override. instanciate the editor widget and initialize it also connect currentIndexChanged signal. \"\"\" cb = widgets . CheckBox ( parent ) cb . currentIndexChanged . connect ( self . currentIndexChanged ) return cb","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.setEditorData","text":"Override. set correct initial value for editor widget Source code in prettyqt/custom_delegates/checkboxdelegate.py def setEditorData ( self , cb , index ): \"\"\"Override. set correct initial value for editor widget \"\"\" current_selection = index . data () with cb . block_signals (): cb . setCurrentText ( current_selection )","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.checkboxdelegate.CheckBoxDelegate.setModelData","text":"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. Source code in prettyqt/custom_delegates/checkboxdelegate.py def setModelData ( self , combo , model , index ): \"\"\"Override, gets called on self.commitData (?). apply the newly selected dtype to the column if possible. \"\"\" dtype = self . dtypes [ combo . currentText ()] # s = model.data(index, model.DATA_ROLE) try : model . setData ( index , dtype , model . DTYPE_ROLE ) except ValueError as e : logger . error ( e )","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate","text":"","title":"icondelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate","text":"","title":"IconDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.icondelegate.IconDelegate.paint","text":"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Parameters: Name Type Description Default painter QPainter painter to paint the icon required option QStyleOptionViewItem state of the item to be displayed required index QModelIndex index which gets decorated required Source code in prettyqt/custom_delegates/icondelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): \"\"\"Override to paint an icon based on given Pixmap / Color / Icon. Pixmap / Color / Icon must be set to 'QtCore.Qt.UserRole + 1000' Args: painter (QtGui.QPainter): painter to paint the icon option (QtWidgets.QStyleOptionViewItem): state of the item to be displayed index (QtCore.QModelIndex): index which gets decorated \"\"\" super () . paint ( painter , option , index ) value = index . data ( DecorationRole2 ) if not value : return margin = 10 mode = gui . Icon . Normal if not ( option . state & widgets . Style . State_Enabled ): mode = gui . Icon . Disabled elif option . state & widgets . Style . State_Selected : mode = gui . Icon . Selected if isinstance ( value , QtGui . QPixmap ): icon = QtGui . QIcon ( value ) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QColor ): pixmap = QtGui . QPixmap ( option . decorationSize ) pixmap . fill ( value ) icon = QtGui . QIcon ( pixmap ) elif isinstance ( value , QtGui . QImage ): icon = QtGui . QIcon ( QtGui . QPixmap . fromImage ( value )) option . decorationSize = value . size () / value . devicePixelRatio () elif isinstance ( value , QtGui . QIcon ): is_on = option . state & widgets . Style . State_Open state = gui . Icon . On if is_on else gui . Icon . Off actual_size = option . icon . actualSize ( option . decorationSize , mode , state ) option . decorationSize = option . decorationSize & actual_size r = core . Rect ( core . Point (), option . decorationSize ) r . moveCenter ( option . rect . center ()) r . setRight ( option . rect . right () - margin ) state = gui . Icon . On if option . state & widgets . Style . State_Open else gui . Icon . Off alignment = constants . ALIGN_RIGHT | constants . ALIGN_V_CENTER icon . paint ( painter , r , alignment , mode , state )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate","text":"","title":"nofocusdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate","text":"","title":"NoFocusDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.nofocusdelegate.NoFocusDelegate.paint","text":"paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/nofocusdelegate.py def paint ( self , painter : QtGui . QPainter , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): if option . state & widgets . Style . State_HasFocus : option . state = option . state ^ widgets . Style . State_HasFocus super () . paint ( painter , option , index )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate","text":"","title":"progressbardelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate.ProgressBarDelegate","text":"","title":"ProgressBarDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.progressbardelegate.ProgressBarDelegate.paint","text":"paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/progressbardelegate.py def paint ( self , painter , option , index ): progress = index . data () progressBar_option = widgets . StyleOptionProgressBar () progressBar_option . rect = option . rect progressBar_option . minimum = 0 progressBar_option . maximum = 100 progressBar_option . progress = progress progressBar_option . text = f \" { progress } %\" progressBar_option . textVisible = True widgets . Application . style () . drawControl ( widgets . Style . CE_ProgressBar , progressBar_option , painter )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate","text":"","title":"radiodelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate","text":"","title":"RadioDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.createEditor","text":"createEditor(self, QWidget, QStyleOptionViewItem, QModelIndex) -> QWidget Source code in prettyqt/custom_delegates/radiodelegate.py def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ) -> widgets . Widget : editor = widgets . Widget ( parent ) editor . set_margin ( 0 ) editor . setAutoFillBackground ( True ) # create a button group to keep track of the checked radio editor . button_group = widgets . ButtonGroup () # adding the widget as an argument to the layout constructor automatically # applies it to the widget layout = widgets . BoxLayout ( \"horizontal\" , parent = editor ) layout . set_margin ( 0 ) for i , k in enumerate ( self . items ): rb = widgets . RadioButton ( k ) layout . addWidget ( rb ) # prevent the radio to get focus from keyboard or mouse rb . set_focus_policy ( \"none\" ) rb . installEventFilter ( self ) editor . button_group . addButton ( rb , i ) # add a stretch to always align contents to the left layout . addStretch ( 1 ) # set a property that will be used for the mask editor . setProperty ( \"offMask\" , gui . Region ( editor . rect ())) # type: ignore editor . installEventFilter ( self ) return editor","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.eventFilter","text":"eventFilter(self, QObject, QEvent) -> bool Source code in prettyqt/custom_delegates/radiodelegate.py def eventFilter ( self , source : QtWidgets . QWidget , event : QtCore . QEvent ) -> bool : if event . type () == core . Event . MouseButtonPress : if isinstance ( source , QtWidgets . QRadioButton ): if not source . parent () . hasFocus (): # the parent has no focus, set it and ignore the click source . parent () . setFocus () return True elif not source . hasFocus (): # the container has been clicked, check source . setFocus () elif event . type () == core . Event . FocusIn : # event received as a consequence of setFocus # clear the mask to show it completely source . clearMask () elif event . type () == core . Event . FocusOut : # another widget has requested focus, set the mask source . setMask ( source . property ( b \"offMask\" )) # update the table viewport to get rid of possible # grid lines left after masking source . parent () . update () return super () . eventFilter ( source , event )","title":"eventFilter()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setEditorData","text":"setEditorData(self, QWidget, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setEditorData ( self , editor : QtWidgets . QWidget , index : QtCore . QModelIndex ): value = index . data ( QtCore . Qt . DisplayRole ) if value in self . items : editor . button_group . button ( self . items . index ( value )) . setChecked ( True )","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.setModelData","text":"setModelData(self, QWidget, QAbstractItemModel, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def setModelData ( self , editor : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , index : QtCore . QModelIndex , ): button = editor . button_group . checkedId () if button >= 0 : model . setData ( index , self . items [ button ], QtCore . Qt . DisplayRole ) self . choices [ button ] = index . row ()","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.radiodelegate.RadioDelegate.updateEditorGeometry","text":"updateEditorGeometry(self, QWidget, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/radiodelegate.py def updateEditorGeometry ( self , editor : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , index : QtCore . QModelIndex , ): rect = core . Rect ( option . rect ) min_width = editor . minimumSizeHint () . width () if rect . width () < min_width : rect . setWidth ( min_width ) editor . setGeometry ( rect ) # create a new mask based on the option rectangle, then apply it mask = gui . Region ( 0 , 0 , option . rect . width (), option . rect . height ()) editor . setProperty ( \"offMask\" , mask ) # type: ignore editor . setMask ( mask )","title":"updateEditorGeometry()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate","text":"","title":"renderlinkdelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate.RenderLinkDelegate","text":"","title":"RenderLinkDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate.RenderLinkDelegate.editorEvent","text":"editorEvent(self, QEvent, QAbstractItemModel, QStyleOptionViewItem, QModelIndex) -> bool Source code in prettyqt/custom_delegates/renderlinkdelegate.py def editorEvent ( self , event , model , option , index ): text = index . data () font = index . data ( constants . FONT_ROLE ) # alignment = index.data(constants.ALIGNMENT_ROLE) if font is None : font = widgets . Application . get_font () fm = gui . FontMetricsF ( font ) rect = fm . get_bounding_rect ( core . RectF ( option . rect ), QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter , text , ) if ( event . type () == QtCore . QEvent . MouseButtonPress and event . button () == QtCore . Qt . LeftButton and event . localPos () in rect ): text = index . data () gui . DesktopServices . open_url ( text ) return True return False","title":"editorEvent()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.renderlinkdelegate.RenderLinkDelegate.paint","text":"paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/renderlinkdelegate.py def paint ( self , painter , option , index ): text = index . data () if not text : return painter . save () # I only wanted it for mouse over, but you'll probably want to remove # this condition if option . state and widgets . Style . State_MouseOver : font = option . font font . setUnderline ( True ) painter . setFont ( font ) painter . setPen ( option . palette . link () . color ()) painter . drawText ( option . rect , QtCore . Qt . AlignLeft | QtCore . Qt . AlignVCenter , text ) painter . restore ()","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate","text":"","title":"stardelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate","text":"A delegate class that allows us to render our star ratings.","title":"StarDelegate"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.createEditor","text":"Create and return the StarEditor object we'll use to edit the StarRating. Source code in prettyqt/custom_delegates/stardelegate.py def createEditor ( self , parent , option , index ): \"\"\"Create and return the StarEditor object we'll use to edit the StarRating.\"\"\" editor = StarEditor ( parent ) editor . editing_finished . connect ( self . commitAndCloseEditor ) return editor","title":"createEditor()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.paint","text":"paint(self, QPainter, QStyleOptionViewItem, QModelIndex) Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter , option , index ): star_rating = StarRating ( index . data ()) # If the row is currently selected, we need to make sure we # paint the background accordingly. if option . state & widgets . Style . State_Selected : # The original C++ example used option.palette.foreground() to # get the brush for painting, but there are a couple of # problems with that: # - foreground() is obsolete now, use windowText() instead # - more importantly, windowText() just returns a brush # containing a flat color, where sometimes the style # would have a nice subtle gradient or something. # Here we just use the brush of the painter object that's # passed in to us, which keeps the row highlighting nice # and consistent. painter . fillRect ( option . rect , painter . brush ()) # Now that we've painted the background, call star_rating.paint() # to paint the stars. star_rating . paint ( painter , option . rect , option . palette )","title":"paint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setEditorData","text":"Set the data to be displayed and edited by our custom editor. Source code in prettyqt/custom_delegates/stardelegate.py def setEditorData ( self , editor , index ): \"\"\"Set the data to be displayed and edited by our custom editor.\"\"\" editor . set_star_rating ( index . data ())","title":"setEditorData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.setModelData","text":"Get the data from our custom editor and stuffs it into the model. Source code in prettyqt/custom_delegates/stardelegate.py def setModelData ( self , editor , model , index ): \"\"\"Get the data from our custom editor and stuffs it into the model.\"\"\" model . setData ( index , editor . star_rating . star_count )","title":"setModelData()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarDelegate.sizeHint","text":"Return the size needed to display the item in a QSize object. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self , option , index ): \"\"\"Return the size needed to display the item in a QSize object.\"\"\" star_rating = StarRating ( index . data ()) return star_rating . sizeHint ()","title":"sizeHint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor","text":"The custom editor for editing StarRatings.","title":"StarEditor"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.__init__","text":"Initialize the editor object, making sure we can watch mouse events. Source code in prettyqt/custom_delegates/stardelegate.py def __init__ ( self , parent : Optional [ QtWidgets . QWidget ] = None ): \"\"\"Initialize the editor object, making sure we can watch mouse events.\"\"\" super () . __init__ ( parent ) self . setMouseTracking ( True ) self . setAutoFillBackground ( True ) self . star_rating = StarRating ()","title":"__init__()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.mouseMoveEvent","text":"Update stars on mouse move. Source code in prettyqt/custom_delegates/stardelegate.py def mouseMoveEvent ( self , event ): \"\"\"Update stars on mouse move.\"\"\" star = self . star_at_position ( event . x ()) if star != - 1 : self . star_rating . star_count = star self . update ()","title":"mouseMoveEvent()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.mouseReleaseEvent","text":"Once star rating was clicked, tell the delegate we're done editing. Source code in prettyqt/custom_delegates/stardelegate.py def mouseReleaseEvent ( self , event ): \"\"\"Once star rating was clicked, tell the delegate we're done editing.\"\"\" self . editing_finished . emit ()","title":"mouseReleaseEvent()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.paintEvent","text":"Paint the editor, offloading the work to the StarRating class. Source code in prettyqt/custom_delegates/stardelegate.py def paintEvent ( self , event ): \"\"\"Paint the editor, offloading the work to the StarRating class.\"\"\" painter = gui . Painter ( self ) self . star_rating . paint ( painter , self . rect (), self . palette (), is_editable = True )","title":"paintEvent()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.sizeHint","text":"Tell the caller how big we are. Source code in prettyqt/custom_delegates/stardelegate.py def sizeHint ( self ): \"\"\"Tell the caller how big we are.\"\"\" return self . star_rating . sizeHint ()","title":"sizeHint()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarEditor.star_at_position","text":"Calculate which star the user's mouse cursor is currently hovering over. Source code in prettyqt/custom_delegates/stardelegate.py def star_at_position ( self , x : int ) -> int : \"\"\"Calculate which star the user's mouse cursor is currently hovering over.\"\"\" val = x // ( self . star_rating . sizeHint () . width () // self . star_rating . max_stars ) + 1 if not 0 < val <= self . star_rating . max_stars : return - 1 return val","title":"star_at_position()"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarRating","text":"Handle the actual painting of the stars themselves.","title":"StarRating"},{"location":"api/custom_delegates.html#prettyqt.custom_delegates.stardelegate.StarRating.paint","text":"Paint the stars (and/or diamonds if we're in editing mode). Source code in prettyqt/custom_delegates/stardelegate.py def paint ( self , painter : QtGui . QPainter , rect : QtCore . QRect , palette : QtGui . QPalette , is_editable : bool = False , ): \"\"\"Paint the stars (and/or diamonds if we're in editing mode).\"\"\" painter . save () painter . setRenderHint ( painter . Antialiasing , True ) painter . setPen ( QtCore . Qt . NoPen ) painter . setBrush ( palette . highlight () if is_editable else palette . windowText ()) y_offset = ( rect . height () - PAINTING_SCALE_FACTOR ) / 2 painter . translate ( rect . x (), rect . y () + y_offset ) painter . scale ( PAINTING_SCALE_FACTOR , PAINTING_SCALE_FACTOR ) for i in range ( self . max_stars ): if i < self . star_count : painter . drawPolygon ( STAR_POLYGON , QtCore . Qt . WindingFill ) elif is_editable : painter . drawPolygon ( DIAMOND_POLYGON , QtCore . Qt . WindingFill ) else : break painter . translate ( 1.0 , 0.0 ) painter . restore ()","title":"paint()"},{"location":"api/custom_models.html","text":"custom_models module Custom_models module. Contains custom models columnitemmodel ColumnItem dataclass Determines how an object attribute is shown. ColumnItemModel Model that provides an interface to an objectree that is build of TreeItems. columnCount ( self , _parent = None ) Return the number of columns in the tree. Source code in prettyqt/custom_models/columnitemmodel.py def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols ) data ( self , index , role ) Return the tree item at the given index and role. Source code in prettyqt/custom_models/columnitemmodel.py def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: val = self . _attr_cols [ col ] . get_label ( tree_item ) return val . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None flags ( self , index ) flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/custom_models/columnitemmodel.py def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN col = index . column () return self . _attr_cols [ col ] . get_flag () headerData ( self , section , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/columnitemmodel.py def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None importlibdistributionmodel ImportlibDistributionModel columnCount ( self , parent =< PyQt5 . QtCore . QModelIndex object at 0x7f1106b130b0 > ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def columnCount ( self , parent = core . ModelIndex ()): return len ( self . HEADER ) if not parent . isValid () else 0 data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Name\" ] elif index . column () == 1 : dist = self . distributions [ index . row ()] return dist . version elif index . column () == 2 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Summary\" ] elif index . column () == 3 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Home-Page\" ] elif index . column () == 4 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Author\" ] elif index . column () == 5 : dist = self . distributions [ index . row ()] return dist . metadata [ \"License\" ] elif role == constants . USER_ROLE : dist = self . distributions [ index . row ()] return dist headerData ( self , offset , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def headerData ( self , offset : int , orientation , role ): # type: ignore if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ] rowCount ( self , parent =< PyQt5 . QtCore . QModelIndex object at 0x7f1106abef20 > ) rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def rowCount ( self , parent = core . ModelIndex ()): return len ( self . distributions ) if not parent . isValid () else 0 playlistmodel PlaylistModel columnCount ( self , parent = None ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/playlistmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER ) data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/playlistmodel.py def data ( self , index : core . ModelIndex , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if self . _playlist is None : return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : location = self . _playlist . media ( index . row ()) . canonicalUrl () return core . FileInfo ( location . path ()) . fileName () return None rowCount ( self , parent = None ) rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/playlistmodel.py def rowCount ( self , parent = None ): if self . _playlist is None : return 0 return len ( self . _playlist ) regexmatchesmodel RegexMatchesModel columnCount ( self , parent = None ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER ) data ( self , index , role ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span () headerData ( self , section , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def headerData ( # type: ignore self , section : int , orientation : QtCore . Qt . Orientation , role : int ) -> Optional [ str ]: if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ section ] rowCount ( self , parent = None ) Required override for AbstractitemModels. Source code in prettyqt/custom_models/regexmatchesmodel.py def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches ) transposeproxymodel TransposeProxyModel columnCount ( self , parent = None ) columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def columnCount ( self , parent : Optional [ core . ModelIndex ] = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . rowCount ( parent ) data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def data ( self , index : core . ModelIndex , role = QtCore . Qt . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role ) headerData ( self , section , orientation , role ) headerData(self, int, Qt.Orientation, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def headerData ( self , section : int , orientation , role ): # type: ignore return self . _source_model . headerData ( section , orientation , role ) index ( self , row , column , parent = None ) index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def index ( self , row : int , column : int , parent : Optional [ core . ModelIndex ] = None ) -> core . ModelIndex : return self . createIndex ( row , column ) mapFromSource ( self , source_index ) mapFromSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapFromSource ( self , source_index : core . ModelIndex ) -> core . ModelIndex : return self . index ( source_index . column (), source_index . row ()) mapToSource ( self , proxy_index ) mapToSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapToSource ( self , proxy_index : core . ModelIndex ) -> core . ModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ()) parent ( self , index ) parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/custom_models/transposeproxymodel.py def parent ( self , index : core . ModelIndex ): # type: ignore return None rowCount ( self , parent = None ) rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def rowCount ( self , parent : Optional [ core . ModelIndex ] = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . columnCount ( parent ) setSourceModel ( self , source_model ) setSourceModel(self, QAbstractItemModel) Source code in prettyqt/custom_models/transposeproxymodel.py def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"custom_models"},{"location":"api/custom_models.html#custom_models-module","text":"","title":"custom_models module"},{"location":"api/custom_models.html#prettyqt.custom_models","text":"Custom_models module. Contains custom models","title":"prettyqt.custom_models"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel","text":"","title":"columnitemmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItem","text":"Determines how an object attribute is shown.","title":"ColumnItem"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel","text":"Model that provides an interface to an objectree that is build of TreeItems.","title":"ColumnItemModel"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.columnCount","text":"Return the number of columns in the tree. Source code in prettyqt/custom_models/columnitemmodel.py def columnCount ( self , _parent = None ): \"\"\"Return the number of columns in the tree.\"\"\" return len ( self . _attr_cols )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.data","text":"Return the tree item at the given index and role. Source code in prettyqt/custom_models/columnitemmodel.py def data ( self , index , role ): \"\"\"Return the tree item at the given index and role.\"\"\" if not index . isValid (): return None col = index . column () tree_item = index . internalPointer () if role in [ constants . DISPLAY_ROLE , constants . EDIT_ROLE ]: val = self . _attr_cols [ col ] . get_label ( tree_item ) return val . replace ( \" \\n \" , \" \" ) elif role == constants . DECORATION_ROLE : return self . _attr_cols [ col ] . get_decoration ( tree_item ) elif role == constants . CHECKSTATE_ROLE : return self . _attr_cols [ col ] . get_checkstate ( tree_item ) elif role == constants . ALIGNMENT_ROLE : return self . _attr_cols [ col ] . get_alignment ( tree_item ) elif role == constants . FOREGROUND_ROLE : return self . _attr_cols [ col ] . get_foreground_color ( tree_item ) elif role == constants . BACKGROUND_ROLE : return self . _attr_cols [ col ] . get_background_color ( tree_item ) elif role == constants . FONT_ROLE : return self . _attr_cols [ col ] . get_font ( tree_item ) else : return None","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.flags","text":"flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/custom_models/columnitemmodel.py def flags ( self , index ): if not index . isValid (): return constants . NO_CHILDREN col = index . column () return self . _attr_cols [ col ] . get_flag ()","title":"flags()"},{"location":"api/custom_models.html#prettyqt.custom_models.columnitemmodel.ColumnItemModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/columnitemmodel.py def headerData ( self , section , orientation , role ): if orientation == constants . HORIZONTAL and role == constants . DISPLAY_ROLE : return self . _attr_cols [ section ] . name else : return None","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel","text":"","title":"importlibdistributionmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel","text":"","title":"ImportlibDistributionModel"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def columnCount ( self , parent = core . ModelIndex ()): return len ( self . HEADER ) if not parent . isValid () else 0","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def data ( self , index , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Name\" ] elif index . column () == 1 : dist = self . distributions [ index . row ()] return dist . version elif index . column () == 2 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Summary\" ] elif index . column () == 3 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Home-Page\" ] elif index . column () == 4 : dist = self . distributions [ index . row ()] return dist . metadata [ \"Author\" ] elif index . column () == 5 : dist = self . distributions [ index . row ()] return dist . metadata [ \"License\" ] elif role == constants . USER_ROLE : dist = self . distributions [ index . row ()] return dist","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/importlibdistributionmodel.py def headerData ( self , offset : int , orientation , role ): # type: ignore if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ offset ]","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.importlibdistributionmodel.ImportlibDistributionModel.rowCount","text":"rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/importlibdistributionmodel.py def rowCount ( self , parent = core . ModelIndex ()): return len ( self . distributions ) if not parent . isValid () else 0","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.playlistmodel","text":"","title":"playlistmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.playlistmodel.PlaylistModel","text":"","title":"PlaylistModel"},{"location":"api/custom_models.html#prettyqt.custom_models.playlistmodel.PlaylistModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/playlistmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.playlistmodel.PlaylistModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/playlistmodel.py def data ( self , index : core . ModelIndex , role = constants . DISPLAY_ROLE ): if not index . isValid (): return None if self . _playlist is None : return None if role == constants . DISPLAY_ROLE : if index . column () == 0 : location = self . _playlist . media ( index . row ()) . canonicalUrl () return core . FileInfo ( location . path ()) . fileName () return None","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.playlistmodel.PlaylistModel.rowCount","text":"rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/playlistmodel.py def rowCount ( self , parent = None ): if self . _playlist is None : return 0 return len ( self . _playlist )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel","text":"","title":"regexmatchesmodel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel","text":"","title":"RegexMatchesModel"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/regexmatchesmodel.py def columnCount ( self , parent = None ): return len ( self . HEADER )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def data ( self , index , role ): if not index . isValid (): return None item = self . matches [ index . row ()] if role in [ constants . DISPLAY_ROLE ]: if index . column () == 0 : return str ( item . span ()[ 0 ]) if index . column () == 1 : return str ( item . span ()[ 1 ]) elif index . column () == 2 : return repr ( item . group ()) elif index . column () == 3 : return str ( len ( item . groups ())) if role in [ constants . USER_ROLE ]: return item . span ()","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/custom_models/regexmatchesmodel.py def headerData ( # type: ignore self , section : int , orientation : QtCore . Qt . Orientation , role : int ) -> Optional [ str ]: if role == constants . DISPLAY_ROLE : if orientation == constants . HORIZONTAL : return self . HEADER [ section ]","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.regexmatchesmodel.RegexMatchesModel.rowCount","text":"Required override for AbstractitemModels. Source code in prettyqt/custom_models/regexmatchesmodel.py def rowCount ( self , parent = None ): \"\"\"Required override for AbstractitemModels.\"\"\" return len ( self . matches )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel","text":"","title":"transposeproxymodel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel","text":"","title":"TransposeProxyModel"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.columnCount","text":"columnCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def columnCount ( self , parent : Optional [ core . ModelIndex ] = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . rowCount ( parent )","title":"columnCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.data","text":"data(self, QModelIndex, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def data ( self , index : core . ModelIndex , role = QtCore . Qt . DisplayRole ): if not index . isValid (): return False return self . _source_model . data ( self . mapFromSource ( index ), role )","title":"data()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.headerData","text":"headerData(self, int, Qt.Orientation, role: int = Qt.DisplayRole) -> Any Source code in prettyqt/custom_models/transposeproxymodel.py def headerData ( self , section : int , orientation , role ): # type: ignore return self . _source_model . headerData ( section , orientation , role )","title":"headerData()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.index","text":"index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def index ( self , row : int , column : int , parent : Optional [ core . ModelIndex ] = None ) -> core . ModelIndex : return self . createIndex ( row , column )","title":"index()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapFromSource","text":"mapFromSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapFromSource ( self , source_index : core . ModelIndex ) -> core . ModelIndex : return self . index ( source_index . column (), source_index . row ())","title":"mapFromSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.mapToSource","text":"mapToSource(self, QModelIndex) -> QModelIndex Source code in prettyqt/custom_models/transposeproxymodel.py def mapToSource ( self , proxy_index : core . ModelIndex ) -> core . ModelIndex : return self . _source_model . index ( proxy_index . column (), proxy_index . row ())","title":"mapToSource()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.parent","text":"parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/custom_models/transposeproxymodel.py def parent ( self , index : core . ModelIndex ): # type: ignore return None","title":"parent()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.rowCount","text":"rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/custom_models/transposeproxymodel.py def rowCount ( self , parent : Optional [ core . ModelIndex ] = None ) -> int : if parent is None : parent = core . ModelIndex () return self . _source_model . columnCount ( parent )","title":"rowCount()"},{"location":"api/custom_models.html#prettyqt.custom_models.transposeproxymodel.TransposeProxyModel.setSourceModel","text":"setSourceModel(self, QAbstractItemModel) Source code in prettyqt/custom_models/transposeproxymodel.py def setSourceModel ( self , source_model : QtCore . QAbstractItemModel ): self . _source_model = source_model super () . setSourceModel ( source_model )","title":"setSourceModel()"},{"location":"api/custom_validators.html","text":"custom_validators module Custom_validators module. Contains custom validators compositevalidator CompositeValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/compositevalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> Tuple [ QtGui . QValidator . State , str , int ]: vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] # type: ignore return min ( vals ), text , pos notemptyvalidator NotEmptyValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notemptyvalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> Tuple [ QtGui . QValidator . State , str , int ]: if text == \"\" : return ( self . Intermediate , text , pos ) return self . Acceptable , text , pos notzerovalidator NotZeroValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notzerovalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> Tuple [ QtGui . QValidator . State , str , int ]: if text == \"0\" : return self . Intermediate , text , pos return self . Acceptable , text , pos pathvalidator PathValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/pathvalidator.py def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return self . Acceptable , text , pos return self . Intermediate , text , pos regexpatternvalidator RegexPatternValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexpatternvalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> Tuple [ QtGui . QValidator . State , str , int ]: # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : compiled = re . compile ( text ) except sre_constants . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . Intermediate , text , pos except re . _regex_core . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . Intermediate , text , pos else : self . error_occured . emit ( \"\" ) self . pattern_updated . emit ( compiled ) return self . Acceptable , text , pos regexvalidators BaseRegexValidator validate ( self , text , pos = 0 ) validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexvalidators.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> Tuple [ QtGui . QValidator . State , str , int ]: if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return self . Intermediate , text , pos match = self . regex . match ( text , partial = True ) if match is None : return self . Invalid , text , pos if match . partial : return self . Intermediate , text , pos else : return self . Acceptable , text , pos","title":"custom_validators"},{"location":"api/custom_validators.html#custom_validators-module","text":"","title":"custom_validators module"},{"location":"api/custom_validators.html#prettyqt.custom_validators","text":"Custom_validators module. Contains custom validators","title":"prettyqt.custom_validators"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator","text":"","title":"compositevalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator","text":"","title":"CompositeValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.compositevalidator.CompositeValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/compositevalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> Tuple [ QtGui . QValidator . State , str , int ]: vals = [ v . validate ( text , pos )[ 0 ] for v in self . validators ] # type: ignore return min ( vals ), text , pos","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator","text":"","title":"notemptyvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator","text":"","title":"NotEmptyValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notemptyvalidator.NotEmptyValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notemptyvalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> Tuple [ QtGui . QValidator . State , str , int ]: if text == \"\" : return ( self . Intermediate , text , pos ) return self . Acceptable , text , pos","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator","text":"","title":"notzerovalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator","text":"","title":"NotZeroValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.notzerovalidator.NotZeroValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/notzerovalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> Tuple [ QtGui . QValidator . State , str , int ]: if text == \"0\" : return self . Intermediate , text , pos return self . Acceptable , text , pos","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator","text":"","title":"pathvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator","text":"","title":"PathValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.pathvalidator.PathValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/pathvalidator.py def validate ( self , text : str , pos : int = 0 ): if pathlib . Path ( text ) . exists (): return self . Acceptable , text , pos return self . Intermediate , text , pos","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator","text":"","title":"regexpatternvalidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator","text":"","title":"RegexPatternValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexpatternvalidator.RegexPatternValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexpatternvalidator.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> Tuple [ QtGui . QValidator . State , str , int ]: # if text == \"\": # self.compiled = None # return (self.Intermediate, text, pos) try : compiled = re . compile ( text ) except sre_constants . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . Intermediate , text , pos except re . _regex_core . error as e : self . error_occured . emit ( str ( e )) self . pattern_updated . emit ( None ) return self . Intermediate , text , pos else : self . error_occured . emit ( \"\" ) self . pattern_updated . emit ( compiled ) return self . Acceptable , text , pos","title":"validate()"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators","text":"","title":"regexvalidators"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator","text":"","title":"BaseRegexValidator"},{"location":"api/custom_validators.html#prettyqt.custom_validators.regexvalidators.BaseRegexValidator.validate","text":"validate(self, str, int) -> Tuple[QValidator.State, str, int] Source code in prettyqt/custom_validators/regexvalidators.py def validate ( # type: ignore self , text : str , pos : int = 0 ) -> Tuple [ QtGui . QValidator . State , str , int ]: if self . regex is None : raise TypeError ( \"Validator not initialized\" ) if text == \"\" : return self . Intermediate , text , pos match = self . regex . match ( text , partial = True ) if match is None : return self . Invalid , text , pos if match . partial : return self . Intermediate , text , pos else : return self . Acceptable , text , pos","title":"validate()"},{"location":"api/custom_widgets.html","text":"custom_widgets module Module containing custom widget classes. codeeditor CodeEditor resizeEvent ( self , event ) resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/codeeditor.py def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect ) LineNumberArea paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/codeeditor.py def paintEvent ( self , event ): self . editor . line_area_paintevent ( event ) sizeHint ( self ) sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/codeeditor.py def sizeHint ( self ) -> core . Size : return core . Size ( self . editor . line_area_width (), 0 ) dataset DataItem set_pos ( self , col = 0 , colspan = None ) Set data item's position on a GUI layout. Source code in prettyqt/custom_widgets/dataset.py def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self DataSetMeta __new__ ( mcs , name , bases , dct ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct ) filechooserbutton FileChooserButton __init__ ( self , extensions = None , mode = 'save' , file_mode = 'existing_files' , root = None , parent = None ) special Initialize FileChooserButton. Parameters: Name Type Description Default extensions Optional[Dict[str, List[str]]] dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode Literal['save', 'open'] Accept mode (\"save\" or \"load\") 'save' file_mode Literal['existing_file', 'existing_files', 'any_file', 'directory'] File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' root Union[NoneType, str, pathlib.Path] Root path None parent Optional[PyQt5.QtWidgets.QWidget] parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py def __init__ ( self , extensions : Optional [ Dict [ str , List [ str ]]] = None , mode : widgets . filedialog . AcceptModeStr = \"save\" , file_mode : widgets . filedialog . FileModeStr = \"existing_files\" , root : Union [ None , str , pathlib . Path ] = None , parent : Optional [ QtWidgets . QWidget ] = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : Optional [ pathlib . Path ] = None self . extensions = extensions self . mode : widgets . filedialog . AcceptModeStr = mode self . file_mode : widgets . filedialog . FileModeStr = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout . add ( self . lineedit ) action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout . add ( self . button ) flowlayout FlowLayout addItem ( self , item ) addItem(self, QLayoutItem) Source code in prettyqt/custom_widgets/flowlayout.py def addItem ( self , item : QtWidgets . QLayoutItem ): self . items . append ( item ) count ( self ) count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py def count ( self ) -> int : return len ( self . items ) hasHeightForWidth ( self ) hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py def hasHeightForWidth ( self ) -> bool : return True heightForWidth ( self , width ) heightForWidth(self, int) -> int Source code in prettyqt/custom_widgets/flowlayout.py def heightForWidth ( self , width : int ) -> int : rect = QtCore . QRect ( 0 , 0 , width , 0 ) return self . do_layout ( rect , True ) itemAt ( self , index ) itemAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def itemAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: # type: ignore if 0 <= index < len ( self . items ): return self . items [ index ] return None minimumSize ( self ) minimumSize(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def minimumSize ( self ) -> QtCore . QSize : size = QtCore . QSize () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += QtCore . QSize ( margin_width , margin_width ) return size setGeometry ( self , rect ) setGeometry(self, QRect) Source code in prettyqt/custom_widgets/flowlayout.py def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False ) sizeHint ( self ) sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def sizeHint ( self ) -> QtCore . QSize : return self . minimumSize () takeAt ( self , index ) takeAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def takeAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: # type: ignore if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None iconbrowser IconBrowser A small browser window that allows the user to search through all icons. You can also copy the name and python code for the currently selected icon. IconListView A QListView that scales its grid size to always show same amount of items. resizeEvent ( self , event ) Re-calculate the grid size to provide scaling icons. Source code in prettyqt/custom_widgets/iconbrowser.py def resizeEvent ( self , event ): \"\"\"Re-calculate the grid size to provide scaling icons.\"\"\" width = self . viewport () . width () - 30 # The minus 30 above ensures we don't end up with an item width that # can't be drawn the expected number of times across the view without # being wrapped. Without this, the view can flicker during resize tile_width = int ( width / self . VIEW_COLUMNS ) icon_width = int ( tile_width * 0.8 ) self . set_grid_size (( tile_width , tile_width )) self . set_icon_size (( icon_width , icon_width )) return super () . resizeEvent ( event ) IconModel data ( self , index , role ) data(self, QModelIndex, int) -> Any Source code in prettyqt/custom_widgets/iconbrowser.py def data ( self , index , role ): if role == constants . DECORATION_ROLE : icon_string = self . data ( index , role = constants . DISPLAY_ROLE ) return iconprovider . _icon ( icon_string , color = self . _icon_color ) return super () . data ( index , role ) flags ( self , index ) flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/custom_widgets/iconbrowser.py def flags ( self , index ): return constants . IS_ENABLED | constants . IS_SELECTABLE iconwidget IconWidget IconWidget gives the ability to display an icon as a widget. if supports the same arguments as icon() for example music_icon = qta.IconWidget('fa5s.music', color='blue', color_active='orange') it also have setIcon() and setIconSize() functions set_icon ( self , _icon ) Set a new icon(). qtawesome.icon icon to set Source code in prettyqt/custom_widgets/iconwidget.py def set_icon ( self , _icon : QtGui . QIcon ): \"\"\"Set a new icon(). Parameters ---------- _icon: qtawesome.icon icon to set \"\"\" self . _icon = _icon self . setPixmap ( _icon . pixmap ( self . _size )) update ( self , * args , ** kwargs ) update(self) update(self, QRect) update(self, QRegion) update(self, int, int, int, int) Source code in prettyqt/custom_widgets/iconwidget.py def update ( self , * args , ** kwargs ): if self . _icon : self . setPixmap ( self . _icon . pixmap ( self . _size )) return super () . update ( * args , ** kwargs ) labeledslider LabeledSlider paintEvent ( self , e ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/labeledslider.py def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PM_SliderSpaceAvailable , st_slider , self . sl ) painter = gui . Painter ( self ) for v , v_str in self . levels : # get the size of the label rect = painter . get_text_rect ( v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc self . bottom_margin = max ( self . bottom_margin , rect . height ()) self . adjust_margins () if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . adjust_margins () else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . adjust_margins () painter . drawText ( left , bottom , v_str ) popupinfo PopupInfo Dialog overlay to show some info to user. show ( self ) show(self) Source code in prettyqt/custom_widgets/popupinfo.py def show ( self ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) // 2 y = ( screen_geo . height () - size . height ()) // 2 self . move ( x , y - 200 ) super () . show () self . timer . start ( 2500 ) regexeditor special Module containing classes related to the RegEx editor. __main__ special This module contains the editor widget implementation. quick_ref Contains the quick reference widget. regexeditorwidget This module contains the editor widget implementation. roundprogressbar RoundProgressBar paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/roundprogressbar.py def paintEvent ( self , event : gui . PaintEvent ): outer_radius = min ( self . width (), self . height ()) rect = core . RectF ( 1 , 1 , outer_radius - 2 , outer_radius - 2 ) with gui . Painter ( self ) as painter : painter . use_antialiasing () if self . bar_style != \"line\" : self . _rebuild_data_brush_if_needed () painter . fillRect ( 0 , 0 , outer_radius , outer_radius , self . palette () . window ()) self . _draw_base ( painter , rect ) self . _draw_value ( painter , rect , self . current_value ) inner_rect , inner_radius = self . _calculate_inner_rect ( outer_radius ) self . _draw_inner_background ( painter , inner_rect ) self . _draw_text ( painter , inner_rect , inner_radius , self . current_value ) spanslider SpanSlider mouseMoveEvent ( self , event ) mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PM_MaximumDragDistance , opt , self ) pixel_pos = self . pick ( event . pos ()) - self . offset new_pos = float ( self . _pixel_pos_to_value ( pixel_pos )) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . pos ()): new_pos = self . position # pick the preferred handle on the first movement if self . _first_movement : if self . lower_val == self . upper_val : if new_pos < self . lower_value : self . _swap_controls () self . _first_movement = False else : self . _first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper_val ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper_val - 1 ) if self . movement == \"free\" and new_pos > self . upper_val : self . _swap_controls () self . set_upper_pos ( new_pos ) else : # movement \"none\" self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower_val : self . _swap_controls () self . set_lower_pos ( new_pos ) else : # movement \"none\" self . set_upper_pos ( new_pos ) event . accept () mousePressEvent ( self , event ) mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . _handle_mouse_press ( event . pos (), self . upper_pressed , self . upper_val , \"upper\" ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . _handle_mouse_press ( event . pos (), self . lower_pressed , self . lower_val , \"lower\" ) self . _first_movement = True event . accept () mouseReleaseEvent ( self , event ) mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SC_None self . update () paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/spanslider.py def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SC_SliderTickmarks painter . draw_complex_control ( \"slider\" , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . draw_complex_control ( \"slider\" , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () if self . is_horizontal (): rect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) else : rect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) self . _draw_span ( painter , rect ) # handles if self . last_pressed == \"lower\" : self . draw_handle ( painter , \"upper\" ) self . draw_handle ( painter , \"lower\" ) else : self . draw_handle ( painter , \"lower\" ) self . draw_handle ( painter , \"upper\" ) set_movement_mode ( self , mode ) Set movement mode. Parameters: Name Type Description Default mode Literal['no_crossing', 'no_overlap', 'free'] movement mode for the main window required Exceptions: Type Description ValueError movement mode type does not exist Source code in prettyqt/custom_widgets/spanslider.py def set_movement_mode ( self , mode : MovementModeStr ): \"\"\"Set movement mode. Args: mode: movement mode for the main window Raises: ValueError: movement mode type does not exist \"\"\" if mode not in MOVEMENT_MODE : raise ValueError ( \"Invalid movement mode\" ) self . movement = mode trigger_action ( self , action , main ) Trigger slider action. Source code in prettyqt/custom_widgets/spanslider.py def trigger_action ( self , action : ActionStr , main : bool ): value = 0.0 no = False up = False my_min = self . minimum () my_max = self . maximum () self . _block_tracking = True main_control = main and self . _main_control == \"upper\" alt_control = not main and self . _main_control == \"lower\" is_upper_handle = main_control or alt_control val = self . upper_val if is_upper_handle else self . lower_val if action == \"single_step_add\" : up = is_upper_handle value = clamp ( val + self . singleStep (), my_min , my_max ) elif action == \"single_step_sub\" : up = is_upper_handle value = clamp ( val - self . singleStep (), my_min , my_max ) elif action == \"to_minimum\" : up = is_upper_handle value = my_min elif action == \"to_maximum\" : up = is_upper_handle value = my_max elif action == \"move\" : up = is_upper_handle no = True elif action == \"none\" : no = True if not no and not up : if self . movement == \"no_crossing\" : value = min ( value , self . upper_val ) elif self . movement == \"no_overlap\" : value = min ( value , self . upper_val - 1 ) if self . movement == \"free\" and value > self . upper_val : self . _swap_controls () self . set_upper_pos ( value ) else : self . set_lower_pos ( value ) elif not no : if self . movement == \"no_crossing\" : value = max ( value , self . lower_val ) elif self . movement == \"no_overlap\" : value = max ( value , self . lower_val + 1 ) if self . movement == \"free\" and value < self . lower_val : self . _swap_controls () self . set_lower_pos ( value ) else : self . set_upper_pos ( value ) self . _block_tracking = False self . set_lower_value ( self . lower_pos ) self . set_upper_value ( self . upper_pos ) timeline Timeline enterEvent ( self , e ) enterEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def enterEvent ( self , e ): self . _is_in = True leaveEvent ( self , e ) leaveEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def leaveEvent ( self , e ): self . _is_in = False self . update () mouseMoveEvent ( self , e ) mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseMoveEvent ( self , e ): self . _position = e . pos () # if mouse is being pressed, update pointer if self . _clicking : x = self . _position . x () self . position_changed . emit ( x ) self . _check_selection ( x ) self . pointer_time_pos = x * self . get_scale () self . update () mousePressEvent ( self , e ) mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mousePressEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : x = e . pos () . x () self . position_changed . emit ( x ) self . pointer_time_pos = x * self . get_scale () self . _check_selection ( x ) self . update () self . _clicking = True # Set clicking check to true mouseReleaseEvent ( self , e ) mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseReleaseEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : self . _clicking = False # Set clicking check to false paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/timeline.py def paintEvent ( self , event ): # Draw time scale = self . get_scale () with gui . Painter ( self ) as qp : qp . set_color ( self . text_color ) qp . setFont ( self . text_font ) qp . use_antialiasing () w = 0 while ( w := w + 100 ) <= self . width (): time_string = self . get_time_string ( w * scale ) rect = core . Rect ( w - 50 , 0 , 100 , 100 ) qp . drawText ( rect , QtCore . Qt . AlignHCenter , time_string ) # Draw down line qp . set_pen ( color = PEN_COLOR , width = 5 ) qp . drawLine ( 0 , 40 , self . width (), 40 ) # Draw dash lines point = 0 qp . set_pen ( color = self . text_color ) qp . drawLine ( 0 , 40 , self . width (), 40 ) while point <= self . width (): y2 = 30 if point % 30 != 0 else 20 qp . drawLine ( 3 * point , 40 , 3 * point , y2 ) point += 10 if self . _position is not None and self . _is_in : qp . drawLine ( self . _position . x (), 0 , self . _position . x (), 40 ) poly = gui . Polygon () if self . _position is not None : val = self . pointer_time_pos / self . get_scale () line = core . Line ( val , 40 , val , self . height ()) poly . add_points (( val - 10 , 20 ), ( val + 10 , 20 ), ( val , 40 )) else : line = core . Line ( 0 , 0 , 0 , self . height ()) poly . add_points (( - 10 , 20 ), ( 10 , 20 ), ( 0 , 40 )) # Draw samples t = 0.0 for sample in self . video_samples : scaled_dur = sample . duration / scale scaled_t = t / scale t += sample . duration # Clear clip path with qp . clip_path () as path : rect = core . RectF ( scaled_t , 50 , scaled_dur , 200 ) path . addRoundedRect ( rect , 10 , 10 ) # Draw sample path = gui . PainterPath () qp . set_pen ( color = sample . color ) rect = core . RectF ( scaled_t , 50 , scaled_dur , 50 ) path . addRoundedRect ( rect , 10 , 10 ) sample . start_pos = scaled_t sample . end_pos = scaled_t + scaled_dur qp . fillPath ( path , sample . color ) qp . drawPath ( path ) # Draw preview pictures if sample . picture is None : continue pic_width = sample . picture . size () . width () if pic_width < scaled_dur : width = float ( pic_width ) pic = sample . picture else : width = scaled_dur pic = sample . picture . copy ( 0 , 0 , int ( scaled_dur ), 45 ) with qp . clip_path () as path : rect = core . RectF ( scaled_t , 52.5 , width , 45 ) path . addRoundedRect ( rect , 10 , 10 ) qp . drawPixmap ( int ( scaled_t ), int ( 52.5 ), int ( width ), 45 , pic ) # Clear clip path with qp . clip_path () as path : path . add_rect ( self . rect ()) # Draw pointer qp . set_color ( PEN_COLOR ) qp . set_brush ( PEN_COLOR ) qp . drawPolygon ( poly ) qp . drawLine ( line ) waitingspinner The MIT License (MIT). Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. BaseWaitingSpinner paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( style = \"none\" ) painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length ) rect = core . RectF ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) for i in range ( self . _line_num ): with painter . backup_state (): rotate_angle = 360 * i / self . _line_num painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . RelativeSize ) WaitingSpinner paintEvent ( self , event ) paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event )","title":"custom_widgets"},{"location":"api/custom_widgets.html#custom_widgets-module","text":"","title":"custom_widgets module"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets","text":"Module containing custom widget classes.","title":"prettyqt.custom_widgets"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor","text":"","title":"codeeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor","text":"","title":"CodeEditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.CodeEditor.resizeEvent","text":"resizeEvent(self, QResizeEvent) Source code in prettyqt/custom_widgets/codeeditor.py def resizeEvent ( self , event ): super () . resizeEvent ( event ) cr = self . contentsRect () rect = core . Rect ( cr . left (), cr . top (), self . line_area_width (), cr . height ()) self . line_area . setGeometry ( rect )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea","text":"","title":"LineNumberArea"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/codeeditor.py def paintEvent ( self , event ): self . editor . line_area_paintevent ( event )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.codeeditor.LineNumberArea.sizeHint","text":"sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/codeeditor.py def sizeHint ( self ) -> core . Size : return core . Size ( self . editor . line_area_width (), 0 )","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset","text":"","title":"dataset"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem","text":"","title":"DataItem"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataItem.set_pos","text":"Set data item's position on a GUI layout. Source code in prettyqt/custom_widgets/dataset.py def set_pos ( self , col = 0 , colspan = None ): \"\"\"Set data item's position on a GUI layout.\"\"\" self . label_col = col self . colspan = colspan return self","title":"set_pos()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta","text":"","title":"DataSetMeta"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.dataset.DataSetMeta.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in prettyqt/custom_widgets/dataset.py def __new__ ( mcs , name , bases , dct ): filtered = [ b for b in bases if getattr ( b , \"__metaclass__\" , None ) is DataSetMeta ] items = { item . _name : item for b in filtered for item in b . _items } # items should contain DataItems of parent classes for attrname , value in list ( dct . items ()): if isinstance ( value , DataItem ): value . name = attrname items [ attrname ] = value dct [ \"_items\" ] = items return type . __new__ ( mcs , name , bases , dct )","title":"__new__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton","text":"","title":"filechooserbutton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton","text":"","title":"FileChooserButton"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.filechooserbutton.FileChooserButton.__init__","text":"Initialize FileChooserButton. Parameters: Name Type Description Default extensions Optional[Dict[str, List[str]]] dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" None mode Literal['save', 'open'] Accept mode (\"save\" or \"load\") 'save' file_mode Literal['existing_file', 'existing_files', 'any_file', 'directory'] File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") 'existing_files' root Union[NoneType, str, pathlib.Path] Root path None parent Optional[PyQt5.QtWidgets.QWidget] parent widget None Source code in prettyqt/custom_widgets/filechooserbutton.py def __init__ ( self , extensions : Optional [ Dict [ str , List [ str ]]] = None , mode : widgets . filedialog . AcceptModeStr = \"save\" , file_mode : widgets . filedialog . FileModeStr = \"existing_files\" , root : Union [ None , str , pathlib . Path ] = None , parent : Optional [ QtWidgets . QWidget ] = None , ): \"\"\"Initialize FileChooserButton. Args: extensions: dict allowed extensions form: \"'name': ['.ext1', '.ext2']\" mode: Accept mode (\"save\" or \"load\") file_mode: File mode (\"existing_files\", \"existing_file\", \"any_file\", or \"directory\") root: Root path parent: parent widget \"\"\" super () . __init__ ( parent ) self . path : Optional [ pathlib . Path ] = None self . extensions = extensions self . mode : widgets . filedialog . AcceptModeStr = mode self . file_mode : widgets . filedialog . FileModeStr = file_mode self . root = root layout = widgets . BoxLayout ( \"horizontal\" , self ) layout . set_margin ( 0 ) self . lineedit = widgets . LineEdit () self . lineedit . set_read_only () layout . add ( self . lineedit ) action = widgets . Action () if self . file_mode == \"directory\" : action . set_icon ( \"mdi.folder-outline\" ) else : action . set_icon ( \"mdi.file-outline\" ) action . triggered . connect ( self . open_file ) self . button = widgets . ToolButton () self . button . setDefaultAction ( action ) layout . add ( self . button )","title":"__init__()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout","text":"","title":"flowlayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout","text":"","title":"FlowLayout"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.addItem","text":"addItem(self, QLayoutItem) Source code in prettyqt/custom_widgets/flowlayout.py def addItem ( self , item : QtWidgets . QLayoutItem ): self . items . append ( item )","title":"addItem()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.count","text":"count(self) -> int Source code in prettyqt/custom_widgets/flowlayout.py def count ( self ) -> int : return len ( self . items )","title":"count()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.hasHeightForWidth","text":"hasHeightForWidth(self) -> bool Source code in prettyqt/custom_widgets/flowlayout.py def hasHeightForWidth ( self ) -> bool : return True","title":"hasHeightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.heightForWidth","text":"heightForWidth(self, int) -> int Source code in prettyqt/custom_widgets/flowlayout.py def heightForWidth ( self , width : int ) -> int : rect = QtCore . QRect ( 0 , 0 , width , 0 ) return self . do_layout ( rect , True )","title":"heightForWidth()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.itemAt","text":"itemAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def itemAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: # type: ignore if 0 <= index < len ( self . items ): return self . items [ index ] return None","title":"itemAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.minimumSize","text":"minimumSize(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def minimumSize ( self ) -> QtCore . QSize : size = QtCore . QSize () for item in self . items : size = size . expandedTo ( item . minimumSize ()) margin_width = 2 * self . contentsMargins () . top () size += QtCore . QSize ( margin_width , margin_width ) return size","title":"minimumSize()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.setGeometry","text":"setGeometry(self, QRect) Source code in prettyqt/custom_widgets/flowlayout.py def setGeometry ( self , rect : QtCore . QRect ): super () . setGeometry ( rect ) self . do_layout ( rect , False )","title":"setGeometry()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.sizeHint","text":"sizeHint(self) -> QSize Source code in prettyqt/custom_widgets/flowlayout.py def sizeHint ( self ) -> QtCore . QSize : return self . minimumSize ()","title":"sizeHint()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.flowlayout.FlowLayout.takeAt","text":"takeAt(self, int) -> QLayoutItem Source code in prettyqt/custom_widgets/flowlayout.py def takeAt ( self , index : int ) -> Optional [ QtWidgets . QLayoutItem ]: # type: ignore if 0 <= index < len ( self . items ): return self . items . pop ( index ) return None","title":"takeAt()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser","text":"","title":"iconbrowser"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconBrowser","text":"A small browser window that allows the user to search through all icons. You can also copy the name and python code for the currently selected icon.","title":"IconBrowser"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconListView","text":"A QListView that scales its grid size to always show same amount of items.","title":"IconListView"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconListView.resizeEvent","text":"Re-calculate the grid size to provide scaling icons. Source code in prettyqt/custom_widgets/iconbrowser.py def resizeEvent ( self , event ): \"\"\"Re-calculate the grid size to provide scaling icons.\"\"\" width = self . viewport () . width () - 30 # The minus 30 above ensures we don't end up with an item width that # can't be drawn the expected number of times across the view without # being wrapped. Without this, the view can flicker during resize tile_width = int ( width / self . VIEW_COLUMNS ) icon_width = int ( tile_width * 0.8 ) self . set_grid_size (( tile_width , tile_width )) self . set_icon_size (( icon_width , icon_width )) return super () . resizeEvent ( event )","title":"resizeEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconModel","text":"","title":"IconModel"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconModel.data","text":"data(self, QModelIndex, int) -> Any Source code in prettyqt/custom_widgets/iconbrowser.py def data ( self , index , role ): if role == constants . DECORATION_ROLE : icon_string = self . data ( index , role = constants . DISPLAY_ROLE ) return iconprovider . _icon ( icon_string , color = self . _icon_color ) return super () . data ( index , role )","title":"data()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconbrowser.IconModel.flags","text":"flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/custom_widgets/iconbrowser.py def flags ( self , index ): return constants . IS_ENABLED | constants . IS_SELECTABLE","title":"flags()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget","text":"","title":"iconwidget"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget","text":"IconWidget gives the ability to display an icon as a widget. if supports the same arguments as icon() for example music_icon = qta.IconWidget('fa5s.music', color='blue', color_active='orange') it also have setIcon() and setIconSize() functions","title":"IconWidget"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.set_icon","text":"Set a new icon(). qtawesome.icon icon to set Source code in prettyqt/custom_widgets/iconwidget.py def set_icon ( self , _icon : QtGui . QIcon ): \"\"\"Set a new icon(). Parameters ---------- _icon: qtawesome.icon icon to set \"\"\" self . _icon = _icon self . setPixmap ( _icon . pixmap ( self . _size ))","title":"set_icon()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.iconwidget.IconWidget.update","text":"update(self) update(self, QRect) update(self, QRegion) update(self, int, int, int, int) Source code in prettyqt/custom_widgets/iconwidget.py def update ( self , * args , ** kwargs ): if self . _icon : self . setPixmap ( self . _icon . pixmap ( self . _size )) return super () . update ( * args , ** kwargs )","title":"update()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider","text":"","title":"labeledslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider","text":"","title":"LabeledSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.labeledslider.LabeledSlider.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/labeledslider.py def paintEvent ( self , e ): super () . paintEvent ( e ) style = self . sl . style () st_slider = widgets . StyleOptionSlider () st_slider . initFrom ( self . sl ) st_slider . orientation = self . sl . orientation () length = style . pixelMetric ( widgets . Style . PM_SliderLength , st_slider , self . sl ) available = style . pixelMetric ( widgets . Style . PM_SliderSpaceAvailable , st_slider , self . sl ) painter = gui . Painter ( self ) for v , v_str in self . levels : # get the size of the label rect = painter . get_text_rect ( v_str ) if self . sl . is_horizontal (): x_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available ) # I assume the offset is half the length of slider, therefore # + length//2 x_loc += length // 2 # left bound of the text = center - half of text width + L_margin left = x_loc - rect . width () // 2 + self . left_margin bottom = self . rect () . bottom () # enlarge margins if clipping if v == self . sl . minimum (): if left <= 0 : self . left_margin = rect . width () // 2 - x_loc self . bottom_margin = max ( self . bottom_margin , rect . height ()) self . adjust_margins () if v == self . sl . maximum () and rect . width () // 2 >= self . right_margin : self . right_margin = rect . width () // 2 self . adjust_margins () else : y_loc = widgets . Style . sliderPositionFromValue ( self . sl . minimum (), self . sl . maximum (), v , available , upsideDown = True ) bottom = y_loc + length // 2 + rect . height () // 2 + self . top_margin - 3 # there is a 3 px offset that I can't attribute to any metric left = self . left_margin - rect . width () if left <= 0 : self . left_margin = rect . width () + 2 self . adjust_margins () painter . drawText ( left , bottom , v_str )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo","text":"","title":"popupinfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo","text":"Dialog overlay to show some info to user.","title":"PopupInfo"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.popupinfo.PopupInfo.show","text":"show(self) Source code in prettyqt/custom_widgets/popupinfo.py def show ( self ): self . hide () screen_geo = gui . GuiApplication . primaryScreen () . geometry () size = self . label . sizeHint () x = ( screen_geo . width () - size . width ()) // 2 y = ( screen_geo . height () - size . height ()) // 2 self . move ( x , y - 200 ) super () . show () self . timer . start ( 2500 )","title":"show()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor","text":"Module containing classes related to the RegEx editor.","title":"regexeditor"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.__main__","text":"This module contains the editor widget implementation.","title":"__main__"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.quick_ref","text":"Contains the quick reference widget.","title":"quick_ref"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.regexeditor.regexeditorwidget","text":"This module contains the editor widget implementation.","title":"regexeditorwidget"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar","text":"","title":"roundprogressbar"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar.RoundProgressBar","text":"","title":"RoundProgressBar"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.roundprogressbar.RoundProgressBar.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/roundprogressbar.py def paintEvent ( self , event : gui . PaintEvent ): outer_radius = min ( self . width (), self . height ()) rect = core . RectF ( 1 , 1 , outer_radius - 2 , outer_radius - 2 ) with gui . Painter ( self ) as painter : painter . use_antialiasing () if self . bar_style != \"line\" : self . _rebuild_data_brush_if_needed () painter . fillRect ( 0 , 0 , outer_radius , outer_radius , self . palette () . window ()) self . _draw_base ( painter , rect ) self . _draw_value ( painter , rect , self . current_value ) inner_rect , inner_radius = self . _calculate_inner_rect ( outer_radius ) self . _draw_inner_background ( painter , inner_rect ) self . _draw_text ( painter , inner_rect , inner_radius , self . current_value )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider","text":"","title":"spanslider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider","text":"","title":"SpanSlider"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseMoveEvent","text":"mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseMoveEvent ( self , event ): if self . lower_pressed != HANDLE_STYLE and self . upper_pressed != HANDLE_STYLE : event . ignore () return opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) m = self . style () . pixelMetric ( widgets . Style . PM_MaximumDragDistance , opt , self ) pixel_pos = self . pick ( event . pos ()) - self . offset new_pos = float ( self . _pixel_pos_to_value ( pixel_pos )) if m >= 0 : r = self . rect () . adjusted ( - m , - m , m , m ) if not r . contains ( event . pos ()): new_pos = self . position # pick the preferred handle on the first movement if self . _first_movement : if self . lower_val == self . upper_val : if new_pos < self . lower_value : self . _swap_controls () self . _first_movement = False else : self . _first_movement = False if self . lower_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = min ( new_pos , self . upper_val ) elif self . movement == \"no_overlap\" : new_pos = min ( new_pos , self . upper_val - 1 ) if self . movement == \"free\" and new_pos > self . upper_val : self . _swap_controls () self . set_upper_pos ( new_pos ) else : # movement \"none\" self . set_lower_pos ( new_pos ) elif self . upper_pressed == HANDLE_STYLE : if self . movement == \"no_crossing\" : new_pos = max ( new_pos , self . lower_value ) elif self . movement == \"no_overlap\" : new_pos = max ( new_pos , self . lower_value + 1 ) if self . movement == \"free\" and new_pos < self . lower_val : self . _swap_controls () self . set_lower_pos ( new_pos ) else : # movement \"none\" self . set_upper_pos ( new_pos ) event . accept ()","title":"mouseMoveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mousePressEvent","text":"mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mousePressEvent ( self , event ): if self . minimum () == self . maximum () or event . buttons () ^ event . button (): event . ignore () return self . upper_pressed = self . _handle_mouse_press ( event . pos (), self . upper_pressed , self . upper_val , \"upper\" ) if self . upper_pressed != HANDLE_STYLE : self . lower_pressed = self . _handle_mouse_press ( event . pos (), self . lower_pressed , self . lower_val , \"lower\" ) self . _first_movement = True event . accept ()","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.mouseReleaseEvent","text":"mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/spanslider.py def mouseReleaseEvent ( self , event ): super () . mouseReleaseEvent ( event ) self . setSliderDown ( False ) self . lower_pressed = self . upper_pressed = widgets . Style . SC_None self . update ()","title":"mouseReleaseEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/spanslider.py def paintEvent ( self , event ): painter = widgets . StylePainter ( self ) # ticks opt = widgets . StyleOptionSlider () self . initStyleOption ( opt ) opt . subControls = widgets . Style . SC_SliderTickmarks painter . draw_complex_control ( \"slider\" , opt ) # groove opt . sliderPosition = 20 opt . sliderValue = 0 opt . subControls = GROOVE_STYLE painter . draw_complex_control ( \"slider\" , opt ) # handle rects opt . sliderPosition = self . lower_pos lr = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) lrv = self . pick ( lr . center ()) opt . sliderPosition = self . upper_pos ur = self . style () . subControlRect ( SLIDER_STYLE , opt , HANDLE_STYLE , self ) urv = self . pick ( ur . center ()) # span minv = min ( lrv , urv ) maxv = max ( lrv , urv ) c = self . style () . subControlRect ( SLIDER_STYLE , opt , GROOVE_STYLE , self ) . center () if self . is_horizontal (): rect = core . Rect ( core . Point ( minv , c . y () - 2 ), core . Point ( maxv , c . y () + 1 )) else : rect = core . Rect ( core . Point ( c . x () - 2 , minv ), core . Point ( c . x () + 1 , maxv )) self . _draw_span ( painter , rect ) # handles if self . last_pressed == \"lower\" : self . draw_handle ( painter , \"upper\" ) self . draw_handle ( painter , \"lower\" ) else : self . draw_handle ( painter , \"lower\" ) self . draw_handle ( painter , \"upper\" )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.set_movement_mode","text":"Set movement mode. Parameters: Name Type Description Default mode Literal['no_crossing', 'no_overlap', 'free'] movement mode for the main window required Exceptions: Type Description ValueError movement mode type does not exist Source code in prettyqt/custom_widgets/spanslider.py def set_movement_mode ( self , mode : MovementModeStr ): \"\"\"Set movement mode. Args: mode: movement mode for the main window Raises: ValueError: movement mode type does not exist \"\"\" if mode not in MOVEMENT_MODE : raise ValueError ( \"Invalid movement mode\" ) self . movement = mode","title":"set_movement_mode()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.spanslider.SpanSlider.trigger_action","text":"Trigger slider action. Source code in prettyqt/custom_widgets/spanslider.py def trigger_action ( self , action : ActionStr , main : bool ): value = 0.0 no = False up = False my_min = self . minimum () my_max = self . maximum () self . _block_tracking = True main_control = main and self . _main_control == \"upper\" alt_control = not main and self . _main_control == \"lower\" is_upper_handle = main_control or alt_control val = self . upper_val if is_upper_handle else self . lower_val if action == \"single_step_add\" : up = is_upper_handle value = clamp ( val + self . singleStep (), my_min , my_max ) elif action == \"single_step_sub\" : up = is_upper_handle value = clamp ( val - self . singleStep (), my_min , my_max ) elif action == \"to_minimum\" : up = is_upper_handle value = my_min elif action == \"to_maximum\" : up = is_upper_handle value = my_max elif action == \"move\" : up = is_upper_handle no = True elif action == \"none\" : no = True if not no and not up : if self . movement == \"no_crossing\" : value = min ( value , self . upper_val ) elif self . movement == \"no_overlap\" : value = min ( value , self . upper_val - 1 ) if self . movement == \"free\" and value > self . upper_val : self . _swap_controls () self . set_upper_pos ( value ) else : self . set_lower_pos ( value ) elif not no : if self . movement == \"no_crossing\" : value = max ( value , self . lower_val ) elif self . movement == \"no_overlap\" : value = max ( value , self . lower_val + 1 ) if self . movement == \"free\" and value < self . lower_val : self . _swap_controls () self . set_lower_pos ( value ) else : self . set_upper_pos ( value ) self . _block_tracking = False self . set_lower_value ( self . lower_pos ) self . set_upper_value ( self . upper_pos )","title":"trigger_action()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline","text":"","title":"timeline"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline","text":"","title":"Timeline"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.enterEvent","text":"enterEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def enterEvent ( self , e ): self . _is_in = True","title":"enterEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.leaveEvent","text":"leaveEvent(self, QEvent) Source code in prettyqt/custom_widgets/timeline.py def leaveEvent ( self , e ): self . _is_in = False self . update ()","title":"leaveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mouseMoveEvent","text":"mouseMoveEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseMoveEvent ( self , e ): self . _position = e . pos () # if mouse is being pressed, update pointer if self . _clicking : x = self . _position . x () self . position_changed . emit ( x ) self . _check_selection ( x ) self . pointer_time_pos = x * self . get_scale () self . update ()","title":"mouseMoveEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mousePressEvent","text":"mousePressEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mousePressEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : x = e . pos () . x () self . position_changed . emit ( x ) self . pointer_time_pos = x * self . get_scale () self . _check_selection ( x ) self . update () self . _clicking = True # Set clicking check to true","title":"mousePressEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.mouseReleaseEvent","text":"mouseReleaseEvent(self, QMouseEvent) Source code in prettyqt/custom_widgets/timeline.py def mouseReleaseEvent ( self , e ): if e . button () == QtCore . Qt . LeftButton : self . _clicking = False # Set clicking check to false","title":"mouseReleaseEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.timeline.Timeline.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/timeline.py def paintEvent ( self , event ): # Draw time scale = self . get_scale () with gui . Painter ( self ) as qp : qp . set_color ( self . text_color ) qp . setFont ( self . text_font ) qp . use_antialiasing () w = 0 while ( w := w + 100 ) <= self . width (): time_string = self . get_time_string ( w * scale ) rect = core . Rect ( w - 50 , 0 , 100 , 100 ) qp . drawText ( rect , QtCore . Qt . AlignHCenter , time_string ) # Draw down line qp . set_pen ( color = PEN_COLOR , width = 5 ) qp . drawLine ( 0 , 40 , self . width (), 40 ) # Draw dash lines point = 0 qp . set_pen ( color = self . text_color ) qp . drawLine ( 0 , 40 , self . width (), 40 ) while point <= self . width (): y2 = 30 if point % 30 != 0 else 20 qp . drawLine ( 3 * point , 40 , 3 * point , y2 ) point += 10 if self . _position is not None and self . _is_in : qp . drawLine ( self . _position . x (), 0 , self . _position . x (), 40 ) poly = gui . Polygon () if self . _position is not None : val = self . pointer_time_pos / self . get_scale () line = core . Line ( val , 40 , val , self . height ()) poly . add_points (( val - 10 , 20 ), ( val + 10 , 20 ), ( val , 40 )) else : line = core . Line ( 0 , 0 , 0 , self . height ()) poly . add_points (( - 10 , 20 ), ( 10 , 20 ), ( 0 , 40 )) # Draw samples t = 0.0 for sample in self . video_samples : scaled_dur = sample . duration / scale scaled_t = t / scale t += sample . duration # Clear clip path with qp . clip_path () as path : rect = core . RectF ( scaled_t , 50 , scaled_dur , 200 ) path . addRoundedRect ( rect , 10 , 10 ) # Draw sample path = gui . PainterPath () qp . set_pen ( color = sample . color ) rect = core . RectF ( scaled_t , 50 , scaled_dur , 50 ) path . addRoundedRect ( rect , 10 , 10 ) sample . start_pos = scaled_t sample . end_pos = scaled_t + scaled_dur qp . fillPath ( path , sample . color ) qp . drawPath ( path ) # Draw preview pictures if sample . picture is None : continue pic_width = sample . picture . size () . width () if pic_width < scaled_dur : width = float ( pic_width ) pic = sample . picture else : width = scaled_dur pic = sample . picture . copy ( 0 , 0 , int ( scaled_dur ), 45 ) with qp . clip_path () as path : rect = core . RectF ( scaled_t , 52.5 , width , 45 ) path . addRoundedRect ( rect , 10 , 10 ) qp . drawPixmap ( int ( scaled_t ), int ( 52.5 ), int ( width ), 45 , pic ) # Clear clip path with qp . clip_path () as path : path . add_rect ( self . rect ()) # Draw pointer qp . set_color ( PEN_COLOR ) qp . set_brush ( PEN_COLOR ) qp . drawPolygon ( poly ) qp . drawLine ( line )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner","text":"The MIT License (MIT). Copyright (c) 2012-2014 Alexander Turkin Copyright (c) 2014 William Hallatt Copyright (c) 2015 Jacob Dawid Copyright (c) 2016 Luca Weiss Copyright (c) 2017 Philipp Temminghoff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"waitingspinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner","text":"","title":"BaseWaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.BaseWaitingSpinner.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): painter = gui . Painter ( self ) painter . fill_rect ( self . rect (), \"transparent\" ) painter . use_antialiasing () if self . _current_counter >= self . _line_num : self . _current_counter = 0 painter . set_pen ( style = \"none\" ) painter . translate ( self . _inner_radius + self . _line_length , self . _inner_radius + self . _line_length ) rect = core . RectF ( 0 , - self . _line_width / 2 , self . _line_length , self . _line_width ) for i in range ( self . _line_num ): with painter . backup_state (): rotate_angle = 360 * i / self . _line_num painter . rotate ( rotate_angle ) painter . translate ( self . _inner_radius , 0 ) distance = self . linecount_distance_from_primary ( i , self . _current_counter , self . _line_num ) color = self . current_line_color ( distance , self . _line_num , self . _trail_fade_percentage , self . _minimum_trail_opacity , self . _color , ) painter . setBrush ( color ) painter . drawRoundedRect ( rect , self . _roundness , self . _roundness , QtCore . Qt . RelativeSize )","title":"paintEvent()"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner","text":"","title":"WaitingSpinner"},{"location":"api/custom_widgets.html#prettyqt.custom_widgets.waitingspinner.WaitingSpinner.paintEvent","text":"paintEvent(self, QPaintEvent) Source code in prettyqt/custom_widgets/waitingspinner.py def paintEvent ( self , event ): self . _update_position () super () . paintEvent ( event )","title":"paintEvent()"},{"location":"api/gui.html","text":"gui module Gui module. Contains QtGui-based classes color Color __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/color.py def __reduce__ ( self ): return type ( self ), ( self . red (), self . green (), self . blue (), self . alpha ()) from_text ( text ) classmethod Create a QColor from specified string. Source code in prettyqt/gui/color.py @classmethod def from_text ( cls , text : str ) -> Color : \"\"\"Create a QColor from specified string.\"\"\" color = cls () if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color colorspace ColorSpace get_primaries ( self ) Return current primaries. Returns: Type Description Literal['custom', 'srgb', 'adobe_rgb', 'dci_p3_d65', 'pro_photo_rgb'] primaries Source code in prettyqt/gui/colorspace.py def get_primaries ( self ) -> PrimariesStr : \"\"\"Return current primaries. Returns: primaries \"\"\" return PRIMARIES . inverse [ self . primaries ()] get_transfer_function ( self ) Return current transfer function. Returns: Type Description Literal['custom', 'linear', 'gamma', 'srgb', 'pro_photo_rgb'] transfer function Source code in prettyqt/gui/colorspace.py def get_transfer_function ( self ) -> TransformFunctionStr : \"\"\"Return current transfer function. Returns: transfer function \"\"\" return TRANSFER_FUNCTION . inverse [ self . transferFunction ()] set_primaries ( self , primaries ) Set primaries. Parameters: Name Type Description Default primaries Literal['custom', 'srgb', 'adobe_rgb', 'dci_p3_d65', 'pro_photo_rgb'] primaries to use required Exceptions: Type Description InvalidParamError primaries do not exist Source code in prettyqt/gui/colorspace.py def set_primaries ( self , primaries : PrimariesStr ): \"\"\"Set primaries. Args: primaries: primaries to use Raises: InvalidParamError: primaries do not exist \"\"\" if primaries not in PRIMARIES : raise InvalidParamError ( primaries , PRIMARIES ) self . setPrimaries ( PRIMARIES [ primaries ]) set_transfer_function ( self , fn , gamma = 0.0 ) Set transfer function. Parameters: Name Type Description Default fn Literal['custom', 'linear', 'gamma', 'srgb', 'pro_photo_rgb'] transfer function to use required Exceptions: Type Description InvalidParamError transfer function do not exist Source code in prettyqt/gui/colorspace.py def set_transfer_function ( self , fn : TransformFunctionStr , gamma : float = 0.0 ): \"\"\"Set transfer function. Args: fn: transfer function to use Raises: InvalidParamError: transfer function do not exist \"\"\" if fn not in TRANSFER_FUNCTION : raise InvalidParamError ( fn , TRANSFER_FUNCTION ) self . setTransferFunction ( TRANSFER_FUNCTION [ fn ], gamma ) cursor Cursor get_shape ( self ) Return current cursor shape. Returns: Type Description Literal['arrow', 'uparrow', 'cross', 'wait', 'caret', 'size_vertical', 'size_horizonal', 'size_topright', 'size_topleft', 'size_all', 'blank', 'split_vertical', 'split_horizontal', 'pointing_hand', 'forbidden', 'open_hand', 'closed_hand', 'whats_this', 'busy', 'drag_move', 'drag_copy', 'drag_link', 'bitmap'] cursor shape Source code in prettyqt/gui/cursor.py def get_shape ( self ) -> constants . CursorShapeStr : \"\"\"Return current cursor shape. Returns: cursor shape \"\"\" return constants . CURSOR_SHAPE . inverse [ self . shape ()] set_shape ( self , shape ) Set cursor shape. Parameters: Name Type Description Default shape Literal['arrow', 'uparrow', 'cross', 'wait', 'caret', 'size_vertical', 'size_horizonal', 'size_topright', 'size_topleft', 'size_all', 'blank', 'split_vertical', 'split_horizontal', 'pointing_hand', 'forbidden', 'open_hand', 'closed_hand', 'whats_this', 'busy', 'drag_move', 'drag_copy', 'drag_link', 'bitmap'] shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/gui/cursor.py def set_shape ( self , shape : constants . CursorShapeStr ): \"\"\"Set cursor shape. Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in constants . CURSOR_SHAPE : raise InvalidParamError ( shape , constants . CURSOR_SHAPE ) self . setShape ( constants . CURSOR_SHAPE [ shape ]) font Font get_capitalization ( self ) Get current font capitalization. Returns: Type Description Literal['mixed_case', 'all_uppercase', 'all_lowercase', 'small_caps', 'capitalize'] current font capitalization Source code in prettyqt/gui/font.py def get_capitalization ( self ) -> CapitalizationStr : \"\"\"Get current font capitalization. Returns: current font capitalization \"\"\" return CAPITALIZATION . inverse [ self . capitalization ()] get_hinting_preference ( self ) Get current hinting preference. Returns: Type Description Literal['default', 'none', 'vertical', 'full'] current hinting preference Source code in prettyqt/gui/font.py def get_hinting_preference ( self ) -> HintingPreferenceStr : \"\"\"Get current hinting preference. Returns: current hinting preference \"\"\" return HINTING_PREFERENCE . inverse [ self . hintingPreference ()] get_letter_spacing_type ( self ) Get current letter spacing type. Returns: Type Description Literal['percentage', 'absolute'] current letter spacing type Source code in prettyqt/gui/font.py def get_letter_spacing_type ( self ) -> SpacingTypeStr : \"\"\"Get current letter spacing type. Returns: current letter spacing type \"\"\" return SPACING_TYPE . inverse [ self . letterSpacingType ()] get_style ( self ) Get current font style. Returns: Type Description Literal['normal', 'italic', 'oblique'] current font style Source code in prettyqt/gui/font.py def get_style ( self ) -> StyleStr : \"\"\"Get current font style. Returns: current font style \"\"\" return STYLE . inverse [ self . style ()] get_weight ( self ) Get current font weight. Returns: Type Description Literal['thin', 'extra_light', 'light', 'normal', 'medium', 'demi_bold', 'bold', 'extra_bold', 'black'] current font weight Source code in prettyqt/gui/font.py def get_weight ( self ) -> WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return WEIGHT . inverse [ self . weight ()] set_capitalization ( self , capitalization ) Set the font capitalization. Parameters: Name Type Description Default capitalization Literal['mixed_case', 'all_uppercase', 'all_lowercase', 'small_caps', 'capitalize'] font capitalization required Exceptions: Type Description InvalidParamError invalid font capitalization Source code in prettyqt/gui/font.py def set_capitalization ( self , capitalization : CapitalizationStr ): \"\"\"Set the font capitalization. Args: capitalization: font capitalization Raises: InvalidParamError: invalid font capitalization \"\"\" if capitalization not in CAPITALIZATION : raise InvalidParamError ( capitalization , CAPITALIZATION ) self . setCapitalization ( CAPITALIZATION [ capitalization ]) set_hinting_preference ( self , preference ) Set the hinting preference. Parameters: Name Type Description Default preference Literal['default', 'none', 'vertical', 'full'] hinting preference required Exceptions: Type Description InvalidParamError invalid hinting preference Source code in prettyqt/gui/font.py def set_hinting_preference ( self , preference : HintingPreferenceStr ): \"\"\"Set the hinting preference. Args: preference: hinting preference Raises: InvalidParamError: invalid hinting preference \"\"\" if preference not in HINTING_PREFERENCE : raise InvalidParamError ( preference , HINTING_PREFERENCE ) self . setHintingPreference ( HINTING_PREFERENCE [ preference ]) set_letter_spacing ( self , typ , spacing ) Set the letter spacing. Parameters: Name Type Description Default typ Literal['percentage', 'absolute'] letter spacing type required spacing float spacing required Exceptions: Type Description InvalidParamError invalid letter spacing type Source code in prettyqt/gui/font.py def set_letter_spacing ( self , typ : SpacingTypeStr , spacing : float ): \"\"\"Set the letter spacing. Args: typ: letter spacing type spacing: spacing Raises: InvalidParamError: invalid letter spacing type \"\"\" if typ not in SPACING_TYPE : raise InvalidParamError ( typ , SPACING_TYPE ) self . setLetterSpacing ( SPACING_TYPE [ typ ], spacing ) set_style ( self , style ) Set the font style. Parameters: Name Type Description Default style Literal['normal', 'italic', 'oblique'] font style required Exceptions: Type Description InvalidParamError invalid font style Source code in prettyqt/gui/font.py def set_style ( self , style : StyleStr ): \"\"\"Set the font style. Args: style: font style Raises: InvalidParamError: invalid font style \"\"\" if style not in STYLE : raise InvalidParamError ( style , STYLE ) self . setStyle ( STYLE [ style ]) set_style_hint ( self , hint ) Set the style hint. Parameters: Name Type Description Default hint Literal['any', 'sans_serif', 'serif', 'typewriter', 'decorative', 'monospace', 'fantasy', 'cursive', 'system'] style hint required Exceptions: Type Description InvalidParamError invalid style hint Source code in prettyqt/gui/font.py def set_style_hint ( self , hint : StyleHintStr ): \"\"\"Set the style hint. Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ]) set_weight ( self , weight ) Set the font weight. Parameters: Name Type Description Default weight Literal['thin', 'extra_light', 'light', 'normal', 'medium', 'demi_bold', 'bold', 'extra_bold', 'black'] font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/font.py def set_weight ( self , weight : WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHT : raise InvalidParamError ( weight , WEIGHT ) self . setWeight ( WEIGHT [ weight ]) gradient Gradient get_coordinate_mode ( self ) Return current coordinate mode. Returns: Type Description Literal['logical', 'object', 'stretch_to_device', 'object_bounding'] coordinate mode Source code in prettyqt/gui/gradient.py def get_coordinate_mode ( self ) -> CoordinateModeStr : \"\"\"Return current coordinate mode. Returns: coordinate mode \"\"\" return COORDINATE_MODE . inverse [ self . coordinateMode ()] get_spread ( self ) Return current spread method. Returns: Type Description Literal['pad', 'repeat', 'reflect'] spread method Source code in prettyqt/gui/gradient.py def get_spread ( self ) -> SpreadStr : \"\"\"Return current spread method. Returns: spread method \"\"\" return SPREAD . inverse [ self . spread ()] get_type ( self ) Return current gradient type. Returns: Type Description Literal['linear', 'radial', 'conical', 'none'] gradient type Source code in prettyqt/gui/gradient.py def get_type ( self ) -> TypeStr : \"\"\"Return current gradient type. Returns: gradient type \"\"\" return TYPE . inverse [ self . type ()] set_coordinate_mode ( self , mode ) Set the coordinate mode. Parameters: Name Type Description Default mode Literal['logical', 'object', 'stretch_to_device', 'object_bounding'] coordinate mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/gradient.py def set_coordinate_mode ( self , mode : CoordinateModeStr ): \"\"\"Set the coordinate mode. Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODE : raise InvalidParamError ( mode , COORDINATE_MODE ) self . setCoordinateMode ( COORDINATE_MODE [ mode ]) set_spread ( self , method ) Set the spread method. Parameters: Name Type Description Default method Literal['pad', 'repeat', 'reflect'] spread method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/gui/gradient.py def set_spread ( self , method : SpreadStr ): \"\"\"Set the spread method. Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREAD : raise InvalidParamError ( method , SPREAD ) self . setSpread ( SPREAD [ method ]) guiapplication GuiApplication copy_to_clipboard ( text ) classmethod Sets clipboard to supplied text. Source code in prettyqt/gui/guiapplication.py @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Clipboard ) cb . setText ( text , mode = cb . Clipboard ) get_application_state () classmethod Get the current application state. Returns: Type Description List[Literal['suspended', 'hidden', 'inactive', 'active']] application state Source code in prettyqt/gui/guiapplication.py @classmethod def get_application_state ( cls ) -> List [ constants . ApplicationStateStr ]: \"\"\"Get the current application state. Returns: application state \"\"\" return [ k for k , v in constants . APPLICATION_STATES . items () if v & cls . applicationState () # type: ignore ] get_high_dpi_scale_factor_rounding_policy () classmethod Get the current high dpi scale factor rounding policy. Returns: Type Description Literal['round', 'ceil', 'floor', 'round_prefer_floor', 'pass_through'] rounding policy Source code in prettyqt/gui/guiapplication.py @classmethod def get_high_dpi_scale_factor_rounding_policy ( cls , ) -> constants . HighDpiScaleFactorRoundingPolicyStr : \"\"\"Get the current high dpi scale factor rounding policy. Returns: rounding policy \"\"\" return constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY . inverse [ cls . highDpiScaleFactorRoundingPolicy () ] get_layout_direction ( self ) Get the current layout direction. Returns: Type Description Literal['left_to_right', 'right_to_left', 'auto'] layout direction Source code in prettyqt/gui/guiapplication.py def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()] set_high_dpi_scale_factor_rounding_policy ( policy ) classmethod Set high dpi scale factor rounding policy. Parameters: Name Type Description Default direction rounding policy required Exceptions: Type Description InvalidParamError rounding policy does not exist Source code in prettyqt/gui/guiapplication.py @classmethod def set_high_dpi_scale_factor_rounding_policy ( cls , policy : constants . HighDpiScaleFactorRoundingPolicyStr ): \"\"\"Set high dpi scale factor rounding policy. Args: direction: rounding policy Raises: InvalidParamError: rounding policy does not exist \"\"\" if policy not in constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY : raise InvalidParamError ( policy , constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY ) cls . setHighDpiScaleFactorRoundingPolicy ( constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY [ policy ] ) set_icon ( self , icon ) Set the default window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/gui/guiapplication.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) set_layout_direction ( self , direction ) Set layout direction. Parameters: Name Type Description Default direction Literal['left_to_right', 'right_to_left', 'auto'] layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/guiapplication.py def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ]) imageiohandler ImageIOHandler get_option ( self , option ) Return the value assigned to option. Parameters: Name Type Description Default option Literal['size', 'clip_rect', 'scaled_size', 'scaled_clip_rect', 'description', 'compression_ratio', 'gamma', 'quality', 'name', 'subtype', 'incremental_reading', 'endianness', 'animation', 'background_color', 'supported_sub_types', 'optimized_write', 'progressive_scan_write', 'image_transformation'] option to get required Returns: Type Description Any option Source code in prettyqt/gui/imageiohandler.py def get_option ( self , option : ImageOptionStr ) -> Any : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . option ( IMAGE_OPTION [ option ]) set_option ( self , option , value ) Set option to given value. Parameters: Name Type Description Default option Literal['size', 'clip_rect', 'scaled_size', 'scaled_clip_rect', 'description', 'compression_ratio', 'gamma', 'quality', 'name', 'subtype', 'incremental_reading', 'endianness', 'animation', 'background_color', 'supported_sub_types', 'optimized_write', 'progressive_scan_write', 'image_transformation'] option to use required value value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/gui/imageiohandler.py def set_option ( self , option : ImageOptionStr , value ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) self . setOption ( IMAGE_OPTION [ option ], value ) supports_option ( self , option ) Return whether the image handler supports given option. Parameters: Name Type Description Default option Literal['size', 'clip_rect', 'scaled_size', 'scaled_clip_rect', 'description', 'compression_ratio', 'gamma', 'quality', 'name', 'subtype', 'incremental_reading', 'endianness', 'animation', 'background_color', 'supported_sub_types', 'optimized_write', 'progressive_scan_write', 'image_transformation'] option to check required Returns: Type Description bool option Source code in prettyqt/gui/imageiohandler.py def supports_option ( self , option : ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . supportsOption ( IMAGE_OPTION [ option ]) imagereader ImageReader get_error ( self ) Return error type. Returns: Type Description Literal['file_not_found', 'device', 'unsupported_format', 'invalid_data', 'unknown'] error type Source code in prettyqt/gui/imagereader.py def get_error ( self ) -> ImageReaderErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_READER_ERROR . inverse [ self . error ()] get_transformation ( self ) Return the transformation and orientation the image has been set to. Returns: Type Description Literal['none', 'mirror', 'flip', 'rotate_180', 'roate_90', 'mirror_and_rotate_90', 'flip_and_rotate_90', 'rotate_270'] transformation Source code in prettyqt/gui/imagereader.py def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()] supports_option ( self , option ) Return whether the image handler supports given option. Parameters: Name Type Description Default option Literal['size', 'clip_rect', 'scaled_size', 'scaled_clip_rect', 'description', 'compression_ratio', 'gamma', 'quality', 'name', 'subtype', 'incremental_reading', 'endianness', 'animation', 'background_color', 'supported_sub_types', 'optimized_write', 'progressive_scan_write', 'image_transformation'] option to check required Returns: Type Description bool option Source code in prettyqt/gui/imagereader.py def supports_option ( self , option : gui . imageiohandler . ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in gui . imageiohandler . IMAGE_OPTION : raise InvalidParamError ( option , gui . imageiohandler . IMAGE_OPTION ) return self . supportsOption ( gui . imageiohandler . IMAGE_OPTION [ option ]) imagewriter ImageWriter get_error ( self ) Return error type. Returns: Type Description Literal['device', 'unsupported_format', 'invalid_image', 'unknown'] error type Source code in prettyqt/gui/imagewriter.py def get_error ( self ) -> ImageWriterErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_WRITER_ERROR . inverse [ self . error ()] get_transformation ( self ) Return the transformation and orientation the image has been set to. Returns: Type Description Literal['none', 'mirror', 'flip', 'rotate_180', 'roate_90', 'mirror_and_rotate_90', 'flip_and_rotate_90', 'rotate_270'] transformation Source code in prettyqt/gui/imagewriter.py def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()] set_transformation ( self , origin ) Set the image transformations metadata including orientation. Parameters: Name Type Description Default origin Literal['none', 'mirror', 'flip', 'rotate_180', 'roate_90', 'mirror_and_rotate_90', 'flip_and_rotate_90', 'rotate_270'] transformation to use required Exceptions: Type Description InvalidParamError transformation does not exist Source code in prettyqt/gui/imagewriter.py def set_transformation ( self , origin : gui . imageiohandler . TransformationStr ): \"\"\"Set the image transformations metadata including orientation. Args: origin: transformation to use Raises: InvalidParamError: transformation does not exist \"\"\" if origin not in gui . imageiohandler . TRANSFORMATION : raise InvalidParamError ( origin , gui . imageiohandler . TRANSFORMATION ) self . setTransformation ( gui . imageiohandler . TRANSFORMATION [ origin ]) keysequence KeySequence __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/keysequence.py def __reduce__ ( self ): return type ( self ), ( self . toString (),) movie Movie get_cache_mode ( self ) Get the current cache mode. Returns: Type Description Literal['none', 'all'] cache mode Source code in prettyqt/gui/movie.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Get the current cache mode. Returns: cache mode \"\"\" return CACHE_MODE . inverse [ self . cacheMode ()] get_state ( self ) Get the current state. Returns: Type Description Literal['not_running', 'paused', 'running'] state Source code in prettyqt/gui/movie.py def get_state ( self ) -> MovieStateStr : \"\"\"Get the current state. Returns: state \"\"\" return MOVIE_STATE . inverse [ self . state ()] set_cache_mode ( self , mode ) Set cache mode. Parameters: Name Type Description Default mode Literal['none', 'all'] cache mode required Exceptions: Type Description InvalidParamError cache mode does not exist Source code in prettyqt/gui/movie.py def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set cache mode. Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODE : raise InvalidParamError ( mode , CACHE_MODE ) self . setCacheMode ( CACHE_MODE [ mode ]) pagelayout PageLayout get_mode ( self ) Get the current mode. Returns: Type Description Literal['standard', 'full_page'] mode Source code in prettyqt/gui/pagelayout.py def get_mode ( self ) -> ModeStr : \"\"\"Get the current mode. Returns: mode \"\"\" return MODES . inverse [ self . mode ()] get_orientation ( self ) Get the current orientation. Returns: Type Description Literal['portrait', 'landscape'] orientation Source code in prettyqt/gui/pagelayout.py def get_orientation ( self ) -> OrientationStr : \"\"\"Get the current orientation. Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()] get_units ( self ) Get the current unit. Returns: Type Description Literal['millimeter', 'point', 'inch', 'pica', 'didot', 'cicero'] unit Source code in prettyqt/gui/pagelayout.py def get_units ( self ) -> UnitStr : \"\"\"Get the current unit. Returns: unit \"\"\" return UNITS . inverse [ self . units ()] set_mode ( self , mode ) Set mode. Parameters: Name Type Description Default mode Literal['standard', 'full_page'] mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/pagelayout.py def set_mode ( self , mode : ModeStr ): \"\"\"Set mode. Args: mode: mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setMode ( MODES [ mode ]) set_orientation ( self , orientation ) Set orientation. Parameters: Name Type Description Default orientation Literal['portrait', 'landscape'] orientation required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/gui/pagelayout.py def set_orientation ( self , orientation : OrientationStr ): \"\"\"Set orientation. Args: orientation: orientation Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ]) set_units ( self , unit ) Set unit. Parameters: Name Type Description Default unit Literal['millimeter', 'point', 'inch', 'pica', 'didot', 'cicero'] unit required Exceptions: Type Description InvalidParamError unit does not exist Source code in prettyqt/gui/pagelayout.py def set_units ( self , unit : UnitStr ): \"\"\"Set unit. Args: unit: unit Raises: InvalidParamError: unit does not exist \"\"\" if unit not in UNITS : raise InvalidParamError ( unit , UNITS ) self . setUnits ( UNITS [ unit ]) pagesize PageSize get_definition_units ( self ) Get the definition unit. Returns: Type Description Literal['millimeter', 'point', 'inch', 'pica', 'didot', 'cicero'] unit Source code in prettyqt/gui/pagesize.py def get_definition_units ( self ) -> UnitStr : \"\"\"Get the definition unit. Returns: unit \"\"\" units = self . definitionUnits () if units == - 1 : raise ValueError ( \"Invalid page size\" ) return UNITS . inverse [ units ] get_id ( self ) Get the standard page size id. Returns: Type Description str page size id Source code in prettyqt/gui/pagesize.py def get_id ( self ) -> str : \"\"\"Get the standard page size id. Returns: page size id \"\"\" return PAGE_SIZE_ID . inverse [ self . id ()] paintdevice PaintDevice get_metric ( self , metric ) Return metric information. Parameters: Name Type Description Default metric Literal['width', 'height', 'width_mm', 'height_mm', 'num_colors', 'depth', 'dpi_x', 'dpi_y', 'physical_dpi_x', 'physical_dpi_y', 'pixel_ratio', 'pixel_ratio_scaled'] metric information to get required Returns: Type Description int metric information Source code in prettyqt/gui/paintdevice.py def get_metric ( self , metric : MetricStr ) -> int : \"\"\"Return metric information. Args: metric: metric information to get Returns: metric information \"\"\" if metric not in METRICS : raise InvalidParamError ( metric , METRICS ) return self . metric ( METRICS [ metric ]) painter Painter get_composition_mode ( self ) Get the current composition mode. Returns: Type Description Literal['source_over', 'destination_over', 'clear', 'source', 'destination', 'source_in', 'destination_in', 'source_out', 'destination_out', 'source_atop', 'destination_atop'] composition mode Source code in prettyqt/gui/painter.py def get_composition_mode ( self ) -> CompositionModeStr : \"\"\"Get the current composition mode. Returns: composition mode \"\"\" return COMPOSITION_MODE . inverse [ self . compositionMode ()] get_pen ( self ) Return current pen. Returns: Type Description Pen current pen Source code in prettyqt/gui/painter.py def get_pen ( self ) -> gui . Pen : \"\"\"Return current pen. Returns: current pen \"\"\" return gui . Pen ( self . pen ()) set_composition_mode ( self , mode ) Set the current composition mode. Exceptions: Type Description InvalidParamError composition mode does not exist Source code in prettyqt/gui/painter.py def set_composition_mode ( self , mode : CompositionModeStr ): \"\"\"Set the current composition mode. Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMPOSITION_MODE : raise InvalidParamError ( mode , COMPOSITION_MODE ) self . setCompositionMode ( COMPOSITION_MODE [ mode ]) set_pen ( self , style = 'solid' , width = 1.0 , color = 'black' , join_style = 'bevel' , cap_style = 'square' ) Set pen to use. Parameters: Name Type Description Default style Literal['none', 'solid', 'dash', 'dot', 'dash_dot', 'dash_dot_dot', 'custom_dash'] pen style to use 'solid' width float pen width 1.0 color Union[str, int, PyQt5.QtCore.Qt.GlobalColor, PyQt5.QtGui.QColor, tuple] pen color 'black' join_style Literal['miter', 'bevel', 'roundsvg_miter'] pen join style to use 'bevel' cap_style Literal['flat', 'square', 'round'] pen cap style to use 'square' Source code in prettyqt/gui/painter.py def set_pen ( self , style : constants . PenStyleStr = \"solid\" , width : float = 1.0 , color : colors . ColorType = \"black\" , join_style : constants . JoinStyleStr = \"bevel\" , cap_style : constants . CapStyleStr = \"square\" , ): \"\"\"Set pen to use. Args: style: pen style to use width: pen width color: pen color join_style: pen join style to use cap_style: pen cap style to use \"\"\" pen = gui . Pen () pen . set_style ( style ) pen . set_cap_style ( cap_style ) pen . set_join_style ( join_style ) pen . setWidthF ( width ) pen . set_color ( color ) self . setPen ( pen ) painterpath PainterPath get_fill_rule ( self ) Return current fill rule. Returns: Type Description constants.FillRuleStr fill rule Source code in prettyqt/gui/painterpath.py def get_fill_rule ( self ) -> constants . FillRuleStr : \"\"\"Return current fill rule. Returns: fill rule \"\"\" return constants . FILL_RULE . inverse [ self . fillRule ()] set_fill_rule ( self , rule ) Set fill rule. Parameters: Name Type Description Default rule constants.FillRuleStr fill rule to use required Exceptions: Type Description InvalidParamError fill rule does not exist Source code in prettyqt/gui/painterpath.py def set_fill_rule ( self , rule : constants . FillRuleStr ): \"\"\"Set fill rule. Args: rule: fill rule to use Raises: InvalidParamError: fill rule does not exist \"\"\" if rule not in constants . FILL_RULE : raise InvalidParamError ( rule , constants . FILL_RULE ) self . setFillRule ( constants . FILL_RULE [ rule ]) painterpathstroker PainterPathStroker get_cap_style ( self ) Return current cap style. Returns: Type Description Literal['flat', 'square', 'round'] cap style Source code in prettyqt/gui/painterpathstroker.py def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()] get_join_style ( self ) Return current join style. Returns: Type Description Literal['miter', 'bevel', 'roundsvg_miter'] join style Source code in prettyqt/gui/painterpathstroker.py def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()] set_cap_style ( self , style ) Set cap style to use. Parameters: Name Type Description Default style Literal['flat', 'square', 'round'] cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ]) set_join_style ( self , style ) Set join style to use. Parameters: Name Type Description Default style Literal['miter', 'bevel', 'roundsvg_miter'] join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ]) palette Palette get_color_group ( self ) Return color group. Returns: Type Description Literal['disabled', 'active', 'inactive'] color group Source code in prettyqt/gui/palette.py def get_color_group ( self ) -> GroupStr : \"\"\"Return color group. Returns: color group \"\"\" return GROUP . inverse [ self . colorGroup ()] set_color_group ( self , group , * args , ** kwargs ) Set the color group. Parameters: Name Type Description Default group Literal['disabled', 'active', 'inactive'] color group to use required Exceptions: Type Description InvalidParamError invalid color group Source code in prettyqt/gui/palette.py def set_color_group ( self , group : GroupStr , * args , ** kwargs ): \"\"\"Set the color group. Args: group: color group to use Raises: InvalidParamError: invalid color group \"\"\" if group not in GROUP : raise InvalidParamError ( group , GROUP ) self . setColorGroup ( GROUP [ group ], * args , ** kwargs ) pen Pen get_cap_style ( self ) Return current cap style. Returns: Type Description Literal['flat', 'square', 'round'] cap style Source code in prettyqt/gui/pen.py def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()] get_join_style ( self ) Return current join style. Returns: Type Description Literal['miter', 'bevel', 'roundsvg_miter'] join style Source code in prettyqt/gui/pen.py def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()] get_style ( self ) Return current pen style. Returns: Type Description Literal['none', 'solid', 'dash', 'dot', 'dash_dot', 'dash_dot_dot', 'custom_dash'] pen style Source code in prettyqt/gui/pen.py def get_style ( self ) -> constants . PenStyleStr : \"\"\"Return current pen style. Returns: pen style \"\"\" return constants . PEN_STYLE . inverse [ self . style ()] set_cap_style ( self , style ) Set cap style to use. Parameters: Name Type Description Default style Literal['flat', 'square', 'round'] cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/pen.py def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ]) set_join_style ( self , style ) Set join style to use. Parameters: Name Type Description Default style Literal['miter', 'bevel', 'roundsvg_miter'] join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/pen.py def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ]) set_style ( self , style ) Set pen style to use. Parameters: Name Type Description Default style Literal['none', 'solid', 'dash', 'dot', 'dash_dot', 'dash_dot_dot', 'custom_dash'] pen style to use required Exceptions: Type Description InvalidParamError pen style does not exist Source code in prettyqt/gui/pen.py def set_style ( self , style : constants . PenStyleStr ): \"\"\"Set pen style to use. Args: style: pen style to use Raises: InvalidParamError: pen style does not exist \"\"\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setStyle ( constants . PEN_STYLE [ style ]) polygon Polygon __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/polygon.py def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () sessionmanager SessionManager get_restart_hint ( self ) Return current restart hint. Returns: Type Description Literal['if_running', 'anyway', 'immediately', 'never'] restart hint Source code in prettyqt/gui/sessionmanager.py def get_restart_hint ( self ) -> RestartHintStr : \"\"\"Return current restart hint. Returns: restart hint \"\"\" return RESTART_HINT . inverse [ self . restartHint ()] set_restart_hint ( self , style ) Set the restart hint. Parameters: Name Type Description Default style Literal['if_running', 'anyway', 'immediately', 'never'] restart hint required Exceptions: Type Description InvalidParamError restart hint does not exist Source code in prettyqt/gui/sessionmanager.py def set_restart_hint ( self , style : RestartHintStr ): \"\"\"Set the restart hint. Args: style: restart hint Raises: InvalidParamError: restart hint does not exist \"\"\" if style not in RESTART_HINT : raise InvalidParamError ( style , RESTART_HINT ) self . setRestartHint ( RESTART_HINT [ style ]) standarditem StandardItem clone ( self ) clone(self) -> QStandardItem Source code in prettyqt/gui/standarditem.py def clone ( self ): item = type ( self )() core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item get_checkstate ( self ) Return checkstate. Returns: Type Description constants.StateStr checkstate Source code in prettyqt/gui/standarditem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] set_checkstate ( self , state ) Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/gui/standarditem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon iconprovider.IconType icon to use required Source code in prettyqt/gui/standarditem.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) statictext StaticText get_performance_hint ( self ) Return current performance hint. Returns: Type Description Literal['moderate', 'aggressive'] performance hint Source code in prettyqt/gui/statictext.py def get_performance_hint ( self ) -> PerformanceHintStr : \"\"\"Return current performance hint. Returns: performance hint \"\"\" return PERFORMANCE_HINT . inverse [ self . performanceHint ()] get_text_format ( self ) Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str text format Source code in prettyqt/gui/statictext.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] set_performance_hint ( self , hint ) Set the performance hint. Parameters: Name Type Description Default hint Literal['moderate', 'aggressive'] performance hint to use required Exceptions: Type Description InvalidParamError performance hint does not exist Source code in prettyqt/gui/statictext.py def set_performance_hint ( self , hint : PerformanceHintStr ): \"\"\"Set the performance hint. Args: hint: performance hint to use Raises: InvalidParamError: performance hint does not exist \"\"\" if hint not in PERFORMANCE_HINT : raise InvalidParamError ( hint , PERFORMANCE_HINT ) self . setPerformanceHint ( PERFORMANCE_HINT [ hint ]) set_text_format ( self , text_format ) Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/gui/statictext.py def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) surface Surface get_surface_class ( self ) Get the current surface class. Returns: Type Description Literal['window', 'offscreen'] surface class Source code in prettyqt/gui/surface.py def get_surface_class ( self ) -> SurfaceClassStr : \"\"\"Get the current surface class. Returns: surface class \"\"\" return SURFACE_CLASS . inverse [ self . surfaceClass ()] get_surface_type ( self ) Get the current surface type. Returns: Type Description Literal['raster', 'open_gl', 'raster_gl', 'open_vg', 'vulkan', 'metal'] surface type Source code in prettyqt/gui/surface.py def get_surface_type ( self ) -> SurfaceTypeStr : \"\"\"Get the current surface type. Returns: surface type \"\"\" return SURFACE_TYPES . inverse [ self . surfaceType ()] syntaxhighlighter SyntaxHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt ) textblockuserdata TextBlockUserData Storage for the user data associated with each line. textcharformat TextCharFormat get_font_weight ( self ) Get current font weight. Returns: Type Description Literal['thin', 'extra_light', 'light', 'normal', 'medium', 'demi_bold', 'bold', 'extra_bold', 'black'] current font weight Source code in prettyqt/gui/textcharformat.py def get_font_weight ( self ) -> gui . font . WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return gui . font . WEIGHT . inverse [ self . fontWeight ()] get_underline_style ( self ) Get current underline style. Returns: Type Description Literal['none', 'single', 'dash', 'dot', 'dashdot', 'dashdotline', 'wave', 'spellcheck'] current underline style Source code in prettyqt/gui/textcharformat.py def get_underline_style ( self ) -> UnderlineStyleStr : \"\"\"Get current underline style. Returns: current underline style \"\"\" return UNDERLINE_STYLE . inverse [ self . underlineStyle ()] get_vertical_alignment ( self ) Get current vertical alignment. Returns: Type Description Literal['normal', 'super_script', 'sub_script', 'middle', 'bottom', 'top', 'baseline'] current vertical alignment Source code in prettyqt/gui/textcharformat.py def get_vertical_alignment ( self ) -> VerticalAlignmentStr : \"\"\"Get current vertical alignment. Returns: current vertical alignment \"\"\" return VERTICAL_ALIGNMENT . inverse [ self . verticalAlignment ()] set_font_style_hint ( self , hint ) Set the font style hint. Parameters: Name Type Description Default hint Literal['any', 'sans_serif', 'serif', 'typewriter', 'decorative', 'monospace', 'fantasy', 'cursive', 'system'] font style hint required Exceptions: Type Description InvalidParamError invalid font style hint Source code in prettyqt/gui/textcharformat.py def set_font_style_hint ( self , hint : gui . font . StyleHintStr ): \"\"\"Set the font style hint. Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in gui . font . STYLE_HINTS : raise InvalidParamError ( hint , gui . font . STYLE_HINTS ) self . setFontStyleHint ( gui . font . STYLE_HINTS [ hint ]) set_font_weight ( self , weight ) Set the font weight. Parameters: Name Type Description Default weight Literal['thin', 'extra_light', 'light', 'normal', 'medium', 'demi_bold', 'bold', 'extra_bold', 'black'] font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/textcharformat.py def set_font_weight ( self , weight : gui . font . WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) self . setFontWeight ( gui . font . WEIGHT [ weight ]) set_underline_style ( self , style ) Set the underline style. Parameters: Name Type Description Default style Literal['none', 'single', 'dash', 'dot', 'dashdot', 'dashdotline', 'wave', 'spellcheck'] underline style required Exceptions: Type Description InvalidParamError invalid underline style Source code in prettyqt/gui/textcharformat.py def set_underline_style ( self , style : UnderlineStyleStr ): \"\"\"Set the underline style. Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLE : raise InvalidParamError ( style , UNDERLINE_STYLE ) self . setUnderlineStyle ( UNDERLINE_STYLE [ style ]) set_vertical_alignment ( self , alignment ) Set the vertical alignment. Parameters: Name Type Description Default alignment Literal['normal', 'super_script', 'sub_script', 'middle', 'bottom', 'top', 'baseline'] vertical alignment required Exceptions: Type Description InvalidParamError invalid vertical alignment Source code in prettyqt/gui/textcharformat.py def set_vertical_alignment ( self , alignment : VerticalAlignmentStr ): \"\"\"Set the vertical alignment. Args: alignment: vertical alignment Raises: InvalidParamError: invalid vertical alignment \"\"\" if alignment not in VERTICAL_ALIGNMENT : raise InvalidParamError ( alignment , VERTICAL_ALIGNMENT ) self . setVerticalAlignment ( VERTICAL_ALIGNMENT [ alignment ]) textcursor TextCursor edit_block ( self ) Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock () select ( self , selection ) select(self, QTextCursor.SelectionType) Source code in prettyqt/gui/textcursor.py def select ( self , selection : Union [ SelectionTypeStr , QtGui . QTextCursor . SelectionType ]): if isinstance ( selection , QtGui . QTextCursor . SelectionType ): sel = selection else : sel = SELECTION_TYPE [ selection ] super () . select ( sel ) select_text ( self , start_pos , end_pos ) Select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos Union[int, Literal['no_move', 'start', 'start_of_line', 'start_of_block', 'start_of_word', 'previous_block', 'previous_char', 'previous_word', 'up', 'left', 'word_left', 'end', 'end_of_line', 'end_of_word', 'end_of_block', 'next_block', 'next_char', 'next_word', 'down', 'right', 'word_right', 'next_cell', 'previous_cell', 'next_row', 'previous_row']] Start position required end_pos Union[int, Literal['no_move', 'start', 'start_of_line', 'start_of_block', 'start_of_word', 'previous_block', 'previous_char', 'previous_word', 'up', 'left', 'word_left', 'end', 'end_of_line', 'end_of_word', 'end_of_block', 'next_block', 'next_char', 'next_word', 'down', 'right', 'word_right', 'next_cell', 'previous_cell', 'next_row', 'previous_row']] End position required Source code in prettyqt/gui/textcursor.py def select_text ( self , start_pos : Union [ int , MoveOperationStr ], end_pos : Union [ int , MoveOperationStr ], ) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText () set_position ( self , pos , mode = 'move' ) Set cursor to given position. Parameters: Name Type Description Default pos int Cursor position required mode Literal['move', 'keep'] Move mode 'move' Source code in prettyqt/gui/textcursor.py def set_position ( self , pos : int , mode : MoveModeStr = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODE [ mode ]) textdocument TextDocument clear_stacks ( self , stack ) Clear undo / redo stack. Parameters: Name Type Description Default stack Literal['undo', 'redo', 'undo_and_redo'] stack to clear required Exceptions: Type Description InvalidParamError stack type does not exist Source code in prettyqt/gui/textdocument.py def clear_stacks ( self , stack : StackStr ): \"\"\"Clear undo / redo stack. Args: stack: stack to clear Raises: InvalidParamError: stack type does not exist \"\"\" if stack not in STACKS : raise InvalidParamError ( stack , STACKS ) self . clearUndoRedoStacks ( STACKS [ stack ]) get_default_cursor_move_style ( self ) Return current cursor move style. Returns: Type Description Literal['logical', 'visual'] cursor move style Source code in prettyqt/gui/textdocument.py def get_default_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return current cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . defaultCursorMoveStyle ()] set_default_cursor_move_style ( self , style ) Set the cursor move style. Parameters: Name Type Description Default style Literal['logical', 'visual'] cursor move style required Exceptions: Type Description InvalidParamError cursor move style does not exist Source code in prettyqt/gui/textdocument.py def set_default_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set the cursor move style. Args: style: cursor move style Raises: InvalidParamError: cursor move style does not exist \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setDefaultCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ]) textformat TextFormat get_layout_direction ( self ) Get the current layout direction. Returns: Type Description Literal['left_to_right', 'right_to_left', 'auto'] layout direction Source code in prettyqt/gui/textformat.py def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()] set_layout_direction ( self , direction ) Set layout direction. Parameters: Name Type Description Default direction Literal['left_to_right', 'right_to_left', 'auto'] layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/textformat.py def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ]) textframeformat TextFrameFormat get_border_style ( self ) Get the current border style. Returns: Type Description Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] border style Source code in prettyqt/gui/textframeformat.py def get_border_style ( self ) -> BorderStyleStr : \"\"\"Get the current border style. Returns: border style \"\"\" return BORDER_STYLES . inverse [ self . borderStyle ()] get_page_break_policy ( self ) Get the current page break policy. Returns: Type Description Literal['auto', 'always_before', 'always_after'] page break policy Source code in prettyqt/gui/textframeformat.py def get_page_break_policy ( self ) -> gui . textformat . PageBreakFlagStr : \"\"\"Get the current page break policy. Returns: page break policy \"\"\" return gui . textformat . PAGE_BREAK_FLAG . inverse [ self . pageBreakPolicy ()] get_position ( self ) Get the current position. Returns: Type Description Literal['in_flow', 'flow_right', 'flow_left'] position Source code in prettyqt/gui/textframeformat.py def get_position ( self ) -> PositionStr : \"\"\"Get the current position. Returns: position \"\"\" return POSITIONS . inverse [ self . position ()] set_border_style ( self , style ) Set border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/textframeformat.py def set_border_style ( self , style : BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in BORDER_STYLES : raise InvalidParamError ( style , BORDER_STYLES ) self . setBorderStyle ( BORDER_STYLES [ style ]) set_page_break_policy ( self , policy ) Set page break policy. Parameters: Name Type Description Default policy Literal['auto', 'always_before', 'always_after'] page break policy required Exceptions: Type Description InvalidParamError page break policy does not exist Source code in prettyqt/gui/textframeformat.py def set_page_break_policy ( self , policy : gui . textformat . PageBreakFlagStr ): \"\"\"Set page break policy. Args: policy: page break policy Raises: InvalidParamError: page break policy does not exist \"\"\" if policy not in gui . textformat . PAGE_BREAK_FLAG : raise InvalidParamError ( policy , gui . textformat . PAGE_BREAK_FLAG ) self . setPageBreakPolicy ( gui . textformat . PAGE_BREAK_FLAG [ policy ]) set_position ( self , position ) Set position. Parameters: Name Type Description Default position Literal['in_flow', 'flow_right', 'flow_left'] position required Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/gui/textframeformat.py def set_position ( self , position : PositionStr ): \"\"\"Set position. Args: position: position Raises: InvalidParamError: position does not exist \"\"\" if position not in POSITIONS : raise InvalidParamError ( position , POSITIONS ) self . setPosition ( POSITIONS [ position ]) textlength TextLength get_type ( self ) Return type of this length object. Returns: Type Description Literal['variable', 'fixed', 'percentage'] timer type Source code in prettyqt/gui/textlength.py def get_type ( self ) -> TypeStr : \"\"\"Return type of this length object. Returns: timer type \"\"\" return TYPES . inverse [ self . type ()] textlistformat TextListFormat get_style ( self ) Get current style. Returns: Type Description Literal['disc', 'circle', 'square', 'decimal', 'lower_alpha', 'upper_alpha', 'lower_roman', 'upper_roman'] current style Source code in prettyqt/gui/textlistformat.py def get_style ( self ) -> StyleStr : \"\"\"Get current style. Returns: current style \"\"\" return STYLES . inverse [ self . style ()] set_style ( self , style ) Set the style. Parameters: Name Type Description Default style Literal['disc', 'circle', 'square', 'decimal', 'lower_alpha', 'upper_alpha', 'lower_roman', 'upper_roman'] style required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/gui/textlistformat.py def set_style ( self , style : StyleStr ): \"\"\"Set the style. Args: style: style Raises: InvalidParamError: invalid style \"\"\" if style not in STYLES : raise InvalidParamError ( style , STYLES ) self . setStyle ( STYLES [ style ]) texttablecellformat TextTableCellFormat get_bottom_border_style ( self ) Get the current bottom border style. Returns: Type Description Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] bottom border style Source code in prettyqt/gui/texttablecellformat.py def get_bottom_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current bottom border style. Returns: bottom border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . bottomBorderStyle ()] get_left_border_style ( self ) Get the current left border style. Returns: Type Description Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] left border style Source code in prettyqt/gui/texttablecellformat.py def get_left_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current left border style. Returns: left border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . leftBorderStyle ()] get_right_border_style ( self ) Get the current right border style. Returns: Type Description Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] right border style Source code in prettyqt/gui/texttablecellformat.py def get_right_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current right border style. Returns: right border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . rightBorderStyle ()] get_top_border_style ( self ) Get the current top border style. Returns: Type Description Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] top border style Source code in prettyqt/gui/texttablecellformat.py def get_top_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current top border style. Returns: top border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . topBorderStyle ()] set_border_style ( self , style ) Set border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_bottom_border_style ( self , style ) Set bottom border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] bottom border style required Exceptions: Type Description InvalidParamError bottom border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_bottom_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set bottom border style. Args: style: bottom border style Raises: InvalidParamError: bottom border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBottomBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_left_border_style ( self , style ) Set left border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] left border style required Exceptions: Type Description InvalidParamError left border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_left_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set left border style. Args: style: left border style Raises: InvalidParamError: left border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setLeftBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_right_border_style ( self , style ) Set right border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] right border style required Exceptions: Type Description InvalidParamError right border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_right_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set right border style. Args: style: right border style Raises: InvalidParamError: right border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setRightBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) set_top_border_style ( self , style ) Set top border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] top border style required Exceptions: Type Description InvalidParamError top border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_top_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set top border style. Args: style: top border style Raises: InvalidParamError: top border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setTopBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ]) transform Transform __reduce__ ( self ) special Helper for pickle. Source code in prettyqt/gui/transform.py def __reduce__ ( self ): return type ( self ), (), self . __getstate__ () validator Validator __radd__ ( self , other ) special Needed for sum(). Source code in prettyqt/gui/validator.py def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other ) window Window get_visibility ( self ) Get the current window visibility. Returns: Type Description Literal['windowed', 'minimized', 'maximized', 'fullscreen', 'automatic', 'hidden'] window visibility Source code in prettyqt/gui/window.py def get_visibility ( self ) -> VisibilityStr : \"\"\"Get the current window visibility. Returns: window visibility \"\"\" return VISIBILITY . inverse [ self . visibility ()] set_visibility ( self , visibility ) Set window visibility. Parameters: Name Type Description Default visibility Literal['windowed', 'minimized', 'maximized', 'fullscreen', 'automatic', 'hidden'] window visibility required Exceptions: Type Description InvalidParamError window visibility does not exist Source code in prettyqt/gui/window.py def set_visibility ( self , visibility : VisibilityStr ): \"\"\"Set window visibility. Args: visibility: window visibility Raises: InvalidParamError: window visibility does not exist \"\"\" if visibility not in VISIBILITY : raise InvalidParamError ( visibility , VISIBILITY ) self . setVisibility ( VISIBILITY [ visibility ]) start_system_resize ( self , edge ) Start system resize. Parameters: Name Type Description Default edge Literal['top', 'left', 'right', 'bottom', 'top_left', 'top_right', 'bottom_left', 'bottom_right'] edge to resize required Exceptions: Type Description InvalidParamError edge does not exist Source code in prettyqt/gui/window.py def start_system_resize ( self , edge : constants . EdgeStr ) -> bool : \"\"\"Start system resize. Args: edge: edge to resize Raises: InvalidParamError: edge does not exist \"\"\" if edge not in constants . EDGES : raise InvalidParamError ( edge , constants . EDGES ) return self . startSystemResize ( constants . EDGES [ edge ])","title":"gui"},{"location":"api/gui.html#gui-module","text":"","title":"gui module"},{"location":"api/gui.html#prettyqt.gui","text":"Gui module. Contains QtGui-based classes","title":"prettyqt.gui"},{"location":"api/gui.html#prettyqt.gui.color","text":"","title":"color"},{"location":"api/gui.html#prettyqt.gui.color.Color","text":"","title":"Color"},{"location":"api/gui.html#prettyqt.gui.color.Color.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/color.py def __reduce__ ( self ): return type ( self ), ( self . red (), self . green (), self . blue (), self . alpha ())","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.color.Color.from_text","text":"Create a QColor from specified string. Source code in prettyqt/gui/color.py @classmethod def from_text ( cls , text : str ) -> Color : \"\"\"Create a QColor from specified string.\"\"\" color = cls () if text . startswith ( \"#\" ) and len ( text ) == 7 : correct = \"#0123456789abcdef\" for char in text : if char . lower () not in correct : return color elif text not in list ( cls . colorNames ()): return color color . setNamedColor ( text ) return color","title":"from_text()"},{"location":"api/gui.html#prettyqt.gui.colorspace","text":"","title":"colorspace"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace","text":"","title":"ColorSpace"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_primaries","text":"Return current primaries. Returns: Type Description Literal['custom', 'srgb', 'adobe_rgb', 'dci_p3_d65', 'pro_photo_rgb'] primaries Source code in prettyqt/gui/colorspace.py def get_primaries ( self ) -> PrimariesStr : \"\"\"Return current primaries. Returns: primaries \"\"\" return PRIMARIES . inverse [ self . primaries ()]","title":"get_primaries()"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.get_transfer_function","text":"Return current transfer function. Returns: Type Description Literal['custom', 'linear', 'gamma', 'srgb', 'pro_photo_rgb'] transfer function Source code in prettyqt/gui/colorspace.py def get_transfer_function ( self ) -> TransformFunctionStr : \"\"\"Return current transfer function. Returns: transfer function \"\"\" return TRANSFER_FUNCTION . inverse [ self . transferFunction ()]","title":"get_transfer_function()"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_primaries","text":"Set primaries. Parameters: Name Type Description Default primaries Literal['custom', 'srgb', 'adobe_rgb', 'dci_p3_d65', 'pro_photo_rgb'] primaries to use required Exceptions: Type Description InvalidParamError primaries do not exist Source code in prettyqt/gui/colorspace.py def set_primaries ( self , primaries : PrimariesStr ): \"\"\"Set primaries. Args: primaries: primaries to use Raises: InvalidParamError: primaries do not exist \"\"\" if primaries not in PRIMARIES : raise InvalidParamError ( primaries , PRIMARIES ) self . setPrimaries ( PRIMARIES [ primaries ])","title":"set_primaries()"},{"location":"api/gui.html#prettyqt.gui.colorspace.ColorSpace.set_transfer_function","text":"Set transfer function. Parameters: Name Type Description Default fn Literal['custom', 'linear', 'gamma', 'srgb', 'pro_photo_rgb'] transfer function to use required Exceptions: Type Description InvalidParamError transfer function do not exist Source code in prettyqt/gui/colorspace.py def set_transfer_function ( self , fn : TransformFunctionStr , gamma : float = 0.0 ): \"\"\"Set transfer function. Args: fn: transfer function to use Raises: InvalidParamError: transfer function do not exist \"\"\" if fn not in TRANSFER_FUNCTION : raise InvalidParamError ( fn , TRANSFER_FUNCTION ) self . setTransferFunction ( TRANSFER_FUNCTION [ fn ], gamma )","title":"set_transfer_function()"},{"location":"api/gui.html#prettyqt.gui.cursor","text":"","title":"cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor","text":"","title":"Cursor"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.get_shape","text":"Return current cursor shape. Returns: Type Description Literal['arrow', 'uparrow', 'cross', 'wait', 'caret', 'size_vertical', 'size_horizonal', 'size_topright', 'size_topleft', 'size_all', 'blank', 'split_vertical', 'split_horizontal', 'pointing_hand', 'forbidden', 'open_hand', 'closed_hand', 'whats_this', 'busy', 'drag_move', 'drag_copy', 'drag_link', 'bitmap'] cursor shape Source code in prettyqt/gui/cursor.py def get_shape ( self ) -> constants . CursorShapeStr : \"\"\"Return current cursor shape. Returns: cursor shape \"\"\" return constants . CURSOR_SHAPE . inverse [ self . shape ()]","title":"get_shape()"},{"location":"api/gui.html#prettyqt.gui.cursor.Cursor.set_shape","text":"Set cursor shape. Parameters: Name Type Description Default shape Literal['arrow', 'uparrow', 'cross', 'wait', 'caret', 'size_vertical', 'size_horizonal', 'size_topright', 'size_topleft', 'size_all', 'blank', 'split_vertical', 'split_horizontal', 'pointing_hand', 'forbidden', 'open_hand', 'closed_hand', 'whats_this', 'busy', 'drag_move', 'drag_copy', 'drag_link', 'bitmap'] shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/gui/cursor.py def set_shape ( self , shape : constants . CursorShapeStr ): \"\"\"Set cursor shape. Args: shape: shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in constants . CURSOR_SHAPE : raise InvalidParamError ( shape , constants . CURSOR_SHAPE ) self . setShape ( constants . CURSOR_SHAPE [ shape ])","title":"set_shape()"},{"location":"api/gui.html#prettyqt.gui.font","text":"","title":"font"},{"location":"api/gui.html#prettyqt.gui.font.Font","text":"","title":"Font"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_capitalization","text":"Get current font capitalization. Returns: Type Description Literal['mixed_case', 'all_uppercase', 'all_lowercase', 'small_caps', 'capitalize'] current font capitalization Source code in prettyqt/gui/font.py def get_capitalization ( self ) -> CapitalizationStr : \"\"\"Get current font capitalization. Returns: current font capitalization \"\"\" return CAPITALIZATION . inverse [ self . capitalization ()]","title":"get_capitalization()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_hinting_preference","text":"Get current hinting preference. Returns: Type Description Literal['default', 'none', 'vertical', 'full'] current hinting preference Source code in prettyqt/gui/font.py def get_hinting_preference ( self ) -> HintingPreferenceStr : \"\"\"Get current hinting preference. Returns: current hinting preference \"\"\" return HINTING_PREFERENCE . inverse [ self . hintingPreference ()]","title":"get_hinting_preference()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_letter_spacing_type","text":"Get current letter spacing type. Returns: Type Description Literal['percentage', 'absolute'] current letter spacing type Source code in prettyqt/gui/font.py def get_letter_spacing_type ( self ) -> SpacingTypeStr : \"\"\"Get current letter spacing type. Returns: current letter spacing type \"\"\" return SPACING_TYPE . inverse [ self . letterSpacingType ()]","title":"get_letter_spacing_type()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_style","text":"Get current font style. Returns: Type Description Literal['normal', 'italic', 'oblique'] current font style Source code in prettyqt/gui/font.py def get_style ( self ) -> StyleStr : \"\"\"Get current font style. Returns: current font style \"\"\" return STYLE . inverse [ self . style ()]","title":"get_style()"},{"location":"api/gui.html#prettyqt.gui.font.Font.get_weight","text":"Get current font weight. Returns: Type Description Literal['thin', 'extra_light', 'light', 'normal', 'medium', 'demi_bold', 'bold', 'extra_bold', 'black'] current font weight Source code in prettyqt/gui/font.py def get_weight ( self ) -> WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return WEIGHT . inverse [ self . weight ()]","title":"get_weight()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_capitalization","text":"Set the font capitalization. Parameters: Name Type Description Default capitalization Literal['mixed_case', 'all_uppercase', 'all_lowercase', 'small_caps', 'capitalize'] font capitalization required Exceptions: Type Description InvalidParamError invalid font capitalization Source code in prettyqt/gui/font.py def set_capitalization ( self , capitalization : CapitalizationStr ): \"\"\"Set the font capitalization. Args: capitalization: font capitalization Raises: InvalidParamError: invalid font capitalization \"\"\" if capitalization not in CAPITALIZATION : raise InvalidParamError ( capitalization , CAPITALIZATION ) self . setCapitalization ( CAPITALIZATION [ capitalization ])","title":"set_capitalization()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_hinting_preference","text":"Set the hinting preference. Parameters: Name Type Description Default preference Literal['default', 'none', 'vertical', 'full'] hinting preference required Exceptions: Type Description InvalidParamError invalid hinting preference Source code in prettyqt/gui/font.py def set_hinting_preference ( self , preference : HintingPreferenceStr ): \"\"\"Set the hinting preference. Args: preference: hinting preference Raises: InvalidParamError: invalid hinting preference \"\"\" if preference not in HINTING_PREFERENCE : raise InvalidParamError ( preference , HINTING_PREFERENCE ) self . setHintingPreference ( HINTING_PREFERENCE [ preference ])","title":"set_hinting_preference()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_letter_spacing","text":"Set the letter spacing. Parameters: Name Type Description Default typ Literal['percentage', 'absolute'] letter spacing type required spacing float spacing required Exceptions: Type Description InvalidParamError invalid letter spacing type Source code in prettyqt/gui/font.py def set_letter_spacing ( self , typ : SpacingTypeStr , spacing : float ): \"\"\"Set the letter spacing. Args: typ: letter spacing type spacing: spacing Raises: InvalidParamError: invalid letter spacing type \"\"\" if typ not in SPACING_TYPE : raise InvalidParamError ( typ , SPACING_TYPE ) self . setLetterSpacing ( SPACING_TYPE [ typ ], spacing )","title":"set_letter_spacing()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style","text":"Set the font style. Parameters: Name Type Description Default style Literal['normal', 'italic', 'oblique'] font style required Exceptions: Type Description InvalidParamError invalid font style Source code in prettyqt/gui/font.py def set_style ( self , style : StyleStr ): \"\"\"Set the font style. Args: style: font style Raises: InvalidParamError: invalid font style \"\"\" if style not in STYLE : raise InvalidParamError ( style , STYLE ) self . setStyle ( STYLE [ style ])","title":"set_style()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_style_hint","text":"Set the style hint. Parameters: Name Type Description Default hint Literal['any', 'sans_serif', 'serif', 'typewriter', 'decorative', 'monospace', 'fantasy', 'cursive', 'system'] style hint required Exceptions: Type Description InvalidParamError invalid style hint Source code in prettyqt/gui/font.py def set_style_hint ( self , hint : StyleHintStr ): \"\"\"Set the style hint. Args: hint: style hint Raises: InvalidParamError: invalid style hint \"\"\" if hint not in STYLE_HINTS : raise InvalidParamError ( hint , STYLE_HINTS ) self . setStyleHint ( STYLE_HINTS [ hint ])","title":"set_style_hint()"},{"location":"api/gui.html#prettyqt.gui.font.Font.set_weight","text":"Set the font weight. Parameters: Name Type Description Default weight Literal['thin', 'extra_light', 'light', 'normal', 'medium', 'demi_bold', 'bold', 'extra_bold', 'black'] font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/font.py def set_weight ( self , weight : WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in WEIGHT : raise InvalidParamError ( weight , WEIGHT ) self . setWeight ( WEIGHT [ weight ])","title":"set_weight()"},{"location":"api/gui.html#prettyqt.gui.gradient","text":"","title":"gradient"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient","text":"","title":"Gradient"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_coordinate_mode","text":"Return current coordinate mode. Returns: Type Description Literal['logical', 'object', 'stretch_to_device', 'object_bounding'] coordinate mode Source code in prettyqt/gui/gradient.py def get_coordinate_mode ( self ) -> CoordinateModeStr : \"\"\"Return current coordinate mode. Returns: coordinate mode \"\"\" return COORDINATE_MODE . inverse [ self . coordinateMode ()]","title":"get_coordinate_mode()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_spread","text":"Return current spread method. Returns: Type Description Literal['pad', 'repeat', 'reflect'] spread method Source code in prettyqt/gui/gradient.py def get_spread ( self ) -> SpreadStr : \"\"\"Return current spread method. Returns: spread method \"\"\" return SPREAD . inverse [ self . spread ()]","title":"get_spread()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.get_type","text":"Return current gradient type. Returns: Type Description Literal['linear', 'radial', 'conical', 'none'] gradient type Source code in prettyqt/gui/gradient.py def get_type ( self ) -> TypeStr : \"\"\"Return current gradient type. Returns: gradient type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.set_coordinate_mode","text":"Set the coordinate mode. Parameters: Name Type Description Default mode Literal['logical', 'object', 'stretch_to_device', 'object_bounding'] coordinate mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/gradient.py def set_coordinate_mode ( self , mode : CoordinateModeStr ): \"\"\"Set the coordinate mode. Args: mode: coordinate mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in COORDINATE_MODE : raise InvalidParamError ( mode , COORDINATE_MODE ) self . setCoordinateMode ( COORDINATE_MODE [ mode ])","title":"set_coordinate_mode()"},{"location":"api/gui.html#prettyqt.gui.gradient.Gradient.set_spread","text":"Set the spread method. Parameters: Name Type Description Default method Literal['pad', 'repeat', 'reflect'] spread method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/gui/gradient.py def set_spread ( self , method : SpreadStr ): \"\"\"Set the spread method. Args: method: spread method Raises: InvalidParamError: method does not exist \"\"\" if method not in SPREAD : raise InvalidParamError ( method , SPREAD ) self . setSpread ( SPREAD [ method ])","title":"set_spread()"},{"location":"api/gui.html#prettyqt.gui.guiapplication","text":"","title":"guiapplication"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication","text":"","title":"GuiApplication"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.copy_to_clipboard","text":"Sets clipboard to supplied text. Source code in prettyqt/gui/guiapplication.py @classmethod def copy_to_clipboard ( cls , text : str ): \"\"\"Sets clipboard to supplied text.\"\"\" cb = cls . clipboard () cb . clear ( mode = cb . Clipboard ) cb . setText ( text , mode = cb . Clipboard )","title":"copy_to_clipboard()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.get_application_state","text":"Get the current application state. Returns: Type Description List[Literal['suspended', 'hidden', 'inactive', 'active']] application state Source code in prettyqt/gui/guiapplication.py @classmethod def get_application_state ( cls ) -> List [ constants . ApplicationStateStr ]: \"\"\"Get the current application state. Returns: application state \"\"\" return [ k for k , v in constants . APPLICATION_STATES . items () if v & cls . applicationState () # type: ignore ]","title":"get_application_state()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.get_high_dpi_scale_factor_rounding_policy","text":"Get the current high dpi scale factor rounding policy. Returns: Type Description Literal['round', 'ceil', 'floor', 'round_prefer_floor', 'pass_through'] rounding policy Source code in prettyqt/gui/guiapplication.py @classmethod def get_high_dpi_scale_factor_rounding_policy ( cls , ) -> constants . HighDpiScaleFactorRoundingPolicyStr : \"\"\"Get the current high dpi scale factor rounding policy. Returns: rounding policy \"\"\" return constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY . inverse [ cls . highDpiScaleFactorRoundingPolicy () ]","title":"get_high_dpi_scale_factor_rounding_policy()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.get_layout_direction","text":"Get the current layout direction. Returns: Type Description Literal['left_to_right', 'right_to_left', 'auto'] layout direction Source code in prettyqt/gui/guiapplication.py def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()]","title":"get_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.set_high_dpi_scale_factor_rounding_policy","text":"Set high dpi scale factor rounding policy. Parameters: Name Type Description Default direction rounding policy required Exceptions: Type Description InvalidParamError rounding policy does not exist Source code in prettyqt/gui/guiapplication.py @classmethod def set_high_dpi_scale_factor_rounding_policy ( cls , policy : constants . HighDpiScaleFactorRoundingPolicyStr ): \"\"\"Set high dpi scale factor rounding policy. Args: direction: rounding policy Raises: InvalidParamError: rounding policy does not exist \"\"\" if policy not in constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY : raise InvalidParamError ( policy , constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY ) cls . setHighDpiScaleFactorRoundingPolicy ( constants . HIGH_DPI_SCALE_FACTOR_ROUNDING_POLICY [ policy ] )","title":"set_high_dpi_scale_factor_rounding_policy()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.set_icon","text":"Set the default window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/gui/guiapplication.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the default window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/gui.html#prettyqt.gui.guiapplication.GuiApplication.set_layout_direction","text":"Set layout direction. Parameters: Name Type Description Default direction Literal['left_to_right', 'right_to_left', 'auto'] layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/guiapplication.py def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ])","title":"set_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.imageiohandler","text":"","title":"imageiohandler"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler","text":"","title":"ImageIOHandler"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.get_option","text":"Return the value assigned to option. Parameters: Name Type Description Default option Literal['size', 'clip_rect', 'scaled_size', 'scaled_clip_rect', 'description', 'compression_ratio', 'gamma', 'quality', 'name', 'subtype', 'incremental_reading', 'endianness', 'animation', 'background_color', 'supported_sub_types', 'optimized_write', 'progressive_scan_write', 'image_transformation'] option to get required Returns: Type Description Any option Source code in prettyqt/gui/imageiohandler.py def get_option ( self , option : ImageOptionStr ) -> Any : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . option ( IMAGE_OPTION [ option ])","title":"get_option()"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.set_option","text":"Set option to given value. Parameters: Name Type Description Default option Literal['size', 'clip_rect', 'scaled_size', 'scaled_clip_rect', 'description', 'compression_ratio', 'gamma', 'quality', 'name', 'subtype', 'incremental_reading', 'endianness', 'animation', 'background_color', 'supported_sub_types', 'optimized_write', 'progressive_scan_write', 'image_transformation'] option to use required value value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/gui/imageiohandler.py def set_option ( self , option : ImageOptionStr , value ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) self . setOption ( IMAGE_OPTION [ option ], value )","title":"set_option()"},{"location":"api/gui.html#prettyqt.gui.imageiohandler.ImageIOHandler.supports_option","text":"Return whether the image handler supports given option. Parameters: Name Type Description Default option Literal['size', 'clip_rect', 'scaled_size', 'scaled_clip_rect', 'description', 'compression_ratio', 'gamma', 'quality', 'name', 'subtype', 'incremental_reading', 'endianness', 'animation', 'background_color', 'supported_sub_types', 'optimized_write', 'progressive_scan_write', 'image_transformation'] option to check required Returns: Type Description bool option Source code in prettyqt/gui/imageiohandler.py def supports_option ( self , option : ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in IMAGE_OPTION : raise InvalidParamError ( option , IMAGE_OPTION ) return self . supportsOption ( IMAGE_OPTION [ option ])","title":"supports_option()"},{"location":"api/gui.html#prettyqt.gui.imagereader","text":"","title":"imagereader"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader","text":"","title":"ImageReader"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_error","text":"Return error type. Returns: Type Description Literal['file_not_found', 'device', 'unsupported_format', 'invalid_data', 'unknown'] error type Source code in prettyqt/gui/imagereader.py def get_error ( self ) -> ImageReaderErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_READER_ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.get_transformation","text":"Return the transformation and orientation the image has been set to. Returns: Type Description Literal['none', 'mirror', 'flip', 'rotate_180', 'roate_90', 'mirror_and_rotate_90', 'flip_and_rotate_90', 'rotate_270'] transformation Source code in prettyqt/gui/imagereader.py def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()]","title":"get_transformation()"},{"location":"api/gui.html#prettyqt.gui.imagereader.ImageReader.supports_option","text":"Return whether the image handler supports given option. Parameters: Name Type Description Default option Literal['size', 'clip_rect', 'scaled_size', 'scaled_clip_rect', 'description', 'compression_ratio', 'gamma', 'quality', 'name', 'subtype', 'incremental_reading', 'endianness', 'animation', 'background_color', 'supported_sub_types', 'optimized_write', 'progressive_scan_write', 'image_transformation'] option to check required Returns: Type Description bool option Source code in prettyqt/gui/imagereader.py def supports_option ( self , option : gui . imageiohandler . ImageOptionStr ) -> bool : \"\"\"Return whether the image handler supports given option. Args: option: option to check Returns: option \"\"\" if option not in gui . imageiohandler . IMAGE_OPTION : raise InvalidParamError ( option , gui . imageiohandler . IMAGE_OPTION ) return self . supportsOption ( gui . imageiohandler . IMAGE_OPTION [ option ])","title":"supports_option()"},{"location":"api/gui.html#prettyqt.gui.imagewriter","text":"","title":"imagewriter"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter","text":"","title":"ImageWriter"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_error","text":"Return error type. Returns: Type Description Literal['device', 'unsupported_format', 'invalid_image', 'unknown'] error type Source code in prettyqt/gui/imagewriter.py def get_error ( self ) -> ImageWriterErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return IMAGE_WRITER_ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.get_transformation","text":"Return the transformation and orientation the image has been set to. Returns: Type Description Literal['none', 'mirror', 'flip', 'rotate_180', 'roate_90', 'mirror_and_rotate_90', 'flip_and_rotate_90', 'rotate_270'] transformation Source code in prettyqt/gui/imagewriter.py def get_transformation ( self ) -> gui . imageiohandler . TransformationStr : \"\"\"Return the transformation and orientation the image has been set to. Returns: transformation \"\"\" return gui . imageiohandler . TRANSFORMATION . inverse [ self . transformation ()]","title":"get_transformation()"},{"location":"api/gui.html#prettyqt.gui.imagewriter.ImageWriter.set_transformation","text":"Set the image transformations metadata including orientation. Parameters: Name Type Description Default origin Literal['none', 'mirror', 'flip', 'rotate_180', 'roate_90', 'mirror_and_rotate_90', 'flip_and_rotate_90', 'rotate_270'] transformation to use required Exceptions: Type Description InvalidParamError transformation does not exist Source code in prettyqt/gui/imagewriter.py def set_transformation ( self , origin : gui . imageiohandler . TransformationStr ): \"\"\"Set the image transformations metadata including orientation. Args: origin: transformation to use Raises: InvalidParamError: transformation does not exist \"\"\" if origin not in gui . imageiohandler . TRANSFORMATION : raise InvalidParamError ( origin , gui . imageiohandler . TRANSFORMATION ) self . setTransformation ( gui . imageiohandler . TRANSFORMATION [ origin ])","title":"set_transformation()"},{"location":"api/gui.html#prettyqt.gui.keysequence","text":"","title":"keysequence"},{"location":"api/gui.html#prettyqt.gui.keysequence.KeySequence","text":"","title":"KeySequence"},{"location":"api/gui.html#prettyqt.gui.keysequence.KeySequence.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/keysequence.py def __reduce__ ( self ): return type ( self ), ( self . toString (),)","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.movie","text":"","title":"movie"},{"location":"api/gui.html#prettyqt.gui.movie.Movie","text":"","title":"Movie"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_cache_mode","text":"Get the current cache mode. Returns: Type Description Literal['none', 'all'] cache mode Source code in prettyqt/gui/movie.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Get the current cache mode. Returns: cache mode \"\"\" return CACHE_MODE . inverse [ self . cacheMode ()]","title":"get_cache_mode()"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.get_state","text":"Get the current state. Returns: Type Description Literal['not_running', 'paused', 'running'] state Source code in prettyqt/gui/movie.py def get_state ( self ) -> MovieStateStr : \"\"\"Get the current state. Returns: state \"\"\" return MOVIE_STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/gui.html#prettyqt.gui.movie.Movie.set_cache_mode","text":"Set cache mode. Parameters: Name Type Description Default mode Literal['none', 'all'] cache mode required Exceptions: Type Description InvalidParamError cache mode does not exist Source code in prettyqt/gui/movie.py def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set cache mode. Args: mode: cache mode Raises: InvalidParamError: cache mode does not exist \"\"\" if mode not in CACHE_MODE : raise InvalidParamError ( mode , CACHE_MODE ) self . setCacheMode ( CACHE_MODE [ mode ])","title":"set_cache_mode()"},{"location":"api/gui.html#prettyqt.gui.pagelayout","text":"","title":"pagelayout"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout","text":"","title":"PageLayout"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_mode","text":"Get the current mode. Returns: Type Description Literal['standard', 'full_page'] mode Source code in prettyqt/gui/pagelayout.py def get_mode ( self ) -> ModeStr : \"\"\"Get the current mode. Returns: mode \"\"\" return MODES . inverse [ self . mode ()]","title":"get_mode()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_orientation","text":"Get the current orientation. Returns: Type Description Literal['portrait', 'landscape'] orientation Source code in prettyqt/gui/pagelayout.py def get_orientation ( self ) -> OrientationStr : \"\"\"Get the current orientation. Returns: orientation \"\"\" return ORIENTATIONS . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.get_units","text":"Get the current unit. Returns: Type Description Literal['millimeter', 'point', 'inch', 'pica', 'didot', 'cicero'] unit Source code in prettyqt/gui/pagelayout.py def get_units ( self ) -> UnitStr : \"\"\"Get the current unit. Returns: unit \"\"\" return UNITS . inverse [ self . units ()]","title":"get_units()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_mode","text":"Set mode. Parameters: Name Type Description Default mode Literal['standard', 'full_page'] mode required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/gui/pagelayout.py def set_mode ( self , mode : ModeStr ): \"\"\"Set mode. Args: mode: mode Raises: InvalidParamError: mode does not exist \"\"\" if mode not in MODES : raise InvalidParamError ( mode , MODES ) self . setMode ( MODES [ mode ])","title":"set_mode()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_orientation","text":"Set orientation. Parameters: Name Type Description Default orientation Literal['portrait', 'landscape'] orientation required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/gui/pagelayout.py def set_orientation ( self , orientation : OrientationStr ): \"\"\"Set orientation. Args: orientation: orientation Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in ORIENTATIONS : raise InvalidParamError ( orientation , ORIENTATIONS ) self . setOrientation ( ORIENTATIONS [ orientation ])","title":"set_orientation()"},{"location":"api/gui.html#prettyqt.gui.pagelayout.PageLayout.set_units","text":"Set unit. Parameters: Name Type Description Default unit Literal['millimeter', 'point', 'inch', 'pica', 'didot', 'cicero'] unit required Exceptions: Type Description InvalidParamError unit does not exist Source code in prettyqt/gui/pagelayout.py def set_units ( self , unit : UnitStr ): \"\"\"Set unit. Args: unit: unit Raises: InvalidParamError: unit does not exist \"\"\" if unit not in UNITS : raise InvalidParamError ( unit , UNITS ) self . setUnits ( UNITS [ unit ])","title":"set_units()"},{"location":"api/gui.html#prettyqt.gui.pagesize","text":"","title":"pagesize"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize","text":"","title":"PageSize"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_definition_units","text":"Get the definition unit. Returns: Type Description Literal['millimeter', 'point', 'inch', 'pica', 'didot', 'cicero'] unit Source code in prettyqt/gui/pagesize.py def get_definition_units ( self ) -> UnitStr : \"\"\"Get the definition unit. Returns: unit \"\"\" units = self . definitionUnits () if units == - 1 : raise ValueError ( \"Invalid page size\" ) return UNITS . inverse [ units ]","title":"get_definition_units()"},{"location":"api/gui.html#prettyqt.gui.pagesize.PageSize.get_id","text":"Get the standard page size id. Returns: Type Description str page size id Source code in prettyqt/gui/pagesize.py def get_id ( self ) -> str : \"\"\"Get the standard page size id. Returns: page size id \"\"\" return PAGE_SIZE_ID . inverse [ self . id ()]","title":"get_id()"},{"location":"api/gui.html#prettyqt.gui.paintdevice","text":"","title":"paintdevice"},{"location":"api/gui.html#prettyqt.gui.paintdevice.PaintDevice","text":"","title":"PaintDevice"},{"location":"api/gui.html#prettyqt.gui.paintdevice.PaintDevice.get_metric","text":"Return metric information. Parameters: Name Type Description Default metric Literal['width', 'height', 'width_mm', 'height_mm', 'num_colors', 'depth', 'dpi_x', 'dpi_y', 'physical_dpi_x', 'physical_dpi_y', 'pixel_ratio', 'pixel_ratio_scaled'] metric information to get required Returns: Type Description int metric information Source code in prettyqt/gui/paintdevice.py def get_metric ( self , metric : MetricStr ) -> int : \"\"\"Return metric information. Args: metric: metric information to get Returns: metric information \"\"\" if metric not in METRICS : raise InvalidParamError ( metric , METRICS ) return self . metric ( METRICS [ metric ])","title":"get_metric()"},{"location":"api/gui.html#prettyqt.gui.painter","text":"","title":"painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter","text":"","title":"Painter"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_composition_mode","text":"Get the current composition mode. Returns: Type Description Literal['source_over', 'destination_over', 'clear', 'source', 'destination', 'source_in', 'destination_in', 'source_out', 'destination_out', 'source_atop', 'destination_atop'] composition mode Source code in prettyqt/gui/painter.py def get_composition_mode ( self ) -> CompositionModeStr : \"\"\"Get the current composition mode. Returns: composition mode \"\"\" return COMPOSITION_MODE . inverse [ self . compositionMode ()]","title":"get_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.get_pen","text":"Return current pen. Returns: Type Description Pen current pen Source code in prettyqt/gui/painter.py def get_pen ( self ) -> gui . Pen : \"\"\"Return current pen. Returns: current pen \"\"\" return gui . Pen ( self . pen ())","title":"get_pen()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_composition_mode","text":"Set the current composition mode. Exceptions: Type Description InvalidParamError composition mode does not exist Source code in prettyqt/gui/painter.py def set_composition_mode ( self , mode : CompositionModeStr ): \"\"\"Set the current composition mode. Raises: InvalidParamError: composition mode does not exist \"\"\" if mode not in COMPOSITION_MODE : raise InvalidParamError ( mode , COMPOSITION_MODE ) self . setCompositionMode ( COMPOSITION_MODE [ mode ])","title":"set_composition_mode()"},{"location":"api/gui.html#prettyqt.gui.painter.Painter.set_pen","text":"Set pen to use. Parameters: Name Type Description Default style Literal['none', 'solid', 'dash', 'dot', 'dash_dot', 'dash_dot_dot', 'custom_dash'] pen style to use 'solid' width float pen width 1.0 color Union[str, int, PyQt5.QtCore.Qt.GlobalColor, PyQt5.QtGui.QColor, tuple] pen color 'black' join_style Literal['miter', 'bevel', 'roundsvg_miter'] pen join style to use 'bevel' cap_style Literal['flat', 'square', 'round'] pen cap style to use 'square' Source code in prettyqt/gui/painter.py def set_pen ( self , style : constants . PenStyleStr = \"solid\" , width : float = 1.0 , color : colors . ColorType = \"black\" , join_style : constants . JoinStyleStr = \"bevel\" , cap_style : constants . CapStyleStr = \"square\" , ): \"\"\"Set pen to use. Args: style: pen style to use width: pen width color: pen color join_style: pen join style to use cap_style: pen cap style to use \"\"\" pen = gui . Pen () pen . set_style ( style ) pen . set_cap_style ( cap_style ) pen . set_join_style ( join_style ) pen . setWidthF ( width ) pen . set_color ( color ) self . setPen ( pen )","title":"set_pen()"},{"location":"api/gui.html#prettyqt.gui.painterpath","text":"","title":"painterpath"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath","text":"","title":"PainterPath"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.get_fill_rule","text":"Return current fill rule. Returns: Type Description constants.FillRuleStr fill rule Source code in prettyqt/gui/painterpath.py def get_fill_rule ( self ) -> constants . FillRuleStr : \"\"\"Return current fill rule. Returns: fill rule \"\"\" return constants . FILL_RULE . inverse [ self . fillRule ()]","title":"get_fill_rule()"},{"location":"api/gui.html#prettyqt.gui.painterpath.PainterPath.set_fill_rule","text":"Set fill rule. Parameters: Name Type Description Default rule constants.FillRuleStr fill rule to use required Exceptions: Type Description InvalidParamError fill rule does not exist Source code in prettyqt/gui/painterpath.py def set_fill_rule ( self , rule : constants . FillRuleStr ): \"\"\"Set fill rule. Args: rule: fill rule to use Raises: InvalidParamError: fill rule does not exist \"\"\" if rule not in constants . FILL_RULE : raise InvalidParamError ( rule , constants . FILL_RULE ) self . setFillRule ( constants . FILL_RULE [ rule ])","title":"set_fill_rule()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker","text":"","title":"painterpathstroker"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker","text":"","title":"PainterPathStroker"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_cap_style","text":"Return current cap style. Returns: Type Description Literal['flat', 'square', 'round'] cap style Source code in prettyqt/gui/painterpathstroker.py def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()]","title":"get_cap_style()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.get_join_style","text":"Return current join style. Returns: Type Description Literal['miter', 'bevel', 'roundsvg_miter'] join style Source code in prettyqt/gui/painterpathstroker.py def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()]","title":"get_join_style()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_cap_style","text":"Set cap style to use. Parameters: Name Type Description Default style Literal['flat', 'square', 'round'] cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ])","title":"set_cap_style()"},{"location":"api/gui.html#prettyqt.gui.painterpathstroker.PainterPathStroker.set_join_style","text":"Set join style to use. Parameters: Name Type Description Default style Literal['miter', 'bevel', 'roundsvg_miter'] join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/painterpathstroker.py def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ])","title":"set_join_style()"},{"location":"api/gui.html#prettyqt.gui.palette","text":"","title":"palette"},{"location":"api/gui.html#prettyqt.gui.palette.Palette","text":"","title":"Palette"},{"location":"api/gui.html#prettyqt.gui.palette.Palette.get_color_group","text":"Return color group. Returns: Type Description Literal['disabled', 'active', 'inactive'] color group Source code in prettyqt/gui/palette.py def get_color_group ( self ) -> GroupStr : \"\"\"Return color group. Returns: color group \"\"\" return GROUP . inverse [ self . colorGroup ()]","title":"get_color_group()"},{"location":"api/gui.html#prettyqt.gui.palette.Palette.set_color_group","text":"Set the color group. Parameters: Name Type Description Default group Literal['disabled', 'active', 'inactive'] color group to use required Exceptions: Type Description InvalidParamError invalid color group Source code in prettyqt/gui/palette.py def set_color_group ( self , group : GroupStr , * args , ** kwargs ): \"\"\"Set the color group. Args: group: color group to use Raises: InvalidParamError: invalid color group \"\"\" if group not in GROUP : raise InvalidParamError ( group , GROUP ) self . setColorGroup ( GROUP [ group ], * args , ** kwargs )","title":"set_color_group()"},{"location":"api/gui.html#prettyqt.gui.pen","text":"","title":"pen"},{"location":"api/gui.html#prettyqt.gui.pen.Pen","text":"","title":"Pen"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_cap_style","text":"Return current cap style. Returns: Type Description Literal['flat', 'square', 'round'] cap style Source code in prettyqt/gui/pen.py def get_cap_style ( self ) -> constants . CapStyleStr : \"\"\"Return current cap style. Returns: cap style \"\"\" return constants . CAP_STYLE . inverse [ self . capStyle ()]","title":"get_cap_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_join_style","text":"Return current join style. Returns: Type Description Literal['miter', 'bevel', 'roundsvg_miter'] join style Source code in prettyqt/gui/pen.py def get_join_style ( self ) -> constants . JoinStyleStr : \"\"\"Return current join style. Returns: join style \"\"\" return constants . JOIN_STYLE . inverse [ self . joinStyle ()]","title":"get_join_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.get_style","text":"Return current pen style. Returns: Type Description Literal['none', 'solid', 'dash', 'dot', 'dash_dot', 'dash_dot_dot', 'custom_dash'] pen style Source code in prettyqt/gui/pen.py def get_style ( self ) -> constants . PenStyleStr : \"\"\"Return current pen style. Returns: pen style \"\"\" return constants . PEN_STYLE . inverse [ self . style ()]","title":"get_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_cap_style","text":"Set cap style to use. Parameters: Name Type Description Default style Literal['flat', 'square', 'round'] cap style to use required Exceptions: Type Description InvalidParamError cap style does not exist Source code in prettyqt/gui/pen.py def set_cap_style ( self , style : constants . CapStyleStr ): \"\"\"Set cap style to use. Args: style: cap style to use Raises: InvalidParamError: cap style does not exist \"\"\" if style not in constants . CAP_STYLE : raise InvalidParamError ( style , constants . CAP_STYLE ) self . setCapStyle ( constants . CAP_STYLE [ style ])","title":"set_cap_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_join_style","text":"Set join style to use. Parameters: Name Type Description Default style Literal['miter', 'bevel', 'roundsvg_miter'] join style to use required Exceptions: Type Description InvalidParamError join style does not exist Source code in prettyqt/gui/pen.py def set_join_style ( self , style : constants . JoinStyleStr ): \"\"\"Set join style to use. Args: style: join style to use Raises: InvalidParamError: join style does not exist \"\"\" if style not in constants . JOIN_STYLE : raise InvalidParamError ( style , constants . JOIN_STYLE ) self . setJoinStyle ( constants . JOIN_STYLE [ style ])","title":"set_join_style()"},{"location":"api/gui.html#prettyqt.gui.pen.Pen.set_style","text":"Set pen style to use. Parameters: Name Type Description Default style Literal['none', 'solid', 'dash', 'dot', 'dash_dot', 'dash_dot_dot', 'custom_dash'] pen style to use required Exceptions: Type Description InvalidParamError pen style does not exist Source code in prettyqt/gui/pen.py def set_style ( self , style : constants . PenStyleStr ): \"\"\"Set pen style to use. Args: style: pen style to use Raises: InvalidParamError: pen style does not exist \"\"\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setStyle ( constants . PEN_STYLE [ style ])","title":"set_style()"},{"location":"api/gui.html#prettyqt.gui.polygon","text":"","title":"polygon"},{"location":"api/gui.html#prettyqt.gui.polygon.Polygon","text":"","title":"Polygon"},{"location":"api/gui.html#prettyqt.gui.polygon.Polygon.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/polygon.py def __reduce__ ( self ): return type ( self ), (), self . __getstate__ ()","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.sessionmanager","text":"","title":"sessionmanager"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager","text":"","title":"SessionManager"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.get_restart_hint","text":"Return current restart hint. Returns: Type Description Literal['if_running', 'anyway', 'immediately', 'never'] restart hint Source code in prettyqt/gui/sessionmanager.py def get_restart_hint ( self ) -> RestartHintStr : \"\"\"Return current restart hint. Returns: restart hint \"\"\" return RESTART_HINT . inverse [ self . restartHint ()]","title":"get_restart_hint()"},{"location":"api/gui.html#prettyqt.gui.sessionmanager.SessionManager.set_restart_hint","text":"Set the restart hint. Parameters: Name Type Description Default style Literal['if_running', 'anyway', 'immediately', 'never'] restart hint required Exceptions: Type Description InvalidParamError restart hint does not exist Source code in prettyqt/gui/sessionmanager.py def set_restart_hint ( self , style : RestartHintStr ): \"\"\"Set the restart hint. Args: style: restart hint Raises: InvalidParamError: restart hint does not exist \"\"\" if style not in RESTART_HINT : raise InvalidParamError ( style , RESTART_HINT ) self . setRestartHint ( RESTART_HINT [ style ])","title":"set_restart_hint()"},{"location":"api/gui.html#prettyqt.gui.standarditem","text":"","title":"standarditem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem","text":"","title":"StandardItem"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.clone","text":"clone(self) -> QStandardItem Source code in prettyqt/gui/standarditem.py def clone ( self ): item = type ( self )() core . DataStream . copy_data ( self , item ) assert type ( item ) == StandardItem return item","title":"clone()"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.get_checkstate","text":"Return checkstate. Returns: Type Description constants.StateStr checkstate Source code in prettyqt/gui/standarditem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/gui/standarditem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ])","title":"set_checkstate()"},{"location":"api/gui.html#prettyqt.gui.standarditem.StandardItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon iconprovider.IconType icon to use required Source code in prettyqt/gui/standarditem.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/gui.html#prettyqt.gui.statictext","text":"","title":"statictext"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText","text":"","title":"StaticText"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_performance_hint","text":"Return current performance hint. Returns: Type Description Literal['moderate', 'aggressive'] performance hint Source code in prettyqt/gui/statictext.py def get_performance_hint ( self ) -> PerformanceHintStr : \"\"\"Return current performance hint. Returns: performance hint \"\"\" return PERFORMANCE_HINT . inverse [ self . performanceHint ()]","title":"get_performance_hint()"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.get_text_format","text":"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str text format Source code in prettyqt/gui/statictext.py def get_text_format ( self ) -> str : \"\"\"Return current text format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_performance_hint","text":"Set the performance hint. Parameters: Name Type Description Default hint Literal['moderate', 'aggressive'] performance hint to use required Exceptions: Type Description InvalidParamError performance hint does not exist Source code in prettyqt/gui/statictext.py def set_performance_hint ( self , hint : PerformanceHintStr ): \"\"\"Set the performance hint. Args: hint: performance hint to use Raises: InvalidParamError: performance hint does not exist \"\"\" if hint not in PERFORMANCE_HINT : raise InvalidParamError ( hint , PERFORMANCE_HINT ) self . setPerformanceHint ( PERFORMANCE_HINT [ hint ])","title":"set_performance_hint()"},{"location":"api/gui.html#prettyqt.gui.statictext.StaticText.set_text_format","text":"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default text_format str text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/gui/statictext.py def set_text_format ( self , text_format : str ): \"\"\"Set the text format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ])","title":"set_text_format()"},{"location":"api/gui.html#prettyqt.gui.surface","text":"","title":"surface"},{"location":"api/gui.html#prettyqt.gui.surface.Surface","text":"","title":"Surface"},{"location":"api/gui.html#prettyqt.gui.surface.Surface.get_surface_class","text":"Get the current surface class. Returns: Type Description Literal['window', 'offscreen'] surface class Source code in prettyqt/gui/surface.py def get_surface_class ( self ) -> SurfaceClassStr : \"\"\"Get the current surface class. Returns: surface class \"\"\" return SURFACE_CLASS . inverse [ self . surfaceClass ()]","title":"get_surface_class()"},{"location":"api/gui.html#prettyqt.gui.surface.Surface.get_surface_type","text":"Get the current surface type. Returns: Type Description Literal['raster', 'open_gl', 'raster_gl', 'open_vg', 'vulkan', 'metal'] surface type Source code in prettyqt/gui/surface.py def get_surface_type ( self ) -> SurfaceTypeStr : \"\"\"Get the current surface type. Returns: surface type \"\"\" return SURFACE_TYPES . inverse [ self . surfaceType ()]","title":"get_surface_type()"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter","text":"","title":"syntaxhighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter","text":"","title":"SyntaxHighlighter"},{"location":"api/gui.html#prettyqt.gui.syntaxhighlighter.SyntaxHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/gui/syntaxhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting for expression , nth , fmt in self . yield_rules (): for match in expression . finditer ( text ): span = match . span ( nth ) self . setFormat ( span [ 0 ], span [ 1 ] - span [ 0 ], fmt )","title":"highlightBlock()"},{"location":"api/gui.html#prettyqt.gui.textblockuserdata","text":"","title":"textblockuserdata"},{"location":"api/gui.html#prettyqt.gui.textblockuserdata.TextBlockUserData","text":"Storage for the user data associated with each line.","title":"TextBlockUserData"},{"location":"api/gui.html#prettyqt.gui.textcharformat","text":"","title":"textcharformat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat","text":"","title":"TextCharFormat"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_font_weight","text":"Get current font weight. Returns: Type Description Literal['thin', 'extra_light', 'light', 'normal', 'medium', 'demi_bold', 'bold', 'extra_bold', 'black'] current font weight Source code in prettyqt/gui/textcharformat.py def get_font_weight ( self ) -> gui . font . WeightStr : \"\"\"Get current font weight. Returns: current font weight \"\"\" return gui . font . WEIGHT . inverse [ self . fontWeight ()]","title":"get_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_underline_style","text":"Get current underline style. Returns: Type Description Literal['none', 'single', 'dash', 'dot', 'dashdot', 'dashdotline', 'wave', 'spellcheck'] current underline style Source code in prettyqt/gui/textcharformat.py def get_underline_style ( self ) -> UnderlineStyleStr : \"\"\"Get current underline style. Returns: current underline style \"\"\" return UNDERLINE_STYLE . inverse [ self . underlineStyle ()]","title":"get_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.get_vertical_alignment","text":"Get current vertical alignment. Returns: Type Description Literal['normal', 'super_script', 'sub_script', 'middle', 'bottom', 'top', 'baseline'] current vertical alignment Source code in prettyqt/gui/textcharformat.py def get_vertical_alignment ( self ) -> VerticalAlignmentStr : \"\"\"Get current vertical alignment. Returns: current vertical alignment \"\"\" return VERTICAL_ALIGNMENT . inverse [ self . verticalAlignment ()]","title":"get_vertical_alignment()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_style_hint","text":"Set the font style hint. Parameters: Name Type Description Default hint Literal['any', 'sans_serif', 'serif', 'typewriter', 'decorative', 'monospace', 'fantasy', 'cursive', 'system'] font style hint required Exceptions: Type Description InvalidParamError invalid font style hint Source code in prettyqt/gui/textcharformat.py def set_font_style_hint ( self , hint : gui . font . StyleHintStr ): \"\"\"Set the font style hint. Args: hint: font style hint Raises: InvalidParamError: invalid font style hint \"\"\" if hint not in gui . font . STYLE_HINTS : raise InvalidParamError ( hint , gui . font . STYLE_HINTS ) self . setFontStyleHint ( gui . font . STYLE_HINTS [ hint ])","title":"set_font_style_hint()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_font_weight","text":"Set the font weight. Parameters: Name Type Description Default weight Literal['thin', 'extra_light', 'light', 'normal', 'medium', 'demi_bold', 'bold', 'extra_bold', 'black'] font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/gui/textcharformat.py def set_font_weight ( self , weight : gui . font . WeightStr ): \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) self . setFontWeight ( gui . font . WEIGHT [ weight ])","title":"set_font_weight()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_underline_style","text":"Set the underline style. Parameters: Name Type Description Default style Literal['none', 'single', 'dash', 'dot', 'dashdot', 'dashdotline', 'wave', 'spellcheck'] underline style required Exceptions: Type Description InvalidParamError invalid underline style Source code in prettyqt/gui/textcharformat.py def set_underline_style ( self , style : UnderlineStyleStr ): \"\"\"Set the underline style. Args: style: underline style Raises: InvalidParamError: invalid underline style \"\"\" if style not in UNDERLINE_STYLE : raise InvalidParamError ( style , UNDERLINE_STYLE ) self . setUnderlineStyle ( UNDERLINE_STYLE [ style ])","title":"set_underline_style()"},{"location":"api/gui.html#prettyqt.gui.textcharformat.TextCharFormat.set_vertical_alignment","text":"Set the vertical alignment. Parameters: Name Type Description Default alignment Literal['normal', 'super_script', 'sub_script', 'middle', 'bottom', 'top', 'baseline'] vertical alignment required Exceptions: Type Description InvalidParamError invalid vertical alignment Source code in prettyqt/gui/textcharformat.py def set_vertical_alignment ( self , alignment : VerticalAlignmentStr ): \"\"\"Set the vertical alignment. Args: alignment: vertical alignment Raises: InvalidParamError: invalid vertical alignment \"\"\" if alignment not in VERTICAL_ALIGNMENT : raise InvalidParamError ( alignment , VERTICAL_ALIGNMENT ) self . setVerticalAlignment ( VERTICAL_ALIGNMENT [ alignment ])","title":"set_vertical_alignment()"},{"location":"api/gui.html#prettyqt.gui.textcursor","text":"","title":"textcursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor","text":"","title":"TextCursor"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.edit_block","text":"Context manager for edit blocks. Can be used for undo actions. Source code in prettyqt/gui/textcursor.py @contextlib . contextmanager def edit_block ( self ): \"\"\"Context manager for edit blocks. Can be used for undo actions.\"\"\" self . beginEditBlock () yield self . endEditBlock ()","title":"edit_block()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select","text":"select(self, QTextCursor.SelectionType) Source code in prettyqt/gui/textcursor.py def select ( self , selection : Union [ SelectionTypeStr , QtGui . QTextCursor . SelectionType ]): if isinstance ( selection , QtGui . QTextCursor . SelectionType ): sel = selection else : sel = SELECTION_TYPE [ selection ] super () . select ( sel )","title":"select()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.select_text","text":"Select text from start position to end position. Positions can be either an integer index or a move operation Parameters: Name Type Description Default start_pos Union[int, Literal['no_move', 'start', 'start_of_line', 'start_of_block', 'start_of_word', 'previous_block', 'previous_char', 'previous_word', 'up', 'left', 'word_left', 'end', 'end_of_line', 'end_of_word', 'end_of_block', 'next_block', 'next_char', 'next_word', 'down', 'right', 'word_right', 'next_cell', 'previous_cell', 'next_row', 'previous_row']] Start position required end_pos Union[int, Literal['no_move', 'start', 'start_of_line', 'start_of_block', 'start_of_word', 'previous_block', 'previous_char', 'previous_word', 'up', 'left', 'word_left', 'end', 'end_of_line', 'end_of_word', 'end_of_block', 'next_block', 'next_char', 'next_word', 'down', 'right', 'word_right', 'next_cell', 'previous_cell', 'next_row', 'previous_row']] End position required Source code in prettyqt/gui/textcursor.py def select_text ( self , start_pos : Union [ int , MoveOperationStr ], end_pos : Union [ int , MoveOperationStr ], ) -> str : \"\"\"Select text from start position to end position. Positions can be either an integer index or a move operation Args: start_pos: Start position end_pos: End position \"\"\" if isinstance ( start_pos , int ): self . set_position ( start_pos ) else : self . move_position ( start_pos ) if isinstance ( end_pos , int ): self . set_position ( end_pos , mode = \"keep\" ) else : self . move_position ( end_pos , mode = \"keep\" ) return self . selectedText ()","title":"select_text()"},{"location":"api/gui.html#prettyqt.gui.textcursor.TextCursor.set_position","text":"Set cursor to given position. Parameters: Name Type Description Default pos int Cursor position required mode Literal['move', 'keep'] Move mode 'move' Source code in prettyqt/gui/textcursor.py def set_position ( self , pos : int , mode : MoveModeStr = \"move\" ): \"\"\"Set cursor to given position. Args: pos: Cursor position mode: Move mode \"\"\" self . setPosition ( pos , MOVE_MODE [ mode ])","title":"set_position()"},{"location":"api/gui.html#prettyqt.gui.textdocument","text":"","title":"textdocument"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument","text":"","title":"TextDocument"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.clear_stacks","text":"Clear undo / redo stack. Parameters: Name Type Description Default stack Literal['undo', 'redo', 'undo_and_redo'] stack to clear required Exceptions: Type Description InvalidParamError stack type does not exist Source code in prettyqt/gui/textdocument.py def clear_stacks ( self , stack : StackStr ): \"\"\"Clear undo / redo stack. Args: stack: stack to clear Raises: InvalidParamError: stack type does not exist \"\"\" if stack not in STACKS : raise InvalidParamError ( stack , STACKS ) self . clearUndoRedoStacks ( STACKS [ stack ])","title":"clear_stacks()"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.get_default_cursor_move_style","text":"Return current cursor move style. Returns: Type Description Literal['logical', 'visual'] cursor move style Source code in prettyqt/gui/textdocument.py def get_default_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return current cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . defaultCursorMoveStyle ()]","title":"get_default_cursor_move_style()"},{"location":"api/gui.html#prettyqt.gui.textdocument.TextDocument.set_default_cursor_move_style","text":"Set the cursor move style. Parameters: Name Type Description Default style Literal['logical', 'visual'] cursor move style required Exceptions: Type Description InvalidParamError cursor move style does not exist Source code in prettyqt/gui/textdocument.py def set_default_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set the cursor move style. Args: style: cursor move style Raises: InvalidParamError: cursor move style does not exist \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setDefaultCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ])","title":"set_default_cursor_move_style()"},{"location":"api/gui.html#prettyqt.gui.textformat","text":"","title":"textformat"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormat","text":"","title":"TextFormat"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormat.get_layout_direction","text":"Get the current layout direction. Returns: Type Description Literal['left_to_right', 'right_to_left', 'auto'] layout direction Source code in prettyqt/gui/textformat.py def get_layout_direction ( self ) -> constants . LayoutDirectionStr : \"\"\"Get the current layout direction. Returns: layout direction \"\"\" return constants . LAYOUT_DIRECTION . inverse [ self . layoutDirection ()]","title":"get_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.textformat.TextFormat.set_layout_direction","text":"Set layout direction. Parameters: Name Type Description Default direction Literal['left_to_right', 'right_to_left', 'auto'] layout direction required Exceptions: Type Description InvalidParamError layout direction does not exist Source code in prettyqt/gui/textformat.py def set_layout_direction ( self , direction : constants . LayoutDirectionStr ): \"\"\"Set layout direction. Args: direction: layout direction Raises: InvalidParamError: layout direction does not exist \"\"\" if direction not in constants . LAYOUT_DIRECTION : raise InvalidParamError ( direction , constants . LAYOUT_DIRECTION ) self . setLayoutDirection ( constants . LAYOUT_DIRECTION [ direction ])","title":"set_layout_direction()"},{"location":"api/gui.html#prettyqt.gui.textframeformat","text":"","title":"textframeformat"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat","text":"","title":"TextFrameFormat"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_border_style","text":"Get the current border style. Returns: Type Description Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] border style Source code in prettyqt/gui/textframeformat.py def get_border_style ( self ) -> BorderStyleStr : \"\"\"Get the current border style. Returns: border style \"\"\" return BORDER_STYLES . inverse [ self . borderStyle ()]","title":"get_border_style()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_page_break_policy","text":"Get the current page break policy. Returns: Type Description Literal['auto', 'always_before', 'always_after'] page break policy Source code in prettyqt/gui/textframeformat.py def get_page_break_policy ( self ) -> gui . textformat . PageBreakFlagStr : \"\"\"Get the current page break policy. Returns: page break policy \"\"\" return gui . textformat . PAGE_BREAK_FLAG . inverse [ self . pageBreakPolicy ()]","title":"get_page_break_policy()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.get_position","text":"Get the current position. Returns: Type Description Literal['in_flow', 'flow_right', 'flow_left'] position Source code in prettyqt/gui/textframeformat.py def get_position ( self ) -> PositionStr : \"\"\"Get the current position. Returns: position \"\"\" return POSITIONS . inverse [ self . position ()]","title":"get_position()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_border_style","text":"Set border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/textframeformat.py def set_border_style ( self , style : BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in BORDER_STYLES : raise InvalidParamError ( style , BORDER_STYLES ) self . setBorderStyle ( BORDER_STYLES [ style ])","title":"set_border_style()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_page_break_policy","text":"Set page break policy. Parameters: Name Type Description Default policy Literal['auto', 'always_before', 'always_after'] page break policy required Exceptions: Type Description InvalidParamError page break policy does not exist Source code in prettyqt/gui/textframeformat.py def set_page_break_policy ( self , policy : gui . textformat . PageBreakFlagStr ): \"\"\"Set page break policy. Args: policy: page break policy Raises: InvalidParamError: page break policy does not exist \"\"\" if policy not in gui . textformat . PAGE_BREAK_FLAG : raise InvalidParamError ( policy , gui . textformat . PAGE_BREAK_FLAG ) self . setPageBreakPolicy ( gui . textformat . PAGE_BREAK_FLAG [ policy ])","title":"set_page_break_policy()"},{"location":"api/gui.html#prettyqt.gui.textframeformat.TextFrameFormat.set_position","text":"Set position. Parameters: Name Type Description Default position Literal['in_flow', 'flow_right', 'flow_left'] position required Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/gui/textframeformat.py def set_position ( self , position : PositionStr ): \"\"\"Set position. Args: position: position Raises: InvalidParamError: position does not exist \"\"\" if position not in POSITIONS : raise InvalidParamError ( position , POSITIONS ) self . setPosition ( POSITIONS [ position ])","title":"set_position()"},{"location":"api/gui.html#prettyqt.gui.textlength","text":"","title":"textlength"},{"location":"api/gui.html#prettyqt.gui.textlength.TextLength","text":"","title":"TextLength"},{"location":"api/gui.html#prettyqt.gui.textlength.TextLength.get_type","text":"Return type of this length object. Returns: Type Description Literal['variable', 'fixed', 'percentage'] timer type Source code in prettyqt/gui/textlength.py def get_type ( self ) -> TypeStr : \"\"\"Return type of this length object. Returns: timer type \"\"\" return TYPES . inverse [ self . type ()]","title":"get_type()"},{"location":"api/gui.html#prettyqt.gui.textlistformat","text":"","title":"textlistformat"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat","text":"","title":"TextListFormat"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.get_style","text":"Get current style. Returns: Type Description Literal['disc', 'circle', 'square', 'decimal', 'lower_alpha', 'upper_alpha', 'lower_roman', 'upper_roman'] current style Source code in prettyqt/gui/textlistformat.py def get_style ( self ) -> StyleStr : \"\"\"Get current style. Returns: current style \"\"\" return STYLES . inverse [ self . style ()]","title":"get_style()"},{"location":"api/gui.html#prettyqt.gui.textlistformat.TextListFormat.set_style","text":"Set the style. Parameters: Name Type Description Default style Literal['disc', 'circle', 'square', 'decimal', 'lower_alpha', 'upper_alpha', 'lower_roman', 'upper_roman'] style required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/gui/textlistformat.py def set_style ( self , style : StyleStr ): \"\"\"Set the style. Args: style: style Raises: InvalidParamError: invalid style \"\"\" if style not in STYLES : raise InvalidParamError ( style , STYLES ) self . setStyle ( STYLES [ style ])","title":"set_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat","text":"","title":"texttablecellformat"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat","text":"","title":"TextTableCellFormat"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_bottom_border_style","text":"Get the current bottom border style. Returns: Type Description Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] bottom border style Source code in prettyqt/gui/texttablecellformat.py def get_bottom_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current bottom border style. Returns: bottom border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . bottomBorderStyle ()]","title":"get_bottom_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_left_border_style","text":"Get the current left border style. Returns: Type Description Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] left border style Source code in prettyqt/gui/texttablecellformat.py def get_left_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current left border style. Returns: left border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . leftBorderStyle ()]","title":"get_left_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_right_border_style","text":"Get the current right border style. Returns: Type Description Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] right border style Source code in prettyqt/gui/texttablecellformat.py def get_right_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current right border style. Returns: right border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . rightBorderStyle ()]","title":"get_right_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.get_top_border_style","text":"Get the current top border style. Returns: Type Description Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] top border style Source code in prettyqt/gui/texttablecellformat.py def get_top_border_style ( self ) -> gui . textframeformat . BorderStyleStr : \"\"\"Get the current top border style. Returns: top border style \"\"\" return gui . textframeformat . BORDER_STYLES . inverse [ self . topBorderStyle ()]","title":"get_top_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_border_style","text":"Set border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] border style required Exceptions: Type Description InvalidParamError border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set border style. Args: style: border style Raises: InvalidParamError: border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_bottom_border_style","text":"Set bottom border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] bottom border style required Exceptions: Type Description InvalidParamError bottom border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_bottom_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set bottom border style. Args: style: bottom border style Raises: InvalidParamError: bottom border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setBottomBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_bottom_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_left_border_style","text":"Set left border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] left border style required Exceptions: Type Description InvalidParamError left border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_left_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set left border style. Args: style: left border style Raises: InvalidParamError: left border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setLeftBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_left_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_right_border_style","text":"Set right border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] right border style required Exceptions: Type Description InvalidParamError right border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_right_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set right border style. Args: style: right border style Raises: InvalidParamError: right border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setRightBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_right_border_style()"},{"location":"api/gui.html#prettyqt.gui.texttablecellformat.TextTableCellFormat.set_top_border_style","text":"Set top border style. Parameters: Name Type Description Default style Literal['none', 'dotted', 'dashed', 'solid', 'double', 'dot_dash', 'dot_dot_dash', 'groove', 'ridge', 'inset', 'outset'] top border style required Exceptions: Type Description InvalidParamError top border style does not exist Source code in prettyqt/gui/texttablecellformat.py def set_top_border_style ( self , style : gui . textframeformat . BorderStyleStr ): \"\"\"Set top border style. Args: style: top border style Raises: InvalidParamError: top border style does not exist \"\"\" if style not in gui . textframeformat . BORDER_STYLES : raise InvalidParamError ( style , gui . textframeformat . BORDER_STYLES ) self . setTopBorderStyle ( gui . textframeformat . BORDER_STYLES [ style ])","title":"set_top_border_style()"},{"location":"api/gui.html#prettyqt.gui.transform","text":"","title":"transform"},{"location":"api/gui.html#prettyqt.gui.transform.Transform","text":"","title":"Transform"},{"location":"api/gui.html#prettyqt.gui.transform.Transform.__reduce__","text":"Helper for pickle. Source code in prettyqt/gui/transform.py def __reduce__ ( self ): return type ( self ), (), self . __getstate__ ()","title":"__reduce__()"},{"location":"api/gui.html#prettyqt.gui.validator","text":"","title":"validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator","text":"","title":"Validator"},{"location":"api/gui.html#prettyqt.gui.validator.Validator.__radd__","text":"Needed for sum(). Source code in prettyqt/gui/validator.py def __radd__ ( self , other : QtGui . QValidator ): \"\"\"Needed for sum().\"\"\" return self . __add__ ( other )","title":"__radd__()"},{"location":"api/gui.html#prettyqt.gui.window","text":"","title":"window"},{"location":"api/gui.html#prettyqt.gui.window.Window","text":"","title":"Window"},{"location":"api/gui.html#prettyqt.gui.window.Window.get_visibility","text":"Get the current window visibility. Returns: Type Description Literal['windowed', 'minimized', 'maximized', 'fullscreen', 'automatic', 'hidden'] window visibility Source code in prettyqt/gui/window.py def get_visibility ( self ) -> VisibilityStr : \"\"\"Get the current window visibility. Returns: window visibility \"\"\" return VISIBILITY . inverse [ self . visibility ()]","title":"get_visibility()"},{"location":"api/gui.html#prettyqt.gui.window.Window.set_visibility","text":"Set window visibility. Parameters: Name Type Description Default visibility Literal['windowed', 'minimized', 'maximized', 'fullscreen', 'automatic', 'hidden'] window visibility required Exceptions: Type Description InvalidParamError window visibility does not exist Source code in prettyqt/gui/window.py def set_visibility ( self , visibility : VisibilityStr ): \"\"\"Set window visibility. Args: visibility: window visibility Raises: InvalidParamError: window visibility does not exist \"\"\" if visibility not in VISIBILITY : raise InvalidParamError ( visibility , VISIBILITY ) self . setVisibility ( VISIBILITY [ visibility ])","title":"set_visibility()"},{"location":"api/gui.html#prettyqt.gui.window.Window.start_system_resize","text":"Start system resize. Parameters: Name Type Description Default edge Literal['top', 'left', 'right', 'bottom', 'top_left', 'top_right', 'bottom_left', 'bottom_right'] edge to resize required Exceptions: Type Description InvalidParamError edge does not exist Source code in prettyqt/gui/window.py def start_system_resize ( self , edge : constants . EdgeStr ) -> bool : \"\"\"Start system resize. Args: edge: edge to resize Raises: InvalidParamError: edge does not exist \"\"\" if edge not in constants . EDGES : raise InvalidParamError ( edge , constants . EDGES ) return self . startSystemResize ( constants . EDGES [ edge ])","title":"start_system_resize()"},{"location":"api/location.html","text":"location module Location module. geomaneuver GeoManeuver get_direction ( self ) Return current direction. Returns: Type Description Literal['none', 'forward', 'bear_right', 'light_right', 'right', 'hard_right', 'u_turn_right', 'u_turn_left', 'hard_left', 'left', 'light_left', 'bear_left'] Direction Source code in prettyqt/location/geomaneuver.py def get_direction ( self ) -> InstructionDirectionStr : \"\"\"Return current direction. Returns: Direction \"\"\" return INSTRUCTION_DIRECTION . inverse [ self . direction ()] set_direction ( self , direction ) Set the direction. Parameters: Name Type Description Default direction Literal['none', 'forward', 'bear_right', 'light_right', 'right', 'hard_right', 'u_turn_right', 'u_turn_left', 'hard_left', 'left', 'light_left', 'bear_left'] Direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/location/geomaneuver.py def set_direction ( self , direction : InstructionDirectionStr ): \"\"\"Set the direction. Args: direction: Direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in INSTRUCTION_DIRECTION : raise InvalidParamError ( direction , INSTRUCTION_DIRECTION ) self . setDirection ( INSTRUCTION_DIRECTION [ direction ]) georouterequest GeoRouteRequest get_feature_weight ( self , feature ) Return current feature weight. Returns: Type Description Literal['neutral', 'prefer', 'require', 'avoid', 'disallow'] Feature weight Source code in prettyqt/location/georouterequest.py def get_feature_weight ( self , feature : FeatureTypeStr ) -> FeatureWeightStr : \"\"\"Return current feature weight. Returns: Feature weight \"\"\" if feature not in FEATURE_TYPES : raise InvalidParamError ( feature , FEATURE_TYPES ) return FEATURE_WEIGHTS . inverse [ self . featureWeight ( FEATURE_TYPES [ feature ])] get_route_optimization ( self ) Return current route optimization. Returns: Type Description Literal['shortest', 'fastest', 'most_economic', 'most_scenic'] Route optimization Source code in prettyqt/location/georouterequest.py def get_route_optimization ( self ) -> RouteOptimizationStr : \"\"\"Return current route optimization. Returns: Route optimization \"\"\" return ROUTE_OPTIMIZATION . inverse [ self . routeOptimization ()] set_feature_weight ( self , feature , weight ) Set the feature weight. Parameters: Name Type Description Default feature Literal['none', 'toll', 'highway', 'public_transit', 'ferry', 'tunnel', 'dirt_road', 'parks', 'motor_pool_lane', 'traffic'] Feature type required weight Literal['neutral', 'prefer', 'require', 'avoid', 'disallow'] Feature weight required Exceptions: Type Description InvalidParamError feature weight / type does not exist Source code in prettyqt/location/georouterequest.py def set_feature_weight ( self , feature : FeatureTypeStr , weight : FeatureWeightStr ): \"\"\"Set the feature weight. Args: feature: Feature type weight: Feature weight Raises: InvalidParamError: feature weight / type does not exist \"\"\" if weight not in FEATURE_WEIGHTS : raise InvalidParamError ( weight , FEATURE_WEIGHTS ) if feature not in FEATURE_TYPES : raise InvalidParamError ( feature , FEATURE_TYPES ) self . setFeatureWeight ( FEATURE_TYPES [ feature ], FEATURE_WEIGHTS [ weight ]) set_route_optimization ( self , optimization ) Set the route optimization. Parameters: Name Type Description Default optimization Literal['shortest', 'fastest', 'most_economic', 'most_scenic'] Route optimization required Exceptions: Type Description InvalidParamError route optimization does not exist Source code in prettyqt/location/georouterequest.py def set_route_optimization ( self , optimization : RouteOptimizationStr ): \"\"\"Set the route optimization. Args: optimization: Route optimization Raises: InvalidParamError: route optimization does not exist \"\"\" if optimization not in ROUTE_OPTIMIZATION : raise InvalidParamError ( optimization , ROUTE_OPTIMIZATION ) self . setRouteOptimization ( ROUTE_OPTIMIZATION [ optimization ]) place Place get_visibility ( self ) Return visibility. Returns: Type Description Literal['unspecified', 'device', 'private', 'public'] Visibility Source code in prettyqt/location/place.py def get_visibility ( self ) -> location . VisibilityStr : \"\"\"Return visibility. Returns: Visibility \"\"\" return location . VISIBILITY . inverse [ self . visibility ()] placecategory PlaceCategory get_visibility ( self ) Return the visibility of the place. Returns: Type Description Literal['unspecified', 'device', 'private', 'public'] Visibility Source code in prettyqt/location/placecategory.py def get_visibility ( self ) -> location . VisibilityStr : \"\"\"Return the visibility of the place. Returns: Visibility \"\"\" return location . VISIBILITY . inverse [ self . visibility ()] placecontent PlaceContent get_type ( self ) Return the visibility of the place. Returns: Type Description Literal['none', 'image', 'review', 'editorial', 'custom'] Place type Source code in prettyqt/location/placecontent.py def get_type ( self ) -> TypeStr : \"\"\"Return the visibility of the place. Returns: Place type \"\"\" return TYPE . inverse [ self . type ()] placecontentrequest PlaceContentRequest get_content_type ( self ) Return current content type. Returns: Type Description Literal['none', 'image', 'review', 'editorial', 'custom'] Relevance type Source code in prettyqt/location/placecontentrequest.py def get_content_type ( self ) -> location . placecontent . TypeStr : \"\"\"Return current content type. Returns: Relevance type \"\"\" return location . placecontent . TYPE . inverse [ self . contentType ()] set_content_type ( self , typ ) Set the content type. Parameters: Name Type Description Default typ Literal['none', 'image', 'review', 'editorial', 'custom'] Relevance type required Exceptions: Type Description InvalidParamError content type does not exist Source code in prettyqt/location/placecontentrequest.py def set_content_type ( self , typ : location . placecontent . TypeStr ): \"\"\"Set the content type. Args: typ: Relevance type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in location . placecontent . TYPE : raise InvalidParamError ( typ , location . placecontent . TYPE ) self . setContentType ( location . placecontent . TYPE [ typ ]) placeidreply PlaceIdReply get_operation_type ( self ) Get current operation_type. Returns: Type Description OperationTypeStr current operation_type Source code in prettyqt/location/placeidreply.py def get_operation_type ( self ) -> OperationTypeStr : \"\"\"Get current operation_type. Returns: current operation_type \"\"\" return OPERATION_TYPES . inverse [ self . operationType ()] placereply PlaceReply get_error ( self ) Return error type. Returns: Type Description Literal['none', 'place_does_not_exist', 'category_does_not_exist', 'communication', 'parse', 'permissions', 'unsupported', 'bad_argument', 'cancel', 'unknown'] Error type Source code in prettyqt/location/placereply.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: Error type \"\"\" return ERROR . inverse [ self . error ()] get_type ( self ) Return type. Returns: Type Description Literal['generic', 'details', 'search', 'search_suggestion', 'content', 'id', 'match'] Type Source code in prettyqt/location/placereply.py def get_type ( self ) -> TypeStr : \"\"\"Return type. Returns: Type \"\"\" return TYPE . inverse [ self . type ()] placesearchrequest PlaceSearchRequest get_relevance_hint ( self ) Return current relevance hint. Returns: Type Description Literal['unspecified', 'distance', 'lexical_place_name'] Relevance hint Source code in prettyqt/location/placesearchrequest.py def get_relevance_hint ( self ) -> RelevanceHintStr : \"\"\"Return current relevance hint. Returns: Relevance hint \"\"\" return RELEVANCE_HINT . inverse [ self . relevanceHint ()] get_visibility_scope ( self ) Return the scope of the visibility. Returns: Type Description Literal['unspecified', 'device', 'private', 'public'] Visibility scope Source code in prettyqt/location/placesearchrequest.py def get_visibility_scope ( self ) -> location . VisibilityStr : \"\"\"Return the scope of the visibility. Returns: Visibility scope \"\"\" return location . VISIBILITY . inverse [ self . visibilityScope ()] set_relevance_hint ( self , hint ) Set the relevance hint. Parameters: Name Type Description Default hint Literal['unspecified', 'distance', 'lexical_place_name'] Relevance hint required Exceptions: Type Description InvalidParamError relevance hint does not exist Source code in prettyqt/location/placesearchrequest.py def set_relevance_hint ( self , hint : RelevanceHintStr ): \"\"\"Set the relevance hint. Args: hint: Relevance hint Raises: InvalidParamError: relevance hint does not exist \"\"\" if hint not in RELEVANCE_HINT : raise InvalidParamError ( hint , RELEVANCE_HINT ) self . setRelevanceHint ( RELEVANCE_HINT [ hint ]) placesearchresult PlaceSearchResult get_type ( self ) Return result type. Returns: Type Description Literal['unknown', 'place', 'proposed_search'] Result type Source code in prettyqt/location/placesearchresult.py def get_type ( self ) -> TypeStr : \"\"\"Return result type. Returns: Result type \"\"\" return TYPE . inverse [ self . type ()]","title":"location"},{"location":"api/location.html#location-module","text":"","title":"location module"},{"location":"api/location.html#prettyqt.location","text":"Location module.","title":"prettyqt.location"},{"location":"api/location.html#prettyqt.location.geomaneuver","text":"","title":"geomaneuver"},{"location":"api/location.html#prettyqt.location.geomaneuver.GeoManeuver","text":"","title":"GeoManeuver"},{"location":"api/location.html#prettyqt.location.geomaneuver.GeoManeuver.get_direction","text":"Return current direction. Returns: Type Description Literal['none', 'forward', 'bear_right', 'light_right', 'right', 'hard_right', 'u_turn_right', 'u_turn_left', 'hard_left', 'left', 'light_left', 'bear_left'] Direction Source code in prettyqt/location/geomaneuver.py def get_direction ( self ) -> InstructionDirectionStr : \"\"\"Return current direction. Returns: Direction \"\"\" return INSTRUCTION_DIRECTION . inverse [ self . direction ()]","title":"get_direction()"},{"location":"api/location.html#prettyqt.location.geomaneuver.GeoManeuver.set_direction","text":"Set the direction. Parameters: Name Type Description Default direction Literal['none', 'forward', 'bear_right', 'light_right', 'right', 'hard_right', 'u_turn_right', 'u_turn_left', 'hard_left', 'left', 'light_left', 'bear_left'] Direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/location/geomaneuver.py def set_direction ( self , direction : InstructionDirectionStr ): \"\"\"Set the direction. Args: direction: Direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in INSTRUCTION_DIRECTION : raise InvalidParamError ( direction , INSTRUCTION_DIRECTION ) self . setDirection ( INSTRUCTION_DIRECTION [ direction ])","title":"set_direction()"},{"location":"api/location.html#prettyqt.location.georouterequest","text":"","title":"georouterequest"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest","text":"","title":"GeoRouteRequest"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.get_feature_weight","text":"Return current feature weight. Returns: Type Description Literal['neutral', 'prefer', 'require', 'avoid', 'disallow'] Feature weight Source code in prettyqt/location/georouterequest.py def get_feature_weight ( self , feature : FeatureTypeStr ) -> FeatureWeightStr : \"\"\"Return current feature weight. Returns: Feature weight \"\"\" if feature not in FEATURE_TYPES : raise InvalidParamError ( feature , FEATURE_TYPES ) return FEATURE_WEIGHTS . inverse [ self . featureWeight ( FEATURE_TYPES [ feature ])]","title":"get_feature_weight()"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.get_route_optimization","text":"Return current route optimization. Returns: Type Description Literal['shortest', 'fastest', 'most_economic', 'most_scenic'] Route optimization Source code in prettyqt/location/georouterequest.py def get_route_optimization ( self ) -> RouteOptimizationStr : \"\"\"Return current route optimization. Returns: Route optimization \"\"\" return ROUTE_OPTIMIZATION . inverse [ self . routeOptimization ()]","title":"get_route_optimization()"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.set_feature_weight","text":"Set the feature weight. Parameters: Name Type Description Default feature Literal['none', 'toll', 'highway', 'public_transit', 'ferry', 'tunnel', 'dirt_road', 'parks', 'motor_pool_lane', 'traffic'] Feature type required weight Literal['neutral', 'prefer', 'require', 'avoid', 'disallow'] Feature weight required Exceptions: Type Description InvalidParamError feature weight / type does not exist Source code in prettyqt/location/georouterequest.py def set_feature_weight ( self , feature : FeatureTypeStr , weight : FeatureWeightStr ): \"\"\"Set the feature weight. Args: feature: Feature type weight: Feature weight Raises: InvalidParamError: feature weight / type does not exist \"\"\" if weight not in FEATURE_WEIGHTS : raise InvalidParamError ( weight , FEATURE_WEIGHTS ) if feature not in FEATURE_TYPES : raise InvalidParamError ( feature , FEATURE_TYPES ) self . setFeatureWeight ( FEATURE_TYPES [ feature ], FEATURE_WEIGHTS [ weight ])","title":"set_feature_weight()"},{"location":"api/location.html#prettyqt.location.georouterequest.GeoRouteRequest.set_route_optimization","text":"Set the route optimization. Parameters: Name Type Description Default optimization Literal['shortest', 'fastest', 'most_economic', 'most_scenic'] Route optimization required Exceptions: Type Description InvalidParamError route optimization does not exist Source code in prettyqt/location/georouterequest.py def set_route_optimization ( self , optimization : RouteOptimizationStr ): \"\"\"Set the route optimization. Args: optimization: Route optimization Raises: InvalidParamError: route optimization does not exist \"\"\" if optimization not in ROUTE_OPTIMIZATION : raise InvalidParamError ( optimization , ROUTE_OPTIMIZATION ) self . setRouteOptimization ( ROUTE_OPTIMIZATION [ optimization ])","title":"set_route_optimization()"},{"location":"api/location.html#prettyqt.location.place","text":"","title":"place"},{"location":"api/location.html#prettyqt.location.place.Place","text":"","title":"Place"},{"location":"api/location.html#prettyqt.location.place.Place.get_visibility","text":"Return visibility. Returns: Type Description Literal['unspecified', 'device', 'private', 'public'] Visibility Source code in prettyqt/location/place.py def get_visibility ( self ) -> location . VisibilityStr : \"\"\"Return visibility. Returns: Visibility \"\"\" return location . VISIBILITY . inverse [ self . visibility ()]","title":"get_visibility()"},{"location":"api/location.html#prettyqt.location.placecategory","text":"","title":"placecategory"},{"location":"api/location.html#prettyqt.location.placecategory.PlaceCategory","text":"","title":"PlaceCategory"},{"location":"api/location.html#prettyqt.location.placecategory.PlaceCategory.get_visibility","text":"Return the visibility of the place. Returns: Type Description Literal['unspecified', 'device', 'private', 'public'] Visibility Source code in prettyqt/location/placecategory.py def get_visibility ( self ) -> location . VisibilityStr : \"\"\"Return the visibility of the place. Returns: Visibility \"\"\" return location . VISIBILITY . inverse [ self . visibility ()]","title":"get_visibility()"},{"location":"api/location.html#prettyqt.location.placecontent","text":"","title":"placecontent"},{"location":"api/location.html#prettyqt.location.placecontent.PlaceContent","text":"","title":"PlaceContent"},{"location":"api/location.html#prettyqt.location.placecontent.PlaceContent.get_type","text":"Return the visibility of the place. Returns: Type Description Literal['none', 'image', 'review', 'editorial', 'custom'] Place type Source code in prettyqt/location/placecontent.py def get_type ( self ) -> TypeStr : \"\"\"Return the visibility of the place. Returns: Place type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/location.html#prettyqt.location.placecontentrequest","text":"","title":"placecontentrequest"},{"location":"api/location.html#prettyqt.location.placecontentrequest.PlaceContentRequest","text":"","title":"PlaceContentRequest"},{"location":"api/location.html#prettyqt.location.placecontentrequest.PlaceContentRequest.get_content_type","text":"Return current content type. Returns: Type Description Literal['none', 'image', 'review', 'editorial', 'custom'] Relevance type Source code in prettyqt/location/placecontentrequest.py def get_content_type ( self ) -> location . placecontent . TypeStr : \"\"\"Return current content type. Returns: Relevance type \"\"\" return location . placecontent . TYPE . inverse [ self . contentType ()]","title":"get_content_type()"},{"location":"api/location.html#prettyqt.location.placecontentrequest.PlaceContentRequest.set_content_type","text":"Set the content type. Parameters: Name Type Description Default typ Literal['none', 'image', 'review', 'editorial', 'custom'] Relevance type required Exceptions: Type Description InvalidParamError content type does not exist Source code in prettyqt/location/placecontentrequest.py def set_content_type ( self , typ : location . placecontent . TypeStr ): \"\"\"Set the content type. Args: typ: Relevance type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in location . placecontent . TYPE : raise InvalidParamError ( typ , location . placecontent . TYPE ) self . setContentType ( location . placecontent . TYPE [ typ ])","title":"set_content_type()"},{"location":"api/location.html#prettyqt.location.placeidreply","text":"","title":"placeidreply"},{"location":"api/location.html#prettyqt.location.placeidreply.PlaceIdReply","text":"","title":"PlaceIdReply"},{"location":"api/location.html#prettyqt.location.placeidreply.PlaceIdReply.get_operation_type","text":"Get current operation_type. Returns: Type Description OperationTypeStr current operation_type Source code in prettyqt/location/placeidreply.py def get_operation_type ( self ) -> OperationTypeStr : \"\"\"Get current operation_type. Returns: current operation_type \"\"\" return OPERATION_TYPES . inverse [ self . operationType ()]","title":"get_operation_type()"},{"location":"api/location.html#prettyqt.location.placereply","text":"","title":"placereply"},{"location":"api/location.html#prettyqt.location.placereply.PlaceReply","text":"","title":"PlaceReply"},{"location":"api/location.html#prettyqt.location.placereply.PlaceReply.get_error","text":"Return error type. Returns: Type Description Literal['none', 'place_does_not_exist', 'category_does_not_exist', 'communication', 'parse', 'permissions', 'unsupported', 'bad_argument', 'cancel', 'unknown'] Error type Source code in prettyqt/location/placereply.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: Error type \"\"\" return ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/location.html#prettyqt.location.placereply.PlaceReply.get_type","text":"Return type. Returns: Type Description Literal['generic', 'details', 'search', 'search_suggestion', 'content', 'id', 'match'] Type Source code in prettyqt/location/placereply.py def get_type ( self ) -> TypeStr : \"\"\"Return type. Returns: Type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/location.html#prettyqt.location.placesearchrequest","text":"","title":"placesearchrequest"},{"location":"api/location.html#prettyqt.location.placesearchrequest.PlaceSearchRequest","text":"","title":"PlaceSearchRequest"},{"location":"api/location.html#prettyqt.location.placesearchrequest.PlaceSearchRequest.get_relevance_hint","text":"Return current relevance hint. Returns: Type Description Literal['unspecified', 'distance', 'lexical_place_name'] Relevance hint Source code in prettyqt/location/placesearchrequest.py def get_relevance_hint ( self ) -> RelevanceHintStr : \"\"\"Return current relevance hint. Returns: Relevance hint \"\"\" return RELEVANCE_HINT . inverse [ self . relevanceHint ()]","title":"get_relevance_hint()"},{"location":"api/location.html#prettyqt.location.placesearchrequest.PlaceSearchRequest.get_visibility_scope","text":"Return the scope of the visibility. Returns: Type Description Literal['unspecified', 'device', 'private', 'public'] Visibility scope Source code in prettyqt/location/placesearchrequest.py def get_visibility_scope ( self ) -> location . VisibilityStr : \"\"\"Return the scope of the visibility. Returns: Visibility scope \"\"\" return location . VISIBILITY . inverse [ self . visibilityScope ()]","title":"get_visibility_scope()"},{"location":"api/location.html#prettyqt.location.placesearchrequest.PlaceSearchRequest.set_relevance_hint","text":"Set the relevance hint. Parameters: Name Type Description Default hint Literal['unspecified', 'distance', 'lexical_place_name'] Relevance hint required Exceptions: Type Description InvalidParamError relevance hint does not exist Source code in prettyqt/location/placesearchrequest.py def set_relevance_hint ( self , hint : RelevanceHintStr ): \"\"\"Set the relevance hint. Args: hint: Relevance hint Raises: InvalidParamError: relevance hint does not exist \"\"\" if hint not in RELEVANCE_HINT : raise InvalidParamError ( hint , RELEVANCE_HINT ) self . setRelevanceHint ( RELEVANCE_HINT [ hint ])","title":"set_relevance_hint()"},{"location":"api/location.html#prettyqt.location.placesearchresult","text":"","title":"placesearchresult"},{"location":"api/location.html#prettyqt.location.placesearchresult.PlaceSearchResult","text":"","title":"PlaceSearchResult"},{"location":"api/location.html#prettyqt.location.placesearchresult.PlaceSearchResult.get_type","text":"Return result type. Returns: Type Description Literal['unknown', 'place', 'proposed_search'] Result type Source code in prettyqt/location/placesearchresult.py def get_type ( self ) -> TypeStr : \"\"\"Return result type. Returns: Result type \"\"\" return TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/multimedia.html","text":"multimedia module Multimedia module. abstractvideobuffer AbstractVideoBuffer get_handle_type ( self ) Return current handle type. Returns: Type Description Literal['none', 'gl_texture', 'xv_shm_image', 'core_image', 'pixmap', 'egl_image', 'user'] handle type Source code in prettyqt/multimedia/abstractvideobuffer.py def get_handle_type ( self ) -> HandleTypeStr : \"\"\"Return current handle type. Returns: handle type \"\"\" return HANDLE_TYPE . inverse [ self . handleType ()] get_map_mode ( self ) Return current map mode. Returns: Type Description Literal['not_mapped', 'read_only', 'write_only', 'read_write'] map mode Source code in prettyqt/multimedia/abstractvideobuffer.py def get_map_mode ( self ) -> MapModeStr : \"\"\"Return current map mode. Returns: map mode \"\"\" return MAP_MODE . inverse [ self . mapMode ()] map ( self , mode , num_bytes , bytes_per_line = 4 ) map(self, QAbstractVideoBuffer.MapMode) -> Tuple[sip.voidptr, int, int] Source code in prettyqt/multimedia/abstractvideobuffer.py def map ( self , mode : Union [ int , str ], num_bytes : int , bytes_per_line : int = 4 , ): if mode in MAP_MODE : mode = MAP_MODE [ mode ] super () . map ( mode , num_bytes , bytes_per_line ) audioencodersettings Settings dataclass Settings(bitrate: 'int', channel_count: 'int', codec: 'str', encoding_mode: 'EncodingModeStr', encoding_options: 'Dict[str, Any]', quality: 'QualityStr', sample_rate: 'int') audioformat Settings dataclass Settings(sample_rate: 'int', channel_count: 'int', sample_size: 'int', byte_order: 'EndianStr', sample_type: 'SampleTypeStr', codec: 'str') camera Camera get_capture_mode ( self ) Return current capture mode. Returns: Type Description Literal['viewfinder', 'still_image', 'video'] capture mode Source code in prettyqt/multimedia/camera.py def get_capture_mode ( self ) -> CaptureModeStr : \"\"\"Return current capture mode. Returns: capture mode \"\"\" return CAPTURE_MODES . inverse [ self . captureMode ()] get_error ( self ) Return current error state. Returns: Type Description Literal['none', 'camera', 'invalid_request', 'service_missing', 'not_supported_feature'] error state Source code in prettyqt/multimedia/camera.py def get_error ( self ) -> ErrorStr : \"\"\"Return current error state. Returns: error state \"\"\" return ERROR . inverse [ self . error ()] get_lock_status ( self ) Return current lock status. Returns: Type Description Literal['unlocked', 'searching', 'locked'] lock status Source code in prettyqt/multimedia/camera.py def get_lock_status ( self ) -> LockStatusStr : \"\"\"Return current lock status. Returns: lock status \"\"\" return LOCK_STATUS . inverse [ self . lockStatus ()] get_state ( self ) Return current state. Returns: Type Description Literal['unloaded', 'loaded', 'active'] state Source code in prettyqt/multimedia/camera.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATES . inverse [ self . state ()] get_status ( self ) Return current status. Returns: Type Description Literal['active', 'starting', 'stopping', 'standby', 'loaded', 'loading', 'unloading', 'unloaded', 'unavailable'] status Source code in prettyqt/multimedia/camera.py def get_status ( self ) -> StatusStr : \"\"\"Return current status. Returns: status \"\"\" return STATUS . inverse [ self . status ()] set_capture_mode ( self , position ) Set the capture mode. Parameters: Name Type Description Default position Literal['viewfinder', 'still_image', 'video'] capture mode required Exceptions: Type Description InvalidParamError capture mode does not exist Source code in prettyqt/multimedia/camera.py def set_capture_mode ( self , position : CaptureModeStr ): \"\"\"Set the capture mode. Args: position: capture mode Raises: InvalidParamError: capture mode does not exist \"\"\" if position not in CAPTURE_MODES : raise InvalidParamError ( position , CAPTURE_MODES ) self . setCaptureMode ( CAPTURE_MODES [ position ]) cameraexposure CameraExposure get_exposure_mode ( self ) Return current exposure mode. Returns: Type Description Literal['auto', 'manual', 'portrait', 'night', 'backlight', 'spotlight', 'sports', 'snow', 'beach', 'large_aperture', 'small_aperture', 'action', 'landscape', 'night_portrait', 'theatre', 'sunset', 'steady_photo', 'fireworks', 'party', 'candlelight', 'barcode', 'mode_vendor'] exposure mode Source code in prettyqt/multimedia/cameraexposure.py def get_exposure_mode ( self ) -> ExposureModeStr : \"\"\"Return current exposure mode. Returns: exposure mode \"\"\" return EXPOSURE_MODES . inverse [ self . item . exposureMode ()] get_flash_mode ( self ) Return current flash mode. Returns: Type Description Literal['auto', 'flash_off', 'flash_on', 'red_eye_reduction', 'fill', 'torch', 'video_light', 'sync_front_curtain', 'sync_rear_curtain', 'manual'] flash mode Source code in prettyqt/multimedia/cameraexposure.py def get_flash_mode ( self ) -> FlashModeStr : \"\"\"Return current flash mode. Returns: flash mode \"\"\" return FLASH_MODES . inverse [ self . item . flashMode ()] get_metering_mode ( self ) Return current metering mode. Returns: Type Description Literal['matrix', 'average', 'spot'] metering mode Source code in prettyqt/multimedia/cameraexposure.py def get_metering_mode ( self ) -> MeteringModeStr : \"\"\"Return current metering mode. Returns: metering mode \"\"\" return METERING_MODES . inverse [ self . item . meteringMode ()] set_exposure_mode ( self , mode ) Set the exposure mode. Parameters: Name Type Description Default mode Literal['auto', 'manual', 'portrait', 'night', 'backlight', 'spotlight', 'sports', 'snow', 'beach', 'large_aperture', 'small_aperture', 'action', 'landscape', 'night_portrait', 'theatre', 'sunset', 'steady_photo', 'fireworks', 'party', 'candlelight', 'barcode', 'mode_vendor'] exposure mode required Exceptions: Type Description InvalidParamError exposure mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_exposure_mode ( self , mode : ExposureModeStr ): \"\"\"Set the exposure mode. Args: mode: exposure mode Raises: InvalidParamError: exposure mode does not exist \"\"\" if mode not in EXPOSURE_MODES : raise InvalidParamError ( mode , EXPOSURE_MODES ) self . item . setExposureMode ( EXPOSURE_MODES [ mode ]) set_flash_mode ( self , mode ) Set the flash mode. Parameters: Name Type Description Default mode Literal['auto', 'flash_off', 'flash_on', 'red_eye_reduction', 'fill', 'torch', 'video_light', 'sync_front_curtain', 'sync_rear_curtain', 'manual'] flash mode required Exceptions: Type Description InvalidParamError flash mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_flash_mode ( self , mode : FlashModeStr ): \"\"\"Set the flash mode. Args: mode: flash mode Raises: InvalidParamError: flash mode does not exist \"\"\" if mode not in FLASH_MODES : raise InvalidParamError ( mode , FLASH_MODES ) self . item . setFlashMode ( FLASH_MODES [ mode ]) set_metering_mode ( self , mode ) Set the metering mode. Parameters: Name Type Description Default mode Literal['matrix', 'average', 'spot'] metering mode required Exceptions: Type Description InvalidParamError metering mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_metering_mode ( self , mode : MeteringModeStr ): \"\"\"Set the metering mode. Args: mode: metering mode Raises: InvalidParamError: metering mode does not exist \"\"\" if mode not in METERING_MODES : raise InvalidParamError ( mode , METERING_MODES ) self . item . setMeteringMode ( METERING_MODES [ mode ]) camerafocus CameraFocus get_focus_mode ( self ) Return current focus mode. Returns: Type Description Literal['manual', 'hyperfocal', 'infinity', 'auto', 'continuous', 'macro'] focus mode Source code in prettyqt/multimedia/camerafocus.py def get_focus_mode ( self ) -> FocusModeStr : \"\"\"Return current focus mode. Returns: focus mode \"\"\" return FOCUS_MODES . inverse [ self . item . focusMode ()] get_focus_point_mode ( self ) Return current focus point mode. Returns: Type Description Literal['auto', 'center', 'face_detection', 'custom'] focus point mode Source code in prettyqt/multimedia/camerafocus.py def get_focus_point_mode ( self ) -> FocusPointModeStr : \"\"\"Return current focus point mode. Returns: focus point mode \"\"\" return FOCUS_POINT_MODE . inverse [ self . item . focusPointMode ()] set_focus_mode ( self , mode ) Set the focus mode. Parameters: Name Type Description Default mode Literal['manual', 'hyperfocal', 'infinity', 'auto', 'continuous', 'macro'] focus mode required Exceptions: Type Description InvalidParamError focus mode does not exist Source code in prettyqt/multimedia/camerafocus.py def set_focus_mode ( self , mode : FocusModeStr ): \"\"\"Set the focus mode. Args: mode: focus mode Raises: InvalidParamError: focus mode does not exist \"\"\" if mode not in FOCUS_MODES : raise InvalidParamError ( mode , FOCUS_MODES ) self . item . setFocusMode ( FOCUS_MODES [ mode ]) set_focus_point_mode ( self , mode ) Set the focus mode. Parameters: Name Type Description Default mode Literal['auto', 'center', 'face_detection', 'custom'] focus point mode required Exceptions: Type Description InvalidParamError focus point mode does not exist Source code in prettyqt/multimedia/camerafocus.py def set_focus_point_mode ( self , mode : FocusPointModeStr ): \"\"\"Set the focus mode. Args: mode: focus point mode Raises: InvalidParamError: focus point mode does not exist \"\"\" if mode not in FOCUS_POINT_MODE : raise InvalidParamError ( mode , FOCUS_POINT_MODE ) self . item . setFocusPointMode ( FOCUS_POINT_MODE [ mode ]) camerafocuszone CameraFocusZone get_focus_mode ( self ) Return current focus mode. Returns: Type Description Literal['invalid', 'unused', 'selected', 'focused'] focus mode Source code in prettyqt/multimedia/camerafocuszone.py def get_focus_mode ( self ) -> FocusZoneStatusStr : \"\"\"Return current focus mode. Returns: focus mode \"\"\" return FOCUS_ZONE_STATUS . inverse [ self . status ()] cameraimageprocessing CameraImageProcessing get_color_filter ( self ) Return current exposure mode. Returns: Type Description Literal['none', 'grayscale', 'negative', 'solarize', 'sepia', 'posterize', 'whiteboard', 'blackboard', 'aqua', 'vendor'] color filter Source code in prettyqt/multimedia/cameraimageprocessing.py def get_color_filter ( self ) -> ColorFilterStr : \"\"\"Return current exposure mode. Returns: color filter \"\"\" return COLOR_FILTERS . inverse [ self . item . colorFilter ()] get_white_balance_mode ( self ) Return current white balance mode. Returns: Type Description Literal['auto', 'manual', 'sunlight', 'cloudy', 'shade', 'tungsten', 'fluorescent', 'flash', 'sunset', 'vendor'] white balance mode Source code in prettyqt/multimedia/cameraimageprocessing.py def get_white_balance_mode ( self ) -> WhiteBalanceModeStr : \"\"\"Return current white balance mode. Returns: white balance mode \"\"\" return WHITE_BALANCE_MODE . inverse [ self . item . whiteBalanceMode ()] set_color_filter ( self , mode ) Set the color filter. Parameters: Name Type Description Default mode Literal['none', 'grayscale', 'negative', 'solarize', 'sepia', 'posterize', 'whiteboard', 'blackboard', 'aqua', 'vendor'] color filter required Exceptions: Type Description InvalidParamError color filter does not exist Source code in prettyqt/multimedia/cameraimageprocessing.py def set_color_filter ( self , mode : ColorFilterStr ): \"\"\"Set the color filter. Args: mode: color filter Raises: InvalidParamError: color filter does not exist \"\"\" if mode not in COLOR_FILTERS : raise InvalidParamError ( mode , COLOR_FILTERS ) self . item . setColorFilter ( COLOR_FILTERS [ mode ]) set_white_balance_mode ( self , mode ) Set the white balance mode. Parameters: Name Type Description Default mode Literal['auto', 'manual', 'sunlight', 'cloudy', 'shade', 'tungsten', 'fluorescent', 'flash', 'sunset', 'vendor'] white balance mode required Exceptions: Type Description InvalidParamError white balance mode does not exist Source code in prettyqt/multimedia/cameraimageprocessing.py def set_white_balance_mode ( self , mode : WhiteBalanceModeStr ): \"\"\"Set the white balance mode. Args: mode: white balance mode Raises: InvalidParamError: white balance mode does not exist \"\"\" if mode not in WHITE_BALANCE_MODE : raise InvalidParamError ( mode , WHITE_BALANCE_MODE ) self . item . setWhiteBalanceMode ( WHITE_BALANCE_MODE [ mode ]) cameraviewfindersettings Settings dataclass Settings(maximum_framerate: 'float', minimum_framerate: 'float', pixel_aspect_ratio: 'Tuple[int, int]', pixel_format: 'multimedia.videoframe.PixelFormatStr', resolution: 'Tuple[int, int]') imageencodersettings Settings dataclass Settings(codec: 'str', encoding_options: 'Dict[str, Any]', quality: 'QualityStr', resolution: 'Tuple[int, int]') mediaobject MediaObject get_availability ( self ) Return availability status. Returns: Type Description Literal['available', 'service_missing', 'resource_error', 'busy'] availability status Source code in prettyqt/multimedia/mediaobject.py def get_availability ( self ) -> AvailabilityStatusStr : \"\"\"Return availability status. Returns: availability status \"\"\" return AVAILABILITY_STATUS . inverse [ self . availability ()] mediaplayer MediaPlayer get_error ( self ) Return error type. Returns: Type Description Literal['none', 'resource', 'format', 'network', 'access_denied', 'service_missing'] error type Source code in prettyqt/multimedia/mediaplayer.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERROR . inverse [ self . error ()] get_media_status ( self ) Return current media status. Returns: Type Description Literal['unknown', 'no_media', 'loading', 'loaded', 'stalled', 'buffering', 'buffered', 'end', 'invalid'] media status Source code in prettyqt/multimedia/mediaplayer.py def get_media_status ( self ) -> MediaStatusStr : \"\"\"Return current media status. Returns: media status \"\"\" return MEDIA_STATUS . inverse [ self . mediaStatus ()] get_state ( self ) Return current state. Returns: Type Description Literal['stopped', 'playing', 'paused'] state Source code in prettyqt/multimedia/mediaplayer.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATES . inverse [ self . state ()] mediaplaylist MediaPlaylist get_playback_mode ( self ) Return current playback mode. Returns: Type Description Literal['item_once', 'item_in_loop', 'sequential', 'loop', 'random'] playback mode Source code in prettyqt/multimedia/mediaplaylist.py def get_playback_mode ( self ) -> PlaybackModeStr : \"\"\"Return current playback mode. Returns: playback mode \"\"\" return PLAYBACK_MODE . inverse [ self . playbackMode ()] set_playback_mode ( self , mode ) Set playback mode for given item view. Parameters: Name Type Description Default mode Literal['item_once', 'item_in_loop', 'sequential', 'loop', 'random'] playback mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/multimedia/mediaplaylist.py def set_playback_mode ( self , mode : PlaybackModeStr ): \"\"\"Set playback mode for given item view. Args: mode: playback mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in PLAYBACK_MODE : raise InvalidParamError ( mode , PLAYBACK_MODE ) self . setPlaybackMode ( PLAYBACK_MODE [ mode ]) mediarecorder MediaRecorder get_availability ( self ) Return availability status. Returns: Type Description Literal['available', 'service_missing', 'resource_error', 'busy'] availability status Source code in prettyqt/multimedia/mediarecorder.py def get_availability ( self ) -> AvailabilityStatusStr : \"\"\"Return availability status. Returns: availability status \"\"\" return AVAILABILITY_STATUS . inverse [ self . availability ()] videoencodersettings Settings dataclass Settings(bitrate: 'int', codec: 'str', encoding_mode: 'EncodingModeStr', encoding_options: 'Dict[str, Any]', quality: 'QualityStr', frame_rate: 'float', resolution: 'Tuple[int, int]') videoframe VideoFrame get_field_type ( self ) Get field type. Returns: Type Description Literal['progressive_frame', 'top_field', 'bottom_field', 'interlaced_frame'] Field type Source code in prettyqt/multimedia/videoframe.py def get_field_type ( self ) -> FieldTypeStr : \"\"\"Get field type. Returns: Field type \"\"\" return FIELD_TYPE . inverse [ self . fieldType ()] set_field_type ( self , typ ) Set current field type. Parameters: Name Type Description Default typ Literal['progressive_frame', 'top_field', 'bottom_field', 'interlaced_frame'] capture mode required Exceptions: Type Description InvalidParamError capture mode does not exist Source code in prettyqt/multimedia/videoframe.py def set_field_type ( self , typ : FieldTypeStr ): \"\"\"Set current field type. Args: typ: capture mode Raises: InvalidParamError: capture mode does not exist \"\"\" if typ not in FIELD_TYPE : raise InvalidParamError ( typ , FIELD_TYPE ) self . setFieldType ( FIELD_TYPE [ typ ])","title":"multimedia"},{"location":"api/multimedia.html#multimedia-module","text":"","title":"multimedia module"},{"location":"api/multimedia.html#prettyqt.multimedia","text":"Multimedia module.","title":"prettyqt.multimedia"},{"location":"api/multimedia.html#prettyqt.multimedia.abstractvideobuffer","text":"","title":"abstractvideobuffer"},{"location":"api/multimedia.html#prettyqt.multimedia.abstractvideobuffer.AbstractVideoBuffer","text":"","title":"AbstractVideoBuffer"},{"location":"api/multimedia.html#prettyqt.multimedia.abstractvideobuffer.AbstractVideoBuffer.get_handle_type","text":"Return current handle type. Returns: Type Description Literal['none', 'gl_texture', 'xv_shm_image', 'core_image', 'pixmap', 'egl_image', 'user'] handle type Source code in prettyqt/multimedia/abstractvideobuffer.py def get_handle_type ( self ) -> HandleTypeStr : \"\"\"Return current handle type. Returns: handle type \"\"\" return HANDLE_TYPE . inverse [ self . handleType ()]","title":"get_handle_type()"},{"location":"api/multimedia.html#prettyqt.multimedia.abstractvideobuffer.AbstractVideoBuffer.get_map_mode","text":"Return current map mode. Returns: Type Description Literal['not_mapped', 'read_only', 'write_only', 'read_write'] map mode Source code in prettyqt/multimedia/abstractvideobuffer.py def get_map_mode ( self ) -> MapModeStr : \"\"\"Return current map mode. Returns: map mode \"\"\" return MAP_MODE . inverse [ self . mapMode ()]","title":"get_map_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.abstractvideobuffer.AbstractVideoBuffer.map","text":"map(self, QAbstractVideoBuffer.MapMode) -> Tuple[sip.voidptr, int, int] Source code in prettyqt/multimedia/abstractvideobuffer.py def map ( self , mode : Union [ int , str ], num_bytes : int , bytes_per_line : int = 4 , ): if mode in MAP_MODE : mode = MAP_MODE [ mode ] super () . map ( mode , num_bytes , bytes_per_line )","title":"map()"},{"location":"api/multimedia.html#prettyqt.multimedia.audioencodersettings","text":"","title":"audioencodersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.audioencodersettings.Settings","text":"Settings(bitrate: 'int', channel_count: 'int', codec: 'str', encoding_mode: 'EncodingModeStr', encoding_options: 'Dict[str, Any]', quality: 'QualityStr', sample_rate: 'int')","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.audioformat","text":"","title":"audioformat"},{"location":"api/multimedia.html#prettyqt.multimedia.audioformat.Settings","text":"Settings(sample_rate: 'int', channel_count: 'int', sample_size: 'int', byte_order: 'EndianStr', sample_type: 'SampleTypeStr', codec: 'str')","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.camera","text":"","title":"camera"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera","text":"","title":"Camera"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_capture_mode","text":"Return current capture mode. Returns: Type Description Literal['viewfinder', 'still_image', 'video'] capture mode Source code in prettyqt/multimedia/camera.py def get_capture_mode ( self ) -> CaptureModeStr : \"\"\"Return current capture mode. Returns: capture mode \"\"\" return CAPTURE_MODES . inverse [ self . captureMode ()]","title":"get_capture_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_error","text":"Return current error state. Returns: Type Description Literal['none', 'camera', 'invalid_request', 'service_missing', 'not_supported_feature'] error state Source code in prettyqt/multimedia/camera.py def get_error ( self ) -> ErrorStr : \"\"\"Return current error state. Returns: error state \"\"\" return ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_lock_status","text":"Return current lock status. Returns: Type Description Literal['unlocked', 'searching', 'locked'] lock status Source code in prettyqt/multimedia/camera.py def get_lock_status ( self ) -> LockStatusStr : \"\"\"Return current lock status. Returns: lock status \"\"\" return LOCK_STATUS . inverse [ self . lockStatus ()]","title":"get_lock_status()"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_state","text":"Return current state. Returns: Type Description Literal['unloaded', 'loaded', 'active'] state Source code in prettyqt/multimedia/camera.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATES . inverse [ self . state ()]","title":"get_state()"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.get_status","text":"Return current status. Returns: Type Description Literal['active', 'starting', 'stopping', 'standby', 'loaded', 'loading', 'unloading', 'unloaded', 'unavailable'] status Source code in prettyqt/multimedia/camera.py def get_status ( self ) -> StatusStr : \"\"\"Return current status. Returns: status \"\"\" return STATUS . inverse [ self . status ()]","title":"get_status()"},{"location":"api/multimedia.html#prettyqt.multimedia.camera.Camera.set_capture_mode","text":"Set the capture mode. Parameters: Name Type Description Default position Literal['viewfinder', 'still_image', 'video'] capture mode required Exceptions: Type Description InvalidParamError capture mode does not exist Source code in prettyqt/multimedia/camera.py def set_capture_mode ( self , position : CaptureModeStr ): \"\"\"Set the capture mode. Args: position: capture mode Raises: InvalidParamError: capture mode does not exist \"\"\" if position not in CAPTURE_MODES : raise InvalidParamError ( position , CAPTURE_MODES ) self . setCaptureMode ( CAPTURE_MODES [ position ])","title":"set_capture_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure","text":"","title":"cameraexposure"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure","text":"","title":"CameraExposure"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.get_exposure_mode","text":"Return current exposure mode. Returns: Type Description Literal['auto', 'manual', 'portrait', 'night', 'backlight', 'spotlight', 'sports', 'snow', 'beach', 'large_aperture', 'small_aperture', 'action', 'landscape', 'night_portrait', 'theatre', 'sunset', 'steady_photo', 'fireworks', 'party', 'candlelight', 'barcode', 'mode_vendor'] exposure mode Source code in prettyqt/multimedia/cameraexposure.py def get_exposure_mode ( self ) -> ExposureModeStr : \"\"\"Return current exposure mode. Returns: exposure mode \"\"\" return EXPOSURE_MODES . inverse [ self . item . exposureMode ()]","title":"get_exposure_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.get_flash_mode","text":"Return current flash mode. Returns: Type Description Literal['auto', 'flash_off', 'flash_on', 'red_eye_reduction', 'fill', 'torch', 'video_light', 'sync_front_curtain', 'sync_rear_curtain', 'manual'] flash mode Source code in prettyqt/multimedia/cameraexposure.py def get_flash_mode ( self ) -> FlashModeStr : \"\"\"Return current flash mode. Returns: flash mode \"\"\" return FLASH_MODES . inverse [ self . item . flashMode ()]","title":"get_flash_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.get_metering_mode","text":"Return current metering mode. Returns: Type Description Literal['matrix', 'average', 'spot'] metering mode Source code in prettyqt/multimedia/cameraexposure.py def get_metering_mode ( self ) -> MeteringModeStr : \"\"\"Return current metering mode. Returns: metering mode \"\"\" return METERING_MODES . inverse [ self . item . meteringMode ()]","title":"get_metering_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.set_exposure_mode","text":"Set the exposure mode. Parameters: Name Type Description Default mode Literal['auto', 'manual', 'portrait', 'night', 'backlight', 'spotlight', 'sports', 'snow', 'beach', 'large_aperture', 'small_aperture', 'action', 'landscape', 'night_portrait', 'theatre', 'sunset', 'steady_photo', 'fireworks', 'party', 'candlelight', 'barcode', 'mode_vendor'] exposure mode required Exceptions: Type Description InvalidParamError exposure mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_exposure_mode ( self , mode : ExposureModeStr ): \"\"\"Set the exposure mode. Args: mode: exposure mode Raises: InvalidParamError: exposure mode does not exist \"\"\" if mode not in EXPOSURE_MODES : raise InvalidParamError ( mode , EXPOSURE_MODES ) self . item . setExposureMode ( EXPOSURE_MODES [ mode ])","title":"set_exposure_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.set_flash_mode","text":"Set the flash mode. Parameters: Name Type Description Default mode Literal['auto', 'flash_off', 'flash_on', 'red_eye_reduction', 'fill', 'torch', 'video_light', 'sync_front_curtain', 'sync_rear_curtain', 'manual'] flash mode required Exceptions: Type Description InvalidParamError flash mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_flash_mode ( self , mode : FlashModeStr ): \"\"\"Set the flash mode. Args: mode: flash mode Raises: InvalidParamError: flash mode does not exist \"\"\" if mode not in FLASH_MODES : raise InvalidParamError ( mode , FLASH_MODES ) self . item . setFlashMode ( FLASH_MODES [ mode ])","title":"set_flash_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraexposure.CameraExposure.set_metering_mode","text":"Set the metering mode. Parameters: Name Type Description Default mode Literal['matrix', 'average', 'spot'] metering mode required Exceptions: Type Description InvalidParamError metering mode does not exist Source code in prettyqt/multimedia/cameraexposure.py def set_metering_mode ( self , mode : MeteringModeStr ): \"\"\"Set the metering mode. Args: mode: metering mode Raises: InvalidParamError: metering mode does not exist \"\"\" if mode not in METERING_MODES : raise InvalidParamError ( mode , METERING_MODES ) self . item . setMeteringMode ( METERING_MODES [ mode ])","title":"set_metering_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus","text":"","title":"camerafocus"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus.CameraFocus","text":"","title":"CameraFocus"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus.CameraFocus.get_focus_mode","text":"Return current focus mode. Returns: Type Description Literal['manual', 'hyperfocal', 'infinity', 'auto', 'continuous', 'macro'] focus mode Source code in prettyqt/multimedia/camerafocus.py def get_focus_mode ( self ) -> FocusModeStr : \"\"\"Return current focus mode. Returns: focus mode \"\"\" return FOCUS_MODES . inverse [ self . item . focusMode ()]","title":"get_focus_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus.CameraFocus.get_focus_point_mode","text":"Return current focus point mode. Returns: Type Description Literal['auto', 'center', 'face_detection', 'custom'] focus point mode Source code in prettyqt/multimedia/camerafocus.py def get_focus_point_mode ( self ) -> FocusPointModeStr : \"\"\"Return current focus point mode. Returns: focus point mode \"\"\" return FOCUS_POINT_MODE . inverse [ self . item . focusPointMode ()]","title":"get_focus_point_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus.CameraFocus.set_focus_mode","text":"Set the focus mode. Parameters: Name Type Description Default mode Literal['manual', 'hyperfocal', 'infinity', 'auto', 'continuous', 'macro'] focus mode required Exceptions: Type Description InvalidParamError focus mode does not exist Source code in prettyqt/multimedia/camerafocus.py def set_focus_mode ( self , mode : FocusModeStr ): \"\"\"Set the focus mode. Args: mode: focus mode Raises: InvalidParamError: focus mode does not exist \"\"\" if mode not in FOCUS_MODES : raise InvalidParamError ( mode , FOCUS_MODES ) self . item . setFocusMode ( FOCUS_MODES [ mode ])","title":"set_focus_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocus.CameraFocus.set_focus_point_mode","text":"Set the focus mode. Parameters: Name Type Description Default mode Literal['auto', 'center', 'face_detection', 'custom'] focus point mode required Exceptions: Type Description InvalidParamError focus point mode does not exist Source code in prettyqt/multimedia/camerafocus.py def set_focus_point_mode ( self , mode : FocusPointModeStr ): \"\"\"Set the focus mode. Args: mode: focus point mode Raises: InvalidParamError: focus point mode does not exist \"\"\" if mode not in FOCUS_POINT_MODE : raise InvalidParamError ( mode , FOCUS_POINT_MODE ) self . item . setFocusPointMode ( FOCUS_POINT_MODE [ mode ])","title":"set_focus_point_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocuszone","text":"","title":"camerafocuszone"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocuszone.CameraFocusZone","text":"","title":"CameraFocusZone"},{"location":"api/multimedia.html#prettyqt.multimedia.camerafocuszone.CameraFocusZone.get_focus_mode","text":"Return current focus mode. Returns: Type Description Literal['invalid', 'unused', 'selected', 'focused'] focus mode Source code in prettyqt/multimedia/camerafocuszone.py def get_focus_mode ( self ) -> FocusZoneStatusStr : \"\"\"Return current focus mode. Returns: focus mode \"\"\" return FOCUS_ZONE_STATUS . inverse [ self . status ()]","title":"get_focus_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing","text":"","title":"cameraimageprocessing"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing.CameraImageProcessing","text":"","title":"CameraImageProcessing"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing.CameraImageProcessing.get_color_filter","text":"Return current exposure mode. Returns: Type Description Literal['none', 'grayscale', 'negative', 'solarize', 'sepia', 'posterize', 'whiteboard', 'blackboard', 'aqua', 'vendor'] color filter Source code in prettyqt/multimedia/cameraimageprocessing.py def get_color_filter ( self ) -> ColorFilterStr : \"\"\"Return current exposure mode. Returns: color filter \"\"\" return COLOR_FILTERS . inverse [ self . item . colorFilter ()]","title":"get_color_filter()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing.CameraImageProcessing.get_white_balance_mode","text":"Return current white balance mode. Returns: Type Description Literal['auto', 'manual', 'sunlight', 'cloudy', 'shade', 'tungsten', 'fluorescent', 'flash', 'sunset', 'vendor'] white balance mode Source code in prettyqt/multimedia/cameraimageprocessing.py def get_white_balance_mode ( self ) -> WhiteBalanceModeStr : \"\"\"Return current white balance mode. Returns: white balance mode \"\"\" return WHITE_BALANCE_MODE . inverse [ self . item . whiteBalanceMode ()]","title":"get_white_balance_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing.CameraImageProcessing.set_color_filter","text":"Set the color filter. Parameters: Name Type Description Default mode Literal['none', 'grayscale', 'negative', 'solarize', 'sepia', 'posterize', 'whiteboard', 'blackboard', 'aqua', 'vendor'] color filter required Exceptions: Type Description InvalidParamError color filter does not exist Source code in prettyqt/multimedia/cameraimageprocessing.py def set_color_filter ( self , mode : ColorFilterStr ): \"\"\"Set the color filter. Args: mode: color filter Raises: InvalidParamError: color filter does not exist \"\"\" if mode not in COLOR_FILTERS : raise InvalidParamError ( mode , COLOR_FILTERS ) self . item . setColorFilter ( COLOR_FILTERS [ mode ])","title":"set_color_filter()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraimageprocessing.CameraImageProcessing.set_white_balance_mode","text":"Set the white balance mode. Parameters: Name Type Description Default mode Literal['auto', 'manual', 'sunlight', 'cloudy', 'shade', 'tungsten', 'fluorescent', 'flash', 'sunset', 'vendor'] white balance mode required Exceptions: Type Description InvalidParamError white balance mode does not exist Source code in prettyqt/multimedia/cameraimageprocessing.py def set_white_balance_mode ( self , mode : WhiteBalanceModeStr ): \"\"\"Set the white balance mode. Args: mode: white balance mode Raises: InvalidParamError: white balance mode does not exist \"\"\" if mode not in WHITE_BALANCE_MODE : raise InvalidParamError ( mode , WHITE_BALANCE_MODE ) self . item . setWhiteBalanceMode ( WHITE_BALANCE_MODE [ mode ])","title":"set_white_balance_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraviewfindersettings","text":"","title":"cameraviewfindersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.cameraviewfindersettings.Settings","text":"Settings(maximum_framerate: 'float', minimum_framerate: 'float', pixel_aspect_ratio: 'Tuple[int, int]', pixel_format: 'multimedia.videoframe.PixelFormatStr', resolution: 'Tuple[int, int]')","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.imageencodersettings","text":"","title":"imageencodersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.imageencodersettings.Settings","text":"Settings(codec: 'str', encoding_options: 'Dict[str, Any]', quality: 'QualityStr', resolution: 'Tuple[int, int]')","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaobject","text":"","title":"mediaobject"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaobject.MediaObject","text":"","title":"MediaObject"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaobject.MediaObject.get_availability","text":"Return availability status. Returns: Type Description Literal['available', 'service_missing', 'resource_error', 'busy'] availability status Source code in prettyqt/multimedia/mediaobject.py def get_availability ( self ) -> AvailabilityStatusStr : \"\"\"Return availability status. Returns: availability status \"\"\" return AVAILABILITY_STATUS . inverse [ self . availability ()]","title":"get_availability()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer","text":"","title":"mediaplayer"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer","text":"","title":"MediaPlayer"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_error","text":"Return error type. Returns: Type Description Literal['none', 'resource', 'format', 'network', 'access_denied', 'service_missing'] error type Source code in prettyqt/multimedia/mediaplayer.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_media_status","text":"Return current media status. Returns: Type Description Literal['unknown', 'no_media', 'loading', 'loaded', 'stalled', 'buffering', 'buffered', 'end', 'invalid'] media status Source code in prettyqt/multimedia/mediaplayer.py def get_media_status ( self ) -> MediaStatusStr : \"\"\"Return current media status. Returns: media status \"\"\" return MEDIA_STATUS . inverse [ self . mediaStatus ()]","title":"get_media_status()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplayer.MediaPlayer.get_state","text":"Return current state. Returns: Type Description Literal['stopped', 'playing', 'paused'] state Source code in prettyqt/multimedia/mediaplayer.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATES . inverse [ self . state ()]","title":"get_state()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist","text":"","title":"mediaplaylist"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist","text":"","title":"MediaPlaylist"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist.get_playback_mode","text":"Return current playback mode. Returns: Type Description Literal['item_once', 'item_in_loop', 'sequential', 'loop', 'random'] playback mode Source code in prettyqt/multimedia/mediaplaylist.py def get_playback_mode ( self ) -> PlaybackModeStr : \"\"\"Return current playback mode. Returns: playback mode \"\"\" return PLAYBACK_MODE . inverse [ self . playbackMode ()]","title":"get_playback_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediaplaylist.MediaPlaylist.set_playback_mode","text":"Set playback mode for given item view. Parameters: Name Type Description Default mode Literal['item_once', 'item_in_loop', 'sequential', 'loop', 'random'] playback mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/multimedia/mediaplaylist.py def set_playback_mode ( self , mode : PlaybackModeStr ): \"\"\"Set playback mode for given item view. Args: mode: playback mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in PLAYBACK_MODE : raise InvalidParamError ( mode , PLAYBACK_MODE ) self . setPlaybackMode ( PLAYBACK_MODE [ mode ])","title":"set_playback_mode()"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder","text":"","title":"mediarecorder"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder","text":"","title":"MediaRecorder"},{"location":"api/multimedia.html#prettyqt.multimedia.mediarecorder.MediaRecorder.get_availability","text":"Return availability status. Returns: Type Description Literal['available', 'service_missing', 'resource_error', 'busy'] availability status Source code in prettyqt/multimedia/mediarecorder.py def get_availability ( self ) -> AvailabilityStatusStr : \"\"\"Return availability status. Returns: availability status \"\"\" return AVAILABILITY_STATUS . inverse [ self . availability ()]","title":"get_availability()"},{"location":"api/multimedia.html#prettyqt.multimedia.videoencodersettings","text":"","title":"videoencodersettings"},{"location":"api/multimedia.html#prettyqt.multimedia.videoencodersettings.Settings","text":"Settings(bitrate: 'int', codec: 'str', encoding_mode: 'EncodingModeStr', encoding_options: 'Dict[str, Any]', quality: 'QualityStr', frame_rate: 'float', resolution: 'Tuple[int, int]')","title":"Settings"},{"location":"api/multimedia.html#prettyqt.multimedia.videoframe","text":"","title":"videoframe"},{"location":"api/multimedia.html#prettyqt.multimedia.videoframe.VideoFrame","text":"","title":"VideoFrame"},{"location":"api/multimedia.html#prettyqt.multimedia.videoframe.VideoFrame.get_field_type","text":"Get field type. Returns: Type Description Literal['progressive_frame', 'top_field', 'bottom_field', 'interlaced_frame'] Field type Source code in prettyqt/multimedia/videoframe.py def get_field_type ( self ) -> FieldTypeStr : \"\"\"Get field type. Returns: Field type \"\"\" return FIELD_TYPE . inverse [ self . fieldType ()]","title":"get_field_type()"},{"location":"api/multimedia.html#prettyqt.multimedia.videoframe.VideoFrame.set_field_type","text":"Set current field type. Parameters: Name Type Description Default typ Literal['progressive_frame', 'top_field', 'bottom_field', 'interlaced_frame'] capture mode required Exceptions: Type Description InvalidParamError capture mode does not exist Source code in prettyqt/multimedia/videoframe.py def set_field_type ( self , typ : FieldTypeStr ): \"\"\"Set current field type. Args: typ: capture mode Raises: InvalidParamError: capture mode does not exist \"\"\" if typ not in FIELD_TYPE : raise InvalidParamError ( typ , FIELD_TYPE ) self . setFieldType ( FIELD_TYPE [ typ ])","title":"set_field_type()"},{"location":"api/multimediawidgets.html","text":"multimediawidgets module Multimediawidgets module. graphicsvideoitem GraphicsVideoItem get_aspect_ratio_mode ( self ) Return current aspect ratio mode. Returns: Type Description Literal['ignore', 'keep', 'keep_by_expanding'] aspect ratio mode Source code in prettyqt/multimediawidgets/graphicsvideoitem.py def get_aspect_ratio_mode ( self ) -> constants . AspectRatioModeStr : \"\"\"Return current aspect ratio mode. Returns: aspect ratio mode \"\"\" return constants . ASPECT_RATIO_MODE . inverse [ self . aspectRatioMode ()] set_aspect_ratio_mode ( self , mode ) Set the aspect ratio mode. Parameters: Name Type Description Default mode Literal['ignore', 'keep', 'keep_by_expanding'] aspect ratio mode required Exceptions: Type Description InvalidParamError aspect ratio mode does not exist Source code in prettyqt/multimediawidgets/graphicsvideoitem.py def set_aspect_ratio_mode ( self , mode : constants . AspectRatioModeStr ): \"\"\"Set the aspect ratio mode. Args: mode: aspect ratio mode Raises: InvalidParamError: aspect ratio mode does not exist \"\"\" if mode not in constants . ASPECT_RATIO_MODE : raise InvalidParamError ( mode , constants . ASPECT_RATIO_MODE ) self . setAspectRatioMode ( constants . ASPECT_RATIO_MODE [ mode ]) videowidget VideoWidget mouseDoubleClickEvent ( self , event ) mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/multimediawidgets/videowidget.py def mouseDoubleClickEvent ( self , event ): if event . button () == QtCore . Qt . LeftButton and self . doubleclick_for_fullscreen : self . setFullScreen ( not self . isFullScreen ()) event . accept () return super () . mouseDoubleClickEvent ( event )","title":"multimediawidgets"},{"location":"api/multimediawidgets.html#multimediawidgets-module","text":"","title":"multimediawidgets module"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets","text":"Multimediawidgets module.","title":"prettyqt.multimediawidgets"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.graphicsvideoitem","text":"","title":"graphicsvideoitem"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.graphicsvideoitem.GraphicsVideoItem","text":"","title":"GraphicsVideoItem"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.graphicsvideoitem.GraphicsVideoItem.get_aspect_ratio_mode","text":"Return current aspect ratio mode. Returns: Type Description Literal['ignore', 'keep', 'keep_by_expanding'] aspect ratio mode Source code in prettyqt/multimediawidgets/graphicsvideoitem.py def get_aspect_ratio_mode ( self ) -> constants . AspectRatioModeStr : \"\"\"Return current aspect ratio mode. Returns: aspect ratio mode \"\"\" return constants . ASPECT_RATIO_MODE . inverse [ self . aspectRatioMode ()]","title":"get_aspect_ratio_mode()"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.graphicsvideoitem.GraphicsVideoItem.set_aspect_ratio_mode","text":"Set the aspect ratio mode. Parameters: Name Type Description Default mode Literal['ignore', 'keep', 'keep_by_expanding'] aspect ratio mode required Exceptions: Type Description InvalidParamError aspect ratio mode does not exist Source code in prettyqt/multimediawidgets/graphicsvideoitem.py def set_aspect_ratio_mode ( self , mode : constants . AspectRatioModeStr ): \"\"\"Set the aspect ratio mode. Args: mode: aspect ratio mode Raises: InvalidParamError: aspect ratio mode does not exist \"\"\" if mode not in constants . ASPECT_RATIO_MODE : raise InvalidParamError ( mode , constants . ASPECT_RATIO_MODE ) self . setAspectRatioMode ( constants . ASPECT_RATIO_MODE [ mode ])","title":"set_aspect_ratio_mode()"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.videowidget","text":"","title":"videowidget"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.videowidget.VideoWidget","text":"","title":"VideoWidget"},{"location":"api/multimediawidgets.html#prettyqt.multimediawidgets.videowidget.VideoWidget.mouseDoubleClickEvent","text":"mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/multimediawidgets/videowidget.py def mouseDoubleClickEvent ( self , event ): if event . button () == QtCore . Qt . LeftButton and self . doubleclick_for_fullscreen : self . setFullScreen ( not self . isFullScreen ()) event . accept () return super () . mouseDoubleClickEvent ( event )","title":"mouseDoubleClickEvent()"},{"location":"api/network.html","text":"network module Network module. Contains QtNetWork-based classes abstractsocket AbstractSocket set_pause_mode ( self , mode ) Set pause mode. Parameters: Name Type Description Default mode Literal['never', 'on_ssl_errors'] pause mode required Exceptions: Type Description InvalidParamError pause mode does not exist Source code in prettyqt/network/abstractsocket.py def set_pause_mode ( self , mode : PauseModeStr ): \"\"\"Set pause mode. Args: mode: pause mode Raises: InvalidParamError: pause mode does not exist \"\"\" if mode not in PAUSE_MODES : raise InvalidParamError ( mode , PAUSE_MODES ) self . setPauseMode ( PAUSE_MODES [ mode ]) httpmultipart HttpMultiPart set_content_type ( self , typ ) Set content type. Parameters: Name Type Description Default typ Literal['mixed', 'related', 'form', 'alternative'] content type required Exceptions: Type Description InvalidParamError content type does not exist Source code in prettyqt/network/httpmultipart.py def set_content_type ( self , typ : ContentTypeStr ): \"\"\"Set content type. Args: typ: content type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in CONTENT_TYPES : raise InvalidParamError ( typ , CONTENT_TYPES ) self . setContentType ( CONTENT_TYPES [ typ ]) networkaccessmanager NetworkAccessManager get ( self , request ) get(self, QNetworkRequest) -> QNetworkReply Source code in prettyqt/network/networkaccessmanager.py def get ( self , request : Union [ str , QtCore . QUrl , QtNetwork . QNetworkRequest ]): if isinstance ( request , str ): request = core . Url ( request ) request = network . NetworkRequest ( request ) return super () . get ( request ) get_redirect_policy ( self ) Get the current redirect policy. Returns: Type Description Literal['manual', 'no_less_safe', 'same_origin', 'user_verified'] redirect policy Source code in prettyqt/network/networkaccessmanager.py def get_redirect_policy ( self ) -> network . networkrequest . RedirectPolicyStr : \"\"\"Get the current redirect policy. Returns: redirect policy \"\"\" return network . networkrequest . REDIRECT_POLICIES . inverse [ self . redirectPolicy ()] set_redirect_policy ( self , policy ) Set redirect policy. Parameters: Name Type Description Default policy Literal['manual', 'no_less_safe', 'same_origin', 'user_verified'] redirect policy required Exceptions: Type Description InvalidParamError redirect policy does not exist Source code in prettyqt/network/networkaccessmanager.py def set_redirect_policy ( self , policy : network . networkrequest . RedirectPolicyStr ): \"\"\"Set redirect policy. Args: policy: redirect policy Raises: InvalidParamError: redirect policy does not exist \"\"\" if policy not in network . networkrequest . REDIRECT_POLICIES : raise InvalidParamError ( policy , network . networkrequest . REDIRECT_POLICIES ) self . setRedirectPolicy ( network . networkrequest . REDIRECT_POLICIES [ policy ]) networkaddressentry NetworkAddressEntry get_dns_eligibility ( self ) Return whether this address is eligible for publication in the DNS. Returns: Type Description Literal['unknown', 'eligible', 'ineligible'] DNS eligibility Source code in prettyqt/network/networkaddressentry.py def get_dns_eligibility ( self ) -> DnsEligibilityStatusStr : \"\"\"Return whether this address is eligible for publication in the DNS. Returns: DNS eligibility \"\"\" return DNS_ELIGIBILITY_STATUS . inverse [ self . dnsEligibility ()] set_dns_eligibility ( self , status ) Set the DNS eligibility flag for this address to status. Parameters: Name Type Description Default status Literal['unknown', 'eligible', 'ineligible'] DNS eligibility status required Exceptions: Type Description InvalidParamError dns eligibility status does not exist Source code in prettyqt/network/networkaddressentry.py def set_dns_eligibility ( self , status : DnsEligibilityStatusStr ): \"\"\"Set the DNS eligibility flag for this address to status. Args: status: DNS eligibility status Raises: InvalidParamError: dns eligibility status does not exist \"\"\" if status not in DNS_ELIGIBILITY_STATUS : raise InvalidParamError ( status , DNS_ELIGIBILITY_STATUS ) self . setDnsEligibility ( DNS_ELIGIBILITY_STATUS [ status ]) networkinterface NetworkInterface get_type ( self ) Get the interface type. Returns: Type Description InterfaceTypeStr interface type Source code in prettyqt/network/networkinterface.py def get_type ( self ) -> InterfaceTypeStr : \"\"\"Get the interface type. Returns: interface type \"\"\" return INTERFACE_TYPE . inverse [ self . type ()] networkproxy NetworkProxy get_type ( self ) Get the proxy type. Returns: Type Description Literal['none', 'default', 'socks5', 'http', 'http_caching', 'ftp_caching'] type Source code in prettyqt/network/networkproxy.py def get_type ( self ) -> ProxyTypeStr : \"\"\"Get the proxy type. Returns: type \"\"\" return PROXY_TYPES . inverse [ self . type ()] set_type ( self , typ ) Set proxy type. Parameters: Name Type Description Default typ Literal['none', 'default', 'socks5', 'http', 'http_caching', 'ftp_caching'] proxy type required Exceptions: Type Description InvalidParamError proxy type does not exist Source code in prettyqt/network/networkproxy.py def set_type ( self , typ : ProxyTypeStr ): \"\"\"Set proxy type. Args: typ: proxy type Raises: InvalidParamError: proxy type does not exist \"\"\" if typ not in PROXY_TYPES : raise InvalidParamError ( typ , PROXY_TYPES ) self . setType ( PROXY_TYPES [ typ ]) networkrequest NetworkRequest get_priority ( self ) Get the current priority. Returns: Type Description Literal['high', 'normal', 'low'] priority Source code in prettyqt/network/networkrequest.py def get_priority ( self ) -> PriorityStr : \"\"\"Get the current priority. Returns: priority \"\"\" return PRIORITY . inverse [ self . priority ()] set_priority ( self , priority ) Set priority. Parameters: Name Type Description Default priority Literal['high', 'normal', 'low'] priority required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/network/networkrequest.py def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority. Args: priority: priority Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITY : raise InvalidParamError ( priority , PRIORITY ) self . setPriority ( PRIORITY [ priority ]) tcpserver TcpServer listen ( self , address , port = 0 ) listen(self, address: Union[QHostAddress, QHostAddress.SpecialAddress] = QHostAddress.Any, port: int = 0) -> bool Source code in prettyqt/network/tcpserver.py def listen ( # type: ignore self , address : Union [ str , QtNetwork . QHostAddress ], port : int = 0 ) -> bool : if isinstance ( address , str ): address = network . HostAddress ( address ) return super () . listen ( address , port )","title":"network"},{"location":"api/network.html#network-module","text":"","title":"network module"},{"location":"api/network.html#prettyqt.network","text":"Network module. Contains QtNetWork-based classes","title":"prettyqt.network"},{"location":"api/network.html#prettyqt.network.abstractsocket","text":"","title":"abstractsocket"},{"location":"api/network.html#prettyqt.network.abstractsocket.AbstractSocket","text":"","title":"AbstractSocket"},{"location":"api/network.html#prettyqt.network.abstractsocket.AbstractSocket.set_pause_mode","text":"Set pause mode. Parameters: Name Type Description Default mode Literal['never', 'on_ssl_errors'] pause mode required Exceptions: Type Description InvalidParamError pause mode does not exist Source code in prettyqt/network/abstractsocket.py def set_pause_mode ( self , mode : PauseModeStr ): \"\"\"Set pause mode. Args: mode: pause mode Raises: InvalidParamError: pause mode does not exist \"\"\" if mode not in PAUSE_MODES : raise InvalidParamError ( mode , PAUSE_MODES ) self . setPauseMode ( PAUSE_MODES [ mode ])","title":"set_pause_mode()"},{"location":"api/network.html#prettyqt.network.httpmultipart","text":"","title":"httpmultipart"},{"location":"api/network.html#prettyqt.network.httpmultipart.HttpMultiPart","text":"","title":"HttpMultiPart"},{"location":"api/network.html#prettyqt.network.httpmultipart.HttpMultiPart.set_content_type","text":"Set content type. Parameters: Name Type Description Default typ Literal['mixed', 'related', 'form', 'alternative'] content type required Exceptions: Type Description InvalidParamError content type does not exist Source code in prettyqt/network/httpmultipart.py def set_content_type ( self , typ : ContentTypeStr ): \"\"\"Set content type. Args: typ: content type Raises: InvalidParamError: content type does not exist \"\"\" if typ not in CONTENT_TYPES : raise InvalidParamError ( typ , CONTENT_TYPES ) self . setContentType ( CONTENT_TYPES [ typ ])","title":"set_content_type()"},{"location":"api/network.html#prettyqt.network.networkaccessmanager","text":"","title":"networkaccessmanager"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager","text":"","title":"NetworkAccessManager"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.get","text":"get(self, QNetworkRequest) -> QNetworkReply Source code in prettyqt/network/networkaccessmanager.py def get ( self , request : Union [ str , QtCore . QUrl , QtNetwork . QNetworkRequest ]): if isinstance ( request , str ): request = core . Url ( request ) request = network . NetworkRequest ( request ) return super () . get ( request )","title":"get()"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.get_redirect_policy","text":"Get the current redirect policy. Returns: Type Description Literal['manual', 'no_less_safe', 'same_origin', 'user_verified'] redirect policy Source code in prettyqt/network/networkaccessmanager.py def get_redirect_policy ( self ) -> network . networkrequest . RedirectPolicyStr : \"\"\"Get the current redirect policy. Returns: redirect policy \"\"\" return network . networkrequest . REDIRECT_POLICIES . inverse [ self . redirectPolicy ()]","title":"get_redirect_policy()"},{"location":"api/network.html#prettyqt.network.networkaccessmanager.NetworkAccessManager.set_redirect_policy","text":"Set redirect policy. Parameters: Name Type Description Default policy Literal['manual', 'no_less_safe', 'same_origin', 'user_verified'] redirect policy required Exceptions: Type Description InvalidParamError redirect policy does not exist Source code in prettyqt/network/networkaccessmanager.py def set_redirect_policy ( self , policy : network . networkrequest . RedirectPolicyStr ): \"\"\"Set redirect policy. Args: policy: redirect policy Raises: InvalidParamError: redirect policy does not exist \"\"\" if policy not in network . networkrequest . REDIRECT_POLICIES : raise InvalidParamError ( policy , network . networkrequest . REDIRECT_POLICIES ) self . setRedirectPolicy ( network . networkrequest . REDIRECT_POLICIES [ policy ])","title":"set_redirect_policy()"},{"location":"api/network.html#prettyqt.network.networkaddressentry","text":"","title":"networkaddressentry"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry","text":"","title":"NetworkAddressEntry"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.get_dns_eligibility","text":"Return whether this address is eligible for publication in the DNS. Returns: Type Description Literal['unknown', 'eligible', 'ineligible'] DNS eligibility Source code in prettyqt/network/networkaddressentry.py def get_dns_eligibility ( self ) -> DnsEligibilityStatusStr : \"\"\"Return whether this address is eligible for publication in the DNS. Returns: DNS eligibility \"\"\" return DNS_ELIGIBILITY_STATUS . inverse [ self . dnsEligibility ()]","title":"get_dns_eligibility()"},{"location":"api/network.html#prettyqt.network.networkaddressentry.NetworkAddressEntry.set_dns_eligibility","text":"Set the DNS eligibility flag for this address to status. Parameters: Name Type Description Default status Literal['unknown', 'eligible', 'ineligible'] DNS eligibility status required Exceptions: Type Description InvalidParamError dns eligibility status does not exist Source code in prettyqt/network/networkaddressentry.py def set_dns_eligibility ( self , status : DnsEligibilityStatusStr ): \"\"\"Set the DNS eligibility flag for this address to status. Args: status: DNS eligibility status Raises: InvalidParamError: dns eligibility status does not exist \"\"\" if status not in DNS_ELIGIBILITY_STATUS : raise InvalidParamError ( status , DNS_ELIGIBILITY_STATUS ) self . setDnsEligibility ( DNS_ELIGIBILITY_STATUS [ status ])","title":"set_dns_eligibility()"},{"location":"api/network.html#prettyqt.network.networkinterface","text":"","title":"networkinterface"},{"location":"api/network.html#prettyqt.network.networkinterface.NetworkInterface","text":"","title":"NetworkInterface"},{"location":"api/network.html#prettyqt.network.networkinterface.NetworkInterface.get_type","text":"Get the interface type. Returns: Type Description InterfaceTypeStr interface type Source code in prettyqt/network/networkinterface.py def get_type ( self ) -> InterfaceTypeStr : \"\"\"Get the interface type. Returns: interface type \"\"\" return INTERFACE_TYPE . inverse [ self . type ()]","title":"get_type()"},{"location":"api/network.html#prettyqt.network.networkproxy","text":"","title":"networkproxy"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy","text":"","title":"NetworkProxy"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.get_type","text":"Get the proxy type. Returns: Type Description Literal['none', 'default', 'socks5', 'http', 'http_caching', 'ftp_caching'] type Source code in prettyqt/network/networkproxy.py def get_type ( self ) -> ProxyTypeStr : \"\"\"Get the proxy type. Returns: type \"\"\" return PROXY_TYPES . inverse [ self . type ()]","title":"get_type()"},{"location":"api/network.html#prettyqt.network.networkproxy.NetworkProxy.set_type","text":"Set proxy type. Parameters: Name Type Description Default typ Literal['none', 'default', 'socks5', 'http', 'http_caching', 'ftp_caching'] proxy type required Exceptions: Type Description InvalidParamError proxy type does not exist Source code in prettyqt/network/networkproxy.py def set_type ( self , typ : ProxyTypeStr ): \"\"\"Set proxy type. Args: typ: proxy type Raises: InvalidParamError: proxy type does not exist \"\"\" if typ not in PROXY_TYPES : raise InvalidParamError ( typ , PROXY_TYPES ) self . setType ( PROXY_TYPES [ typ ])","title":"set_type()"},{"location":"api/network.html#prettyqt.network.networkrequest","text":"","title":"networkrequest"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest","text":"","title":"NetworkRequest"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.get_priority","text":"Get the current priority. Returns: Type Description Literal['high', 'normal', 'low'] priority Source code in prettyqt/network/networkrequest.py def get_priority ( self ) -> PriorityStr : \"\"\"Get the current priority. Returns: priority \"\"\" return PRIORITY . inverse [ self . priority ()]","title":"get_priority()"},{"location":"api/network.html#prettyqt.network.networkrequest.NetworkRequest.set_priority","text":"Set priority. Parameters: Name Type Description Default priority Literal['high', 'normal', 'low'] priority required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/network/networkrequest.py def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority. Args: priority: priority Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITY : raise InvalidParamError ( priority , PRIORITY ) self . setPriority ( PRIORITY [ priority ])","title":"set_priority()"},{"location":"api/network.html#prettyqt.network.tcpserver","text":"","title":"tcpserver"},{"location":"api/network.html#prettyqt.network.tcpserver.TcpServer","text":"","title":"TcpServer"},{"location":"api/network.html#prettyqt.network.tcpserver.TcpServer.listen","text":"listen(self, address: Union[QHostAddress, QHostAddress.SpecialAddress] = QHostAddress.Any, port: int = 0) -> bool Source code in prettyqt/network/tcpserver.py def listen ( # type: ignore self , address : Union [ str , QtNetwork . QHostAddress ], port : int = 0 ) -> bool : if isinstance ( address , str ): address = network . HostAddress ( address ) return super () . listen ( address , port )","title":"listen()"},{"location":"api/objbrowser.html","text":"objbrowser module Objbrowser package. attribute_model Module that defines AttributeModel. safe_data_fn ( obj_fn , log_exceptions = False ) Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function Source code in prettyqt/objbrowser/attribute_model.py def safe_data_fn ( obj_fn : Callable , log_exceptions : bool = False , ) -> Callable : \"\"\"Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function \"\"\" def data_fn ( tree_item : treeitem . TreeItem ) -> str : \"\"\"Call the obj_fn(tree_item.obj). Returns empty string in case of an error \"\"\" try : return str ( obj_fn ( tree_item . obj )) except Exception as ex : if log_exceptions : logger . exception ( ex ) return \"\" return data_fn objectbrowser Object browser GUI in Qt. ObjectBrowser Object browser main application window. __init__ ( self , obj , name = '' ) special Constructor. :param obj: any Python object or variable :param name: name of the object as it will appear in the root node Source code in prettyqt/objbrowser/objectbrowser.py def __init__ ( self , obj , name : str = \"\" ): \"\"\"Constructor. :param obj: any Python object or variable :param name: name of the object as it will appear in the root node \"\"\" super () . __init__ () self . _instance_nr = self . _add_instance () self . set_icon ( \"mdi.language-python\" ) # Model self . _attr_cols = DEFAULT_ATTR_COLS self . _attr_details = DEFAULT_ATTR_DETAILS logger . debug ( \"Reading model settings for window: %d \" , self . _instance_nr ) with core . Settings ( settings_id = self . _settings_group_name ( \"model\" )) as settings : self . _auto_refresh = settings . get ( \"auto_refresh\" , False ) logger . debug ( \"read auto_refresh: %r \" , self . _auto_refresh ) self . _refresh_rate = settings . get ( \"refresh_rate\" , 2 ) logger . debug ( \"read refresh_rate: %r \" , self . _refresh_rate ) show_callable_attributes = settings . get ( \"show_callable_attributes\" , True ) logger . debug ( \"read show_callable_attributes: %r \" , show_callable_attributes ) show_special_attributes = settings . get ( \"show_special_attributes\" , True ) logger . debug ( \"read show_special_attributes: %r \" , show_special_attributes ) self . _tree_model = objectbrowsertreemodel . ObjectBrowserTreeModel ( obj , name , attr_cols = self . _attr_cols ) self . _proxy_tree_model = objectbrowsertreemodel . ObjectBrowserTreeProxyModel ( show_callable_attributes = show_callable_attributes , show_special_attributes = show_special_attributes , ) self . _proxy_tree_model . setSourceModel ( self . _tree_model ) # self._proxy_tree_model.setSortRole(RegistryTableModel.SORT_ROLE) self . _proxy_tree_model . setDynamicSortFilter ( True ) # self._proxy_tree_model.setSortCaseSensitivity(Qt.CaseInsensitive) # Views self . _setup_actions () self . _setup_views () self . _setup_menu () self . set_title ( \"Object browser\" ) self . _read_view_settings () assert self . _refresh_rate > 0 self . _refresh_timer = core . Timer ( self ) self . _refresh_timer . setInterval ( self . _refresh_rate * 1000 ) self . _refresh_timer . timeout . connect ( self . _tree_model . refresh_tree ) # Update views with model self . toggle_special_attribute_action . setChecked ( show_special_attributes ) self . toggle_callable_action . setChecked ( show_callable_attributes ) self . toggle_auto_refresh_action . setChecked ( self . _auto_refresh ) # Select first row so that a hidden root node will not be selected. first_row_index = self . _proxy_tree_model . first_item_index () self . obj_tree . setCurrentIndex ( first_row_index ) if self . _tree_model . inspected_node_is_visible : self . obj_tree . expand ( first_row_index ) browse ( * args , ** kwargs ) classmethod Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The args and *kwargs will be passed to the ObjectBrowser constructor. Source code in prettyqt/objbrowser/objectbrowser.py @classmethod def browse ( cls , * args , ** kwargs ): \"\"\"Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The *args and **kwargs will be passed to the ObjectBrowser constructor. \"\"\" cls . app = widgets . app () # keeping reference to prevent garbage collection. cls . app . setOrganizationName ( \"phil65\" ) cls . app . setApplicationName ( \"PrettyQt\" ) object_browser = cls ( * args , ** kwargs ) object_browser . show () object_browser . raise_ () assert cls . app is not None , \"QApplication object doesn't exist yet.\" return cls . app . main_loop () closeEvent ( self , event ) Called when the window is closed. Source code in prettyqt/objbrowser/objectbrowser.py def closeEvent ( self , event ): \"\"\"Called when the window is closed.\"\"\" logger . debug ( \"closeEvent\" ) self . _write_model_settings () self . _write_view_settings () self . _finalize () self . close () event . accept () \"\"\"Set the reference in the browser list to None.\"\"\" idx = self . _browsers . index ( self ) self . _browsers [ idx ] = None logger . debug ( \"Closed window %s \" , self . _instance_nr ) toggle_auto_refresh ( self , checked ) Toggle auto-refresh on/off. Source code in prettyqt/objbrowser/objectbrowser.py def toggle_auto_refresh ( self , checked ): \"\"\"Toggle auto-refresh on/off.\"\"\" if checked : logger . info ( \"Auto-refresh on. Rate %g seconds\" , self . _refresh_rate ) self . _refresh_timer . start () else : logger . info ( \"Auto-refresh off\" ) self . _refresh_timer . stop () self . _auto_refresh = checked objectbrowsertreemodel Module that defines the TreeModel. https://github.com/PySide/Examples/blob/master/examples/itemviews/simpletreemodel /simpletreemodel.py ObjectBrowserTreeItem Tree node class that can be used to build trees of objects. is_callable_attribute: bool property readonly Return true if the items is an attribute and it is callable. is_special_attribute: bool property readonly Return true if the item represents a dunder attribute. ObjectBrowserTreeModel Model that provides an interface to an objectree that is build of tree items. inspected_node_is_visible property readonly Return True if the inspected node is visible. In that case an invisible root node has been added. root_item: ObjectBrowserTreeItem property readonly The root ObjectBrowserTreeItem. __init__ ( self , obj , obj_name = '' , attr_cols = None , parent = None ) special Constructor. Parameters: Name Type Description Default obj Any Object to inspect required obj_name str Name of the object '' attr_cols Optional[List[custom_models.ColumnItem]] List of Column items None parent Optional[QtCore.QObject] Description None Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , obj : Any , obj_name : str = \"\" , attr_cols : Optional [ List [ custom_models . ColumnItem ]] = None , parent : Optional [ QtCore . QObject ] = None , ): \"\"\"Constructor. Args: obj (Any): Object to inspect obj_name (str, optional): Name of the object attr_cols (None, optional): List of Column items parent (None, optional): Description \"\"\" super () . __init__ ( attr_cols = attr_cols , parent = parent ) # The root_item is always invisible. If the obj_name is the empty string, the # inspectedItem will be the invisible root_item. If the obj_name is given, # an invisible root item will be added and the inspectedItem will be its # only child. In that case the inspected item will be visible. self . _inspected_node_is_visible = obj_name != \"\" if self . _inspected_node_is_visible : self . _root_item = ObjectBrowserTreeItem ( None , \"<invisible_root>\" , \"<invisible_root>\" , None ) self . _root_item . children_fetched = True self . inspected_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . _root_item . append_child ( self . inspected_item ) else : # The root itself will be invisible self . _root_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . inspected_item = self . _root_item # Fetch all items of the root so we can select the first row in the ctor. root_index = self . index ( 0 , 0 ) self . fetchMore ( root_index ) canFetchMore ( self , parent = None ) canFetchMore(self, QModelIndex) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def canFetchMore ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : result = not self . tree_item ( parent ) . children_fetched # logger.debug(\"canFetchMore: {} = {}\".format(parent, result)) return result fetchMore ( self , parent = None ) Fetches the children given the model index of a parent node. Adds the children to the parent. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def fetchMore ( self , parent : Optional [ core . ModelIndex ] = None ): \"\"\"Fetches the children given the model index of a parent node. Adds the children to the parent. \"\"\" parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return parent_item = self . tree_item ( parent ) if parent_item . children_fetched : return tree_items = self . _fetch_object_children ( parent_item . obj , parent_item . obj_path ) with self . insert_rows ( 0 , len ( tree_items ) - 1 , parent ): for tree_item in tree_items : parent_item . append_child ( tree_item ) parent_item . children_fetched = True flags ( self , index ) flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def flags ( self , index : core . ModelIndex ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE hasChildren ( self , parent = None ) hasChildren(self, parent: QModelIndex = QModelIndex()) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def hasChildren ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : return self . tree_item ( parent ) . has_children index ( self , row , column , parent = None ) index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def index ( self , row : int , column : int , parent : Optional [ core . ModelIndex ] = None ) -> core . ModelIndex : if parent is None : logger . debug ( \"parent is None\" ) parent = core . ModelIndex () parent_item = self . tree_item ( parent ) if not self . hasIndex ( row , column , parent ): logger . debug ( \"hasIndex is False: ( %s , %s ) %r \" , row , column , parent_item ) # logger.warn(\"Parent index model: {!r} != {!r}\".format(parent.model(), self)) return core . ModelIndex () child_item = parent_item . child ( row ) # logger.debug(\" {}\".format(child_item.obj_path)) if child_item : return self . createIndex ( row , column , child_item ) else : logger . warn ( \"no child_item\" ) return core . ModelIndex () inspected_index ( self ) The model index that point to the inspectedItem. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def inspected_index ( self ) -> core . ModelIndex : \"\"\"The model index that point to the inspectedItem.\"\"\" if self . inspected_node_is_visible : return self . createIndex ( 0 , 0 , self . inspected_item ) else : return self . root_index () parent ( self , index ) parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def parent ( self , index : core . ModelIndex ) -> QtCore . QModelIndex : # type:ignore if not index . isValid (): return core . ModelIndex () child_item = index . internalPointer () parent_item = child_item . parent () # type: ignore if parent_item is None or parent_item == self . root_item : return core . ModelIndex () return self . createIndex ( parent_item . row (), 0 , parent_item ) refresh_tree ( self ) Refreshes the tree model from the underlying root object. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def refresh_tree ( self ): \"\"\"Refreshes the tree model from the underlying root object.\"\"\" logger . info ( \"\" ) logger . info ( \"refresh_tree: %s \" , self . root_item ) root_item = self . tree_item ( self . root_index ()) logger . info ( \" root_item: %s (idx= %s )\" , root_item , self . root_index ()) inspected_item = self . tree_item ( self . inspected_index ()) logger . info ( \" inspected_item: %s (idx= %s )\" , inspected_item , self . inspected_index () ) assert ( root_item is inspected_item ) != self . inspected_node_is_visible , \"sanity check\" self . _aux_refresh_tree ( self . inspected_index ()) logger . debug ( \"After _aux_refresh_tree, root_obj: %s \" , helpers . cut_off_str ( self . root_item . obj , 80 ), ) self . root_item . pretty_print () # Emit the dataChanged signal for all cells. This is faster than checking which # nodes have changed, which may be slow for some underlying Python objects. bottom_row = self . rowCount () - 1 right_column = self . columnCount () - 1 top_left = self . index ( 0 , 0 ) bottom_right = self . index ( bottom_row , right_column ) logger . debug ( f \"bottom_right: ( { bottom_row } , { right_column } )\" ) self . dataChanged . emit ( top_left , bottom_right ) root_index ( self ) The index that returns the root element (same as an invalid index). Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def root_index ( self ) -> core . ModelIndex : # TODO: needed? \"\"\"The index that returns the root element (same as an invalid index).\"\"\" return core . ModelIndex () rowCount ( self , parent = None ) rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def rowCount ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : # This is taken from the PyQt simpletreemodel example. return 0 else : return self . tree_item ( parent ) . child_count () ObjectBrowserTreeProxyModel Proxy model that overrides the sorting and can filter out items. __init__ ( self , show_callable_attributes = True , show_special_attributes = True , parent = None ) special Constructor. :param show_callable_attributes: if True the callables objects, i.e. objects (such as function) that a call method, will be displayed (in brown). If False they are hidden. :param show_special_attributes: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , show_callable_attributes : bool = True , show_special_attributes : bool = True , parent = None , ): \"\"\"Constructor. :param show_callable_attributes: if True the callables objects, i.e. objects (such as function) that a __call__ method, will be displayed (in brown). If False they are hidden. :param show_special_attributes: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget \"\"\" super () . __init__ ( parent ) self . _show_callables = show_callable_attributes self . _show_special_attributes = show_special_attributes filterAcceptsRow ( self , source_row , source_parent_index ) Return true if the item should be included in the model. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def filterAcceptsRow ( self , source_row : int , source_parent_index : core . ModelIndex ): \"\"\"Return true if the item should be included in the model.\"\"\" parent_item = self . sourceModel () . tree_item ( source_parent_index ) tree_item = parent_item . child ( source_row ) accept = ( self . _show_special_attributes or not tree_item . is_special_attribute ) and ( self . _show_callables or not tree_item . is_callable_attribute ) # logger.debug(\"filterAcceptsRow = {}: {}\".format(accept, tree_item)) return accept first_item_index ( self ) Return the first child of the root item. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def first_item_index ( self ) -> core . ModelIndex : \"\"\"Return the first child of the root item.\"\"\" # We cannot just call the same function of the source model because the first node # there may be hidden. source_root_index = self . sourceModel () . root_index () proxy_root_index = self . mapFromSource ( source_root_index ) first_item_index = self . index ( 0 , 0 , proxy_root_index ) return first_item_index set_show_callables ( self , show_callables ) Show/hide show_callables which have a call attribute. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_callables ( self , show_callables : bool ): \"\"\"Show/hide show_callables which have a __call__ attribute.\"\"\" logger . debug ( \"set_show_callables: %s \" , show_callables ) self . _show_callables = show_callables self . invalidateFilter () set_show_special_attributes ( self , show_special_attributes ) Show/hide special attributes which begin with an underscore. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_special_attributes ( self , show_special_attributes : bool ): \"\"\"Show/hide special attributes which begin with an underscore.\"\"\" logger . debug ( \"set_show_special_attributes: %s \" , show_special_attributes ) self . _show_special_attributes = show_special_attributes self . invalidateFilter ()","title":"objbrowser"},{"location":"api/objbrowser.html#objbrowser-module","text":"","title":"objbrowser module"},{"location":"api/objbrowser.html#prettyqt.objbrowser","text":"Objbrowser package.","title":"prettyqt.objbrowser"},{"location":"api/objbrowser.html#prettyqt.objbrowser.attribute_model","text":"Module that defines AttributeModel.","title":"attribute_model"},{"location":"api/objbrowser.html#prettyqt.objbrowser.attribute_model.safe_data_fn","text":"Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function Source code in prettyqt/objbrowser/attribute_model.py def safe_data_fn ( obj_fn : Callable , log_exceptions : bool = False , ) -> Callable : \"\"\"Create a function that returns an empty string in case of an exception. :param fnobj_fn: function that will be wrapped :type obj_fn: object to basestring function :returns: function that can be used as AttributeModel data_fn attribute :rtype: custom_models.treeitem.TreeItem to string function \"\"\" def data_fn ( tree_item : treeitem . TreeItem ) -> str : \"\"\"Call the obj_fn(tree_item.obj). Returns empty string in case of an error \"\"\" try : return str ( obj_fn ( tree_item . obj )) except Exception as ex : if log_exceptions : logger . exception ( ex ) return \"\" return data_fn","title":"safe_data_fn()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser","text":"Object browser GUI in Qt.","title":"objectbrowser"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser","text":"Object browser main application window.","title":"ObjectBrowser"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.__init__","text":"Constructor. :param obj: any Python object or variable :param name: name of the object as it will appear in the root node Source code in prettyqt/objbrowser/objectbrowser.py def __init__ ( self , obj , name : str = \"\" ): \"\"\"Constructor. :param obj: any Python object or variable :param name: name of the object as it will appear in the root node \"\"\" super () . __init__ () self . _instance_nr = self . _add_instance () self . set_icon ( \"mdi.language-python\" ) # Model self . _attr_cols = DEFAULT_ATTR_COLS self . _attr_details = DEFAULT_ATTR_DETAILS logger . debug ( \"Reading model settings for window: %d \" , self . _instance_nr ) with core . Settings ( settings_id = self . _settings_group_name ( \"model\" )) as settings : self . _auto_refresh = settings . get ( \"auto_refresh\" , False ) logger . debug ( \"read auto_refresh: %r \" , self . _auto_refresh ) self . _refresh_rate = settings . get ( \"refresh_rate\" , 2 ) logger . debug ( \"read refresh_rate: %r \" , self . _refresh_rate ) show_callable_attributes = settings . get ( \"show_callable_attributes\" , True ) logger . debug ( \"read show_callable_attributes: %r \" , show_callable_attributes ) show_special_attributes = settings . get ( \"show_special_attributes\" , True ) logger . debug ( \"read show_special_attributes: %r \" , show_special_attributes ) self . _tree_model = objectbrowsertreemodel . ObjectBrowserTreeModel ( obj , name , attr_cols = self . _attr_cols ) self . _proxy_tree_model = objectbrowsertreemodel . ObjectBrowserTreeProxyModel ( show_callable_attributes = show_callable_attributes , show_special_attributes = show_special_attributes , ) self . _proxy_tree_model . setSourceModel ( self . _tree_model ) # self._proxy_tree_model.setSortRole(RegistryTableModel.SORT_ROLE) self . _proxy_tree_model . setDynamicSortFilter ( True ) # self._proxy_tree_model.setSortCaseSensitivity(Qt.CaseInsensitive) # Views self . _setup_actions () self . _setup_views () self . _setup_menu () self . set_title ( \"Object browser\" ) self . _read_view_settings () assert self . _refresh_rate > 0 self . _refresh_timer = core . Timer ( self ) self . _refresh_timer . setInterval ( self . _refresh_rate * 1000 ) self . _refresh_timer . timeout . connect ( self . _tree_model . refresh_tree ) # Update views with model self . toggle_special_attribute_action . setChecked ( show_special_attributes ) self . toggle_callable_action . setChecked ( show_callable_attributes ) self . toggle_auto_refresh_action . setChecked ( self . _auto_refresh ) # Select first row so that a hidden root node will not be selected. first_row_index = self . _proxy_tree_model . first_item_index () self . obj_tree . setCurrentIndex ( first_row_index ) if self . _tree_model . inspected_node_is_visible : self . obj_tree . expand ( first_row_index )","title":"__init__()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.browse","text":"Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The args and *kwargs will be passed to the ObjectBrowser constructor. Source code in prettyqt/objbrowser/objectbrowser.py @classmethod def browse ( cls , * args , ** kwargs ): \"\"\"Create and run object browser. For this, the following three steps are done: 1) Create QApplication object if it doesn't yet exist 2) Create and show an ObjectBrowser window 3) Start the Qt event loop. The *args and **kwargs will be passed to the ObjectBrowser constructor. \"\"\" cls . app = widgets . app () # keeping reference to prevent garbage collection. cls . app . setOrganizationName ( \"phil65\" ) cls . app . setApplicationName ( \"PrettyQt\" ) object_browser = cls ( * args , ** kwargs ) object_browser . show () object_browser . raise_ () assert cls . app is not None , \"QApplication object doesn't exist yet.\" return cls . app . main_loop ()","title":"browse()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.closeEvent","text":"Called when the window is closed. Source code in prettyqt/objbrowser/objectbrowser.py def closeEvent ( self , event ): \"\"\"Called when the window is closed.\"\"\" logger . debug ( \"closeEvent\" ) self . _write_model_settings () self . _write_view_settings () self . _finalize () self . close () event . accept () \"\"\"Set the reference in the browser list to None.\"\"\" idx = self . _browsers . index ( self ) self . _browsers [ idx ] = None logger . debug ( \"Closed window %s \" , self . _instance_nr )","title":"closeEvent()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowser.ObjectBrowser.toggle_auto_refresh","text":"Toggle auto-refresh on/off. Source code in prettyqt/objbrowser/objectbrowser.py def toggle_auto_refresh ( self , checked ): \"\"\"Toggle auto-refresh on/off.\"\"\" if checked : logger . info ( \"Auto-refresh on. Rate %g seconds\" , self . _refresh_rate ) self . _refresh_timer . start () else : logger . info ( \"Auto-refresh off\" ) self . _refresh_timer . stop () self . _auto_refresh = checked","title":"toggle_auto_refresh()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel","text":"Module that defines the TreeModel. https://github.com/PySide/Examples/blob/master/examples/itemviews/simpletreemodel /simpletreemodel.py","title":"objectbrowsertreemodel"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem","text":"Tree node class that can be used to build trees of objects.","title":"ObjectBrowserTreeItem"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem.is_callable_attribute","text":"Return true if the items is an attribute and it is callable.","title":"is_callable_attribute"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeItem.is_special_attribute","text":"Return true if the item represents a dunder attribute.","title":"is_special_attribute"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel","text":"Model that provides an interface to an objectree that is build of tree items.","title":"ObjectBrowserTreeModel"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.inspected_node_is_visible","text":"Return True if the inspected node is visible. In that case an invisible root node has been added.","title":"inspected_node_is_visible"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.root_item","text":"The root ObjectBrowserTreeItem.","title":"root_item"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.__init__","text":"Constructor. Parameters: Name Type Description Default obj Any Object to inspect required obj_name str Name of the object '' attr_cols Optional[List[custom_models.ColumnItem]] List of Column items None parent Optional[QtCore.QObject] Description None Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , obj : Any , obj_name : str = \"\" , attr_cols : Optional [ List [ custom_models . ColumnItem ]] = None , parent : Optional [ QtCore . QObject ] = None , ): \"\"\"Constructor. Args: obj (Any): Object to inspect obj_name (str, optional): Name of the object attr_cols (None, optional): List of Column items parent (None, optional): Description \"\"\" super () . __init__ ( attr_cols = attr_cols , parent = parent ) # The root_item is always invisible. If the obj_name is the empty string, the # inspectedItem will be the invisible root_item. If the obj_name is given, # an invisible root item will be added and the inspectedItem will be its # only child. In that case the inspected item will be visible. self . _inspected_node_is_visible = obj_name != \"\" if self . _inspected_node_is_visible : self . _root_item = ObjectBrowserTreeItem ( None , \"<invisible_root>\" , \"<invisible_root>\" , None ) self . _root_item . children_fetched = True self . inspected_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . _root_item . append_child ( self . inspected_item ) else : # The root itself will be invisible self . _root_item = ObjectBrowserTreeItem ( obj , obj_name , obj_name , is_attribute = None ) self . inspected_item = self . _root_item # Fetch all items of the root so we can select the first row in the ctor. root_index = self . index ( 0 , 0 ) self . fetchMore ( root_index )","title":"__init__()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.canFetchMore","text":"canFetchMore(self, QModelIndex) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def canFetchMore ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : result = not self . tree_item ( parent ) . children_fetched # logger.debug(\"canFetchMore: {} = {}\".format(parent, result)) return result","title":"canFetchMore()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.fetchMore","text":"Fetches the children given the model index of a parent node. Adds the children to the parent. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def fetchMore ( self , parent : Optional [ core . ModelIndex ] = None ): \"\"\"Fetches the children given the model index of a parent node. Adds the children to the parent. \"\"\" parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return parent_item = self . tree_item ( parent ) if parent_item . children_fetched : return tree_items = self . _fetch_object_children ( parent_item . obj , parent_item . obj_path ) with self . insert_rows ( 0 , len ( tree_items ) - 1 , parent ): for tree_item in tree_items : parent_item . append_child ( tree_item ) parent_item . children_fetched = True","title":"fetchMore()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.flags","text":"flags(self, QModelIndex) -> Qt.ItemFlags Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def flags ( self , index : core . ModelIndex ): if not index . isValid (): return constants . NO_CHILDREN return constants . IS_ENABLED | constants . IS_SELECTABLE","title":"flags()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.hasChildren","text":"hasChildren(self, parent: QModelIndex = QModelIndex()) -> bool Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def hasChildren ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : return 0 else : return self . tree_item ( parent ) . has_children","title":"hasChildren()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.index","text":"index(self, int, int, parent: QModelIndex = QModelIndex()) -> QModelIndex Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def index ( self , row : int , column : int , parent : Optional [ core . ModelIndex ] = None ) -> core . ModelIndex : if parent is None : logger . debug ( \"parent is None\" ) parent = core . ModelIndex () parent_item = self . tree_item ( parent ) if not self . hasIndex ( row , column , parent ): logger . debug ( \"hasIndex is False: ( %s , %s ) %r \" , row , column , parent_item ) # logger.warn(\"Parent index model: {!r} != {!r}\".format(parent.model(), self)) return core . ModelIndex () child_item = parent_item . child ( row ) # logger.debug(\" {}\".format(child_item.obj_path)) if child_item : return self . createIndex ( row , column , child_item ) else : logger . warn ( \"no child_item\" ) return core . ModelIndex ()","title":"index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.inspected_index","text":"The model index that point to the inspectedItem. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def inspected_index ( self ) -> core . ModelIndex : \"\"\"The model index that point to the inspectedItem.\"\"\" if self . inspected_node_is_visible : return self . createIndex ( 0 , 0 , self . inspected_item ) else : return self . root_index ()","title":"inspected_index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.parent","text":"parent(self, QModelIndex) -> QModelIndex parent(self) -> QObject Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def parent ( self , index : core . ModelIndex ) -> QtCore . QModelIndex : # type:ignore if not index . isValid (): return core . ModelIndex () child_item = index . internalPointer () parent_item = child_item . parent () # type: ignore if parent_item is None or parent_item == self . root_item : return core . ModelIndex () return self . createIndex ( parent_item . row (), 0 , parent_item )","title":"parent()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.refresh_tree","text":"Refreshes the tree model from the underlying root object. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def refresh_tree ( self ): \"\"\"Refreshes the tree model from the underlying root object.\"\"\" logger . info ( \"\" ) logger . info ( \"refresh_tree: %s \" , self . root_item ) root_item = self . tree_item ( self . root_index ()) logger . info ( \" root_item: %s (idx= %s )\" , root_item , self . root_index ()) inspected_item = self . tree_item ( self . inspected_index ()) logger . info ( \" inspected_item: %s (idx= %s )\" , inspected_item , self . inspected_index () ) assert ( root_item is inspected_item ) != self . inspected_node_is_visible , \"sanity check\" self . _aux_refresh_tree ( self . inspected_index ()) logger . debug ( \"After _aux_refresh_tree, root_obj: %s \" , helpers . cut_off_str ( self . root_item . obj , 80 ), ) self . root_item . pretty_print () # Emit the dataChanged signal for all cells. This is faster than checking which # nodes have changed, which may be slow for some underlying Python objects. bottom_row = self . rowCount () - 1 right_column = self . columnCount () - 1 top_left = self . index ( 0 , 0 ) bottom_right = self . index ( bottom_row , right_column ) logger . debug ( f \"bottom_right: ( { bottom_row } , { right_column } )\" ) self . dataChanged . emit ( top_left , bottom_right )","title":"refresh_tree()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.root_index","text":"The index that returns the root element (same as an invalid index). Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def root_index ( self ) -> core . ModelIndex : # TODO: needed? \"\"\"The index that returns the root element (same as an invalid index).\"\"\" return core . ModelIndex ()","title":"root_index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeModel.rowCount","text":"rowCount(self, parent: QModelIndex = QModelIndex()) -> int Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def rowCount ( self , parent : Optional [ core . ModelIndex ] = None ): parent = core . ModelIndex () if parent is None else parent if parent . column () > 0 : # This is taken from the PyQt simpletreemodel example. return 0 else : return self . tree_item ( parent ) . child_count ()","title":"rowCount()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel","text":"Proxy model that overrides the sorting and can filter out items.","title":"ObjectBrowserTreeProxyModel"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.__init__","text":"Constructor. :param show_callable_attributes: if True the callables objects, i.e. objects (such as function) that a call method, will be displayed (in brown). If False they are hidden. :param show_special_attributes: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def __init__ ( self , show_callable_attributes : bool = True , show_special_attributes : bool = True , parent = None , ): \"\"\"Constructor. :param show_callable_attributes: if True the callables objects, i.e. objects (such as function) that a __call__ method, will be displayed (in brown). If False they are hidden. :param show_special_attributes: if True the objects special attributes, i.e. methods with a name that starts and ends with two underscores, will be displayed (in italics). If False they are hidden. :param parent: the parent widget \"\"\" super () . __init__ ( parent ) self . _show_callables = show_callable_attributes self . _show_special_attributes = show_special_attributes","title":"__init__()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.filterAcceptsRow","text":"Return true if the item should be included in the model. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def filterAcceptsRow ( self , source_row : int , source_parent_index : core . ModelIndex ): \"\"\"Return true if the item should be included in the model.\"\"\" parent_item = self . sourceModel () . tree_item ( source_parent_index ) tree_item = parent_item . child ( source_row ) accept = ( self . _show_special_attributes or not tree_item . is_special_attribute ) and ( self . _show_callables or not tree_item . is_callable_attribute ) # logger.debug(\"filterAcceptsRow = {}: {}\".format(accept, tree_item)) return accept","title":"filterAcceptsRow()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.first_item_index","text":"Return the first child of the root item. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def first_item_index ( self ) -> core . ModelIndex : \"\"\"Return the first child of the root item.\"\"\" # We cannot just call the same function of the source model because the first node # there may be hidden. source_root_index = self . sourceModel () . root_index () proxy_root_index = self . mapFromSource ( source_root_index ) first_item_index = self . index ( 0 , 0 , proxy_root_index ) return first_item_index","title":"first_item_index()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.set_show_callables","text":"Show/hide show_callables which have a call attribute. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_callables ( self , show_callables : bool ): \"\"\"Show/hide show_callables which have a __call__ attribute.\"\"\" logger . debug ( \"set_show_callables: %s \" , show_callables ) self . _show_callables = show_callables self . invalidateFilter ()","title":"set_show_callables()"},{"location":"api/objbrowser.html#prettyqt.objbrowser.objectbrowsertreemodel.ObjectBrowserTreeProxyModel.set_show_special_attributes","text":"Show/hide special attributes which begin with an underscore. Source code in prettyqt/objbrowser/objectbrowsertreemodel.py def set_show_special_attributes ( self , show_special_attributes : bool ): \"\"\"Show/hide special attributes which begin with an underscore.\"\"\" logger . debug ( \"set_show_special_attributes: %s \" , show_special_attributes ) self . _show_special_attributes = show_special_attributes self . invalidateFilter ()","title":"set_show_special_attributes()"},{"location":"api/positioning.html","text":"positioning module Positioning module. Contains QtPositioning-based classes geoareamonitorsource GeoAreaMonitorSource get_error ( self ) Return error type. Returns: Type Description Literal['persistent_area', 'any_area'] error type Source code in prettyqt/positioning/geoareamonitorsource.py def get_error ( self ) -> AreaMonitorFeatureStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()] geopositioninfosource GeoPositionInfoSource get_error ( self ) Return error type. Returns: Type Description Literal['access_error', 'closed_error', 'none', 'unknown_source'] error type Source code in prettyqt/positioning/geopositioninfosource.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()] get_preferred_positioning_methods ( self ) Return list of preferred positioning methods. Returns: Type Description List[Literal['none', 'satellite', 'non_satellite', 'all']] list of preferred positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_preferred_positioning_methods ( self ) -> List [ PositioningMethodStr ]: \"\"\"Return list of preferred positioning methods. Returns: list of preferred positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . preferredPositioningMethods () ] get_supported_positioning_methods ( self ) Return list of supported positioning methods. Returns: Type Description List[Literal['none', 'satellite', 'non_satellite', 'all']] list of supported positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_supported_positioning_methods ( self ) -> List [ PositioningMethodStr ]: \"\"\"Return list of supported positioning methods. Returns: list of supported positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . supportedPositioningMethods () ] set_preferred_positioning_methods ( self , * methods ) Set preferred positioning methods. Parameters: Name Type Description Default methods Literal['none', 'satellite', 'non_satellite', 'all'] positioning methods to use () Exceptions: Type Description InvalidParamError invalid positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def set_preferred_positioning_methods ( self , * methods : PositioningMethodStr ): \"\"\"Set preferred positioning methods. Args: methods: positioning methods to use Raises: InvalidParamError: invalid positioning methods \"\"\" for item in methods : if item not in POSITIONING_METHODS : raise InvalidParamError ( item , POSITIONING_METHODS ) flags = helpers . merge_flags ( methods , POSITIONING_METHODS ) self . setPreferredPositioningMethods ( flags ) geosatelliteinfo GeoSatelliteInfo get_satellite_system ( self ) Return satellite system. Returns: Type Description Literal['undefined', 'gps', 'glonass'] satellite system Source code in prettyqt/positioning/geosatelliteinfo.py def get_satellite_system ( self ) -> SatelliteSystemStr : \"\"\"Return satellite system. Returns: satellite system \"\"\" return SATELLITE_SYSTEMS . inverse [ self . satelliteSystem ()] set_satellite_system ( self , system ) Set satellite system. Parameters: Name Type Description Default system Literal['undefined', 'gps', 'glonass'] satellite system to use required Exceptions: Type Description InvalidParamError invalid system Source code in prettyqt/positioning/geosatelliteinfo.py def set_satellite_system ( self , system : SatelliteSystemStr ): \"\"\"Set satellite system. Args: system: satellite system to use Raises: InvalidParamError: invalid system \"\"\" if system not in SATELLITE_SYSTEMS : raise InvalidParamError ( system , SATELLITE_SYSTEMS ) self . setSatelliteSystem ( SATELLITE_SYSTEMS [ system ]) geosatelliteinfosource GeoSatelliteInfoSource get_error ( self ) Return error type. Returns: Type Description Literal['access_error', 'closed_error', 'none', 'unknown_source'] error type Source code in prettyqt/positioning/geosatelliteinfosource.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERROR . inverse [ self . error ()]","title":"positioning"},{"location":"api/positioning.html#positioning-module","text":"","title":"positioning module"},{"location":"api/positioning.html#prettyqt.positioning","text":"Positioning module. Contains QtPositioning-based classes","title":"prettyqt.positioning"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource","text":"","title":"geoareamonitorsource"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource.GeoAreaMonitorSource","text":"","title":"GeoAreaMonitorSource"},{"location":"api/positioning.html#prettyqt.positioning.geoareamonitorsource.GeoAreaMonitorSource.get_error","text":"Return error type. Returns: Type Description Literal['persistent_area', 'any_area'] error type Source code in prettyqt/positioning/geoareamonitorsource.py def get_error ( self ) -> AreaMonitorFeatureStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()]","title":"get_error()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource","text":"","title":"geopositioninfosource"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource","text":"","title":"GeoPositionInfoSource"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.get_error","text":"Return error type. Returns: Type Description Literal['access_error', 'closed_error', 'none', 'unknown_source'] error type Source code in prettyqt/positioning/geopositioninfosource.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERRORS . inverse [ self . error ()]","title":"get_error()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.get_preferred_positioning_methods","text":"Return list of preferred positioning methods. Returns: Type Description List[Literal['none', 'satellite', 'non_satellite', 'all']] list of preferred positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_preferred_positioning_methods ( self ) -> List [ PositioningMethodStr ]: \"\"\"Return list of preferred positioning methods. Returns: list of preferred positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . preferredPositioningMethods () ]","title":"get_preferred_positioning_methods()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.get_supported_positioning_methods","text":"Return list of supported positioning methods. Returns: Type Description List[Literal['none', 'satellite', 'non_satellite', 'all']] list of supported positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def get_supported_positioning_methods ( self ) -> List [ PositioningMethodStr ]: \"\"\"Return list of supported positioning methods. Returns: list of supported positioning methods \"\"\" return [ k for k , v in POSITIONING_METHODS . items () if v & self . supportedPositioningMethods () ]","title":"get_supported_positioning_methods()"},{"location":"api/positioning.html#prettyqt.positioning.geopositioninfosource.GeoPositionInfoSource.set_preferred_positioning_methods","text":"Set preferred positioning methods. Parameters: Name Type Description Default methods Literal['none', 'satellite', 'non_satellite', 'all'] positioning methods to use () Exceptions: Type Description InvalidParamError invalid positioning methods Source code in prettyqt/positioning/geopositioninfosource.py def set_preferred_positioning_methods ( self , * methods : PositioningMethodStr ): \"\"\"Set preferred positioning methods. Args: methods: positioning methods to use Raises: InvalidParamError: invalid positioning methods \"\"\" for item in methods : if item not in POSITIONING_METHODS : raise InvalidParamError ( item , POSITIONING_METHODS ) flags = helpers . merge_flags ( methods , POSITIONING_METHODS ) self . setPreferredPositioningMethods ( flags )","title":"set_preferred_positioning_methods()"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo","text":"","title":"geosatelliteinfo"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo","text":"","title":"GeoSatelliteInfo"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.get_satellite_system","text":"Return satellite system. Returns: Type Description Literal['undefined', 'gps', 'glonass'] satellite system Source code in prettyqt/positioning/geosatelliteinfo.py def get_satellite_system ( self ) -> SatelliteSystemStr : \"\"\"Return satellite system. Returns: satellite system \"\"\" return SATELLITE_SYSTEMS . inverse [ self . satelliteSystem ()]","title":"get_satellite_system()"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfo.GeoSatelliteInfo.set_satellite_system","text":"Set satellite system. Parameters: Name Type Description Default system Literal['undefined', 'gps', 'glonass'] satellite system to use required Exceptions: Type Description InvalidParamError invalid system Source code in prettyqt/positioning/geosatelliteinfo.py def set_satellite_system ( self , system : SatelliteSystemStr ): \"\"\"Set satellite system. Args: system: satellite system to use Raises: InvalidParamError: invalid system \"\"\" if system not in SATELLITE_SYSTEMS : raise InvalidParamError ( system , SATELLITE_SYSTEMS ) self . setSatelliteSystem ( SATELLITE_SYSTEMS [ system ])","title":"set_satellite_system()"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource","text":"","title":"geosatelliteinfosource"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource.GeoSatelliteInfoSource","text":"","title":"GeoSatelliteInfoSource"},{"location":"api/positioning.html#prettyqt.positioning.geosatelliteinfosource.GeoSatelliteInfoSource.get_error","text":"Return error type. Returns: Type Description Literal['access_error', 'closed_error', 'none', 'unknown_source'] error type Source code in prettyqt/positioning/geosatelliteinfosource.py def get_error ( self ) -> ErrorStr : \"\"\"Return error type. Returns: error type \"\"\" return ERROR . inverse [ self . error ()]","title":"get_error()"},{"location":"api/qml.html","text":"qml module Qml module. Contains QtQml-based classes jsvalue JSValue from_object ( obj , jsengine ) classmethod Convert any python object into a QJSValue (must happen in GUI thread). Source code in prettyqt/qml/jsvalue.py @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls () qmlengine QmlEngine get_object_ownership ( self , obj ) Return object ownership. Returns: Type Description Literal['cpp', 'javascript'] object ownership Source code in prettyqt/qml/qmlengine.py def get_object_ownership ( self , obj : QtCore . QObject ) -> ObjectOwnershipStr : \"\"\"Return object ownership. Returns: object ownership \"\"\" return OBJECT_OWNERSHIP . inverse [ self . objectOwnership ( obj )] set_object_ownership ( self , obj , mode ) Set the object ownership. Parameters: Name Type Description Default mode Literal['cpp', 'javascript'] object ownership to use required Exceptions: Type Description InvalidParamError invalid object ownership Source code in prettyqt/qml/qmlengine.py def set_object_ownership ( self , obj : QtCore . QObject , mode : ObjectOwnershipStr ): \"\"\"Set the object ownership. Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIP : raise InvalidParamError ( mode , OBJECT_OWNERSHIP ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIP [ mode ])","title":"qml"},{"location":"api/qml.html#qml-module","text":"","title":"qml module"},{"location":"api/qml.html#prettyqt.qml","text":"Qml module. Contains QtQml-based classes","title":"prettyqt.qml"},{"location":"api/qml.html#prettyqt.qml.jsvalue","text":"","title":"jsvalue"},{"location":"api/qml.html#prettyqt.qml.jsvalue.JSValue","text":"","title":"JSValue"},{"location":"api/qml.html#prettyqt.qml.jsvalue.JSValue.from_object","text":"Convert any python object into a QJSValue (must happen in GUI thread). Source code in prettyqt/qml/jsvalue.py @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls ()","title":"from_object()"},{"location":"api/qml.html#prettyqt.qml.qmlengine","text":"","title":"qmlengine"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngine","text":"","title":"QmlEngine"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngine.get_object_ownership","text":"Return object ownership. Returns: Type Description Literal['cpp', 'javascript'] object ownership Source code in prettyqt/qml/qmlengine.py def get_object_ownership ( self , obj : QtCore . QObject ) -> ObjectOwnershipStr : \"\"\"Return object ownership. Returns: object ownership \"\"\" return OBJECT_OWNERSHIP . inverse [ self . objectOwnership ( obj )]","title":"get_object_ownership()"},{"location":"api/qml.html#prettyqt.qml.qmlengine.QmlEngine.set_object_ownership","text":"Set the object ownership. Parameters: Name Type Description Default mode Literal['cpp', 'javascript'] object ownership to use required Exceptions: Type Description InvalidParamError invalid object ownership Source code in prettyqt/qml/qmlengine.py def set_object_ownership ( self , obj : QtCore . QObject , mode : ObjectOwnershipStr ): \"\"\"Set the object ownership. Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIP : raise InvalidParamError ( mode , OBJECT_OWNERSHIP ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIP [ mode ])","title":"set_object_ownership()"},{"location":"api/qthelp.html","text":"qthelp module qthelp module. contains QtHelp-based classes","title":"qthelp"},{"location":"api/qthelp.html#qthelp-module","text":"","title":"qthelp module"},{"location":"api/qthelp.html#prettyqt.qthelp","text":"qthelp module. contains QtHelp-based classes","title":"prettyqt.qthelp"},{"location":"api/quick.html","text":"quick module quick module. contains QtQuick-based classes quickitem QuickItem get_transform_origin ( self ) Return the render type of text-like elements in Qt Quick. Returns: Type Description Literal['top_left', 'top', 'top_right', 'left', 'center', 'right', 'bottom_left', 'bottom', 'bottom_right'] transform origin Source code in prettyqt/quick/quickitem.py def get_transform_origin ( self ) -> TransformOriginStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: transform origin \"\"\" return TRANSFORM_ORIGIN . inverse [ self . transformOrigin ()] set_transform_origin ( self , origin ) Set the origin point around which scale and rotation transform. The default is \"center\". Parameters: Name Type Description Default origin Literal['top_left', 'top', 'top_right', 'left', 'center', 'right', 'bottom_left', 'bottom', 'bottom_right'] transform origin to use required Exceptions: Type Description InvalidParamError transform origin does not exist Source code in prettyqt/quick/quickitem.py def set_transform_origin ( self , origin : TransformOriginStr ): \"\"\"Set the origin point around which scale and rotation transform. The default is \"center\". Args: origin: transform origin to use Raises: InvalidParamError: transform origin does not exist \"\"\" if origin not in TRANSFORM_ORIGIN : raise InvalidParamError ( origin , TRANSFORM_ORIGIN ) self . setTransformOrigin ( TRANSFORM_ORIGIN [ origin ]) quickpainteditem QuickPaintedItem get_render_target ( self ) Return the render target. Returns: Type Description Literal['image', 'framebuffer_objectinverted_y_framebuffer_object'] render target Source code in prettyqt/quick/quickpainteditem.py def get_render_target ( self ) -> RenderTargetStr : \"\"\"Return the render target. Returns: render target \"\"\" return RENDER_TARGET . inverse [ self . renderTarget ()] set_render_target ( self , target ) Set the render target. Parameters: Name Type Description Default target Literal['image', 'framebuffer_objectinverted_y_framebuffer_object'] render target to use required Exceptions: Type Description InvalidParamError render target does not exist Source code in prettyqt/quick/quickpainteditem.py def set_render_target ( self , target : RenderTargetStr ): \"\"\"Set the render target. Args: target: render target to use Raises: InvalidParamError: render target does not exist \"\"\" if target not in RENDER_TARGET : raise InvalidParamError ( target , RENDER_TARGET ) self . setRenderTarget ( RENDER_TARGET [ target ]) quickwindow QuickWindow get_text_render_type () staticmethod Return the render type of text-like elements in Qt Quick. Returns: Type Description Literal['qt_text', 'native_text'] text render type Source code in prettyqt/quick/quickwindow.py @staticmethod def get_text_render_type () -> TextRenderTypeStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: text render type \"\"\" return TEXT_RENDER_TYPE . inverse [ QuickWindow . textRenderType ()] set_text_render_type ( typ ) staticmethod Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Parameters: Name Type Description Default typ Literal['qt_text', 'native_text'] text render type to use required Exceptions: Type Description InvalidParamError text render type does not exist Source code in prettyqt/quick/quickwindow.py @staticmethod def set_text_render_type ( typ : TextRenderTypeStr ): \"\"\"Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Args: typ: text render type to use Raises: InvalidParamError: text render type does not exist \"\"\" if typ not in TEXT_RENDER_TYPE : raise InvalidParamError ( typ , TEXT_RENDER_TYPE ) QuickWindow . setTextRenderType ( TEXT_RENDER_TYPE [ typ ])","title":"quick"},{"location":"api/quick.html#quick-module","text":"","title":"quick module"},{"location":"api/quick.html#prettyqt.quick","text":"quick module. contains QtQuick-based classes","title":"prettyqt.quick"},{"location":"api/quick.html#prettyqt.quick.quickitem","text":"","title":"quickitem"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItem","text":"","title":"QuickItem"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItem.get_transform_origin","text":"Return the render type of text-like elements in Qt Quick. Returns: Type Description Literal['top_left', 'top', 'top_right', 'left', 'center', 'right', 'bottom_left', 'bottom', 'bottom_right'] transform origin Source code in prettyqt/quick/quickitem.py def get_transform_origin ( self ) -> TransformOriginStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: transform origin \"\"\" return TRANSFORM_ORIGIN . inverse [ self . transformOrigin ()]","title":"get_transform_origin()"},{"location":"api/quick.html#prettyqt.quick.quickitem.QuickItem.set_transform_origin","text":"Set the origin point around which scale and rotation transform. The default is \"center\". Parameters: Name Type Description Default origin Literal['top_left', 'top', 'top_right', 'left', 'center', 'right', 'bottom_left', 'bottom', 'bottom_right'] transform origin to use required Exceptions: Type Description InvalidParamError transform origin does not exist Source code in prettyqt/quick/quickitem.py def set_transform_origin ( self , origin : TransformOriginStr ): \"\"\"Set the origin point around which scale and rotation transform. The default is \"center\". Args: origin: transform origin to use Raises: InvalidParamError: transform origin does not exist \"\"\" if origin not in TRANSFORM_ORIGIN : raise InvalidParamError ( origin , TRANSFORM_ORIGIN ) self . setTransformOrigin ( TRANSFORM_ORIGIN [ origin ])","title":"set_transform_origin()"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem","text":"","title":"quickpainteditem"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem","text":"","title":"QuickPaintedItem"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.get_render_target","text":"Return the render target. Returns: Type Description Literal['image', 'framebuffer_objectinverted_y_framebuffer_object'] render target Source code in prettyqt/quick/quickpainteditem.py def get_render_target ( self ) -> RenderTargetStr : \"\"\"Return the render target. Returns: render target \"\"\" return RENDER_TARGET . inverse [ self . renderTarget ()]","title":"get_render_target()"},{"location":"api/quick.html#prettyqt.quick.quickpainteditem.QuickPaintedItem.set_render_target","text":"Set the render target. Parameters: Name Type Description Default target Literal['image', 'framebuffer_objectinverted_y_framebuffer_object'] render target to use required Exceptions: Type Description InvalidParamError render target does not exist Source code in prettyqt/quick/quickpainteditem.py def set_render_target ( self , target : RenderTargetStr ): \"\"\"Set the render target. Args: target: render target to use Raises: InvalidParamError: render target does not exist \"\"\" if target not in RENDER_TARGET : raise InvalidParamError ( target , RENDER_TARGET ) self . setRenderTarget ( RENDER_TARGET [ target ])","title":"set_render_target()"},{"location":"api/quick.html#prettyqt.quick.quickwindow","text":"","title":"quickwindow"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow","text":"","title":"QuickWindow"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow.get_text_render_type","text":"Return the render type of text-like elements in Qt Quick. Returns: Type Description Literal['qt_text', 'native_text'] text render type Source code in prettyqt/quick/quickwindow.py @staticmethod def get_text_render_type () -> TextRenderTypeStr : \"\"\"Return the render type of text-like elements in Qt Quick. Returns: text render type \"\"\" return TEXT_RENDER_TYPE . inverse [ QuickWindow . textRenderType ()]","title":"get_text_render_type()"},{"location":"api/quick.html#prettyqt.quick.quickwindow.QuickWindow.set_text_render_type","text":"Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Parameters: Name Type Description Default typ Literal['qt_text', 'native_text'] text render type to use required Exceptions: Type Description InvalidParamError text render type does not exist Source code in prettyqt/quick/quickwindow.py @staticmethod def set_text_render_type ( typ : TextRenderTypeStr ): \"\"\"Set the default render type of text-like elements in Qt Quick. Note: setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified. Args: typ: text render type to use Raises: InvalidParamError: text render type does not exist \"\"\" if typ not in TEXT_RENDER_TYPE : raise InvalidParamError ( typ , TEXT_RENDER_TYPE ) QuickWindow . setTextRenderType ( TEXT_RENDER_TYPE [ typ ])","title":"set_text_render_type()"},{"location":"api/scintilla.html","text":"scintilla module Module containing QSciScintilla-related classes. sciscintilla SciScintilla scroll_to_bottom ( self ) Scroll to the bottom of the scroll area. Source code in prettyqt/scintilla/sciscintilla.py def scroll_to_bottom ( self ): self . ensureLineVisible ( self . lines ())","title":"scintilla"},{"location":"api/scintilla.html#scintilla-module","text":"","title":"scintilla module"},{"location":"api/scintilla.html#prettyqt.scintilla","text":"Module containing QSciScintilla-related classes.","title":"prettyqt.scintilla"},{"location":"api/scintilla.html#prettyqt.scintilla.sciscintilla","text":"","title":"sciscintilla"},{"location":"api/scintilla.html#prettyqt.scintilla.sciscintilla.SciScintilla","text":"","title":"SciScintilla"},{"location":"api/scintilla.html#prettyqt.scintilla.sciscintilla.SciScintilla.scroll_to_bottom","text":"Scroll to the bottom of the scroll area. Source code in prettyqt/scintilla/sciscintilla.py def scroll_to_bottom ( self ): self . ensureLineVisible ( self . lines ())","title":"scroll_to_bottom()"},{"location":"api/svg.html","text":"svg module svg module. contains QtSvg-based classes","title":"svg"},{"location":"api/svg.html#svg-module","text":"","title":"svg module"},{"location":"api/svg.html#prettyqt.svg","text":"svg module. contains QtSvg-based classes","title":"prettyqt.svg"},{"location":"api/syntaxhighlighters.html","text":"syntaxhighlighters module syntaxhighlighters module. contains some custom syntax highlighers highlightrule HighlightRule dataclass HighlightRule(regex: Union[str, List[str]] = '', color: str = 'black', italic: bool = False, bold: bool = False, minimal: bool = False, font_size: Union[float, NoneType] = None, nth: int = 0, fmt: prettyqt.gui.textcharformat.TextCharFormat = TextCharFormat(2)) __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format () jsonhighlighter JsonHighlighter highlightBlock ( self , text ) Highlight a block of code using the rules outlined in the Constructor. Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT ) markdownhighlighter Syntax highlighter for Markdown markup language. MarkdownHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE ) pygmentshighlighter PygmentsHighlighter Syntax highlighter that uses Pygments for parsing. highlightBlock ( self , string ) Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack set_style ( self , style ) Sets the style to the specified Pygments style. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style ( self , style : Union [ str , Style ]): \"\"\"Sets the style to the specified Pygments style.\"\"\" if isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches () set_style_sheet ( self , stylesheet ) Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style_sheet ( self , stylesheet : str ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches () get_tokens_unprocessed ( self , text , stack = ( 'root' ,)) Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def get_tokens_unprocessed ( self , text : str , stack = ( \"root\" ,)): \"\"\"Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while 1 : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if type ( action ) is _TokenType : yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , \"wrong state def: %r \" % new_state statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" pos += 1 statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos , Text , \" \\n \" continue yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack ) qstring_length ( text ) Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def qstring_length ( text : str ) -> int : \"\"\"Tries to compute what the length of an utf16-encoded QString would be.\"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length pythonhighlighter Syntax highlighter for the programming language Python. PythonHighlighter Syntax highlighter for the Python language. highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE ) match_multiline ( self , text , delimiter , in_state , style ) Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def match_multiline ( self , text , delimiter , in_state , style ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : match = delimiter . match ( text ) if not match . hasMatch (): return start = match . capturedStart () add = match . capturedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter match = delimiter . match ( text , start + add ) end = match . capturedStart () # Ending delimiter on this line? if end >= add : length = end - start + add + match . capturedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . match ( text , start + length ) . capturedStart () # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state regexmatchhighlighter RegexMatchHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i ) xmlhighlighter Based on http://www.yasinuludag.com/blog/?p=49 . XmlHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . match ( text ) . capturedStart () while start_index >= 0 : match = VALUE_END_EXPRESSION . match ( text , start_index ) end_index = match . capturedStart () if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : comment_len = end_index - start_index + match . capturedLength () self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . match ( text , start_index + comment_len ) . capturedStart () yamlhighlighter YamlHighlighter highlightBlock ( self , text ) Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . match ( text ) . capturedStart () if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"syntaxhighlighters"},{"location":"api/syntaxhighlighters.html#syntaxhighlighters-module","text":"","title":"syntaxhighlighters module"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters","text":"syntaxhighlighters module. contains some custom syntax highlighers","title":"prettyqt.syntaxhighlighters"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule","text":"","title":"highlightrule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule","text":"HighlightRule(regex: Union[str, List[str]] = '', color: str = 'black', italic: bool = False, bold: bool = False, minimal: bool = False, font_size: Union[float, NoneType] = None, nth: int = 0, fmt: prettyqt.gui.textcharformat.TextCharFormat = TextCharFormat(2))","title":"HighlightRule"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.highlightrule.HighlightRule.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in prettyqt/syntaxhighlighters/highlightrule.py def __init_subclass__ ( cls ): super () . __init_subclass__ () if isinstance ( cls . regex , str ): cls . compiled = re . compile ( cls . regex ) # cls.compiled.setMinimal(True) else : cls . compiled = [ re . compile ( r ) for r in cls . regex ] cls . fmt = cls . get_format ()","title":"__init_subclass__()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter","text":"","title":"jsonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter","text":"","title":"JsonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.jsonhighlighter.JsonHighlighter.highlightBlock","text":"Highlight a block of code using the rules outlined in the Constructor. Source code in prettyqt/syntaxhighlighters/jsonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Highlight a block of code using the rules outlined in the Constructor.\"\"\" for m in BRACKETS . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], SYMBOL_FORMAT ) text . replace ( ' \\\\ \"' , \" \" ) for m in REGEXP1 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], NAME_FORMAT ) for m in REGEXP2 . finditer ( text ): self . setFormat ( m . span ()[ 0 ], m . span ()[ 1 ] - m . span ()[ 0 ], VALUE_FORMAT )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter","text":"Syntax highlighter for Markdown markup language.","title":"markdownhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter","text":"","title":"MarkdownHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.markdownhighlighter.MarkdownHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/markdownhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) self . _match_multiline ( text , * TRI_SINGLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter","text":"","title":"pygmentshighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter","text":"Syntax highlighter that uses Pygments for parsing.","title":"PygmentsHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.highlightBlock","text":"Highlight a block of text. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def highlightBlock ( self , string ): \"\"\"Highlight a block of text.\"\"\" prev_data = self . currentBlock () . previous () . userData () if prev_data is not None : self . _lexer . _saved_state_stack = prev_data . syntax_stack elif hasattr ( self . _lexer , \"_saved_state_stack\" ): del self . _lexer . _saved_state_stack # Lex the text using Pygments index = 0 for token , text in self . _lexer . get_tokens ( string ): length = qstring_length ( text ) self . setFormat ( index , length , self . _get_format ( token )) index += length if hasattr ( self . _lexer , \"_saved_state_stack\" ): data = gui . TextBlockUserData ( syntax_stack = self . _lexer . _saved_state_stack ) self . currentBlock () . setUserData ( data ) # Clean up for the next go-round. del self . _lexer . _saved_state_stack","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style","text":"Sets the style to the specified Pygments style. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style ( self , style : Union [ str , Style ]): \"\"\"Sets the style to the specified Pygments style.\"\"\" if isinstance ( style , str ): style = get_style_by_name ( style ) self . _style = style self . _clear_caches ()","title":"set_style()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.PygmentsHighlighter.set_style_sheet","text":"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def set_style_sheet ( self , stylesheet : str ): \"\"\"Sets a CSS stylesheet. The classes in the stylesheet should correspond to those generated by: pygmentize -S <style> -f html Note that \"set_style\" and \"set_style_sheet\" completely override each other, i.e. they cannot be used in conjunction. \"\"\" self . _document . setDefaultStyleSheet ( stylesheet ) self . _style = None self . _clear_caches ()","title":"set_style_sheet()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.get_tokens_unprocessed","text":"Split text into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The text parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def get_tokens_unprocessed ( self , text : str , stack = ( \"root\" ,)): \"\"\"Split ``text`` into (tokentype, text) pairs. Monkeypatched to store the final stack on the object itself. The `text` parameter this gets passed is only the current line, so to highlight things like multiline strings correctly, we need to retrieve the state from the previous line (this is done in PygmentsHighlighter, below), and use it to continue processing the current line. \"\"\" pos = 0 tokendefs = self . _tokens if hasattr ( self , \"_saved_state_stack\" ): statestack = list ( self . _saved_state_stack ) else : statestack = list ( stack ) statetokens = tokendefs [ statestack [ - 1 ]] while 1 : for rexmatch , action , new_state in statetokens : m = rexmatch ( text , pos ) if not m : continue if action is not None : if type ( action ) is _TokenType : yield pos , action , m . group () else : yield from action ( self , m ) pos = m . end () if new_state is None : break # state transition if isinstance ( new_state , tuple ): for state in new_state : if state == \"#pop\" : statestack . pop () elif state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : statestack . append ( state ) elif isinstance ( new_state , int ): # pop del statestack [ new_state :] elif new_state == \"#push\" : statestack . append ( statestack [ - 1 ]) else : assert False , \"wrong state def: %r \" % new_state statetokens = tokendefs [ statestack [ - 1 ]] break else : try : if text [ pos ] == \" \\n \" : # at EOL, reset state to \"root\" pos += 1 statestack = [ \"root\" ] statetokens = tokendefs [ \"root\" ] yield pos , Text , \" \\n \" continue yield pos , Error , text [ pos ] pos += 1 except IndexError : break self . _saved_state_stack = list ( statestack )","title":"get_tokens_unprocessed()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pygmentshighlighter.qstring_length","text":"Tries to compute what the length of an utf16-encoded QString would be. Source code in prettyqt/syntaxhighlighters/pygmentshighlighter.py def qstring_length ( text : str ) -> int : \"\"\"Tries to compute what the length of an utf16-encoded QString would be.\"\"\" utf16_text = text . encode ( \"utf16\" ) length = len ( utf16_text ) // 2 # Remove Byte order mark. # TODO: All unicode Non-characters should be removed if utf16_text [: 2 ] in [ b \" \\xff\\xfe \" , b \" \\xff\\xff \" , b \" \\xfe\\xff \" ]: length -= 1 return length","title":"qstring_length()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter","text":"Syntax highlighter for the programming language Python.","title":"pythonhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter","text":"Syntax highlighter for the Python language.","title":"PythonHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def highlightBlock ( self , text : str ): \"\"\"Apply syntax highlighting to the given block of text.\"\"\" # Do other syntax formatting super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) # Do multi-line strings if not self . match_multiline ( text , * TRI_SINGLE ): self . match_multiline ( text , * TRI_DOUBLE )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.pythonhighlighter.PythonHighlighter.match_multiline","text":"Do highlighting of multi-line strings. delimiter should be a core.RegExp for triple-single-quotes or triple-double-quotes, and in_state should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. Source code in prettyqt/syntaxhighlighters/pythonhighlighter.py def match_multiline ( self , text , delimiter , in_state , style ): \"\"\"Do highlighting of multi-line strings. ``delimiter`` should be a ``core.RegExp`` for triple-single-quotes or triple-double-quotes, and ``in_state`` should be a unique integer to represent the corresponding state changes when inside those strings. Returns True if we're still inside a multi-line string when this function is finished. \"\"\" # If inside triple-single quotes, start at 0 if self . previousBlockState () == in_state : start = 0 add = 0 # Otherwise, look for the delimiter on this line else : match = delimiter . match ( text ) if not match . hasMatch (): return start = match . capturedStart () add = match . capturedLength () # As long as there's a delimiter match on this line... while start >= 0 : # Look for the ending delimiter match = delimiter . match ( text , start + add ) end = match . capturedStart () # Ending delimiter on this line? if end >= add : length = end - start + add + match . capturedLength () self . setCurrentBlockState ( 0 ) # No; multi-line string else : self . setCurrentBlockState ( in_state ) length = len ( text ) - start + add # Apply formatting self . setFormat ( start , length , style ) # Look for the next match start = delimiter . match ( text , start + length ) . capturedStart () # Return True if still inside a multi-line string, False otherwise return self . currentBlockState () == in_state","title":"match_multiline()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter","text":"","title":"regexmatchhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter","text":"","title":"RegexMatchHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.regexmatchhighlighter.RegexMatchHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/regexmatchhighlighter.py def highlightBlock ( self , text : str ): block = self . currentBlock () # line_no = block.blockNumber() # if line_no == 0: # self.setCurrentBlockState(-1) start_char = block . position () end_char = start_char + block . length () # print(f\"\\nline {line_no} ({start_char} - {end_char})\") # print(f\"prev block state: {self.previousBlockState()}\") if not self . spans or not text : return None for i , ( start , end ) in enumerate ( self . spans ): if end < start_char : continue if start > end_char : break starts_in_line = start_char <= start <= end_char ends_in_line = start_char <= end <= end_char if starts_in_line and ends_in_line : # print(f\"in line: {line_pos} - {line_pos + match_len}\") self . _colorize ( start - start_char , end - start , i ) elif ends_in_line : # if self.previousBlockState() == 1: # print(f\"ends: {end}\") self . _colorize ( 0 , end - start , i ) # self.setCurrentBlockState(-1) elif starts_in_line : # print(f\"starts: {line_pos}\") # self.setCurrentBlockState(1) self . _colorize ( start - start_char , end - start , i )","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter","text":"Based on http://www.yasinuludag.com/blog/?p=49 .","title":"xmlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter","text":"","title":"XmlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.xmlhighlighter.XmlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/xmlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) # HANDLE QUOTATION MARKS NOW.. WE WANT TO START WITH \" AND END WITH \".. # A THIRD \" SHOULD NOT CAUSE THE WORDS INBETWEEN SECOND AND THIRD # TO BE COLORED self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = VALUE_START_EXPRESSION . match ( text ) . capturedStart () while start_index >= 0 : match = VALUE_END_EXPRESSION . match ( text , start_index ) end_index = match . capturedStart () if end_index == - 1 : self . setCurrentBlockState ( 1 ) comment_len = len ( text ) - start_index else : comment_len = end_index - start_index + match . capturedLength () self . setFormat ( start_index , comment_len , VALUE_FORMAT ) start_index = VALUE_START_EXPRESSION . match ( text , start_index + comment_len ) . capturedStart ()","title":"highlightBlock()"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter","text":"","title":"yamlhighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter","text":"","title":"YamlHighlighter"},{"location":"api/syntaxhighlighters.html#prettyqt.syntaxhighlighters.yamlhighlighter.YamlHighlighter.highlightBlock","text":"Apply syntax highlighting to the given block of text. Source code in prettyqt/syntaxhighlighters/yamlhighlighter.py def highlightBlock ( self , text : str ): super () . highlightBlock ( text ) self . setCurrentBlockState ( 0 ) start_index = 0 if self . previousBlockState () != 1 : start_index = COMMENT_START . match ( text ) . capturedStart () if start_index >= 0 : comment_len = len ( text ) - start_index self . setFormat ( start_index , comment_len , COMMENT_FORMAT )","title":"highlightBlock()"},{"location":"api/texttospeech.html","text":"qml module Qml module. Contains QtQml-based classes jsvalue JSValue from_object ( obj , jsengine ) classmethod Convert any python object into a QJSValue (must happen in GUI thread). Source code in prettyqt/qml/jsvalue.py @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls () qmlengine QmlEngine get_object_ownership ( self , obj ) Return object ownership. Returns: Type Description Literal['cpp', 'javascript'] object ownership Source code in prettyqt/qml/qmlengine.py def get_object_ownership ( self , obj : QtCore . QObject ) -> ObjectOwnershipStr : \"\"\"Return object ownership. Returns: object ownership \"\"\" return OBJECT_OWNERSHIP . inverse [ self . objectOwnership ( obj )] set_object_ownership ( self , obj , mode ) Set the object ownership. Parameters: Name Type Description Default mode Literal['cpp', 'javascript'] object ownership to use required Exceptions: Type Description InvalidParamError invalid object ownership Source code in prettyqt/qml/qmlengine.py def set_object_ownership ( self , obj : QtCore . QObject , mode : ObjectOwnershipStr ): \"\"\"Set the object ownership. Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIP : raise InvalidParamError ( mode , OBJECT_OWNERSHIP ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIP [ mode ])","title":"texttospeech"},{"location":"api/texttospeech.html#qml-module","text":"","title":"qml module"},{"location":"api/texttospeech.html#prettyqt.qml","text":"Qml module. Contains QtQml-based classes","title":"prettyqt.qml"},{"location":"api/texttospeech.html#prettyqt.qml.jsvalue","text":"","title":"jsvalue"},{"location":"api/texttospeech.html#prettyqt.qml.jsvalue.JSValue","text":"","title":"JSValue"},{"location":"api/texttospeech.html#prettyqt.qml.jsvalue.JSValue.from_object","text":"Convert any python object into a QJSValue (must happen in GUI thread). Source code in prettyqt/qml/jsvalue.py @classmethod def from_object ( cls , obj , jsengine ) -> JSValue : \"\"\"Convert any python object into a QJSValue (must happen in GUI thread).\"\"\" if obj is None : return cls () elif isinstance ( obj , list ) or isinstance ( obj , tuple ): length = len ( obj ) array = JSValue ( jsengine . newArray ( length )) for i , v in enumerate ( obj ): array . setProperty ( i , cls . from_object ( v , jsengine )) return array elif isinstance ( obj , dict ): array = JSValue ( jsengine . newArray ()) for k , v in obj . items (): array . setProperty ( k , cls . from_object ( v , jsengine )) return array else : try : return cls ( obj ) except TypeError : logger . debug ( \"unknown type: \" + str ( obj )) return cls ()","title":"from_object()"},{"location":"api/texttospeech.html#prettyqt.qml.qmlengine","text":"","title":"qmlengine"},{"location":"api/texttospeech.html#prettyqt.qml.qmlengine.QmlEngine","text":"","title":"QmlEngine"},{"location":"api/texttospeech.html#prettyqt.qml.qmlengine.QmlEngine.get_object_ownership","text":"Return object ownership. Returns: Type Description Literal['cpp', 'javascript'] object ownership Source code in prettyqt/qml/qmlengine.py def get_object_ownership ( self , obj : QtCore . QObject ) -> ObjectOwnershipStr : \"\"\"Return object ownership. Returns: object ownership \"\"\" return OBJECT_OWNERSHIP . inverse [ self . objectOwnership ( obj )]","title":"get_object_ownership()"},{"location":"api/texttospeech.html#prettyqt.qml.qmlengine.QmlEngine.set_object_ownership","text":"Set the object ownership. Parameters: Name Type Description Default mode Literal['cpp', 'javascript'] object ownership to use required Exceptions: Type Description InvalidParamError invalid object ownership Source code in prettyqt/qml/qmlengine.py def set_object_ownership ( self , obj : QtCore . QObject , mode : ObjectOwnershipStr ): \"\"\"Set the object ownership. Args: mode: object ownership to use Raises: InvalidParamError: invalid object ownership \"\"\" if mode not in OBJECT_OWNERSHIP : raise InvalidParamError ( mode , OBJECT_OWNERSHIP ) self . setObjectOwnership ( obj , OBJECT_OWNERSHIP [ mode ])","title":"set_object_ownership()"},{"location":"api/webenginecore.html","text":"webenginecore module Webenginewidgets module. contains QtWebEngineCore-based classes webenginehttprequest WebEngineHttpRequest get_method ( self ) Get the method this WebEngine request is using. Returns: Type Description Literal['get', 'post'] method Source code in prettyqt/webenginecore/webenginehttprequest.py def get_method ( self ) -> MethodStr : \"\"\"Get the method this WebEngine request is using. Returns: method \"\"\" return METHODS . inverse [ self . method ()] set_method ( self , method ) Set method this WebEngine request is using. Parameters: Name Type Description Default method Literal['get', 'post'] method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/webenginecore/webenginehttprequest.py def set_method ( self , method : MethodStr ): \"\"\"Set method this WebEngine request is using. Args: method: method Raises: InvalidParamError: method does not exist \"\"\" if method not in METHODS : raise InvalidParamError ( method , METHODS ) self . setMethod ( METHODS [ method ]) webengineurlscheme WebEngineUrlScheme get_syntax ( self ) Return syntax. Returns: Type Description SyntaxStr syntax Source code in prettyqt/webenginecore/webengineurlscheme.py def get_syntax ( self ) -> SyntaxStr : \"\"\"Return syntax. Returns: syntax \"\"\" return SYNTAX . inverse [ self . syntax ()] set_syntax ( self , syntax ) Set syntax. Parameters: Name Type Description Default syntax SyntaxStr syntax to use required Exceptions: Type Description InvalidParamError syntax does not exist Source code in prettyqt/webenginecore/webengineurlscheme.py def set_syntax ( self , syntax : SyntaxStr ): \"\"\"Set syntax. Args: syntax: syntax to use Raises: InvalidParamError: syntax does not exist \"\"\" if syntax not in SYNTAX : raise InvalidParamError ( syntax , SYNTAX ) self . setSyntax ( SYNTAX [ syntax ])","title":"webenginecore"},{"location":"api/webenginecore.html#webenginecore-module","text":"","title":"webenginecore module"},{"location":"api/webenginecore.html#prettyqt.webenginecore","text":"Webenginewidgets module. contains QtWebEngineCore-based classes","title":"prettyqt.webenginecore"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest","text":"","title":"webenginehttprequest"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest","text":"","title":"WebEngineHttpRequest"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.get_method","text":"Get the method this WebEngine request is using. Returns: Type Description Literal['get', 'post'] method Source code in prettyqt/webenginecore/webenginehttprequest.py def get_method ( self ) -> MethodStr : \"\"\"Get the method this WebEngine request is using. Returns: method \"\"\" return METHODS . inverse [ self . method ()]","title":"get_method()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webenginehttprequest.WebEngineHttpRequest.set_method","text":"Set method this WebEngine request is using. Parameters: Name Type Description Default method Literal['get', 'post'] method required Exceptions: Type Description InvalidParamError method does not exist Source code in prettyqt/webenginecore/webenginehttprequest.py def set_method ( self , method : MethodStr ): \"\"\"Set method this WebEngine request is using. Args: method: method Raises: InvalidParamError: method does not exist \"\"\" if method not in METHODS : raise InvalidParamError ( method , METHODS ) self . setMethod ( METHODS [ method ])","title":"set_method()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme","text":"","title":"webengineurlscheme"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme","text":"","title":"WebEngineUrlScheme"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.get_syntax","text":"Return syntax. Returns: Type Description SyntaxStr syntax Source code in prettyqt/webenginecore/webengineurlscheme.py def get_syntax ( self ) -> SyntaxStr : \"\"\"Return syntax. Returns: syntax \"\"\" return SYNTAX . inverse [ self . syntax ()]","title":"get_syntax()"},{"location":"api/webenginecore.html#prettyqt.webenginecore.webengineurlscheme.WebEngineUrlScheme.set_syntax","text":"Set syntax. Parameters: Name Type Description Default syntax SyntaxStr syntax to use required Exceptions: Type Description InvalidParamError syntax does not exist Source code in prettyqt/webenginecore/webengineurlscheme.py def set_syntax ( self , syntax : SyntaxStr ): \"\"\"Set syntax. Args: syntax: syntax to use Raises: InvalidParamError: syntax does not exist \"\"\" if syntax not in SYNTAX : raise InvalidParamError ( syntax , SYNTAX ) self . setSyntax ( SYNTAX [ syntax ])","title":"set_syntax()"},{"location":"api/webenginewidgets.html","text":"webenginewidgets module Webenginewidgets module. contains QtWebEngineWidgets-based classes webenginedownloaditem WebEngineDownloadItem get_save_page_format ( self ) Return current save page format. Returns: Type Description Literal['unknown', 'single_html', 'complete_html', 'mime_html'] Save page format Source code in prettyqt/webenginewidgets/webenginedownloaditem.py def get_save_page_format ( self ) -> SavePageFormatStr : \"\"\"Return current save page format. Returns: Save page format \"\"\" return SAVE_PAGE_FORMAT . inverse [ self . item . savePageFormat ()] set_save_page_format ( self , fmt ) Set the save page format. Parameters: Name Type Description Default fmt Literal['unknown', 'single_html', 'complete_html', 'mime_html'] save page format for the layout required Exceptions: Type Description InvalidParamError save page format does not exist Source code in prettyqt/webenginewidgets/webenginedownloaditem.py def set_save_page_format ( self , fmt : SavePageFormatStr ): \"\"\"Set the save page format. Args: fmt: save page format for the layout Raises: InvalidParamError: save page format does not exist \"\"\" if fmt not in SAVE_PAGE_FORMAT : raise InvalidParamError ( fmt , SAVE_PAGE_FORMAT ) self . item . setSavePageFormat ( SAVE_PAGE_FORMAT [ fmt ]) webenginepage WebEnginePage A web engine page holds the HTML document contents, link history + actions. find_text ( self , string , backward = False , case_sensitive = False , callback = None ) Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Optional[Callable[[bool], NoneType]] result callback None Source code in prettyqt/webenginewidgets/webenginepage.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Optional [ Callable [[ bool ], None ]] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlags () if case_sensitive : flag |= self . FindCaseSensitively if backward : flag |= self . FindBackward self . findText ( string , flag , callback ) get_lifecycle_state ( self ) Get the current lifecycle state. Returns: Type Description Literal['active', 'frozen', 'discarded'] lifecycle state Source code in prettyqt/webenginewidgets/webenginepage.py def get_lifecycle_state ( self ) -> LifecycleStateStr : \"\"\"Get the current lifecycle state. Returns: lifecycle state \"\"\" return LIFECYCLE_STATE . inverse [ self . lifecycleState ()] load_url ( self , url ) Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webenginepage.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) set_lifecycle_state ( self , state ) Set lifecycle state. Parameters: Name Type Description Default state Literal['active', 'frozen', 'discarded'] lifecycle state required Exceptions: Type Description InvalidParamError lifecycle state does not exist Source code in prettyqt/webenginewidgets/webenginepage.py def set_lifecycle_state ( self , state : LifecycleStateStr ): \"\"\"Set lifecycle state. Args: state: lifecycle state Raises: InvalidParamError: lifecycle state does not exist \"\"\" if state not in LIFECYCLE_STATE : raise InvalidParamError ( state , LIFECYCLE_STATE ) self . setLifecycleState ( LIFECYCLE_STATE [ state ]) set_url ( self , url ) Set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webenginepage.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom ) Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webenginepage.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom ) webengineprofile WebEngineProfile get_http_cache_type ( self ) Return current http cache type. Returns: Type Description Literal['none', 'disk', 'memory'] Http cache type Source code in prettyqt/webenginewidgets/webengineprofile.py def get_http_cache_type ( self ) -> HttpCacheTypeStr : \"\"\"Return current http cache type. Returns: Http cache type \"\"\" return HTTP_CACHE_TYPE . inverse [ self . httpCacheType ()] get_persistent_cookie_policy ( self ) Return current persistent cookie policy. Returns: Type Description Literal['none', 'allow', 'force'] Persistent cookie policy Source code in prettyqt/webenginewidgets/webengineprofile.py def get_persistent_cookie_policy ( self ) -> PersistentCookiePolicyStr : \"\"\"Return current persistent cookie policy. Returns: Persistent cookie policy \"\"\" return PERSISTENT_COOKIE_POLICY . inverse [ self . persistentCookiesPolicy ()] set_http_cache_type ( self , typ ) Set the http cache type. Parameters: Name Type Description Default typ Literal['none', 'disk', 'memory'] http cache type required Exceptions: Type Description InvalidParamError Cache type does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_http_cache_type ( self , typ : HttpCacheTypeStr ): \"\"\"Set the http cache type. Args: typ: http cache type Raises: InvalidParamError: Cache type does not exist \"\"\" if typ not in HTTP_CACHE_TYPE : raise InvalidParamError ( typ , HTTP_CACHE_TYPE ) self . setHttpCacheType ( HTTP_CACHE_TYPE [ typ ]) set_persistent_cookie_policy ( self , policy ) Set the persistent cookie policy. Parameters: Name Type Description Default policy Literal['none', 'allow', 'force'] persistent cookie policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_persistent_cookie_policy ( self , policy : PersistentCookiePolicyStr ): \"\"\"Set the persistent cookie policy. Args: policy: persistent cookie policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in PERSISTENT_COOKIE_POLICY : raise InvalidParamError ( policy , PERSISTENT_COOKIE_POLICY ) self . setPersistentCookiesPolicy ( PERSISTENT_COOKIE_POLICY [ policy ]) webenginescript WebEngineScript get_injection_point ( self ) Return injection point. Returns: Type Description Literal['document_creation', 'document_ready', 'deferred'] injection point Source code in prettyqt/webenginewidgets/webenginescript.py def get_injection_point ( self ) -> InjectionPointStr : \"\"\"Return injection point. Returns: injection point \"\"\" return INJECTION_POINT . inverse [ self . injectionPoint ()] set_injection_point ( self , point ) Set injection point. Parameters: Name Type Description Default point Literal['document_creation', 'document_ready', 'deferred'] injection point to use required Exceptions: Type Description InvalidParamError injection point does not exist Source code in prettyqt/webenginewidgets/webenginescript.py def set_injection_point ( self , point : InjectionPointStr ): \"\"\"Set injection point. Args: point: injection point to use Raises: InvalidParamError: injection point does not exist \"\"\" if point not in INJECTION_POINT : raise InvalidParamError ( point , INJECTION_POINT ) self . setInjectionPoint ( INJECTION_POINT [ point ]) webenginesettings WebEngineSettings get_font_family ( self , family ) Return the actual font family for the specified generic font family. Parameters: Name Type Description Default family Literal['standard', 'fixed', 'serif', 'sans_serif', 'cursive', 'fantasy', 'pictograph'] generic font family required Returns: Type Description str Font family Source code in prettyqt/webenginewidgets/webenginesettings.py def get_font_family ( self , family : FontFamilyStr ) -> str : \"\"\"Return the actual font family for the specified generic font family. Args: family: generic font family Returns: Font family \"\"\" return self . item . fontFamily ( FONT_FAMILY [ family ]) get_font_size ( self , typ ) Return the default font size for type in pixels. Parameters: Name Type Description Default typ Literal['minimum', 'minimum_logical', 'default', 'default_fixed'] font size type required Returns: Type Description int Font size Source code in prettyqt/webenginewidgets/webenginesettings.py def get_font_size ( self , typ : FontSizeStr ) -> int : \"\"\"Return the default font size for type in pixels. Args: typ: font size type Returns: Font size \"\"\" return self . item . fontSize ( FONT_SIZE [ typ ]) get_unknown_url_scheme_policy ( self ) Return current unknown url scheme policy. Returns: Type Description Literal['disallow', 'allow_from_user_interaction', 'allow_all'] Unknown url scheme policy Source code in prettyqt/webenginewidgets/webenginesettings.py def get_unknown_url_scheme_policy ( self ) -> UnknownUrlSchemePolicyStr : \"\"\"Return current unknown url scheme policy. Returns: Unknown url scheme policy \"\"\" return UNKNOWN_URL_SCHEME_POLICY . inverse [ self . item . unknownUrlSchemePolicy ()] set_font_family ( self , which , family ) Set the actual font family to family for the specified generic family, which. Parameters: Name Type Description Default which Literal['standard', 'fixed', 'serif', 'sans_serif', 'cursive', 'fantasy', 'pictograph'] family to set required family str generic family required Exceptions: Type Description InvalidParamError Font family does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_font_family ( self , which : FontFamilyStr , family : str ): \"\"\"Set the actual font family to family for the specified generic family, which. Args: which: family to set family: generic family Raises: InvalidParamError: Font family does not exist \"\"\" if which not in FONT_FAMILY : raise InvalidParamError ( which , FONT_FAMILY ) self . item . setFontFamily ( FONT_FAMILY [ which ], family ) set_font_size ( self , typ , size ) Set the font size for type to size in pixels. Parameters: Name Type Description Default typ Literal['minimum', 'minimum_logical', 'default', 'default_fixed'] font size type required size int size in pixels required Exceptions: Type Description InvalidParamError Font size does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_font_size ( self , typ : FontSizeStr , size : int ): \"\"\"Set the font size for type to size in pixels. Args: typ: font size type size: size in pixels Raises: InvalidParamError: Font size does not exist \"\"\" if typ not in FONT_SIZE : raise InvalidParamError ( typ , FONT_SIZE ) self . item . setFontSize ( FONT_SIZE [ typ ], size ) set_unknown_url_scheme_policy ( self , policy ) Set the unknown url scheme policy. Parameters: Name Type Description Default policy Literal['disallow', 'allow_from_user_interaction', 'allow_all'] unknown url scheme policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_unknown_url_scheme_policy ( self , policy : UnknownUrlSchemePolicyStr ): \"\"\"Set the unknown url scheme policy. Args: policy: unknown url scheme policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in UNKNOWN_URL_SCHEME_POLICY : raise InvalidParamError ( policy , UNKNOWN_URL_SCHEME_POLICY ) self . item . setUnknownUrlSchemePolicy ( UNKNOWN_URL_SCHEME_POLICY [ policy ]) webengineview WebEngineView find_text ( self , string , backward = False , case_sensitive = False , callback = None ) Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable[[bool], NoneType] result callback None Source code in prettyqt/webenginewidgets/webengineview.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlags () if case_sensitive : flag |= QtWebEngineWidgets . QWebEnginePage . FindCaseSensitively if backward : flag |= QtWebEngineWidgets . QWebEnginePage . FindBackward self . findText ( string , flag , callback ) load_url ( self , url ) Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webengineview.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url ) set_url ( self , url ) Set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webengineview.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url ) set_zoom ( self , zoom ) Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"webenginewidgets"},{"location":"api/webenginewidgets.html#webenginewidgets-module","text":"","title":"webenginewidgets module"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets","text":"Webenginewidgets module. contains QtWebEngineWidgets-based classes","title":"prettyqt.webenginewidgets"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginedownloaditem","text":"","title":"webenginedownloaditem"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginedownloaditem.WebEngineDownloadItem","text":"","title":"WebEngineDownloadItem"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginedownloaditem.WebEngineDownloadItem.get_save_page_format","text":"Return current save page format. Returns: Type Description Literal['unknown', 'single_html', 'complete_html', 'mime_html'] Save page format Source code in prettyqt/webenginewidgets/webenginedownloaditem.py def get_save_page_format ( self ) -> SavePageFormatStr : \"\"\"Return current save page format. Returns: Save page format \"\"\" return SAVE_PAGE_FORMAT . inverse [ self . item . savePageFormat ()]","title":"get_save_page_format()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginedownloaditem.WebEngineDownloadItem.set_save_page_format","text":"Set the save page format. Parameters: Name Type Description Default fmt Literal['unknown', 'single_html', 'complete_html', 'mime_html'] save page format for the layout required Exceptions: Type Description InvalidParamError save page format does not exist Source code in prettyqt/webenginewidgets/webenginedownloaditem.py def set_save_page_format ( self , fmt : SavePageFormatStr ): \"\"\"Set the save page format. Args: fmt: save page format for the layout Raises: InvalidParamError: save page format does not exist \"\"\" if fmt not in SAVE_PAGE_FORMAT : raise InvalidParamError ( fmt , SAVE_PAGE_FORMAT ) self . item . setSavePageFormat ( SAVE_PAGE_FORMAT [ fmt ])","title":"set_save_page_format()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage","text":"","title":"webenginepage"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage","text":"A web engine page holds the HTML document contents, link history + actions.","title":"WebEnginePage"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.find_text","text":"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Optional[Callable[[bool], NoneType]] result callback None Source code in prettyqt/webenginewidgets/webenginepage.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Optional [ Callable [[ bool ], None ]] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEnginePage instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlags () if case_sensitive : flag |= self . FindCaseSensitively if backward : flag |= self . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.get_lifecycle_state","text":"Get the current lifecycle state. Returns: Type Description Literal['active', 'frozen', 'discarded'] lifecycle state Source code in prettyqt/webenginewidgets/webenginepage.py def get_lifecycle_state ( self ) -> LifecycleStateStr : \"\"\"Get the current lifecycle state. Returns: lifecycle state \"\"\" return LIFECYCLE_STATE . inverse [ self . lifecycleState ()]","title":"get_lifecycle_state()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.load_url","text":"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webenginepage.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The Page remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_lifecycle_state","text":"Set lifecycle state. Parameters: Name Type Description Default state Literal['active', 'frozen', 'discarded'] lifecycle state required Exceptions: Type Description InvalidParamError lifecycle state does not exist Source code in prettyqt/webenginewidgets/webenginepage.py def set_lifecycle_state ( self , state : LifecycleStateStr ): \"\"\"Set lifecycle state. Args: state: lifecycle state Raises: InvalidParamError: lifecycle state does not exist \"\"\" if state not in LIFECYCLE_STATE : raise InvalidParamError ( state , LIFECYCLE_STATE ) self . setLifecycleState ( LIFECYCLE_STATE [ state ])","title":"set_lifecycle_state()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_url","text":"Set the url of the WebEnginePage. Clears the Page and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webenginepage.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEnginePage. Clears the Page and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginepage.WebEnginePage.set_zoom","text":"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webenginepage.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the Page. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile","text":"","title":"webengineprofile"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile","text":"","title":"WebEngineProfile"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.get_http_cache_type","text":"Return current http cache type. Returns: Type Description Literal['none', 'disk', 'memory'] Http cache type Source code in prettyqt/webenginewidgets/webengineprofile.py def get_http_cache_type ( self ) -> HttpCacheTypeStr : \"\"\"Return current http cache type. Returns: Http cache type \"\"\" return HTTP_CACHE_TYPE . inverse [ self . httpCacheType ()]","title":"get_http_cache_type()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.get_persistent_cookie_policy","text":"Return current persistent cookie policy. Returns: Type Description Literal['none', 'allow', 'force'] Persistent cookie policy Source code in prettyqt/webenginewidgets/webengineprofile.py def get_persistent_cookie_policy ( self ) -> PersistentCookiePolicyStr : \"\"\"Return current persistent cookie policy. Returns: Persistent cookie policy \"\"\" return PERSISTENT_COOKIE_POLICY . inverse [ self . persistentCookiesPolicy ()]","title":"get_persistent_cookie_policy()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.set_http_cache_type","text":"Set the http cache type. Parameters: Name Type Description Default typ Literal['none', 'disk', 'memory'] http cache type required Exceptions: Type Description InvalidParamError Cache type does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_http_cache_type ( self , typ : HttpCacheTypeStr ): \"\"\"Set the http cache type. Args: typ: http cache type Raises: InvalidParamError: Cache type does not exist \"\"\" if typ not in HTTP_CACHE_TYPE : raise InvalidParamError ( typ , HTTP_CACHE_TYPE ) self . setHttpCacheType ( HTTP_CACHE_TYPE [ typ ])","title":"set_http_cache_type()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineprofile.WebEngineProfile.set_persistent_cookie_policy","text":"Set the persistent cookie policy. Parameters: Name Type Description Default policy Literal['none', 'allow', 'force'] persistent cookie policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginewidgets/webengineprofile.py def set_persistent_cookie_policy ( self , policy : PersistentCookiePolicyStr ): \"\"\"Set the persistent cookie policy. Args: policy: persistent cookie policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in PERSISTENT_COOKIE_POLICY : raise InvalidParamError ( policy , PERSISTENT_COOKIE_POLICY ) self . setPersistentCookiesPolicy ( PERSISTENT_COOKIE_POLICY [ policy ])","title":"set_persistent_cookie_policy()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginescript","text":"","title":"webenginescript"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginescript.WebEngineScript","text":"","title":"WebEngineScript"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginescript.WebEngineScript.get_injection_point","text":"Return injection point. Returns: Type Description Literal['document_creation', 'document_ready', 'deferred'] injection point Source code in prettyqt/webenginewidgets/webenginescript.py def get_injection_point ( self ) -> InjectionPointStr : \"\"\"Return injection point. Returns: injection point \"\"\" return INJECTION_POINT . inverse [ self . injectionPoint ()]","title":"get_injection_point()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginescript.WebEngineScript.set_injection_point","text":"Set injection point. Parameters: Name Type Description Default point Literal['document_creation', 'document_ready', 'deferred'] injection point to use required Exceptions: Type Description InvalidParamError injection point does not exist Source code in prettyqt/webenginewidgets/webenginescript.py def set_injection_point ( self , point : InjectionPointStr ): \"\"\"Set injection point. Args: point: injection point to use Raises: InvalidParamError: injection point does not exist \"\"\" if point not in INJECTION_POINT : raise InvalidParamError ( point , INJECTION_POINT ) self . setInjectionPoint ( INJECTION_POINT [ point ])","title":"set_injection_point()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings","text":"","title":"webenginesettings"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings","text":"","title":"WebEngineSettings"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.get_font_family","text":"Return the actual font family for the specified generic font family. Parameters: Name Type Description Default family Literal['standard', 'fixed', 'serif', 'sans_serif', 'cursive', 'fantasy', 'pictograph'] generic font family required Returns: Type Description str Font family Source code in prettyqt/webenginewidgets/webenginesettings.py def get_font_family ( self , family : FontFamilyStr ) -> str : \"\"\"Return the actual font family for the specified generic font family. Args: family: generic font family Returns: Font family \"\"\" return self . item . fontFamily ( FONT_FAMILY [ family ])","title":"get_font_family()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.get_font_size","text":"Return the default font size for type in pixels. Parameters: Name Type Description Default typ Literal['minimum', 'minimum_logical', 'default', 'default_fixed'] font size type required Returns: Type Description int Font size Source code in prettyqt/webenginewidgets/webenginesettings.py def get_font_size ( self , typ : FontSizeStr ) -> int : \"\"\"Return the default font size for type in pixels. Args: typ: font size type Returns: Font size \"\"\" return self . item . fontSize ( FONT_SIZE [ typ ])","title":"get_font_size()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.get_unknown_url_scheme_policy","text":"Return current unknown url scheme policy. Returns: Type Description Literal['disallow', 'allow_from_user_interaction', 'allow_all'] Unknown url scheme policy Source code in prettyqt/webenginewidgets/webenginesettings.py def get_unknown_url_scheme_policy ( self ) -> UnknownUrlSchemePolicyStr : \"\"\"Return current unknown url scheme policy. Returns: Unknown url scheme policy \"\"\" return UNKNOWN_URL_SCHEME_POLICY . inverse [ self . item . unknownUrlSchemePolicy ()]","title":"get_unknown_url_scheme_policy()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.set_font_family","text":"Set the actual font family to family for the specified generic family, which. Parameters: Name Type Description Default which Literal['standard', 'fixed', 'serif', 'sans_serif', 'cursive', 'fantasy', 'pictograph'] family to set required family str generic family required Exceptions: Type Description InvalidParamError Font family does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_font_family ( self , which : FontFamilyStr , family : str ): \"\"\"Set the actual font family to family for the specified generic family, which. Args: which: family to set family: generic family Raises: InvalidParamError: Font family does not exist \"\"\" if which not in FONT_FAMILY : raise InvalidParamError ( which , FONT_FAMILY ) self . item . setFontFamily ( FONT_FAMILY [ which ], family )","title":"set_font_family()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.set_font_size","text":"Set the font size for type to size in pixels. Parameters: Name Type Description Default typ Literal['minimum', 'minimum_logical', 'default', 'default_fixed'] font size type required size int size in pixels required Exceptions: Type Description InvalidParamError Font size does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_font_size ( self , typ : FontSizeStr , size : int ): \"\"\"Set the font size for type to size in pixels. Args: typ: font size type size: size in pixels Raises: InvalidParamError: Font size does not exist \"\"\" if typ not in FONT_SIZE : raise InvalidParamError ( typ , FONT_SIZE ) self . item . setFontSize ( FONT_SIZE [ typ ], size )","title":"set_font_size()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webenginesettings.WebEngineSettings.set_unknown_url_scheme_policy","text":"Set the unknown url scheme policy. Parameters: Name Type Description Default policy Literal['disallow', 'allow_from_user_interaction', 'allow_all'] unknown url scheme policy required Exceptions: Type Description InvalidParamError Policy does not exist Source code in prettyqt/webenginewidgets/webenginesettings.py def set_unknown_url_scheme_policy ( self , policy : UnknownUrlSchemePolicyStr ): \"\"\"Set the unknown url scheme policy. Args: policy: unknown url scheme policy Raises: InvalidParamError: Policy does not exist \"\"\" if policy not in UNKNOWN_URL_SCHEME_POLICY : raise InvalidParamError ( policy , UNKNOWN_URL_SCHEME_POLICY ) self . item . setUnknownUrlSchemePolicy ( UNKNOWN_URL_SCHEME_POLICY [ policy ])","title":"set_unknown_url_scheme_policy()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview","text":"","title":"webengineview"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView","text":"","title":"WebEngineView"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.find_text","text":"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Parameters: Name Type Description Default string str string to search for required backward bool search backwards False case_sensitive bool case-sensitive search False callback Callable[[bool], NoneType] result callback None Source code in prettyqt/webenginewidgets/webengineview.py def find_text ( self , string : str , backward : bool = False , case_sensitive : bool = False , callback : Callable [[ bool ], None ] = None , ): \"\"\"Find text in the current page. Finds the specified string, subString, in the page, using the given options. The findTextFinished() signal is emitted when a string search is completed. To clear the search highlight, just pass an empty string. The resultCallback must take a boolean parameter. It will be called with a value of true if the subString was found; otherwise the callback value will be false. Warning: It is guaranteed that the callback is always called, but it might be done during page destruction. When WebEnginePage is deleted, the callback is triggered with an invalid value and it is not safe to use the corresponding QWebEnginePage or QWebEngineView instance inside it. Args: string: string to search for backward: search backwards case_sensitive: case-sensitive search callback: result callback \"\"\" if callback is None : def do_nothing ( x ): pass callback = do_nothing flag = QtWebEngineWidgets . QWebEnginePage . FindFlags () if case_sensitive : flag |= QtWebEngineWidgets . QWebEnginePage . FindCaseSensitively if backward : flag |= QtWebEngineWidgets . QWebEnginePage . FindBackward self . findText ( string , flag , callback )","title":"find_text()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.load_url","text":"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to load required Source code in prettyqt/webenginewidgets/webengineview.py def load_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Load the URL. Loads the specified url and displays it. Note: The view remains the same until enough data has arrived to display the new URL. Args: url: URL to load \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . load ( url )","title":"load_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_url","text":"Set the url of the WebEngineView. Clears the view and loads the URL. Parameters: Name Type Description Default url Union[str, pathlib.Path] URL to set required Source code in prettyqt/webenginewidgets/webengineview.py def set_url ( self , url : Union [ str , pathlib . Path ]): \"\"\"Set the url of the WebEngineView. Clears the view and loads the URL. Args: url: URL to set \"\"\" if isinstance ( url , pathlib . Path ): url = core . Url . fromLocalFile ( str ( url )) elif isinstance ( url , str ): url = core . Url ( url ) self . setUrl ( url )","title":"set_url()"},{"location":"api/webenginewidgets.html#prettyqt.webenginewidgets.webengineview.WebEngineView.set_zoom","text":"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Parameters: Name Type Description Default zoom float Zoom factor required Source code in prettyqt/webenginewidgets/webengineview.py def set_zoom ( self , zoom : float ): \"\"\"Set the zoom factor for the view. Valid values are within the range from 0.25 to 5.0. The default factor is 1.0. Args: zoom: Zoom factor \"\"\" self . setZoomFactor ( zoom )","title":"set_zoom()"},{"location":"api/widgets.html","text":"widgets module widgets module. contains QtWidgets-based classes abstractbutton AbstractButton set_icon ( self , icon ) Set the icon for the button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/abstractbutton.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) set_icon_size ( self , size ) Set size of the icon. Source code in prettyqt/widgets/abstractbutton.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icon.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) set_style_icon ( self , icon , size = 15 ) Set theme icon for the button. Parameters: Name Type Description Default icon Literal['titlebar_min_button=', 'titlebar_menu_button', 'titlebar_max_button', 'titlebar_close_button', 'titlebar_normal_button', 'titlebar_shade_button', 'titlebar_unshade_button', 'titlebar_context_help_button', 'information', 'warning', 'critical', 'question', 'desktop', 'trash', 'computer', 'drive_fd', 'drive_hd', 'drive_cd', 'drive_dvd', 'drive_net', 'dir_home', 'dir_open', 'dir_closed', 'dir', 'dir_link', 'dir_link_open', 'file', 'file_link', 'file_dialog_start', 'file_dialog_end', 'file_dialog_to_parent', 'file_dialog_new_folder', 'file_dialog_detailed_view', 'file_dialog_info_view', 'file_dialog_contents_view', 'file_dialog_list_view', 'file_dialog_back', 'dockwidget_close_button', 'toolbar_horizontal_extension', 'toolbar_vertical_extension', 'dialog_ok', 'dialog_cancel', 'dialog_help', 'dialog_open', 'dialog_save', 'dialog_close', 'dialog_apply', 'dialor_reset', 'dialog_discard', 'dialog_yes', 'dialog_no', 'arrow_up', 'arrow_down', 'arrow_left', 'arrow_right', 'arrow_back', 'arrow_forward', 'command_link', 'vista_shield', 'browser_reload', 'browser_stop', 'media_play', 'media_stop', 'media_pause', 'media_skip_forward', 'media_skip_backward', 'media_seek_forward', 'media_seek_backward', 'media_volume', 'media_volume_muted', 'lineedit_clear', 'custom_base'] icon to use required size int icon size 15 Source code in prettyqt/widgets/abstractbutton.py def set_style_icon ( self , icon : widgets . style . StandardPixmapStr , size : int = 15 ): \"\"\"Set theme icon for the button. Args: icon: icon to use size: icon size \"\"\" if icon not in widgets . style . STANDARD_PIXMAP : raise InvalidParamError ( icon , widgets . style . STANDARD_PIXMAP ) qicon = self . style () . standardIcon ( widgets . style . STANDARD_PIXMAP [ icon ], None , self ) self . set_icon ( qicon ) self . setIconSize ( core . Size ( size , size )) abstractitemview AbstractItemView get_drag_drop_mode ( self ) Return current drag-drop mode. Returns: Type Description Literal['none', 'drag', 'drop', 'drag_drop', 'internal'] drag-drop mode Source code in prettyqt/widgets/abstractitemview.py def get_drag_drop_mode ( self ) -> DragDropModeStr : \"\"\"Return current drag-drop mode. Returns: drag-drop mode \"\"\" return DRAG_DROP_MODE . inverse [ self . dragDropMode ()] get_selection_behaviour ( self ) Return current selection behaviour. Returns: Type Description Literal['rows', 'columns', 'items'] selection behaviour Source code in prettyqt/widgets/abstractitemview.py def get_selection_behaviour ( self ) -> SelectionBehaviourStr : \"\"\"Return current selection behaviour. Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOUR . inverse [ self . selectionBehavior ()] get_selection_mode ( self ) Return current selection mode. Returns: Type Description Literal['single', 'extended', 'multi', 'none'] selection mode Source code in prettyqt/widgets/abstractitemview.py def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()] highlight_when_inactive ( self ) Highlight items when widget does not have focus. Source code in prettyqt/widgets/abstractitemview.py def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p ) jump_to_column ( self , col_num ) Make sure column at given index is visible. scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx ) num_selected ( self ) Return amount of selected rows. Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ()) scroll_to_bottom ( self ) Override to use abstractitemview-way of scrolling to bottom. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom () scroll_to_top ( self ) Override to use abstractitemview-way of scrolling to top. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop () selectAll ( self ) Override, we dont want to selectAll for too many items bc of performance. Source code in prettyqt/widgets/abstractitemview.py def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return super () . selectAll () selected_data ( self ) Returns generator yielding selected userData. Source code in prettyqt/widgets/abstractitemview.py def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes ()) selected_indexes ( self ) Returns list of selected indexes in first row. Source code in prettyqt/widgets/abstractitemview.py def selected_indexes ( self ) -> List [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) return sorted ( indexes , key = lambda x : x . row ()) selected_names ( self ) Returns generator yielding item names. Source code in prettyqt/widgets/abstractitemview.py def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ()) selected_rows ( self ) Returns generator yielding row nums. Source code in prettyqt/widgets/abstractitemview.py def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ()) set_drag_drop_mode ( self , mode ) Set drag-drop mode for given item view. Parameters: Name Type Description Default mode Literal['none', 'drag', 'drop', 'drag_drop', 'internal'] drag-drop mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_drag_drop_mode ( self , mode : DragDropModeStr ): \"\"\"Set drag-drop mode for given item view. Args: mode: drag-drop mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_DROP_MODE : raise InvalidParamError ( mode , DRAG_DROP_MODE ) self . setDragDropMode ( DRAG_DROP_MODE [ mode ]) set_horizontal_scroll_mode ( self , mode ) Set the horizontal scroll mode. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_horizontal_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the horizontal scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) set_model ( self , model ) Delete old selection model explicitely, seems to help with memory usage. Source code in prettyqt/widgets/abstractitemview.py def set_model ( self , model : Optional [ QtCore . QAbstractItemModel ]): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # type: ignore # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model set_scroll_mode ( self , mode ) Set the scroll mode for both directions. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the scroll mode for both directions. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) self . setVerticalScrollMode ( SCROLL_MODE [ mode ]) set_selection_behaviour ( self , behaviour ) Set selection behaviour for given item view. Parameters: Name Type Description Default behaviour Literal['rows', 'columns', 'items'] selection behaviour to use required Exceptions: Type Description InvalidParamError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_behaviour ( self , behaviour : SelectionBehaviourStr ): \"\"\"Set selection behaviour for given item view. Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOUR : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOUR ) self . setSelectionBehavior ( SELECTION_BEHAVIOUR [ behaviour ]) set_selection_mode ( self , mode ) Set selection mode for given item view. Parameters: Name Type Description Default mode Optional[Literal['single', 'extended', 'multi', 'none']] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_mode ( self , mode : Optional [ SelectionModeStr ]): \"\"\"Set selection mode for given item view. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ]) set_vertical_scroll_mode ( self , mode ) Set the vertical scroll mode. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_vertical_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the vertical scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setVerticalScrollMode ( SCROLL_MODE [ mode ]) toggle_select_all ( self ) Select all items from list (deselect when all selected). Source code in prettyqt/widgets/abstractitemview.py def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll () abstractscrollarea AbstractScrollArea get_size_adjust_policy ( self ) Return size adjust policy. Returns: Type Description Literal['content', 'first_show', 'ignored'] size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def get_size_adjust_policy ( self ) -> SizePolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_POLICY . inverse [ self . sizeAdjustPolicy ()] scroll_to_bottom ( self ) Scroll to the bottom of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max () scroll_to_top ( self ) Scroll to the top of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min () set_horizontal_scrollbar_policy ( self , mode ) Set the horizontal scrollbar visibility. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the horizontal scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) set_horizontal_scrollbar_width ( self , width ) Set the horizontal scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) set_scrollbar_policy ( self , mode ) Set the policy for both scrollbars. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the policy for both scrollbars. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) set_scrollbar_width ( self , width ) Set the width for both scrollbars. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width ) set_size_adjust_policy ( self , policy ) Set size adjust policy. Parameters: Name Type Description Default policy Literal['content', 'first_show', 'ignored'] size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def set_size_adjust_policy ( self , policy : SizePolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICY : raise InvalidParamError ( policy , SIZE_POLICY ) self . setSizeAdjustPolicy ( SIZE_POLICY [ policy ]) set_vertical_scrollbar_policy ( self , mode ) Set the vertical scrollbar visibility. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the vertical scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) set_vertical_scrollbar_width ( self , width ) Set the vertical scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" ) abstractslider AbstractSlider get_orientation ( self ) Return current orientation. Returns: Type Description Literal['horizontal', 'vertical'] orientation Source code in prettyqt/widgets/abstractslider.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] get_repeat_action ( self ) Get current repeat action. Returns: Type Description Literal['none', 'single_step_add', 'single_step_sub', 'page_step_add', 'page_step_sub', 'to_minimum', 'to_maximum', 'move'] current repeat action Source code in prettyqt/widgets/abstractslider.py def get_repeat_action ( self ) -> SliderActionStr : \"\"\"Get current repeat action. Returns: current repeat action \"\"\" return SLIDER_ACTION . inverse [ self . repeatAction ()] is_horizontal ( self ) Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == QtCore . Qt . Horizontal is_vertical ( self ) Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == QtCore . Qt . Vertical scroll_to_max ( self ) Scroll to the maximum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ()) scroll_to_min ( self ) Scroll to the minimum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ()) set_horizontal ( self ) Set slider orientation to horizontal. Source code in prettyqt/widgets/abstractslider.py def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( QtCore . Qt . Horizontal ) set_orientation ( self , orientation ) Set the orientation of the slider. Parameters: Name Type Description Default orientation Literal['horizontal', 'vertical'] orientation for the slider required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/abstractslider.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the slider. Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) set_repeat_action ( self , action , threshold = 500 , repeat_time = 50 ) Set the repeat action. Parameters: Name Type Description Default action Literal['none', 'single_step_add', 'single_step_sub', 'page_step_add', 'page_step_sub', 'to_minimum', 'to_maximum', 'move'] repeat action required Exceptions: Type Description InvalidParamError invalid repeat action Source code in prettyqt/widgets/abstractslider.py def set_repeat_action ( self , action : SliderActionStr , threshold : int = 500 , repeat_time : int = 50 ): \"\"\"Set the repeat action. Args: action: repeat action Raises: InvalidParamError: invalid repeat action \"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . setRepeatAction ( SLIDER_ACTION [ action ], threshold , repeat_time ) set_vertical ( self ) Set slider orientation to vertical. Source code in prettyqt/widgets/abstractslider.py def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( QtCore . Qt . Vertical ) trigger_action ( self , action ) Trigger slider action. Source code in prettyqt/widgets/abstractslider.py def trigger_action ( self , action : SliderActionStr ): \"\"\"Trigger slider action.\"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . triggerAction ( SLIDER_ACTION [ action ]) abstractspinbox AbstractSpinBox get_button_symbols ( self ) Return button symbol type. Returns: Type Description Literal['up_down', 'plus_minus', 'none'] button symbol type Source code in prettyqt/widgets/abstractspinbox.py def get_button_symbols ( self ) -> SymbolStr : \"\"\"Return button symbol type. Returns: button symbol type \"\"\" return SYMBOLS . inverse [ self . buttonSymbols ()] get_correction_mode ( self ) Return correction mode. Returns: Type Description Literal['to_previous', 'to_nearest'] correction mode Source code in prettyqt/widgets/abstractspinbox.py def get_correction_mode ( self ) -> CorrectionModeStr : \"\"\"Return correction mode. Returns: correction mode \"\"\" return CORRECTION_MODES . inverse [ self . correctionMode ()] get_step_type ( self ) Return step type. Returns: Type Description Literal['default', 'adaptive'] step type Source code in prettyqt/widgets/abstractspinbox.py def get_step_type ( self ) -> StepTypeStr : \"\"\"Return step type. Returns: step type \"\"\" return STEP_TYPES . inverse [ self . stepType ()] set_button_symbols ( self , mode ) Set button symbol type. Parameters: Name Type Description Default mode Literal['up_down', 'plus_minus', 'none'] button symbol type to use required Exceptions: Type Description InvalidParamError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py def set_button_symbols ( self , mode : SymbolStr ): \"\"\"Set button symbol type. Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ]) set_correction_mode ( self , mode ) Set correction mode. Parameters: Name Type Description Default mode Literal['to_previous', 'to_nearest'] correction mode to use required Exceptions: Type Description InvalidParamError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py def set_correction_mode ( self , mode : CorrectionModeStr ): \"\"\"Set correction mode. Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ]) set_step_type ( self , mode ) Set step type. Parameters: Name Type Description Default mode Literal['default', 'adaptive'] step type to use required Exceptions: Type Description InvalidParamError invalid step type Source code in prettyqt/widgets/abstractspinbox.py def set_step_type ( self , mode : StepTypeStr ): \"\"\"Set step type. Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ]) action Action get_menu_role ( self ) Return menu role. Returns: Type Description Literal['none', 'text_heuristic', 'application_specific', 'about_qt', 'about', 'preferences', 'quit'] menu role Source code in prettyqt/widgets/action.py def get_menu_role ( self ) -> RoleStr : \"\"\"Return menu role. Returns: menu role \"\"\" return ROLES . inverse [ self . menuRole ()] get_priority ( self ) Return current priority. Returns: Type Description Literal['low', 'normal', 'high'] priority Source code in prettyqt/widgets/action.py def get_priority ( self ) -> PriorityStr : \"\"\"Return current priority. Returns: priority \"\"\" return PRIORITIES . inverse [ self . priority ()] get_shortcut_context ( self ) Return shortcut context. Returns: Type Description Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context Source code in prettyqt/widgets/action.py def get_shortcut_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . shortcutContext ()] set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/action.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) set_menu_role ( self , role ) Set menu role. Parameters: Name Type Description Default role Literal['none', 'text_heuristic', 'application_specific', 'about_qt', 'about', 'preferences', 'quit'] menu role required Exceptions: Type Description InvalidParamError menu role does not exist Source code in prettyqt/widgets/action.py def set_menu_role ( self , role : RoleStr ): \"\"\"Set menu role. Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ]) set_priority ( self , priority ) Set priority of the action. Parameters: Name Type Description Default priority Literal['low', 'normal', 'high'] priority for the action required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/widgets/action.py def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority of the action. Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ]) set_shortcut_context ( self , context ) Set shortcut context. Parameters: Name Type Description Default context Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/action.py def set_shortcut_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setShortcutContext ( constants . CONTEXT [ context ]) actiongroup ActionGroup get_exclusion_policy ( self ) Return current exclusion policy. Returns: Type Description Literal['none', 'exclusive', 'exclusive_optional'] exclusion policy Source code in prettyqt/widgets/actiongroup.py def get_exclusion_policy ( self ) -> ExclusionPolicyStr : \"\"\"Return current exclusion policy. Returns: exclusion policy \"\"\" return POLICIES . inverse [ self . exclusionPolicy ()] set_exclusion_policy ( self , policy ) Set exclusion policy to use. Parameters: Name Type Description Default policy Optional[Literal['none', 'exclusive', 'exclusive_optional']] exclusion policy to use required Exceptions: Type Description InvalidParamError exclusion policy does not exist Source code in prettyqt/widgets/actiongroup.py def set_exclusion_policy ( self , policy : Optional [ ExclusionPolicyStr ]): \"\"\"Set exclusion policy to use. Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ]) application Application get_navigation_mode ( self ) Return navigation mode. Returns: Type Description Literal['none', 'keypad_tab_order', 'keypad_directional', 'cursor_auto', 'cursor_force_visible'] navigation mode Source code in prettyqt/widgets/application.py def get_navigation_mode ( self ) -> constants . NavigationModeStr : \"\"\"Return navigation mode. Returns: navigation mode \"\"\" return constants . NAVIGATION_MODES . inverse [ self . navigationMode ()] is_effect_enabled ( self , effect ) Return desktop effect state. Returns: Type Description bool desktop effect state Source code in prettyqt/widgets/application.py def is_effect_enabled ( self , effect : constants . UiEffectStr ) -> bool : \"\"\"Return desktop effect state. Returns: desktop effect state \"\"\" return self . isEffectEnabled ( constants . UI_EFFECTS [ effect ]) set_effect_enabled ( self , effect , enabled = True ) Set the enabled state of a desktop effect. Parameters: Name Type Description Default effect Literal['animate_menu', 'fade_menu', 'animate_combo', 'animate_tooltip', 'fade_tooltip', 'animate_toolbox'] desktop effect to set required enabled bool new state True Exceptions: Type Description InvalidParamError invalid desktop effect Source code in prettyqt/widgets/application.py def set_effect_enabled ( self , effect : constants . UiEffectStr , enabled : bool = True ): \"\"\"Set the enabled state of a desktop effect. Args: effect: desktop effect to set enabled: new state Raises: InvalidParamError: invalid desktop effect \"\"\" if effect not in constants . UI_EFFECTS : raise InvalidParamError ( effect , constants . UI_EFFECTS ) self . setEffectEnabled ( constants . UI_EFFECTS [ effect ]) set_navigation_mode ( self , mode ) Set the navigation mode. Parameters: Name Type Description Default mode Literal['none', 'keypad_tab_order', 'keypad_directional', 'cursor_auto', 'cursor_force_visible'] navigation mode to use required Exceptions: Type Description InvalidParamError invalid navigation mode Source code in prettyqt/widgets/application.py def set_navigation_mode ( self , mode : constants . NavigationModeStr ): \"\"\"Set the navigation mode. Args: mode: navigation mode to use Raises: InvalidParamError: invalid navigation mode \"\"\" if mode not in constants . NAVIGATION_MODES : raise InvalidParamError ( mode , constants . NAVIGATION_MODES ) self . setNavigationMode ( constants . NAVIGATION_MODES [ mode ]) boxlayout BoxLayout get_direction ( self ) Return current direction. Returns: Type Description Literal['left_to_right', 'right_to_left', 'top_to_bottom', 'bottom_to_top'] direction Source code in prettyqt/widgets/boxlayout.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()] set_direction ( self , direction ) Set the direction. Parameters: Name Type Description Default direction Literal['left_to_right', 'right_to_left', 'top_to_bottom', 'bottom_to_top'] direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/widgets/boxlayout.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ]) calendarwidget CalendarWidget get_selection_mode ( self ) Return current selection mode. Returns: Type Description Literal['none', 'single'] selection mode Source code in prettyqt/widgets/calendarwidget.py def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()] set_selection_mode ( self , mode ) Set selection mode for given calendar widget. Parameters: Name Type Description Default mode Optional[Literal['none', 'single']] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/calendarwidget.py def set_selection_mode ( self , mode : Optional [ SelectionModeStr ]): \"\"\"Set selection mode for given calendar widget. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ]) checkbox CheckBox get_checkstate ( self ) Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/checkbox.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] set_checkstate ( self , state ) Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/checkbox.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) combobox ComboBox get_insert_policy ( self ) Return insert policy. Returns: Type Description Literal['no_insert', 'top', 'current', 'bottom', 'after_current', 'before_current', 'alphabetically'] insert policy Source code in prettyqt/widgets/combobox.py def get_insert_policy ( self ) -> InsertPolicyStr : \"\"\"Return insert policy. Returns: insert policy \"\"\" return INSERT_POLICY . inverse [ self . insertPolicy ()] get_size_adjust_policy ( self ) Return size adjust policy. Returns: Type Description Literal['content', 'first_show', 'min_length', 'min_length_with_icon'] size adjust policy Source code in prettyqt/widgets/combobox.py def get_size_adjust_policy ( self ) -> SizeAdjustPolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_ADJUST_POLICY . inverse [ self . sizeAdjustPolicy ()] set_icon_size ( self , size ) Set size of the icons. Source code in prettyqt/widgets/combobox.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) set_insert_policy ( self , policy ) Set insert policy. Parameters: Name Type Description Default policy Literal['no_insert', 'top', 'current', 'bottom', 'after_current', 'before_current', 'alphabetically'] insert policy to use required Exceptions: Type Description InvalidParamError invalid insert policy Source code in prettyqt/widgets/combobox.py def set_insert_policy ( self , policy : InsertPolicyStr ): \"\"\"Set insert policy. Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICY : raise InvalidParamError ( policy , INSERT_POLICY ) self . setInsertPolicy ( INSERT_POLICY [ policy ]) set_size_adjust_policy ( self , policy ) Set size adjust policy. Parameters: Name Type Description Default policy Literal['content', 'first_show', 'min_length', 'min_length_with_icon'] size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/combobox.py def set_size_adjust_policy ( self , policy : SizeAdjustPolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_ADJUST_POLICY : raise InvalidParamError ( policy , SIZE_ADJUST_POLICY ) self . setSizeAdjustPolicy ( SIZE_ADJUST_POLICY [ policy ]) completer Completer get_completion_mode ( self ) Return current completion mode. Returns: Type Description Literal['popup', 'inline', 'unfiltered_popup'] completion mode Source code in prettyqt/widgets/completer.py def get_completion_mode ( self ) -> CompletionModeStr : \"\"\"Return current completion mode. Returns: completion mode \"\"\" return COMPLETION_MODE . inverse [ self . completionMode ()] get_filter_mode ( self ) Return current filter mode. Returns: Type Description Literal['starts_with', 'contains', 'ends_with'] filter mode Source code in prettyqt/widgets/completer.py def get_filter_mode ( self ) -> constants . FilterModeStr : \"\"\"Return current filter mode. Returns: filter mode \"\"\" return constants . FILTER_MODES . inverse [ self . filterMode ()] get_sort_mode ( self ) Return current sort mode. Returns: Type Description Literal['unsorted', 'case_sensitive', 'case_insensitive'] sort mode Source code in prettyqt/widgets/completer.py def get_sort_mode ( self ) -> SortModeStr : \"\"\"Return current sort mode. Returns: sort mode \"\"\" return SORT_MODE . inverse [ self . modelSorting ()] set_completion_mode ( self , mode ) Set completion mode to use. Parameters: Name Type Description Default mode Literal['popup', 'inline', 'unfiltered_popup'] completion mode to use required Exceptions: Type Description InvalidParamError completion mode does not exist Source code in prettyqt/widgets/completer.py def set_completion_mode ( self , mode : CompletionModeStr ): \"\"\"Set completion mode to use. Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODE : raise InvalidParamError ( mode , COMPLETION_MODE ) self . setCompletionMode ( COMPLETION_MODE [ mode ]) set_filter_mode ( self , mode ) Set filter mode to use. Parameters: Name Type Description Default mode Literal['starts_with', 'contains', 'ends_with'] filter mode to use required Exceptions: Type Description InvalidParamError filter mode does not exist Source code in prettyqt/widgets/completer.py def set_filter_mode ( self , mode : constants . FilterModeStr ): \"\"\"Set filter mode to use. Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in constants . FILTER_MODES : raise InvalidParamError ( mode , constants . FILTER_MODES ) self . setFilterMode ( constants . FILTER_MODES [ mode ]) set_sort_mode ( self , mode ) Set sort mode to use. Parameters: Name Type Description Default mode Optional[Literal['unsorted', 'case_sensitive', 'case_insensitive']] sort mode to use required Exceptions: Type Description InvalidParamError sort mode does not exist Source code in prettyqt/widgets/completer.py def set_sort_mode ( self , mode : Optional [ SortModeStr ]): \"\"\"Set sort mode to use. Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODE : raise InvalidParamError ( mode , SORT_MODE ) self . setModelSorting ( SORT_MODE [ mode ]) datawidgetmapper DataWidgetMapper get_orientation ( self ) Return current orientation. Returns: Type Description Literal['horizontal', 'vertical'] orientation Source code in prettyqt/widgets/datawidgetmapper.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] get_submit_policy ( self ) Return current submit policy. Returns: Type Description Literal['auto', 'manual'] submit policy Source code in prettyqt/widgets/datawidgetmapper.py def get_submit_policy ( self ) -> SubmitPolicyStr : \"\"\"Return current submit policy. Returns: submit policy \"\"\" return SUBMIT_POLICY . inverse [ self . submitPolicy ()] set_orientation ( self , orientation ) Set the orientation of the data widget mapper. Parameters: Name Type Description Default orientation Literal['horizontal', 'vertical'] orientation for the data widget mapper required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the data widget mapper. Args: orientation: orientation for the data widget mapper Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) set_submit_policy ( self , policy ) Set the submit policy of the mapper. Parameters: Name Type Description Default policy Literal['auto', 'manual'] submit_policy for the data widget mapper required Exceptions: Type Description InvalidParamError submit_policy does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_submit_policy ( self , policy : SubmitPolicyStr ): \"\"\"Set the submit policy of the mapper. Args: policy: submit_policy for the data widget mapper Raises: InvalidParamError: submit_policy does not exist \"\"\" if policy not in SUBMIT_POLICY : raise InvalidParamError ( policy , SUBMIT_POLICY ) self . setSubmitPolicy ( SUBMIT_POLICY [ policy ]) dialog BaseDialog keyPressEvent ( self , e ) keyPressEvent(self, QKeyEvent) Source code in prettyqt/widgets/dialog.py def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e ) dialogbuttonbox DialogButtonBox add_button ( self , button , role = 'accept' , callback = None ) Add a button. Parameters: Name Type Description Default button Union[PyQt5.QtWidgets.QPushButton, Literal['cancel', 'ok', 'save', 'open', 'close', 'discard', 'apply', 'reset', 'restore_defaults', 'help', 'save_all', 'yes', 'yes_to_all', 'no', 'no_to_all', 'abort', 'retry', 'ignore']] button to add required role Literal['invalid', 'accept', 'reject', 'destructive', 'action', 'help', 'yes', 'no', 'apply', 'reset'] role of the button 'accept' callback Optional[Callable] function to call when button gets clicked None Returns: Type Description PushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_button ( self , button : Union [ QtWidgets . QPushButton , ButtonStr ], role : RoleStr = \"accept\" , callback : Optional [ Callable ] = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button add_default_button ( self , button , callback = None ) Add a default button. Parameters: Name Type Description Default button Literal['cancel', 'ok', 'save', 'open', 'close', 'discard', 'apply', 'reset', 'restore_defaults', 'help', 'save_all', 'yes', 'yes_to_all', 'no', 'no_to_all', 'abort', 'retry', 'ignore'] button to add required callback Optional[Callable] function to call when button gets clicked None Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_default_button ( self , button : ButtonStr , callback : Optional [ Callable ] = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn create ( ** kwargs ) classmethod create(self, window: sip.voidptr = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) Source code in prettyqt/widgets/dialogbuttonbox.py @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) # type: ignore return box get_orientation ( self ) Return current orientation. Returns: Type Description Literal['horizontal', 'vertical'] orientation Source code in prettyqt/widgets/dialogbuttonbox.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] set_orientation ( self , orientation ) Set the orientation of the button box. Parameters: Name Type Description Default orientation Literal['horizontal', 'vertical'] orientation for the button box required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the button box. Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) dockwidget DockWidget Customized DockWidget class. Contains a custom TitleBar with maximize button filedialog FileDialog Simple dialog used to display some widget. get_accept_mode ( self ) Return accept mode. Returns: Type Description Literal['save', 'open'] accept mode Source code in prettyqt/widgets/filedialog.py def get_accept_mode ( self ) -> AcceptModeStr : \"\"\"Return accept mode. Returns: accept mode \"\"\" return ACCEPT_MODE . inverse [ self . acceptMode ()] get_directory ( self ) Return current directory. returns current directory level as a Pathlib object Returns: Type Description Path Pathlib object Source code in prettyqt/widgets/filedialog.py def get_directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( self . directory () . absolutePath ()) get_file_mode ( self ) Return file mode. Returns: Type Description Literal['existing_file', 'existing_files', 'any_file', 'directory'] file mode Source code in prettyqt/widgets/filedialog.py def get_file_mode ( self ) -> FileModeStr : \"\"\"Return file mode. Returns: file mode \"\"\" return FILE_MODE . inverse [ self . fileMode ()] get_label_text ( self , label ) Return label text. Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py def get_label_text ( self , label : LabelStr ) -> str : \"\"\"Return label text. Returns: label text \"\"\" return self . labelText ( LABEL [ label ]) get_view_mode ( self ) Return view mode. Returns: Type Description Literal['detail', 'list'] view mode Source code in prettyqt/widgets/filedialog.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] set_accept_mode ( self , mode ) Set accept mode. Parameters: Name Type Description Default mode Literal['save', 'open'] accept mode to use required Exceptions: Type Description InvalidParamError invalid accept mode Source code in prettyqt/widgets/filedialog.py def set_accept_mode ( self , mode : AcceptModeStr ): \"\"\"Set accept mode. Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODE : raise InvalidParamError ( mode , ACCEPT_MODE ) self . setAcceptMode ( ACCEPT_MODE [ mode ]) set_directory ( self , path ) Set start directory. Source code in prettyqt/widgets/filedialog.py def set_directory ( self , path : Union [ str , pathlib . Path ]): \"\"\"Set start directory.\"\"\" if isinstance ( path , pathlib . Path ): path = str ( path ) self . setDirectory ( path ) set_extension_filter ( self , extension_dict ) Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict Dict[str, List[str]] filter dictionary required Source code in prettyqt/widgets/filedialog.py def set_extension_filter ( self , extension_dict : Dict [ str , List [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str ) set_file_mode ( self , mode ) Set the file mode of the dialog. Parameters: Name Type Description Default mode Literal['existing_file', 'existing_files', 'any_file', 'directory'] mode to use required Source code in prettyqt/widgets/filedialog.py def set_file_mode ( self , mode : FileModeStr ): \"\"\"Set the file mode of the dialog. Args: mode: mode to use \"\"\" self . setFileMode ( FILE_MODE [ mode ]) set_label_text ( self , label , text ) Set the label text for button label. Parameters: Name Type Description Default label Literal['look_in', 'filename', 'filetype', 'accept'] button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py def set_label_text ( self , label : LabelStr , text : str ): \"\"\"Set the label text for button label. Args: label: button to set text for text: text to use \"\"\" if label not in LABEL : raise InvalidParamError ( label , LABEL ) self . setLabelText ( LABEL [ label ], text ) set_view_mode ( self , mode ) Set view mode. Parameters: Name Type Description Default mode Literal['detail', 'list'] view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/filedialog.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) filesystemmodel FileSystemModel Class to populate a filesystem treeview. data ( self , index , role = 0 ) data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/widgets/filesystemmodel.py def data ( self , index , role = QtCore . Qt . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role ) fontcombobox FontComboBox get_font_filters ( self ) Return list of font filters. Returns: Type Description List[Literal['all', 'scalable', 'non_scalable', 'monospaced', 'proportional']] font filter list Source code in prettyqt/widgets/fontcombobox.py def get_font_filters ( self ) -> List [ FontFilterStr ]: \"\"\"Return list of font filters. Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()] set_font_filters ( self , * filters ) Set font filters. Parameters: Name Type Description Default filters Literal['all', 'scalable', 'non_scalable', 'monospaced', 'proportional'] font filters to use () Exceptions: Type Description InvalidParamError invalid font filters Source code in prettyqt/widgets/fontcombobox.py def set_font_filters ( self , * filters : FontFilterStr ): \"\"\"Set font filters. Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags ) formlayout FormLayout __len__ ( self ) special Needed for PySide2. Source code in prettyqt/widgets/formlayout.py def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount () get_field_growth_policy ( self ) Return current field growth policy. Returns: Type Description FieldGrowthPolicyStr field growth policy Source code in prettyqt/widgets/formlayout.py def get_field_growth_policy ( self ) -> FieldGrowthPolicyStr : \"\"\"Return current field growth policy. Returns: field growth policy \"\"\" return FIELD_GROWTH_POLICY . inverse [ self . fieldGrowthPolicy ()] get_row_wrap_policy ( self ) Return current row wrap policy. Returns: Type Description RowWrapPolicyStr row wrap policy Source code in prettyqt/widgets/formlayout.py def get_row_wrap_policy ( self ) -> RowWrapPolicyStr : \"\"\"Return current row wrap policy. Returns: row wrap policy \"\"\" return ROW_WRAP_POLICY . inverse [ self . rowWrapPolicy ()] set_field_growth_policy ( self , policy ) Set field growth policy to use. Parameters: Name Type Description Default policy FieldGrowthPolicyStr field growth policy to use required Exceptions: Type Description InvalidParamError field growth policy does not exist Source code in prettyqt/widgets/formlayout.py def set_field_growth_policy ( self , policy : FieldGrowthPolicyStr ): \"\"\"Set field growth policy to use. Args: policy: field growth policy to use Raises: InvalidParamError: field growth policy does not exist \"\"\" if policy not in FIELD_GROWTH_POLICY : raise InvalidParamError ( policy , FIELD_GROWTH_POLICY ) self . setFieldGrowthPolicy ( FIELD_GROWTH_POLICY [ policy ]) set_row_wrap_policy ( self , policy ) Set row wrap policy to use. Parameters: Name Type Description Default policy RowWrapPolicyStr row wrap policy to use required Exceptions: Type Description InvalidParamError row wrap policy does not exist Source code in prettyqt/widgets/formlayout.py def set_row_wrap_policy ( self , policy : RowWrapPolicyStr ): \"\"\"Set row wrap policy to use. Args: policy: row wrap policy to use Raises: InvalidParamError: row wrap policy does not exist \"\"\" if policy not in ROW_WRAP_POLICY : raise InvalidParamError ( policy , ROW_WRAP_POLICY ) self . setRowWrapPolicy ( ROW_WRAP_POLICY [ policy ]) frame Frame get_frame_shadow ( self ) Return current frame shadow. Returns: Type Description Optional[Literal['plain', 'raised', 'sunken']] frame style Source code in prettyqt/widgets/frame.py def get_frame_shadow ( self ) -> Optional [ ShadowStr ]: \"\"\"Return current frame shadow. Returns: frame style \"\"\" if ( frame_shadow := self . frameShadow ()) == 0 : return None return SHADOW . inverse [ frame_shadow ] get_frame_shape ( self ) Return current frame shape. Returns: Type Description Literal['no_frame', 'box', 'panel', 'styled_panel', 'h_line', 'v_line', 'win_panel'] frame shape Source code in prettyqt/widgets/frame.py def get_frame_shape ( self ) -> FrameShapeStr : \"\"\"Return current frame shape. Returns: frame shape \"\"\" return FRAME_SHAPE . inverse [ self . frameShape ()] set_frame_shadow ( self , style ) Set frame shadow. Parameters: Name Type Description Default style Literal['plain', 'raised', 'sunken'] frame style to use required Exceptions: Type Description InvalidParamError style does not exist Source code in prettyqt/widgets/frame.py def set_frame_shadow ( self , style : ShadowStr ): \"\"\"Set frame shadow. Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style is None : return if style not in SHADOW : raise InvalidParamError ( style , SHADOW ) self . setFrameShadow ( SHADOW [ style ]) set_frame_shape ( self , shape ) Set frame shape. Parameters: Name Type Description Default shape Literal['no_frame', 'box', 'panel', 'styled_panel', 'h_line', 'v_line', 'win_panel'] frame shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/widgets/frame.py def set_frame_shape ( self , shape : FrameShapeStr ): \"\"\"Set frame shape. Args: shape: frame shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in FRAME_SHAPE : raise InvalidParamError ( shape , FRAME_SHAPE ) self . setFrameShape ( FRAME_SHAPE [ shape ]) gesture Gesture get_gesture_cancel_policy ( self ) Return current gesture cancel policy. Returns: Type Description Literal['none', 'all_in_context'] gesture cancel policy Source code in prettyqt/widgets/gesture.py def get_gesture_cancel_policy ( self ) -> GestureCancelPolicyStr : \"\"\"Return current gesture cancel policy. Returns: gesture cancel policy \"\"\" return GESTURE_CANCEL_POLICY . inverse [ self . gestureCancelPolicy ()] get_gesture_type ( self ) Return current gesture type. Returns: Type Description Literal['tap', 'tap_and_hold', 'pan', 'pinch', 'swipe', 'custom'] gesture type Source code in prettyqt/widgets/gesture.py def get_gesture_type ( self ) -> constants . GestureTypeStr : \"\"\"Return current gesture type. Returns: gesture type \"\"\" return constants . GESTURE_TYPE . inverse [ self . gestureType ()] get_state ( self ) Return current state. Returns: Type Description Literal['none', 'started', 'updated', 'finished', 'canceled'] state Source code in prettyqt/widgets/gesture.py def get_state ( self ) -> constants . GestureStateStr : \"\"\"Return current state. Returns: state \"\"\" return constants . GESTURE_STATE . inverse [ self . state ()] set_gesture_cancel_policy ( self , policy ) Set gesture cancel policy. Parameters: Name Type Description Default policy Literal['none', 'all_in_context'] gesture cancel policy to use required Exceptions: Type Description InvalidParamError gesture cancel policy does not exist Source code in prettyqt/widgets/gesture.py def set_gesture_cancel_policy ( self , policy : GestureCancelPolicyStr ): \"\"\"Set gesture cancel policy. Args: policy: gesture cancel policy to use Raises: InvalidParamError: gesture cancel policy does not exist \"\"\" if policy not in GESTURE_CANCEL_POLICY : raise InvalidParamError ( policy , GESTURE_CANCEL_POLICY ) self . setGestureCancelPolicy ( GESTURE_CANCEL_POLICY [ policy ]) graphicsitem GraphicsItem get_panel_modality ( self ) Get the current modality modes as a string. Returns: Type Description Literal['none', 'panel', 'scene'] panel modality Source code in prettyqt/widgets/graphicsitem.py def get_panel_modality ( self ) -> PanelModalityStr : \"\"\"Get the current modality modes as a string. Returns: panel modality \"\"\" return MODALITY . inverse [ self . panelModality ()] set_panel_modality ( self , modality ) Set panel modality. Parameters: Name Type Description Default modality Literal['none', 'panel', 'scene'] panel modality required Exceptions: Type Description InvalidParamError panel modality does not exist Source code in prettyqt/widgets/graphicsitem.py def set_panel_modality ( self , modality : PanelModalityStr ) -> None : \"\"\"Set panel modality. Args: modality: panel modality Raises: InvalidParamError: panel modality does not exist \"\"\" if modality not in MODALITY : raise InvalidParamError ( modality , MODALITY ) self . setPanelModality ( MODALITY [ modality ]) graphicsscene GraphicsScene get_item_index_method ( self ) Return item index method. Returns: Type Description Literal['bsp_tree', 'none'] item index method Source code in prettyqt/widgets/graphicsscene.py def get_item_index_method ( self ) -> ItemIndexMethodStr : \"\"\"Return item index method. Returns: item index method \"\"\" return ITEM_INDEX_METHOD . inverse [ self . itemIndexMethod ()] set_item_index_method ( self , method ) Set item index method. Parameters: Name Type Description Default method Literal['bsp_tree', 'none'] item index method to use required Exceptions: Type Description InvalidParamError invalid item index method Source code in prettyqt/widgets/graphicsscene.py def set_item_index_method ( self , method : ItemIndexMethodStr ): \"\"\"Set item index method. Args: method: item index method to use Raises: InvalidParamError: invalid item index method \"\"\" if method not in ITEM_INDEX_METHOD : raise InvalidParamError ( method , ITEM_INDEX_METHOD ) self . setItemIndexMethod ( ITEM_INDEX_METHOD [ method ]) graphicsview GraphicsView get_cache_mode ( self ) Return current cache mode. Returns: Type Description Literal['none', 'background'] cache mode Source code in prettyqt/widgets/graphicsview.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Return current cache mode. Returns: cache mode \"\"\" return CACHE_MODES . inverse [ self . cacheMode ()] get_drag_mode ( self ) Return current drag mode. Returns: Type Description Literal['none', 'scroll_hand', 'rubber_band'] drag mode Source code in prettyqt/widgets/graphicsview.py def get_drag_mode ( self ) -> DragModeStr : \"\"\"Return current drag mode. Returns: drag mode \"\"\" return DRAG_MODE . inverse [ self . dragMode ()] get_resize_anchor ( self ) Return current resize anchor. Returns: Type Description Literal['none', 'view_center', 'under_mouse'] resize anchor Source code in prettyqt/widgets/graphicsview.py def get_resize_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current resize anchor. Returns: resize anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . resizeAnchor ()] get_rubberband_selection_mode ( self ) Return current rubberband selection mode. Returns: Type Description Literal['contains_shape', 'intersects_shape', 'contains_bounding_rect', 'intersects_bounding_rect'] rubberband selection mode Source code in prettyqt/widgets/graphicsview.py def get_rubberband_selection_mode ( self ) -> constants . ItemSelectionModeStr : \"\"\"Return current rubberband selection mode. Returns: rubberband selection mode \"\"\" return constants . ITEM_SELECTION_MODE . inverse [ self . rubberBandSelectionMode ()] get_transformation_anchor ( self ) Return current transformation anchor. Returns: Type Description Literal['none', 'view_center', 'under_mouse'] viewport anchor Source code in prettyqt/widgets/graphicsview.py def get_transformation_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current transformation anchor. Returns: viewport anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . transformationAnchor ()] get_viewport_update_mode ( self ) Return current viewport update mode. Returns: Type Description Literal['full', 'minimal', 'smart', 'bounding_rect', 'none'] viewport update mode Source code in prettyqt/widgets/graphicsview.py def get_viewport_update_mode ( self ) -> ViewportUpdateModeStr : \"\"\"Return current viewport update mode. Returns: viewport update mode \"\"\" return VIEWPORT_UPDATE_MODE . inverse [ self . viewportUpdateMode ()] set_cache_mode ( self , mode ) Set the cache mode. Parameters: Name Type Description Default mode Literal['none', 'background'] cache mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set the cache mode. Args: mode: cache mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ]) set_drag_mode ( self , mode ) Set the behavior for dragging the mouse while the left mouse button is pressed. Parameters: Name Type Description Default mode Literal['none', 'scroll_hand', 'rubber_band'] drag mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_drag_mode ( self , mode : DragModeStr ): \"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed. Args: mode: drag mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_MODE : raise InvalidParamError ( mode , DRAG_MODE ) self . setDragMode ( DRAG_MODE [ mode ]) set_resize_anchor ( self , mode ) Set how the view should position the scene during resizes. Parameters: Name Type Description Default mode Literal['none', 'view_center', 'under_mouse'] resize anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_resize_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during resizes. Args: mode: resize anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setResizeAnchor ( VIEWPORT_ANCHOR [ mode ]) set_rubberband_selection_mode ( self , mode ) Set the behavior for selecting items with a rubber band selection rectangle. Parameters: Name Type Description Default mode Literal['contains_shape', 'intersects_shape', 'contains_bounding_rect', 'intersects_bounding_rect'] rubberband selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_rubberband_selection_mode ( self , mode : constants . ItemSelectionModeStr ): \"\"\"Set the behavior for selecting items with a rubber band selection rectangle. Args: mode: rubberband selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) self . setRubberBandSelectionMode ( constants . ITEM_SELECTION_MODE [ mode ]) set_transformation_anchor ( self , mode ) Set how the view should position the scene during transformations. Parameters: Name Type Description Default mode Literal['none', 'view_center', 'under_mouse'] transformation anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_transformation_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during transformations. Args: mode: transformation anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setTransformationAnchor ( VIEWPORT_ANCHOR [ mode ]) set_viewport_update_mode ( self , mode ) Set how the viewport should update its contents. Parameters: Name Type Description Default mode Literal['full', 'minimal', 'smart', 'bounding_rect', 'none'] viewport update mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_viewport_update_mode ( self , mode : ViewportUpdateModeStr ): \"\"\"Set how the viewport should update its contents. Args: mode: viewport update mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_UPDATE_MODE : raise InvalidParamError ( mode , VIEWPORT_UPDATE_MODE ) self . setViewportUpdateMode ( VIEWPORT_UPDATE_MODE [ mode ]) graphicswidget GraphicsWidget get_focus_policy ( self ) Return way the widget accepts keyboard focus. Returns: Type Description Literal['tab', 'click', 'strong', 'wheel', 'none'] str: Focus policy Source code in prettyqt/widgets/graphicswidget.py def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return way the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()] set_focus_policy ( self , policy ) Set the way the widget accepts keyboard focus. Parameters: Name Type Description Default policy Literal['tab', 'click', 'strong', 'wheel', 'none'] Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/graphicswidget.py def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy: Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ]) window_frame_section_at ( self , point ) Return the window frame section at given position. Returns: Type Description Literal['none', 'text', 'text_beside_icon', 'text_below_icon'] str: Window frame section Source code in prettyqt/widgets/graphicswidget.py def window_frame_section_at ( self , point : Union [ QtCore . QPoint , Tuple [ int , int ]] ) -> constants . WindowFrameSectionStr : \"\"\"Return the window frame section at given position. Returns: str: Window frame section \"\"\" if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) return constants . WINDOW_FRAME_SECTION . inverse [ self . windowFrameSectionAt ( point )] gridlayout GridLayout get_origin_corner ( self ) Return current origin corner. Returns: Type Description Literal['top_left', 'top_right', 'bottom_left', 'bottom_right'] origin corner Source code in prettyqt/widgets/gridlayout.py def get_origin_corner ( self ) -> constants . CornerStr : \"\"\"Return current origin corner. Returns: origin corner \"\"\" return constants . CORNER . inverse [ self . originCorner ()] set_origin_corner ( self , corner ) Set the origin corner. Parameters: Name Type Description Default corner Literal['top_left', 'top_right', 'bottom_left', 'bottom_right'] origin corner required Exceptions: Type Description InvalidParamError corner does not exist Source code in prettyqt/widgets/gridlayout.py def set_origin_corner ( self , corner : constants . CornerStr ): \"\"\"Set the origin corner. Args: corner: origin corner Raises: InvalidParamError: corner does not exist \"\"\" if corner not in constants . CORNER : raise InvalidParamError ( corner , constants . CORNER ) self . setOriginCorner ( constants . CORNER [ corner ]) groupbox GroupBox GroupBox widget. A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets. headerview HeaderView contextMenuEvent ( self , event ) Context menu for our files tree. Source code in prettyqt/widgets/headerview.py def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) actions = self . get_header_actions () menu . add_actions ( actions ) menu . exec_ ( self . mapToGlobal ( event . pos ())) inputdialog InputDialog get_input_mode ( self ) Return input mode. Returns: Type Description Literal['text', 'int', 'double'] input mode Source code in prettyqt/widgets/inputdialog.py def get_input_mode ( self ) -> InputModeStr : \"\"\"Return input mode. Returns: input mode \"\"\" return INPUT_MODE . inverse [ self . inputMode ()] get_text_echo_mode ( self ) Return text echo mode. Returns: Type Description Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode Source code in prettyqt/widgets/inputdialog.py def get_text_echo_mode ( self ) -> widgets . lineedit . EchoModeStr : \"\"\"Return text echo mode. Returns: echo mode \"\"\" return widgets . lineedit . ECHO_MODE . inverse [ self . textEchoMode ()] set_input_mode ( self , mode ) Set input mode. Parameters: Name Type Description Default mode Literal['text', 'int', 'double'] input mode to use required Exceptions: Type Description InvalidParamError invalid input mode Source code in prettyqt/widgets/inputdialog.py def set_input_mode ( self , mode : InputModeStr ): \"\"\"Set input mode. Args: mode: input mode to use Raises: InvalidParamError: invalid input mode \"\"\" if mode not in INPUT_MODE : raise InvalidParamError ( mode , INPUT_MODE ) self . setInputMode ( INPUT_MODE [ mode ]) set_text_echo_mode ( self , mode ) Set text echo mode. Parameters: Name Type Description Default mode Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/inputdialog.py def set_text_echo_mode ( self , mode : widgets . lineedit . EchoModeStr ): \"\"\"Set text echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in widgets . lineedit . ECHO_MODE : raise InvalidParamError ( mode , widgets . lineedit . ECHO_MODE ) self . setTextEchoMode ( widgets . lineedit . ECHO_MODE [ mode ]) label Label get_text_format ( self ) Return current text format. Returns: Type Description TextFormatStr text format Source code in prettyqt/widgets/label.py def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] get_text_interaction ( self ) Return current text interaction mode. Returns: Type Description List[TextInteractionStr] list of text interaction modes Source code in prettyqt/widgets/label.py def get_text_interaction ( self ) -> List [ TextInteractionStr ]: \"\"\"Return current text interaction mode. Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()] set_alignment ( self , horizontal = None , vertical = None ) Set the alignment of the label's contents. Source code in prettyqt/widgets/label.py def set_alignment ( self , horizontal : Optional [ constants . HorizontalAlignmentStr ] = None , vertical : Optional [ constants . VerticalAlignmentStr ] = None , ): \"\"\"Set the alignment of the label's contents.\"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setAlignment ( flag ) return self set_indent ( self , indent ) Set the label's text indent in pixels. Source code in prettyqt/widgets/label.py def set_indent ( self , indent : int ) -> Label : \"\"\"Set the label's text indent in pixels.\"\"\" self . setIndent ( indent ) return self set_text ( self , text ) Set the label's text. Source code in prettyqt/widgets/label.py def set_text ( self , text : str ) -> Label : \"\"\"Set the label's text.\"\"\" self . setText ( text ) return self set_text_format ( self , text_format ) Set the text format. Parameters: Name Type Description Default text_format TextFormatStr text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/label.py def set_text_format ( self , text_format : TextFormatStr ) -> Label : \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) return self set_text_interaction ( self , * types ) Set the text interaction mode. Parameters: Name Type Description Default types TextInteractionStr text interaction mode to use () Exceptions: Type Description InvalidParamError text interaction mode does not exist Source code in prettyqt/widgets/label.py def set_text_interaction ( self , * types : TextInteractionStr ) -> Label : \"\"\"Set the text interaction mode. Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self set_weight ( self , weight ) Set the font weight. Parameters: Name Type Description Default weight gui.font.WeightStr font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/widgets/label.py def set_weight ( self , weight : gui . font . WeightStr ) -> Label : \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) font = self . font () font . setWeight ( gui . font . WEIGHT [ weight ]) self . setFont ( font ) return self layout Layout get_size_mode ( self ) Return current size mode. Returns: Type Description Literal['default', 'fixed', 'minimum', 'maximum', 'min_and_max', 'none'] size mode Source code in prettyqt/widgets/layout.py def get_size_mode ( self ) -> SizeConstraintStr : \"\"\"Return current size mode. Returns: size mode \"\"\" return SIZE_CONSTRAINT . inverse [ self . sizeConstraint ()] set_alignment ( self , alignment , item = None ) Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Parameters: Name Type Description Default alignment Literal['top', 'left', 'right', 'bottom', 'top_left', 'top_right', 'bottom_left', 'bottom_right'] alignment for the layout required item Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] set alignment for specific child only None Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layout.py def set_alignment ( self , alignment : constants . AlignmentStr , item : Optional [ Union [ QtWidgets . QWidget , QtWidgets . QLayout ]] = None , ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) if item is not None : return self . setAlignment ( item , constants . ALIGNMENTS [ alignment ]) else : return self . setAlignment ( constants . ALIGNMENTS [ alignment ]) set_size_mode ( self , mode ) Set the size mode of the layout. Parameters: Name Type Description Default mode Literal['default', 'fixed', 'minimum', 'maximum', 'min_and_max', 'none'] size mode for the layout required Exceptions: Type Description InvalidParamError size mode does not exist Source code in prettyqt/widgets/layout.py def set_size_mode ( self , mode : SizeConstraintStr ): \"\"\"Set the size mode of the layout. Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in SIZE_CONSTRAINT : raise InvalidParamError ( mode , SIZE_CONSTRAINT ) self . setSizeConstraint ( SIZE_CONSTRAINT [ mode ]) lcdnumber LCDNumber get_mode ( self ) Return current lcd mode. Returns: Type Description Literal['hex', 'decimal', 'octal', 'binary'] lcd mode Source code in prettyqt/widgets/lcdnumber.py def get_mode ( self ) -> ModeStr : \"\"\"Return current lcd mode. Returns: lcd mode \"\"\" return MODE . inverse [ self . mode ()] get_segment_style ( self ) Return current segment style. Returns: Type Description Literal['outline', 'filled', 'flat'] segment style Source code in prettyqt/widgets/lcdnumber.py def get_segment_style ( self ) -> SegmentStyleStr : \"\"\"Return current segment style. Returns: segment style \"\"\" return SEGMENT_STYLE . inverse [ self . segmentStyle ()] set_mode ( self , mode ) Set the lcd mode. Parameters: Name Type Description Default mode Literal['hex', 'decimal', 'octal', 'binary'] lcd mode to use required Exceptions: Type Description InvalidParamError lcd mode does not exist Source code in prettyqt/widgets/lcdnumber.py def set_mode ( self , mode : ModeStr ): \"\"\"Set the lcd mode. Args: mode: lcd mode to use Raises: InvalidParamError: lcd mode does not exist \"\"\" if mode not in MODE : raise InvalidParamError ( mode , MODE ) self . setMode ( MODE [ mode ]) set_segment_style ( self , mode ) Set the segment style. Parameters: Name Type Description Default mode Literal['outline', 'filled', 'flat'] segment style to use required Exceptions: Type Description InvalidParamError segment style does not exist Source code in prettyqt/widgets/lcdnumber.py def set_segment_style ( self , mode : SegmentStyleStr ): \"\"\"Set the segment style. Args: mode: segment style to use Raises: InvalidParamError: segment style does not exist \"\"\" if mode not in SEGMENT_STYLE : raise InvalidParamError ( mode , SEGMENT_STYLE ) self . setSegmentStyle ( SEGMENT_STYLE [ mode ]) lineedit LineEdit font ( self ) font(self) -> QFont Source code in prettyqt/widgets/lineedit.py def font ( self ) -> gui . Font : return gui . Font ( super () . font ()) get_cursor_move_style ( self ) Return cursor move style. Returns: Type Description Literal['logical', 'visual'] cursor move style Source code in prettyqt/widgets/lineedit.py def get_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . cursorMoveStyle ()] get_echo_mode ( self ) Return echo mode. Returns: Type Description Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode Source code in prettyqt/widgets/lineedit.py def get_echo_mode ( self ) -> EchoModeStr : \"\"\"Return echo mode. Returns: echo mode \"\"\" return ECHO_MODE . inverse [ self . echoMode ()] set_cursor_move_style ( self , style ) Set cursor move style. Parameters: Name Type Description Default style Literal['logical', 'visual'] cursor move style to use required Exceptions: Type Description InvalidParamError invalid cursor move style Source code in prettyqt/widgets/lineedit.py def set_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set cursor move style. Args: style: cursor move style to use Raises: InvalidParamError: invalid cursor move style \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ]) set_echo_mode ( self , mode ) Set echo mode. Parameters: Name Type Description Default mode Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/lineedit.py def set_echo_mode ( self , mode : EchoModeStr ): \"\"\"Set echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODE : raise InvalidParamError ( mode , ECHO_MODE ) self . setEchoMode ( ECHO_MODE [ mode ]) set_read_only ( self , value = True ) Set text to read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) listview ListView get_flow ( self ) Return flow mode. Returns: Type Description Literal['left_to_right', 'top_to_bottom'] flow mode Source code in prettyqt/widgets/listview.py def get_flow ( self ) -> FlowStr : \"\"\"Return flow mode. Returns: flow mode \"\"\" return FLOW . inverse [ self . flow ()] get_layout_mode ( self ) Return layout mode. Returns: Type Description Literal['single_pass', 'batched'] layout mode Source code in prettyqt/widgets/listview.py def get_layout_mode ( self ) -> LayoutModeStr : \"\"\"Return layout mode. Returns: layout mode \"\"\" return LAYOUT_MODE . inverse [ self . layoutMode ()] get_movement ( self ) Return movement mode. Returns: Type Description Literal['static', 'free', 'snap'] movement mode Source code in prettyqt/widgets/listview.py def get_movement ( self ) -> MovementStr : \"\"\"Return movement mode. Returns: movement mode \"\"\" return MOVEMENT . inverse [ self . movement ()] get_resize_mode ( self ) Return resize mode. Returns: Type Description Literal['fixed', 'adjust'] resize mode Source code in prettyqt/widgets/listview.py def get_resize_mode ( self ) -> ResizeModeStr : \"\"\"Return resize mode. Returns: resize mode \"\"\" return RESIZE_MODE . inverse [ self . resizeMode ()] get_view_mode ( self ) Return view mode. Returns: Type Description Literal['list', 'icon'] view mode Source code in prettyqt/widgets/listview.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] set_flow ( self , mode ) Set flow mode. Parameters: Name Type Description Default mode Literal['left_to_right', 'top_to_bottom'] flow mode to use required Exceptions: Type Description InvalidParamError invalid flow mode Source code in prettyqt/widgets/listview.py def set_flow ( self , mode : FlowStr ): \"\"\"Set flow mode. Args: mode: flow mode to use Raises: InvalidParamError: invalid flow mode \"\"\" if mode not in FLOW : raise InvalidParamError ( mode , FLOW ) self . setFlow ( FLOW [ mode ]) set_layout_mode ( self , mode ) Set layout mode. Parameters: Name Type Description Default mode Literal['single_pass', 'batched'] layout mode to use required Exceptions: Type Description InvalidParamError invalid layout mode Source code in prettyqt/widgets/listview.py def set_layout_mode ( self , mode : LayoutModeStr ): \"\"\"Set layout mode. Args: mode: layout mode to use Raises: InvalidParamError: invalid layout mode \"\"\" if mode not in LAYOUT_MODE : raise InvalidParamError ( mode , LAYOUT_MODE ) self . setLayoutMode ( LAYOUT_MODE [ mode ]) set_movement ( self , mode ) Set movement mode. Parameters: Name Type Description Default mode Literal['static', 'free', 'snap'] movement mode to use required Exceptions: Type Description InvalidParamError invalid movement mode Source code in prettyqt/widgets/listview.py def set_movement ( self , mode : MovementStr ): \"\"\"Set movement mode. Args: mode: movement mode to use Raises: InvalidParamError: invalid movement mode \"\"\" if mode not in MOVEMENT : raise InvalidParamError ( mode , MOVEMENT ) self . setMovement ( MOVEMENT [ mode ]) set_resize_mode ( self , mode ) Set resize mode. Parameters: Name Type Description Default mode Literal['fixed', 'adjust'] resize mode to use required Exceptions: Type Description InvalidParamError invalid resize mode Source code in prettyqt/widgets/listview.py def set_resize_mode ( self , mode : ResizeModeStr ): \"\"\"Set resize mode. Args: mode: resize mode to use Raises: InvalidParamError: invalid resize mode \"\"\" if mode not in RESIZE_MODE : raise InvalidParamError ( mode , RESIZE_MODE ) self . setResizeMode ( RESIZE_MODE [ mode ]) set_view_mode ( self , mode ) Set view mode. Parameters: Name Type Description Default mode Literal['list', 'icon'] view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/listview.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) listwidgetitem ListWidgetItem get_checkstate ( self ) Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/listwidgetitem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] set_checkstate ( self , state ) Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/listwidgetitem.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) mainwindow MainWindow Class for our mainWindow. Includes all docks, a centralwidget and a toolbar add_toolbar ( self , toolbar , position = 'top' ) Adds a toolbar to the mainmenu at specified area. Parameters: Name Type Description Default toolbar QToolBar toolbar to use required position Literal['top', 'bottom', 'left', 'right', 'all', 'none'] position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBar ( constants . TOOLBAR_AREA [ position ], toolbar ) add_toolbar_break ( self , position = 'top' ) Adds a toolbar break to the given area behind the last item. Parameters: Name Type Description Default position Literal['top', 'bottom', 'left', 'right', 'all', 'none'] position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar_break ( self , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBarBreak ( constants . TOOLBAR_AREA [ position ]) createPopupMenu ( self ) createPopupMenu(self) -> QMenu Source code in prettyqt/widgets/mainwindow.py def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add ( action ) return menu save_window_state ( self , recursive = False ) Save current window state as QSetting. Parameters: Name Type Description Default recursive bool Description False Source code in prettyqt/widgets/mainwindow.py def save_window_state ( self , recursive : bool = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { self . windowTitle () !r} ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state () toggle_fullscreen ( self ) Toggle between fullscreen and regular size. Source code in prettyqt/widgets/mainwindow.py def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen () mdiarea MdiArea get_tab_position ( self ) Return current tab position. Returns: Type Description Literal['north', 'south', 'west', 'east'] tab position Source code in prettyqt/widgets/mdiarea.py def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return current tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()] get_view_mode ( self ) Return current view mode. Returns: Type Description Literal['default', 'tabbed'] view mode Source code in prettyqt/widgets/mdiarea.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return current view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()] get_window_order ( self ) Return current window order. Returns: Type Description Literal['creation', 'stacking', 'activation_history'] view mode Source code in prettyqt/widgets/mdiarea.py def get_window_order ( self ) -> WindowOrderStr : \"\"\"Return current window order. Returns: view mode \"\"\" return WINDOW_ORDER . inverse [ self . activationOrder ()] set_tab_position ( self , position ) Set tab position for the MDI area. Parameters: Name Type Description Default position Literal['north', 'south', 'west', 'east'] tabs position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/mdiarea.py def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the MDI area. Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ]) set_view_mode ( self , mode ) Set view mode for the MDI area. Parameters: Name Type Description Default mode Literal['default', 'tabbed'] view mode to use required Exceptions: Type Description InvalidParamError view mode does not exist Source code in prettyqt/widgets/mdiarea.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode for the MDI area. Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ]) set_window_order ( self , mode ) Set the window order behaviour for the MDI area. Parameters: Name Type Description Default mode Literal['creation', 'stacking', 'activation_history'] window order behaviour to use required Exceptions: Type Description InvalidParamError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py def set_window_order ( self , mode : WindowOrderStr ): \"\"\"Set the window order behaviour for the MDI area. Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDER : raise InvalidParamError ( mode , WINDOW_ORDER ) self . setActivationOrder ( WINDOW_ORDER [ mode ]) menu Menu add_action ( self , label , callback = None , icon = None , checkable = False , checked = False , shortcut = None , status_tip = None ) Add an action to the menu. Parameters: Name Type Description Default label Union[str, prettyqt.widgets.action.Action] Label for button required callback Callable gets called when action is triggered None icon Optional[Any] icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut Optional[str] Shortcut for action None status_tip Optional[str] Status tip to be shown in status bar None Returns: Type Description Action Action added to menu Source code in prettyqt/widgets/menu.py def add_action ( self , label : Union [ str , widgets . Action ], callback : Callable = None , icon : Optional [ Any ] = None , checkable : bool = False , checked : bool = False , shortcut : Optional [ str ] = None , status_tip : Optional [ str ] = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action add_separator ( self , text = None ) Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None Returns: Type Description WidgetAction Separator action Source code in prettyqt/widgets/menu.py def add_separator ( self , text : Optional [ str ] = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator set_icon ( self , icon ) Set the icon for the menu. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/menu.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) messagebox MessageBox add_button ( self , button ) Add a default button. Parameters: Name Type Description Default button Literal['none', 'cancel', 'ok', 'save', 'open', 'close', 'discard', 'apply', 'reset', 'restore_defaults', 'help', 'save_all', 'yes', 'yes_to_all', 'no', 'no_to_all', 'abort', 'retry', 'ignore'] button to add required Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/messagebox.py def add_button ( self , button : ButtonStr ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ]) get_text_format ( self ) Return current text format. Returns: Type Description Literal['rich', 'plain', 'auto'] text format Source code in prettyqt/widgets/messagebox.py def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()] set_icon ( self , icon ) Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path, NoneType, Literal['none', 'information', 'warning', 'critical', 'question']] icon to use required Source code in prettyqt/widgets/messagebox.py def set_icon ( self , icon : Union [ iconprovider . IconType , IconStr ]): if icon in ICONS : self . setIcon ( ICONS [ icon ]) else : ico = iconprovider . get_icon ( icon ) self . setIconPixmap ( ico . get_pixmap ( size = 64 )) set_text_format ( self , text_format ) Set the text format. Parameters: Name Type Description Default text_format Literal['rich', 'plain', 'auto'] text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/messagebox.py def set_text_format ( self , text_format : TextFormatStr ): \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) plaintextedit PlainTextEdit get_line_wrap_mode ( self ) Get the current wrap mode. Returns: Type Description Literal['none', 'widget_width'] Wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()] get_word_wrap_mode ( self ) Get the current word wrap mode. Returns: Type Description Literal['none', 'word', 'anywhere', 'boundary_or_anywhere'] Word wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()] set_line_wrap_mode ( self , mode ) Set line wrap mode. Parameters: Name Type Description Default mode Literal['none', 'widget_width'] line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ]) set_read_only ( self , value = True ) Make the PlainTextEdit read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value ) set_word_wrap_mode ( self , mode ) Set word wrap mode. Parameters: Name Type Description Default mode Literal['none', 'word', 'anywhere', 'boundary_or_anywhere'] word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ]) wheelEvent ( self , event ) Handle wheel event for zooming. Source code in prettyqt/widgets/plaintextedit.py def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event ) progressbar ProgressBar Progress dialog. wrapper for QtWidgets.QProgressBar get_alignment ( self ) Return current alignment. Returns: Type Description Literal['top', 'left', 'right', 'bottom', 'top_left', 'top_right', 'bottom_left', 'bottom_right'] alignment Source code in prettyqt/widgets/progressbar.py def get_alignment ( self ) -> constants . AlignmentStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . ALIGNMENTS . inverse [ self . alignment ()] get_orientation ( self ) Return current orientation. Returns: Type Description Literal['horizontal', 'vertical'] orientation Source code in prettyqt/widgets/progressbar.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] get_text_direction ( self ) Return current text direction. Returns: Type Description Literal['top_to_bottom', 'bottom_to_top'] Text direction Source code in prettyqt/widgets/progressbar.py def get_text_direction ( self ) -> TextDirectionStr : \"\"\"Return current text direction. Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inverse [ self . textDirection ()] set_alignment ( self , alignment ) Set the alignment of the layout. Parameters: Name Type Description Default alignment Literal['top', 'left', 'right', 'bottom', 'top_left', 'top_right', 'bottom_left', 'bottom_right'] alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/progressbar.py def set_alignment ( self , alignment : constants . AlignmentStr ): \"\"\"Set the alignment of the layout. Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) self . setAlignment ( constants . ALIGNMENTS [ alignment ]) set_orientation ( self , orientation ) Set the orientation of the progress bar. Parameters: Name Type Description Default orientation Literal['horizontal', 'vertical'] orientation for the progress bar required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/progressbar.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the progress bar. Args: orientation: orientation for the progress bar Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) set_text_direction ( self , text_direction ) Set the text direction of the layout. Parameters: Name Type Description Default text_direction Literal['top_to_bottom', 'bottom_to_top'] text direction for the layout required Exceptions: Type Description InvalidParamError text direction does not exist Source code in prettyqt/widgets/progressbar.py def set_text_direction ( self , text_direction : TextDirectionStr ): \"\"\"Set the text direction of the layout. Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ]) progressdialog ProgressDialog Progress dialog. Wrapper for QtWidgets.QProgressDialog scroller Scroller get_state ( self ) Return current state. Returns: Type Description Literal['inactive', 'pressed', 'dragging', 'scrolling'] state Source code in prettyqt/widgets/scroller.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()] scrollerproperties ScrollerProperties get_scroll_metric ( self , metric ) Return scroll metric. Parameters: Name Type Description Default metric Literal['mouse_press_event_delay', 'drag_start_distance', 'drag_velocity_smoothing_factor', 'axis_lock_threshold', 'scrolling_curve', 'deceleration_factor', 'minimum_velocity', 'maximum_velocity', 'maximum_click_through_velocity', 'accelerating_flick_maximum_time', 'accelerating_flick_speedup_factor', 'snap_position_ratio', 'snap_time', 'overshoot_drag_resistance_factor', 'overshoot_drag_distance_factor', 'overshoot_scroll_distance_factor', 'overshoot_scroll_time', 'horizontal_overshoot_policy', 'vertical_overshoot_policy', 'frame_rate', 'scroll_metric_count'] Scroll metric to get required Exceptions: Type Description InvalidParamError metric does not exist Returns: Type Description Any state Source code in prettyqt/widgets/scrollerproperties.py def get_scroll_metric ( self , metric : ScrollmetricStr ) -> Any : \"\"\"Return scroll metric. Args: metric: Scroll metric to get Raises: InvalidParamError: metric does not exist Returns: state \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) return self . scrollMetric ( SCROLL_METRIC [ metric ]) set_scroll_metric ( self , metric , value ) Set scroll metric. Parameters: Name Type Description Default metric Literal['mouse_press_event_delay', 'drag_start_distance', 'drag_velocity_smoothing_factor', 'axis_lock_threshold', 'scrolling_curve', 'deceleration_factor', 'minimum_velocity', 'maximum_velocity', 'maximum_click_through_velocity', 'accelerating_flick_maximum_time', 'accelerating_flick_speedup_factor', 'snap_position_ratio', 'snap_time', 'overshoot_drag_resistance_factor', 'overshoot_drag_distance_factor', 'overshoot_scroll_distance_factor', 'overshoot_scroll_time', 'horizontal_overshoot_policy', 'vertical_overshoot_policy', 'frame_rate', 'scroll_metric_count'] Scroll metric to set required value Any Value to set required Exceptions: Type Description InvalidParamError metric does not exist Source code in prettyqt/widgets/scrollerproperties.py def set_scroll_metric ( self , metric : ScrollmetricStr , value : Any ): \"\"\"Set scroll metric. Args: metric: Scroll metric to set value: Value to set Raises: InvalidParamError: metric does not exist \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) self . setScrollMetric ( SCROLL_METRIC [ metric ], value ) shortcut Shortcut get_context ( self ) Return shortcut context. Returns: Type Description Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context Source code in prettyqt/widgets/shortcut.py def get_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . context ()] get_key ( self ) Return the shortcut's key sequence. Returns: Type Description KeySequence Key sequence Source code in prettyqt/widgets/shortcut.py def get_key ( self ) -> gui . KeySequence : \"\"\"Return the shortcut's key sequence. Returns: Key sequence \"\"\" return gui . KeySequence ( self . key ()) set_context ( self , context ) Set shortcut context. Parameters: Name Type Description Default context Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/shortcut.py def set_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setContext ( constants . CONTEXT [ context ]) sizepolicy SizePolicy get_control_type ( self ) Return control type. Returns: Type Description Literal['default', 'buttonbox', 'checkbox', 'combobox', 'frame', 'groupbox', 'label', 'line', 'lineedit', 'pushbutton', 'radiobutton', 'slider', 'spinbox', 'tabwidget', 'toolbutton'] control type Source code in prettyqt/widgets/sizepolicy.py def get_control_type ( self ) -> ControlTypeStr : \"\"\"Return control type. Returns: control type \"\"\" return CONTROL_TYPE . inverse [ self . controlType ()] get_horizontal_policy ( self ) Return size policy. Returns: Type Description Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] horizontal size policy Source code in prettyqt/widgets/sizepolicy.py def get_horizontal_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: horizontal size policy \"\"\" return SIZE_POLICY . inverse [ self . horizontalPolicy ()] get_vertical_policy ( self ) Return size policy. Returns: Type Description Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] vertical size policy Source code in prettyqt/widgets/sizepolicy.py def get_vertical_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: vertical size policy \"\"\" return SIZE_POLICY . inverse [ self . verticalPolicy ()] set_control_type ( self , typ ) Set the control type. Parameters: Name Type Description Default typ Literal['default', 'buttonbox', 'checkbox', 'combobox', 'frame', 'groupbox', 'label', 'line', 'lineedit', 'pushbutton', 'radiobutton', 'slider', 'spinbox', 'tabwidget', 'toolbutton'] control type to set required Exceptions: Type Description InvalidParamError control type does not exist Source code in prettyqt/widgets/sizepolicy.py def set_control_type ( self , typ : ControlTypeStr ) -> None : \"\"\"Set the control type. Args: typ: control type to set Raises: InvalidParamError: control type does not exist \"\"\" if typ not in CONTROL_TYPE : raise InvalidParamError ( typ , CONTROL_TYPE ) self . setControlType ( CONTROL_TYPE [ typ ]) set_horizontal_policy ( self , policy ) Set the horizontal policy. Parameters: Name Type Description Default policy Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_horizontal_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setHorizontalPolicy ( SIZE_POLICY [ policy ]) set_vertical_policy ( self , policy ) Set the horizontal policy. Parameters: Name Type Description Default policy Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_vertical_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setVerticalPolicy ( SIZE_POLICY [ policy ]) slider Slider get_tick_position ( self ) Return tick position. Returns: Type Description Literal['none', 'both_sides', 'above', 'below'] tick position Source code in prettyqt/widgets/slider.py def get_tick_position ( self ) -> TickPositionStr : \"\"\"Return tick position. Returns: tick position \"\"\" return TICK_POSITION . inverse [ self . tickPosition ()] set_tick_position ( self , position ) Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Parameters: Name Type Description Default position Literal['none', 'both_sides', 'above', 'below', 'left', 'right'] position for the ticks required Source code in prettyqt/widgets/slider.py def set_tick_position ( self , position : TickPositionAllStr ): \"\"\"Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITION : raise InvalidParamError ( position , TICK_POSITION ) self . setTickPosition ( TICK_POSITION [ position ]) splitter Splitter get_orientation ( self ) Return current orientation. Returns: Type Description Literal['horizontal', 'vertical'] orientation Source code in prettyqt/widgets/splitter.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()] set_orientation ( self , orientation ) Set the orientation of the splitter. Parameters: Name Type Description Default orientation Literal['horizontal', 'vertical'] orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitter.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the splitter. Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ]) styleoptionslider StyleOptionSlider is_horizontal ( self ) Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == QtCore . Qt . Horizontal is_vertical ( self ) Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == QtCore . Qt . Vertical set_horizontal ( self ) Set slider orientation to horizontal. Source code in prettyqt/widgets/styleoptionslider.py def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = QtCore . Qt . Horizontal set_vertical ( self ) Set slider orientation to vertical. Source code in prettyqt/widgets/styleoptionslider.py def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = QtCore . Qt . Vertical swipegesture SwipeGesture get_horizontal_direction ( self ) Return horizontal direction of the gesture. Returns: Type Description Literal['none', 'left', 'right'] horizontal direction Source code in prettyqt/widgets/swipegesture.py def get_horizontal_direction ( self ) -> HorizontalDirectionStr : \"\"\"Return horizontal direction of the gesture. Returns: horizontal direction \"\"\" return SWIPE_DIRECTION . inverse [ self . horizontalDirection ()] get_vertical_direction ( self ) Return vertical direction of the gesture. Returns: Type Description Literal['none', 'up', 'down'] vertical direction Source code in prettyqt/widgets/swipegesture.py def get_vertical_direction ( self ) -> VerticalDirectionStr : \"\"\"Return vertical direction of the gesture. Returns: vertical direction \"\"\" return SWIPE_DIRECTION . inverse [ self . verticalDirection ()] systemtrayicon SystemTrayIcon set_icon ( self , icon ) Set the system tray icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/systemtrayicon.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) tabbar TabBar get_elide_mode ( self ) Return elide mode. Returns: Type Description Literal['left', 'right', 'middle', 'none'] elide mode Source code in prettyqt/widgets/tabbar.py def get_elide_mode ( self ) -> constants . ElideModeStr : \"\"\"Return elide mode. Returns: elide mode \"\"\" return constants . ELIDE_MODE . inverse [ self . elideMode ()] get_remove_behaviour ( self ) Return remove behaviour. Returns: Type Description Literal['left_tab', 'right_tab', 'previous_tab'] remove behaviour Source code in prettyqt/widgets/tabbar.py def get_remove_behaviour ( self ) -> RemoveBehaviourStr : \"\"\"Return remove behaviour. Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOUR . inverse [ self . selectionBehaviorOnRemove ()] mouseDoubleClickEvent ( self , event ) mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/widgets/tabbar.py def mouseDoubleClickEvent ( self , event ): event . accept () tab = self . tabAt ( event . pos ()) pos = QtGui . QCursor . pos () self . on_detach . emit ( tab , pos ) set_elide_mode ( self , mode ) Set elide mode. Parameters: Name Type Description Default mode Literal['left', 'right', 'middle', 'none'] elide mode to use required Exceptions: Type Description InvalidParamError invalid elide mode Source code in prettyqt/widgets/tabbar.py def set_elide_mode ( self , mode : constants . ElideModeStr ) -> None : \"\"\"Set elide mode. Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in constants . ELIDE_MODE : raise InvalidParamError ( mode , constants . ELIDE_MODE ) self . setElideMode ( constants . ELIDE_MODE [ mode ]) set_icon_size ( self , size ) Set size of the icons. Source code in prettyqt/widgets/tabbar.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) set_selection_behavior_on_remove ( self , mode ) Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Parameters: Name Type Description Default mode Literal['left_tab', 'right_tab', 'previous_tab'] new remove behaviour required Source code in prettyqt/widgets/tabbar.py def set_selection_behavior_on_remove ( self , mode : RemoveBehaviourStr ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOUR : raise InvalidParamError ( mode , REMOVE_BEHAVIOUR ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOUR [ mode ]) tableview TableView get_grid_style ( self ) Return grid style. Returns: Type Description Literal['none', 'solid', 'dash', 'dot', 'dash_dot', 'dash_dot_dot', 'custom_dash'] grid style Source code in prettyqt/widgets/tableview.py def get_grid_style ( self ) -> constants . PenStyleStr : \"\"\"Return grid style. Returns: grid style \"\"\" return constants . PEN_STYLE . inverse [ self . gridStyle ()] set_grid_style ( self , style ) Set grid style. Parameters: Name Type Description Default style Literal['none', 'solid', 'dash', 'dot', 'dash_dot', 'dash_dot_dot', 'custom_dash'] grid style to use required Exceptions: Type Description InvalidParamError invalid grid style Source code in prettyqt/widgets/tableview.py def set_grid_style ( self , style : constants . PenStyleStr ): \"\"\"Set grid style. Args: style: grid style to use Raises: InvalidParamError: invalid grid style \"\"\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setGridStyle ( constants . PEN_STYLE [ style ]) tablewidgetitem TableWidgetItem get_checkstate ( self ) Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/tablewidgetitem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()] set_checkstate ( self , state ) Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/tablewidgetitem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ]) set_icon ( self , icon ) Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/tablewidgetitem.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon ) set_text_alignment ( self , horizontal = None , vertical = None ) Set text alignment of the checkbox. Parameters: Name Type Description Default alignment text alignment to use required Exceptions: Type Description InvalidParamError invalid text alignment Source code in prettyqt/widgets/tablewidgetitem.py def set_text_alignment ( self , horizontal : Optional [ constants . HorizontalAlignmentStr ] = None , vertical : Optional [ constants . VerticalAlignmentStr ] = None , ): \"\"\"Set text alignment of the checkbox. Args: alignment: text alignment to use Raises: InvalidParamError: invalid text alignment \"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setTextAlignment ( flag ) tabwidget DetachedTab Window containing a detached tab. When a tab is detached, the contents are placed into this QMainWindow. The tab can be re-attached by closing the dialog Attributes: Name Type Description on_close signal, emitted when window is closed (widget, title, icon) closeEvent ( self , event ) closeEvent(self, QCloseEvent) Source code in prettyqt/widgets/tabwidget.py def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . get_id (), self . windowIcon ()) TabWidget Widget for managing the tabs section. attach_tab ( self , widget , name , icon = None , insert_at = None ) Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Parameters: Name Type Description Default widget Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] the content widget from the DetachedTab window required name str the name of the detached tab required icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] the window icon for the detached tab None insert_at Optional[int] insert the re-attached tab at the given index None Source code in prettyqt/widgets/tabwidget.py def attach_tab ( self , widget : Union [ QtWidgets . QWidget , QtWidgets . QLayout ], name : str , icon : iconprovider . IconType = None , insert_at : Optional [ int ] = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (iconprovider.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True ) close_detached_tabs ( self ) Close all tabs that are currently detached. Source code in prettyqt/widgets/tabwidget.py def close_detached_tabs ( self ): \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close () detach_tab ( self , index , point ) Detach tab by removing its contents and placing them in a DetachedTab window. Parameters: Name Type Description Default index int index location of the tab to be detached required point Union[PyQt5.QtCore.QPoint, Tuple[int, int]] screen pos for creating the new DetachedTab window required Returns: Type Description None Description Source code in prettyqt/widgets/tabwidget.py @core . Slot ( int , QtCore . QPoint ) def detach_tab ( self , index : int , point : Union [ QtCore . QPoint , Tuple [ int , int ]]): \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) name = self . tabText ( index ) icon = self . tabIcon ( index ) if icon . isNull (): icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab get_tab_position ( self ) Return tab position. Returns: Type Description Literal['north', 'south', 'west', 'east'] tab position Source code in prettyqt/widgets/tabwidget.py def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()] get_tab_shape ( self ) Return tab shape. Returns: Type Description Literal['rounded', 'triangular'] tab shape Source code in prettyqt/widgets/tabwidget.py def get_tab_shape ( self ) -> TabShapeStr : \"\"\"Return tab shape. Returns: tab shape \"\"\" return TAB_SHAPES . inverse [ self . tabShape ()] open_widget ( self , widget , title = 'Unnamed' ) Create a tab containing delivered widget. Source code in prettyqt/widgets/tabwidget.py @core . Slot ( QtWidgets . QWidget , str ) def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True ) set_icon_size ( self , size ) Set size of the icons. Source code in prettyqt/widgets/tabwidget.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) set_tab_position ( self , position ) Set tab position for the tabwidget. Parameters: Name Type Description Default position Literal['north', 'south', 'west', 'east'] tab position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the tabwidget. Args: position: tab position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ]) set_tab_shape ( self , shape ) Set tab shape for the tabwidget. Parameters: Name Type Description Default shape Literal['rounded', 'triangular'] tab shape to use required Exceptions: Type Description InvalidParamError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_shape ( self , shape : TabShapeStr ): \"\"\"Set tab shape for the tabwidget. Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ]) textedit TextEdit get_auto_formatting ( self ) Get the current auto formatting mode. Returns: Type Description AutoFormattingStr Auto formatting mode Source code in prettyqt/widgets/textedit.py def get_auto_formatting ( self ) -> AutoFormattingStr : \"\"\"Get the current auto formatting mode. Returns: Auto formatting mode \"\"\" return AUTO_FORMATTING . inverse [ self . autoFormatting ()] get_line_wrap_mode ( self ) Get the current wrap mode. Returns: Type Description LineWrapModeStr Wrap mode Source code in prettyqt/widgets/textedit.py def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()] get_word_wrap_mode ( self ) Get the current word wrap mode. Returns: Type Description gui.textoption.WordWrapModeStr Word wrap mode Source code in prettyqt/widgets/textedit.py def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()] set_auto_formatting ( self , mode ) Set auto formatting mode. Parameters: Name Type Description Default mode AutoFormattingStr auto formatting mode to use required Exceptions: Type Description InvalidParamError auto formatting mode does not exist Source code in prettyqt/widgets/textedit.py def set_auto_formatting ( self , mode : AutoFormattingStr ): \"\"\"Set auto formatting mode. Args: mode: auto formatting mode to use Raises: InvalidParamError: auto formatting mode does not exist \"\"\" if mode not in AUTO_FORMATTING : raise InvalidParamError ( mode , AUTO_FORMATTING ) self . setAutoFormatting ( AUTO_FORMATTING [ mode ]) set_line_wrap_mode ( self , mode ) Set line wrap mode. Parameters: Name Type Description Default mode LineWrapModeStr line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/textedit.py def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ]) set_word_wrap_mode ( self , mode ) Set word wrap mode. Parameters: Name Type Description Default mode gui.textoption.WordWrapModeStr word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/textedit.py def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ]) toolbar ToolBar add_separator ( self , text = None , before = None ) Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None before QAction insert separator before specific action None Returns: Type Description QAction Separator action Source code in prettyqt/widgets/toolbar.py def add_separator ( self , text : Optional [ str ] = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label ) get_style ( self ) Return current style. Returns: Type Description Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] style Source code in prettyqt/widgets/toolbar.py def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return current style. Returns: style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()] is_area_allowed ( self , area ) Check if toolbar is allowed at specified area. Parameters: Name Type Description Default area Literal['top', 'bottom', 'left', 'right', 'all', 'none'] area of the toolbar required Exceptions: Type Description InvalidParamError area does not exist Source code in prettyqt/widgets/toolbar.py def is_area_allowed ( self , area : constants . ToolbarAreaStr ) -> bool : \"\"\"Check if toolbar is allowed at specified area. Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in constants . TOOLBAR_AREA : raise InvalidParamError ( area , constants . TOOLBAR_AREA ) return self . isAreaAllowed ( constants . TOOLBAR_AREA [ area ]) set_icon_size ( self , size ) Set size of the icons. Source code in prettyqt/widgets/toolbar.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size ) toolbutton ToolButton get_arrow_type ( self ) Return arrow type. Returns: Type Description Literal['none', 'up', 'down', 'left', 'right'] arrow type Source code in prettyqt/widgets/toolbutton.py def get_arrow_type ( self ) -> constants . ArrowTypeStr : \"\"\"Return arrow type. Returns: arrow type \"\"\" return constants . ARROW_TYPE . inverse [ self . arrowType ()] get_popup_mode ( self ) Return popup mode. Returns: Type Description Literal['delayed', 'menu_button', 'instant'] popup mode Source code in prettyqt/widgets/toolbutton.py def get_popup_mode ( self ) -> PopupModeStr : \"\"\"Return popup mode. Returns: popup mode \"\"\" return POPUP_MODE . inverse [ self . popupMode ()] get_style ( self ) Return toolbutton style. Returns: Type Description Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] toolbutton style Source code in prettyqt/widgets/toolbutton.py def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return toolbutton style. Returns: toolbutton style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()] set_arrow_type ( self , mode ) Set the arrow type of the toolbutton. Parameters: Name Type Description Default mode Literal['none', 'up', 'down', 'left', 'right'] arrow type to use required Exceptions: Type Description InvalidParamError invalid arrow type Source code in prettyqt/widgets/toolbutton.py def set_arrow_type ( self , mode : constants . ArrowTypeStr ): \"\"\"Set the arrow type of the toolbutton. Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in constants . ARROW_TYPE : raise InvalidParamError ( mode , constants . ARROW_TYPE ) self . setArrowType ( constants . ARROW_TYPE [ mode ]) set_popup_mode ( self , mode ) Set the popup mode of the toolbutton. Parameters: Name Type Description Default mode Literal['delayed', 'menu_button', 'instant'] popup mode to use required Exceptions: Type Description InvalidParamError invalid popup mode Source code in prettyqt/widgets/toolbutton.py def set_popup_mode ( self , mode : PopupModeStr ): \"\"\"Set the popup mode of the toolbutton. Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODE : raise InvalidParamError ( mode , POPUP_MODE ) self . setPopupMode ( POPUP_MODE [ mode ]) set_style ( self , style ) Set the toolbutton style. Parameters: Name Type Description Default style Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] style to use required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/widgets/toolbutton.py def set_style ( self , style : constants . ToolButtonStyleStr ): \"\"\"Set the toolbutton style. Args: style: style to use Raises: InvalidParamError: invalid style \"\"\" if style not in constants . TOOLBUTTON_STYLE : raise InvalidParamError ( style , constants . TOOLBUTTON_STYLE ) self . setToolButtonStyle ( constants . TOOLBUTTON_STYLE [ style ]) treewidgetitem TreeWidgetItem get_checkstate ( self , column = 0 ) Return checkstate. Parameters: Name Type Description Default column int column 0 Returns: Type Description constants.StateStr checkstate Source code in prettyqt/widgets/treewidgetitem.py def get_checkstate ( self , column : int = 0 ) -> constants . StateStr : \"\"\"Return checkstate. Args: column: column Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ( column )] get_child_indicator_policy ( self ) Return current child indicator policy. Returns: Type Description ChildIndicatorPolicyStr child indicator policy Source code in prettyqt/widgets/treewidgetitem.py def get_child_indicator_policy ( self ) -> ChildIndicatorPolicyStr : \"\"\"Return current child indicator policy. Returns: child indicator policy \"\"\" return CHILD_INDICATOR_POLICY . inverse [ self . childIndicatorPolicy ()] set_checkstate ( self , state , column = 0 ) Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required column int column 0 Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py def set_checkstate ( self , state : constants . StateStr , column : int = 0 ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use column: column Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( column , constants . STATE [ state ]) set_child_indicator_policy ( self , policy ) Set the child indicator policy. Parameters: Name Type Description Default policy ChildIndicatorPolicyStr child indicator policy required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/treewidgetitem.py def set_child_indicator_policy ( self , policy : ChildIndicatorPolicyStr ): \"\"\"Set the child indicator policy. Args: policy: child indicator policy Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CHILD_INDICATOR_POLICY : raise InvalidParamError ( policy , CHILD_INDICATOR_POLICY ) self . setChildIndicatorPolicy ( CHILD_INDICATOR_POLICY [ policy ]) set_icon ( self , icon , column = 0 ) Set the icon for the action. Parameters: Name Type Description Default icon iconprovider.IconType icon to use required column int column 0 Source code in prettyqt/widgets/treewidgetitem.py def set_icon ( self , icon : iconprovider . IconType , column : int = 0 ): \"\"\"Set the icon for the action. Args: icon: icon to use column: column \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( column , icon ) undoview UndoView set_clean_icon ( self , icon ) Set the icon for the clean button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/undoview.py def set_clean_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setCleanIcon ( icon ) widget Widget get_contextmenu_policy ( self ) Return current contextmenu policy. Returns: Type Description Literal['none', 'prevent', 'default', 'actions', 'custom'] contextmenu policy Source code in prettyqt/widgets/widget.py def get_contextmenu_policy ( self ) -> constants . ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return constants . CONTEXT_POLICY . inverse [ self . contextMenuPolicy ()] get_focus_policy ( self ) Return waay the widget accepts keyboard focus. Returns: Type Description Literal['tab', 'click', 'strong', 'wheel', 'none'] str: Focus policy Source code in prettyqt/widgets/widget.py def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return waay the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()] get_modality ( self ) Get the current modality modes as a string. Returns: Type Description Literal['window', 'application', 'none'] modality mode Source code in prettyqt/widgets/widget.py def get_modality ( self ) -> constants . ModalityStr : \"\"\"Get the current modality modes as a string. Returns: modality mode \"\"\" return constants . MODALITY . inverse [ self . windowModality ()] get_window_state ( self ) Return current window state. Returns: Type Description Literal['none', 'minimized', 'maximized', 'fullscreen', 'active'] window state Source code in prettyqt/widgets/widget.py def get_window_state ( self ) -> constants . WindowStateStr : \"\"\"Return current window state. Returns: window state \"\"\" return constants . WINDOW_STATES . inverse [ self . windowState ()] resize ( self , * size ) resize(self, QSize) resize(self, int, int) Source code in prettyqt/widgets/widget.py def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size ) set_contextmenu_policy ( self , policy ) Set contextmenu policy for given item view. Parameters: Name Type Description Default policy Literal['none', 'prevent', 'default', 'actions', 'custom'] contextmenu policy to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_contextmenu_policy ( self , policy : constants . ContextPolicyStr ) -> None : \"\"\"Set contextmenu policy for given item view. Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . CONTEXT_POLICY : raise InvalidParamError ( policy , constants . CONTEXT_POLICY ) self . setContextMenuPolicy ( constants . CONTEXT_POLICY [ policy ]) set_focus_policy ( self , policy ) Set the way the widget accepts keyboard focus. Parameters: Name Type Description Default policy Literal['tab', 'click', 'strong', 'wheel', 'none'] Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/widget.py def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ]) set_icon ( self , icon ) Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/widget.py def set_icon ( self , icon : iconprovider . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon ) set_modality ( self , modality ) Set modality for the dialog. Parameters: Name Type Description Default modality Literal['window', 'application', 'none'] modality for the main window required Exceptions: Type Description InvalidParamError modality type does not exist Source code in prettyqt/widgets/widget.py def set_modality ( self , modality : constants . ModalityStr ) -> None : \"\"\"Set modality for the dialog. Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in constants . MODALITY : raise InvalidParamError ( modality , constants . MODALITY ) self . setWindowModality ( constants . MODALITY [ modality ]) set_size_policy ( self , horizontal = None , vertical = None ) Set the sizes policy. Parameters: Name Type Description Default horizontal Optional[Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored']] horizontal size policy None vertical Optional[Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored']] vertical size policy None Source code in prettyqt/widgets/widget.py def set_size_policy ( self , horizontal : Optional [ widgets . sizepolicy . SizePolicyStr ] = None , vertical : Optional [ widgets . sizepolicy . SizePolicyStr ] = None , ) -> None : \"\"\"Set the sizes policy. Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp ) set_window_state ( self , policy ) Set window state for given item view. Parameters: Name Type Description Default policy Literal['none', 'minimized', 'maximized', 'fullscreen', 'active'] window state to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_window_state ( self , policy : constants . WindowStateStr ) -> None : \"\"\"Set window state for given item view. Args: policy: window state to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . WINDOW_STATES : raise InvalidParamError ( policy , constants . WINDOW_STATES ) self . setWindowState ( constants . WINDOW_STATES [ policy ]) wizard Wizard get_button_text ( self , button_type ) Return text for given button type. Parameters: Name Type Description Default button_type WizardButtonStr button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizard.py def get_button_text ( self , button_type : WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . buttonText ( WIZARD_BUTTON [ button_type ]) get_option ( self , option ) Return the value assigned to option. Parameters: Name Type Description Default option WizardOptionStr option to get required Returns: Type Description bool option Source code in prettyqt/widgets/wizard.py def get_option ( self , option : WizardOptionStr ) -> bool : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) return self . testOption ( WIZARD_OPTIONS [ option ]) get_subtitle_format ( self ) Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str subtitle format Source code in prettyqt/widgets/wizard.py def get_subtitle_format ( self ) -> str : \"\"\"Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: subtitle format \"\"\" return TEXT_FORMATS . inverse [ self . subTitleFormat ()] get_title_format ( self ) Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str title format Source code in prettyqt/widgets/wizard.py def get_title_format ( self ) -> str : \"\"\"Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: title format \"\"\" return TEXT_FORMATS . inverse [ self . titleFormat ()] get_wizard_style ( self ) Return current wizard style. Returns: Type Description WizardStyleStr Wizard style Source code in prettyqt/widgets/wizard.py def get_wizard_style ( self ) -> WizardStyleStr : \"\"\"Return current wizard style. Returns: Wizard style \"\"\" return WIZARD_STYLE . inverse [ self . wizardStyle ()] set_button_text ( self , button_type , value ) Set text for given button type. Parameters: Name Type Description Default button_type WizardButtonStr button to get text from required value str text to set required Source code in prettyqt/widgets/wizard.py def set_button_text ( self , button_type : WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) self . setButtonText ( WIZARD_BUTTON [ button_type ], value ) set_option ( self , option , value ) Set option to given value. Parameters: Name Type Description Default option WizardOptionStr option to use required value bool value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/widgets/wizard.py def set_option ( self , option : WizardOptionStr , value : bool ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) self . setOption ( WIZARD_OPTIONS [ option ], value ) set_subtitle_format ( self , fmt ) Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt str subtitle format to use required Exceptions: Type Description InvalidParamError subtitle format does not exist Source code in prettyqt/widgets/wizard.py def set_subtitle_format ( self , fmt : str ): \"\"\"Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: subtitle format to use Raises: InvalidParamError: subtitle format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setSubTitleFormat ( TEXT_FORMATS [ fmt ]) set_title_format ( self , fmt ) Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt str title format to use required Exceptions: Type Description InvalidParamError title format does not exist Source code in prettyqt/widgets/wizard.py def set_title_format ( self , fmt : str ): \"\"\"Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: title format to use Raises: InvalidParamError: title format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setTitleFormat ( TEXT_FORMATS [ fmt ]) set_wizard_style ( self , style ) Set the wizard style. Parameters: Name Type Description Default style WizardStyleStr wizard style required Exceptions: Type Description InvalidParamError wizard style does not exist Source code in prettyqt/widgets/wizard.py def set_wizard_style ( self , style : WizardStyleStr ): \"\"\"Set the wizard style. Args: style: wizard style Raises: InvalidParamError: wizard style does not exist \"\"\" if style not in WIZARD_STYLE : raise InvalidParamError ( style , WIZARD_STYLE ) self . setWizardStyle ( WIZARD_STYLE [ style ]) wizardpage WizardPage get_button_text ( self , button_type ) Return text for given button type. Parameters: Name Type Description Default button_type Literal['back', 'next', 'commit', 'finish', 'cancel', 'help', 'custom_1', 'custom_2', 'custom_3'] button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizardpage.py def get_button_text ( self , button_type : widgets . wizard . WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) return self . buttonText ( widgets . wizard . WIZARD_BUTTON [ button_type ]) set_button_text ( self , button_type , value ) Set text for given button type. Parameters: Name Type Description Default button_type Literal['back', 'next', 'commit', 'finish', 'cancel', 'help', 'custom_1', 'custom_2', 'custom_3'] button to get text from required value str text to set required Source code in prettyqt/widgets/wizardpage.py def set_button_text ( self , button_type : widgets . wizard . WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) self . setButtonText ( widgets . wizard . WIZARD_BUTTON [ button_type ], value )","title":"widgets"},{"location":"api/widgets.html#widgets-module","text":"","title":"widgets module"},{"location":"api/widgets.html#prettyqt.widgets","text":"widgets module. contains QtWidgets-based classes","title":"prettyqt.widgets"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton","text":"","title":"abstractbutton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton","text":"","title":"AbstractButton"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton.set_icon","text":"Set the icon for the button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/abstractbutton.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton.set_icon_size","text":"Set size of the icon. Source code in prettyqt/widgets/abstractbutton.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icon.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.abstractbutton.AbstractButton.set_style_icon","text":"Set theme icon for the button. Parameters: Name Type Description Default icon Literal['titlebar_min_button=', 'titlebar_menu_button', 'titlebar_max_button', 'titlebar_close_button', 'titlebar_normal_button', 'titlebar_shade_button', 'titlebar_unshade_button', 'titlebar_context_help_button', 'information', 'warning', 'critical', 'question', 'desktop', 'trash', 'computer', 'drive_fd', 'drive_hd', 'drive_cd', 'drive_dvd', 'drive_net', 'dir_home', 'dir_open', 'dir_closed', 'dir', 'dir_link', 'dir_link_open', 'file', 'file_link', 'file_dialog_start', 'file_dialog_end', 'file_dialog_to_parent', 'file_dialog_new_folder', 'file_dialog_detailed_view', 'file_dialog_info_view', 'file_dialog_contents_view', 'file_dialog_list_view', 'file_dialog_back', 'dockwidget_close_button', 'toolbar_horizontal_extension', 'toolbar_vertical_extension', 'dialog_ok', 'dialog_cancel', 'dialog_help', 'dialog_open', 'dialog_save', 'dialog_close', 'dialog_apply', 'dialor_reset', 'dialog_discard', 'dialog_yes', 'dialog_no', 'arrow_up', 'arrow_down', 'arrow_left', 'arrow_right', 'arrow_back', 'arrow_forward', 'command_link', 'vista_shield', 'browser_reload', 'browser_stop', 'media_play', 'media_stop', 'media_pause', 'media_skip_forward', 'media_skip_backward', 'media_seek_forward', 'media_seek_backward', 'media_volume', 'media_volume_muted', 'lineedit_clear', 'custom_base'] icon to use required size int icon size 15 Source code in prettyqt/widgets/abstractbutton.py def set_style_icon ( self , icon : widgets . style . StandardPixmapStr , size : int = 15 ): \"\"\"Set theme icon for the button. Args: icon: icon to use size: icon size \"\"\" if icon not in widgets . style . STANDARD_PIXMAP : raise InvalidParamError ( icon , widgets . style . STANDARD_PIXMAP ) qicon = self . style () . standardIcon ( widgets . style . STANDARD_PIXMAP [ icon ], None , self ) self . set_icon ( qicon ) self . setIconSize ( core . Size ( size , size ))","title":"set_style_icon()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview","text":"","title":"abstractitemview"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView","text":"","title":"AbstractItemView"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_drag_drop_mode","text":"Return current drag-drop mode. Returns: Type Description Literal['none', 'drag', 'drop', 'drag_drop', 'internal'] drag-drop mode Source code in prettyqt/widgets/abstractitemview.py def get_drag_drop_mode ( self ) -> DragDropModeStr : \"\"\"Return current drag-drop mode. Returns: drag-drop mode \"\"\" return DRAG_DROP_MODE . inverse [ self . dragDropMode ()]","title":"get_drag_drop_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_behaviour","text":"Return current selection behaviour. Returns: Type Description Literal['rows', 'columns', 'items'] selection behaviour Source code in prettyqt/widgets/abstractitemview.py def get_selection_behaviour ( self ) -> SelectionBehaviourStr : \"\"\"Return current selection behaviour. Returns: selection behaviour \"\"\" return SELECTION_BEHAVIOUR . inverse [ self . selectionBehavior ()]","title":"get_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.get_selection_mode","text":"Return current selection mode. Returns: Type Description Literal['single', 'extended', 'multi', 'none'] selection mode Source code in prettyqt/widgets/abstractitemview.py def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.highlight_when_inactive","text":"Highlight items when widget does not have focus. Source code in prettyqt/widgets/abstractitemview.py def highlight_when_inactive ( self ): \"\"\"Highlight items when widget does not have focus.\"\"\" p = gui . Palette () p . highlight_inactive () self . setPalette ( p )","title":"highlight_when_inactive()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.jump_to_column","text":"Make sure column at given index is visible. scrolls to column at given index Parameters: Name Type Description Default col_num int column to scroll to required Source code in prettyqt/widgets/abstractitemview.py def jump_to_column ( self , col_num : int ): \"\"\"Make sure column at given index is visible. scrolls to column at given index Args: col_num: column to scroll to \"\"\" if self . model () is None : return idx = self . model () . index ( 0 , col_num ) self . scrollTo ( idx )","title":"jump_to_column()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.num_selected","text":"Return amount of selected rows. Returns: Type Description int amount of selected rows Source code in prettyqt/widgets/abstractitemview.py def num_selected ( self ) -> int : \"\"\"Return amount of selected rows. Returns: amount of selected rows \"\"\" if self . selectionModel () is None : return 0 return len ( self . selectionModel () . selectedRows ())","title":"num_selected()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_bottom","text":"Override to use abstractitemview-way of scrolling to bottom. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_bottom ( self ): \"\"\"Override to use abstractitemview-way of scrolling to bottom.\"\"\" self . scrollToBottom ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.scroll_to_top","text":"Override to use abstractitemview-way of scrolling to top. Source code in prettyqt/widgets/abstractitemview.py def scroll_to_top ( self ): \"\"\"Override to use abstractitemview-way of scrolling to top.\"\"\" self . scrollToTop ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selectAll","text":"Override, we dont want to selectAll for too many items bc of performance. Source code in prettyqt/widgets/abstractitemview.py def selectAll ( self ): \"\"\"Override, we dont want to selectAll for too many items bc of performance.\"\"\" if self . model () is None : return if self . model () . rowCount () * self . model () . columnCount () > 1_000_000 : logger . warning ( \"Too many cells to select.\" ) return super () . selectAll ()","title":"selectAll()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_data","text":"Returns generator yielding selected userData. Source code in prettyqt/widgets/abstractitemview.py def selected_data ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding selected userData.\"\"\" return ( x . data ( constants . USER_ROLE ) for x in self . selected_indexes ())","title":"selected_data()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_indexes","text":"Returns list of selected indexes in first row. Source code in prettyqt/widgets/abstractitemview.py def selected_indexes ( self ) -> List [ QtCore . QModelIndex ]: \"\"\"Returns list of selected indexes in first row.\"\"\" indexes = ( x for x in self . selectedIndexes () if x . column () == 0 ) return sorted ( indexes , key = lambda x : x . row ())","title":"selected_indexes()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_names","text":"Returns generator yielding item names. Source code in prettyqt/widgets/abstractitemview.py def selected_names ( self ) -> Generator [ Any , None , None ]: \"\"\"Returns generator yielding item names.\"\"\" return ( x . data ( constants . NAME_ROLE ) for x in self . selected_indexes ())","title":"selected_names()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.selected_rows","text":"Returns generator yielding row nums. Source code in prettyqt/widgets/abstractitemview.py def selected_rows ( self ) -> Generator [ int , None , None ]: \"\"\"Returns generator yielding row nums.\"\"\" return ( x . row () for x in self . selected_indexes ())","title":"selected_rows()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_drag_drop_mode","text":"Set drag-drop mode for given item view. Parameters: Name Type Description Default mode Literal['none', 'drag', 'drop', 'drag_drop', 'internal'] drag-drop mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_drag_drop_mode ( self , mode : DragDropModeStr ): \"\"\"Set drag-drop mode for given item view. Args: mode: drag-drop mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_DROP_MODE : raise InvalidParamError ( mode , DRAG_DROP_MODE ) self . setDragDropMode ( DRAG_DROP_MODE [ mode ])","title":"set_drag_drop_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_horizontal_scroll_mode","text":"Set the horizontal scroll mode. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_horizontal_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the horizontal scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ])","title":"set_horizontal_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_model","text":"Delete old selection model explicitely, seems to help with memory usage. Source code in prettyqt/widgets/abstractitemview.py def set_model ( self , model : Optional [ QtCore . QAbstractItemModel ]): \"\"\"Delete old selection model explicitely, seems to help with memory usage.\"\"\" old_model = self . model () old_sel_model = self . selectionModel () if old_model is not None or model is not None : self . setModel ( model ) # type: ignore # if old_model: # old_model.deleteLater() # del old_model if old_sel_model : old_sel_model . deleteLater () del old_sel_model","title":"set_model()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_scroll_mode","text":"Set the scroll mode for both directions. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the scroll mode for both directions. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setHorizontalScrollMode ( SCROLL_MODE [ mode ]) self . setVerticalScrollMode ( SCROLL_MODE [ mode ])","title":"set_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_behaviour","text":"Set selection behaviour for given item view. Parameters: Name Type Description Default behaviour Literal['rows', 'columns', 'items'] selection behaviour to use required Exceptions: Type Description InvalidParamError behaviour does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_behaviour ( self , behaviour : SelectionBehaviourStr ): \"\"\"Set selection behaviour for given item view. Args: behaviour: selection behaviour to use Raises: InvalidParamError: behaviour does not exist \"\"\" if behaviour not in SELECTION_BEHAVIOUR : raise InvalidParamError ( behaviour , SELECTION_BEHAVIOUR ) self . setSelectionBehavior ( SELECTION_BEHAVIOUR [ behaviour ])","title":"set_selection_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_selection_mode","text":"Set selection mode for given item view. Parameters: Name Type Description Default mode Optional[Literal['single', 'extended', 'multi', 'none']] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/abstractitemview.py def set_selection_mode ( self , mode : Optional [ SelectionModeStr ]): \"\"\"Set selection mode for given item view. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.set_vertical_scroll_mode","text":"Set the vertical scroll mode. Parameters: Name Type Description Default mode Literal['item', 'pixel'] mode to set required Exceptions: Type Description InvalidParamError invalid scroll mode Source code in prettyqt/widgets/abstractitemview.py def set_vertical_scroll_mode ( self , mode : ScrollModeStr ): \"\"\"Set the vertical scroll mode. Args: mode: mode to set Raises: InvalidParamError: invalid scroll mode \"\"\" if mode not in SCROLL_MODE : raise InvalidParamError ( mode , SCROLL_MODE ) self . setVerticalScrollMode ( SCROLL_MODE [ mode ])","title":"set_vertical_scroll_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractitemview.AbstractItemView.toggle_select_all","text":"Select all items from list (deselect when all selected). Source code in prettyqt/widgets/abstractitemview.py def toggle_select_all ( self ): \"\"\"Select all items from list (deselect when all selected).\"\"\" if self . selectionModel () is None : return if self . selectionModel () . hasSelection (): self . clearSelection () else : self . selectAll ()","title":"toggle_select_all()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea","text":"","title":"abstractscrollarea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea","text":"","title":"AbstractScrollArea"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.get_size_adjust_policy","text":"Return size adjust policy. Returns: Type Description Literal['content', 'first_show', 'ignored'] size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def get_size_adjust_policy ( self ) -> SizePolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_POLICY . inverse [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_bottom","text":"Scroll to the bottom of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_bottom ( self ): \"\"\"Scroll to the bottom of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_max ()","title":"scroll_to_bottom()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.scroll_to_top","text":"Scroll to the top of the scroll area. Source code in prettyqt/widgets/abstractscrollarea.py def scroll_to_top ( self ): \"\"\"Scroll to the top of the scroll area.\"\"\" self . verticalScrollBar () . scroll_to_min ()","title":"scroll_to_top()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_policy","text":"Set the horizontal scrollbar visibility. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the horizontal scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ])","title":"set_horizontal_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_horizontal_scrollbar_width","text":"Set the horizontal scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_horizontal_scrollbar_width ( self , width : int ): \"\"\"Set the horizontal scrollbar width. Args: width: width in pixels \"\"\" with self . h_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" )","title":"set_horizontal_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_policy","text":"Set the policy for both scrollbars. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the policy for both scrollbars. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setHorizontalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ]) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ])","title":"set_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_scrollbar_width","text":"Set the width for both scrollbars. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_scrollbar_width ( self , width : int ): \"\"\"Set the width for both scrollbars. Args: width: width in pixels \"\"\" self . set_horizontal_scrollbar_width ( width ) self . set_vertical_scrollbar_width ( width )","title":"set_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_size_adjust_policy","text":"Set size adjust policy. Parameters: Name Type Description Default policy Literal['content', 'first_show', 'ignored'] size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/abstractscrollarea.py def set_size_adjust_policy ( self , policy : SizePolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_POLICY : raise InvalidParamError ( policy , SIZE_POLICY ) self . setSizeAdjustPolicy ( SIZE_POLICY [ policy ])","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_policy","text":"Set the vertical scrollbar visibility. Parameters: Name Type Description Default mode Literal['always_on', 'always_off', 'as_needed'] visibilty to set required Exceptions: Type Description InvalidParamError invalid scrollbar policy Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_policy ( self , mode : constants . ScrollBarPolicyStr ): \"\"\"Set the vertical scrollbar visibility. Args: mode: visibilty to set Raises: InvalidParamError: invalid scrollbar policy \"\"\" if mode not in constants . SCROLLBAR_POLICY : raise InvalidParamError ( mode , constants . SCROLLBAR_POLICY ) self . setVerticalScrollBarPolicy ( constants . SCROLLBAR_POLICY [ mode ])","title":"set_vertical_scrollbar_policy()"},{"location":"api/widgets.html#prettyqt.widgets.abstractscrollarea.AbstractScrollArea.set_vertical_scrollbar_width","text":"Set the vertical scrollbar width. Parameters: Name Type Description Default width int width in pixels required Source code in prettyqt/widgets/abstractscrollarea.py def set_vertical_scrollbar_width ( self , width : int ): \"\"\"Set the vertical scrollbar width. Args: width: width in pixels \"\"\" with self . v_scrollbar . edit_stylesheet () as ss : ss . QScrollBar . horizontal . height . setValue ( f \" { width } px\" )","title":"set_vertical_scrollbar_width()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider","text":"","title":"abstractslider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider","text":"","title":"AbstractSlider"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.get_orientation","text":"Return current orientation. Returns: Type Description Literal['horizontal', 'vertical'] orientation Source code in prettyqt/widgets/abstractslider.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.get_repeat_action","text":"Get current repeat action. Returns: Type Description Literal['none', 'single_step_add', 'single_step_sub', 'page_step_add', 'page_step_sub', 'to_minimum', 'to_maximum', 'move'] current repeat action Source code in prettyqt/widgets/abstractslider.py def get_repeat_action ( self ) -> SliderActionStr : \"\"\"Get current repeat action. Returns: current repeat action \"\"\" return SLIDER_ACTION . inverse [ self . repeatAction ()]","title":"get_repeat_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_horizontal","text":"Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/abstractslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation () == QtCore . Qt . Horizontal","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.is_vertical","text":"Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/abstractslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation () == QtCore . Qt . Vertical","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_max","text":"Scroll to the maximum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_max ( self ): \"\"\"Scroll to the maximum value of the slider.\"\"\" self . setValue ( self . maximum ())","title":"scroll_to_max()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.scroll_to_min","text":"Scroll to the minimum value of the slider. Source code in prettyqt/widgets/abstractslider.py def scroll_to_min ( self ): \"\"\"Scroll to the minimum value of the slider.\"\"\" self . setValue ( self . minimum ())","title":"scroll_to_min()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_horizontal","text":"Set slider orientation to horizontal. Source code in prettyqt/widgets/abstractslider.py def set_horizontal ( self ): \"\"\"Set slider orientation to horizontal.\"\"\" self . setOrientation ( QtCore . Qt . Horizontal )","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_orientation","text":"Set the orientation of the slider. Parameters: Name Type Description Default orientation Literal['horizontal', 'vertical'] orientation for the slider required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/abstractslider.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the slider. Args: orientation: orientation for the slider Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_repeat_action","text":"Set the repeat action. Parameters: Name Type Description Default action Literal['none', 'single_step_add', 'single_step_sub', 'page_step_add', 'page_step_sub', 'to_minimum', 'to_maximum', 'move'] repeat action required Exceptions: Type Description InvalidParamError invalid repeat action Source code in prettyqt/widgets/abstractslider.py def set_repeat_action ( self , action : SliderActionStr , threshold : int = 500 , repeat_time : int = 50 ): \"\"\"Set the repeat action. Args: action: repeat action Raises: InvalidParamError: invalid repeat action \"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . setRepeatAction ( SLIDER_ACTION [ action ], threshold , repeat_time )","title":"set_repeat_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.set_vertical","text":"Set slider orientation to vertical. Source code in prettyqt/widgets/abstractslider.py def set_vertical ( self ): \"\"\"Set slider orientation to vertical.\"\"\" self . setOrientation ( QtCore . Qt . Vertical )","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.abstractslider.AbstractSlider.trigger_action","text":"Trigger slider action. Source code in prettyqt/widgets/abstractslider.py def trigger_action ( self , action : SliderActionStr ): \"\"\"Trigger slider action.\"\"\" if action not in SLIDER_ACTION : raise InvalidParamError ( action , SLIDER_ACTION ) self . triggerAction ( SLIDER_ACTION [ action ])","title":"trigger_action()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox","text":"","title":"abstractspinbox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox","text":"","title":"AbstractSpinBox"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_button_symbols","text":"Return button symbol type. Returns: Type Description Literal['up_down', 'plus_minus', 'none'] button symbol type Source code in prettyqt/widgets/abstractspinbox.py def get_button_symbols ( self ) -> SymbolStr : \"\"\"Return button symbol type. Returns: button symbol type \"\"\" return SYMBOLS . inverse [ self . buttonSymbols ()]","title":"get_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_correction_mode","text":"Return correction mode. Returns: Type Description Literal['to_previous', 'to_nearest'] correction mode Source code in prettyqt/widgets/abstractspinbox.py def get_correction_mode ( self ) -> CorrectionModeStr : \"\"\"Return correction mode. Returns: correction mode \"\"\" return CORRECTION_MODES . inverse [ self . correctionMode ()]","title":"get_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.get_step_type","text":"Return step type. Returns: Type Description Literal['default', 'adaptive'] step type Source code in prettyqt/widgets/abstractspinbox.py def get_step_type ( self ) -> StepTypeStr : \"\"\"Return step type. Returns: step type \"\"\" return STEP_TYPES . inverse [ self . stepType ()]","title":"get_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_button_symbols","text":"Set button symbol type. Parameters: Name Type Description Default mode Literal['up_down', 'plus_minus', 'none'] button symbol type to use required Exceptions: Type Description InvalidParamError invalid button symbol type Source code in prettyqt/widgets/abstractspinbox.py def set_button_symbols ( self , mode : SymbolStr ): \"\"\"Set button symbol type. Args: mode: button symbol type to use Raises: InvalidParamError: invalid button symbol type \"\"\" if mode not in SYMBOLS : raise InvalidParamError ( mode , SYMBOLS ) self . setButtonSymbols ( SYMBOLS [ mode ])","title":"set_button_symbols()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_correction_mode","text":"Set correction mode. Parameters: Name Type Description Default mode Literal['to_previous', 'to_nearest'] correction mode to use required Exceptions: Type Description InvalidParamError invalid correction mode Source code in prettyqt/widgets/abstractspinbox.py def set_correction_mode ( self , mode : CorrectionModeStr ): \"\"\"Set correction mode. Args: mode: correction mode to use Raises: InvalidParamError: invalid correction mode \"\"\" if mode not in CORRECTION_MODES : raise InvalidParamError ( mode , CORRECTION_MODES ) self . setCorrectionMode ( CORRECTION_MODES [ mode ])","title":"set_correction_mode()"},{"location":"api/widgets.html#prettyqt.widgets.abstractspinbox.AbstractSpinBox.set_step_type","text":"Set step type. Parameters: Name Type Description Default mode Literal['default', 'adaptive'] step type to use required Exceptions: Type Description InvalidParamError invalid step type Source code in prettyqt/widgets/abstractspinbox.py def set_step_type ( self , mode : StepTypeStr ): \"\"\"Set step type. Args: mode: step type to use Raises: InvalidParamError: invalid step type \"\"\" if mode not in STEP_TYPES : raise InvalidParamError ( mode , STEP_TYPES ) self . setStepType ( STEP_TYPES [ mode ])","title":"set_step_type()"},{"location":"api/widgets.html#prettyqt.widgets.action","text":"","title":"action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action","text":"","title":"Action"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_menu_role","text":"Return menu role. Returns: Type Description Literal['none', 'text_heuristic', 'application_specific', 'about_qt', 'about', 'preferences', 'quit'] menu role Source code in prettyqt/widgets/action.py def get_menu_role ( self ) -> RoleStr : \"\"\"Return menu role. Returns: menu role \"\"\" return ROLES . inverse [ self . menuRole ()]","title":"get_menu_role()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_priority","text":"Return current priority. Returns: Type Description Literal['low', 'normal', 'high'] priority Source code in prettyqt/widgets/action.py def get_priority ( self ) -> PriorityStr : \"\"\"Return current priority. Returns: priority \"\"\" return PRIORITIES . inverse [ self . priority ()]","title":"get_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.get_shortcut_context","text":"Return shortcut context. Returns: Type Description Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context Source code in prettyqt/widgets/action.py def get_shortcut_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . shortcutContext ()]","title":"get_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/action.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_menu_role","text":"Set menu role. Parameters: Name Type Description Default role Literal['none', 'text_heuristic', 'application_specific', 'about_qt', 'about', 'preferences', 'quit'] menu role required Exceptions: Type Description InvalidParamError menu role does not exist Source code in prettyqt/widgets/action.py def set_menu_role ( self , role : RoleStr ): \"\"\"Set menu role. Args: role: menu role Raises: InvalidParamError: menu role does not exist \"\"\" if role not in ROLES : raise InvalidParamError ( role , ROLES ) self . setMenuRole ( ROLES [ role ])","title":"set_menu_role()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_priority","text":"Set priority of the action. Parameters: Name Type Description Default priority Literal['low', 'normal', 'high'] priority for the action required Exceptions: Type Description InvalidParamError priority does not exist Source code in prettyqt/widgets/action.py def set_priority ( self , priority : PriorityStr ): \"\"\"Set priority of the action. Args: priority: priority for the action Raises: InvalidParamError: priority does not exist \"\"\" if priority not in PRIORITIES : raise InvalidParamError ( priority , PRIORITIES ) self . setPriority ( PRIORITIES [ priority ])","title":"set_priority()"},{"location":"api/widgets.html#prettyqt.widgets.action.Action.set_shortcut_context","text":"Set shortcut context. Parameters: Name Type Description Default context Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/action.py def set_shortcut_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setShortcutContext ( constants . CONTEXT [ context ])","title":"set_shortcut_context()"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup","text":"","title":"actiongroup"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup","text":"","title":"ActionGroup"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.get_exclusion_policy","text":"Return current exclusion policy. Returns: Type Description Literal['none', 'exclusive', 'exclusive_optional'] exclusion policy Source code in prettyqt/widgets/actiongroup.py def get_exclusion_policy ( self ) -> ExclusionPolicyStr : \"\"\"Return current exclusion policy. Returns: exclusion policy \"\"\" return POLICIES . inverse [ self . exclusionPolicy ()]","title":"get_exclusion_policy()"},{"location":"api/widgets.html#prettyqt.widgets.actiongroup.ActionGroup.set_exclusion_policy","text":"Set exclusion policy to use. Parameters: Name Type Description Default policy Optional[Literal['none', 'exclusive', 'exclusive_optional']] exclusion policy to use required Exceptions: Type Description InvalidParamError exclusion policy does not exist Source code in prettyqt/widgets/actiongroup.py def set_exclusion_policy ( self , policy : Optional [ ExclusionPolicyStr ]): \"\"\"Set exclusion policy to use. Args: policy: exclusion policy to use Raises: InvalidParamError: exclusion policy does not exist \"\"\" if policy is None : policy = \"none\" if policy not in POLICIES : raise InvalidParamError ( policy , POLICIES ) self . setExclusionPolicy ( POLICIES [ policy ])","title":"set_exclusion_policy()"},{"location":"api/widgets.html#prettyqt.widgets.application","text":"","title":"application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application","text":"","title":"Application"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.get_navigation_mode","text":"Return navigation mode. Returns: Type Description Literal['none', 'keypad_tab_order', 'keypad_directional', 'cursor_auto', 'cursor_force_visible'] navigation mode Source code in prettyqt/widgets/application.py def get_navigation_mode ( self ) -> constants . NavigationModeStr : \"\"\"Return navigation mode. Returns: navigation mode \"\"\" return constants . NAVIGATION_MODES . inverse [ self . navigationMode ()]","title":"get_navigation_mode()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.is_effect_enabled","text":"Return desktop effect state. Returns: Type Description bool desktop effect state Source code in prettyqt/widgets/application.py def is_effect_enabled ( self , effect : constants . UiEffectStr ) -> bool : \"\"\"Return desktop effect state. Returns: desktop effect state \"\"\" return self . isEffectEnabled ( constants . UI_EFFECTS [ effect ])","title":"is_effect_enabled()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.set_effect_enabled","text":"Set the enabled state of a desktop effect. Parameters: Name Type Description Default effect Literal['animate_menu', 'fade_menu', 'animate_combo', 'animate_tooltip', 'fade_tooltip', 'animate_toolbox'] desktop effect to set required enabled bool new state True Exceptions: Type Description InvalidParamError invalid desktop effect Source code in prettyqt/widgets/application.py def set_effect_enabled ( self , effect : constants . UiEffectStr , enabled : bool = True ): \"\"\"Set the enabled state of a desktop effect. Args: effect: desktop effect to set enabled: new state Raises: InvalidParamError: invalid desktop effect \"\"\" if effect not in constants . UI_EFFECTS : raise InvalidParamError ( effect , constants . UI_EFFECTS ) self . setEffectEnabled ( constants . UI_EFFECTS [ effect ])","title":"set_effect_enabled()"},{"location":"api/widgets.html#prettyqt.widgets.application.Application.set_navigation_mode","text":"Set the navigation mode. Parameters: Name Type Description Default mode Literal['none', 'keypad_tab_order', 'keypad_directional', 'cursor_auto', 'cursor_force_visible'] navigation mode to use required Exceptions: Type Description InvalidParamError invalid navigation mode Source code in prettyqt/widgets/application.py def set_navigation_mode ( self , mode : constants . NavigationModeStr ): \"\"\"Set the navigation mode. Args: mode: navigation mode to use Raises: InvalidParamError: invalid navigation mode \"\"\" if mode not in constants . NAVIGATION_MODES : raise InvalidParamError ( mode , constants . NAVIGATION_MODES ) self . setNavigationMode ( constants . NAVIGATION_MODES [ mode ])","title":"set_navigation_mode()"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout","text":"","title":"boxlayout"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayout","text":"","title":"BoxLayout"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayout.get_direction","text":"Return current direction. Returns: Type Description Literal['left_to_right', 'right_to_left', 'top_to_bottom', 'bottom_to_top'] direction Source code in prettyqt/widgets/boxlayout.py def get_direction ( self ) -> DirectionStr : \"\"\"Return current direction. Returns: direction \"\"\" return DIRECTION . inverse [ self . direction ()]","title":"get_direction()"},{"location":"api/widgets.html#prettyqt.widgets.boxlayout.BoxLayout.set_direction","text":"Set the direction. Parameters: Name Type Description Default direction Literal['left_to_right', 'right_to_left', 'top_to_bottom', 'bottom_to_top'] direction required Exceptions: Type Description InvalidParamError direction does not exist Source code in prettyqt/widgets/boxlayout.py def set_direction ( self , direction : DirectionStr ): \"\"\"Set the direction. Args: direction: direction Raises: InvalidParamError: direction does not exist \"\"\" if direction not in DIRECTION : raise InvalidParamError ( direction , DIRECTION ) self . setDirection ( DIRECTION [ direction ])","title":"set_direction()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget","text":"","title":"calendarwidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget","text":"","title":"CalendarWidget"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.get_selection_mode","text":"Return current selection mode. Returns: Type Description Literal['none', 'single'] selection mode Source code in prettyqt/widgets/calendarwidget.py def get_selection_mode ( self ) -> SelectionModeStr : \"\"\"Return current selection mode. Returns: selection mode \"\"\" return SELECTION_MODE . inverse [ self . selectionMode ()]","title":"get_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.calendarwidget.CalendarWidget.set_selection_mode","text":"Set selection mode for given calendar widget. Parameters: Name Type Description Default mode Optional[Literal['none', 'single']] selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/calendarwidget.py def set_selection_mode ( self , mode : Optional [ SelectionModeStr ]): \"\"\"Set selection mode for given calendar widget. Args: mode: selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode is None : mode = \"none\" if mode not in SELECTION_MODE : raise InvalidParamError ( mode , SELECTION_MODE ) self . setSelectionMode ( SELECTION_MODE [ mode ])","title":"set_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox","text":"","title":"checkbox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox","text":"","title":"CheckBox"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.get_checkstate","text":"Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/checkbox.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.checkbox.CheckBox.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/checkbox.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.combobox","text":"","title":"combobox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox","text":"","title":"ComboBox"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_insert_policy","text":"Return insert policy. Returns: Type Description Literal['no_insert', 'top', 'current', 'bottom', 'after_current', 'before_current', 'alphabetically'] insert policy Source code in prettyqt/widgets/combobox.py def get_insert_policy ( self ) -> InsertPolicyStr : \"\"\"Return insert policy. Returns: insert policy \"\"\" return INSERT_POLICY . inverse [ self . insertPolicy ()]","title":"get_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.get_size_adjust_policy","text":"Return size adjust policy. Returns: Type Description Literal['content', 'first_show', 'min_length', 'min_length_with_icon'] size adjust policy Source code in prettyqt/widgets/combobox.py def get_size_adjust_policy ( self ) -> SizeAdjustPolicyStr : \"\"\"Return size adjust policy. Returns: size adjust policy \"\"\" return SIZE_ADJUST_POLICY . inverse [ self . sizeAdjustPolicy ()]","title":"get_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_icon_size","text":"Set size of the icons. Source code in prettyqt/widgets/combobox.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_insert_policy","text":"Set insert policy. Parameters: Name Type Description Default policy Literal['no_insert', 'top', 'current', 'bottom', 'after_current', 'before_current', 'alphabetically'] insert policy to use required Exceptions: Type Description InvalidParamError invalid insert policy Source code in prettyqt/widgets/combobox.py def set_insert_policy ( self , policy : InsertPolicyStr ): \"\"\"Set insert policy. Args: policy: insert policy to use Raises: InvalidParamError: invalid insert policy \"\"\" if policy not in INSERT_POLICY : raise InvalidParamError ( policy , INSERT_POLICY ) self . setInsertPolicy ( INSERT_POLICY [ policy ])","title":"set_insert_policy()"},{"location":"api/widgets.html#prettyqt.widgets.combobox.ComboBox.set_size_adjust_policy","text":"Set size adjust policy. Parameters: Name Type Description Default policy Literal['content', 'first_show', 'min_length', 'min_length_with_icon'] size adjust policy to use required Exceptions: Type Description InvalidParamError invalid size adjust policy Source code in prettyqt/widgets/combobox.py def set_size_adjust_policy ( self , policy : SizeAdjustPolicyStr ): \"\"\"Set size adjust policy. Args: policy: size adjust policy to use Raises: InvalidParamError: invalid size adjust policy \"\"\" if policy not in SIZE_ADJUST_POLICY : raise InvalidParamError ( policy , SIZE_ADJUST_POLICY ) self . setSizeAdjustPolicy ( SIZE_ADJUST_POLICY [ policy ])","title":"set_size_adjust_policy()"},{"location":"api/widgets.html#prettyqt.widgets.completer","text":"","title":"completer"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer","text":"","title":"Completer"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_completion_mode","text":"Return current completion mode. Returns: Type Description Literal['popup', 'inline', 'unfiltered_popup'] completion mode Source code in prettyqt/widgets/completer.py def get_completion_mode ( self ) -> CompletionModeStr : \"\"\"Return current completion mode. Returns: completion mode \"\"\" return COMPLETION_MODE . inverse [ self . completionMode ()]","title":"get_completion_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_filter_mode","text":"Return current filter mode. Returns: Type Description Literal['starts_with', 'contains', 'ends_with'] filter mode Source code in prettyqt/widgets/completer.py def get_filter_mode ( self ) -> constants . FilterModeStr : \"\"\"Return current filter mode. Returns: filter mode \"\"\" return constants . FILTER_MODES . inverse [ self . filterMode ()]","title":"get_filter_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.get_sort_mode","text":"Return current sort mode. Returns: Type Description Literal['unsorted', 'case_sensitive', 'case_insensitive'] sort mode Source code in prettyqt/widgets/completer.py def get_sort_mode ( self ) -> SortModeStr : \"\"\"Return current sort mode. Returns: sort mode \"\"\" return SORT_MODE . inverse [ self . modelSorting ()]","title":"get_sort_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_completion_mode","text":"Set completion mode to use. Parameters: Name Type Description Default mode Literal['popup', 'inline', 'unfiltered_popup'] completion mode to use required Exceptions: Type Description InvalidParamError completion mode does not exist Source code in prettyqt/widgets/completer.py def set_completion_mode ( self , mode : CompletionModeStr ): \"\"\"Set completion mode to use. Args: mode: completion mode to use Raises: InvalidParamError: completion mode does not exist \"\"\" if mode not in COMPLETION_MODE : raise InvalidParamError ( mode , COMPLETION_MODE ) self . setCompletionMode ( COMPLETION_MODE [ mode ])","title":"set_completion_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_filter_mode","text":"Set filter mode to use. Parameters: Name Type Description Default mode Literal['starts_with', 'contains', 'ends_with'] filter mode to use required Exceptions: Type Description InvalidParamError filter mode does not exist Source code in prettyqt/widgets/completer.py def set_filter_mode ( self , mode : constants . FilterModeStr ): \"\"\"Set filter mode to use. Args: mode: filter mode to use Raises: InvalidParamError: filter mode does not exist \"\"\" if mode not in constants . FILTER_MODES : raise InvalidParamError ( mode , constants . FILTER_MODES ) self . setFilterMode ( constants . FILTER_MODES [ mode ])","title":"set_filter_mode()"},{"location":"api/widgets.html#prettyqt.widgets.completer.Completer.set_sort_mode","text":"Set sort mode to use. Parameters: Name Type Description Default mode Optional[Literal['unsorted', 'case_sensitive', 'case_insensitive']] sort mode to use required Exceptions: Type Description InvalidParamError sort mode does not exist Source code in prettyqt/widgets/completer.py def set_sort_mode ( self , mode : Optional [ SortModeStr ]): \"\"\"Set sort mode to use. Args: mode: sort mode to use Raises: InvalidParamError: sort mode does not exist \"\"\" if mode is None : mode = \"unsorted\" if mode not in SORT_MODE : raise InvalidParamError ( mode , SORT_MODE ) self . setModelSorting ( SORT_MODE [ mode ])","title":"set_sort_mode()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper","text":"","title":"datawidgetmapper"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper","text":"","title":"DataWidgetMapper"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_orientation","text":"Return current orientation. Returns: Type Description Literal['horizontal', 'vertical'] orientation Source code in prettyqt/widgets/datawidgetmapper.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.get_submit_policy","text":"Return current submit policy. Returns: Type Description Literal['auto', 'manual'] submit policy Source code in prettyqt/widgets/datawidgetmapper.py def get_submit_policy ( self ) -> SubmitPolicyStr : \"\"\"Return current submit policy. Returns: submit policy \"\"\" return SUBMIT_POLICY . inverse [ self . submitPolicy ()]","title":"get_submit_policy()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_orientation","text":"Set the orientation of the data widget mapper. Parameters: Name Type Description Default orientation Literal['horizontal', 'vertical'] orientation for the data widget mapper required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the data widget mapper. Args: orientation: orientation for the data widget mapper Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.datawidgetmapper.DataWidgetMapper.set_submit_policy","text":"Set the submit policy of the mapper. Parameters: Name Type Description Default policy Literal['auto', 'manual'] submit_policy for the data widget mapper required Exceptions: Type Description InvalidParamError submit_policy does not exist Source code in prettyqt/widgets/datawidgetmapper.py def set_submit_policy ( self , policy : SubmitPolicyStr ): \"\"\"Set the submit policy of the mapper. Args: policy: submit_policy for the data widget mapper Raises: InvalidParamError: submit_policy does not exist \"\"\" if policy not in SUBMIT_POLICY : raise InvalidParamError ( policy , SUBMIT_POLICY ) self . setSubmitPolicy ( SUBMIT_POLICY [ policy ])","title":"set_submit_policy()"},{"location":"api/widgets.html#prettyqt.widgets.dialog","text":"","title":"dialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.BaseDialog","text":"","title":"BaseDialog"},{"location":"api/widgets.html#prettyqt.widgets.dialog.BaseDialog.keyPressEvent","text":"keyPressEvent(self, QKeyEvent) Source code in prettyqt/widgets/dialog.py def keyPressEvent ( self , e ): if e . key () == QtCore . Qt . Key_Escape : self . close () elif e . key () == QtCore . Qt . Key_F11 : self . showNormal () if self . isMaximized () else self . showMaximized () else : super () . keyPressEvent ( e )","title":"keyPressEvent()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox","text":"","title":"dialogbuttonbox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox","text":"","title":"DialogButtonBox"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_button","text":"Add a button. Parameters: Name Type Description Default button Union[PyQt5.QtWidgets.QPushButton, Literal['cancel', 'ok', 'save', 'open', 'close', 'discard', 'apply', 'reset', 'restore_defaults', 'help', 'save_all', 'yes', 'yes_to_all', 'no', 'no_to_all', 'abort', 'retry', 'ignore']] button to add required role Literal['invalid', 'accept', 'reject', 'destructive', 'action', 'help', 'yes', 'no', 'apply', 'reset'] role of the button 'accept' callback Optional[Callable] function to call when button gets clicked None Returns: Type Description PushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_button ( self , button : Union [ QtWidgets . QPushButton , ButtonStr ], role : RoleStr = \"accept\" , callback : Optional [ Callable ] = None , ) -> widgets . PushButton : \"\"\"Add a button. Args: button: button to add role: role of the button callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if isinstance ( button , str ): button = widgets . PushButton ( button ) self . addButton ( button , ROLES [ role ]) if callback : button . clicked . connect ( callback ) return button","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.add_default_button","text":"Add a default button. Parameters: Name Type Description Default button Literal['cancel', 'ok', 'save', 'open', 'close', 'discard', 'apply', 'reset', 'restore_defaults', 'help', 'save_all', 'yes', 'yes_to_all', 'no', 'no_to_all', 'abort', 'retry', 'ignore'] button to add required callback Optional[Callable] function to call when button gets clicked None Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/dialogbuttonbox.py def add_default_button ( self , button : ButtonStr , callback : Optional [ Callable ] = None ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add callback: function to call when button gets clicked Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) btn = self . addButton ( BUTTONS [ button ]) btn . setObjectName ( button ) if callback : btn . clicked . connect ( callback ) return btn","title":"add_default_button()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.create","text":"create(self, window: sip.voidptr = 0, initializeWindow: bool = True, destroyOldWindow: bool = True) Source code in prettyqt/widgets/dialogbuttonbox.py @classmethod def create ( cls , ** kwargs ): box = cls () for k , v in kwargs . items (): box . add_default_button ( k , callback = v ) # type: ignore return box","title":"create()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.get_orientation","text":"Return current orientation. Returns: Type Description Literal['horizontal', 'vertical'] orientation Source code in prettyqt/widgets/dialogbuttonbox.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.dialogbuttonbox.DialogButtonBox.set_orientation","text":"Set the orientation of the button box. Parameters: Name Type Description Default orientation Literal['horizontal', 'vertical'] orientation for the button box required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/dialogbuttonbox.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the button box. Args: orientation: orientation for the button box Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.dockwidget","text":"","title":"dockwidget"},{"location":"api/widgets.html#prettyqt.widgets.dockwidget.DockWidget","text":"Customized DockWidget class. Contains a custom TitleBar with maximize button","title":"DockWidget"},{"location":"api/widgets.html#prettyqt.widgets.filedialog","text":"","title":"filedialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog","text":"Simple dialog used to display some widget.","title":"FileDialog"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_accept_mode","text":"Return accept mode. Returns: Type Description Literal['save', 'open'] accept mode Source code in prettyqt/widgets/filedialog.py def get_accept_mode ( self ) -> AcceptModeStr : \"\"\"Return accept mode. Returns: accept mode \"\"\" return ACCEPT_MODE . inverse [ self . acceptMode ()]","title":"get_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_directory","text":"Return current directory. returns current directory level as a Pathlib object Returns: Type Description Path Pathlib object Source code in prettyqt/widgets/filedialog.py def get_directory ( self ) -> pathlib . Path : \"\"\"Return current directory. returns current directory level as a Pathlib object Returns: Pathlib object \"\"\" return pathlib . Path ( self . directory () . absolutePath ())","title":"get_directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_file_mode","text":"Return file mode. Returns: Type Description Literal['existing_file', 'existing_files', 'any_file', 'directory'] file mode Source code in prettyqt/widgets/filedialog.py def get_file_mode ( self ) -> FileModeStr : \"\"\"Return file mode. Returns: file mode \"\"\" return FILE_MODE . inverse [ self . fileMode ()]","title":"get_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_label_text","text":"Return label text. Returns: Type Description str label text Source code in prettyqt/widgets/filedialog.py def get_label_text ( self , label : LabelStr ) -> str : \"\"\"Return label text. Returns: label text \"\"\" return self . labelText ( LABEL [ label ])","title":"get_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.get_view_mode","text":"Return view mode. Returns: Type Description Literal['detail', 'list'] view mode Source code in prettyqt/widgets/filedialog.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_accept_mode","text":"Set accept mode. Parameters: Name Type Description Default mode Literal['save', 'open'] accept mode to use required Exceptions: Type Description InvalidParamError invalid accept mode Source code in prettyqt/widgets/filedialog.py def set_accept_mode ( self , mode : AcceptModeStr ): \"\"\"Set accept mode. Args: mode: accept mode to use Raises: InvalidParamError: invalid accept mode \"\"\" if mode not in ACCEPT_MODE : raise InvalidParamError ( mode , ACCEPT_MODE ) self . setAcceptMode ( ACCEPT_MODE [ mode ])","title":"set_accept_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_directory","text":"Set start directory. Source code in prettyqt/widgets/filedialog.py def set_directory ( self , path : Union [ str , pathlib . Path ]): \"\"\"Set start directory.\"\"\" if isinstance ( path , pathlib . Path ): path = str ( path ) self . setDirectory ( path )","title":"set_directory()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_extension_filter","text":"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Parameters: Name Type Description Default extension_dict Dict[str, List[str]] filter dictionary required Source code in prettyqt/widgets/filedialog.py def set_extension_filter ( self , extension_dict : Dict [ str , List [ str ]]): \"\"\"Set filter based on given dictionary. dict must contain \"'name': ['.ext1', '.ext2']\" as key-value pairs Args: extension_dict: filter dictionary \"\"\" items = [ f \" { k } ( { ' ' . join ( f '* { ext } ' for ext in v ) } )\" for k , v in extension_dict . items () ] filter_str = \";;\" . join ( items ) self . setNameFilter ( filter_str )","title":"set_extension_filter()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_file_mode","text":"Set the file mode of the dialog. Parameters: Name Type Description Default mode Literal['existing_file', 'existing_files', 'any_file', 'directory'] mode to use required Source code in prettyqt/widgets/filedialog.py def set_file_mode ( self , mode : FileModeStr ): \"\"\"Set the file mode of the dialog. Args: mode: mode to use \"\"\" self . setFileMode ( FILE_MODE [ mode ])","title":"set_file_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_label_text","text":"Set the label text for button label. Parameters: Name Type Description Default label Literal['look_in', 'filename', 'filetype', 'accept'] button to set text for required text str text to use required Source code in prettyqt/widgets/filedialog.py def set_label_text ( self , label : LabelStr , text : str ): \"\"\"Set the label text for button label. Args: label: button to set text for text: text to use \"\"\" if label not in LABEL : raise InvalidParamError ( label , LABEL ) self . setLabelText ( LABEL [ label ], text )","title":"set_label_text()"},{"location":"api/widgets.html#prettyqt.widgets.filedialog.FileDialog.set_view_mode","text":"Set view mode. Parameters: Name Type Description Default mode Literal['detail', 'list'] view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/filedialog.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel","text":"","title":"filesystemmodel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel","text":"Class to populate a filesystem treeview.","title":"FileSystemModel"},{"location":"api/widgets.html#prettyqt.widgets.filesystemmodel.FileSystemModel.data","text":"data(self, QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any Source code in prettyqt/widgets/filesystemmodel.py def data ( self , index , role = QtCore . Qt . DisplayRole ): if role == self . DATA_ROLE : path = index . data ( self . FilePathRole ) return pathlib . Path ( path ) return super () . data ( index , role )","title":"data()"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox","text":"","title":"fontcombobox"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox","text":"","title":"FontComboBox"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.get_font_filters","text":"Return list of font filters. Returns: Type Description List[Literal['all', 'scalable', 'non_scalable', 'monospaced', 'proportional']] font filter list Source code in prettyqt/widgets/fontcombobox.py def get_font_filters ( self ) -> List [ FontFilterStr ]: \"\"\"Return list of font filters. Returns: font filter list \"\"\" return [ k for k , v in FONT_FILTERS . items () if v & self . fontFilters ()]","title":"get_font_filters()"},{"location":"api/widgets.html#prettyqt.widgets.fontcombobox.FontComboBox.set_font_filters","text":"Set font filters. Parameters: Name Type Description Default filters Literal['all', 'scalable', 'non_scalable', 'monospaced', 'proportional'] font filters to use () Exceptions: Type Description InvalidParamError invalid font filters Source code in prettyqt/widgets/fontcombobox.py def set_font_filters ( self , * filters : FontFilterStr ): \"\"\"Set font filters. Args: filters: font filters to use Raises: InvalidParamError: invalid font filters \"\"\" if not filters : filters = ( \"all\" ,) for item in filters : if item not in FONT_FILTERS : raise InvalidParamError ( item , FONT_FILTERS ) flags = helpers . merge_flags ( filters , FONT_FILTERS ) self . setFontFilters ( flags )","title":"set_font_filters()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout","text":"","title":"formlayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout","text":"","title":"FormLayout"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.__len__","text":"Needed for PySide2. Source code in prettyqt/widgets/formlayout.py def __len__ ( self ) -> int : \"\"\"Needed for PySide2.\"\"\" return self . rowCount ()","title":"__len__()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_field_growth_policy","text":"Return current field growth policy. Returns: Type Description FieldGrowthPolicyStr field growth policy Source code in prettyqt/widgets/formlayout.py def get_field_growth_policy ( self ) -> FieldGrowthPolicyStr : \"\"\"Return current field growth policy. Returns: field growth policy \"\"\" return FIELD_GROWTH_POLICY . inverse [ self . fieldGrowthPolicy ()]","title":"get_field_growth_policy()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.get_row_wrap_policy","text":"Return current row wrap policy. Returns: Type Description RowWrapPolicyStr row wrap policy Source code in prettyqt/widgets/formlayout.py def get_row_wrap_policy ( self ) -> RowWrapPolicyStr : \"\"\"Return current row wrap policy. Returns: row wrap policy \"\"\" return ROW_WRAP_POLICY . inverse [ self . rowWrapPolicy ()]","title":"get_row_wrap_policy()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_field_growth_policy","text":"Set field growth policy to use. Parameters: Name Type Description Default policy FieldGrowthPolicyStr field growth policy to use required Exceptions: Type Description InvalidParamError field growth policy does not exist Source code in prettyqt/widgets/formlayout.py def set_field_growth_policy ( self , policy : FieldGrowthPolicyStr ): \"\"\"Set field growth policy to use. Args: policy: field growth policy to use Raises: InvalidParamError: field growth policy does not exist \"\"\" if policy not in FIELD_GROWTH_POLICY : raise InvalidParamError ( policy , FIELD_GROWTH_POLICY ) self . setFieldGrowthPolicy ( FIELD_GROWTH_POLICY [ policy ])","title":"set_field_growth_policy()"},{"location":"api/widgets.html#prettyqt.widgets.formlayout.FormLayout.set_row_wrap_policy","text":"Set row wrap policy to use. Parameters: Name Type Description Default policy RowWrapPolicyStr row wrap policy to use required Exceptions: Type Description InvalidParamError row wrap policy does not exist Source code in prettyqt/widgets/formlayout.py def set_row_wrap_policy ( self , policy : RowWrapPolicyStr ): \"\"\"Set row wrap policy to use. Args: policy: row wrap policy to use Raises: InvalidParamError: row wrap policy does not exist \"\"\" if policy not in ROW_WRAP_POLICY : raise InvalidParamError ( policy , ROW_WRAP_POLICY ) self . setRowWrapPolicy ( ROW_WRAP_POLICY [ policy ])","title":"set_row_wrap_policy()"},{"location":"api/widgets.html#prettyqt.widgets.frame","text":"","title":"frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame","text":"","title":"Frame"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.get_frame_shadow","text":"Return current frame shadow. Returns: Type Description Optional[Literal['plain', 'raised', 'sunken']] frame style Source code in prettyqt/widgets/frame.py def get_frame_shadow ( self ) -> Optional [ ShadowStr ]: \"\"\"Return current frame shadow. Returns: frame style \"\"\" if ( frame_shadow := self . frameShadow ()) == 0 : return None return SHADOW . inverse [ frame_shadow ]","title":"get_frame_shadow()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.get_frame_shape","text":"Return current frame shape. Returns: Type Description Literal['no_frame', 'box', 'panel', 'styled_panel', 'h_line', 'v_line', 'win_panel'] frame shape Source code in prettyqt/widgets/frame.py def get_frame_shape ( self ) -> FrameShapeStr : \"\"\"Return current frame shape. Returns: frame shape \"\"\" return FRAME_SHAPE . inverse [ self . frameShape ()]","title":"get_frame_shape()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.set_frame_shadow","text":"Set frame shadow. Parameters: Name Type Description Default style Literal['plain', 'raised', 'sunken'] frame style to use required Exceptions: Type Description InvalidParamError style does not exist Source code in prettyqt/widgets/frame.py def set_frame_shadow ( self , style : ShadowStr ): \"\"\"Set frame shadow. Args: style: frame style to use Raises: InvalidParamError: style does not exist \"\"\" if style is None : return if style not in SHADOW : raise InvalidParamError ( style , SHADOW ) self . setFrameShadow ( SHADOW [ style ])","title":"set_frame_shadow()"},{"location":"api/widgets.html#prettyqt.widgets.frame.Frame.set_frame_shape","text":"Set frame shape. Parameters: Name Type Description Default shape Literal['no_frame', 'box', 'panel', 'styled_panel', 'h_line', 'v_line', 'win_panel'] frame shape to use required Exceptions: Type Description InvalidParamError shape does not exist Source code in prettyqt/widgets/frame.py def set_frame_shape ( self , shape : FrameShapeStr ): \"\"\"Set frame shape. Args: shape: frame shape to use Raises: InvalidParamError: shape does not exist \"\"\" if shape not in FRAME_SHAPE : raise InvalidParamError ( shape , FRAME_SHAPE ) self . setFrameShape ( FRAME_SHAPE [ shape ])","title":"set_frame_shape()"},{"location":"api/widgets.html#prettyqt.widgets.gesture","text":"","title":"gesture"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture","text":"","title":"Gesture"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.get_gesture_cancel_policy","text":"Return current gesture cancel policy. Returns: Type Description Literal['none', 'all_in_context'] gesture cancel policy Source code in prettyqt/widgets/gesture.py def get_gesture_cancel_policy ( self ) -> GestureCancelPolicyStr : \"\"\"Return current gesture cancel policy. Returns: gesture cancel policy \"\"\" return GESTURE_CANCEL_POLICY . inverse [ self . gestureCancelPolicy ()]","title":"get_gesture_cancel_policy()"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.get_gesture_type","text":"Return current gesture type. Returns: Type Description Literal['tap', 'tap_and_hold', 'pan', 'pinch', 'swipe', 'custom'] gesture type Source code in prettyqt/widgets/gesture.py def get_gesture_type ( self ) -> constants . GestureTypeStr : \"\"\"Return current gesture type. Returns: gesture type \"\"\" return constants . GESTURE_TYPE . inverse [ self . gestureType ()]","title":"get_gesture_type()"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.get_state","text":"Return current state. Returns: Type Description Literal['none', 'started', 'updated', 'finished', 'canceled'] state Source code in prettyqt/widgets/gesture.py def get_state ( self ) -> constants . GestureStateStr : \"\"\"Return current state. Returns: state \"\"\" return constants . GESTURE_STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/widgets.html#prettyqt.widgets.gesture.Gesture.set_gesture_cancel_policy","text":"Set gesture cancel policy. Parameters: Name Type Description Default policy Literal['none', 'all_in_context'] gesture cancel policy to use required Exceptions: Type Description InvalidParamError gesture cancel policy does not exist Source code in prettyqt/widgets/gesture.py def set_gesture_cancel_policy ( self , policy : GestureCancelPolicyStr ): \"\"\"Set gesture cancel policy. Args: policy: gesture cancel policy to use Raises: InvalidParamError: gesture cancel policy does not exist \"\"\" if policy not in GESTURE_CANCEL_POLICY : raise InvalidParamError ( policy , GESTURE_CANCEL_POLICY ) self . setGestureCancelPolicy ( GESTURE_CANCEL_POLICY [ policy ])","title":"set_gesture_cancel_policy()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem","text":"","title":"graphicsitem"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem","text":"","title":"GraphicsItem"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem.get_panel_modality","text":"Get the current modality modes as a string. Returns: Type Description Literal['none', 'panel', 'scene'] panel modality Source code in prettyqt/widgets/graphicsitem.py def get_panel_modality ( self ) -> PanelModalityStr : \"\"\"Get the current modality modes as a string. Returns: panel modality \"\"\" return MODALITY . inverse [ self . panelModality ()]","title":"get_panel_modality()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsitem.GraphicsItem.set_panel_modality","text":"Set panel modality. Parameters: Name Type Description Default modality Literal['none', 'panel', 'scene'] panel modality required Exceptions: Type Description InvalidParamError panel modality does not exist Source code in prettyqt/widgets/graphicsitem.py def set_panel_modality ( self , modality : PanelModalityStr ) -> None : \"\"\"Set panel modality. Args: modality: panel modality Raises: InvalidParamError: panel modality does not exist \"\"\" if modality not in MODALITY : raise InvalidParamError ( modality , MODALITY ) self . setPanelModality ( MODALITY [ modality ])","title":"set_panel_modality()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene","text":"","title":"graphicsscene"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene","text":"","title":"GraphicsScene"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.get_item_index_method","text":"Return item index method. Returns: Type Description Literal['bsp_tree', 'none'] item index method Source code in prettyqt/widgets/graphicsscene.py def get_item_index_method ( self ) -> ItemIndexMethodStr : \"\"\"Return item index method. Returns: item index method \"\"\" return ITEM_INDEX_METHOD . inverse [ self . itemIndexMethod ()]","title":"get_item_index_method()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsscene.GraphicsScene.set_item_index_method","text":"Set item index method. Parameters: Name Type Description Default method Literal['bsp_tree', 'none'] item index method to use required Exceptions: Type Description InvalidParamError invalid item index method Source code in prettyqt/widgets/graphicsscene.py def set_item_index_method ( self , method : ItemIndexMethodStr ): \"\"\"Set item index method. Args: method: item index method to use Raises: InvalidParamError: invalid item index method \"\"\" if method not in ITEM_INDEX_METHOD : raise InvalidParamError ( method , ITEM_INDEX_METHOD ) self . setItemIndexMethod ( ITEM_INDEX_METHOD [ method ])","title":"set_item_index_method()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview","text":"","title":"graphicsview"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView","text":"","title":"GraphicsView"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_cache_mode","text":"Return current cache mode. Returns: Type Description Literal['none', 'background'] cache mode Source code in prettyqt/widgets/graphicsview.py def get_cache_mode ( self ) -> CacheModeStr : \"\"\"Return current cache mode. Returns: cache mode \"\"\" return CACHE_MODES . inverse [ self . cacheMode ()]","title":"get_cache_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_drag_mode","text":"Return current drag mode. Returns: Type Description Literal['none', 'scroll_hand', 'rubber_band'] drag mode Source code in prettyqt/widgets/graphicsview.py def get_drag_mode ( self ) -> DragModeStr : \"\"\"Return current drag mode. Returns: drag mode \"\"\" return DRAG_MODE . inverse [ self . dragMode ()]","title":"get_drag_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_resize_anchor","text":"Return current resize anchor. Returns: Type Description Literal['none', 'view_center', 'under_mouse'] resize anchor Source code in prettyqt/widgets/graphicsview.py def get_resize_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current resize anchor. Returns: resize anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . resizeAnchor ()]","title":"get_resize_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_rubberband_selection_mode","text":"Return current rubberband selection mode. Returns: Type Description Literal['contains_shape', 'intersects_shape', 'contains_bounding_rect', 'intersects_bounding_rect'] rubberband selection mode Source code in prettyqt/widgets/graphicsview.py def get_rubberband_selection_mode ( self ) -> constants . ItemSelectionModeStr : \"\"\"Return current rubberband selection mode. Returns: rubberband selection mode \"\"\" return constants . ITEM_SELECTION_MODE . inverse [ self . rubberBandSelectionMode ()]","title":"get_rubberband_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_transformation_anchor","text":"Return current transformation anchor. Returns: Type Description Literal['none', 'view_center', 'under_mouse'] viewport anchor Source code in prettyqt/widgets/graphicsview.py def get_transformation_anchor ( self ) -> ViewportAnchorStr : \"\"\"Return current transformation anchor. Returns: viewport anchor \"\"\" return VIEWPORT_ANCHOR . inverse [ self . transformationAnchor ()]","title":"get_transformation_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.get_viewport_update_mode","text":"Return current viewport update mode. Returns: Type Description Literal['full', 'minimal', 'smart', 'bounding_rect', 'none'] viewport update mode Source code in prettyqt/widgets/graphicsview.py def get_viewport_update_mode ( self ) -> ViewportUpdateModeStr : \"\"\"Return current viewport update mode. Returns: viewport update mode \"\"\" return VIEWPORT_UPDATE_MODE . inverse [ self . viewportUpdateMode ()]","title":"get_viewport_update_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_cache_mode","text":"Set the cache mode. Parameters: Name Type Description Default mode Literal['none', 'background'] cache mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_cache_mode ( self , mode : CacheModeStr ): \"\"\"Set the cache mode. Args: mode: cache mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in CACHE_MODES : raise InvalidParamError ( mode , CACHE_MODES ) self . setCacheMode ( CACHE_MODES [ mode ])","title":"set_cache_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_drag_mode","text":"Set the behavior for dragging the mouse while the left mouse button is pressed. Parameters: Name Type Description Default mode Literal['none', 'scroll_hand', 'rubber_band'] drag mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_drag_mode ( self , mode : DragModeStr ): \"\"\"Set the behavior for dragging the mouse while the left mouse button is pressed. Args: mode: drag mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in DRAG_MODE : raise InvalidParamError ( mode , DRAG_MODE ) self . setDragMode ( DRAG_MODE [ mode ])","title":"set_drag_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_resize_anchor","text":"Set how the view should position the scene during resizes. Parameters: Name Type Description Default mode Literal['none', 'view_center', 'under_mouse'] resize anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_resize_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during resizes. Args: mode: resize anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setResizeAnchor ( VIEWPORT_ANCHOR [ mode ])","title":"set_resize_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_rubberband_selection_mode","text":"Set the behavior for selecting items with a rubber band selection rectangle. Parameters: Name Type Description Default mode Literal['contains_shape', 'intersects_shape', 'contains_bounding_rect', 'intersects_bounding_rect'] rubberband selection mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_rubberband_selection_mode ( self , mode : constants . ItemSelectionModeStr ): \"\"\"Set the behavior for selecting items with a rubber band selection rectangle. Args: mode: rubberband selection mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in constants . ITEM_SELECTION_MODE : raise InvalidParamError ( mode , constants . ITEM_SELECTION_MODE ) self . setRubberBandSelectionMode ( constants . ITEM_SELECTION_MODE [ mode ])","title":"set_rubberband_selection_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_transformation_anchor","text":"Set how the view should position the scene during transformations. Parameters: Name Type Description Default mode Literal['none', 'view_center', 'under_mouse'] transformation anchor to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_transformation_anchor ( self , mode : ViewportAnchorStr ): \"\"\"Set how the view should position the scene during transformations. Args: mode: transformation anchor to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_ANCHOR : raise InvalidParamError ( mode , VIEWPORT_ANCHOR ) self . setTransformationAnchor ( VIEWPORT_ANCHOR [ mode ])","title":"set_transformation_anchor()"},{"location":"api/widgets.html#prettyqt.widgets.graphicsview.GraphicsView.set_viewport_update_mode","text":"Set how the viewport should update its contents. Parameters: Name Type Description Default mode Literal['full', 'minimal', 'smart', 'bounding_rect', 'none'] viewport update mode to use required Exceptions: Type Description InvalidParamError mode does not exist Source code in prettyqt/widgets/graphicsview.py def set_viewport_update_mode ( self , mode : ViewportUpdateModeStr ): \"\"\"Set how the viewport should update its contents. Args: mode: viewport update mode to use Raises: InvalidParamError: mode does not exist \"\"\" if mode not in VIEWPORT_UPDATE_MODE : raise InvalidParamError ( mode , VIEWPORT_UPDATE_MODE ) self . setViewportUpdateMode ( VIEWPORT_UPDATE_MODE [ mode ])","title":"set_viewport_update_mode()"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget","text":"","title":"graphicswidget"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget","text":"","title":"GraphicsWidget"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget.get_focus_policy","text":"Return way the widget accepts keyboard focus. Returns: Type Description Literal['tab', 'click', 'strong', 'wheel', 'none'] str: Focus policy Source code in prettyqt/widgets/graphicswidget.py def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return way the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()]","title":"get_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget.set_focus_policy","text":"Set the way the widget accepts keyboard focus. Parameters: Name Type Description Default policy Literal['tab', 'click', 'strong', 'wheel', 'none'] Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/graphicswidget.py def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy: Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ])","title":"set_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.graphicswidget.GraphicsWidget.window_frame_section_at","text":"Return the window frame section at given position. Returns: Type Description Literal['none', 'text', 'text_beside_icon', 'text_below_icon'] str: Window frame section Source code in prettyqt/widgets/graphicswidget.py def window_frame_section_at ( self , point : Union [ QtCore . QPoint , Tuple [ int , int ]] ) -> constants . WindowFrameSectionStr : \"\"\"Return the window frame section at given position. Returns: str: Window frame section \"\"\" if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) return constants . WINDOW_FRAME_SECTION . inverse [ self . windowFrameSectionAt ( point )]","title":"window_frame_section_at()"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout","text":"","title":"gridlayout"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout","text":"","title":"GridLayout"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.get_origin_corner","text":"Return current origin corner. Returns: Type Description Literal['top_left', 'top_right', 'bottom_left', 'bottom_right'] origin corner Source code in prettyqt/widgets/gridlayout.py def get_origin_corner ( self ) -> constants . CornerStr : \"\"\"Return current origin corner. Returns: origin corner \"\"\" return constants . CORNER . inverse [ self . originCorner ()]","title":"get_origin_corner()"},{"location":"api/widgets.html#prettyqt.widgets.gridlayout.GridLayout.set_origin_corner","text":"Set the origin corner. Parameters: Name Type Description Default corner Literal['top_left', 'top_right', 'bottom_left', 'bottom_right'] origin corner required Exceptions: Type Description InvalidParamError corner does not exist Source code in prettyqt/widgets/gridlayout.py def set_origin_corner ( self , corner : constants . CornerStr ): \"\"\"Set the origin corner. Args: corner: origin corner Raises: InvalidParamError: corner does not exist \"\"\" if corner not in constants . CORNER : raise InvalidParamError ( corner , constants . CORNER ) self . setOriginCorner ( constants . CORNER [ corner ])","title":"set_origin_corner()"},{"location":"api/widgets.html#prettyqt.widgets.groupbox","text":"","title":"groupbox"},{"location":"api/widgets.html#prettyqt.widgets.groupbox.GroupBox","text":"GroupBox widget. A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets.","title":"GroupBox"},{"location":"api/widgets.html#prettyqt.widgets.headerview","text":"","title":"headerview"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView","text":"","title":"HeaderView"},{"location":"api/widgets.html#prettyqt.widgets.headerview.HeaderView.contextMenuEvent","text":"Context menu for our files tree. Source code in prettyqt/widgets/headerview.py def contextMenuEvent ( self , event ): \"\"\"Context menu for our files tree.\"\"\" menu = widgets . Menu ( parent = self ) actions = self . get_header_actions () menu . add_actions ( actions ) menu . exec_ ( self . mapToGlobal ( event . pos ()))","title":"contextMenuEvent()"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog","text":"","title":"inputdialog"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog","text":"","title":"InputDialog"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.get_input_mode","text":"Return input mode. Returns: Type Description Literal['text', 'int', 'double'] input mode Source code in prettyqt/widgets/inputdialog.py def get_input_mode ( self ) -> InputModeStr : \"\"\"Return input mode. Returns: input mode \"\"\" return INPUT_MODE . inverse [ self . inputMode ()]","title":"get_input_mode()"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.get_text_echo_mode","text":"Return text echo mode. Returns: Type Description Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode Source code in prettyqt/widgets/inputdialog.py def get_text_echo_mode ( self ) -> widgets . lineedit . EchoModeStr : \"\"\"Return text echo mode. Returns: echo mode \"\"\" return widgets . lineedit . ECHO_MODE . inverse [ self . textEchoMode ()]","title":"get_text_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.set_input_mode","text":"Set input mode. Parameters: Name Type Description Default mode Literal['text', 'int', 'double'] input mode to use required Exceptions: Type Description InvalidParamError invalid input mode Source code in prettyqt/widgets/inputdialog.py def set_input_mode ( self , mode : InputModeStr ): \"\"\"Set input mode. Args: mode: input mode to use Raises: InvalidParamError: invalid input mode \"\"\" if mode not in INPUT_MODE : raise InvalidParamError ( mode , INPUT_MODE ) self . setInputMode ( INPUT_MODE [ mode ])","title":"set_input_mode()"},{"location":"api/widgets.html#prettyqt.widgets.inputdialog.InputDialog.set_text_echo_mode","text":"Set text echo mode. Parameters: Name Type Description Default mode Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/inputdialog.py def set_text_echo_mode ( self , mode : widgets . lineedit . EchoModeStr ): \"\"\"Set text echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in widgets . lineedit . ECHO_MODE : raise InvalidParamError ( mode , widgets . lineedit . ECHO_MODE ) self . setTextEchoMode ( widgets . lineedit . ECHO_MODE [ mode ])","title":"set_text_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.label","text":"","title":"label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label","text":"","title":"Label"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_format","text":"Return current text format. Returns: Type Description TextFormatStr text format Source code in prettyqt/widgets/label.py def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.get_text_interaction","text":"Return current text interaction mode. Returns: Type Description List[TextInteractionStr] list of text interaction modes Source code in prettyqt/widgets/label.py def get_text_interaction ( self ) -> List [ TextInteractionStr ]: \"\"\"Return current text interaction mode. Returns: list of text interaction modes \"\"\" return [ k for k , v in TEXT_INTERACTION . items () if v & self . textInteractionFlags ()]","title":"get_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_alignment","text":"Set the alignment of the label's contents. Source code in prettyqt/widgets/label.py def set_alignment ( self , horizontal : Optional [ constants . HorizontalAlignmentStr ] = None , vertical : Optional [ constants . VerticalAlignmentStr ] = None , ): \"\"\"Set the alignment of the label's contents.\"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setAlignment ( flag ) return self","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_indent","text":"Set the label's text indent in pixels. Source code in prettyqt/widgets/label.py def set_indent ( self , indent : int ) -> Label : \"\"\"Set the label's text indent in pixels.\"\"\" self . setIndent ( indent ) return self","title":"set_indent()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text","text":"Set the label's text. Source code in prettyqt/widgets/label.py def set_text ( self , text : str ) -> Label : \"\"\"Set the label's text.\"\"\" self . setText ( text ) return self","title":"set_text()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_format","text":"Set the text format. Parameters: Name Type Description Default text_format TextFormatStr text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/label.py def set_text_format ( self , text_format : TextFormatStr ) -> Label : \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ]) return self","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_text_interaction","text":"Set the text interaction mode. Parameters: Name Type Description Default types TextInteractionStr text interaction mode to use () Exceptions: Type Description InvalidParamError text interaction mode does not exist Source code in prettyqt/widgets/label.py def set_text_interaction ( self , * types : TextInteractionStr ) -> Label : \"\"\"Set the text interaction mode. Args: types: text interaction mode to use Raises: InvalidParamError: text interaction mode does not exist \"\"\" for item in types : if item not in TEXT_INTERACTION : raise InvalidParamError ( item , TEXT_INTERACTION ) flags = helpers . merge_flags ( types , TEXT_INTERACTION ) self . setTextInteractionFlags ( flags ) return self","title":"set_text_interaction()"},{"location":"api/widgets.html#prettyqt.widgets.label.Label.set_weight","text":"Set the font weight. Parameters: Name Type Description Default weight gui.font.WeightStr font weight required Exceptions: Type Description InvalidParamError invalid font weight Source code in prettyqt/widgets/label.py def set_weight ( self , weight : gui . font . WeightStr ) -> Label : \"\"\"Set the font weight. Args: weight: font weight Raises: InvalidParamError: invalid font weight \"\"\" if weight not in gui . font . WEIGHT : raise InvalidParamError ( weight , gui . font . WEIGHT ) font = self . font () font . setWeight ( gui . font . WEIGHT [ weight ]) self . setFont ( font ) return self","title":"set_weight()"},{"location":"api/widgets.html#prettyqt.widgets.layout","text":"","title":"layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout","text":"","title":"Layout"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.get_size_mode","text":"Return current size mode. Returns: Type Description Literal['default', 'fixed', 'minimum', 'maximum', 'min_and_max', 'none'] size mode Source code in prettyqt/widgets/layout.py def get_size_mode ( self ) -> SizeConstraintStr : \"\"\"Return current size mode. Returns: size mode \"\"\" return SIZE_CONSTRAINT . inverse [ self . sizeConstraint ()]","title":"get_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_alignment","text":"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Parameters: Name Type Description Default alignment Literal['top', 'left', 'right', 'bottom', 'top_left', 'top_right', 'bottom_left', 'bottom_right'] alignment for the layout required item Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] set alignment for specific child only None Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/layout.py def set_alignment ( self , alignment : constants . AlignmentStr , item : Optional [ Union [ QtWidgets . QWidget , QtWidgets . QLayout ]] = None , ): \"\"\"Set the alignment for widget / layout to alignment. Returns true if w is found in this layout (not including child layouts). Args: alignment: alignment for the layout item: set alignment for specific child only Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) if item is not None : return self . setAlignment ( item , constants . ALIGNMENTS [ alignment ]) else : return self . setAlignment ( constants . ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.layout.Layout.set_size_mode","text":"Set the size mode of the layout. Parameters: Name Type Description Default mode Literal['default', 'fixed', 'minimum', 'maximum', 'min_and_max', 'none'] size mode for the layout required Exceptions: Type Description InvalidParamError size mode does not exist Source code in prettyqt/widgets/layout.py def set_size_mode ( self , mode : SizeConstraintStr ): \"\"\"Set the size mode of the layout. Args: mode: size mode for the layout Raises: InvalidParamError: size mode does not exist \"\"\" if mode not in SIZE_CONSTRAINT : raise InvalidParamError ( mode , SIZE_CONSTRAINT ) self . setSizeConstraint ( SIZE_CONSTRAINT [ mode ])","title":"set_size_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber","text":"","title":"lcdnumber"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber","text":"","title":"LCDNumber"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_mode","text":"Return current lcd mode. Returns: Type Description Literal['hex', 'decimal', 'octal', 'binary'] lcd mode Source code in prettyqt/widgets/lcdnumber.py def get_mode ( self ) -> ModeStr : \"\"\"Return current lcd mode. Returns: lcd mode \"\"\" return MODE . inverse [ self . mode ()]","title":"get_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.get_segment_style","text":"Return current segment style. Returns: Type Description Literal['outline', 'filled', 'flat'] segment style Source code in prettyqt/widgets/lcdnumber.py def get_segment_style ( self ) -> SegmentStyleStr : \"\"\"Return current segment style. Returns: segment style \"\"\" return SEGMENT_STYLE . inverse [ self . segmentStyle ()]","title":"get_segment_style()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_mode","text":"Set the lcd mode. Parameters: Name Type Description Default mode Literal['hex', 'decimal', 'octal', 'binary'] lcd mode to use required Exceptions: Type Description InvalidParamError lcd mode does not exist Source code in prettyqt/widgets/lcdnumber.py def set_mode ( self , mode : ModeStr ): \"\"\"Set the lcd mode. Args: mode: lcd mode to use Raises: InvalidParamError: lcd mode does not exist \"\"\" if mode not in MODE : raise InvalidParamError ( mode , MODE ) self . setMode ( MODE [ mode ])","title":"set_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lcdnumber.LCDNumber.set_segment_style","text":"Set the segment style. Parameters: Name Type Description Default mode Literal['outline', 'filled', 'flat'] segment style to use required Exceptions: Type Description InvalidParamError segment style does not exist Source code in prettyqt/widgets/lcdnumber.py def set_segment_style ( self , mode : SegmentStyleStr ): \"\"\"Set the segment style. Args: mode: segment style to use Raises: InvalidParamError: segment style does not exist \"\"\" if mode not in SEGMENT_STYLE : raise InvalidParamError ( mode , SEGMENT_STYLE ) self . setSegmentStyle ( SEGMENT_STYLE [ mode ])","title":"set_segment_style()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit","text":"","title":"lineedit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit","text":"","title":"LineEdit"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.font","text":"font(self) -> QFont Source code in prettyqt/widgets/lineedit.py def font ( self ) -> gui . Font : return gui . Font ( super () . font ())","title":"font()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_cursor_move_style","text":"Return cursor move style. Returns: Type Description Literal['logical', 'visual'] cursor move style Source code in prettyqt/widgets/lineedit.py def get_cursor_move_style ( self ) -> constants . CursorMoveStyleStr : \"\"\"Return cursor move style. Returns: cursor move style \"\"\" return constants . CURSOR_MOVE_STYLE . inverse [ self . cursorMoveStyle ()]","title":"get_cursor_move_style()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.get_echo_mode","text":"Return echo mode. Returns: Type Description Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode Source code in prettyqt/widgets/lineedit.py def get_echo_mode ( self ) -> EchoModeStr : \"\"\"Return echo mode. Returns: echo mode \"\"\" return ECHO_MODE . inverse [ self . echoMode ()]","title":"get_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_cursor_move_style","text":"Set cursor move style. Parameters: Name Type Description Default style Literal['logical', 'visual'] cursor move style to use required Exceptions: Type Description InvalidParamError invalid cursor move style Source code in prettyqt/widgets/lineedit.py def set_cursor_move_style ( self , style : constants . CursorMoveStyleStr ): \"\"\"Set cursor move style. Args: style: cursor move style to use Raises: InvalidParamError: invalid cursor move style \"\"\" if style not in constants . CURSOR_MOVE_STYLE : raise InvalidParamError ( style , constants . CURSOR_MOVE_STYLE ) self . setCursorMoveStyle ( constants . CURSOR_MOVE_STYLE [ style ])","title":"set_cursor_move_style()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_echo_mode","text":"Set echo mode. Parameters: Name Type Description Default mode Literal['normal', 'no_echo', 'password', 'echo_on_edit'] echo mode to use required Exceptions: Type Description InvalidParamError invalid echo mode Source code in prettyqt/widgets/lineedit.py def set_echo_mode ( self , mode : EchoModeStr ): \"\"\"Set echo mode. Args: mode: echo mode to use Raises: InvalidParamError: invalid echo mode \"\"\" if mode not in ECHO_MODE : raise InvalidParamError ( mode , ECHO_MODE ) self . setEchoMode ( ECHO_MODE [ mode ])","title":"set_echo_mode()"},{"location":"api/widgets.html#prettyqt.widgets.lineedit.LineEdit.set_read_only","text":"Set text to read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/lineedit.py def set_read_only ( self , value : bool = True ): \"\"\"Set text to read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.listview","text":"","title":"listview"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView","text":"","title":"ListView"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_flow","text":"Return flow mode. Returns: Type Description Literal['left_to_right', 'top_to_bottom'] flow mode Source code in prettyqt/widgets/listview.py def get_flow ( self ) -> FlowStr : \"\"\"Return flow mode. Returns: flow mode \"\"\" return FLOW . inverse [ self . flow ()]","title":"get_flow()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_layout_mode","text":"Return layout mode. Returns: Type Description Literal['single_pass', 'batched'] layout mode Source code in prettyqt/widgets/listview.py def get_layout_mode ( self ) -> LayoutModeStr : \"\"\"Return layout mode. Returns: layout mode \"\"\" return LAYOUT_MODE . inverse [ self . layoutMode ()]","title":"get_layout_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_movement","text":"Return movement mode. Returns: Type Description Literal['static', 'free', 'snap'] movement mode Source code in prettyqt/widgets/listview.py def get_movement ( self ) -> MovementStr : \"\"\"Return movement mode. Returns: movement mode \"\"\" return MOVEMENT . inverse [ self . movement ()]","title":"get_movement()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_resize_mode","text":"Return resize mode. Returns: Type Description Literal['fixed', 'adjust'] resize mode Source code in prettyqt/widgets/listview.py def get_resize_mode ( self ) -> ResizeModeStr : \"\"\"Return resize mode. Returns: resize mode \"\"\" return RESIZE_MODE . inverse [ self . resizeMode ()]","title":"get_resize_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.get_view_mode","text":"Return view mode. Returns: Type Description Literal['list', 'icon'] view mode Source code in prettyqt/widgets/listview.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_flow","text":"Set flow mode. Parameters: Name Type Description Default mode Literal['left_to_right', 'top_to_bottom'] flow mode to use required Exceptions: Type Description InvalidParamError invalid flow mode Source code in prettyqt/widgets/listview.py def set_flow ( self , mode : FlowStr ): \"\"\"Set flow mode. Args: mode: flow mode to use Raises: InvalidParamError: invalid flow mode \"\"\" if mode not in FLOW : raise InvalidParamError ( mode , FLOW ) self . setFlow ( FLOW [ mode ])","title":"set_flow()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_layout_mode","text":"Set layout mode. Parameters: Name Type Description Default mode Literal['single_pass', 'batched'] layout mode to use required Exceptions: Type Description InvalidParamError invalid layout mode Source code in prettyqt/widgets/listview.py def set_layout_mode ( self , mode : LayoutModeStr ): \"\"\"Set layout mode. Args: mode: layout mode to use Raises: InvalidParamError: invalid layout mode \"\"\" if mode not in LAYOUT_MODE : raise InvalidParamError ( mode , LAYOUT_MODE ) self . setLayoutMode ( LAYOUT_MODE [ mode ])","title":"set_layout_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_movement","text":"Set movement mode. Parameters: Name Type Description Default mode Literal['static', 'free', 'snap'] movement mode to use required Exceptions: Type Description InvalidParamError invalid movement mode Source code in prettyqt/widgets/listview.py def set_movement ( self , mode : MovementStr ): \"\"\"Set movement mode. Args: mode: movement mode to use Raises: InvalidParamError: invalid movement mode \"\"\" if mode not in MOVEMENT : raise InvalidParamError ( mode , MOVEMENT ) self . setMovement ( MOVEMENT [ mode ])","title":"set_movement()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_resize_mode","text":"Set resize mode. Parameters: Name Type Description Default mode Literal['fixed', 'adjust'] resize mode to use required Exceptions: Type Description InvalidParamError invalid resize mode Source code in prettyqt/widgets/listview.py def set_resize_mode ( self , mode : ResizeModeStr ): \"\"\"Set resize mode. Args: mode: resize mode to use Raises: InvalidParamError: invalid resize mode \"\"\" if mode not in RESIZE_MODE : raise InvalidParamError ( mode , RESIZE_MODE ) self . setResizeMode ( RESIZE_MODE [ mode ])","title":"set_resize_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listview.ListView.set_view_mode","text":"Set view mode. Parameters: Name Type Description Default mode Literal['list', 'icon'] view mode to use required Exceptions: Type Description InvalidParamError invalid view mode Source code in prettyqt/widgets/listview.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode. Args: mode: view mode to use Raises: InvalidParamError: invalid view mode \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem","text":"","title":"listwidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem","text":"","title":"ListWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.get_checkstate","text":"Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/listwidgetitem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/listwidgetitem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.listwidgetitem.ListWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/listwidgetitem.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow","text":"","title":"mainwindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow","text":"Class for our mainWindow. Includes all docks, a centralwidget and a toolbar","title":"MainWindow"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar","text":"Adds a toolbar to the mainmenu at specified area. Parameters: Name Type Description Default toolbar QToolBar toolbar to use required position Literal['top', 'bottom', 'left', 'right', 'all', 'none'] position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar ( self , toolbar : QtWidgets . QToolBar , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar to the mainmenu at specified area. Args: toolbar: toolbar to use position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBar ( constants . TOOLBAR_AREA [ position ], toolbar )","title":"add_toolbar()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.add_toolbar_break","text":"Adds a toolbar break to the given area behind the last item. Parameters: Name Type Description Default position Literal['top', 'bottom', 'left', 'right', 'all', 'none'] position of the toolbar 'top' Exceptions: Type Description InvalidParamError position does not exist Source code in prettyqt/widgets/mainwindow.py def add_toolbar_break ( self , position : constants . ToolbarAreaStr = \"top\" ): \"\"\"Adds a toolbar break to the given area behind the last item. Args: position: position of the toolbar Raises: InvalidParamError: position does not exist \"\"\" if position not in constants . TOOLBAR_AREA : raise InvalidParamError ( position , constants . TOOLBAR_AREA ) self . addToolBarBreak ( constants . TOOLBAR_AREA [ position ])","title":"add_toolbar_break()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.createPopupMenu","text":"createPopupMenu(self) -> QMenu Source code in prettyqt/widgets/mainwindow.py def createPopupMenu ( self ) -> widgets . Menu : # qactions = self.createPopupMenu() menu = widgets . Menu ( parent = self ) for i , item in enumerate ( self . get_docks ()): action = widgets . Action ( text = item . windowTitle (), parent = self ) action . set_checkable ( True ) action . set_checked ( item . isVisible ()) action . set_shortcut ( f \"Ctrl+Shift+ { i } \" ) action . set_shortcut_context ( \"application\" ) action . toggled . connect ( item . setVisible ) menu . add ( action ) menu . add_separator () for tb in self . get_toolbars (): action = widgets . Action ( text = tb . windowTitle (), parent = self ) action . set_checkable ( True ) action . toggled . connect ( tb . setVisible ) action . set_checked ( tb . isVisible ()) menu . add ( action ) return menu","title":"createPopupMenu()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.save_window_state","text":"Save current window state as QSetting. Parameters: Name Type Description Default recursive bool Description False Source code in prettyqt/widgets/mainwindow.py def save_window_state ( self , recursive : bool = False ): \"\"\"Save current window state as QSetting. Args: recursive (bool, optional): Description \"\"\" settings = core . Settings () name = self . get_id () logger . debug ( f \"Saving window state for { self . windowTitle () !r} ...\" ) settings [ f \" { name } .geometry\" ] = self . saveGeometry () settings [ f \" { name } .state\" ] = self . saveState () if recursive : for window in self . find_children ( MainWindow , recursive = True ): if window . get_id (): window . save_window_state ()","title":"save_window_state()"},{"location":"api/widgets.html#prettyqt.widgets.mainwindow.MainWindow.toggle_fullscreen","text":"Toggle between fullscreen and regular size. Source code in prettyqt/widgets/mainwindow.py def toggle_fullscreen ( self ): \"\"\"Toggle between fullscreen and regular size.\"\"\" if self . isFullScreen (): self . showNormal () else : self . showFullScreen ()","title":"toggle_fullscreen()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea","text":"","title":"mdiarea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea","text":"","title":"MdiArea"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_tab_position","text":"Return current tab position. Returns: Type Description Literal['north', 'south', 'west', 'east'] tab position Source code in prettyqt/widgets/mdiarea.py def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return current tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()]","title":"get_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_view_mode","text":"Return current view mode. Returns: Type Description Literal['default', 'tabbed'] view mode Source code in prettyqt/widgets/mdiarea.py def get_view_mode ( self ) -> ViewModeStr : \"\"\"Return current view mode. Returns: view mode \"\"\" return VIEW_MODE . inverse [ self . viewMode ()]","title":"get_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.get_window_order","text":"Return current window order. Returns: Type Description Literal['creation', 'stacking', 'activation_history'] view mode Source code in prettyqt/widgets/mdiarea.py def get_window_order ( self ) -> WindowOrderStr : \"\"\"Return current window order. Returns: view mode \"\"\" return WINDOW_ORDER . inverse [ self . activationOrder ()]","title":"get_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_tab_position","text":"Set tab position for the MDI area. Parameters: Name Type Description Default position Literal['north', 'south', 'west', 'east'] tabs position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/mdiarea.py def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the MDI area. Args: position: tabs position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ])","title":"set_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_view_mode","text":"Set view mode for the MDI area. Parameters: Name Type Description Default mode Literal['default', 'tabbed'] view mode to use required Exceptions: Type Description InvalidParamError view mode does not exist Source code in prettyqt/widgets/mdiarea.py def set_view_mode ( self , mode : ViewModeStr ): \"\"\"Set view mode for the MDI area. Args: mode: view mode to use Raises: InvalidParamError: view mode does not exist \"\"\" if mode not in VIEW_MODE : raise InvalidParamError ( mode , VIEW_MODE ) self . setViewMode ( VIEW_MODE [ mode ])","title":"set_view_mode()"},{"location":"api/widgets.html#prettyqt.widgets.mdiarea.MdiArea.set_window_order","text":"Set the window order behaviour for the MDI area. Parameters: Name Type Description Default mode Literal['creation', 'stacking', 'activation_history'] window order behaviour to use required Exceptions: Type Description InvalidParamError window order mode not existing. Source code in prettyqt/widgets/mdiarea.py def set_window_order ( self , mode : WindowOrderStr ): \"\"\"Set the window order behaviour for the MDI area. Args: mode: window order behaviour to use Raises: InvalidParamError: window order mode not existing. \"\"\" if mode not in WINDOW_ORDER : raise InvalidParamError ( mode , WINDOW_ORDER ) self . setActivationOrder ( WINDOW_ORDER [ mode ])","title":"set_window_order()"},{"location":"api/widgets.html#prettyqt.widgets.menu","text":"","title":"menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu","text":"","title":"Menu"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_action","text":"Add an action to the menu. Parameters: Name Type Description Default label Union[str, prettyqt.widgets.action.Action] Label for button required callback Callable gets called when action is triggered None icon Optional[Any] icon for button None checkable bool as checkbox button False checked bool if checkable, turn on by default False shortcut Optional[str] Shortcut for action None status_tip Optional[str] Status tip to be shown in status bar None Returns: Type Description Action Action added to menu Source code in prettyqt/widgets/menu.py def add_action ( self , label : Union [ str , widgets . Action ], callback : Callable = None , icon : Optional [ Any ] = None , checkable : bool = False , checked : bool = False , shortcut : Optional [ str ] = None , status_tip : Optional [ str ] = None , ) -> widgets . Action : \"\"\"Add an action to the menu. Args: label: Label for button callback: gets called when action is triggered icon: icon for button checkable: as checkbox button checked: if checkable, turn on by default shortcut: Shortcut for action status_tip: Status tip to be shown in status bar Returns: Action added to menu \"\"\" if isinstance ( label , str ): action = widgets . Action ( text = label , parent = self ) if callback : action . triggered . connect ( callback ) action . set_icon ( icon ) action . set_shortcut ( shortcut ) if checkable : action . setCheckable ( True ) action . setChecked ( checked ) if status_tip is not None : action . setStatusTip ( status_tip ) else : action = label action . setParent ( self ) self . addAction ( action ) return action","title":"add_action()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.add_separator","text":"Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None Returns: Type Description WidgetAction Separator action Source code in prettyqt/widgets/menu.py def add_separator ( self , text : Optional [ str ] = None ) -> widgets . WidgetAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator Returns: Separator action \"\"\" separator = widgets . WidgetAction ( parent = self ) if text is None : separator . setSeparator ( True ) else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) separator . setDefaultWidget ( label ) separator . setEnabled ( False ) self . add ( separator ) return separator","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.menu.Menu.set_icon","text":"Set the icon for the menu. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/menu.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the menu. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox","text":"","title":"messagebox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox","text":"","title":"MessageBox"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.add_button","text":"Add a default button. Parameters: Name Type Description Default button Literal['none', 'cancel', 'ok', 'save', 'open', 'close', 'discard', 'apply', 'reset', 'restore_defaults', 'help', 'save_all', 'yes', 'yes_to_all', 'no', 'no_to_all', 'abort', 'retry', 'ignore'] button to add required Returns: Type Description QPushButton created button Exceptions: Type Description InvalidParamError Button type not available Source code in prettyqt/widgets/messagebox.py def add_button ( self , button : ButtonStr ) -> QtWidgets . QPushButton : \"\"\"Add a default button. Args: button: button to add Returns: created button Raises: InvalidParamError: Button type not available \"\"\" if button not in BUTTONS : raise InvalidParamError ( button , BUTTONS ) return self . addButton ( BUTTONS [ button ])","title":"add_button()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.get_text_format","text":"Return current text format. Returns: Type Description Literal['rich', 'plain', 'auto'] text format Source code in prettyqt/widgets/messagebox.py def get_text_format ( self ) -> TextFormatStr : \"\"\"Return current text format. Returns: text format \"\"\" return TEXT_FORMAT . inverse [ self . textFormat ()]","title":"get_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_icon","text":"Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path, NoneType, Literal['none', 'information', 'warning', 'critical', 'question']] icon to use required Source code in prettyqt/widgets/messagebox.py def set_icon ( self , icon : Union [ iconprovider . IconType , IconStr ]): if icon in ICONS : self . setIcon ( ICONS [ icon ]) else : ico = iconprovider . get_icon ( icon ) self . setIconPixmap ( ico . get_pixmap ( size = 64 ))","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.messagebox.MessageBox.set_text_format","text":"Set the text format. Parameters: Name Type Description Default text_format Literal['rich', 'plain', 'auto'] text format to use required Exceptions: Type Description InvalidParamError text format does not exist Source code in prettyqt/widgets/messagebox.py def set_text_format ( self , text_format : TextFormatStr ): \"\"\"Set the text format. Args: text_format: text format to use Raises: InvalidParamError: text format does not exist \"\"\" if text_format not in TEXT_FORMAT : raise InvalidParamError ( text_format , TEXT_FORMAT ) self . setTextFormat ( TEXT_FORMAT [ text_format ])","title":"set_text_format()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit","text":"","title":"plaintextedit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit","text":"","title":"PlainTextEdit"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.get_line_wrap_mode","text":"Get the current wrap mode. Returns: Type Description Literal['none', 'widget_width'] Wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()]","title":"get_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.get_word_wrap_mode","text":"Get the current word wrap mode. Returns: Type Description Literal['none', 'word', 'anywhere', 'boundary_or_anywhere'] Word wrap mode Source code in prettyqt/widgets/plaintextedit.py def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()]","title":"get_word_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_line_wrap_mode","text":"Set line wrap mode. Parameters: Name Type Description Default mode Literal['none', 'widget_width'] line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ])","title":"set_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_read_only","text":"Make the PlainTextEdit read-only. Parameters: Name Type Description Default value bool True, for read-only, otherwise False True Source code in prettyqt/widgets/plaintextedit.py def set_read_only ( self , value : bool = True ): \"\"\"Make the PlainTextEdit read-only. Args: value: True, for read-only, otherwise False \"\"\" self . setReadOnly ( value )","title":"set_read_only()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.set_word_wrap_mode","text":"Set word wrap mode. Parameters: Name Type Description Default mode Literal['none', 'word', 'anywhere', 'boundary_or_anywhere'] word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/plaintextedit.py def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ])","title":"set_word_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.plaintextedit.PlainTextEdit.wheelEvent","text":"Handle wheel event for zooming. Source code in prettyqt/widgets/plaintextedit.py def wheelEvent ( self , event ): \"\"\"Handle wheel event for zooming.\"\"\" if not self . _allow_wheel_zoom : return None if event . modifiers () & constants . CTRL_MOD : self . zoomIn () if event . angleDelta () . y () > 0 else self . zoomOut () else : super () . wheelEvent ( event )","title":"wheelEvent()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar","text":"","title":"progressbar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar","text":"Progress dialog. wrapper for QtWidgets.QProgressBar","title":"ProgressBar"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_alignment","text":"Return current alignment. Returns: Type Description Literal['top', 'left', 'right', 'bottom', 'top_left', 'top_right', 'bottom_left', 'bottom_right'] alignment Source code in prettyqt/widgets/progressbar.py def get_alignment ( self ) -> constants . AlignmentStr : \"\"\"Return current alignment. Returns: alignment \"\"\" return constants . ALIGNMENTS . inverse [ self . alignment ()]","title":"get_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_orientation","text":"Return current orientation. Returns: Type Description Literal['horizontal', 'vertical'] orientation Source code in prettyqt/widgets/progressbar.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.get_text_direction","text":"Return current text direction. Returns: Type Description Literal['top_to_bottom', 'bottom_to_top'] Text direction Source code in prettyqt/widgets/progressbar.py def get_text_direction ( self ) -> TextDirectionStr : \"\"\"Return current text direction. Returns: Text direction \"\"\" return TEXT_DIRECTIONS . inverse [ self . textDirection ()]","title":"get_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_alignment","text":"Set the alignment of the layout. Parameters: Name Type Description Default alignment Literal['top', 'left', 'right', 'bottom', 'top_left', 'top_right', 'bottom_left', 'bottom_right'] alignment for the layout required Exceptions: Type Description InvalidParamError alignment does not exist Source code in prettyqt/widgets/progressbar.py def set_alignment ( self , alignment : constants . AlignmentStr ): \"\"\"Set the alignment of the layout. Args: alignment: alignment for the layout Raises: InvalidParamError: alignment does not exist \"\"\" if alignment not in constants . ALIGNMENTS : raise InvalidParamError ( alignment , constants . ALIGNMENTS ) self . setAlignment ( constants . ALIGNMENTS [ alignment ])","title":"set_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_orientation","text":"Set the orientation of the progress bar. Parameters: Name Type Description Default orientation Literal['horizontal', 'vertical'] orientation for the progress bar required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/progressbar.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the progress bar. Args: orientation: orientation for the progress bar Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.progressbar.ProgressBar.set_text_direction","text":"Set the text direction of the layout. Parameters: Name Type Description Default text_direction Literal['top_to_bottom', 'bottom_to_top'] text direction for the layout required Exceptions: Type Description InvalidParamError text direction does not exist Source code in prettyqt/widgets/progressbar.py def set_text_direction ( self , text_direction : TextDirectionStr ): \"\"\"Set the text direction of the layout. Args: text_direction: text direction for the layout Raises: InvalidParamError: text direction does not exist \"\"\" if text_direction not in TEXT_DIRECTIONS : raise InvalidParamError ( text_direction , TEXT_DIRECTIONS ) self . setTextDirection ( TEXT_DIRECTIONS [ text_direction ])","title":"set_text_direction()"},{"location":"api/widgets.html#prettyqt.widgets.progressdialog","text":"","title":"progressdialog"},{"location":"api/widgets.html#prettyqt.widgets.progressdialog.ProgressDialog","text":"Progress dialog. Wrapper for QtWidgets.QProgressDialog","title":"ProgressDialog"},{"location":"api/widgets.html#prettyqt.widgets.scroller","text":"","title":"scroller"},{"location":"api/widgets.html#prettyqt.widgets.scroller.Scroller","text":"","title":"Scroller"},{"location":"api/widgets.html#prettyqt.widgets.scroller.Scroller.get_state","text":"Return current state. Returns: Type Description Literal['inactive', 'pressed', 'dragging', 'scrolling'] state Source code in prettyqt/widgets/scroller.py def get_state ( self ) -> StateStr : \"\"\"Return current state. Returns: state \"\"\" return STATE . inverse [ self . state ()]","title":"get_state()"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties","text":"","title":"scrollerproperties"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties","text":"","title":"ScrollerProperties"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.get_scroll_metric","text":"Return scroll metric. Parameters: Name Type Description Default metric Literal['mouse_press_event_delay', 'drag_start_distance', 'drag_velocity_smoothing_factor', 'axis_lock_threshold', 'scrolling_curve', 'deceleration_factor', 'minimum_velocity', 'maximum_velocity', 'maximum_click_through_velocity', 'accelerating_flick_maximum_time', 'accelerating_flick_speedup_factor', 'snap_position_ratio', 'snap_time', 'overshoot_drag_resistance_factor', 'overshoot_drag_distance_factor', 'overshoot_scroll_distance_factor', 'overshoot_scroll_time', 'horizontal_overshoot_policy', 'vertical_overshoot_policy', 'frame_rate', 'scroll_metric_count'] Scroll metric to get required Exceptions: Type Description InvalidParamError metric does not exist Returns: Type Description Any state Source code in prettyqt/widgets/scrollerproperties.py def get_scroll_metric ( self , metric : ScrollmetricStr ) -> Any : \"\"\"Return scroll metric. Args: metric: Scroll metric to get Raises: InvalidParamError: metric does not exist Returns: state \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) return self . scrollMetric ( SCROLL_METRIC [ metric ])","title":"get_scroll_metric()"},{"location":"api/widgets.html#prettyqt.widgets.scrollerproperties.ScrollerProperties.set_scroll_metric","text":"Set scroll metric. Parameters: Name Type Description Default metric Literal['mouse_press_event_delay', 'drag_start_distance', 'drag_velocity_smoothing_factor', 'axis_lock_threshold', 'scrolling_curve', 'deceleration_factor', 'minimum_velocity', 'maximum_velocity', 'maximum_click_through_velocity', 'accelerating_flick_maximum_time', 'accelerating_flick_speedup_factor', 'snap_position_ratio', 'snap_time', 'overshoot_drag_resistance_factor', 'overshoot_drag_distance_factor', 'overshoot_scroll_distance_factor', 'overshoot_scroll_time', 'horizontal_overshoot_policy', 'vertical_overshoot_policy', 'frame_rate', 'scroll_metric_count'] Scroll metric to set required value Any Value to set required Exceptions: Type Description InvalidParamError metric does not exist Source code in prettyqt/widgets/scrollerproperties.py def set_scroll_metric ( self , metric : ScrollmetricStr , value : Any ): \"\"\"Set scroll metric. Args: metric: Scroll metric to set value: Value to set Raises: InvalidParamError: metric does not exist \"\"\" if metric not in SCROLL_METRIC : raise InvalidParamError ( metric , SCROLL_METRIC ) self . setScrollMetric ( SCROLL_METRIC [ metric ], value )","title":"set_scroll_metric()"},{"location":"api/widgets.html#prettyqt.widgets.shortcut","text":"","title":"shortcut"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut","text":"","title":"Shortcut"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.get_context","text":"Return shortcut context. Returns: Type Description Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context Source code in prettyqt/widgets/shortcut.py def get_context ( self ) -> constants . ContextStr : \"\"\"Return shortcut context. Returns: shortcut context \"\"\" return constants . CONTEXT . inverse [ self . context ()]","title":"get_context()"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.get_key","text":"Return the shortcut's key sequence. Returns: Type Description KeySequence Key sequence Source code in prettyqt/widgets/shortcut.py def get_key ( self ) -> gui . KeySequence : \"\"\"Return the shortcut's key sequence. Returns: Key sequence \"\"\" return gui . KeySequence ( self . key ())","title":"get_key()"},{"location":"api/widgets.html#prettyqt.widgets.shortcut.Shortcut.set_context","text":"Set shortcut context. Parameters: Name Type Description Default context Literal['widget', 'widget_with_children', 'window', 'application'] shortcut context required Exceptions: Type Description InvalidParamError shortcut context does not exist Source code in prettyqt/widgets/shortcut.py def set_context ( self , context : constants . ContextStr ): \"\"\"Set shortcut context. Args: context: shortcut context Raises: InvalidParamError: shortcut context does not exist \"\"\" if context not in constants . CONTEXT : raise InvalidParamError ( context , constants . CONTEXT ) self . setContext ( constants . CONTEXT [ context ])","title":"set_context()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy","text":"","title":"sizepolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy","text":"","title":"SizePolicy"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_control_type","text":"Return control type. Returns: Type Description Literal['default', 'buttonbox', 'checkbox', 'combobox', 'frame', 'groupbox', 'label', 'line', 'lineedit', 'pushbutton', 'radiobutton', 'slider', 'spinbox', 'tabwidget', 'toolbutton'] control type Source code in prettyqt/widgets/sizepolicy.py def get_control_type ( self ) -> ControlTypeStr : \"\"\"Return control type. Returns: control type \"\"\" return CONTROL_TYPE . inverse [ self . controlType ()]","title":"get_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_horizontal_policy","text":"Return size policy. Returns: Type Description Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] horizontal size policy Source code in prettyqt/widgets/sizepolicy.py def get_horizontal_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: horizontal size policy \"\"\" return SIZE_POLICY . inverse [ self . horizontalPolicy ()]","title":"get_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.get_vertical_policy","text":"Return size policy. Returns: Type Description Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] vertical size policy Source code in prettyqt/widgets/sizepolicy.py def get_vertical_policy ( self ) -> SizePolicyStr : \"\"\"Return size policy. Returns: vertical size policy \"\"\" return SIZE_POLICY . inverse [ self . verticalPolicy ()]","title":"get_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_control_type","text":"Set the control type. Parameters: Name Type Description Default typ Literal['default', 'buttonbox', 'checkbox', 'combobox', 'frame', 'groupbox', 'label', 'line', 'lineedit', 'pushbutton', 'radiobutton', 'slider', 'spinbox', 'tabwidget', 'toolbutton'] control type to set required Exceptions: Type Description InvalidParamError control type does not exist Source code in prettyqt/widgets/sizepolicy.py def set_control_type ( self , typ : ControlTypeStr ) -> None : \"\"\"Set the control type. Args: typ: control type to set Raises: InvalidParamError: control type does not exist \"\"\" if typ not in CONTROL_TYPE : raise InvalidParamError ( typ , CONTROL_TYPE ) self . setControlType ( CONTROL_TYPE [ typ ])","title":"set_control_type()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_horizontal_policy","text":"Set the horizontal policy. Parameters: Name Type Description Default policy Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_horizontal_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setHorizontalPolicy ( SIZE_POLICY [ policy ])","title":"set_horizontal_policy()"},{"location":"api/widgets.html#prettyqt.widgets.sizepolicy.SizePolicy.set_vertical_policy","text":"Set the horizontal policy. Parameters: Name Type Description Default policy Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored'] policy to set required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/sizepolicy.py def set_vertical_policy ( self , policy : SizePolicyStr ) -> None : \"\"\"Set the horizontal policy. Args: policy: policy to set Raises: InvalidParamError: policy does not exist \"\"\" self . setVerticalPolicy ( SIZE_POLICY [ policy ])","title":"set_vertical_policy()"},{"location":"api/widgets.html#prettyqt.widgets.slider","text":"","title":"slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider","text":"","title":"Slider"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.get_tick_position","text":"Return tick position. Returns: Type Description Literal['none', 'both_sides', 'above', 'below'] tick position Source code in prettyqt/widgets/slider.py def get_tick_position ( self ) -> TickPositionStr : \"\"\"Return tick position. Returns: tick position \"\"\" return TICK_POSITION . inverse [ self . tickPosition ()]","title":"get_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.slider.Slider.set_tick_position","text":"Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Parameters: Name Type Description Default position Literal['none', 'both_sides', 'above', 'below', 'left', 'right'] position for the ticks required Source code in prettyqt/widgets/slider.py def set_tick_position ( self , position : TickPositionAllStr ): \"\"\"Set the tick position for the slider. For vertical orientation, \"above\" equals to \"left\" and \"below\" to \"right\". Args: position: position for the ticks \"\"\" if position == \"left\" : position = \"above\" elif position == \"right\" : position = \"below\" elif position not in TICK_POSITION : raise InvalidParamError ( position , TICK_POSITION ) self . setTickPosition ( TICK_POSITION [ position ])","title":"set_tick_position()"},{"location":"api/widgets.html#prettyqt.widgets.splitter","text":"","title":"splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter","text":"","title":"Splitter"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.get_orientation","text":"Return current orientation. Returns: Type Description Literal['horizontal', 'vertical'] orientation Source code in prettyqt/widgets/splitter.py def get_orientation ( self ) -> constants . OrientationStr : \"\"\"Return current orientation. Returns: orientation \"\"\" return constants . ORIENTATION . inverse [ self . orientation ()]","title":"get_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.splitter.Splitter.set_orientation","text":"Set the orientation of the splitter. Parameters: Name Type Description Default orientation Literal['horizontal', 'vertical'] orientation for the splitter required Exceptions: Type Description InvalidParamError orientation does not exist Source code in prettyqt/widgets/splitter.py def set_orientation ( self , orientation : constants . OrientationStr ): \"\"\"Set the orientation of the splitter. Args: orientation: orientation for the splitter Raises: InvalidParamError: orientation does not exist \"\"\" if orientation not in constants . ORIENTATION : raise InvalidParamError ( orientation , constants . ORIENTATION ) self . setOrientation ( constants . ORIENTATION [ orientation ])","title":"set_orientation()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider","text":"","title":"styleoptionslider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider","text":"","title":"StyleOptionSlider"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_horizontal","text":"Check if silder is horizontal. Returns: Type Description bool True if horizontal, else False Source code in prettyqt/widgets/styleoptionslider.py def is_horizontal ( self ) -> bool : \"\"\"Check if silder is horizontal. Returns: True if horizontal, else False \"\"\" return self . orientation == QtCore . Qt . Horizontal","title":"is_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.is_vertical","text":"Check if silder is vertical. Returns: Type Description bool True if vertical, else False Source code in prettyqt/widgets/styleoptionslider.py def is_vertical ( self ) -> bool : \"\"\"Check if silder is vertical. Returns: True if vertical, else False \"\"\" return self . orientation == QtCore . Qt . Vertical","title":"is_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_horizontal","text":"Set slider orientation to horizontal. Source code in prettyqt/widgets/styleoptionslider.py def set_horizontal ( self ) -> None : \"\"\"Set slider orientation to horizontal.\"\"\" self . orientation = QtCore . Qt . Horizontal","title":"set_horizontal()"},{"location":"api/widgets.html#prettyqt.widgets.styleoptionslider.StyleOptionSlider.set_vertical","text":"Set slider orientation to vertical. Source code in prettyqt/widgets/styleoptionslider.py def set_vertical ( self ) -> None : \"\"\"Set slider orientation to vertical.\"\"\" self . orientation = QtCore . Qt . Vertical","title":"set_vertical()"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture","text":"","title":"swipegesture"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGesture","text":"","title":"SwipeGesture"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGesture.get_horizontal_direction","text":"Return horizontal direction of the gesture. Returns: Type Description Literal['none', 'left', 'right'] horizontal direction Source code in prettyqt/widgets/swipegesture.py def get_horizontal_direction ( self ) -> HorizontalDirectionStr : \"\"\"Return horizontal direction of the gesture. Returns: horizontal direction \"\"\" return SWIPE_DIRECTION . inverse [ self . horizontalDirection ()]","title":"get_horizontal_direction()"},{"location":"api/widgets.html#prettyqt.widgets.swipegesture.SwipeGesture.get_vertical_direction","text":"Return vertical direction of the gesture. Returns: Type Description Literal['none', 'up', 'down'] vertical direction Source code in prettyqt/widgets/swipegesture.py def get_vertical_direction ( self ) -> VerticalDirectionStr : \"\"\"Return vertical direction of the gesture. Returns: vertical direction \"\"\" return SWIPE_DIRECTION . inverse [ self . verticalDirection ()]","title":"get_vertical_direction()"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon","text":"","title":"systemtrayicon"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon","text":"","title":"SystemTrayIcon"},{"location":"api/widgets.html#prettyqt.widgets.systemtrayicon.SystemTrayIcon.set_icon","text":"Set the system tray icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/systemtrayicon.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the system tray icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar","text":"","title":"tabbar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar","text":"","title":"TabBar"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_elide_mode","text":"Return elide mode. Returns: Type Description Literal['left', 'right', 'middle', 'none'] elide mode Source code in prettyqt/widgets/tabbar.py def get_elide_mode ( self ) -> constants . ElideModeStr : \"\"\"Return elide mode. Returns: elide mode \"\"\" return constants . ELIDE_MODE . inverse [ self . elideMode ()]","title":"get_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.get_remove_behaviour","text":"Return remove behaviour. Returns: Type Description Literal['left_tab', 'right_tab', 'previous_tab'] remove behaviour Source code in prettyqt/widgets/tabbar.py def get_remove_behaviour ( self ) -> RemoveBehaviourStr : \"\"\"Return remove behaviour. Returns: remove behaviour \"\"\" return REMOVE_BEHAVIOUR . inverse [ self . selectionBehaviorOnRemove ()]","title":"get_remove_behaviour()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.mouseDoubleClickEvent","text":"mouseDoubleClickEvent(self, QMouseEvent) Source code in prettyqt/widgets/tabbar.py def mouseDoubleClickEvent ( self , event ): event . accept () tab = self . tabAt ( event . pos ()) pos = QtGui . QCursor . pos () self . on_detach . emit ( tab , pos )","title":"mouseDoubleClickEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_elide_mode","text":"Set elide mode. Parameters: Name Type Description Default mode Literal['left', 'right', 'middle', 'none'] elide mode to use required Exceptions: Type Description InvalidParamError invalid elide mode Source code in prettyqt/widgets/tabbar.py def set_elide_mode ( self , mode : constants . ElideModeStr ) -> None : \"\"\"Set elide mode. Args: mode: elide mode to use Raises: InvalidParamError: invalid elide mode \"\"\" if mode not in constants . ELIDE_MODE : raise InvalidParamError ( mode , constants . ELIDE_MODE ) self . setElideMode ( constants . ELIDE_MODE [ mode ])","title":"set_elide_mode()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_icon_size","text":"Set size of the icons. Source code in prettyqt/widgets/tabbar.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.tabbar.TabBar.set_selection_behavior_on_remove","text":"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Parameters: Name Type Description Default mode Literal['left_tab', 'right_tab', 'previous_tab'] new remove behaviour required Source code in prettyqt/widgets/tabbar.py def set_selection_behavior_on_remove ( self , mode : RemoveBehaviourStr ) -> None : \"\"\"Set the remove hehaviour. What tab should be set as current when removeTab is called if the removed tab is also the current tab. Args: mode: new remove behaviour \"\"\" if mode not in REMOVE_BEHAVIOUR : raise InvalidParamError ( mode , REMOVE_BEHAVIOUR ) self . setSelectionBehaviorOnRemove ( REMOVE_BEHAVIOUR [ mode ])","title":"set_selection_behavior_on_remove()"},{"location":"api/widgets.html#prettyqt.widgets.tableview","text":"","title":"tableview"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableView","text":"","title":"TableView"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableView.get_grid_style","text":"Return grid style. Returns: Type Description Literal['none', 'solid', 'dash', 'dot', 'dash_dot', 'dash_dot_dot', 'custom_dash'] grid style Source code in prettyqt/widgets/tableview.py def get_grid_style ( self ) -> constants . PenStyleStr : \"\"\"Return grid style. Returns: grid style \"\"\" return constants . PEN_STYLE . inverse [ self . gridStyle ()]","title":"get_grid_style()"},{"location":"api/widgets.html#prettyqt.widgets.tableview.TableView.set_grid_style","text":"Set grid style. Parameters: Name Type Description Default style Literal['none', 'solid', 'dash', 'dot', 'dash_dot', 'dash_dot_dot', 'custom_dash'] grid style to use required Exceptions: Type Description InvalidParamError invalid grid style Source code in prettyqt/widgets/tableview.py def set_grid_style ( self , style : constants . PenStyleStr ): \"\"\"Set grid style. Args: style: grid style to use Raises: InvalidParamError: invalid grid style \"\"\" if style not in constants . PEN_STYLE : raise InvalidParamError ( style , constants . PEN_STYLE ) self . setGridStyle ( constants . PEN_STYLE [ style ])","title":"set_grid_style()"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem","text":"","title":"tablewidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem","text":"","title":"TableWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.get_checkstate","text":"Return checkstate. Returns: Type Description Literal['unchecked', 'partial', 'checked'] checkstate Source code in prettyqt/widgets/tablewidgetitem.py def get_checkstate ( self ) -> constants . StateStr : \"\"\"Return checkstate. Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ()]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state Literal['unchecked', 'partial', 'checked'] checkstate to use required Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/tablewidgetitem.py def set_checkstate ( self , state : constants . StateStr ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( constants . STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/tablewidgetitem.py def set_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the action. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.tablewidgetitem.TableWidgetItem.set_text_alignment","text":"Set text alignment of the checkbox. Parameters: Name Type Description Default alignment text alignment to use required Exceptions: Type Description InvalidParamError invalid text alignment Source code in prettyqt/widgets/tablewidgetitem.py def set_text_alignment ( self , horizontal : Optional [ constants . HorizontalAlignmentStr ] = None , vertical : Optional [ constants . VerticalAlignmentStr ] = None , ): \"\"\"Set text alignment of the checkbox. Args: alignment: text alignment to use Raises: InvalidParamError: invalid text alignment \"\"\" if horizontal is None and vertical is not None : flag = constants . V_ALIGNMENT [ vertical ] elif vertical is None and horizontal is not None : flag = constants . H_ALIGNMENT [ horizontal ] elif vertical is not None and horizontal is not None : flag = constants . V_ALIGNMENT [ vertical ] | constants . H_ALIGNMENT [ horizontal ] else : return self . setTextAlignment ( flag )","title":"set_text_alignment()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget","text":"","title":"tabwidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab","text":"Window containing a detached tab. When a tab is detached, the contents are placed into this QMainWindow. The tab can be re-attached by closing the dialog Attributes: Name Type Description on_close signal, emitted when window is closed (widget, title, icon)","title":"DetachedTab"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.DetachedTab.closeEvent","text":"closeEvent(self, QCloseEvent) Source code in prettyqt/widgets/tabwidget.py def closeEvent ( self , event ): self . on_close . emit ( self . widget , self . get_id (), self . windowIcon ())","title":"closeEvent()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget","text":"Widget for managing the tabs section.","title":"TabWidget"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.attach_tab","text":"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Parameters: Name Type Description Default widget Union[PyQt5.QtWidgets.QWidget, PyQt5.QtWidgets.QLayout] the content widget from the DetachedTab window required name str the name of the detached tab required icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] the window icon for the detached tab None insert_at Optional[int] insert the re-attached tab at the given index None Source code in prettyqt/widgets/tabwidget.py def attach_tab ( self , widget : Union [ QtWidgets . QWidget , QtWidgets . QLayout ], name : str , icon : iconprovider . IconType = None , insert_at : Optional [ int ] = None , ): \"\"\"Re-attach tab. Re-attach the tab by removing the content from the DetachedTab window, closing it, and placing the content back into the DetachableTabWidget. Args: widget (Union[QtWidgets.QWidget, QtWidgets.QLayout]): the content widget from the DetachedTab window name (str): the name of the detached tab icon (iconprovider.IconType, optional): the window icon for the detached tab insert_at (Optional[int], optional): insert the re-attached tab at the given index \"\"\" widget . setParent ( self ) # Remove the reference del self . detached_tabs [ name ] # Determine if the given image and the main window icon are the same. # If they are, then do not add the icon to the tab self . add_tab ( widget , name , icon = icon , position = insert_at , show = True )","title":"attach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.close_detached_tabs","text":"Close all tabs that are currently detached. Source code in prettyqt/widgets/tabwidget.py def close_detached_tabs ( self ): \"\"\"Close all tabs that are currently detached.\"\"\" tabs = list ( self . detached_tabs . values ()) for tab in tabs : tab . close ()","title":"close_detached_tabs()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.detach_tab","text":"Detach tab by removing its contents and placing them in a DetachedTab window. Parameters: Name Type Description Default index int index location of the tab to be detached required point Union[PyQt5.QtCore.QPoint, Tuple[int, int]] screen pos for creating the new DetachedTab window required Returns: Type Description None Description Source code in prettyqt/widgets/tabwidget.py @core . Slot ( int , QtCore . QPoint ) def detach_tab ( self , index : int , point : Union [ QtCore . QPoint , Tuple [ int , int ]]): \"\"\"Detach tab by removing its contents and placing them in a DetachedTab window. Args: index (int): index location of the tab to be detached point (QtCore.QPoint): screen pos for creating the new DetachedTab window Returns: None: Description \"\"\" # Get the tab content if isinstance ( point , tuple ): point = QtCore . QPoint ( * point ) name = self . tabText ( index ) icon = self . tabIcon ( index ) if icon . isNull (): icon = self . window () . windowIcon () widget = self . widget ( index ) try : widget_rect = widget . frameGeometry () except AttributeError : return # Create a new detached tab window detached_tab = DetachedTab ( name , widget ) detached_tab . set_modality ( \"none\" ) detached_tab . set_icon ( icon ) detached_tab . setGeometry ( widget_rect ) detached_tab . on_close . connect ( self . attach_tab ) detached_tab . move ( point ) detached_tab . show () # Create a reference to maintain access to the detached tab self . detached_tabs [ name ] = detached_tab","title":"detach_tab()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_position","text":"Return tab position. Returns: Type Description Literal['north', 'south', 'west', 'east'] tab position Source code in prettyqt/widgets/tabwidget.py def get_tab_position ( self ) -> TabPositionStr : \"\"\"Return tab position. Returns: tab position \"\"\" return TAB_POSITION . inverse [ self . tabPosition ()]","title":"get_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.get_tab_shape","text":"Return tab shape. Returns: Type Description Literal['rounded', 'triangular'] tab shape Source code in prettyqt/widgets/tabwidget.py def get_tab_shape ( self ) -> TabShapeStr : \"\"\"Return tab shape. Returns: tab shape \"\"\" return TAB_SHAPES . inverse [ self . tabShape ()]","title":"get_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.open_widget","text":"Create a tab containing delivered widget. Source code in prettyqt/widgets/tabwidget.py @core . Slot ( QtWidgets . QWidget , str ) def open_widget ( self , widget : QtWidgets . QWidget , title : str = \"Unnamed\" ): \"\"\"Create a tab containing delivered widget.\"\"\" self . add_tab ( widget , title , icon = \"mdi.widgets\" , show = True )","title":"open_widget()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_icon_size","text":"Set size of the icons. Source code in prettyqt/widgets/tabwidget.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_position","text":"Set tab position for the tabwidget. Parameters: Name Type Description Default position Literal['north', 'south', 'west', 'east'] tab position to use required Exceptions: Type Description InvalidParamError tab position does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_position ( self , position : TabPositionStr ): \"\"\"Set tab position for the tabwidget. Args: position: tab position to use Raises: InvalidParamError: tab position does not exist \"\"\" if position not in TAB_POSITION : raise InvalidParamError ( position , TAB_POSITION ) self . setTabPosition ( TAB_POSITION [ position ])","title":"set_tab_position()"},{"location":"api/widgets.html#prettyqt.widgets.tabwidget.TabWidget.set_tab_shape","text":"Set tab shape for the tabwidget. Parameters: Name Type Description Default shape Literal['rounded', 'triangular'] tab shape to use required Exceptions: Type Description InvalidParamError tab shape does not exist Source code in prettyqt/widgets/tabwidget.py def set_tab_shape ( self , shape : TabShapeStr ): \"\"\"Set tab shape for the tabwidget. Args: shape: tab shape to use Raises: InvalidParamError: tab shape does not exist \"\"\" if shape not in TAB_SHAPES : raise InvalidParamError ( shape , TAB_SHAPES ) self . setTabShape ( TAB_SHAPES [ shape ])","title":"set_tab_shape()"},{"location":"api/widgets.html#prettyqt.widgets.textedit","text":"","title":"textedit"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit","text":"","title":"TextEdit"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.get_auto_formatting","text":"Get the current auto formatting mode. Returns: Type Description AutoFormattingStr Auto formatting mode Source code in prettyqt/widgets/textedit.py def get_auto_formatting ( self ) -> AutoFormattingStr : \"\"\"Get the current auto formatting mode. Returns: Auto formatting mode \"\"\" return AUTO_FORMATTING . inverse [ self . autoFormatting ()]","title":"get_auto_formatting()"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.get_line_wrap_mode","text":"Get the current wrap mode. Returns: Type Description LineWrapModeStr Wrap mode Source code in prettyqt/widgets/textedit.py def get_line_wrap_mode ( self ) -> LineWrapModeStr : \"\"\"Get the current wrap mode. Returns: Wrap mode \"\"\" return LINE_WRAP_MODE . inverse [ self . lineWrapMode ()]","title":"get_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.get_word_wrap_mode","text":"Get the current word wrap mode. Returns: Type Description gui.textoption.WordWrapModeStr Word wrap mode Source code in prettyqt/widgets/textedit.py def get_word_wrap_mode ( self ) -> gui . textoption . WordWrapModeStr : \"\"\"Get the current word wrap mode. Returns: Word wrap mode \"\"\" return gui . textoption . WORD_WRAP_MODE . inverse [ self . wordWrapMode ()]","title":"get_word_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.set_auto_formatting","text":"Set auto formatting mode. Parameters: Name Type Description Default mode AutoFormattingStr auto formatting mode to use required Exceptions: Type Description InvalidParamError auto formatting mode does not exist Source code in prettyqt/widgets/textedit.py def set_auto_formatting ( self , mode : AutoFormattingStr ): \"\"\"Set auto formatting mode. Args: mode: auto formatting mode to use Raises: InvalidParamError: auto formatting mode does not exist \"\"\" if mode not in AUTO_FORMATTING : raise InvalidParamError ( mode , AUTO_FORMATTING ) self . setAutoFormatting ( AUTO_FORMATTING [ mode ])","title":"set_auto_formatting()"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.set_line_wrap_mode","text":"Set line wrap mode. Parameters: Name Type Description Default mode LineWrapModeStr line wrap mode to use required Exceptions: Type Description InvalidParamError line wrap mode does not exist Source code in prettyqt/widgets/textedit.py def set_line_wrap_mode ( self , mode : LineWrapModeStr ): \"\"\"Set line wrap mode. Args: mode: line wrap mode to use Raises: InvalidParamError: line wrap mode does not exist \"\"\" if mode not in LINE_WRAP_MODE : raise InvalidParamError ( mode , LINE_WRAP_MODE ) self . setLineWrapMode ( LINE_WRAP_MODE [ mode ])","title":"set_line_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.textedit.TextEdit.set_word_wrap_mode","text":"Set word wrap mode. Parameters: Name Type Description Default mode gui.textoption.WordWrapModeStr word wrap mode to use required Exceptions: Type Description InvalidParamError wrap mode does not exist Source code in prettyqt/widgets/textedit.py def set_word_wrap_mode ( self , mode : gui . textoption . WordWrapModeStr ): \"\"\"Set word wrap mode. Args: mode: word wrap mode to use Raises: InvalidParamError: wrap mode does not exist \"\"\" if mode not in gui . textoption . WORD_WRAP_MODE : raise InvalidParamError ( mode , gui . textoption . WORD_WRAP_MODE ) self . setWordWrapMode ( gui . textoption . WORD_WRAP_MODE [ mode ])","title":"set_word_wrap_mode()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar","text":"","title":"toolbar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar","text":"","title":"ToolBar"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.add_separator","text":"Adds a separator showing an optional label. Parameters: Name Type Description Default text Optional[str] Text to show on separator None before QAction insert separator before specific action None Returns: Type Description QAction Separator action Source code in prettyqt/widgets/toolbar.py def add_separator ( self , text : Optional [ str ] = None , before : QtWidgets . QAction = None ) -> QtWidgets . QAction : \"\"\"Adds a separator showing an optional label. Args: text: Text to show on separator before: insert separator before specific action Returns: Separator action \"\"\" if text is None : if before : return self . insertSeparator ( before ) else : return self . addSeparator () else : label = widgets . Label ( text ) label . setMinimumWidth ( self . minimumWidth ()) with label . edit_stylesheet () as ss : ss . background . setValue ( \"lightgrey\" ) label . set_alignment ( horizontal = \"center\" ) if before : return self . insertWidget ( before , label ) else : return self . addWidget ( label )","title":"add_separator()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.get_style","text":"Return current style. Returns: Type Description Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] style Source code in prettyqt/widgets/toolbar.py def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return current style. Returns: style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()]","title":"get_style()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.is_area_allowed","text":"Check if toolbar is allowed at specified area. Parameters: Name Type Description Default area Literal['top', 'bottom', 'left', 'right', 'all', 'none'] area of the toolbar required Exceptions: Type Description InvalidParamError area does not exist Source code in prettyqt/widgets/toolbar.py def is_area_allowed ( self , area : constants . ToolbarAreaStr ) -> bool : \"\"\"Check if toolbar is allowed at specified area. Args: area: area of the toolbar Raises: InvalidParamError: area does not exist \"\"\" if area not in constants . TOOLBAR_AREA : raise InvalidParamError ( area , constants . TOOLBAR_AREA ) return self . isAreaAllowed ( constants . TOOLBAR_AREA [ area ])","title":"is_area_allowed()"},{"location":"api/widgets.html#prettyqt.widgets.toolbar.ToolBar.set_icon_size","text":"Set size of the icons. Source code in prettyqt/widgets/toolbar.py def set_icon_size ( self , size : Union [ int , Tuple [ int , int ], QtCore . QSize ]): \"\"\"Set size of the icons.\"\"\" if isinstance ( size , int ): size = core . Size ( size , size ) elif isinstance ( size , tuple ): size = core . Size ( * size ) self . setIconSize ( size )","title":"set_icon_size()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton","text":"","title":"toolbutton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton","text":"","title":"ToolButton"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_arrow_type","text":"Return arrow type. Returns: Type Description Literal['none', 'up', 'down', 'left', 'right'] arrow type Source code in prettyqt/widgets/toolbutton.py def get_arrow_type ( self ) -> constants . ArrowTypeStr : \"\"\"Return arrow type. Returns: arrow type \"\"\" return constants . ARROW_TYPE . inverse [ self . arrowType ()]","title":"get_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_popup_mode","text":"Return popup mode. Returns: Type Description Literal['delayed', 'menu_button', 'instant'] popup mode Source code in prettyqt/widgets/toolbutton.py def get_popup_mode ( self ) -> PopupModeStr : \"\"\"Return popup mode. Returns: popup mode \"\"\" return POPUP_MODE . inverse [ self . popupMode ()]","title":"get_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.get_style","text":"Return toolbutton style. Returns: Type Description Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] toolbutton style Source code in prettyqt/widgets/toolbutton.py def get_style ( self ) -> constants . ToolButtonStyleStr : \"\"\"Return toolbutton style. Returns: toolbutton style \"\"\" return constants . TOOLBUTTON_STYLE . inverse [ self . toolButtonStyle ()]","title":"get_style()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_arrow_type","text":"Set the arrow type of the toolbutton. Parameters: Name Type Description Default mode Literal['none', 'up', 'down', 'left', 'right'] arrow type to use required Exceptions: Type Description InvalidParamError invalid arrow type Source code in prettyqt/widgets/toolbutton.py def set_arrow_type ( self , mode : constants . ArrowTypeStr ): \"\"\"Set the arrow type of the toolbutton. Args: mode: arrow type to use Raises: InvalidParamError: invalid arrow type \"\"\" if mode not in constants . ARROW_TYPE : raise InvalidParamError ( mode , constants . ARROW_TYPE ) self . setArrowType ( constants . ARROW_TYPE [ mode ])","title":"set_arrow_type()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_popup_mode","text":"Set the popup mode of the toolbutton. Parameters: Name Type Description Default mode Literal['delayed', 'menu_button', 'instant'] popup mode to use required Exceptions: Type Description InvalidParamError invalid popup mode Source code in prettyqt/widgets/toolbutton.py def set_popup_mode ( self , mode : PopupModeStr ): \"\"\"Set the popup mode of the toolbutton. Args: mode: popup mode to use Raises: InvalidParamError: invalid popup mode \"\"\" if mode not in POPUP_MODE : raise InvalidParamError ( mode , POPUP_MODE ) self . setPopupMode ( POPUP_MODE [ mode ])","title":"set_popup_mode()"},{"location":"api/widgets.html#prettyqt.widgets.toolbutton.ToolButton.set_style","text":"Set the toolbutton style. Parameters: Name Type Description Default style Literal['icon', 'text', 'text_beside_icon', 'text_below_icon'] style to use required Exceptions: Type Description InvalidParamError invalid style Source code in prettyqt/widgets/toolbutton.py def set_style ( self , style : constants . ToolButtonStyleStr ): \"\"\"Set the toolbutton style. Args: style: style to use Raises: InvalidParamError: invalid style \"\"\" if style not in constants . TOOLBUTTON_STYLE : raise InvalidParamError ( style , constants . TOOLBUTTON_STYLE ) self . setToolButtonStyle ( constants . TOOLBUTTON_STYLE [ style ])","title":"set_style()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem","text":"","title":"treewidgetitem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem","text":"","title":"TreeWidgetItem"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_checkstate","text":"Return checkstate. Parameters: Name Type Description Default column int column 0 Returns: Type Description constants.StateStr checkstate Source code in prettyqt/widgets/treewidgetitem.py def get_checkstate ( self , column : int = 0 ) -> constants . StateStr : \"\"\"Return checkstate. Args: column: column Returns: checkstate \"\"\" return constants . STATE . inverse [ self . checkState ( column )]","title":"get_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.get_child_indicator_policy","text":"Return current child indicator policy. Returns: Type Description ChildIndicatorPolicyStr child indicator policy Source code in prettyqt/widgets/treewidgetitem.py def get_child_indicator_policy ( self ) -> ChildIndicatorPolicyStr : \"\"\"Return current child indicator policy. Returns: child indicator policy \"\"\" return CHILD_INDICATOR_POLICY . inverse [ self . childIndicatorPolicy ()]","title":"get_child_indicator_policy()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_checkstate","text":"Set checkstate of the checkbox. Parameters: Name Type Description Default state constants.StateStr checkstate to use required column int column 0 Exceptions: Type Description InvalidParamError invalid checkstate Source code in prettyqt/widgets/treewidgetitem.py def set_checkstate ( self , state : constants . StateStr , column : int = 0 ): \"\"\"Set checkstate of the checkbox. Args: state: checkstate to use column: column Raises: InvalidParamError: invalid checkstate \"\"\" if state not in constants . STATE : raise InvalidParamError ( state , constants . STATE ) self . setCheckState ( column , constants . STATE [ state ])","title":"set_checkstate()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_child_indicator_policy","text":"Set the child indicator policy. Parameters: Name Type Description Default policy ChildIndicatorPolicyStr child indicator policy required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/treewidgetitem.py def set_child_indicator_policy ( self , policy : ChildIndicatorPolicyStr ): \"\"\"Set the child indicator policy. Args: policy: child indicator policy Raises: InvalidParamError: policy does not exist \"\"\" if policy not in CHILD_INDICATOR_POLICY : raise InvalidParamError ( policy , CHILD_INDICATOR_POLICY ) self . setChildIndicatorPolicy ( CHILD_INDICATOR_POLICY [ policy ])","title":"set_child_indicator_policy()"},{"location":"api/widgets.html#prettyqt.widgets.treewidgetitem.TreeWidgetItem.set_icon","text":"Set the icon for the action. Parameters: Name Type Description Default icon iconprovider.IconType icon to use required column int column 0 Source code in prettyqt/widgets/treewidgetitem.py def set_icon ( self , icon : iconprovider . IconType , column : int = 0 ): \"\"\"Set the icon for the action. Args: icon: icon to use column: column \"\"\" icon = iconprovider . get_icon ( icon ) self . setIcon ( column , icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.undoview","text":"","title":"undoview"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView","text":"","title":"UndoView"},{"location":"api/widgets.html#prettyqt.widgets.undoview.UndoView.set_clean_icon","text":"Set the icon for the clean button. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/undoview.py def set_clean_icon ( self , icon : iconprovider . IconType ): \"\"\"Set the icon for the clean button. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon ) self . setCleanIcon ( icon )","title":"set_clean_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget","text":"","title":"widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget","text":"","title":"Widget"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_contextmenu_policy","text":"Return current contextmenu policy. Returns: Type Description Literal['none', 'prevent', 'default', 'actions', 'custom'] contextmenu policy Source code in prettyqt/widgets/widget.py def get_contextmenu_policy ( self ) -> constants . ContextPolicyStr : \"\"\"Return current contextmenu policy. Returns: contextmenu policy \"\"\" return constants . CONTEXT_POLICY . inverse [ self . contextMenuPolicy ()]","title":"get_contextmenu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_focus_policy","text":"Return waay the widget accepts keyboard focus. Returns: Type Description Literal['tab', 'click', 'strong', 'wheel', 'none'] str: Focus policy Source code in prettyqt/widgets/widget.py def get_focus_policy ( self ) -> constants . FocusPolicyStr : \"\"\"Return waay the widget accepts keyboard focus. Returns: str: Focus policy \"\"\" return constants . FOCUS_POLICY . inverse [ self . focusPolicy ()]","title":"get_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_modality","text":"Get the current modality modes as a string. Returns: Type Description Literal['window', 'application', 'none'] modality mode Source code in prettyqt/widgets/widget.py def get_modality ( self ) -> constants . ModalityStr : \"\"\"Get the current modality modes as a string. Returns: modality mode \"\"\" return constants . MODALITY . inverse [ self . windowModality ()]","title":"get_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.get_window_state","text":"Return current window state. Returns: Type Description Literal['none', 'minimized', 'maximized', 'fullscreen', 'active'] window state Source code in prettyqt/widgets/widget.py def get_window_state ( self ) -> constants . WindowStateStr : \"\"\"Return current window state. Returns: window state \"\"\" return constants . WINDOW_STATES . inverse [ self . windowState ()]","title":"get_window_state()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.resize","text":"resize(self, QSize) resize(self, int, int) Source code in prettyqt/widgets/widget.py def resize ( self , * size ) -> None : if isinstance ( size [ 0 ], tuple ): super () . resize ( * size [ 0 ]) else : super () . resize ( * size )","title":"resize()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_contextmenu_policy","text":"Set contextmenu policy for given item view. Parameters: Name Type Description Default policy Literal['none', 'prevent', 'default', 'actions', 'custom'] contextmenu policy to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_contextmenu_policy ( self , policy : constants . ContextPolicyStr ) -> None : \"\"\"Set contextmenu policy for given item view. Args: policy: contextmenu policy to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . CONTEXT_POLICY : raise InvalidParamError ( policy , constants . CONTEXT_POLICY ) self . setContextMenuPolicy ( constants . CONTEXT_POLICY [ policy ])","title":"set_contextmenu_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_focus_policy","text":"Set the way the widget accepts keyboard focus. Parameters: Name Type Description Default policy Literal['tab', 'click', 'strong', 'wheel', 'none'] Focus policy required Exceptions: Type Description InvalidParamError Description Source code in prettyqt/widgets/widget.py def set_focus_policy ( self , policy : constants . FocusPolicyStr ) -> None : \"\"\"Set the way the widget accepts keyboard focus. Args: policy (str): Focus policy Raises: InvalidParamError: Description \"\"\" if policy not in constants . FOCUS_POLICY : raise InvalidParamError ( policy , constants . FOCUS_POLICY ) self . setFocusPolicy ( constants . FOCUS_POLICY [ policy ])","title":"set_focus_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_icon","text":"Set the window icon. Parameters: Name Type Description Default icon Union[PyQt5.QtGui.QIcon, str, pathlib.Path] icon to use required Source code in prettyqt/widgets/widget.py def set_icon ( self , icon : iconprovider . IconType ) -> None : \"\"\"Set the window icon. Args: icon: icon to use \"\"\" icon = iconprovider . get_icon ( icon , color = colors . WINDOW_ICON_COLOR ) self . setWindowIcon ( icon )","title":"set_icon()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_modality","text":"Set modality for the dialog. Parameters: Name Type Description Default modality Literal['window', 'application', 'none'] modality for the main window required Exceptions: Type Description InvalidParamError modality type does not exist Source code in prettyqt/widgets/widget.py def set_modality ( self , modality : constants . ModalityStr ) -> None : \"\"\"Set modality for the dialog. Args: modality: modality for the main window Raises: InvalidParamError: modality type does not exist \"\"\" if modality not in constants . MODALITY : raise InvalidParamError ( modality , constants . MODALITY ) self . setWindowModality ( constants . MODALITY [ modality ])","title":"set_modality()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_size_policy","text":"Set the sizes policy. Parameters: Name Type Description Default horizontal Optional[Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored']] horizontal size policy None vertical Optional[Literal['fixed', 'minimum', 'maximum', 'preferred', 'expanding', 'minimum_expanding', 'ignored']] vertical size policy None Source code in prettyqt/widgets/widget.py def set_size_policy ( self , horizontal : Optional [ widgets . sizepolicy . SizePolicyStr ] = None , vertical : Optional [ widgets . sizepolicy . SizePolicyStr ] = None , ) -> None : \"\"\"Set the sizes policy. Args: horizontal: horizontal size policy vertical: vertical size policy \"\"\" sp = self . get_size_policy () if horizontal is not None : sp . set_horizontal_policy ( horizontal ) if vertical is not None : sp . set_vertical_policy ( vertical ) self . setSizePolicy ( sp )","title":"set_size_policy()"},{"location":"api/widgets.html#prettyqt.widgets.widget.Widget.set_window_state","text":"Set window state for given item view. Parameters: Name Type Description Default policy Literal['none', 'minimized', 'maximized', 'fullscreen', 'active'] window state to use required Exceptions: Type Description InvalidParamError policy does not exist Source code in prettyqt/widgets/widget.py def set_window_state ( self , policy : constants . WindowStateStr ) -> None : \"\"\"Set window state for given item view. Args: policy: window state to use Raises: InvalidParamError: policy does not exist \"\"\" if policy not in constants . WINDOW_STATES : raise InvalidParamError ( policy , constants . WINDOW_STATES ) self . setWindowState ( constants . WINDOW_STATES [ policy ])","title":"set_window_state()"},{"location":"api/widgets.html#prettyqt.widgets.wizard","text":"","title":"wizard"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard","text":"","title":"Wizard"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_button_text","text":"Return text for given button type. Parameters: Name Type Description Default button_type WizardButtonStr button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizard.py def get_button_text ( self , button_type : WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) return self . buttonText ( WIZARD_BUTTON [ button_type ])","title":"get_button_text()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_option","text":"Return the value assigned to option. Parameters: Name Type Description Default option WizardOptionStr option to get required Returns: Type Description bool option Source code in prettyqt/widgets/wizard.py def get_option ( self , option : WizardOptionStr ) -> bool : \"\"\"Return the value assigned to option. Args: option: option to get Returns: option \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) return self . testOption ( WIZARD_OPTIONS [ option ])","title":"get_option()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_subtitle_format","text":"Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str subtitle format Source code in prettyqt/widgets/wizard.py def get_subtitle_format ( self ) -> str : \"\"\"Return current subtitle format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: subtitle format \"\"\" return TEXT_FORMATS . inverse [ self . subTitleFormat ()]","title":"get_subtitle_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_title_format","text":"Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: Type Description str title format Source code in prettyqt/widgets/wizard.py def get_title_format ( self ) -> str : \"\"\"Return current title format. Possible values: \"rich\", \"plain\", \"auto\", \"markdown\" Returns: title format \"\"\" return TEXT_FORMATS . inverse [ self . titleFormat ()]","title":"get_title_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.get_wizard_style","text":"Return current wizard style. Returns: Type Description WizardStyleStr Wizard style Source code in prettyqt/widgets/wizard.py def get_wizard_style ( self ) -> WizardStyleStr : \"\"\"Return current wizard style. Returns: Wizard style \"\"\" return WIZARD_STYLE . inverse [ self . wizardStyle ()]","title":"get_wizard_style()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_button_text","text":"Set text for given button type. Parameters: Name Type Description Default button_type WizardButtonStr button to get text from required value str text to set required Source code in prettyqt/widgets/wizard.py def set_button_text ( self , button_type : WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in WIZARD_BUTTON : raise InvalidParamError ( button_type , WIZARD_BUTTON ) self . setButtonText ( WIZARD_BUTTON [ button_type ], value )","title":"set_button_text()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_option","text":"Set option to given value. Parameters: Name Type Description Default option WizardOptionStr option to use required value bool value to set required Exceptions: Type Description InvalidParamError option does not exist Source code in prettyqt/widgets/wizard.py def set_option ( self , option : WizardOptionStr , value : bool ): \"\"\"Set option to given value. Args: option: option to use value: value to set Raises: InvalidParamError: option does not exist \"\"\" if option not in WIZARD_OPTIONS : raise InvalidParamError ( option , WIZARD_OPTIONS ) self . setOption ( WIZARD_OPTIONS [ option ], value )","title":"set_option()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_subtitle_format","text":"Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt str subtitle format to use required Exceptions: Type Description InvalidParamError subtitle format does not exist Source code in prettyqt/widgets/wizard.py def set_subtitle_format ( self , fmt : str ): \"\"\"Set the subtitle format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: subtitle format to use Raises: InvalidParamError: subtitle format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setSubTitleFormat ( TEXT_FORMATS [ fmt ])","title":"set_subtitle_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_title_format","text":"Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Parameters: Name Type Description Default fmt str title format to use required Exceptions: Type Description InvalidParamError title format does not exist Source code in prettyqt/widgets/wizard.py def set_title_format ( self , fmt : str ): \"\"\"Set the title format. Allowed values are \"rich\", \"plain\", \"auto\", \"markdown\" Args: fmt: title format to use Raises: InvalidParamError: title format does not exist \"\"\" if fmt not in TEXT_FORMATS : raise InvalidParamError ( fmt , TEXT_FORMATS ) self . setTitleFormat ( TEXT_FORMATS [ fmt ])","title":"set_title_format()"},{"location":"api/widgets.html#prettyqt.widgets.wizard.Wizard.set_wizard_style","text":"Set the wizard style. Parameters: Name Type Description Default style WizardStyleStr wizard style required Exceptions: Type Description InvalidParamError wizard style does not exist Source code in prettyqt/widgets/wizard.py def set_wizard_style ( self , style : WizardStyleStr ): \"\"\"Set the wizard style. Args: style: wizard style Raises: InvalidParamError: wizard style does not exist \"\"\" if style not in WIZARD_STYLE : raise InvalidParamError ( style , WIZARD_STYLE ) self . setWizardStyle ( WIZARD_STYLE [ style ])","title":"set_wizard_style()"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage","text":"","title":"wizardpage"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPage","text":"","title":"WizardPage"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPage.get_button_text","text":"Return text for given button type. Parameters: Name Type Description Default button_type Literal['back', 'next', 'commit', 'finish', 'cancel', 'help', 'custom_1', 'custom_2', 'custom_3'] button to get text from required Returns: Type Description str Button text Source code in prettyqt/widgets/wizardpage.py def get_button_text ( self , button_type : widgets . wizard . WizardButtonStr ) -> str : \"\"\"Return text for given button type. Args: button_type: button to get text from Returns: Button text \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) return self . buttonText ( widgets . wizard . WIZARD_BUTTON [ button_type ])","title":"get_button_text()"},{"location":"api/widgets.html#prettyqt.widgets.wizardpage.WizardPage.set_button_text","text":"Set text for given button type. Parameters: Name Type Description Default button_type Literal['back', 'next', 'commit', 'finish', 'cancel', 'help', 'custom_1', 'custom_2', 'custom_3'] button to get text from required value str text to set required Source code in prettyqt/widgets/wizardpage.py def set_button_text ( self , button_type : widgets . wizard . WizardButtonStr , value : str ): \"\"\"Set text for given button type. Args: button_type: button to get text from value: text to set \"\"\" if button_type not in widgets . wizard . WIZARD_BUTTON : raise InvalidParamError ( button_type , widgets . wizard . WIZARD_BUTTON ) self . setButtonText ( widgets . wizard . WIZARD_BUTTON [ button_type ], value )","title":"set_button_text()"}]}